[
  {
    "language": "Fortran",
    "code": "program shik_and_game\n  implicit none\n  integer :: n, i, j = 0\n  integer(8) :: e, t, x(100001) = 0_8, dp(0:100000) = 0_8, tmp = 0_8\n  read(*,*) n, e, t\n  read(*,*) x(1:n)\n  x(n+1) = e\n  do i = 1, n\n    do while (2_8*(x(i)-x(j+1)) > t)\n      tmp = min(tmp,dp(j)-2_8*x(j+1))\n      j = j+1\n    end do\n    dp(i) = dp(j)+t\n    if (j > 0) dp(i) = min(dp(i),2_8*x(i)+tmp)\n  end do\n  write(*,'(i0)') dp(n)+e\nend program shik_and_game"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 1e18;\n\t\tfor (auto itr = dp[i - 1].begin(); itr != dp[i - 1].end(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\tif (besuto > jikan) {\n\t\t\t\tbesuto = jikan;\n\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t\tdp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].begin(); itr != dp[N - 1].end(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+5&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)(i-j)*(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\tif (n > 2000)\n\t\tcout << \"HELLO\" << endl;\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tlong long int loss=0;\n\t\t\tif ((x[i] - x[j + 1]) * 2 < t)\n\t\t\t\tloss = t - (x[i] - x[j+1]) * 2;\n\t\t\t//cout << dp[j] + x[i] - x[j] + x[i] - x[j + 1] + loss + x[i] - x[j + 1] << endl;\n\t\t\tres = min(res, dp[j] + x[i] - x[j] + x[i] - x[j + 1] + loss + x[i] - x[j + 1]);\n\t\t}\n\t\tdp[i] = res;\n\t}\n\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nclass MQ {\n\tprivate:\n\tdeque<ll> q;\n\tpublic:\n\tvoid push(ll val) {\n\t\twhile(!(q.empty()) && q.back() > val) {\n\t\t\tq.pop_back();\n\t\t}\n\t\tq.push_back(val);\n\t}\n\tvoid pop(ll val) {\n\t\tif(!q.empty() && q.front() == val) {\n\t\t\tq.pop_front();\n\t\t}\n\t}\n\tll front() {\n\t\treturn q.front();\n\t}\n};\nvl w,dp;\nint main() {\n\tll n,ti,ed;\n\tcin >> n >> ed >> ti;\n\tfor(int i=0;i<n;i++) {\n\t\tll t;\n\t\tcin >> t;\n\t\tw.push_back(t);\n\t}\n\tw.push_back(ed);\n\tdp.assign(w.size(),1e18);\n\n\tdp.back() = 0;\n\tll rv = 1e18;\n\tMQ q;\n\tll pt = dp.size()-1;\n\tq.push(0);\n\tfor(int i=n-1;i>=0;i--) {\n\t\twhile(pt > i && (w[pt-1]-w[i])*2 > ti) {\n\t\t\tq.pop(dp[pt]);\n\t\t\trv = min(rv,dp[pt]+(w[pt-1]-w[i])*2);\n\t\t\tpt--;\n\t\t}\n\t\tdp[i] = min(q.front()+ti,rv);\n\t\tq.push(dp[i]);\n\t\tif(i > 0) {\n\t\t\trv += 2*(w[i]-w[i-1]);\n\t\t}\n\t}\n\t//what\n\tcout << dp[0]+ed << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\n\nll f[N][N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    if(n>N)return 0;\n    lol(i,n)cin>>d[i+1];\n    lol(i,N)lol(j,N)f[i][j]=1e17; f[0][0]=0;\n    lol(i,n+1){\n\tlol(j,i+1){\n\t    if(i==j){\n\t\tchmin(f[i+1][j],f[i][j]);\n\t    }\n\t    if(i!=j){\n\t\tchmin(f[i+1][j],f[i][j]+d[i+1]-d[i]);\n\t\tll dis=d[i]-d[j+1];\n\t\tchmin(f[i][i],f[i][j]+max(dis,t-dis));\n\t    }\n\t    //cout<<f[i][j]<<\" \";\n\t}//cout<<endl;\n    }\n    cout<<e+f[n+1][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=1e5+1e4;\nint n,E,T,l,r,Temp[N]; ll ans=1e16,a[N],f[N];\nint rd(){\n\tint s=0,ff=1;\n\tchar w=getchar();\n\twhile(!isdigit(w))\n\t\tff^=w=='-',w=getchar();\n\twhile(isdigit(w))\n\t\ts=s*10+w-'0',w=getchar();\n\treturn ff?s:-s;\n}\nint main(){\n\tn=rd(),E=rd(),T=rd(); l=1,r=0;\n\tfor(int i=1;i<=n;i++) a[i]=rd(),f[i]=1e16;\n\tTemp[++r]=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(2*a[i]-2*a[Temp[l]+1]>=T&&l<=r)\n\t\t\tans=min(ans,f[Temp[l]]-2*a[Temp[l]+1]-a[Temp[l]]),l++;\n\t\tf[i]=min(f[i],3LL*a[i]+ans);\n\t\tif(l<=r) f[i]=min(f[i],f[Temp[l]]+T+a[i]-a[Temp[l]]);\n\t\twhile(f[i]-a[i]<f[Temp[r]]-a[Temp[r]]&&l<=r) r--; Temp[++r]=i;\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define en end()\n#define bg begin()\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n#define y1 y1234567890\n#define um unordered_map                         \n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define sqrd(x) ((x) * 1.0 * (x))\n\nconst ll INF = (ll)1e18;\nconst int inf = (int)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst double pi = acos(-1.0);\nconst double eps = (double)1e-9;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nconst int N = 300500;\n\nint n;\nll x[N], dp[N], t, e, dp2[N];\n\nint main() {\n\tsrand(time(NULL));\n\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\n\tcout << setprecision(10) << fixed;\n\n\tcin >> n >> e >> t;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> x[i];\n\n\tdp[0] = 0;\n\t\n\tint cur = 1;\n\n\tdp2[0] = INF;\n\n\tfor(int i = 1; i <= n; ++i){\n\t\twhile(t - 2LL * (x[i] - x[cur]) < 0)\n\t\t\tcur++;\n\t\tdp2[i] = min(dp2[i - 1], dp[i - 1] - 2LL * x[i]);\n\t   \tdp[i] = min(dp2[cur - 1] + 2LL * x[i], dp[cur - 1] + t);\n\t}\n\n\tcout << dp[n] + e;\n\n\t//cerr << (clock() + 0.0) / 1000.0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define maxn 100010\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\nint a[maxn], q[maxn];\nlong long f[maxn];\nint main()\n{\n\tint n,m,T;\n        scanf(\"%d%d%d\",&n,&m,&T);\n\tfor (int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tint p = 1, h = 0, t = 0;\n        long long fp = 1234567891234567ll;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\twhile ((a[i] - a[p]) * 2 > T) cmin(fp, f[p - 1] - 2 * a[p]), ++p;\n\t\twhile (head < tail && (a[i] - a[q[head + 1]]) * 2 > T) ++head;\n\t\tf[i] = 1ll * i * T;\n\t\tcmin(f[i], fp + 2 * a[i]);\n\t\thead < tail ? cmin(f[i], f[q[head + 1] - 1] + T) : 0;\n\t\tcmin(f[i], f[i - 1] + T);\n\t\twhile (head < tail && f[q[tail] - 1] > f[i]) --tail;\n\t\tq[++tail] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 4;\n\nint main()\n{\n    int n, e, t;\n    cin >> n >> e >> t;\n\n    vector<int> x(n+2);\n    x[0] = 0;\n    x[n+1] = e;\n    for(int i=1; i<=n; ++i)\n        cin >> x[i];\n\n    vector<vector<long long> > dp(n+2, vector<long long>(n+2, INF));\n    dp[0][0] = 0;\n    for(int i=0; i<n+2; ++i){\n        for(int j=0; j<=i; ++j){\n            if(i < n + 1){\n                int cost = x[i+1] - x[i];\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + cost);\n            }\n\n            if(j < i){\n                int cost = max(t, (x[i] - x[j+1]) * 2);\n                dp[i][i] = min(dp[i][i], dp[i][j] + cost);\n            }\n        }\n    }\n    cout << dp[n+1][n] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n\n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n\n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e5+50;\nint n,E,T;\nint xc[N];\nLL f[N];\nint main() {\n\tn=rd(), E=rd(), T=rd();\n\tfor(int i=1;i<=n;i++) xc[i]=rd();\n\txc[n+1]=E;\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0; f[1]=xc[1];\n\tfor(int i=2,j=1;i<=n;i++) {\n\t\twhile(2*(xc[i]-xc[j])<T) ++j;\n\t\tf[i]=min(f[i],f[i-1]+T+xc[i]-xc[i-1]);\n\t\tf[i+1]=f[j]+2*(xc[i]-xc[j])+xc[i+1]-xc[j];\n\t} cout<<min(f[n+1],f[n]+T+xc[n+1]-xc[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t;\nll x[100005];\nll dp[100005];\nint main(){\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++){\n        dp[i] = 1000000000000000000;\n        while (pivot < i && 2*(x[i]-x[pivot+1]) < t) {\n            if (pivot >= 1) mn = min(mn,dp[pivot-1]-2*x[pivot]);\n            pivot++;\n        }\n        //printf(\"pivot for %d = %d\\n\",i,pivot);\n        dp[i] = min(2*x[i]+mn,dp[pivot-1]+t);\n        //printf(\"%lld first\\n\",dp[i]);\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int MAXN = 100000;\nint x[MAXN + 1];\nll dp[MAXN + 1];\n\nint main() {\n    //ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    int n, e, t;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    for(int i = 0; i <= MAXN; i++)\n        dp[i] = 1e18;\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        dp[i] = min(dp[i], dp[i - 1] + (x[i] - x[i - 1]) + t);\n        /*for(int j = 0; j < i; j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }*/\n        for(int j = 0; j <= 0; j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }\n        int l = 0, r = i, m;\n        while(r > l + 1) {\n            m = (l + r) / 2;\n            ll need = 2 * (x[i] - x[m]);\n            if(need < t)\n                r = m;\n            else\n                l = m;\n        }\n        for(int j = max(1, r - 10); j < min(i, r + 10); j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }\n    }\n    dp[n] += e - x[n];\n    cout << dp[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Grand Contest 007\n// D - Shik and Game\n\n#include <cstdio>\n#include <algorithm>\n#define MAX_N 100000\n#define MAX_ELEMENTS (1 << 17)\n#define INF 1e18\nusing namespace std;\n\n\ntypedef long long int ll;\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  int n;\n  T dat[2 * MAX_ELEMENTS - 1];\n  void init(int _n);\n  void update(int k, T a);\n  T query(int a, int b, int k, int l, int r);\n  T query(int a, int b);\n};\n\ntemplate <typename T>\nvoid SegmentTree<T>::init(int _n) {\n  n = 1;\n  while (n < _n) {\n    n <<= 1;\n  }\n  for (int i = 0; i < 2 * n - 1; i++) {\n    dat[i] = INF;\n  }\n  return;\n}\n\ntemplate <typename T>\nvoid SegmentTree<T>::update(int k, T a) {\n  k += n - 1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n  return;\n}\n\n// [a, b), [l, r)\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b, int k, int l, int r) {\n  if (r <= a || b <= l) {\n    return INF;\n  }\n  if (a <= l && r <= b) {\n    return dat[k];\n  }\n  return min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n}\n\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b) {\n  return query(a, b, 0, 0, n);\n}\n\n\nint N, E, T;\nSegmentTree<ll> st;\nint x[MAX_N + 1];\nll dp[MAX_N + 1];\n\nint main() {\n\n  ll dmin = INF;\n  int j;\n\n  scanf(\"%d%d%d\", &N, &E, &T);\n  x[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  dp[0] = 0;\n  st.init(N);\n  st.update(0, dp[0]);\n  j = 0;\n  for (int i = 1; i <= N; i++) {\n    for (; (x[i] - x[j + 1]) * 2 > T; j++) {\n      dmin = min(dmin, dp[j] - x[j + 1] * 2);\n    }\n    dp[i] = dmin + x[i] * 2;\n    dp[i] = min(dp[i], st.query(j, i) + T);\n    st.update(i, dp[i]);\n  }\n\n  printf(\"%lld\\n\", dp[N] + E);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] = x;\n    while(k>0) k = (k-1)/2, dat[k] = min(dat[k*2+1],dat[k*2+2]);\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return min(A, B);\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  if(n>2000) throw runtime_error(\"error\");\n  vll x(n+1, -10000000000);re(i, n) scanf(\"%lld\", &x[i+1]);\n\n  ll INF = 1000000000000000000;\n  vll dp(n+1, INF);\n  dp[0] = e;\n  segtree seg(n+1, INF);\n  seg.update(dp[0]-2*x[1], 0);\n\n  for(int now=1;now<=n;now++){\n    ll l = lower_bound(all(x), x[now]-t/2) - x.begin();\n\n    if(now!=1){\n      dp[now] = dp[max((ll)0, l-1)] + t;\n      dp[now] = min(dp[now], 2*x[now]+seg.query(0, l-1));\n    }else{\n      dp[now] = dp[0] + t;\n    }\n    if(now!=n) seg.update(dp[now]-2*x[now+1],now);\n  }\n\n  //std::cout << dp[1] << '\\n';\n  //std::cout << dp[2] << '\\n';\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n;\nll E, T;\nvll x;\n\nll dp[2001];\n\nint main(void){\n    cin >> n >> E >> T;\n    assert(n <= 2000);\n\n    rep(i, n + 1) dp[i] = inf;\n    dp[0] = 0LL;\n\n    x = vll(n);\n    for(auto& e : x) cin >> e;\n\n    rep(i, n){\n        rep(j, i + 1, n + 1){\n            ll dist = x[j - 1] - x[i];\n            ll diff = 2LL * dist + max(T - 2 * dist, 0LL);\n\n            chmin(dp[j], dp[i] + diff);\n        }\n    }\n\n    cout << E + dp[n] << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<4*maxn;i++){\n\t\tseg[i]={(long long)1e18,(int)1e9};\n\t\tseg2[i]={(long long)1e18,(int)1e9};\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\tif(2*(a[i]-a[0])<d){\n\t\t\tr=0;\n\t\t}\n\t\tif(2*(a[i]-a[i-1])>=d){\n\t\t\tl=i-1;\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nll N,E,T;\nll dp1 [100001];\nll dp2 [100001];\nconst ll INF = 1e17;\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&E,&T);\n\tvector<ll> X(N + 1);\n\tfor(int i = 1;i <= N;i++){\n\t\tscanf(\"%lld\",&X [i]);\n\t}\n\n\tfill_n(dp1,N + 1,INF);\n\tfill_n(dp2,N + 1,INF);\n\tdp1 [0] = 0;\n\n\tint j = 1;\n\tfor(int i = 1;i <= N;i++){\n\t\twhile(j < i && (X [i] - X [j]) * 2 > T) j++;\n\t\tprintf(\"%d %d\\n\",i,j);\n\t\tchmin(dp1 [i],dp1 [j - 1] + T);\n\t\tchmin(dp1 [i],dp2 [j - 1] + X [i] * 2);\n\t\tchmin(dp2 [i],min(dp2 [i - 1],dp1 [i - 1] - X [i] * 2));\n\t}\n\n\tprintf(\"%lld\\n\",dp1 [N] + E);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\n//pair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>=val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "//Δ\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5+15;\nconst LL inf = 1e18+N;\nint n,e,t,a[N];\nLL dp[N];\nint main()\n{\n\tint i,x;\n\tLL y,z;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(i=1;i<=n;i=i+1)\n\t\tscanf(\"%d\",a+i);\n\ta[0]=0,a[n+1]=e;\n\tdp[1]=0;\n\tx=1;\n\ty=inf;\n\tfor(i=1;i<=n;i=i+1){\n\t\twhile(2*(a[i]-a[x])>t){\n\t\t\ty=min(y,dp[x]-2*a[x]);\n\t\t\tx++;\n\t\t}\n\t\tdp[i+1]=min(dp[x]+t,y+2*a[i]);\n\t\t//cout<<i+1<<' '<<x<<' '<<dp[i+1]<<endl;\n\t}\n\tcout<<dp[n+1]+e<<endl;\n\treturn 0;\n}\n/*\n2 1000000000 1000000000\n1 999999999\n*/"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint dp[N], a[N], b[N], seg[4][N << 2], lazy[4][N << 2], sum[N];\n\nvoid shift(int id, int c) {\n\tseg[id][c << 1] += lazy[id][c];\n\tseg[id][c << 1 | 1] += lazy[id][c];\n\tlazy[id][c << 1] += lazy[id][c];\n\tlazy[id][c << 1 | 1] += lazy[id][c];\n\tlazy[id][c] = 0;\n}\n\nvoid upd(int id, int c, int b, int e, int l, int r, int x) {\n\tif(r <= b || e <= l)\n\t\treturn;\n\tif(l <= b && e <= r) {\n\t\tseg[id][c] += x;\n\t\tlazy[id][c] += x;\n\t\treturn;\n\t}\n\tint mid = (b + e) >> 1;\n\tshift(id, c);\n\tupd(id, c << 1, b, mid, l, r, x), upd(id, c << 1 | 1, mid, e, l, r, x);\n\tseg[id][c] = min(seg[id][c << 1], seg[id][c << 1 | 1]);\n}\n\nint get(int id, int c, int b, int e, int l, int r) {\n\tif(r <= b || e <= l)\n\t\treturn OO;\n\tif(l <= b && e <= r)\n\t\treturn seg[id][c];\n\tint mid = (b + e) >> 1;\n\tshift(id, c);\n\treturn min(get(id, c << 1, b, mid, l, r), get(id, c << 1 | 1, mid, e, l, r));\n}\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t, h = 0;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tupd(1, 1, 0, n + 1, 0, 1, -2 * a[1]);\n\tfor(int i = 1; i <= n; i++) {\n\t\tupd(1, 1, 0, n + 1, 0, i, 3 * (a[i] - a[i - 1]));\n\t\tupd(2, 1, 0, n + 1, 0, i, a[i] - a[i - 1]);\n\t\twhile(2 * (a[i] - a[h]) >= t)\n\t\t\th++;\n\t\tdp[i] = min(t + get(2, 1, 0, n + 1, h - 1, i), get(1, 1, 0, n + 1, 0, h - 1));\n\t\tupd(1, 1, 0, n + 1, i, i + 1, dp[i] - 2 * (a[i + 1] - a[i]));\n\t\tupd(2, 1, 0, n + 1, i, i + 1, dp[i]);\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e15;\nll n, T, E, x[MAXN], dp[MAXN];\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[i] = inf;\n\tdp[0] = 0;\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tdp[i] = min(max(dp[j] + x[i] - x[j] + x[i] - x[j + 1], dp[j] + x[j + 1] - x[j] + T) + x[i] - x[j + 1], dp[i]);\n\t\n\tcout << dp[n] + E - x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(int u, int l, int r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(int u, int l, int r, int x, int val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nint query(int u, int l, int r, int b, int e)\n{\n\tif (r == l)\n\t\treturn mod;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tint mid = (l + r) / 2, tmp = mod;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tsort(x, x + n);\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind ? dp[ind - 1] : 0));\n\t\tif (i)\n\t\t\tupdate(0, 0, n, i, dp[i - 1]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll t,e;\nll x[100005];\nll dp[100005];\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tif(n>=2001)return 0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i]=(ll)x[n]+n*t;\n\t}\n\tdp[0]=0;\n\tint now=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i>0){\n\t\t\twhile(now<i){\n\t\t\t\tll ela=x[i]-x[now+1];\n\t\t\t\tif(ela+x[i]-x[now+1]>=t){\n\t\t\t\t\tdp[i]=min(dp[i],dp[now]+(x[i]-x[now+1])*2LL);\n\t\t\t\t\tnow++;\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[now+1]);\n\t\t\t\t\tdp[i]=min(dp[i],dp[now]+(x[i]-x[now+1])*2LL+rest);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t\tif(i<n)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t\tif(i>=1 && j<i){\n\t\t\t\tll ela=dp[i][j]-dp[j+1][j];\n\t\t\t\t//printf(\"%lld\\n\",ela);\n\t\t\t\tif(ela+x[i]-x[j+1]>=t){\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL);\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[j+1]);\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL+rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ll long long\n#define inf 20021225\n#define N 100100\nusing namespace std;\nint read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n\treturn f*s;\n}\nll f[N],mn; int t,e,n,p[N];\nint main()\n{\n\tn=read(),e=read(),t=read();\n\tint l=0; mn=1e18;\n\tfor(int i=1;i<=n;i++)\tp[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(l<=i && 2*(p[i]-p[l+1])>t)\n\t\t\tmn=min(mn,f[l]-2*p[l+1]), l++;\n\t\tif(l<i)\tf[i]=f[l]+t;\n\t\tf[i]=min(f[i],mn+2*p[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=2e3+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nint p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n}\nll dp[N];\nvoid work()\n{\n\tFor(i,1,n)\n\t{\n\t\tdp[i]=dp[i-1]+T;\t\n\t\tFor(j,1,i-1)\n\t\t{\n\t\t\tcmin(dp[i],dp[j-1]+max(2*(p[i]-p[j]),T));\n\t\t}\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+1,0),dp(N+1,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    LazySegmentTree seg1(vector<ll>(N+1,0)),seg2(vector<ll>(N+1,0));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.add(0,1,dp[0]);\n    seg2.add(0,1,dp[0]);\n    for(int i=1;i<=N;i++){\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        //cerr << i << \" \" << id << \" \" << seg2.getmin(id-1,i) << \" \" << seg1.getmin(0,id-1) << endl;\n        dp[i] = seg2.getmin(id-1,i)+T+X[i+1]-X[i];\n        if(id>1) dp[i] = min(dp[i],seg1.getmin(0,id-1)+X[i+1]-X[i]);\n        seg1.add(i,i+1,dp[i]);\n        seg1.add(0,i,3*(X[i+1]-X[i]));\n        seg2.add(i,i+1,dp[i]);\n        seg2.add(0,i,X[i+1]-X[i]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <cstring>\n#include <bitset>\n#include <stack>\nusing namespace std;\n#define MP make_pair\n#define PB push_back\nconst int INF=1e9;\n\nint n,e,t,pos;\nlong long a[100005];\nlong long dp[100005],cur;\n\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor (int i=1;i<=n;i++) cin>>a[i];\n\tdp[0]=0;\n\tcur=1e18;\n\tpos=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (t<=2*(a[i]-a[pos+1]))\n\t\t{\n\t\t\tcur=min(cur,dp[pos]-2*a[pos+1]);\n\t\t\tpos++;\n\t\t}\n\t\tdp[i]=min(cur+2*a[i],dp[pos]+t);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] = x;\n    while(k>0) k = (k-1)/2, dat[k] = min(dat[k*2+1],dat[k*2+2]);\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return min(A, B);\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n+1, -10000000000);re(i, n) scanf(\"%lld\", &x[i+1]);\n\n  ll INF = 1000000000000000000;\n  vll dp(n+1, INF);\n  dp[0] = e;\n  segtree seg(n+1, INF);\n  seg.update(dp[0]-2*x[1], 0);\n\n  for(int now=1;now<=n;now++){\n    ll l = lower_bound(all(x), x[now]-t/2) - x.begin();\n\n    if(now!=1){\n      dp[now] = dp[max((ll)0, l-1)] + t;\n      dp[now] = min(dp[now], 2*x[now]+seg.query(0, l-1));\n    }else{\n      dp[now] = dp[0] + t;\n    }\n    if(now!=n) seg.update(dp[now]-2*x[now+1],now);\n  }\n\n  //std::cout << dp[1] << '\\n';\n  //std::cout << dp[2] << '\\n';\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint last=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tfor(int j=last;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif((x[i]-x[j+1])*2<t)\n\t\t\tbreak;\n\t\t\tif(dp[i]==(x[i]-x[j+1])*2+dp[j])\n\t\t\tlast=j;\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define pii pair<int,int>\n#define iiii pair<int,pii >\n#define ld double \n#define MAXN 100100\n#define inf 1000000000000000000ll\nusing namespace std;\n\nll Dp[MAXN],e,t,q=inf,a[MAXN];\nint n,p;\n\n\n\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",a+i);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile ((a[i]-a[p+1])*2>=t)\n\t\t{\n\t\t\tq=min(q,Dp[p]-a[p+1]*2-a[p]);\n\t\t\tp++;\n\t\t}\n\t\tDp[i]=min(3ll*a[i]+q,Dp[p]+a[i]-a[p]+t);\n\t}\n\t\n\t \n\tprintf(\"%lld\\n\",Dp[n]-a[n]+e);\n\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nvoid update(ll N,ll m,ll right,ll val,ll plus,vi &dp,vi &sum,vi &min){\n    rep(i,0,right/m){\n        sum[i]+=plus;\n        min[i]+=plus;\n    }    \n    REP(i,right/m*m,right) dp[i]+=plus;\n    dp[right]=val;\n    min[right/m]=inf;\n    rep(i,right/m*m,std::min(right/m*m+m,N)) min[i/m]=std::min(min[i/m],dp[i]);\n}\nll Query(ll m,ll right,vi &min,vi &dp,vi &sum){\n    ll ret=inf;\n    if(right<0) return inf;\n    rep(i,0,right/m) ret=std::min(ret,min[i]);\n    REP(i,right/m*m,right) ret=std::min(ret,dp[i]+sum[i/m]);\n    return ret;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,T,E; cin>>N>>E>>T;\n    ll m=sqrt(N)+1;\n    vi A(N);\n    rep(i,0,N) cin>>A[i];\n    vi dp(N+1,inf);\n    dp[0]=0;\n    vi sum(m+1),min(m+1);\n    min[0]=0;\n    Segment_tree<ll> seg(dp,inf);\n    rep(i,0,N){\n        ll X=std::upper_bound(ALL(A),A[i]-(T+1)/2)-A.begin();\n        X--;\n        if(i<N-1) update(N,m,i+1,std::min(Query(m,X,min,dp,sum),seg.Query(X+1,N+1,0,0,-1)+T),(A[i+1]-A[i])*2,dp,sum,min);\n        else dp[N]=std::min(Query(m,X,min,dp,sum),seg.Query(X+1,N+1,0,0,-1)+T);\n        seg.update(i+1,dp[i+1]);\n    }\n    ll ans=E+dp[N];\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tf[i] = max(2 * (d[i] - d[1]),t);\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\twhile (2 * (d[i] - d[pp + 1]) > t) {\n\t\t\tf[i] = min(f[i],f[pp] + 2 * (d[i] - d[pp + 1]));\n\t\t\tpp++;\n\t\t}\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\tif (f[pp] + t < f[i]) f[i] = f[pp] + t;\n\t\tif (pp > 0) pp--;\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n\t}\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nint N, E, T;\nvector<int> X;\nvector<ll> dp;\n\nll f(int i, int j){\n    return dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    cin >> N >> E >> T;\n    X.assign(N + 1, 0);\n    rep(i, 1, N + 1) cin >> X[i];\n    \n    // i\n    dp.assign(N + 1, 1LL << 60);\n    dp[0] = 0;\n    rep(i, 1, N + 1){\n        \n        int l = 0; int r = i;\n        int cnt = 0;\n        while(r - l > 5 && cnt < 50){\n            int ml = (2 * l + r) / 3;\n            int mr = (l + 2 * r) / 3;\n            if(f(i, ml) < f(i, mr)){\n                r = mr;\n            }\n            else{\n                l = ml;\n            }\n            cnt++;\n        }\n        rep(j, l, r){\n            dp[i] = min(dp[i], f(i, j));\n        }\n        \n        \n//        rep(j, i){\n//            dp[i] = min(dp[i], dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1]);\n//        }\n    }\n    \n    ll ret = dp[N] + (E - X[N]);\n    \n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n+1,0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvl dp(n+1,INF);\n\tdp[0] = e;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tfor (int j =0; j<i; j++) {\n\t\t\tmi = min(mi, dp[j]+max(t, 2 * (x[i]-x[j+1])));\n\t\t}\n\t\tdp[i] = mi;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include<iostream>\n//#include<cstdio>\n//using namespace std;\n//LL n,e,t,f[10001],a[10001];\n//LL main()\n//{\n//\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n//\tfor (LL i=1; i<=n; ++i)\n//\t\tscanf(\"%lld\",&a[i]);\n//\tfor (LL i=1; i<=n; ++i)\n//\t{\n//\t\tf[i]=f[i-1]+(a[i]-a[i-1])+t;\n//\t\tfor (LL j=i-1; j>=1; --j)\n//\t\t\tf[i]=min(f[i],f[j-1]+3*a[i]-2*a[j]-a[j-1]+max(1ll*0,t-2*(a[i]-a[j])));\n//\t}\n//\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n//}\n\n#include<iostream>\n#include<cstdio>\n#define N (100000+1000)\n#define LL long long\nusing namespace std;\n\nLL n,e,t,f[N],a[N],Segt[N<<2],p;\n\nvoid Update(LL now,LL l,LL r,LL x,LL v)\n{\n\tif (l==r) {Segt[now]=v; return;}\n\tLL mid=(l+r)>>1;\n\tif (x<=mid) Update(now<<1,l,mid,x,v);\n\telse Update(now<<1|1,mid+1,r,x,v);\n\tSegt[now]=min(Segt[now<<1],Segt[now<<1|1]);\n}\n\nLL Query(LL now,LL l,LL r,LL l1,LL r1)\n{\n\tif (l>r1 || r<l1) return 1e17;\n\tif (l1<=l && r<=r1) return Segt[now];\n\tLL mid=(l+r)>>1;\n\treturn min(Query(now<<1,l,mid,l1,r1),Query(now<<1|1,mid+1,r,l1,r1));\n}\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\twhile (p<=i-1 && 2*(a[i]-a[p])>=t) Update(1,1,n,p,-2*a[p]),p++;\n\t\tLL temp=1e17;\n\t\ttemp=min(temp,Query(1,1,n,1,p-1));\n\t\tif (p<=i-1) temp=min(temp,Query(1,1,n,p,i-1)+t-2*a[i]);\n\t\tf[i]=min(temp+3*a[i],f[i-1]+a[i]-a[i-1]+t);\n\t\tUpdate(1,1,n,i,-2*a[i]-a[i-1]+2*a[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j != 0){\n            tmp1 = sgt2.query(0, min(j-1, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <unordered_map>\n#include <map>\n#include <set>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(int argc, char const *argv[]) {\n  long long n,e,t;cin>>n>>e>>t;\n  vector<long long> dp(n+1,1ll<<62),x(n);\n  for(int i=0;i<n;++i)cin>>x[i];\n  dp[0]=x[0]+t;\n  for(int i=1;i<n;++i){\n    dp[i]=dp[i-1]+x[i]-x[i-1]+t;\n    dp[i]=min(dp[i],x[0]+3*(x[i]-x[0])+max(0ll,t-2*(x[i]-x[0])));\n    for(int j=1;j<i;++j){\n      dp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+3*(x[i]-x[j])+max(0ll,t-2*(x[i]-x[j])));\n    }\n  }\n  cout<<dp[n-1]+e-x[n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = f[j] + x[i] - x[j + 1];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\tfor (int j = max(0, i - 100000000 / n); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t\tfor (int j = 0; j < min(i, 100000000 / n); j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\n\t\t}\n\t\twhile (p + 1 < i && calc(p, i) > calc(p + 1, i)) ++p;\n\t\tf[i] = min(f[i], calc(p, i));\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n \nusing namespace std;\n \n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n \n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n \npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n \n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n \n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n \nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n \n    vector<long long> A(N);\n    A[0] = x[0]+T;\n \n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[0]+(x[i]-x[0])*3+max(0, T-(x[i]-x[0])*2));\n \n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n \n        if (1<r)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, r));\n        if (r<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(r, i));\n \n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    dp[1] = T;\n    for (ll i = 2, j = 0, k = 0; i <= N;) {\n        ll L = max(2 * (X[i] - X[j + 1]), T);\n        if (L == T) {\n            dp[i] = min(dp[j] + T, dp[k] + max(2 * (X[i] - X[k + 1]), T));\n            i++;\n        } else {\n            ll dpj = dp[j] + L;\n            ll dpk = dp[k] + 2 * (X[i] - X[k + 1]);\n            if (dpj < dpk) {\n                k = j;\n            }\n            j++;\n        }\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst int N=100005;\nconst int M=2005;\nconst ll inf=1000000000000000000ll;\n\nstruct ST{\n\tint l,r;\n\tll mn1,mn2,tag;\n}t[N<<2];\nint n;\nll e,T,mn;\nint f[N];\nll dp[M][M],x[N];\n\nvoid update(int k){\n\tt[k].mn1=min(t[k<<1].mn1,t[k<<1|1].mn1);\n\tt[k].mn2=min(t[k<<1].mn2,t[k<<1|1].mn2);\n}\n\nvoid build(int k,int l,int r){\n\tt[k].l=l; t[k].r=r;\n\tt[k].mn1=t[k].mn2=inf; t[k].tag=0;\n\tif (l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n}\n\nvoid add(int k,ll w){\n\tt[k].tag+=w;\n\tt[k].mn1+=w;\n\tt[k].mn2+=w;\n}\n\nvoid pushdown(int k){\n\tif (t[k].tag){\n\t\tadd(k<<1,t[k].tag);\n\t\tadd(k<<1|1,t[k].tag);\n\t\tt[k].tag=0;\n\t}\n}\n\nvoid modifys(int k,int L,int R,ll w){\n\tif (L<=t[k].l&&t[k].r<=R){\n\t\tadd(k,w);\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (L<=mid) modifys(k<<1,L,R,w);\n\tif (R>mid) modifys(k<<1|1,L,R,w);\n\tupdate(k);\n}\n\nvoid modifyp(int k,int p,ll w){\n\tif (t[k].l==t[k].r){\n\t\tt[k].mn1=min(t[k].mn1,w);\n\t\tt[k].mn2=min(t[k].mn2,w-2ll*x[p]);\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (p<=mid) modifyp(k<<1,p,w);\n\telse modifyp(k<<1|1,p,w);\n\tupdate(k);\n}\n\nll query1(int k,int L,int R){\n\tif (L<=t[k].l&&t[k].r<=R) return t[k].mn1;\n\tpushdown(k);\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (R<=mid) return query1(k<<1,L,R);\n\telse if (L>mid) return query1(k<<1|1,L,R);\n\telse return min(query1(k<<1,L,R),query1(k<<1|1,L,R));\n}\n\nll query2(int k,int L,int R){\n\tif (L<=t[k].l&&t[k].r<=R) return t[k].mn2;\n\tpushdown(k);\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (R<=mid) return query2(k<<1,L,R);\n\telse if (L>mid) return query2(k<<1|1,L,R);\n\telse return min(query2(k<<1,L,R),query2(k<<1|1,L,R));\n}\n\nvoid init(){\n\tint i,l,r,mid;\n\tfor (i=1;i<=n;i++){\n\t\tl=0; r=i-1;\n\t\twhile (l<r){\n\t\t\tmid=(l+r+1)>>1;\n\t\t\tif (2*(x[i]-x[mid])>=T) l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tf[i]=l;\n\t}\n}\n\nvoid solve1(){\n\tint i,j;\n\tfor (i=0;i<=n+1;i++)\n\t\tfor (j=0;j<=n+1;j++) dp[i][j]=inf;\n\tdp[1][1]=x[1];\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=i;j++) if (dp[i][j]<inf){\n\t\t\tdp[i+1][i+1]=min(dp[i+1][i+1],dp[i][j]+max(2*(x[i]-x[j]),T)+x[i+1]-x[i]);\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t}\n\tprintf(\"%lld\\n\",dp[n+1][n+1]);\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d%lld%lld\",&n,&e,&T);\n\tfor (i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tinit();\n\tx[n+1]=e;\n\t//if (n<=2000){solve1();return 0;}\n\tbuild(1,1,n+1);\n\tmodifyp(1,1,x[1]);\n\tfor (i=1;i<=n;i++){\n\t\tmn=query1(1,f[i]+1,i);\n\t\tmodifyp(1,i+1,mn+T+x[i+1]-x[i]);\n\t\tif (f[i]>0){\n\t\t\tmn=query2(1,1,f[i]);\n\t\t\tmodifyp(1,i+1,mn+2ll*x[i]+x[i+1]-x[i]);\n\t\t}\n\t\tmodifys(1,1,i,x[i+1]-x[i]);\n\t}\n\tprintf(\"%lld\\n\",query1(1,n+1,n+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Debug(x) cout<<#x<<\"=\"<<(x)<<endl;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL inf = 1LL << 61;\nconst LL mod = 1000000007;\nconst int max_n = 100010;\n\n\nint n;\nLL T, E;\nLL dp[max_n], d[max_n];\nint main()\n{\n    int i = 0, j = 0, k = 0;\n    Fill(d, 0);\n    Fill(dp, 0);\n    scanf(\"%d %I64d %I64d\", &n,&E,&T);\n    for(i = 1; i <= n; i++)\n    {\n        scanf(\"%I64d\", d+i);\n    }\n    dp[1] = d[1]+T;\n    LL ans;\n    for(i = 2; i <= n; i++)\n    {\n        dp[i] = dp[i-1]+d[i]-d[i-1]+T;\n        for(j = i-1; j >= 1; j--)\n        {\n            if(d[i]-d[j]>T)\n                break;\n            if(T<=2*(d[i]-d[j]))\n            {\n                ans = dp[j-1]+d[i]-d[j-1]+2*(d[i]-d[j]);\n            }\n            else\n            {\n                ans = dp[j-1]+d[i]-d[j-1]+T;\n            }\n            dp[i] = min(dp[i], ans);\n        }\n    }\n    /*\n    for(i = 1; i <= n; i++)\n    {\n        cout << dp[i] << \" \";\n    }\n    cout << endl;\n    */\n    ans = dp[n]+E-d[n];\n    printf(\"%I64d\\n\", ans);\n\n\n    return 0;\n}\n/*\n5 8 4\n1 3 4 6 7\n*/\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int INF = 2e9;\n\nint dp[MAXN], seg[4 * MAXN], x[MAXN];\n\nvoid _set(int v, int l, int r, int p, int x) {\n    if (r - l == 1) {\n\tseg[v] = x;\n\treturn;\n    }\n    int mid = (r + l) / 2;\n    if (p < mid) \n\t_set(2 * v, l, mid, p, x);\n    else\n\t_set(2 * v + 1, mid, r, p, x);\n    seg[v] = min(seg[2 * v], seg[2 * v + 1]);\n}\n\nint query(int v, int l, int r, int s, int t) {\n    if (s <= l && r <= t)\n\treturn seg[v];\n    int mid = (l + r) / 2, res = INF;\n    if (s < mid)\n\tres = min(res, query(2 * v, l, mid, s, t));\n    if (t > mid)\n\tres = min(res, query(2 * v + 1, mid, r, s, t));\n    return res;\n}\n\nint lower(int val, int s, int t) {\n    if (t - s == 1)\n\treturn s;\n    int mid = (s + t) / 2;\n    if (x[mid-1] >= val)\n\treturn lower(val, s, mid);\n    else\n\treturn lower(val, mid, t);\n}\n\nint main() {\n    int N, T, E;\n    cin >> N >> E >> T;\n    T *= 2;\n    for (int i = 0; i < N; i ++) cin >> x[i], x[i] *= 2;\n    for (int i = 0; i < N; i ++) {\n\tint last = lower(x[i] - T/2, 0, N);\n\t//if(i)cerr << dp[i-1] << endl;\n\tif (last <= 1) {\n\t    dp[i] = (last?2 * x[i] - 2 * x[0] : T);\n\t    if(i)dp[i] = min(dp[i], dp[last - 1] + T);\n\t    _set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n\t    continue;\n\t}\n\tdp[i] = query(1, 0, N, 0, last-1) + 2 * x[i]; dp[i] = min(dp[i], dp[last- 1] + T);\n\t_set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n    }\n    cout << dp[N -1]/2 + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1000000000000000007ll\nusing namespace std;\n\nint n,e,t,a[100010],dp[100010];\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tint minv=INF,pos=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(2*(a[i]-a[pos+1])>t){\n\t\t\tminv=min(minv,dp[pos]-2*a[pos+1]);\n\t\t\tpos++;\n\t\t}\n\t\tdp[i]=min(minv+2*a[i],dp[pos]+t);\n\t}\n\tcout<<dp[n]+e<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nvoid dump(vector<T> &vec){\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i];\n\t\tif(i+1<vec.size())cout << ' ';\n\t\telse cout << endl;\n\t}\n\treturn;\n}\nint N;\nll E,T;\nll x[100100];\nll dp[100100];\npriority_queue<ll,vector<ll>,greater<ll> > q;\nint main(){\n\tcin >> N >> E >> T;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i];\n\t}\n\tfor(int i=0;i<=N;i++){\n\t\tdp[i] = LLINF;\n\t}\n\tdp[0] = 0ll;\n\tdp[1] = T;\n\tint p = -2ll;\n\tfor(int i=0;i<N;i++){\n\t\twhile(p+1<i&&2*(x[i]-x[p+2])>T){\n\t\t\tp++;\n\t\t\tq.push(dp[p+1]-2*x[p+1]);\n\t\t}\n\t\tif(!q.empty())chmin(dp[i+1],2*x[i]+q.top());\n\t\tif(p<i-1)chmin(dp[i+1],dp[p+2]+T);\n\t\t// cout << i << ' ' << p << ' ' << dp[i] << endl;\n\n\t}\n\tcout << E+dp[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x \": \" << x << \" \"\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << \"{\"; for(const T &a : v) out << a << \", \"; out << \"}\"; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << \"(\" << p.st << \", \" << p.nd << \")\"; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, t, e;\nlong long X[100010];\nlong long T[100010];\nmultiset<long long> D, G;\n\nlong long minS(const multiset<long long> &M){\n\tif(M.empty()) return 1000LL*1000*1000*1000 + 3;\n\treturn *M.begin();\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tFWD(i,1,n+1) scanf(\"%lld\", &X[i]);\n\n\tD.insert(T[0] - X[0] + t);\n\n\tint p = 0;\n\tFWD(k,1,n+1){\n\t\twhile(2*(X[k] - X[p+1]) > t){\n\t\t\tD.erase(D.find(T[p] - X[p] + t));\n\t\t\tG.insert(T[p] - 2*X[p+1] - X[p]);\n\t\t\t++p;\n\t\t}\n\t\tT[k] = min(minS(G) + 3*X[k], minS(D) + X[k]);\n\t\tD.insert(T[k] - X[k] + t);\n\t}\n\tprintf(\"%lld\\n\", T[n] + e - X[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <deque>\n#include <stack>\nusing namespace std;\n\nlong long dp[200005];\nlong long x[200005];\ndeque<int> dq;\n\nbool stack_better(int j1, int j2) {\n    return dp[j1] - x[j1] - 2LL * x[j1 + 1] < dp[j2] - x[j2] - 2LL * x[j2 + 1];\n}\n\nbool deque_better(int i, int j) {\n    return dp[i] - x[i] < dp[j] - x[j];\n}\n\nint main() {\n    //ifstream cin(\"f.in\");\n    int n, j = -1, bst = -1; long long t, e;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++ i) {\n        cin >> x[i];\n    }\n    dp[0] = 0;\n    dq.push_back(0);\n    for (int i = 1; i <= n; ++ i) {\n        dp[i] = 1LL << 60;\n\n        /// the ones whose time surpassed t\n        while (j + 1 < i && 2LL * (x[i] - x[j + 2]) >= t) {\n            j += 1;\n            if (bst == -1 || stack_better(j, bst)) {\n                bst = j;\n            }\n        }\n        if (j >= 0) {\n            dp[i] = min(dp[i], dp[bst] - (x[bst] + 2LL * x[bst + 1]) + 3LL * x[i]);\n        }\n\n        /// time did not surpass t\n        while (!dq.empty() && 2LL * (x[i] - x[dq.front() + 1]) >= t) {\n            dq.pop_front();\n        }\n        if (!dq.empty()) {\n            dp[i] = min(dp[i], dp[dq.front()] - x[dq.front()] + x[i] + t);\n        }\n        while (!dq.empty() && dp[i] - x[i] < dp[dq.back()] - x[dq.back()]) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n    }\n    cout << dp[n] + (e - x[n]) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\t/*\n\tincID(j, m[i - 1], m[i]) {\n\t\tauto it1 = ms.find(dp[j]);\n\t\tauto it2 = it1;\n\t\tit2++;\n\t\tms.erase(it1, it2);\n\t}\n\tms.insert(dp[i - 1]);\n\t*/\n\t\n\tms.clear();\n\tincID(j, m[i], i) { ms.insert(dp[j]); }\n\treturn *(ms.rbegin());\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n#define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 100010;\n\nll N, T, E;\nll X[maxn];\nll dp[maxn], pmn[maxn];\n\nvoid MAIN() {\n\n    cin >> N >> E >> T;\n    fori (i, N) cin >> X[i + 1];\n    dp[N] = E - X[N];\n    pmn[N] = dp[N] + X[N] * 3;\n    pmn[N + 1] = BIG;\n    ll ptr = N;\n    forir (i, N) {\n        while ((X[ptr] - X[i + 1]) * 2 > T) --ptr;\n        dp[i] = T + dp[ptr] + X[ptr] - X[i + 1];\n        smin(dp[i], pmn[ptr + 1] - X[i + 1] * 3);\n        dp[i] += X[i + 1] - X[i];\n        pmn[i] = min(pmn[i + 1], dp[i] + X[i] * 3);\n    }\n    cout << dp[0] << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n5 100 1000\n4 10 30 40 50\n\n3 9 3\n1 3 8\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n \n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n \ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n \ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n \ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n \ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n \nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+10&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long maxn = 1e5 + 10 , inf = 2e18;\nlong long e , n , t , x[maxn] , dp[maxn] , p[maxn];\n\nint main()\n{\n    cin >> n >> e >> t;\n    for(int i=1 ; i<=n ; i++) cin >> x[i];\n    dp[0] = 0; p[0] = dp[0] - 2*x[1];\n    for(int i=1 ; i<=n ; i++)\n    {\n        int y = lower_bound(x,x+n , x[i]-(t/2))-x;\n        dp[i] = (y <= 1 ? t : min(p[y-2] + 2*x[i] , dp[y-1] + t));\n        p[i] = min(p[i-1] , dp[i] - 2*(x[i+1]));\n    }\n    cout << dp[n] + e;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\n\nstruct RMQ {\n\tint n; vector<int>node;\n\tvoid init(int N) {\n\t\tn = 1;\n\t\twhile (n < N)n *= 2;\n\t\tnode.resize(2 * n, inf);\n\t}\n\n\tvoid update(int x, int a) {\n\t\tx += n - 1;\n\t\tnode[x] = a;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[x * 2 + 1], node[x * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tint get(int a, int b) {\n\t\tif (a > b)return inf;\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\nRMQ dp1, dp2;\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\tdp1.init(n + 1);\n\tdp2.init(n + 1);\n\n\tx[n] = x[n - 1];\n\tdp1.update(0, 0);\n\tdp2.update(0, -2*x[0]);\n\trep(i,n){//dp[i+1]\n\t\tint lb = -1, ub = i;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mi = (ub + lb) / 2;\n\t\t\tif (2 * (x[i] - x[mi]) > t)lb = mi;\n\t\t\telse ub = mi;\n\t\t}\n\n\t\t//0~lb ub~i\n\t\tint X1, X2;\n\t\tX1 = dp1.get(ub, i+1) + t;\n\t\tX2 = dp2.get(0, ub) + 2 * x[i];\n//\t\tcout << ub << ' ' << X1 << ' ' << X2 << endl;\n\t\tdp1.update(i+1, min(X1, X2));\n\t\tdp2.update(i+1, dp1.get(i+1, i + 2) - 2 * x[i]);\n\t}\n\tcout << dp1.get(n, n+1)+e << endl;\n\n\t/*\n\tdp[0] = 0;\n\trep(i, n) {\n\t\tfor (int j = i; j<n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + max(2 * (x[j] - x[i]), t));\n\t\t}\n\t}\n\tcout << dp[n] + e<< endl;\n\t*/\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[200010];\nint main() {\n    ll N, E, T; scanf(\"%lld%lld%lld\", &N, &E, &T);\n\n    vector<ll> S(N+1);\n    for(int i=0; i<N; i++) {\n        scanf(\"%lld\", &S[i+1]);\n    }\n\n    fill(dp, dp + N + 1, LONGINF);\n    dp[0] = 0;\n    vector<ll> c(N+1, -LONGINF);\n    multiset<ll> ms1, ms2;\n    \n    ll ans = (S[1] - 0) + (E - S[N]), j = 0, d = 0;\n    for(int i=0; i<=N; i++) {\n        if(i == N) continue;\n        ll e = (i+1 < N ? S[i+2] - S[i+1] : 0);\n        while(j <= i and 2*(S[i+1] - S[j+1]) >= T) {\n            ms2.erase(ms2.find(c[j]));\n            ll v = dp[j] + 3*(S[i+1] - S[j+1]);\n            ms1.emplace(v - 3*d);\n            c[j] = v - 3*d;\n            j++;\n        }\n        {\n            ll v = dp[i] + T + (S[i+1] - S[j+1]);\n            ms2.emplace(v - d);\n            c[i] = v - d;\n        }\n        /*\n        for(int j=0; j<=i; j++) {\n            ll d = S[i+1] - S[j+1];\n            ll c1 = dp[j] + 3*d, c2 = dp[j] + T + d;\n            chmin(dp[i+1], max(c1, c2) + e);\n        }\n        */\n\n        ll min_v_1 = (ms1.size() ? *ms1.begin() + 3*d : LONGINF);\n        ll min_v_2 = (ms2.size() ? *ms2.begin() + 1*d : LONGINF);\n        chmin(dp[i+1], min(min_v_1, min_v_2) + e);\n        // fprintf(stderr, \"i = %d, j = %lld, c1 = %lld, c2 = %lld, e = %lld\\n\", i, j, c1, c2, e);\n        fprintf(stderr, \"dp[%d] = %lld\\n\", i+1, dp[i+1]);\n        \n        d += S[i+2] - S[i+1];\n        fprintf(stderr, \"d = %lld\\n\", d);\n        /*\n        c1 += 3*d;\n        c2 += d;\n        */\n        // fprintf(stderr, \"after: c1 = %lld, c2 = %lld\\n\", c1, c2);\n    }\n    ans += dp[N];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 1LL << 62;\n        for (int j = i - 1; j >= 0; --j) {\n            dp[i] = min(dp[i], dp[j] + X[j + 1] - X[j] + \n                    3LL * (X[i] - X[j + 1]) + max(0LL, T - 2LL * (X[i] - X[j + 1])));\n        }\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MN = 100010;\n\nint N, E, T;\nint X[MN];\n\nstruct BIT {\n    vector<ll> tree;\n    void init() {\n        tree = vector<ll>(4 * MN, 1e18);\n    }\n    void upd(int idx, ll val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = min(tree[n], val);\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = min(tree[2*n], tree[2*n + 1]);\n    }\n    ll quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 1e18;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        ll L = quer(a, b, l, m, 2*n);\n        ll R = quer(a, b, m + 1, r, 2*n + 1);\n        return min(L, R);\n    }\n} bit1, bit2;\n\nll dp[MN];\n\nint main() {\n    scanf(\"%d %d %d\", &N, &E, &T);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    X[N] = E;\n\n    bit1.init();\n    bit2.init();\n\n    dp[N] = 0;\n    bit1.upd(N, dp[N] + 2 * X[N - 1] + X[N], 0, MN - 1, 1);\n    bit2.upd(N, dp[N] + X[N], 0, MN - 1, 1);\n\n    for(int i = N - 1; i >= 0; i--) {\n\n        int s = i + 1, e = N, p = -1;\n        while(s <= e) {\n            int m = (s + e)>>1;\n\n            if(T > 2 * (X[m - 1] - X[i])) {\n                p = m;\n                s = m + 1;\n            }\n            else e = m - 1;\n        }\n\n        dp[i] = bit1.quer(p + 1, N, 0, MN - 1, 1) - 3LL * X[i];\n        dp[i] = min(dp[i], bit2.quer(i + 1, p, 0, MN - 1, 1) - X[i] + T);\n\n        bit1.upd(i, dp[i] + 2 * (i? X[i - 1] : 0) + X[i], 0, MN - 1, 1);\n        bit2.upd(i, dp[i] + X[i], 0, MN - 1, 1);\n    }\n\n    printf(\"%lld\", dp[0] + X[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = n;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 > T) low = mid;\n      else high = mid;\n    }\n    int pos = low;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll dp[100016];\n\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vx;\n\trep(i, 0, n) {\n\t\tll a;\n\t\tcin >> a;\n\t\tvx.pb(a);\n\t}\n\trep(i, 0, 100016)dp[i] = 1000000000000000000LL;\n\tdp[0] = 0;\n\tdp[1] = t;\n\tif (n == 1) {\n\t\tcout << e + t << endl;\n\t\treturn 0;\n\t}\n\trep(i, 2, vx.sz + 1) {\n\t\tdp[i] = dp[i - 1] + t;\n\t\tlong long low = 0;\n\t\tlong long high = i-1;\n\n\t\twhile (low < high) {\n\t\t\tlong long mid = (high + low) >> 1;\n\n\t\t\tif (t <= (vx[i - 1] - vx[mid]) * 2) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\tdp[i] = min(dp[i], dp[low] + max(t, (vx[i - 1] - vx[low]) * 2));\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <vector>\n#define MAXN 100005\n#define LL long long\nusing namespace std;\nint n, e, t;\nvector<int> num;\nint main()\n{\n    scanf(\"%d%d%d\", &n, &e, &t);\n    num.clear();\n    for(int x, i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x);\n        num.push_back(x);\n    }\n    LL sum = 0;\n    sum += num[0] + e - num[n - 1];\n    for(int j, i = 0; i < n; i = j)\n    {\n        j = i;\n        while(j < n && num[j] - num[i] <  t) j++;\n        sum += 3LL * (num[j - 1] - num[i]);\n        int xx = 0;\n        for(int k = i; k < j; k++)\n        {\n            if((num[j - 1] - num[i]) * 2 + xx < t)\n            {\n                sum += (t - (num[j - 1] - num[i]) * 2 - xx);\n                xx += (t - (num[j - 1] - num[i]) * 2 - xx);\n            }\n        }\n        if(j < n) sum += num[j] - num[j - 1];\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll INF = 1ll<<60;\n\n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return seg[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n\nconst int MAXN = 100100;\nint N, E, T;\nint X[MAXN];\nll dp[MAXN];\n\nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i];\n\tconst ll INF = 1ll<<60;\n\tST<ll> seg(N+10);\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i] = INF;\n\t}\n\tX[N] = E;\n\tdp[N] = 0;\n\tseg.update(N, dp[N] + X[N] + 2*X[N-1]);\n\tfor (int i = N-1; i >= 0; i--) {\n\t\t// まず T が支配的な部分を探索\n\t\tint low = i, high = N;\n\t\twhile (high - low > 1) {\n\t\t\tconst int med = (low + high) / 2;\n\t\t\tif (2*(X[med]-X[i]) <= T) {\n\t\t\t\tlow = med;\n\t\t\t} else {\n\t\t\t\thigh = med;\n\t\t\t}\n\t\t}\n\t\t//cout << i << \" \" << low << endl;\n\t\tdp[i] = dp[low+1] + X[low+1] - X[i] + T;\n\t\tdp[i] = min(dp[i], seg.query(low+1, N) - 3*X[i]);\n\t\tif (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n\t\t//cout << i << \" \" << dp[i] << endl;\n\t}\n\tcout << X[0] + dp[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define ran 111111\nint n,e,t;\nint x[ran];\nlong long int dp2[ran];\nlong long int pref[ran];\nlong long int a[ran*4];\nvoid upd(int i,int lef,int rig,int x,long long int val){\n\tif(lef == x && rig == x){\n\t\ta[i] = val;\n\t\treturn;\n\t}\n\tint m = (lef+rig)/2;\n\tif(x <= m)\n\t\tupd(i*2,lef,m,x,val);\n\telse\n\t\tupd(i*2+1,m+1,rig,x,val);\n\ta[i] = min(a[i*2],a[i*2+1]);\n}\nlong long int query(int i,int lef,int rig,int from,int to){\n\tif(lef == from && rig == to)\n\t\treturn a[i];\n\tint m = (lef+rig)/2;\n\tif(to <= m)\n\t\treturn query(i*2,lef,m,from,to);\n\tif(from > m)\n\t\treturn query(i*2+1,m+1,rig,from,to);\n\treturn min(query(i*2,lef,m,from,m),query(i*2+1,m+1,rig,m+1,to));\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tx[0] = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1] = e;\n\tdp2[0] = 0;\n\tpref[0] = -2 * x[1];\n\tupd(1,0,n,0,dp2[0]);\n\tfor(int i=1; i<=n; i++){\n\t\tint lo = 0, hi = i-1;\n\t\twhile(lo!=hi){\n\t\t\tint mi = (lo+hi)/2;\n\t\t\tif((x[i] - x[mi+1]) * 2 <= t)\n\t\t\t\thi = mi;\n\t\t\telse\n\t\t\t\tlo = mi+1;\n\t\t}\n\t\tdp2[i] = query(1,0,n,lo,i-1) + t;\n\t\tif((x[i] - x[lo]) * 2 > t)dp2[i] = min(dp2[i], pref[lo-1] + 2 * x[i]);\n\t\tpref[i] = min(pref[i-1], dp2[i] - 2 * x[i+1]);\n\t\tupd(1, 0, n, i, dp2[i]);\n\t}\n\tcout << dp2[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2 - 1;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans  << \"\\n\";\n\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n#define INF 1e15+7\nstruct SegmentTree {\nprivate:\n    int nn; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        nn = 1; while(nn < sz) nn *= 2;\n        node.resize(2*nn-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (nn - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = nn;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+2),seg2(n+2);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-x[i]*2+x[mid+1]*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#define maxn 500009\n#define lson 1,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst long long INF=1e18;\nlong long tree[maxn];\nint n,E,T;\nlong long a[maxn],dp[maxn];\nlong long f[maxn];\nvoid pushup(int rt){\n\ttree[rt]=min(tree[rt<<1],tree[rt<<1|1]);\n}\nvoid build(int l,int r,int rt){\n\ttree[rt]=INF;\n\tif(l==r){\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n}\nvoid update(int L,int R,long long val,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\ttree[rt]=min(tree[rt],val);\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(L<=m)\n\t\tupdate(L,R,val,lson);\n\tif(R>m)\n\t\tupdate(L,R,val,rson);\n\tpushup(rt);\n}\nlong long query(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)\n\t\treturn tree[rt];\n\tlong long res1=INF,res2=INF;\n\tint m=(l+r)>>1;\n\tif(L<=m) res1=query(L,R,lson);\n\tif(R>m) res2=query(L,R,rson);\n\treturn min(res1,res2);\n}\nint main(){\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tbuild(1,n,1);\n\tdp[0]=0;\n\tupdate(1,1,dp[0]-a[0],1,n,1);\n\tdp[0]=0;\n\tf[0]=INF;\n\tfor(int i=1;i<=n;i++){\n\t\tint L=1,R=i;\n\t\twhile(L<R){\n\t\t\tint M=(L+R)>>1;\n\t\t\tif(2LL*(a[i]-a[M])<=T)\n\t\t\t\tR=M;\n\t\t\telse\n\t\t\t\tL=M+1;\n\t\t}\n\t\tlong long res=query(R,i,1,n,1);\n\t\tdp[i]=res+a[i]+T;\n\t\tif(R>1){\n\t\t\tdp[i]=min(dp[i],f[R-1]+3*a[i]);\n\t\t}\n\t\tf[i]=min(f[i-1],dp[i-1]+a[i]-a[i-1]-3*a[i]);\n\t\tupdate(i+1,i+1,dp[i]-a[i],1,n,1);\n\t}\n\tcout<<dp[n]+E-a[n]<<endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n\n\n  dp[0] = e;\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    idx -= now;\n    // そこかその一個前\n    for(int d=idx-1;d<=idx&&d+now<n;d++){\n      ll ad = max(t, 2*(x[now+d] - x[now])); //追加される分\n      ll nxt = now + d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  std::cout << dp[n] << '\\n';\n\n  //全ての辺について2通りの可能性\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,0,n)cin>>x[i];\n    int v=0;\n    while(v<n&&x[v]-x[0]<(t+1)/2)v++;\n    if(v==n)\n    {\n    \tcout<<t+e;\n    \texit(0);\n    }\n    int g=0;\n    up(1,0,n,0,-2*x[0]);\n    rep(j,1,v)\n    {\n        if(x[v]-x[j]>=(t+1)/2)up(1,0,n,j,-2*x[j]+t);\n        else\n        {\n            up(1,0,n,j,2*t);\n            break;\n        }\n    }\n    rep(i,v,n)\n    {\n        while(x[i]-x[g+1]>=(t+1)/2)g++;\n    \tdp[i]=2*x[i]+query(1,0,n,0,g+1);\n    \tup(1,0,n,i,dp[i-1]-2*x[i]);\n    \tif(g>=v)dp[i]=min(dp[i],dp[g]+t);\n        else dp[i]=min(dp[i],2*t);\n    }\n    cout<<dp[n-1]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto &\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\nlint x[100020];\n\nlint dp[2020];\n\nlint brute(){\n    rep(i, n+1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    for(int i = 0; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            chmin(dp[j], dp[i] + (x[i+1] - x[i]) + max<lint>(t, (x[j] - x[i+1]) * 3));\n        }\n    }\n    return dp[n] + (e - x[n]);\n}\n\nint main() {\n    cin >> n >> e >> t;\n    rep(i, n) cin >> x[i+1];\n\n    cout << brute() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[100001];\t//1-indexed, x[0] = 0\nint dp[100001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値 - x[i], Xiのコインは既に回収済み\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 1; i <= n; i++) {\n\t\tif (2 * (x[i] - x[1]) > t) {\n\t\t\tdp[i] = 2 * (x[i] - x[1]);\n\t\t}\n\t}\n\t\n\tfor (i = 1; i <= n; i++) {\n\t\tint st = -1, ed = i, mid;\t//xxxooo, (st, ed]\n\t\twhile (ed - st >= 2) {\n\t\t\tmid = (st + ed) / 2;\n\t\t\tif (2 * (x[i] - x[mid + 1]) <= t) ed = mid;\n\t\t\telse st = mid;\n\t\t}\n\t\tdp[i] = min(dp[i], dp[ed] + t);\n\t}\n\t\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int>x(N);\n\trep(i, N)cin >> x[i];\n\tsort(ALL(x));\n\n\tint ans = x[0] + E - x[N-1];\n\tint xpos = 0;\n\twhile (xpos < N) {\n\t\tint nowpos = x[xpos];\n\t\twhile (xpos < N - 1) {\n\t\t\tint D = x[xpos + 1] - nowpos;\n\t\t\tif (max(D * 3, T + D) <= 2 * T + D)xpos++;\n\t\t\telse break;\n\t\t}\n\t\tint endpos = x[xpos++];\n\t\tint D = endpos - nowpos;\n\t\tans += min(max(D * 3, T + D), 2 * T + D);\n\t\tif(xpos < N)ans += x[xpos] - x[xpos - 1];\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V> v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return LLONG_MAX;\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nll dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,E,T;\n    cin >> n >> E >> T;\n    vl vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    segtree<ll> st(vl(n,0));\n    dp[0] = 0;\n    st.range(0,1,-2*vec[0]);\n    rep(i,n){\n        int id = lower_bound(all(vec),vec[i]-T/2)-vec.begin();\n        if(id == 0){\n            dp[i+1] = dp[id]+T;\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n            // cout << \"OO \" << i+1 << \" \" << dp[i+1]-2*vec[i+1] << \"\\n\";\n            continue;\n        }else if(id <= i){\n            dp[i+1] = dp[id]+T;\n        }\n        // cmn(dp[i+1],st.query(0,i)+2*vec[i]);\n        // show(st.query(0,i+1));\n        if(i < n-1){\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n        }\n    }\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << \"\\n\";\n    // }\n    cout << dp[n]+E << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    for (int j=0;j<=i-2;j++)\n      {   \n        long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-a[i]-a[j+1],h-a[j+1])+a[i]-a[j+1]);\n      }\n    }  \n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nint T;\nint a[maxn]; \nint q[maxn];\nlong long f[maxn];\n\n\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  long long mn=2e9;\n  int r=0; int l=0;\n  for (int i=1;i<=n;i++)\n  {\n    r++;\n    q[r]=i;\n    while (2*(a[i]-a[q[l]])>=T)\n      {\n        mn=min(mn,f[q[l]-1]-2*a[q[l]]);\n        l++;\n      }\n    f[i]=f[q[l]-1]+T;\n    f[i]=min(f[i],2*a[i]+mn);\n  }\n  cout<<f[n]+e<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    for (int j=0;j<=i-2;j++)\n      {   \n        long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-(a[i]-a[j+1]),h-a[j+1])+a[i]-a[j+1]);\n      }\n    }  \n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP(x) cerr << #x << \" = \" << (x) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent=false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n\ntemplate<typename T = int> inline T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> inline vector<T> in(int n) { vector<T> xs(n); rep(i, n) cin >> xs[i]; return xs; }\ntemplate<typename T = int> inline vector<vector<T>> in(int n, int m) { vector<vector<T>> xs(n, vector<T>(m)); rep(i, n) rep(j, m) cin >> xs[i][j]; return xs; }\n\nint main(void) {\n    LL N, E, T;\n    cin >> N >> E >> T;\n    VLL xs = in<LL>(N);\n\n    if (N > 2000) return -1;\n\n    VLL dp(N, INFL);\n    rrep(i, N) {\n        {\n            LL t = T;\n            if (i + 1 < N) t += dp[i + 1] + (xs[i + 1] - xs[i]);\n            MINUD(dp[i], t);\n        }\n\n        for (int j = i + 1; j < N; j++) {\n            LL d = xs[j] - xs[i];\n            LL m = d * 2;\n            LL k = max(0LL, T - m);\n            LL t = m + k + d;\n\n            if (j + 1 < N) t += dp[j + 1] + (xs[j + 1] - xs[j]);\n            MINUD(dp[i], t);\n        }\n    }\n\n    LL ans = dp[0] + xs[0] + E - xs[N - 1];\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\ntypedef pair<LL, int> pli;\n\nint N, E, T;\nint p[100005];\nLL dp[100005];\npriority_queue <pli, vector<pli>, greater<pli> > dpmin, dpmns;\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d%d%d\", &N, &E, &T);\n    for(int i = 1; i <= N; i++) scanf(\"%d\", &p[i]);\n\n    int pos = 1;\n    dpmin.push({0, 0});\n    for(int i = 1; i <= N; i++)\n    {\n        while(2 * (p[i] - p[pos]) >= T)\n        {\n            dpmns.push({dp[pos - 1] - 2LL * p[pos], pos});\n            pos++;\n        }\n\n        while(!dpmin.empty() && dpmin.top().second < pos - 1)\n            dpmin.pop();\n\n        dp[i] = dpmin.top().first + T;\n        pli x = {0, 0};\n        if(!dpmns.empty())  dp[i] = min(dp[i], 2LL * p[i] + dpmns.top().first), x = dpmns.top();\n\n        dpmin.push({dp[i], i});\n    }\n\n    LL ans = 1LL * dp[N] + 1LL * E;\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <unistd.h>\n\n\n#define ll long long\n#define lst(x) x.size()-1\n#define ld long double\n#define pr pair<ll,ll>\n#define loop(i,n) for(ll i=0 ; i<n ; ++i)\n#define rep(i,x,n) for(ll i=x ; i<=n ; ++i)\n#define iteloop(type,data,name,it) for(type<data>::iterator it=name.begin() ;it!=name.end() ; ++it)\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<typename T>\nusing os = tree<T, null_type, less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nconst ll N=2e3+5,M=1e1+5,MOD=1e9+7,OO=1e9;\nint pos[N],n,t,e;\nll memo[N][N];\nll calc(int cur,int frst){\n    int d=pos[cur]-pos[frst];\n    int res=0;\n    if(d*2<t){\n        res+=t-2*d;\n    }\n    return res+2*d;\n}\nint main(){\n    cin.sync_with_stdio(false), cin.tie(0) , cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"rt\" , stdin);\n    // freopen(\"in.txt\", \"wt\" , stdout);\n#endif // ONLINE_JUDGE\n    cin>>n>>e>>t;\n    loop(i,n){\n        cin>>pos[i];\n    }\n    for(int cur=n-1 ; ~cur ; cur--){\n        for(int frst=cur ; ~frst ; frst--){\n            if(cur==n-1){\n                memo[cur][frst]=calc(cur,frst)+memo[cur+1][cur+1];\n            }else {\n//                if(cur==1 && frst==0){\n//                    cout<<memo[cur + 1][frst] + pos[cur + 1] - pos[cur]<<endl;\n//                    cout<<calc(cur, frst) + memo[cur + 1][cur + 1]<<endl;\n//                }\n                memo[cur][frst] = min(memo[cur + 1][frst] ,\n                                      calc(cur, frst) + memo[cur + 1][cur + 1])+pos[cur + 1] - pos[cur];\n            }\n          //  cout<<cur<<\" \"<<frst<<\" \"<<memo[cur][frst]<<endl;\n        }\n    }\n  //  cout<<memo[0][0]<<endl;\n    cout<<memo[0][0]+e-pos[n-1]+pos[0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nint N, E, T;\nvector<int> X;\nvector<ll> dp;\n\nll f(int i, int j){\n    return dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    cin >> N >> E >> T;\n    X.assign(N + 1, 0);\n    rep(i, 1, N + 1) cin >> X[i];\n    \n    // i\n    dp.assign(N + 1, 1LL << 60);\n    dp[0] = 0;\n    rep(i, 1, N + 1){\n        \n        int l = 0; int r = i - 1;\n        while(l + 5 < r){\n            int ml = (2 * l + r) / 3;\n            int mr = (l + 2 * r) / 3;\n            if(f(i, ml) < f(i, mr)){\n                r = mr;\n            }\n            else{\n                l = ml;\n            }\n        }\n        rep(j, l, r + 1){\n            dp[i] = min(dp[i], f(i, j));\n        }\n        \n        \n//        rep(j, i){\n//            dp[i] = min(dp[i], dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1]);\n//        }\n    }\n    \n    ll ret = dp[N] + (E - X[N]);\n    \n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define NMAX 100005\n\nll t[4*NMAX], a[NMAX];\nll n, e, T;\nvoid upd(int i, int s, int e, int indx, ll val){\n\tif(s == e){\n\t\tt[i] = val;\n\t\treturn;\n\t}\n\tint m = (s + e)/2;\n\tif(indx <= m) upd(i*2, s, m, indx, val);\n\telse upd(i*2+1, m+1, e, indx, val);\n\tt[i] = min(t[i*2], t[i*2+1]);\n}\n\nll query(int i, int s, int e, int l, int r){\n\tif(s >= l & e <= r){\n\t\treturn t[i];\n\t}\n\tif(s > r || e < l) return LONG_LONG_MAX;\n\tint m = (s + e)/2;\n\treturn min(query(i*2, s, m, l, r), query(i*2+1, m+1, e, l, r));\n}\n\nint main(){\n\tcin>>n>>e>>T;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tll dp[n+1]; dp[n] = 0; dp[n-1] = T; upd(1, 0, n-1, n-1, 2*a[n-1]);\n\tfor(int i = n-2; i >= 0; i--){\n\t\tdp[i] = dp[i+1] + T;\n\t\tll sv = (T + 2LL*a[i] + 1)/2LL;\n\t\tint indx = lower_bound(a + i, a + n, sv) - a;\n\t\t//cout<<\"INDX: \"<<i<<\" \"<<indx<<endl;\n\t\tif(indx-1 >= i) dp[i] = min(dp[i], dp[indx] + max(2*(a[indx-1]-a[i]), T));\n\t\tif(indx < n) dp[i] = min(dp[i], query(1, 0, n-1, indx, n-1) - 2*a[i]);\n\t\tupd(1, 0, n-1, i, dp[i+1] + 2*a[i]);\n\t\t//cout<<\"UPD : \"<<i<<\" : \"<<dp[i+1] + 2*a[i]<<endl;\n\t\t//cout<<\"DP \"<<i<<\" \"<<dp[i]<<endl;\n\t\t//dp[i] = min(dp[i], dp[indx+1] + max(2*(a[indx]-a[i]), T));\n\t}\n\tcout<<dp[0] + e<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[100003];\nLL dp[100003];\nLL mn1[100003], mn2[100003];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tmn1[0]=mn2[0]=0;\n\t/*for(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}*/\n\tfor(i=1;i<=n;i++){\n\t\t//rintf(\"%d %d %d\\n\",i,mn1[i-1],mn2[i-1]);\n\t\tdp[i]=dp[mn1[i-1]]+max(2*(x[i]-x[mn1[i-1]+1]),(LL)t);\n\t\tdp[i]=min(dp[i],dp[mn2[i-1]]+max(2*(x[i]-x[mn2[i-1]+1]),(LL)t));\n\t\tmn1[i]=dp[mn1[i-1]]<dp[i] ? mn1[i-1]:i;\n\t\tmn2[i]=(dp[mn2[i-1]]-2*x[mn2[i-1]+1]<dp[i]-2*x[i+1]) ? mn2[i-1]:i;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[2001];\t//1-indexed, x[0] = 0\nint dp[2001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値, Xiのコインは既に回収済み\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j <= n; j++) {\t//X_i -> X_i+1 -> X_j -> X_i+1 -> X_j\n\t\t\tint cst;\n\t\t\tif (2 * (x[j] - x[i + 1]) > t) { cst = 3 * (x[j] - x[i + 1]) + (x[i + 1] - x[i]); }\n\t\t\telse { cst = t + x[j] - x[i]; }\n\t\t\tdp[j] = min(dp[j], dp[i] + cst);\n\t\t}\n\t}\n\t\n//\tfor (i = 0; i <= n; i++) { cout << dp[i] << endl; }\n\t\n\tcout << dp[n] + e - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint n;\nll c[N],f[N],s[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline void add(int x,ll y) {\n    while(x) c[x]=min(c[x],y),x-=(x&-x);\n}\ninline ll query(int x) {\n    ll ret=1LL<<60;\n    while(x<=n+1) ret=min(ret,c[x]),x+=(x&-x);\n    return ret;\n}\nint main() {\n    int E,T;\n    ll la=1LL<<60;\n    cin>>n>>E>>T;\n    for(int i=1;i<=n;i++) s[i]=gi();\n    memset(c,127/3,sizeof(c));\n    f[0]=0,f[1]=s[1]+T;\n    for(int i=0;i<2;i++) add(i+1,f[i]-s[i]);\n    for(int i=2,j=0;i<=n;i++) {\n\twhile(2*(s[i]-s[j+1])>T)\n\t    la=min(la,f[j]-s[j]-2*s[j+1]),++j;\n\tf[i]=min(la+3*s[i],query(j+1)+T+s[i]);\n\tadd(i+1,f[i]-s[i]);\n    }\n    cout<<f[n]+E-s[n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j <= n; ++j) {\n      dp[j] = min(dp[j], dp[i] + x[j] - x[i] + (ll)t * (j - i));\n      ll extra = max(0LL, t - 2 * (x[j] - x[i + 1]));\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n\nconst ll maxn=100003;\n\nll pos,n,T,E,x[maxn],mn=0x3f3f3f3f3f3f3f3f,f[maxn];\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&E,&T);\n\tfor(ll i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x[i]);\n\t\twhile(pos<i&&2*(x[i]-x[pos+1])>T){\n\t\t\tmn=min(mn,f[pos]-2*x[pos+1]);\n\t\t\t++pos;\n\t\t}\n//\t\tprintf(\"%lld %lld !\\n\",pos,f[pos]+T);\n\t\tf[i]=min(mn+2*x[i],f[pos]+T);\n\t}\n\tprintf(\"%lld\\n\",f[n]+E);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nconst int N=1e5+5;\nconst long long inf=2e12+7;\nlong long dp[N],dp1[4*N],lazy[4*N],pos[N];\nvoid upd(int idx,int l,int r,int lef,int rig,int val){\n\tif(l>rig||r<lef){\n\t\treturn;\n\t}\n\tif(l>=lef&&r<=rig){\n\t\tif(dp1[idx]<=val){\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif(dp1[idx]>val){\n\t\t\t\tlazy[idx]=val;\n\t\t\t\tdp1[idx]=val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif(lazy[idx]!=inf){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\tlazy[idx]=inf;\n\t}\n\tupd(2*idx,l,(l+r)/2,lef,rig,val);\n\tupd(2*idx+1,(l+r)/2+1,r,lef,rig,val);\n\tdp1[idx]=max(dp1[2*idx],dp1[2*idx+1]);\n}\nlong long getans(int idx,int l,int r,int pos1){\n\tif(l>pos1||r<pos1){\n\t\treturn inf;\n\t}\n\tif(l==r){\n\t\treturn dp1[idx];\n\t}\n\tif(lazy[idx]!=inf){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\tlazy[idx]=inf;\n\t}\n\treturn min(getans(2*idx,l,(l+r)/2,pos1),getans(2*idx+1,(l+r)/2+1,r,pos1));\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,end,time,i,j,k;\n\tcin>>n>>end>>time;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>pos[i];\n\t}\n\tfor(i=1;i<N;i++){\n\t\tdp[i]=inf;\n\t}\n\tfor(i=1;i<4*N;i++){\n\t\tdp1[i]=inf;\n\t}\n\tfor(i=1;i<4*N;i++){\n\t\tlazy[i]=inf;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(i!=0){\n\t\t\tdp[i]=min(dp[i],getans(1,1,n,i)+3*pos[i]);\n\t\t}\n\t\tk=upper_bound(pos+1,pos+1+n,(time+2*pos[i+1])/2)-pos-1;\n\t\tdp[k]=min(dp[k],dp[i]+time+pos[k]-pos[i]);\n\t\tif(k!=n){\n\t\t\tupd(1,1,n,k+1,n,dp[i]-2*pos[i+1]-pos[i]);\n\t\t}\n\t}\n\tdp[n]=min(dp[n],getans(1,1,n,n)+3*pos[n]);\n\tcout<<dp[n]+end-pos[n];\n}"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n    #include <iostream>\n    #include <algorithm>\n    #include <cstring>\n    #include <set>\n    #define N 100010\n    #define INF (1LL << 60)\n    #define LL long long\n    using namespace std;\n    int n, e, t, x[N];\n    LL dp[N], preMin[N];\n    set<LL> st;\n     \n    int main() {\n    \tscanf(\"%d%d%d\", &n, &e, &t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\tscanf(\"%d\", &x[i]);\n    \t}\n    \t\n    \tdp[0] = 0;\n    \tx[0] = 0;\n    \tint last = 0;\n    \tpreMin[0] = - 2 * x[1];\n    \tst.insert(t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n    \t\t\tst.erase(dp[last] - x[last] + t);\n    \t\t\t++last;\n    \t\t}\n\t\t\tdp[i] = (((LL)1)<<50);\n\t\t\tif(last - 1 >= 0) dp[i] = min(dp[i], preMin[last - 1] + 3LL * x[i]);\n\t\t\tif(!st.empty()) dp[i] = min(dp[i], *st.begin() + x[i]);\n    \t\t//if (last - 1 >= 0) dp[i] = min(preMin[last - 1] + 3LL * x[i], *st.begin() + x[i]);\n    \t\t//else dp[i] = *st.begin() + x[i];\n    //cout << last << ' ' << preMin[last - 1] << ' ' << *st.begin() << ' ' << dp[i] << endl;\n    \t\tif (i < n) st.insert(dp[i] - x[i] + t);\n    \t\tpreMin[i] = min(dp[i] - x[i] - 2LL * x[i + 1], preMin[i - 1]);\n    //cout << dp[i] << ' ';\n    \t}\n    //cout << endl;\n    \t\n    \tprintf(\"%lld\\n\", dp[n] + e - x[n]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int len = 1e5+5;\nconst ll inf = 1e15;\nint arr[len], n, en, t;\nll dp[len];\n\nll solve(int i){\n    if (i == n+1) return 0;\n    if (dp[i] != -1) return dp[i];\n\n    ll ans = inf;\n    for (int j = i; j <= n; j++){\n        int dis = (arr[j]-arr[i]);\n        ans = min(ans, 1LL*max(2*dis, t)+(arr[j+1]-arr[i])+solve(j+1));\n    }\n\n    //printf(\"dp[%d] = %lld\\n\", i, ans);\n    return dp[i] = ans;\n}\n\nint main(){\n    scanf(\"%d %d %d\", &n, &en, &t);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &arr[i]);\n    arr[n+1] = en;\n\n    for (int i = 1; i <= n; i++)\n        dp[i] = -1;\n\n    printf(\"%lld\\n\", solve(1)+arr[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint p[100001],s[100001],l,r;\nlong long f[100001];\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tlong long z=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\ts[++r]=i;\n\t\tfor(;2*(p[i]-p[s[l]])>=t;l++)\n\t\t\tz=min(z,f[s[l]-1]-2*p[s[l]]);\n\t\tf[i]=f[s[l]-1]+t;\n\t\tf[i]=min(f[i],2*p[i]+z);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    if(n > 2000) return 1;\n    sort(x, x + n + 1);\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << e - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\nconst int mod=1000000007;\nconst int mod1=998244353;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,T,e;cin >> n >> e >> T;\n\tvector<ll> x(n);\n\trep(i,n) cin >> x.at(i);\n\tll ans=x.at(0);\n\tvector<bool> b(n);\n\trep(i,n){\n\t\tif(i==n-1){\n\t\t\tif(!b.at(i)) ans+=T;\n\t\t\tans+=e-x.at(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(b.at(i)){\n\t\t\tans+=x.at(i+1)-x.at(i);\n\t\t}\n\t\telse{\n\t\t\tif((x.at(i+1)-x.at(i))*2-T>=T) ans+=T;\n\t\t\telse{\n\t\t\t\tint k=i;\n\t\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\t\tif((x.at(j)-x.at(i))*2<T){\n\t\t\t\t\t\tk=j;\n\t\t\t\t\t\tb.at(j)=true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((T-(x.at(j-1)-x.at(i))*2)>(x.at(j)-x.at(j-1))*2-T){\n\t\t\t\t\t\t\tk=j;\n\t\t\t\t\t\t\tb.at(j)=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=(x.at(k)-x.at(i))*2+max(T-(x.at(k)-x.at(i))*2,(ll)0);\n\t\t\t}\n\t\t\tans+=x.at(i+1)-x.at(i);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg2[id].first==0||seg2[id].first>val){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<int(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n#define MAX_N (1<<17) // 10^5\n\nstruct SegTree {\n  long long seg[MAX_N*2-1];\n  SegTree() {\n    for (int i=MAX_N*2-2; i>=0; i--) seg[i] = INF;\n  }\n\n  void update(int i, long long x) {\n    i += MAX_N-1;\n    if (seg[i] <= x) return;\n    seg[i] = x;\n    while (i > 0) {\n      i = (i-1) / 2;\n      seg[i] = min(seg[i*2+1], seg[i*2+2]);\n    }\n  }\n  long long query(int a, int b, int k=0, int l=0, int r=MAX_N) {\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[k];\n    return min(\n      query(a, b, k*2+1, l, (l+r)/2),\n      query(a, b, k*2+2, (l+r)/2, r)\n    );\n  }\n};\n\nint N, E, T;\nint X[100002];\nSegTree dp, f;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> T;\n  for (int i=1; i<=N; i++) cin >> X[i];\n\n  dp.update(0, 0);\n  f.update(0, -2LL*X[1]);\n  int l = 0;\n  for (int i=1; i<=N; i++) {\n    long long m = INF;\n    while (l < N && X[l+1] < X[i] - T/2) l++;\n    m = min(m, dp.query(l, i) + T);\n    m = min(m, f.query(0, l) + 2*X[i]);\n    f.update(i, m - 2LL*X[i+1]);\n    dp.update(i, m);\n  }\n  cout << dp.query(N, N+1) + E << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\tvector<int> suf(n + 1, inf);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif(j == n - 1) {\n\t\t\t\tint now = max(k, 2 * (a[j] - a[i])) + (a[j] - a[i]);\n\t\t\t\tsuf[i] = min(suf[i], now);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint now = max(k, 2 * (a[j] - a[i])) + (a[j + 1] - a[i]) + suf[j + 1];\n\t\t\t\t// cout << \"X \" << i << \" \" << now << endl;\n\t\t\t\tsuf[i] = min(suf[i], now);\n\t\t\t}\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MN = 100002;\n\nint N, E, T;\nvector<ll> X;\nvector<ll> dp;\n\nstruct BIT {\n    vector<ll> tree;\n    void init() {\n        tree = vector<ll>(4*MN, 1e18);\n    }\n    void upd(int idx, ll val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = val;\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = min(tree[2*n], tree[2*n + 1]);\n    }\n    ll quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 1e18;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        ll L = quer(a, b, l, m, 2*n);\n        ll R = quer(a, b, m + 1, r, 2*n + 1);\n        return min(L, R);\n    }\n} bit1, bit2;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &E, &T);\n\n    X.push_back(0);\n    for(int i = 0; i < N; i++) {\n        int t; scanf(\"%d\", &t);\n        X.push_back(t);\n    }\n\n    dp.resize(X.size());\n    dp[X.size() - 1] = E - X.back();\n\n    bit1.init();\n    bit2.init();\n    bit1.upd(X.size() - 1, X.back() + dp[X.size() - 1], 0, MN - 1, 1);\n    bit2.upd(X.size() - 1, 3*X.back() + dp[X.size() - 1], 0, MN - 1, 1);\n\n    for(int i = (int)X.size() - 2; i >= 0; i--) {\n        int s = i + 1, e = (int)X.size() - 1;\n        int x = i;\n        while(s <= e) {\n            int m = (s + e)>>1;\n\n            if(X[m] - X[i + 1] <= T/2) {\n                x = m;\n                s = m + 1;\n            }\n            else e = m - 1;\n        }\n\n        dp[i] = min(-X[i] + bit1.quer(i + 1, x, 0, MN - 1, 1) + T, -X[i] - 2*X[i + 1] + bit2.quer(x + 1, MN - 1, 0, MN - 1, 1));\n        bit1.upd(i, X[i] + dp[i], 0, MN - 1, 1);\n        bit2.upd(i, 3*X[i] + dp[i], 0, MN - 1, 1);\n    }\n\n    cout << dp[0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nint n,e,T;\nll dp[100010];\nint dis[100010];\nll inf=1LL<<60;\n\nint main() {\n    //freopen(\"hi.txt\", \"r\", stdin);\n    scanf(\"%d%d%d\",&n,&e,&T);\n    /// dp[x] = dp[i] + 3(dis[x]-dis[i+1]) + (dis[i+1]-dis[i]) + max(0,T-2(dis[x]-dis[i+1]))\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&dis[i]);\n    }\n    for(int x=1;x<=n;x++){\n        dp[x]=inf;\n        for(int i=0;i<x;i++){\n            ll ans=dp[i] +3LL*(dis[x]-dis[i+1]) +(dis[i+1]-dis[i]);\n            ans+=max(0LL,(ll)T-2*(dis[x]-dis[i+1]));\n            dp[x]=min(dp[x],ans);\n        }\n        //printf(\"dp %d = %lld\\n\",x,dp[x]);\n    }\n    printf(\"%lld\\n\",dp[n]+e-dis[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N = 2e5 + 10;\nconst LL inf = 1e18;\n\nint n;\nLL E, t, a[N], dp[N], pre[N];\n\nint main() {\n\tcin >> n >> E >> t;\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", &a[i]);\n\tdp[0] = 0;\n\tpre[0] = inf;\n\tfor (int i = 1, j = 1; i <= n; ++i) {\n\t\tdp[i] = inf;\n\t\twhile (2 * (a[i] - a[j]) > t) ++j;\n\t\tdp[i] = min(dp[i], dp[j - 1] + t);\n\t\tdp[i] = min(dp[i], 2 * a[i] + pre[j - 1]);\n\t\tpre[i] = min(pre[i - 1], dp[i - 1] - 2 * a[i]);\n\t}\n\tprintf(\"%lld\\n\", dp[n] + E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[100003];\nLL dp[100003];\nLL mn1[100003], mn2[100003];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tmn1[0]=mn2[0]=0;\n\t/*for(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}*/\n\tfor(i=1;i<=n;i++){\n\t\t//rintf(\"%d %d %d\\n\",i,mn1[i-1],mn2[i-1]);\n\t\tdp[i]=dp[mn1[i-1]]+max(2*(x[i]-x[mn1[i-1]+1]),(LL)t);\n\t\tdp[i]=min(dp[i],dp[mn2[i-1]]+max(2*(x[i]-x[mn2[i-1]+1]),(LL)t));\n\t\tmn1[i]=dp[mn1[i-1]]<dp[i] ? mn1[i-1]:i;\n\t\tmn2[i]=((dp[mn2[i-1]]-2*x[mn2[i-1]+1])<(dp[i]-2*x[i+1])) ? mn2[i-1]:i;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100005\n#define cmax(_i,_j) ((_i)<(_j)?(_i)=(_j):0)\n#define cmin(_i,_j) ((_i)>(_j)?(_i)=(_j):0)\nusing namespace std;\nnamespace runzhe2000\n{\n\ttypedef long long ll;\n\tint q[N], head, tail; ll f[N], x[N];\n\tvoid main()\n\t{\n\t\tint n, E, T; scanf(\"%d%d%d\",&n,&E,&T);\n\t\tfor(int i = 1; i <= n; i++) scanf(\"%lld\",&x[i]); sort(x+1,x+1+n);\n\t\t\n\t\tll pre = 1ll<<60; int cur = 1; head = 1;\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(; 2*(x[i]-x[cur]) >= T; cur++)\n\t\t\t{\n\t\t\t\tcmin(pre,f[cur-1]-2*x[cur]);\n\t\t\t\tif(head <= tail && q[head] == cur) head++;\n\t\t\t}\n\t\t\tfor(; head <= tail && f[q[tail]-1]-x[q[tail]] >= f[i-1]-x[i]; --tail);\n\t\t\tq[++tail] = i;\n\t\t\t\n\t\t\tf[i] = pre + 2 * x[i];\n\t\t\tif(head <= tail) cmin(f[i], f[q[head]-1]-x[q[head]]+x[i]+T);\n\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]+E);\n\t}\n}\nint main()\n{\n\trunzhe2000::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DIF(i) pos[i]-pos[i-1]\nusing namespace std;\nlong long dp[100005],n,e,t,pos[1000005];\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&pos[i]);\n\tdp[0]=0;\n\tdp[1]=(long long)1e18;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=min(dp[i-1]+DIF(i)+t,dp[i]);\n\t\tdp[i+1]=dp[i-1]+DIF(i)+DIF(i+1)+max(t,(DIF(i+1))*2);\n\t}\n\t//for(int i=1;i<=n;i++)printf(\"%lld\\n\",dp[i]);\n\tprintf(\"%lld\",dp[n]+e-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  const int N = 100000 + 10;\n  int n;\n  lli e, t;\n  while (cin >> n >> e >> t) {\n    lli x[N];\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i];\n    }\n    x[n] = e;\n    lli dp[N]; // 0~(i-1)まで全て回収してiにいる。\n    fill(dp, dp + N, 1LL << 60);\n    dp[0] = 0;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j <= n; ++j) {\n        lli cost = max(t, 2 * (x[j - 1] - x[i]));\n        dp[j] = min(dp[j], dp[i] + cost);\n      }\n    }\n\n    // for (int i = 0; i <= n; ++i) cout << i << \": \" << dp[i] << endl;\n    \n    cout << dp[n] + e << endl;\n    // cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <unistd.h>\n\n\n#define ll long long\n#define lst(x) x.size()-1\n#define ld long double\n#define pr pair<ll,ll>\n#define loop(i,n) for(ll i=0 ; i<n ; ++i)\n#define rep(i,x,n) for(ll i=x ; i<=n ; ++i)\n#define iteloop(type,data,name,it) for(type<data>::iterator it=name.begin() ;it!=name.end() ; ++it)\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<typename T>\nusing os = tree<T, null_type, less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nconst ll N=1e5+5,M=1e1+5,MOD=1e9+7,INF=1e18;\n\nint pos[N],n,t,e;\nll memo[N];\nll seg[4*N],lazy[4*N];\n\nint getMid(int st,int en){\n    return (st+en)/2;\n}\nll build(int st,int en,int frst){\n    if(st==en){\n        return seg[frst]=0;\n    }\n    int mid=getMid(st,en);\n    return seg[frst]=min(build(st,mid,frst*2+1),build(mid+1,en,frst*2+2));\n}\nll getmin(int st,int en,int qs,int qe,int frst){\n    if(qs>qe)return INF;\n    if(lazy[frst]){\n        seg[frst]+=lazy[frst];\n        if(st!=en) {\n            lazy[frst * 2 + 1] += lazy[frst];\n            lazy[frst * 2 + 2] += lazy[frst];\n        }\n        lazy[frst]=0;\n    }\n    if(st>qe || qs>en)return INF;\n    if(st>=qs && en<=qe){\n        return seg[frst];\n    }\n    int mid=getMid(st,en);\n    return min(getmin(st,mid,qs,qe,frst*2+1),getmin(mid+1,en,qs,qe,frst*2+2));\n}\nvoid update(int st,int en,int qs,int qe,ll val,int frst){\n    if(lazy[frst]){\n        seg[frst]+=lazy[frst];\n        if(st!=en) {\n            lazy[frst * 2 + 1] += lazy[frst];\n            lazy[frst * 2 + 2] += lazy[frst];\n        }\n        lazy[frst]=0;\n    }\n    if(st>qe || en<qs)return;\n    if(st<=qs && en>=qe){\n        lazy[frst]+=val;\n        return ;\n    }\n    int mid=getMid(st,en);\n    update(st,mid,qs,qe,val,frst*2+1);\n    update(mid+1,en,qs,qe,val,frst*2+2);\n    seg[frst]=min(seg[frst*2+1],seg[frst*2+2]);\n}\n\nll seg2[4*N];\n\nll build2(int st,int en,int frst){\n    if(st==en){\n        return seg2[frst]=0;\n    }\n    int mid=getMid(st,en);\n    return seg2[frst]=min(build2(st,mid,frst*2+1),build2(mid+1,en,frst*2+2));\n}\nll getmin2(int st,int en,int qs,int qe,int frst){\n    if(qs>qe)return INF;\n    if(st>qe || qs>en)return INF;\n    if(st>=qs && en<=qe){\n        return seg2[frst];\n    }\n    int mid=getMid(st,en);\n    return min(getmin2(st,mid,qs,qe,frst*2+1),getmin2(mid+1,en,qs,qe,frst*2+2));\n}\nll update(int st,int en,int indexToUpdate,ll val,int frst){\n    if(st>indexToUpdate || en<indexToUpdate)return seg2[frst];\n    if(st==en){\n        return seg2[frst]=val;\n    }\n    int mid=getMid(st,en);\n    return seg2[frst]=min(update(st,mid,indexToUpdate,val,frst*2+1),\n                          update(mid+1,en,indexToUpdate,val,frst*2+2));\n}\nint main(){\n    cin.sync_with_stdio(false), cin.tie(0) , cout.tie(0);\n#ifndef ONLINE_JUDGE\n  //  freopen(\"in.txt\", \"rt\" , stdin);\n    // freopen(\"in.txt\", \"wt\" , stdout);\n#endif // ONLINE_JUDGE\n    cin>>n>>e>>t;\n    loop(i,n){\n        cin>>pos[i];\n    }\n    memo[0]=t;\n\n    build2(0,n-1,0);\n    build(0,n-1,0);\n\n    update(0,n-1,0,t,0);\n    update(0,n-1,0,0,t,0);\n\n    rep(i,1,n-1){\n        int st=0,en=i-1;\n        while(st<=en){\n            int mid=getMid(st,en);\n            if(pos[i]-pos[mid+1]>t){\n                st=mid+1;\n            }else{\n                en=mid-1;\n            }\n        }\n     //   cout<<st<<endl;\n        memo[i]=getmin(0,n-1,0,st-1,0);\n\n     //   cout<<i<<\" \"<<memo[i]<<endl;\n\n        // to decide if it's better to return to the begining\n        memo[i]=min(memo[i],(ll)max(t,2*(pos[i]-pos[0])));\n       // cout<<i<<\" \"<<memo[i]<<endl;\n        memo[i]=min(memo[i],getmin2(0,n-1,st,i-1,0)+t);\n        memo[i]=min(memo[i],t+memo[i-1]);\n       // cout<<i<<\" \"<<memo[i]<<endl;\n\n        update(0,n-1,0,i-1,2*(pos[i+1]-pos[i]),0);\n        update(0,n-1,i,i,memo[i],0);\n        update(0,n-1,i,memo[i],0);\n\n    }\n\n    cout<<memo[n-1]+e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tint pnt=n+1;\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\twhile (2*(A[pnt-1]-A[i])>=T) pnt--;\n\t\tfor (int j=i; j<=n; j++){\n\t\t\tll cost=T;\n\t\t\tif (j>=pnt) cost=(A[j]-A[i])*2;\n\t\t\tdp[i]=min(dp[i], cost+dp[j+1]);\n\t\t}\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n} \nconst int N = 1e5+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, t, e, px[N];\nint64 f[N], p = 1, w = INF;\nint main()\n{\n    n = read(), e = read(), t = read();\n    for(int i = 1; i <= n; ++i) px[i] = read();\n    for(int i = 1; i <= n; ++i)\n    {\n        if(2*(px[i]-px[p]) >= t) w = min(f[p-1]-2*px[p]-px[p-1], w), ++p;\n        f[i] = min(f[i-1]+px[i]-px[i-1]+t, w+3ll*px[i]);\n        // for(int j = 1; j <= i; ++j)\n        //     if(2*(px[i]-px[j]) >= t) \n        //         f[i] = min(f[i], f[j-1]-2*px[j]-px[j-1]+3ll*px[i]);\n    }\n    printf(\"%lld\\n\", f[n]+e-px[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005];\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tassert(n<=2000);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=x[0]+max(t,2ll*(x[i]-x[0]))+x[i]-x[0];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tfor (int j=0;j<i-1;j++) mem[i]=min(mem[i],mem[j]+(x[j+1]-x[j])+max(t,2ll*(x[i]-x[j+1]))+x[i]-x[j+1]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    deque<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = -LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = T + 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (cval <= pval) {\n                d.pop_back();\n                continue;\n            }\n            int64_t prevSteady = T + 2 * X[p + 1];\n            time = max(prevSteady, (int64_t) (2 * X[i])) + cval - pval;\n            if (time > currSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = -LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (SZ(d) > 1 && 2 * X[i] >= d[1].second) {\n            d.pop_front();\n        }\n        d.front().second = -LINF;\n        int p = d.front().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n\n  vector<long long> x(n);\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<int> t_min;\n  t_min.push_back(0);\n  long long w = 1ll<<57;\n  long long add = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      w = min(w, dp[j]);\n      j++;\n    }\n    while(t_min.size() && t_min.front() < j){\n      t_min.pop_front();\n    }\n\n    dp[i+1] = min(dp[i+1], w+add);\n    if(t_min.size()) dp[i+1] = min(dp[i+1], dp[t_min.front()] + t);\n\n    add += 2*(x[i+1] - x[i]);\n    while(t_min.size() && dp[t_min.back()] >= dp[i+1]){\n      t_min.pop_back();\n    }\n    t_min.push_back( i+1 );\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iterator>\n#include <array>\n#include <functional>\n#include <utility>\n#include <cstdio>\n#include <map>\n#include <vector>\nnamespace XX\n{   \n    template<template<typename> class Compare, typename T>\n    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}\n    template<typename Compare, typename T>\n    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}\n\n    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}\n    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}\n\n    template<typename T>\n    struct Mapper\n    {\n        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n        T rev(int idx){return rtable[idx + 1];}\n        std::map<T, int> table;\n        std::map<int, T> rtable;\n    };\n\n    template<typename T, int S>\n    struct ReferenceArray\n    {\n        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n        int size()const{return _ptr.size();}\n        It begin()const{return {_ptr.begin()};}\n        It end()const{return {_ptr.end()};}\n        T& operator[](int idx)const{return *_ptr[idx];}\n        mutable std::array<T*, S> _ptr;\n    };\n    template<typename T, typename... Args> \n    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\n    struct Range\n    {   \n        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n        Range(int ee):b(0),e(ee){}\n        Range(int bb, int ee):b(bb), e(ee){}\n        It begin(){return {b, (b < e? 1: -1)};}\n        It end(){return {e, 0};}\n        int b, e;\n    };\n\n}\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\ntemplate<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}\ntemplate<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}\nusing XX::UP; //(x,y) comp\nusing RG = XX::Range;\nusing XX::MAKEV;\nusing XX::Mapper;\n//template\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\n#include <queue>\nusing namespace std;\n\ntypedef long long int ll;\n\n\nint xs[200009];\n\nint main()\n{\n    int N, E, T;\n    RD(N, E, T);\n\n    RDV(xs + 1, xs + N + 1); \n    ll alc = 0;\n\n    pair<ll, ll> best = {0, -1000000000};\n    deque<pair<ll, ll>> que;\n    \n\n    ll last = 0;\n    for(int i: RG(1, N + 1))\n    {\n        int x = xs[i];\n\n        while(que.size() && 2 * (x - que.front().second) >= T)\n        {\n            if(best.first > que.front().first - 2 * (que.front().second - best.second))\n                best = que.front();\n            que.pop_front();\n        }\n\n        ll now = T + last;\n        UMIN(now, best.first + 2 * (x - best.second));\n        if(que.size())\n            UMIN(now, que.front().first + (x - que.front().second) + T);\n\n        while(que.size() && que.back().first > now + x - que.back().second)\n            que.pop_back();\n\n        que.emplace_back(last, x);\n        last = now;\n    }\n\n    WTL(last + E);\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e17;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    int n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    \n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=upper_bound(x,x+n,(x[i]-T))-x;\n        j-=2;\n        if(j>=0){\n            dp[i]=dp2[j]+x[i]*2;\n        }\n        \n        dp[i]=min(dp[i-1]+2*T,dp[i]);\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n       // cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n        \n    }\n    \n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=100110;\n\tconst ll INF=9223372036854775807ll;\n\tint a[N],b[N];\n\tint n,m;\n\tll ans;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=a[n];\n\t\tfor(int i=1,j;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;get_dis(i,j+1)*2<=m;j++);\n\t\t\tans+=m;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n//\tfreopen(\"out\",\"w\",stdout);\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T + (a[i] - a[opt]);\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\twhile(opt + 1 <= i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) < cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tdp[i] = cost(i , opt);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nconst int MAXN = 100010;\nLL x[MAXN], dp[MAXN];\n\nint n; LL t, e;\n\nint main() {\n    GI(n); GLL(e); GLL(t);\n\n    FOR1(i, n) {\n        GLL(x[i]);\n    }\n\n    x[n+1] = e; dp[n+1] = 0; dp[n] = t + (e - x[n]);\n\n    for (int i = n-1; i >= 1; i--) {\n        LL timeToJ = t;\n\n        dp[i] = timeToJ + (x[i+1] - x[i]) + dp[i+1];\n\n        for (int j = i+1; j <= n; j++) {\n            timeToJ += (x[j] - x[j-1]);\n            timeToJ = max(timeToJ, x[j] - x[i] + t);\n            dp[i] = min(dp[i], max(timeToJ, 3 * (x[j] - x[i])) + x[j+1] - x[j] + dp[j+1]);\n        }\n    }\n\n    printf(\"%lld\\n\", dp[1] + x[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 2e9;\nint x[111111], dp[111111], st[333333] = {inf};\nint upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind)\n        return inf;\n    if(l == r)\n        return st[cur] = val;\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    return st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl)\n        return inf;\n    if(l == r)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}\nint32_t main()\n{\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    upd(0, n, 0, 0, -2*x[1]);\n\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if((x[i]-x[j])*2 < t)\n            j--;\n        dp[i] = min(dp[j]+t, mn(0,n,0,j-1,0)+2*x[i]);\n        //cout << i << ' ' << j << ' ' << dp[i] << endl;\n\n        upd(0, n, 0, i, dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nstatic ll dp[1 << 20];\nstatic int pos[1 << 20];\nstatic int s[1 << 20];\nint n,S,T;\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    fi>>n>>S>>T;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    for (int i = 1;i <= n;++i)\n    {\n        pos[i] = pos[i - 1];\n        while (T < 2ll * (s[i] - s[pos[i]])) ++pos[i];\n    }\n    dp[0] = 0;\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = max(0ll,pos[i] - 5);j <= min(i - 1,pos[i] + 5);++j)\n                dp[i] = min(dp[i],dp[j] + s[i] - s[j] + 2ll * (s[i] - s[j + 1]) + max(0ll,1ll * T - 2 * (s[i] - s[j + 1])));\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 1e5 + 7;\nint n, E, T;\nLL f[N], x[N];\nint q[N], hd = 1, tl;\nint main() {\n#ifdef fwat\n#endif\n\tn = gi(), E = gi(), T = gi();\n//\tif(n > 2000) return puts(\"gg\"), 0;\n\tmemset(f, 0x3f, sizeof f); f[0] = 0;\n\trep(i, 1, n) x[i] = gi();\n\tLL mi = 1e18;\n\tq[++tl] = 0;\n\tfor(int i = 1, j = 0; i <= n; ++i) {\n\t\tfor(; j < i && 2 * (x[i] - x[j + 1]) >= T; ++j) Min(mi, f[j] - 2 * x[j + 1]);\n\t\tMin(f[i], mi + 2 * x[i]);\n\t\twhile(hd <= tl && 2 * (x[i] - x[q[hd] + 1]) >= T) ++hd;\n\t\tif(hd <= tl)\n\t\t\tMin(f[i], f[q[hd]] + T);\n\t\tfor(; hd <= tl && f[i] <= f[q[tl]]; --tl);\n\t\tq[++tl] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nVI x;\nVI sl;\nmultiset<in> vclos;\nin bvfar;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,t,e;\n  cin>>n>>e>>t;\n  x.resize(n+2);\n  x[0]=0;\n  x[n+1]=e;\n  forn(i,n)\n    cin>>x[i+1];\n  sl.resize(n+2);\n  sl[0]=0;\n  bvfar=1e18;\n  in nxfar=0;\n  vclos.insert(sl[0]-x[0]);\n  sl[1]=x[1];\n  vclos.insert(sl[1]-x[1]);\n  for(in i=2;i<=n+1;++i){\n    while((x[i-1]-x[nxfar])*2>=t){\n      bvfar=min(bvfar,sl[nxfar]-3*x[nxfar]);\n      vclos.erase(vclos.find(sl[nxfar]-x[nxfar]));\n      ++nxfar;\n    }\n    sl[i]=bvfar+3*x[i-1]+(x[i]-x[i-1]);\n    if(!(vclos.empty()))\n      sl[i]=min(sl[i],*(vclos.begin())+t+x[i]);\n    vclos.insert(sl[i]-x[i]);\n  }\n  cout<<sl[n+1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  vector<ll> dp;\n  rep(i,n+1){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n\n  rep(i,n){\n    reps(j,n-i){\n      chmin(dp[i+j], dp[i] + X[i+1]-X[i] + max(2*(X[i+j]-X[i+1]), t) + X[i+j] - X[i+1]);\n    }\n  }\n  cout<<dp[n] + e - X[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\ntypedef long long LL;\nconst LL INF=1e15+10;\n\nint n;\nLL x[maxn],e,t;\nint ll[maxn],rr[maxn];\nLL mini1[maxn],mini2[maxn];\nLL dp[maxn];\n\nvoid build(int p,int l,int r)\n{\n\tll[p]=l;rr[p]=r;\n\tmini1[p]=mini2[p]=INF;\n\tif (l==r) return;\n\tbuild(p<<1,l,(l+r)>>1);\n\tbuild((p<<1)|1,((l+r)>>1)+1,r);\n\treturn;\n}\n\nvoid update(int p,int pos,LL val,int tp)\n{\n\tif (!tp) mini1[p]=min(mini1[p],val);\n\telse mini2[p]=min(mini2[p],val);\n\tif (ll[p]==rr[p]) return;\n\tif (pos<=rr[p<<1]) update(p<<1,pos,val,tp);\n\telse update((p<<1)|1,pos,val,tp);\n\treturn;\n}\n\nLL getmini(int p,int l,int r,int tp)\n{\n\tif (l>r) return INF;\n\tif (r<ll[p] || rr[p]<l) return INF;\n\tif (l<=ll[p] && rr[p]<=r) \n\t{\n\t\tif (!tp) return mini1[p];\n\t\telse return mini2[p];\n\t}\n\treturn min(getmini(p<<1,l,r,tp),getmini((p<<1)|1,l,r,tp));\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tx[n+1]=e;\n\t\n\tdp[0]=x[1];\n\tbuild(1,0,n);\n\tupdate(1,0,dp[0]-x[1],0);\n\tupdate(1,0,dp[0]-x[1]*3ll,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint tmp=lower_bound(x+1,x+n+1,x[i]-(t>>1))-x;\n\t\tdp[i]=min(getmini(1,0,tmp-2,1)+3ll*x[i],getmini(1,tmp-1,i-1,0)+t+x[i]);\n\t\tdp[i]+=x[i+1]-x[i];\n\t\tupdate(1,i,dp[i]-x[i+1],0);\n\t\tupdate(1,i,dp[i]-x[i+1]*3ll,1);\n\t\t//printf(\"%d %d\\n\",tmp,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\tvl e(N+1,e18);\n\td[0]=0;\n\te[0]=T;\n\tfoor(i,1,N){\n\t\tfor(int j=0;2*(x[i]-x[j+1])>T;++j){\n\t\t\tif(2*(x[i-1]-x[j+1])<=T){\n\t\t\t\te[j]=d[j]+2*(x[i]-x[j+1]);\n\t\t\t}else{\n\t\t\t\te[j]+=2*(x[i]-x[i-1]);\n\t\t\t}\n\t\t}\n\t\tfr(j,i){\n\t\t\tchmin(d[i],e[j]);\n\t\t}\n\t\te[i]=d[i]+T;\n\t}\n\tprint(d[N]+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\t// printf(\"[%d] -> [%d] : %d %d %d\\n\", j, i, f[j], a[i] - a[j], std::max((a[i] - a[j]) << 1, k));\n\t\t\tf[i] = std::min(f[i], f[j] + a[i] - a[j] + std::max((a[i] - a[j + 1]) << 1, k));\n\t\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\nint N;\nll E, T;\nint X[101010];\nint Y[101010];\nll YY[101010];\nll dp[101010][2];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\tY[0] = X[0];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\trep(i, 1, N + 1) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\trep(j, 0, i) {\n\t\t\t// Uターンする\n\t\t\tdp[i][1] = min(dp[i][1], dp[j][0] + (YY[i] - YY[j]) * 3);\n\t\t}\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N - 1][1] + Y[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\nconst int maxn = 1e5 + 100;\nconst ll inf = 1e18;\n\nll x[maxn];\nll dp[maxn], seg[maxn * 4];\n\n\nvoid add(int v, int l, int r, int i, ll val)\n{\n    if(r - l == 1)\n    {\n        seg[v] = val;\n        return ;\n    }\n    int mid = (l + r) / 2;\n    if(i < mid)\n        add(v * 2, l, mid, i, val);\n    else\n        add(v * 2 + 1, mid, r, i, val);\n    seg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\n\nll query(int v, int l, int r, int b, int e)\n{\n    if(e <= l || r <= b)\n        return inf;\n    if(b <= l && r <= e)\n        return seg[v];\n    int mid = (l + r) / 2;\n    return min(query(v * 2, l, mid, b, e), query(v * 2 + 1, mid, r, b, e));\n}\n\nint main()\n{\n    ll n, E, T;\n    cin >> n >> E >> T;\n\n    for(int i = 1; i <= n; i++)\n        cin >> x[i], x[i] *= 2;\n\n    add(1, 0, n + 1, 0, -x[1] * 2);\n\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x + 1, x + n + 1, x[i] - T) - x;\n\n        if(x[j] > x[i] - T)\n            j--;\n\n        dp[i] = min(query(1, 0, n + 1, 0, j) + x[i] * 2, dp[j] + T * 2);\n\n    }\n\n    cout << (dp[n] + E * 2) / 2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\nint n,e,t,x[200000];\nlong long dp[200000];\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tset<pair<long long,int>> s;\n\tfor(long long i=1,j=0,buf=1ll<<40;i<=n;i++)\n\t{\n\t\twhile(t<(x[i]-x[j+1])*2)\n\t\t{\n\t\t\tbuf=min(buf,dp[j]-x[j]-x[j+1]*2);\n\t\t\ts.erase({dp[j]-x[j],j});\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=min(buf+x[i]*3ll,s.begin()->first+x[i]+t);\n\t\t//for(int j=0;j<i;j++)dp[i]=min(dp[i],dp[j]+x[i]-x[j]+max(t,(x[i]-x[j+1])<<1));\n\t\ts.insert({dp[i]-x[i],i});\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long f[100010],c[100010],d[100010];\nint x[100010];\nint n,e,t,T;\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tT=t;\n\tif(t%2)T++;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(c,0x3f,sizeof(c));\n\tmemset(d,0x3f,sizeof(d));\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=min(f[i],f[i-1]+x[i]-x[i-1]+t);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif((x[j]-x[i])*2>=t)f[j]=min(f[j],f[i-1]+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t\telse f[j]=min(f[j],f[i-1]+t-2*(x[j]-x[i])+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t}\n\t}\n\tcout<<f[n]+e-x[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nstruct ST{\nprivate:\n    ll n;\n    vector<pll> dat;\npublic:\n    ST(vector<ll> v){\n        ll sz=v.size();\n        n=1;while(n<sz)n*=2;\n        pll p={inf,inf};\n        dat.resize(2*n-1,p);\n        rep(i,0,sz)dat[i+n-1]={v[i],i};\n        rrep(i,n-2,0){\n            dat[i]=min(dat[i*2+1],dat[i*2+2]);\n        }\n    }\n    void add(ll k,ll x){\n        ll i=k+n-1;\n        dat[i].first+=x;\n        while(i>0){\n            i=(i-1)/2;\n            dat[i]=min(dat[2*i+1],dat[2*i+2]);\n        }\n    }\n    pll que(ll a,ll b,ll k=0,ll l=0,ll r=-1){\n        if(r<0)r=n;\n        if(b<=l||a>=r)return {inf,inf};\n        if(a<=l&&b>=r)return dat[k];\n        pll m1=que(a,b,2*k+1,l,(l+r)/2);\n        pll m2=que(a,b,2*k+2,(l+r)/2,r);\n        return min(m1,m2);\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,e,t;cin>>n>>e>>t;\n    vector<ll> x(n+1);\n    rep(i,1,n+1)cin>>x[i];\n    x[0]=0;\n    vector<ll> v;\n    rep(i,0,n+1){\n        v.push_back(-x[i]+t);\n    }\n    vector<ll> vv;\n    rep(i,0,n){\n        vv.push_back(-2*x[i+1]-x[i]);\n    }\n    ST seg1(v),seg2(vv);\n    ll dp[n+1];\n    dp[0]=0;\n    rep(i,1,n+1){\n        seg1.add(i-1,dp[i-1]);\n        seg2.add(i-1,dp[i-1]);\n        ll ge=x[i]-(t+1)/2;\n        ll y=upper_bound(x.begin(),x.end(),ge)-x.begin();\n        if(y>0)y--;\n        ll ans=inf;\n        pll p=seg2.que(0,y);\n        Min(ans,3*x[i]+p.first);\n        p=seg1.que(y,i);\n        Min(ans,x[i]+p.first);\n        dp[i]=ans;\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#define maxn 500009\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst long long INF=1e18;\nlong long tree[maxn];\nint n,E,T;\nlong long a[maxn],dp[maxn];\nlong long f[maxn];\nvoid pushup(int rt){\n\ttree[rt]=min(tree[rt<<1],tree[rt<<1|1]);\n}\nvoid build(int l,int r,int rt){\n\ttree[rt]=INF;\n\tif(l==r){\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n}\nvoid update(int L,int R,long long val,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\ttree[rt]=min(tree[rt],val);\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(L<=m)\n\t\tupdate(L,R,val,lson);\n\tif(R>m)\n\t\tupdate(L,R,val,rson);\n\tpushup(rt);\n}\nlong long query(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)\n\t\treturn tree[rt];\n\tlong long res1=INF,res2=INF;\n\tint m=(l+r)>>1;\n\tif(L<=m) res1=query(L,R,lson);\n\tif(R>m) res2=query(L,R,rson);\n\treturn min(res1,res2);\n}\nint main(){\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tbuild(1,n,1);\n\tdp[0]=0;\n\tupdate(1,1,dp[0]-a[0],1,n,1);\n\tdp[0]=0;\n\tf[0]=INF;\n\tfor(int i=1;i<=n;i++){\n\t\tint L=1,R=i;\n\t\twhile(L<R){\n\t\t\tint M=(L+R)>>1;\n\t\t\tif(2LL*(a[i]-a[M])<=T)\n\t\t\t\tR=M;\n\t\t\telse\n\t\t\t\tL=M+1;\n\t\t}\n\t\tlong long res=query(R,i,1,n,1);\n\t\tdp[i]=res+a[i]+T;\n\t\tif(R>1){\n\t\t\tdp[i]=min(dp[i],f[R-1]+3*a[i]);\n\t\t}\n\t\tf[i]=min(f[i-1],dp[i-1]+a[i]-a[i-1]-3*a[i]);\n\t\tupdate(i+1,i+1,dp[i]-a[i],1,n,1);\n\t}\n\tcout<<dp[n]+E-a[n]<<endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  int l = 0, r = 0;\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n\n    for(int d=max(r, idx)-1;d<idx2&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n    l = max(l, idx);\n    r = max(r, idx2);\n  }\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 0;\n\t\tfor (auto itr = dp[i - 1].rbegin(); itr != dp[i - 1].rend(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\t\n\t\t\tif (D[i] * 2 < T) {\n\t\t\t\tdp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t\telse if (D[i] * 2 >= T * 2) {\n\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][0] = max(dp[i][0], jikan + max(T, saizu));\n\t\t\t\tif (saizu < T) dp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].rbegin(); itr != dp[N - 1].rend(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[2001];\nLL dp[2001];\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tif(n > 2000) { return 1; }\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tinc1(i, n) {\n\t\tLL mi = 1000000000000000LL;\n\t\tinc(j, i) {\n\t\t\tLL v = dp[j] + max(2 * (x[i] - x[j + 1]), t);\n\t\t\tsetmin(mi, v);\n\t\t}\n\t\tdp[i] = mi;\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tint pnt=n+1;\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\twhile (2*(A[pnt-1]-A[i])>=T) pnt--;\n\t\tdp[i]=T+dp[i+1];\n\t\tfor (int j=pnt; j<=n; j++){\n\t\t\tdp[i]=min(dp[i], (A[j]-A[i])*2+dp[j+1]);\n\t\t}\n\t\t\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = 0;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\tfor( size_t i = idxmin; i < max( N + 1, idxmin + 100 ); i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX_N = 1e5 + 5, inf = 1000000LL * 1000000LL * 1000000LL;\nll n, E, T;\nll x[MAX_N];\nll dp[MAX_N];\nll seg[MAX_N << 2];\nll lazy[MAX_N << 2];\n\nvoid shift (ll id) {\n\tseg[id << 1] += lazy[id];\n\tlazy[id << 1] += lazy[id];\n\n\tseg[id << 1 | 1] += lazy[id];\n\tlazy[id << 1 | 1] += lazy[id];\n\tlazy[id] = 0;\n}\n\nvoid add (ll l, ll r, ll val, ll s = 0, ll e = n, ll id = 1) {\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn ;\n\t}\n\n\tif (r <= s || e <= l)\n\t\treturn ;\n\n\tshift(id);\n\n\tll mid = e + s >> 1;\n\tadd(l, r, val, s, mid, id << 1);\n\tadd(l, r, val, mid, e, id << 1 | 1);\n\tseg[id] = min(seg[id << 1], seg[id << 1 | 1]);\n}\n\nll get (ll l, ll r, ll s = 0, ll e = n, ll id = 1) {\n\tif (l <= s && e <= r)\n\t\treturn seg[id];\n\n\tif (r <= s || e <= l)\n\t\treturn inf;\n\n\tshift(id);\n\tll mid = e + s >> 1;\n\treturn min(get(l, r, s, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> E >> T;\n\tfor (ll i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tdp[n - 1] = T;\n\tfor (ll i = n - 2; ~i; i--) {\n\t\tadd(i + 1, n, 2 * (x[i + 1] - x[i]));\n\t\tadd(i, i + 1, dp[i + 1]);\n\t\tll ind = lower_bound(x, x + n, x[i] + (T + 1) / 2) - x;\n\t\tind--;\n\n\t\tdp[i] = T + dp[ind + 1];\n\t\tif (ind + 1 < n)\n\t\t\tdp[i] = min(dp[i], get(ind + 1, n));\n\t}\n\n\tcout << dp[0] + E << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\ntemplate<class V, int NV> class SegTree {\npublic:\n\tstatic V const def = -(1LL << 60);\n\tV comp(V l, V r) { return max(l, r); };\n\n\tvector<V> val;\n\tSegTree() { val = vector<V>(NV * 2, def); }\n\n\tV getval(int l, int r) { //[l,r]\n\t\tl += NV; r += NV + 1;\n\t\tV ret = def;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) ret = comp(ret, val[l++]);\n\t\t\tif (r & 1) ret = comp(ret, val[--r]);\n\t\t\tl /= 2; r /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV;\n\t\tval[i] = v;\n\t\twhile (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n};\n//-----------------------------------------------------------------\nint N;\nll E, T;\nll X[101010];\nll Y[101010];\nll YY[101010];\nll dp[101010][2];\nSegTree<ll, 1 << 20> st;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\tY[0] = X[0];\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\tst.update(0, dp[0][0] - YY[0] * 3);\n\trep(i, 1, N + 1) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\tdp[i][1] = min(dp[i][1], YY[i] * 3 + st.getval(0, i - 1));\n\t\tst.update(i, dp[i][0] - YY[i] * 3);\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint last=0,lastt=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tif(lastt!=0)\n\t\tdp[i]=min(dp[i],(x[i]-x[last+1])*2+dp[last]);\n\t\tfor(int j=lastt;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif((x[i]-x[j+1])*2<t)\n\t\t\t{\t\n\t\t\t\tlastt=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dp[i]==(x[i]-x[j+1])*2+dp[j])\n\t\t\tlast=j;\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tlong long a[N];\n\tlong long dp[N];\n\tpriority_queue<pair<long long, long long> >q;\n\tf(i, N){\n\t\ta[i] = 0;\n\t\tdp[i] = 0;\n\t}\n\tint n, k;\n\tlong long x, y, z;\n\tlong long s, ans, t;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d %lld %lld\", &n, &s, &t);\n\tans = s;\n\tf(i, n){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tif (n == 1){\n\t\tprintf(\"%lld\\n\", s + t);\n\t\treturn 0;\n\t}\n\tdp[0] = t;\n\tq.push(make_pair(a[1] - dp[0], a[1]));\n\tq.push(make_pair(a[0], a[0]));\n\ts = 100000000000000000;\n\tfor (int i = 1; i<n; i++){\n\t\twhile (true){\n\t\t\tx = -q.top().first;\n\t\t\ty = q.top().second;\n\t\t\tif (2*(a[i] - y)>t){\n\t\t\t\ts = min(s, x - y);\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tx = -q.top().first;\n\t\tdp[i] = min(t + x + a[i], s + (2 * a[i]));\n\t\tif (i < n - 1)\tq.push(make_pair(a[i + 1] - dp[i], a[i + 1]));\n\t}\n\tans += dp[n - 1];\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\n#define LL long long\nLL dp[MAXN],a[MAXN],T,tmp=1000000000000000LL;\nint n,m,t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(T<=2*(a[i]-a[t+1]))\n\t\t\ttmp=min(tmp,dp[t]-2*a[t+1]),t++;\n\t\tdp[i]=min(tmp+2*a[i],dp[t]+T);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/17] 13:50:15\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\ntemplate<typename ValueMonoid>\nclass segtree\n{\npublic:\n    using value_monoid_type = ValueMonoid;\n    using value_type        = typename value_monoid_type::value_type;\n    segtree(const usize sz, const value_type initial = value_monoid_type::id()) : sz{sz}, half{ceil2(sz)}, val(half << 1, value_monoid_type::id())\n    {\n        if (initial != value_monoid_type::id()) {\n            std::fill(val.begin() + half, val.end(), initial);\n            for (usize i = half - 1; i >= 1; i--) { up(i); }\n        }\n    }\n    template<typename InIt>\n    segtree(const InIt first, const InIt last) : sz{static_cast<usize>(std::distance(first, last))}, half{ceil2(sz)}, val(half << 1, value_monoid_type::id())\n    {\n        std::copy(first, last, val.begin() + half);\n        for (usize i = half - 1; i >= 1; i--) { up(i); }\n    }\n    value_type get(const usize a) const { return assert(a < sz), val[a + half]; }\n    void set(usize a, const value_type& v)\n    {\n        assert(a < sz);\n        val[a += half] = v;\n        while (a >>= 1) { up(a); }\n    }\n    value_type fold(usize l, usize r) const\n    {\n        assert(l < r), assert(r <= sz);\n        value_type accl = value_monoid_type::id(), accr = value_monoid_type::id();\n        for (l += half, r += half; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { accl = value_monoid_type::merge(accl, val[l++]); }\n            if (r & 1) { accr = value_monoid_type::merge(val[--r], accr); }\n        }\n        return value_monoid_type::merge(accl, accr);\n    }\n    usize size() const { return sz; }\n    friend std::ostream& operator<<(std::ostream& os, const segtree& seg)\n    {\n        os << \"[\";\n        for (usize i = seg.half; i < seg.half + seg.sz; i++) { os << seg.val[i] << (i + 1 == seg.half + seg.sz ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(const usize i) { val[i] = value_monoid_type::merge(val[i << 1], val[i << 1 | 1]); }\n    const usize sz, half;\n    std::vector<value_type> val;\n};\n\ntemplate<typename Element>\nstruct min\n{\n    using element_type = Element;\n    using value_type   = element_type;\n    min()              = delete;\n    static value_type merge(const value_type& a, const value_type& b) { return std::min(a, b); }\n    static constexpr value_type id() { return inf_v<value_type>; }\n};\nint main()\n{\n    const auto N = in<int>();\n    const auto E = in<ll>(), T = in<ll>();\n    std::vector<ll> xs(N + 2);\n    xs[0] = 0, xs[N + 1] = E;\n    for (int i = 1; i <= N; i++) { xs[i] = in<ll>(); }\n    std::vector<ll> dp(N + 1, inf_v<ll>);\n    dp[0] = 0;\n    segtree<min<ll>> seg1(N + 1);  // dp[i]-x_i\n    segtree<min<ll>> seg2(N + 1);  // dp[i]-2*x_{i+1}-x_i\n    seg1.set(0, 0LL), seg2.set(0, -2LL * xs[1]);\n    for (int i = 1; i <= N; i++) {\n        int inf = 0, sup = i;\n        while (sup - inf > 1) {\n            const int mid                              = (inf + sup) / 2;\n            (2LL * (xs[i] - xs[mid]) <= T ? sup : inf) = mid;\n        }\n        const int m = inf;\n        if (m < i) { chmin(dp[i], seg1.fold(m, i) + T + xs[i]); }\n        if (0 < m) { chmin(dp[i], seg2.fold(0, m) + 3LL * xs[i]); }\n        seg1.set(i, dp[i] - xs[i]);\n        seg2.set(i, dp[i] - 2LL * xs[i + 1] - xs[i]);\n    }\n    outln(dp[N] + xs[N + 1] - xs[N]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<62;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tll n,e,t;cin>>n>>e>>t;\n\tif(n>2000)return 0;\n\tvector<ll> x(n+10);\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tvector<ll> dp(n+10,LINF);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tchmin(dp[i],dp[j]+max(t,2LL*(x[i]-x[j+1])));\n\t\t}\n\t}\n\tcout<<e+dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint x[MAXN];\nlong long int dp[MAXN];\nlong long int f(int p1, int p2, long long int t)\n{\n\tlong long int t1 = x[p2] - x[p1];\n\tif(2*t1 > t)\n\t\treturn 3*t1;\n\treturn 3*t1 + (t - 2*t1);\n}\nint main()\n{\n\tint n,e,t;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint prev = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\twhile(prev+1 < i)\n\t\t{\n\t\t\tlong long int v1 = dp[prev] + (x[prev+1] - x[prev]) + f(prev+1,i,t);\n\t\t\tprev++;\n\t\t\tlong long int v2 = dp[prev] + (x[prev+1] - x[prev]) + f(prev+1,i,t);\n\t\t\tprev--;\n\t\t\tif(v2 <= v1)\n\t\t\t\tprev++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tlong long int cval = dp[prev] + (x[prev+1] - x[prev]) + f(prev+1,i,t);\n\t\tdp[i] = cval;\n\t\t// cout<<i<<\": \"<<dp[i]<<\" \"<<prev<<\"\\n\";\n\t}\n\tdp[n] = dp[prev] + (x[prev+1] - x[prev]) + f(prev+1,n,t);\n\tlong long int ans = dp[n] + (e - x[n]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll ;\nconst int maxn = 1e5 + 10 ;\nint x[maxn] ;\nll dp[maxn] ;\nint que[maxn], st, ed ;\nint main() {\n\tint n, e, t ;\n\tscanf(\"%d%d%d\", &n, &e, &t) ;\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf(\"%d\", &x[i]) ;\n\tmemset (dp, 0x3f, sizeof dp) ;\n\tdp[0] = 0 ;\n\tll mn_val = 1e18 ;\n\tst = 1; ed = 0 ;\n\tque[++ ed] = 0 ;\n\tfor (int i = 1; i <= n; i ++) {\n\t\t/*for (int j = 0; j < i; j ++) {\n\t\t\t//dp[i] = x[j + 1] - x[j] + dp[j] - 3ll * x[j + 1] + 3ll * x[i] ;\n\t\t\t//dp[i] = dp[j] - x[j] + x[i] + t ;\n\t\t\tdp[i] = min (dp[i], x[j + 1] - x[j] + dp[j] + max (3ll * (x[i] - x[j + 1]), 1ll * x[i] - x[j + 1] + t)) ;\n\t\t}*/\n\t\twhile (st <= ed && 3ll * (x[i] - x[que[st] + 1]) >= 1ll * x[i] - x[que[st] + 1] + t) {\n\t\t\tmn_val = min (mn_val, x[que[st] + 1] - x[que[st]] + dp[que[st]] - 3ll * x[que[st] + 1]) ;\n\t\t\tst ++ ;\n\t\t}\n\t\tdp[i] = min (dp[i], mn_val + 3ll * x[i]) ;\n\t\tif (st <= ed) dp[i] = min (dp[i], dp[que[st]] - x[que[st]] + x[i] + t) ;\n\t\tif (i == n) continue ;\n\t\twhile (st <= ed && dp[i] - x[i] <= dp[que[ed]] - x[que[ed]]) {\n\t\t\tmn_val = min (mn_val, x[que[ed] + 1] - x[que[ed]] + dp[que[ed]] - 3ll * x[que[ed] + 1]) ;\n\t\t\ted -- ;\n\t\t}\n\t\tque[++ ed] = i ;\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e - x[n]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename t>void chkmin(t&a,t b){if(a>b)a=b;}\n\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,t,e,x[maxn],end=0;\nll dp[maxn],val=1e18;\n\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;++i){\n\t\tdp[i]=1e18;\n\t\tcin>>x[i];\n\t\twhile(end<i&&2*(x[i]-x[end+1])>=t)\n\t\t\tchkmin(val,dp[end]-2*x[end+1]),++end;\n\t\tchkmin(dp[i],val+2*x[i]);\n\t\tif(end<i)\n\t\t\tchkmin(dp[i],dp[end]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n//BEGIN CUT HERE\ntemplate <typename T>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  int n;  //セグ木の幅\n  F f;  //モノイドの作用\n  T ti;  //初期値\n  vector<T> dat;  //セグ木で使う配列 一番上に使われるのがdat[1] 一番下の段の左端がdat[n]\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}  //fがモノイドとしての作用、tiが単位元\n  SegmentTree(F f,T ti,int n_):f(f),ti(ti){\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n  SegmentTree(F f,T ti,const vector<T> &v):f(f),ti(ti){\n    int n_=v.size();\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n    for(int i=0;i<n_;i++)dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  T get(int x){\n    return dat[x+n];\n  }\n\n  void init(int n_){  //ただの初期化\n    n=1;\n    while(n<n_) n<<=1;  //nが実際にとる２べきの幅\n    dat.assign(n<<1,ti);  //dat配列は幅の２倍あってその全てにtiを代入\n  }\n\n  void build(const vector<T> &v){  //vector vに合わせた初期化\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];  //v[i]を一番子の所に代入\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);  //iの子供は2*i、2*i+1\n  }\n\n  void set_val(int k,T x){  //（0-indexedで）kにxを代入\n    dat[k+=n]=x;\n    while(k>>=1)  //kがどんどん自分の親になっていく、0になったらおしまい\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n\n  T query(int a,int b){  //[a,b)の範囲のモノイドの作用を返す\n    T vl=ti,vr=ti;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);  //左端を使いたくなるのはブロックが奇数の時\n      if(r&1) vr=f(dat[--r],vr);  //右端〃偶数の時（開区間なのでr:奇数で反応）\n    }\n    return f(vl,vr);\n  }\n\n  template<typename C>\n  int find(int st,C &check,T &acc,int k,int l,int r){  //dat[k]:[l,r)の間にいるenを返す\n    //下のfind用なので先にそっち読むべき\n    //accはst~lとかで確定している値\n    if(l+1==r){  //答えがちゃんと存在するならこのlが答え\n      acc=f(acc,dat[k]);\n      return check(acc)?k-n:-1; //入るならk-n(==l)を、入らないなら-1を返す\n    }\n    int m=(l+r)>>1;  //にぶたんのそれ\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);  //mがstより後ろなら明らかにl=m;\n    if(st<=l&&!check(f(acc,dat[k]))){  //今見てるk全部でもダメ(mだと足りないのでl=mにする）\n      acc=f(acc,dat[k]);  //kは全部accに加えた上で-1を返す\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);  //まず[l,m)の中にenがいるか探す\n    if(~vl) return vl;  //いたならそれを返す(if(~vl)は-1以外にのみ反応する)\n    return find(st,check,acc,(k<<1)|1,m,r);  //いなかったら[m,r)の中にenがいるのでそれを返す\n    //acc=f(acc,dat[k]);がここで効いてる\n  }\n\n  template<typename C>\n  int find(int st,C &check){\n    //check(f(dat[st]~dat[en-1]))=false,check(f(dat[st]~dat[en]))＝trueとなるenを返す\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }\n};\n//END CUT HERE\nconst int INF=1e18;\nauto f=[](int a,int b){return min(a,b);};\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\nsigned main(){\n  int n,e,t;cin>>n>>e>>t;\n  vector<int> x(n+1,0);\n  REP(i,0,n)cin>>x[i+1];\n  SegmentTree<int> seg1(f,INF,n),seg2(f,INF,n);\n  seg1.set_val(0,-2*x[1]);\n  seg2.set_val(0,0);\n  REP(i,1,n+1){\n    int l=-1,r=i;//2(x[i+1]-x[l])>T\n    while(r-l>1){\n      int mid=(l+r)>>1;\n      (2*(x[i]-x[mid])>t?l:r)=mid;\n    }\n    int a=min(seg1.query(0,l)+3*x[i],seg2.query(l,i)+x[i]+t);\n    if(i<n){\n      seg1.set_val(i,-2*x[i+1]-x[i]+a);\n      seg2.set_val(i,a-x[i]);\n    }\n    else fin(e-x[n]+a);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a) (a).begin(), (a).end()\n#define FOR(x,n) for(int x = 0; x < n; x++)\n#define FORR(x,n) for(int x = n-1; x >= 0; x--)\n#define FIN ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define SZ(a) ((int)(a).size())\nusing namespace std;\ntypedef long long ll;\n\nconst int MXN = 1e5+1;\nint N, T, E;\nll xs[MXN];\nll t = 0;\n\nint main(){\n  cin >> N >> E >> T;\n  FOR(x,N) cin >> xs[x];\n\n  ll last = 0;\n  FOR(x,N) {\n    int xsrt = x;\n    t += xs[x] - last;\n    set<ll> ts; ts.insert(T);\n    while(x+1 < N && xs[x+1] - xs[xsrt] <= T) x++, ts.insert(xs[x]-xs[xsrt]+T);\n    ll tmp = 2*(xs[x]-xs[xsrt]);\n    last = xs[xsrt];\n    for(int i = xsrt; i <= x; i++) {\n      tmp += xs[i]-last;\n      if(tmp < *ts.begin()){\n        tmp = *ts.begin();\n      }\n      ts.erase(ts.begin());\n      last = xs[i];\n    }\n    t += tmp;\n  }\n  \n  cout << (E-last) + t << \"\\n\";\n  \n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\nint n, e, t;\nint x[2000];\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> e >> t;\n\tif (n > 2000)return 0;\n\trep(i, n)cin >> x[i];\n\tlong long dp[2001];\n\tfill_n(dp, n + 1, 1LL << 60);\n\tdp[0] = x[0];\n\trep(i,n) {\n\t\tfor (int j = i; j < n;j++) {\n\t\t\tlong long d = x[j] - x[i];\n\t\t\tlong long nxt = (j + 1 == n ? e : x[j + 1]) - x[j];\n\t\t\tlong long c = t <= 2 * d ? 3 * d : 3 * d + (t - d * 2);\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + c + nxt);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],pm[4*maxn];\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,1,n+1)cin>>x[i];\n    int g=0;\n    pm[0]=-2*x[1];\n    rep(i,1,n+1)\n    {\n        while(x[g+1]<=x[i]-t/2.0)g++;\n        dp[i]=min(t+dp[g],2*x[i]+pm[g-1]);\n        pm[i]= min(pm[i-1],dp[i]-2*x[i+1]);\n    }\n    cout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tvector<ll> x(N + 1,0);\n\trepn(i, N) cin >> x[i];\n\n\tvector<ll> dp(N + 1, 0), mn(N + 1, INF);\n\n\trepn(i, N) {\n\t\tauto itr = lower_bound(++x.begin(), x.end(), x[i] - T / 2);\n\t\tll j = distance(x.begin(), itr);\n\t\tdp[i] = dp[j - 1] + T;\n\n\t\tdp[i] = min(dp[i], mn[j - 1] + 2 * x[i]);\n\n\t\tmn[i] = min(mn[i - 1], dp[i - 1] - 2 * x[i]);\n\t}\n\n\tcout << E + dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=2e18;\n\nll x[MAXN],dp[MAXN],dp2[MAXN];\n\nint main() {\n   // cout << \"HI\" <<endl;\n    ll n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    dp[0]=0;\n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=lower_bound(x+1,x+n+1,(x[i]-T))-x;\n\n        if(x[j]>x[i]-T&&j){\n            j--;\n        }\n\n        dp[i]=dp[j]+T*2;\n\n        if(j>0){\n            dp[i]=min(dp[i],dp2[j-1]+x[i]*2);\n        }\n\n\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n      //  cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n\n    }\n\n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long LL;\n \nconstexpr LL INF = 1e18;\nLL dp[100001], dp2[100001];\nLL N, T, E;\nLL x[100001];\n \nint main() {\n    scanf(\"%lld %lld %lld\", &N, &E, &T);\n    for(int i = 1; i<=N; ++i) scanf(\"%lld\", x+i);\n    int now = 1;\n    LL mn = -2*x[1];\n    for(int i = 1; i<=N; ++i) {\n        if( 2*(x[i] - x[1]) <= T ) {\n            dp[i] = T;\n            continue;\n        }\n        while( 2*(x[i]-x[now+1]) > T ) {\n            mn = min(mn, dp[now]-2*x[now+1]);\n            ++now;\n        }\n        dp[i] = min(dp[now]+T, mn+2*x[i]);\n    }\n    printf(\"%lld\\n\", dp[N]+E);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 20);\n\ntemplate<class T>\nstruct monotonous_queue_min\n{\n\tint64_t len;\n\tdeque<pair<T, int64_t> > Q;\n\n\tmonotonous_queue_min() { Q.clear(); len = 0; }\n\n\tvoid init(int64_t _l)\n\t{\n\t\tlen = _l;\n\t\tQ.clear();\n\t}\n\n\tvoid push_back(T x, int64_t X)\n\t{\n\t\twhile(!Q.empty() && X - Q.front().second > len) Q.pop_front();\n\t\twhile(!Q.empty() && x <= Q.back().first) Q.pop_back();\n\t\tQ.push_back({x, X});\n\t}\n\n\tT query()\n\t{\n\t\tif(Q.empty()) return (T)1e18;\n\t\treturn Q.front().first;\n\t}\n};\n\nint64_t n, t, e, L;\nint64_t x[MAXN];\n\nvoid read()\n{\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n}\n\nint64_t dp[MAXN];\n\n/*\n\n   dp[i] = MIN ( 2 * x[i] - 2 * x[j] + dp[j - 1] - x[j - 1] + x[i] + MAX(t - 2 * x[i] + 2 * x[j], 0) )\n   dp[i] = 3 * x[i] + MIN(dp[j - 1] - x[j] * 2 - x[j - 1])  \n   dp[i] = 3 * x[i] + MIN(dp[j - 1] - x[j] * 2 - x[j - 1] + t - 2 * x[i] + 2 * x[j])\n\n   dp[i] = dp[j - 1] + 3 * x[i] - 2 * x[j] - x[j - 1] \n\n   t >= x[i] * 2 - x[j] * 2\n   floor(t / 2) >= x[i] - x[j]\n*/\n\nint64_t mn[MAXN];\n\nmonotonous_queue_min<int64_t> mq;\n\nvoid solve()\n{\n\tx[0] = 0;\n\tdp[0] = 0;\n\tmn[0] = (int64_t)1e18;\n\tL = t / 2;\n\n\tmq.init(L);\t\n\n\tint last = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\t/*for(int j = i; j >= 1; j--)\n\t\t{\n\t\t\tint64_t wait_t = max((int64_t)0, t - 2 * (x[i] - x[j]));\n\t\t\tchkmin(dp[i], -x[j - 1] + wait_t + (-x[j]) * (int64_t)2 + dp[j - 1]);\n\t\t}*/\n\n\t\tmn[i] = min(mn[i - 1], dp[i - 1] - x[i] * (int64_t)2 - x[i - 1]);\n\t\tmq.push_back(dp[i - 1] - x[i - 1], x[i]);\n\t\tdp[i] = mq.query() + t - 2 * x[i];\n\t\twhile(i >= last && (x[i] - x[last]) > L) last++;\n\t\tchkmin(dp[i], mn[last - 1]);\n\t\tdp[i] += 3ll * x[i];\n\t}\n\n\tcout << dp[n] + e - x[n] << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) { // TLE\n\tLL mi2_v = MAX;\n\tincID(j, m[i], i) { setmin(mi2_v, dp[j]); }\n\treturn mi2_v;\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nmultiset<long long>s1,s2;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\ts2.insert(t);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(st+1<i && 2*(x[i]-x[st+1])>=t)\n\t\t{\n\t\t\ts2.erase(s2.find(dp[st]-x[st]+t));\n\t\t\ts1.insert(dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=4e18;\n\t\tif(s1.size())dp[i]=min(dp[i],(*s1.begin())+3LL*x[i]);\n\t\tif(s2.size())dp[i]=min(dp[i],x[i]+(*s2.begin())),\n\t\ts2.insert(dp[i]-x[i]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\n#define Set(a, b) memset(a, b, sizeof a)\n\ntypedef long long LL;\n\nconst LL Inf = LONG_LONG_MAX / 2;\nconst int N = 1e5 + 10;\n\nint n, e, t;\nLL f[N], p[N];\n\nint main() {\n\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) \n\t\tscanf(\"%lld\", &p[i]);\n\tSet(f, 60);\n\tf[0] = 0;\n\tLL mn = Inf;\n\tfor (int i = 1, j = 0; i <= n; ++i) {\n\t\tfor (; t <= 2 * (p[i] - p[j + 1]); ++j) \n\t\t\tmn = min(mn, f[j] - 2 * p[j + 1]);\n\t\tif (j < i)\n\t\t\tf[i] = min(f[i], f[j] + t);\n\t\tf[i] = min(f[i], mn + 2 * p[i]);\n\t}\n\tprintf(\"%lld\\n\", e + f[n]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nint n, T, E;\nll x[N], dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &E, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n    if (i == 1) continue;\n    int l = 1, r = i - 1, res = 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if ((x[i] - x[mid]) * 2 >= T) {\n        res = mid;\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    dp[i] = min(dp[i], dp[res - 1] + x[res] - x[res - 1] + (x[i] - x[res]) * 3);\n    if (++res != i) {\n      dp[i] = min(dp[i], dp[res - 1] + x[i] - x[res - 1] + T);\n    }\n  }\n  printf(\"%lld\\n\", dp[n] + E - x[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long n,t,e,x[111111],mnp,pos,dp[111111];\nmultiset<long long> s;\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tdp[0]=0;\n\tmnp=1e18;\n\tpos=1;\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif (2*(x[i]-x[pos])>t) \n\t\t\t{\n\t\t\t\tmnp=min(mnp,dp[pos-1]-2*x[pos]);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mnp+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[j], ans[i] + getdist(x, T,i, j));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nint n,T,E;\nint a[100010];\nlong long ans;\nlong long f[100010],g[100010];\npair<int,long long> q[100010];\n\nint main()\n{int i,j,t,w;\n \n scanf(\"%d%d%d\",&n,&E,&T);\n for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n f[0]=0;\n j=1;\n a[n+1]=E;\n t=1;\n w=0;\n for(i=1;i<=n;i++)\n {\twhile(j+1<=i && (a[i]-a[j+1])*2>=T) j++;\n\tif((a[i]-a[j])*2>=T) f[i]=max(f[i],(a[i+1]-a[i])*2+g[j-1]);\n\twhile(t<=w && (a[i]-a[q[t].first])*2>=T) t++;\n\twhile(t<=w && q[w].second<=f[i-1]-a[i]*2) w--;\n\tq[++w]=make_pair(i,f[i-1]-a[i]*2);\n\tif(t<=w) f[i]=max(f[i],q[t].second+2*a[i]+2*(a[i+1]-a[i])-T);\n\tg[i]=max(g[i-1],f[i]);\n\t//cout<<i<<\" \"<<f[i]<<endl;\n }\n ans=(ll)3*E-f[n]-2*a[1];\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n \ntypedef pair<int,int>  pii;\n \nconst int MAX=1e6;\nconst int INF=1e18;\n \nint N,E,T,arr[MAX],dp[MAX],tot[MAX],pre[MAX],nxt[MAX];\n \n/*int cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}*/\n \nvoid solve()\n{\n\tdp[N]=T+E-arr[N];\n\ttot[N]=3*arr[N]+T-arr[N];\n\t//cout<<dp[N]<<\" ha ha \\n\";\n\t//tot[N]=INF;\n\tfor(int A=N-1;A>=1;A--)\n\t{\n\t\tdp[A]=pre[A]+arr[nxt[A]+1]-arr[nxt[A]]+dp[nxt[A]+1];\n\t   \tif(nxt[A]<N)\n\t   \t    dp[A]=min(dp[A],-3*arr[A]+tot[nxt[A]+1]);\n\t\ttot[A]=min(tot[A+1],3*arr[A]+arr[A+1]-arr[A]+dp[A+1]);\n\t\t/*for(int B=nxt[A]+1;B<=N;B++)\n\t\t{\n\t\t\tcout<<dp[A]<<\"lol \\n\";\n\t\t\tdp[A]=min(dp[A],3*(arr[B]-arr[A])+arr[B+1]-arr[B]+dp[B+1]);\n\t\t\t//cout<<dp[A]<<\" \"<<3*(arr[B]-arr[A])<<\" \"<<arr[B+1]-arr[B]<<\" \"<<dp[B+1]<<\"lol \\n\";\n\t\t}*/\n\t\t//cout<<A<<\" \"<<dp[A]<<\"\\n\";\n\t\t//<<pre[A]<<\" \"<<dp[nxt[A]+1]<<\"\\n\";\n\t}\n\treturn ;\n}\n \nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n \n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t{\n\t\tint low=A,high=N,mid,res=A;\n\t\twhile(low<=high)\n\t\t{\n\t\t\tmid=(low+high)/2;\n\t\t\tif(T-2*(arr[mid]-arr[A])>0)\n\t\t\t{\n\t\t\t\tres=mid;\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh=mid-1;\n\t\t}\n\t\tnxt[A]=res;\n\t\tpre[A]=T-2*(arr[res]-arr[A])+3*(arr[res]-arr[A]);\n\t}\n\tsolve();\n\tcout<<arr[1]+dp[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\n\ntemplate<typename F>struct NoOp{void setup(ui, F){}void op(F&p,F n,ui,ui){p=n;}void down(F&,F&,F&,ui,ui) {}};\n\ntemplate<typename F,typename SetOp,typename PowerOp>struct Lazy{\n    void setup(ui s,F def){this->def=def;this->s=s;L=new F[s]();fill(L,L+s,def);}\n    void down(F&u,F&l,F&r,ui i,ui s){op(l,L[i],i<<1,s>>1);op(r,L[i],i<<1|1,s>>1);L[i]=def;}\n    void op(F&p,F n,ui i,ui s){p=sop(p,pop(n,s));if(i<this->s)this->L[i]=sop(this->L[i],n);}\n    SetOp sop;PowerOp pop;F*L;ui s;F def;\n};\n\ntemplate <typename F, typename CombineOp, typename ModifyOp = NoOp<F>> struct SegTree {\n\tvoid setup(ui s, F def) {\n\t\tn = 1<<logceil(s);\n\t\tT = vector<F>(2*n, def);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tvoid setup(vector<F> & data, F def = F()) {\n\t\tn = 1<<logceil(data.size());\n\t\tT = vector<F>(2*n, def);\n\t\tcopy(data.begin(), data.end(), T.begin() + n);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tinline void put(ui x, F n) { put(x, x, n); }\n\tinline void put(ui from, ui to, F v) { put2(from, to+1, v, 1, n); }\n\tinline F get(ui x) { return get(x, x); }\n\tinline F get(ui from, ui to) { return get2(from, to+1, 1, n); }\n\n\tvoid put2(ui from, ui to, F v, ui i, ui s) {\n\t\tif (from == 0 && to == s) { mop.op(T[i], v, i, s); return; }\n\t\tmop.down(T[i], T[i<<1], T[i<<1|1], i, s);\n        s>>=1;i<<=1;\n        if (to <= s) { put2(from, to, v, i, s); }\n        else if (from >= s) { put2(from-s, to-s, v, i|1, s); }\n        else {\n            put2(from, s, v, i, s);\n            put2(0, to-s, v, i|1, s);\n        }\n\t\tT[i>>1] = cop(T[i], T[i|1]);\n\t}\n\n\tF get2(ui from, ui to, ui i, ui s) {\n        while (true) {\n            if (from == 0 && to == s) return T[i];\n            mop.down(T[i], T[i << 1], T[i << 1 | 1], i, s);\n            s >>= 1;i <<= 1;\n            if (to > s) {\n                to -= s;\n                if (from >= s) { from -= s; i|=1; }\n                else return cop(get2(from, s, i, s), get2(0, to, i|1, s));\n            }\n        }\n    }\n\n\tui n;\n\tvector<F> T;\n\tCombineOp cop;\n    ModifyOp mop;\n};\n\n\ntemplate <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};\ntemplate <typename F> struct MinOp { F operator()(F a, F b) { return std::min(a,b); }};\ntemplate <typename F> struct MaxOp { F operator()(F a, F b) { return std::max(a,b); }};\ntemplate <typename F> struct MultiplyOp { F operator()(F a, F b) { return a*b; }};\ntemplate <typename F> struct MultOp { F operator()(F a, ui b) { return a*b; }};\ntemplate <typename F> struct IdempOp { F operator()(F a, ui b) { return a; }};\ntemplate <typename F> struct InverseOp { F operator()(F a, F b) { return b?b-a:a; }};\n\ntemplate<typename T> using AddSumTree = SegTree<T, AddOp<T>, Lazy<T, AddOp<T>, MultOp<T>>>;\ntemplate<typename T> using AddMaxTree = SegTree<T, MaxOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AddMinTree = SegTree<T, MinOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMinTree = SegTree<T, MinOp<T>, Lazy<T, MinOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMaxTree = SegTree<T, MaxOp<T>, Lazy<T, MaxOp<T>, IdempOp<T>>>;\ntemplate<typename T> using XorTree = SegTree<T, AddOp<T>, Lazy<T, InverseOp<T>, MultOp<T>>>;\n\ntemplate<typename T> using SetMinTree = SegTree<T, MinOp<T>>;\ntemplate<typename T> using SetMaxTree = SegTree<T, MaxOp<T>>;\ntemplate<typename T> using SetMulTree = SegTree<T, MultiplyOp<T>>;\n\n\nclass DShikAndGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, E, T; cin >> N >> E >> T;\n        vector<ll> X(N+1, 0);\n        for (int i = 0; i < N; ++i) cin >> X[i+1];\n        vector<ll> W(N+1, 1e18);\n        ll d = E;\n        SetMinTree<ll> F, G;\n        F.setup(W, 0); G.setup(W, 0);\n        int j = 0;\n\n        for (int i = 1; i <= N; ++i) {\n            F.put(i-1, d - 2 * X[i]);\n            G.put(i-1, d);\n            d = 1e18;\n            while (2*(X[i]-X[j+1]) >= T) ++j;\n//            int z = bsl(0, i-1, [&](int t) { return 2*(X[i] - X[t+1]) < T; });\n//            cout << z << ' ' << j << endl;\n            if (j != i) d = X[i] + T + G.get(j, i-1);\n            if (j != 0) d = min(d, F.get(0, j-1) + 3 * X[i]);\n            d -= X[i];\n        }\n\n        cout << d << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDShikAndGame solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <fstream>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n\n#define maxn 200010\n#define inf 1LL<<60\n\nusing namespace std;\nlong long x[maxn];\nlong long dp[maxn];\n\nint main() {\n    // freopen(\"POLYGON.in\", \"r\", stdin);\n    // freopen(\"POLYGON.out\", \"w\", stdout);\n    int n;\n    long long e, t;\n    cin >> n >> e >> t;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> x[i];\n    }\n    x[n+1] = e;\n    \n    dp[1] = x[1];\n    for (int i = 2; i <= n+1; ++i) {\n        dp[i] = inf;\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (dp[i] == inf)\n            continue;\n        int lo = i, hi = n+1;\n        while (hi - lo > 1) {\n            int mid = (lo + hi)/2;\n            if (2*(x[mid] - x[i]) <= t) {\n                lo = mid;\n            } else {\n                hi = mid;\n            }\n        }\n        dp[lo+1] = min(dp[lo+1], dp[i] + 3*(x[lo] - x[i]) + (t - 2*(x[lo]-x[i])) + x[lo+1] - x[lo]);\n        if (lo+2 <= n+1) {\n            dp[lo+2] = min(dp[lo+2], dp[i] + 3*(x[lo+1] - x[i]) + x[lo+2] - x[lo+1]);\n        }\n    }\n    cout << dp[n+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nll n,t[200010][2],mx = 100000000000000,dp[100010],x[100010],y[100010];\nvoid update(ll p,ll a,int x){\n\tfor(t[p+=n][x] = a;p>1;p >>= 1){\n\t\tt[p>>1][x] = min(t[p][x],t[p^1][x]);\n\t}\n}\n\nll query(int l, int r,int x){\n\tll mn = mx;\n\tfor(l += n, r += n; l<r; l >>= 1,r >>= 1){\n\t\tif(l&1) mn = min(mn,t[l++][x]);\n\t\tif(r&1) mn = min(mn,t[--r][x]);\n\t}\n\treturn mn;\n}\n\nint main(){\n\tll i,e,T;\n\tcin >> n >> e >> T;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> x[i];\n\t}\n\tx[0] = 0; dp[0] = 0;\n\tint l = -1;\n\tfor(i=0;i<=n;i++){\n\t\twhile(2*(x[i] - x[l + 1])>T && l<n-1) l++;\n\t\ty[i] = l;\n\t}\n\tupdate(0,-x[0] - 2*x[1],0); update(0,-x[0],1);\n\tfor(i=1;i<=n;i++){\n\t\tdp[i] = min(3*x[i] + query(0,y[i],0),x[i] + T + query(y[i],i,1));\n\t\tupdate(i,dp[i] - x[i] - 2*x[i + 1],0);\n\t\tupdate(i,dp[i] - x[i],1);\n\t}\n\tcout << dp[n] + e - x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (int i = 1; i <= n; ++i) a[i] = F();\n\tif (n > 2000) return 0;\n\tR long long ans = E;\n\tR int last = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = 1ll * i * T;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tlong long S = a[i] - a[j], temp = dmax(T - 2ll * S, 0);\n\t\t\tcmin(f[i], f[j - 1] + temp * (i - j + 1) + S * 2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nll A[MAX_N],DP[MAX_N];\n\nll n,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T;\n}\n\nll g(int idx){\n  ll& x = DP[idx];\n  if(x >= 0) return x;\n  \n  for(int i=idx+1;i<=n;i++){\n    ll val = g(i) + f(A[i-1]-A[idx]);\n    if(x == -1 || val < x) x = val;\n  }\n  \n  return x;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n >> E >> T;\n  \n  if(n > 2030) return 0;\n  \n  for(int i=0;i<n;i++) cin >> A[i];\n  \n  for(int i=0;i<n;i++) DP[i] = -1;\n  \n  cout << E+g(0) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<class T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;\n\n\tT e(){ return INF<T>();}\n\tT c(T a,T b){return min(a,b);}\n\n\t// T me(){return 0;}\n\t// T mc(T a,T b){return a + b;}\n\tSegmentTree(int n):size(n),n2(upper_pow2(size)){\n\t\tdat=vector<T>(n2*2,e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn c(lv,rv);\n\t}\n};\n\ntemplate <typename T,typename Func>\nT satisfy_mini(Func P,T l ,T r){//(l |sep| r)\n\tl--;\n\twhile(r-l>EPS<T>()){\n\t\tT m=(l+r)/2;\n\t\t(P(m)?r:l)=m;\n\t}\n\treturn r;\n}\n\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;ll E,T;cin >> N >> E >> T;\n\t\tvector<ll> xs(N+1);\n\t\tfor(int i:range(N)) cin >> xs[i+1];\n\n\n\t\tvector<ll> dp(N+1,INF<ll>());\n\n\t\tSegmentTree<ll> seg1(N+1);\n\t\t// seg1[i] = dp[i] - xs[i] - 2 * xs[i+1];\n\t\tSegmentTree<ll> seg2(N+1);\n\t\t// seg2[i] = dp[i] - xs[i];\n\t\tdp[0] = 0;\n\t\tseg1.set(0,dp[0]-xs[0]-2*xs[1]);\n\t\tseg2.set(0,dp[0]-xs[0]);\n\t\t// seg.set(0,0);\n\t\tfor(int i:range(1,N+1)){\n\t\t\t// ll d = xs[i] - xs[pre+1];\n\t\t\t// dp[i] = min(dp[i],xs[i] +  dp[pre] - xs[pre] + max(2*d,T));\n\t\t\t// dp[i] = min(3*xs[i] + min{pre < t}(seg1[pre]), xs[i] + T + min{pre >= t}(seg2[pre]))\n\t\t\tint t = satisfy_mini([&](int pre){\n\t\t\t\treturn 2*(xs[i]-xs[pre+1]) <= T;\n\t\t\t},-1,i);\n\t\t\t// cerr << t <<\" \" <<  2*(xs[i]-xs[t+1])  <<\" \" << T << endl;\n\t\t\t// cerr << t <<\":\" << i << endl;\n\t\t\t// cerr << 3*xs[i] + seg1.query(0,t) << \"::\" << xs[i] + T + seg2.query(t,i) << endl;\n\t\t\tdp[i] = min(3*xs[i] + seg1.query(0,t),xs[i] + T + seg2.query(t,i));\n\t\t\tseg1.set(i,dp[i] - xs[i] - 2 * xs[i+1]);\n\t\t\tseg2.set(i,dp[i] - xs[i]);\n\t\t}\n\t\tcout << dp[N] + E - xs[N] << endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[100005];\nint n,e,t;\nint x[100005];\nsigned main(){\n\tcin>>n>>e>>t;if(n>2000)return 0;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tmemset(dp,inf,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+max(2*(x[i]-x[j]),x[i]-x[j]+t));\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++)cerr<<i<<\" \"<<dp[i]<<endl;\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\n#define mid ((s + e) / 2)\n#define int long long\n\nint n, ed, tad;\nint x[N];\nint dp[N];\nint seg[N * 4];\nint laz[N * 4];\nint get(int l, int r, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn 2e18;\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\treturn min(get(l, r, v * 2, s, mid), get(l, r, v * 2 + 1, mid, e));\n}\nvoid add(int l, int r, int val, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[v] += val;\n\t\tlaz[v] += val;\n\t\treturn;\n\t}\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v * 2] += laz[v];\n\tlaz[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\tadd(l, r, val, v * 2, s, mid);\n\tadd(l, r, val, v * 2 + 1, mid, e);\n\tseg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\nint tmp[N];\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> ed >> tad;\n\tint pnt = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t\ttmp[i] = 2e18;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\ttmp[i] = min(tmp[i], tmp[j - 1] + x[j] - x[j - 1] + max(2 * (x[i] - x[j]), tad) + x[i] - x[j]);\n\t\t}\n\t//\tcout << i << \" tmp : \" << tmp[i] << endl;\n\t}\n\tcout << ed - x[n] + tmp[n] << '\\n';\n\treturn 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tadd(0, 1, 0 + x[1] - 0 + tad);\n\t\t}\n\t\tadd(0, pnt + 1, (x[i] - x[i - 1]) * 2);\n\t\twhile ((x[i] - x[pnt + 1]) * 2 >= tad) {\n\t\t\tadd(pnt, pnt + 1, (x[i] - x[pnt + 1]) * 2 - tad);\n\t\t\tpnt++;\n\t\t}\n\t\tadd(0, i - 1, x[i] - x[i - 1]);\n/*\t\tcout << \"all done : \" << endl;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tcout << j << \" > \" << get(j, j + 1) << \"    \"; \n\t\tcout << endl;*/\n\t\tdp[i] = get(0, i);\n//\t\tcout << \"dp[i] : \" << i << \" \" << dp[i] << \" \" << dp[i] + x[i + 1] - x[i] + tad << endl;\n\t\tadd(i, i + 1, dp[i] + x[i + 1] - x[i] + tad);\n\t}\n\tcout << ed - x[n] + dp[n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nll e, t;\nll x[100010];\n\nll memo[100010];\n\nll calc(int k) {\n    if (memo[k] < 0) {\n        if (k == n) memo[k] = 0;\n        else {\n            // wait\n            ll res = t + x[k+1] - x[k] + calc(k+1);\n            for (int i = k+1; i < n; i++) {\n                ll d = x[i] - x[k];\n                res = min(res, 3*d + max(0LL, t-2*d) + calc(i+1)+x[i+1]-x[i]);\n            }\n            memo[k] = res;\n        }\n    }\n    return memo[k];\n}\n\nll solve() {\n    memset(memo, -1, sizeof(memo));\n    x[n] = e;\n    return calc(0) + x[0];\n}\n\nvoid input() {\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> x[i];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j-1 > 0){\n            tmp1 = sgt2.query(0, min(j-1, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\nint N, T, E, X[2002];\nint64 dp[2003][2003];\n\n// [Left, Right]\nint64 getCost(int Left, int Right)\n{\n  if(Left > Right) {\n    return (0);\n  } else if(Left == Right) {\n    return (T);\n  } else {\n    // Right にいて Left に戻る\n    int64 Time = X[Right] - X[Left];\n    int64 ret = Time * 2;\n    // E 経過してなかったらその分を加える\n    ret += max(0LL, T - Time - 2);\n    return (ret);\n  }\n}\n\n// endd 回収済み(閉区間)\nint64 rec(int endd, int idx)\n{\n  if(idx > N) return (INF);\n  if(endd == N && idx == N) return (0);\n  if(idx == N || endd == N) return (INF);\n  if(~dp[endd][idx]) return (dp[endd][idx]);\n  int64 ret = INF;\n  ret = min(ret, rec(idx + 1, idx + 1) + getCost(endd, idx) + X[idx + 1] - X[idx]);\n  ret = min(ret, rec(endd, idx + 1) + X[idx + 1] - X[idx]);\n  return (dp[endd][idx] = ret);\n}\n\nsigned main()\n{\n  cin >> N;\n  if(N > 2000) throw (0);\n  cin >> E >> T;\n  for(int i = 1; i <= N; i++) {\n    cin >> X[i];\n  }\n  X[N + 1] = E;\n  N++;\n  memset(dp, -1, sizeof(dp));\n  cout << rec(1, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nint n, T, E;\nll x[N], dp[N];\n\nll calc(int l, int r) {\n  return (x[r] - x[l]) * 3 + max(0ll, (ll) T - 2 * (x[r] - x[l])); \n}\n\nint main() {\n  scanf(\"%d %d %d\", &n, &E, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n    if (i == 1) continue;\n    int l = 1, r = i - 1, res = 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (calc(mid, i) <= calc(mid + 1, i)) {\n        res = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    dp[i] = min(dp[i], dp[res - 1] + x[res] - x[res - 1] + calc(res, i));\n  }\n  printf(\"%lld\\n\", dp[n] + E - x[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nlong long dp[maxn];\nlong long mi[maxn];\nint x[maxn];\nint q[maxn],head,tail;\nint main()\n{\n    int n,e,t;\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",x+i);\n    dp[n]=e-x[n]+t;\n    head=tail=0;\n    long long mi=100000000000000000LL;\n    q[tail++]=n;\n    dp[n+1]=0;\n    x[n+1]=e;\n    for(int i=n-1;i;i--)\n    {\n        while(head<tail)\n        {\n            int u=q[head];\n            if((x[u]-x[i])*2>t){\n                mi=min(mi,dp[u+1]+x[u]*2+x[u+1]);\n                head++;\n            }\n            else break;\n        }\n        //printf(\"%d %lld %lld %lld %d %dss\\n\",i,dp[q[head]]+x[q[head]+1]-x[i]+t,mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i],head,tail);\n        dp[i]=min(mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i]);\n        if(head<tail)\n            dp[i]=min(dp[q[head]+1]+x[q[head]+1]-x[i]+t,dp[i]);\n\n        while(head<tail)\n        {\n            int u=q[tail-1];\n            if(dp[u+1]+x[u+1]>=dp[i+1]+x[i+1]){\n                tail--;\n            }\n            else break;\n        }\n        q[tail++]=i;\n    }\n    printf(\"%lld\\n\",dp[1]+x[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <deque>\n#include <stack>\nusing namespace std;\n\nlong long dp[2005];\nlong long x[2005];\n\nbool stack_better(int j1, int j2) {\n    return dp[j1] - x[j1] + 2LL * x[j1 + 1] < dp[j2] - x[j2] + 2LL * x[j2 + 1];\n}\n\nbool deque_better(int i, int j) {\n    return dp[i] - x[i] < dp[j] - x[j];\n}\n\nint main() {\n    //ifstream cin(\"f.in\");\n    int n; long long t, e;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++ i) {\n        cin >> x[i];\n    }\n    dp[0] = 0;\n    deque<int> dq;\n    stack<int> stk;\n    dq.push_back(0);\n    for (int i = 1; i <= n; ++ i) {\n        while (!dq.empty() && 2LL * (x[i] - x[dq.front() + 1]) >= t) {\n            int j = dq.front();\n            while (!stk.empty() && stack_better(j, stk.top())) {\n                stk.pop();\n            }\n            dq.pop_front();\n            stk.push(j);\n        }\n        dp[i] = 1LL << 60;\n        if (!dq.empty()) {\n            dp[i] = min(dp[i], dp[dq.front()] - x[dq.front()] + x[i] + t);\n        }\n        if (!stk.empty()) {\n            dp[i] = min(dp[i], dp[stk.top()] - (x[stk.top()] + 2LL * x[stk.top() + 1]) + 3LL * x[i]);\n        }\n        while (!dq.empty() && deque_better(i, dq.back())) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n        /**\n        for (int j = 0; j <= i - 1; ++ j) {\n            /// j = last batch\n            long long extra = x[i] - x[j];\n            extra += (x[i] - x[j + 1]);\n            extra += max(0LL, (t - (extra - (x[j + 1] - x[j]))));\n            extra += (x[i] - x[j + 1]);\n            dp[i] = min(dp[i], dp[j] + extra);\n        }*/\n    }\n    cout << dp[n] + (e - x[n]) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\nconst lint linf = 0x3f3f3f3f3f3f3f3f;\n\nint n,tar,que[_]={0},he,ta;\nlint tim,loc[_],f[_]={0};\n\nint main()\n{\n\tn=ty(),tar=ty(),tim=ty();\n\tfor(int i=1;i<=n;i++)loc[i]=ty();\n\n\tlint temp=linf;\n\tloc[0]=0,he=1,ta=0,que[++ta]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(he<=ta && 2*(loc[i]-loc[que[he]+1])>tim)\n\t\t\ttemp=min(temp,f[que[he]]-loc[que[he]]-2*loc[que[he]+1]),he++;\n\t\tf[i]=min(3*loc[i]+temp,tim+f[que[ta]]+loc[i]-loc[que[ta]]);\n\t\twhile(he<=ta && f[que[ta]]-loc[que[ta]]>=f[i]-loc[i])ta--;\n\t\tque[++ta]=i;\n\t}\n\n\tprintf(\"%lld\\n\",f[n]+tar-loc[n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n, e, t;\nint x[100005];\nll f[100005];\nll tr[100005 << 2][2];\nvoid Update(int L, int R, int p, int x, int l, int r, int rt)\n{\n\tif(L <= l && r <=R)\n\t{\n\t\ttr[rt]\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + max((x[i] - x[j + 1]) * 2, t) + (x[i] - x[j]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + e - x[n]);\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long\n#define up(i,a,b) for (int i=a; i<=b; i++)\n#define down(i,a,b) for (int i=a; i>=b; i--)\n#define endl '\\n'\n#define X first\n#define Y second\n#define II pair<int, int>\n#define III pair<int, pair<int, int> >\n#define debug(X) cerr<< #X << \" = \" <<X << endl\n#define debug2(X,Y) cerr<< #X << \" = \" <<X << \",\"<<#Y<<\" = \"<<Y<<endl\n#define show(X,a,b) {cerr << #X << \" = \"; up(__,a,b) cerr << X[__] << ' '; cerr << endl;}\n#define gc getchar\n#define pc putchar\nusing namespace std;\n\n\nint n,t,x[100010];\nvoid input()\n{\n    cin>>n;\n    cin>>x[n+1]>>t;\n    up(i,1,n) cin>>x[i];\n}\n\nvoid solve()\n{\n\tlong res= x[1];\n    int cur= 1;\n    up(i,1,n)\n     if (i>= cur)\n\t {\n        while (cur+1<=n and x[cur+1]- x[i]<=t) cur++;\n        res+= 3LL*(x[cur]- x[i])+ max(0, t- 2*(x[cur]- x[i]) );\n       \tres+= x[cur+1]- x[cur]; //debug(res);\n\t\tcur++;\n\t }\n\tcout<<res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);// don't use when interactive\n\n    #ifdef I_Love_Pork\n    #define TASK \"tmp\"\n    freopen(TASK\".inp\",\"r\",stdin);\n    freopen(TASK\".out\",\"w\",stdout);\n\t  #endif\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,E,T;\nll X[202020];\nll ST1[202020],ST3[202020];\n\n\nll R[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>E>>T;\n\t\n\tx=0;\n\tX[N+1]=E;\n\tfor(i=1;i<=N;i++) cin>>X[i];\n\t\n\tll mi1=0;\n\tll mi3=-2*X[1];\n\tfor(i=1;i<=N;i++) {\n\t\twhile(2*(X[i]-X[x+1])>T) {\n\t\t\tmi3=min(mi3,ST3[x]);\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tR[i]=min(3*X[i]+mi3, X[i]+T+mi1);\n\t\tST1[i]=R[i]-X[i];\n\t\tmi1=min(mi1,ST1[i]);\n\t\tST3[i]=R[i]-(X[i]+2*X[i+1]);\n\t\t\n\t}\n\t\n\tcout<<R[N]+E-X[N]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <unistd.h>\n\n\n#define ll long long\n#define lst(x) x.size()-1\n#define ld long double\n#define pr pair<ll,ll>\n#define loop(i,n) for(ll i=0 ; i<n ; ++i)\n#define rep(i,x,n) for(ll i=x ; i<=n ; ++i)\n#define iteloop(type,data,name,it) for(type<data>::iterator it=name.begin() ;it!=name.end() ; ++it)\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<typename T>\nusing os = tree<T, null_type, less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nconst ll N=1e5+5,M=1e1+5,MOD=1e9+7,INF=1e18;\n\nint pos[N],n,t,e;\nll memo[N];\nll seg[4*N],lazy[4*N];\n\nint getMid(int st,int en){\n    return (st+en)/2;\n}\nll build(int st,int en,int frst){\n    if(st==en){\n        return seg[frst]=0;\n    }\n    int mid=getMid(st,en);\n    return seg[frst]=min(build(st,mid,frst*2+1),build(mid+1,en,frst*2+2));\n}\nll getmin(int st,int en,int qs,int qe,int frst){\n    if(qs>qe)return INF;\n    if(lazy[frst]){\n        seg[frst]+=lazy[frst];\n        if(st!=en) {\n            lazy[frst * 2 + 1] += lazy[frst];\n            lazy[frst * 2 + 2] += lazy[frst];\n        }\n        lazy[frst]=0;\n    }\n    if(st>qe || qs>en)return INF;\n    if(st>=qs && en<=qe){\n        return seg[frst];\n    }\n    int mid=getMid(st,en);\n    return min(getmin(st,mid,qs,qe,frst*2+1),getmin(mid+1,en,qs,qe,frst*2+2));\n}\nvoid update(int st,int en,int qs,int qe,ll val,int frst){\n    if(lazy[frst]){\n        seg[frst]+=lazy[frst];\n        if(st!=en) {\n            lazy[frst * 2 + 1] += lazy[frst];\n            lazy[frst * 2 + 2] += lazy[frst];\n        }\n        lazy[frst]=0;\n    }\n    if(st>qe || en<qs)return;\n    if(st<=qs && en>=qe){\n        lazy[frst]+=val;\n        return ;\n    }\n    int mid=getMid(st,en);\n    update(st,mid,qs,qe,val,frst*2+1);\n    update(mid+1,en,qs,qe,val,frst*2+2);\n    seg[frst]=min(seg[frst*2+1],seg[frst*2+2]);\n}\n\nll seg2[4*N];\n\nll build2(int st,int en,int frst){\n    if(st==en){\n        return seg2[frst]=0;\n    }\n    int mid=getMid(st,en);\n    return seg2[frst]=min(build2(st,mid,frst*2+1),build2(mid+1,en,frst*2+2));\n}\nll getmin2(int st,int en,int qs,int qe,int frst){\n    if(qs>qe)return INF;\n    if(st>qe || qs>en)return INF;\n    if(st>=qs && en<=qe){\n        return seg2[frst];\n    }\n    int mid=getMid(st,en);\n    return min(getmin2(st,mid,qs,qe,frst*2+1),getmin2(mid+1,en,qs,qe,frst*2+2));\n}\nll update(int st,int en,int indexToUpdate,ll val,int frst){\n    if(st>indexToUpdate || en<indexToUpdate)return seg2[frst];\n    if(st==en){\n        return seg2[frst]=val;\n    }\n    int mid=getMid(st,en);\n    return seg2[frst]=min(update(st,mid,indexToUpdate,val,frst*2+1),\n                          update(mid+1,en,indexToUpdate,val,frst*2+2));\n}\nint main(){\n    cin.sync_with_stdio(false), cin.tie(0) , cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"rt\" , stdin);\n    // freopen(\"in.txt\", \"wt\" , stdout);\n#endif // ONLINE_JUDGE\n    cin>>n>>e>>t;\n    loop(i,n){\n        cin>>pos[i];\n    }\n    memo[0]=t;\n\n    build2(0,n-1,0);\n    build(0,n-1,0);\n\n    update(0,n-1,0,t,0);\n    update(0,n-1,0,0,t,0);\n\n    rep(i,1,n-1){\n        int st=0,en=i-1;\n        while(st<=en){\n            int mid=getMid(st,en);\n            if(2*(pos[i]-pos[mid+1])>t){\n                st=mid+1;\n            }else{\n                en=mid-1;\n            }\n        }\n      //  cout<<st<<endl;\n        memo[i]=getmin(0,n-1,0,st-1,0);\n\n     //   cout<<i<<\" \"<<memo[i]<<endl;\n\n        // to decide if it's better to return to the begining\n        memo[i]=min(memo[i],(ll)max(t,2*(pos[i]-pos[0])));\n     //   cout<<i<<\" \"<<memo[i]<<endl;\n\n        memo[i]=min(memo[i],getmin2(0,n-1,st,i-1,0)+t);\n      //  cout<<i<<\" h \"<<memo[i]<<endl;\n\n        memo[i]=min(memo[i],t+memo[i-1]);\n       // cout<<i<<\" \"<<memo[i]<<endl;\n\n        update(0,n-1,0,i-1,2*(pos[i+1]-pos[i]),0);\n        update(0,n-1,i,i,memo[i],0);\n        update(0,n-1,i,memo[i],0);\n\n    }\n    cout<<memo[n-1]+e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll dp[100016];\n\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vx;\n\trep(i, 0, n) {\n\t\tll a;\n\t\tcin >> a;\n\t\tvx.pb(a);\n\t}\n\trep(i, 0, 100016)dp[i] = 1000000000000000000LL;\n\tdp[0] = 0;\n\tdp[1] = t;\n\tif (n == 1) {\n\t\tcout << e + t << endl;\n\t\treturn 0;\n\t}\n\trep(i, 2, vx.sz + 1) {\n\t\tdp[i] = dp[i - 1] + t;\n\t\tlong long low = 0;\n\t\tlong long high = i-1;\n\n\t\twhile (low < high) {\n\t\t\tlong long mid = (high + low) >> 1;\n\n\t\t\tif (t < (vx[i - 1] - vx[mid]) * 2) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\tdp[i] = min(dp[i], dp[low] + max(t, (vx[i - 1] - vx[low]) * 2));\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    set<ll> As;\n    set<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>t){\n            As.insert(A[iter]);\n            Bs.erase(B[iter]);\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define rep(i, s, n)  for(int i = s; i <= (n); ++i)\n#define rev(i, n, s)  for(int i = (n); i >= s; --i)\n#define fore(x, a) for(auto &&x : a)\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int N = 100005;\n\nll a[N];\nll dp[N];\n\nint main() {\n#ifdef loc\n  if(!freopen((string(FOLDER) + \"inp.txt\").c_str(), \"r\", stdin)) {\n    assert(0);\n  }\n  freopen((string(FOLDER) + \"out.txt\").c_str(), \"w\", stdout);\n#endif\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  int n; ll t, e;\n  cin >> n >> e >> t;\n  rep(i, 1,n) {\n    cin >> a[i];\n  }\n  const ll inf = mod * 1LL * mod;\n  rep(i, 1, n) {\n    dp[i] = inf;\n    rep(j, 0, i - 1) {\n      dp[i] = min(dp[i], dp[j] + a[j + 1] - a[j] + a[i] - a[j + 1] + max(t, 2 * (a[i] - a[j + 1])));\n    }\n  }\n  cout << dp[n] + e - a[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n \nusing namespace std;\n \n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n#define ll long long\n#define ld double\n#define ull unsigned long long\n#define PI pair < int, int > \n \nconst int N = 123;\nconst int M = 123;\nconst ld Pi = acos(-1);\nconst ll Inf = 1e18;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nconst int Sz = 501;\nconst int MOD = 1e9 + 7;\n \nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint mult(int a, int b) {\n  return 1ll * a * b % mod;\n}\nint sum(int a, int b) {\n  add(a, b);\n  return a;\n}\n \nint n, a[N], t, m;\nll dp[N];\n\nll calc(int l, int r) {\n  ll ans = max((a[r] - a[l]) * 2ll, 1ll * t);\n  return ans;\n}\n \nvoid solve() { \n  cin >> n >> m >> t;\n  for (int i = 1;i <= n;i++) {\n    cin >> a[i];\n    dp[i] = 1e18;\n  }\n  for (int i = 1;i <= n;i++) {\n    for (int j = 1;j <= i;j++) {\n      ll cur = dp[j - 1] + calc(j, i);\n      dp[i] = min(dp[i], cur);\n    }\n  }\n  cout << dp[n] + m << endl;\n}\n  \nint main() {\n  #ifdef wws\n   freopen(\"in\", \"r\", stdin);\n   // freopen(\"in\", \"w\", stdout);\n  #endif \n  ios_base::sync_with_stdio(0);\n  int tt = 1; \n  while(tt--) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=2e5+500;\nconst long long INF=1e18;\nint head,tail,n,E,T,x[N],q[N];\nlong long f[N],g1[N],g2[N];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    long long mi=INF;\n    for(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n    int j=0;g1[0]=-2*x[1],g2[0]=T-x[1];\n    int head=1,tail=1;q[1]=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(j<i&&2*x[j+1]<=2*x[i]-T)mi=min(mi,g1[j]),++j;\n        while(head<=tail&&q[head]<j)++head;\n        f[i]=3ll*x[i]+mi;\n        if(head<=tail)f[i]=min(f[i],2ll*x[i]+g2[q[head]]);\n        g1[i]=f[i]-x[i]-2*x[i+1];\n        g2[i]=f[i]-x[i]-x[i+1]+T;\n        while(head<=tail&&g2[i]<=g2[q[tail]])--tail;q[++tail]=i;\n    }\n    cout<<f[n]+E-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<climits>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 2005\n#define M 10005\n#define INF 10000000000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint is_mul_overflow(ll a, ll b) {\n        return LLONG_MAX / a < b;\n}\n\nint x[N];\nll dp[N];\nint n,e,t;\nll get(int a,int b)\n{\n    ll d = x[b]-x[a];\n    return t>2LL*d?t+d:3LL*d;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n>>e>>t)\n    {\n        FOR(i,1,n)cin>>x[i];\n        FOR(i,0,n)dp[i] = INF;\n        x[0] = 0;\n        dp[0] = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,0,i-1)\n            {\n                dp[i] = min(dp[i],dp[j]+get(j+1,i)+x[j+1]-x[j]);\n            }\n            //cout<<i<<\" \"<<dp[i]<<endl;\n        }\n        cout<<dp[n]+e-x[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long n,e,t,f[100001],a[100001];\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tf[i]=f[i-1]+(a[i]-a[i-1])+t;\n\t\tfor (int j=i-1; j>=1; --j)\n//\t\t\tf[i]=min(f[i],f[j-1]+(a[i]-a[j])*3+(a[j]-a[j-1])+max(1ll*0,t-2*(a[i]-a[j]))); \n\t\t\tf[i]=min(f[i],f[j-1]+3*a[i]-2*a[j]-a[j-1]+max(1ll*0,t-2*(a[i]-a[j])));\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005],ml[100005];\nmultiset<ll> s;\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tml[0]=mem[0]-x[0]-x[1]-x[1];\n\tint cur=1;\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=max(t,x[i]-x[0]+x[i]-x[0])+x[i];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tif (i>1) {\n\t\t\twhile(cur<i && x[i]-x[cur]+x[i]-x[cur+1]>t) {\n\t\t\t\ts.erase(s.find(mem[cur]-x[cur]));\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tmem[i]=min(mem[i],ml[min(cur,i-1)-1]+3ll*x[i]);\n\t\t\tif (!s.empty()) mem[i]=min(mem[i],(*s.begin())+t+x[i]);\n\t\t}\n\t\tml[i]=min(ml[i-1],mem[i]-x[i]-x[i+1]-x[i+1]);\n\t\ts.insert(mem[i]-x[i]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\n\nvoid solve() {\n        long long n, e, t;\n        cin >> n >> e >> t;\n        vector<long long> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        vector<long long> dp(n, INFL);\n        dp[0] = t;\n        int now = 0;\n        long long mi = INFL;\n        for (int i = 1; i < n; i ++) {\n                if (2 * (x[i] - x[0]) <= t) {\n                        dp[i] = t;\n                        continue;\n                }\n                mi = min(mi, -2 * x[0]);\n                while (2 * (x[i] - x[now + 1]) > t) {\n                        mi = min(mi, dp[now] - 2 * x[now + 1]);\n                        now ++;\n                }\n                dp[i] = mi + 2 * x[i];\n                dp[i] = min(dp[i], dp[now] + t);\n        }\n        cout << dp[n - 1] + e << endl;\n        return;\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll T,E;\nll dp[100010] = {};\nconst ll inf = 1e18;\n\nint main(){\n    cin >> N >> E >> T;\n//    assert(N<=2000);\n    vector<ll> X(N+1,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i]-X[i-1]+T;\n        int id = upper_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        for(int j=max(id-10,1);j<=min(id+10,i-1);j++){\n            dp[i] = min(dp[i],dp[j-1]+X[j]-X[j-1]+3*(X[i]-X[j])+max(T-2*(X[i]-X[j]),0LL));\n        }\n    }\n/*    for(int i=0;i<=N;i++) cerr << dp[i] << \" \";\n    cerr << endl;\n*/    cout << dp[N]+(E-X[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nclass MQ {\n\tprivate:\n\tdeque<ll> q;\n\tpublic:\n\tvoid push(ll val) {\n\t\twhile(!(q.empty()) && q.back() > val) {\n\t\t\tq.pop_back();\n\t\t}\n\t\tq.push_back(val);\n\t}\n\tvoid pop(ll val) {\n\t\tif(!q.empty() && q.front() == val) {\n\t\t\tq.pop_front();\n\t\t}\n\t}\n\tll front() {\n\t\treturn q.front();\n\t}\n};\nvl w,dp;\nint main() {\n\tll n,ti,ed;\n\tcin >> n >> ed >> ti;\n\tfor(int i=0;i<n;i++) {\n\t\tll t;\n\t\tcin >> t;\n\t\tw.push_back(t);\n\t}\n\tw.push_back(ed);\n\tdp.assign(w.size(),1e18);\n\n\tdp.back() = 0;\n\tll rv = 1e18;\n\tMQ q;\n\tll pt = dp.size()-1;\n\tfor(int i=n-1;i>=0;i--) {\n\t\twhile(pt > i && (w[pt-1]-w[i])*2 > ti) {\n\t\t\tq.pop(dp[pt]);\n\t\t\trv = min(rv,dp[pt]+(w[pt-1]-w[i])*2);\n\t\t\tpt--;\n\t\t}\n\t\tdp[i] = min(q.front()+ti,rv);\n\t\tq.push(dp[i]);\n\t\tif(i > 0) {\n\t\t\trv += 2*(w[i]-w[i-1]);\n\t\t}\n\t}\n\t//what\n\tcout << dp[0]+ed << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\tincID(j, m[i - 1], m[i]) {\n\t\tif(ms.count(dp[j]) == 0) { return 1; }\n\t\tauto it1 = ms.find(dp[j]);\n\t\tauto it2 = it1;\n\t\tit2++;\n\t\tms.erase(it1, it2);\n\t}\n\tms.insert(dp[i - 1]);\n\treturn *(ms.rbegin());\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = (2e3)+1;\n\nint n, e, t, x[MAX];\nlong long dp[MAX];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t\tdp[i] = LLONG_MAX;\n\t\tfor(int j = 0; j < i; j++) dp[i] = min(dp[j]+x[i]-x[j]+max(2*(x[i]-x[j+1]), t), dp[i]);\n\t}\n\tcout << dp[n]+e-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint l[N],x[N];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tl[n+1]=n;\n\tfor(int i=n;i>=1;i--){\n\t\tl[i]=min(i,l[i+1]);\n\t\twhile(l[i]>0&&2*(x[i]-x[l[i]])<=t) l[i]--;\n\t}\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=1LL<<60;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+max(t,2*(x[i]-x[j])));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\tincID(j, m[i - 1], m[i]) {\n\t\tauto it1 = ms.find(dp[j]);\n\t\tauto it2 = it1;\n\t\tit2++;\n\t\tms.erase(it1, it2);\n\t}\n\tms.insert(dp[i - 1]);\n\treturn *(ms.rbegin());\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define Pair pair<int, int>\n#define MP(x, y) make_pair(x, y)\n#define fi first\n#define se second\n//#define int long long \n#define LL long long \n#define Fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define Fout(x) {freopen(#x\".out\",\"w\",stdout);}\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)\nchar buf[(1 << 22)], *p1 = buf, *p2 = buf;\nusing namespace std;\nconst int MAXN = 2001, mod = 998244353, INF = 1e9 + 10;\nconst double eps = 1e-9;\ntemplate <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}\ntemplate <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}\ntemplate <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}\ntemplate <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}\ntemplate <typename A> inline void debug(A a){cout << a << '\\n';}\ntemplate <typename A> inline LL sqr(A x){return 1ll * x * x;}\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nLL N, E, T, a[MAXN], f[MAXN];\nint main() {\n\tN = read(); E = read(); T = read();\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i = 1; i <= N; i++) a[i] = read();\n\tf[0] = 0; f[1] = T;\n\tfor(int i = 2; i <= N; i++) {\n\t//\tf[i] = f[i - 1] + T;\n\t\tfor(int j = i - 1; j >= 0; j--) \n\t\t\tchmin(f[i], f[j] + max(T, 2 * (a[i] - a[j + 1])));\n\t}\n\tcout << f[N] + E;\n    return 0;\n}\n/*\n1,2,6,14,38,100,268,726,1974,\n\n*/"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nint move(int i, int j) {\n\tif (j < 0 || j >= i) return f[N - 1];\n\treturn f[j] + a[i] - a[j] + std::max((a[i] - a[j + 1]) << 1, k);\n}\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint j = std::lower_bound(a, a + i, (a[i] * 2 - k + 1) >> 1) - a;\n\t\t// printf(\"i=%d j=%d\\n\", i, j);\n\t\tf[i] = std::min(f[i], move(i, j - 2));\n\t\tf[i] = std::min(f[i], move(i, j - 1));\n\t\tf[i] = std::min(f[i], move(i, j));\n\t\tf[i] = std::min(f[i], move(i, j + 1));\n\t\tf[i] = std::min(f[i], move(i, j + 2));\n\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tint mn=0x3f3f3f3f3f3f3f3fll;\n\tfz(i,1,n){\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n\t\t\tmn=min(mn,dp[j]-a[j]+2*(-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n\t\tdp[i]=min(dp[i],dp[q.front()]+a[i]-a[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn+3*a[i]);\n\t\twhile(!q.empty()&&dp[q.back()]-a[q.back()]>dp[i]-a[i])\tq.pop_back();\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+abs(a[n]-E)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint dp[100005];\n\n// ------------>8---------- LazySegmentTree ---------->8------------\n\n// ## write [ LST lst(n, SUM/MAX/MIN, ADD/UPD) ] when using this snippet.\nenum QUERY_SEG_LazySegmentTree { SUM, MAX, MIN };\nenum QUERY_LAZ_LazySegmentTree { ADD, UPD };\ntemplate<class SEG, class LAZ>\nclass LazySegmentTree {\nprivate:\n\tstd::vector<SEG> seg;\n\tstd::vector<LAZ> laz;\n\tstd::vector<bool> isUpdated;\n\tint ARY_SIZE;\n\tSEG eSeg;\n\tLAZ eLaz;\n\tstd::function<SEG(SEG&, SEG&)> mergeSeg;\n\tstd::function<LAZ(LAZ&, LAZ&)> mergeLaz;\n\tstd::function<SEG(SEG&, LAZ&, int)> applyLaz;\n\n\tvoid push(int k, int l, int r) {\n\t\tif (!isUpdated[k]) {\n\t\t\tapplyLaz(seg[k], laz[k], r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tmergeLaz(laz[k * 2 + 1], laz[k]); isUpdated[k * 2 + 1] = false;\n\t\t\t\tmergeLaz(laz[k * 2 + 2], laz[k]); isUpdated[k * 2 + 2] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = eLaz;\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n, QUERY_SEG_LazySegmentTree qSeg, QUERY_LAZ_LazySegmentTree qLaz) : ARY_SIZE(1) {\n\t\tARY_SIZE = 1;\n\t\twhile (ARY_SIZE < n) ARY_SIZE *= 2;\n\t\tseg.resize(ARY_SIZE * 2 - 1);\n\t\tlaz.resize(ARY_SIZE * 2 - 1);\n\t\tisUpdated.resize(ARY_SIZE * 2 - 1, true);\n\n\t\tswitch (qSeg) {\n\t\tcase SUM:\n\t\t\teSeg = 0;\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return l + r; };\n\t\t\tbreak;\n\t\tcase MAX:\n\t\t\teSeg = std::numeric_limits<SEG>::lowest();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::max(l, r); };\n\t\t\tbreak;\n\t\tcase MIN:\n\t\t\teSeg = std::numeric_limits<SEG>::max();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::min(l, r); };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (qLaz)\n\t\t{\n\t\tcase ADD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l += r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s += l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s += l; };\n\t\t\tbreak;\n\t\tcase UPD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l = r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s = l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s = l; };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid update(int a, int b, SEG v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tLAZ la(v);\n\t\t\tmergeLaz(laz[k], la);\n\t\t\tisUpdated[k] = false;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = mergeSeg(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\t// ## update [l, r) with v\n\tvoid update(int l, int r, SEG v) {\n\t\tupdate(l, r, v, 0, 0, ARY_SIZE);\n\t}\n\tSEG query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return eSeg;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tSEG vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tSEG vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn mergeSeg(vl, vr);\n\t}\n\t// ## return SUM/MAX/MIN in [l, r)\n\tSEG query(int l, int r) {\n\t\treturn query(l, r, 0, 0, ARY_SIZE);\n\t}\n};\n\nusing LST = LazySegmentTree<ll, ll>;\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nint solve(std::vector<int> x, int T) {\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l > r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tLST lst(n, MIN, ADD);\n\tdp[0] = T;\n\n\tFOR(i, 1, n) {\n\t\tint pre = std::lower_bound(ALL(x), x[i - 1] - T / 2) - x.begin();\n\t\tint t = std::lower_bound(ALL(x), x[i] - T / 2) - x.begin();\n\t\tFOR(j, pre, t) {\n\t\t\tlst.update(j, j + 1, dp[j] + cost(j + 1, i) - lst.query(j, j + 1));\n\t\t}\n\t\tlst.update(0, pre, (x[i] - x[i - 1]) * 2);\n\t\tlst.update(i - 1, i, dp[i - 1] + T - lst.query(i - 1, i));\n\n\t\tdp[i] = std::min(lst.query(0, i), cost(0, i));\n\t}\n\treturn dp[n - 1];\n}\n\nint solve2(std::vector<int> x, int T) { // slow\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l > r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tFILL(dp, INFLL);\n\tREP(i, n) {\n\t\tCHMIN(dp[i], cost(0, i));\n\t\tREP(j, i) {\n\t\t\tCHMIN(dp[i], dp[j] + cost(j + 1, i));\n\t\t}\n\t}\n\treturn dp[n - 1];\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\n\tint ans = e;\n\tRREP(i, n) x[i] -= x[0];\n\tans += solve2(x, t);\n\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nll A[MAX_N],DP[MAX_N];\n\nll n,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T;\n}\n\nint last;\n\nll g(int idx){\n  ll& x = DP[idx];\n  if(x >= 0) return x;\n  \n  for(int i=last;i>idx;i--){\n    ll val = g(i) + f(A[i-1]-A[idx]);\n    if(x == -1 || val < x){\n      x = val;\n    } else {\n      last = i+1;\n      break;\n    }\n  }\n  \n  return x;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n >> E >> T;\n  \n  last = n;\n  \n  for(int i=0;i<n;i++) cin >> A[i];\n  \n  for(int i=0;i<n;i++) DP[i] = -1;\n  \n  for(int i=n-1;i>=0;i--) g(i);\n  \n  cout << E+g(0) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V> v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return LLONG_MAX;\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nll dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,E,T;\n    cin >> n >> E >> T;\n    vl vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    segtree<ll> st(vl(n,0));\n    dp[0] = 0;\n    st.range(0,1,-2*vec[0]);\n    rep(i,n){\n        int id = lower_bound(all(vec),vec[i]-T/2)-vec.begin();\n        if(id == 0){\n            dp[i+1] = dp[id]+T;\n            if(i < n-1){\n                st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n            }\n            // cout << \"OO \" << i+1 << \" \" << dp[i+1]-2*vec[i+1] << \"\\n\";\n            continue;\n        }else if(id <= i){\n            dp[i+1] = dp[id]+T;\n        }\n        if(i == 0){\n            cmn(dp[i+1],2*vec[i]);\n        }else{\n            cmn(dp[i+1],st.query(0,i)+2*vec[i]);\n        }\n        // show(st.query(0,i+1));\n        if(i < n-1){\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n        }\n    }\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << \"\\n\";\n    // }\n    cout << dp[n]+E << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[0]+(x[i]-x[0])*3+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i+1;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<r)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, r));\n        if (r<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(r, i));\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint a[N], b[N], dp[N], sum[N];\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tif(i == 1) {\n\t\t\tdp[1] = t + a[1];\n\t\t\tsum[1] = a[1];\n\t\t\tcontinue;\n\t\t}\n\t\tsum[i] = sum[i - 1] + a[i] - a[i - 1];\n\t\tdp[i] = a[i] + i * t;\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint cnt = dp[j] + sum[j + 1] - sum[j] + max(t, 2 * (sum[i] - sum[j + 1])) + sum[i] - sum[j + 1];\n\t\t\tdp[i] = min(dp[i], cnt);\n\t\t}\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int MaxN = 1e5 + 10;\n\nint N, E, T, x[MaxN];\n\nlong long f[MaxN];\n\nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && 2 * (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n\nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint j = find(i);\n\t\tif (j != i)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}\n\t\tif (j)\n\t\t{\n\t\t\t--j;\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct SegmentTree {\n  using T = lint;\n  static T op(const T& x, const T& y) { return min(x, y); }\n  static constexpr T e() { return numeric_limits<T>::max(); }\n\n  const int n;\n  V<T> t;\n  SegmentTree(int n) : n(n), t(2 * n, e()) {}\n  T& operator[](int i) { return t[i + n]; }\n  void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n  T acc(int l, int r) const {\n    T resl = e(), resr = e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) resl = op(resl, t[l++]);\n      if (r & 1) resr = op(t[--r], resr);\n    }\n    return op(resl, resr);\n  }\n  void set(int i, const T& x) {\n    t[i += n] = x;\n    while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint E, T; cin >> E >> T;\n  V<lint> x(n); for (auto&& e : x) cin >> e;\n  x.push_back(E);\n  V<lint> dp(n + 1, 9e18);\n  SegmentTree st0(n + 1), st1(n + 1);\n  dp[n] = 0;\n  for (int i = n; i >= 0; --i) {\n    if (i < n) {\n      int k = lower_bound(begin(x), end(x), x[i] + (T + 1) / 2) - begin(x) + 1;\n      k = min(k, n + 1);\n      dp[i] = min(dp[i], T - x[i] + st0.acc(i + 1, k));\n      dp[i] = min(dp[i], -3 * x[i] + st1.acc(k, n + 1));\n    }\n    st0.set(i, x[i] + dp[i]);\n    if (i) st1.set(i, 2 * x[i - 1] + x[i] + dp[i]);\n  }\n  cout << x[0] + dp[0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector< vector<int> > vvi;\ntypedef vector<ll> vl;\ntypedef vector< vector<ll> > vvl;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n#define forv(i, v) forn(i, v.size())\n#define all(v) v.begin(), v.end()\n#define mp make_pair\n#define pb push_back\n\nconst ll INF = 1e18;\n\nint main() {\n#ifdef NEREVAR_PROJECT\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    ll t, e;\n    cin >> n >> e >> t;\n    vl x(n);\n    forn(i, n) {\n        scanf(\"%lld\", &x[i]);\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    forn(i, n) {\n        ll pos = i == 0 ? 0 : x[i - 1];\n        for (int j = i; j < n; j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n    }\n    cout << dp[n] + e - x[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,t,x[100010];\nlong long f[100010],k=1e18;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\tfor(;2*(x[i]-x[j+1])>t;j++)\n\t\t\tk=min(k,f[j]-2*x[j+1]);\n\t\tf[i]=min(k+2*x[i],f[j]+t);\n\t}\n\tcout<<f[n]+m<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n    T oo;\n\n    T q(int l, int r)\n    {\n        T a = oo;\n        if (l%2!=0)\n            a = min(a, A[l]);\n        if (r%2!=0)\n            a = min(a, A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        oo = numeric_limits<T>::max();\n        A = vector<T>(2*n, oo);\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        /*\n        for (int j=1; j<i; j++)\n            if ((x[i]-x[j])*2 > T)\n                A[i] = min(A[i], A[j-1]-x[j-1]-2*x[j] + 3*x[i]);\n            else\n                A[i] = min(A[i], A[j-1]-x[j-1] + T+x[i]);\n                */\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <set>\n#include <utility>\n#define MAXN 200000\n\nusing namespace std;\n\nint N;\nlong long E, T;\nlong long x[MAXN];\nlong long dp[MAXN];\n\nset <pair <long long, int>> dpm1; // min dp[i] + x[i]\nlong long dpm2; // min dp[i] + x[i] + 2 * x[i - 1]\n\nlong long val1(int k) {\n    return dp[k] + x[k];\n}\n\nlong long val2(int k) {\n    return dp[k] + x[k] + 2 * x[k - 1];\n}\n\nint main() {\n    scanf(\"%d%lld%lld\", &N, &E, &T);\n    for (int i = 0; i < N; i++)\n        scanf(\"%lld\", &x[i]);\n\n    dp[N - 1] = T;\n    int k = N - 1;\n    dpm1.insert({val1(k), k});\n    dpm2 = T + 3 * E;\n    for (int i = N - 2; i >= 0; i--) {\n        dp[i] = x[N - 1] - x[i] + max(2 * (x[N - 1] - x[i]), T);\n        /*\n        for (int j = i; j + 1 < N; j++) {\n            long long cost = (x[j + 1] - x[i]) + max(2 * (x[j] - x[i]), T);\n            dp[i] = min(dp[i], dp[j + 1] + cost);\n        }\n        */\n        // keep dpm1 for j <= k where 2 * (x[j] - x[i]) <= T\n        // keep dpm2 for j >= k where 2 * (x[j] - x[i]) > T\n        while (k > i && 2 * (x[k - 1] - x[i]) > T) {\n            dpm1.erase({val1(k), k});\n            dpm2 = min(dpm2, val2(k)); // k > 0\n            k--;\n        }\n        if (dpm1.size() > 0)\n            dp[i] = min(dp[i], dpm1.cbegin()->first + T - x[i]);\n        dp[i] = min(dp[i], dpm2 - 3 * x[i]);\n        dpm1.insert({val1(i), i});\n    }\n\n    long long res = dp[0] + x[0] + E - x[N - 1];\n    printf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e17;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 1;\n    ll now = 1e17;\n    for(int i = 1; i <= N; i++) {\n        now += 2 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before]) >= T) {\n            now = min(now, dp[before - 1] + (x[i] - x[before - 1]) + 2 * (x[i] - x[before]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        //dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i - 1] << \" \" << x[i] << \" \" <<x[i - 1] << \" \" << T << endl;\n        //cout << i << \" \" << dp[i - 1] + x[i] - x[i - 1] + T << endl;\n        //cout << i << \" \" << dp[i] << endl;\n        //if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        dp[i] = min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + T + x[i] - x[before]);\n        //cout << i << \" \" << min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + T + x[i] - x[before]) << endl;\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << now << endl;\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t;\nint x[100005];\nll dp[100005];\nint main(){\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++){\n        dp[i] = 1000000000000000000;\n        while (pivot < i && 2*(x[i]-x[pivot+1]) > t) {\n            mn = min(mn,dp[pivot]-2*x[pivot+1]);\n            pivot++;\n        }\n        //printf(\"pivot for %d = %d\\n\",i,pivot);\n        dp[i] = min(2*x[i]+mn,dp[pivot]+t);\n        //printf(\"%lld first\\n\",dp[i]);\n        /*dp[i] = 1000000000000000000;\n        for (int j = 0; j < i; j++){\n            if ((x[i]-x[j+1])*2 <= t){\n                //printf(\"pivot at %d\\n\",j);\n            }\n            //printf(\"%lld + %d\\n\",dp[j],max(t,(x[i]-x[j+1])*2));\n            dp[i] = min(dp[i],dp[j]+max(t,(x[i]-x[j+1])*2));\n        }\n        printf(\"%lld second\\n\",dp[i]);*/\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nint N, E, T;\nvector<int> X;\nvector<ll> dp;\n\nll f(int i, int j){\n    return dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    cin >> N >> E >> T;\n    X.assign(N + 1, 0);\n    rep(i, 1, N + 1) cin >> X[i];\n    \n    // i\n    dp.assign(N + 1, 1LL << 60);\n    dp[0] = 0;\n    rep(i, 1, N + 1){\n        \n        int l = 0; int r = i - 1;\n        while(l + 2 < r){\n            int ml = (2 * l + r) / 3;\n            int mr = (l + 2 * r) / 3;\n            if(f(i, ml) < f(i, mr)){\n                r = mr;\n            }\n            else{\n                l = ml;\n            }\n        }\n        rep(j, l, r + 1){\n            dp[i] = min(dp[i], f(i, j));\n        }\n        \n        \n//        rep(j, i){\n//            dp[i] = min(dp[i], dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1]);\n//        }\n    }\n    \n    ll ret = dp[N] + (E - X[N]);\n    \n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = x[i] - x[j + 1] + f[j];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\t/*for (int j = max(0, i - 100000000 / n); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t\tfor (int j = 0; j < min(i, 100000000 / n); j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\n\t\t}*/\n\t\twhile (p + 1 < i && calc(p, i) > calc(p + 1, i)) ++p;\n\t\tf[i] = min(f[i], calc(p, i));\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n#include <bits/stdc++.h>\n//#include \"testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n\nbool debug=true;\n\n/*    *************************************\n\t  * Written in New Computer           *\n\t  * The following code belongs to     *\n\t  * XiaoGeNintendo of HellHoleStudios *\n\t  *************************************\n*/\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,pair<T1,T2> ptt){\n\tos<<ptt.first<<\",\"<<ptt.second;\n\treturn os;\n}\ntemplate<typename T>ostream& operator<<(ostream& os,vector<T> vt){\n\tos<<\"{\";\n\tfor(int i=0;i<vt.size();i++){\n\t\tos<<vt[i]<<\" \";\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll n,t,e;\nll dp[100005];\nll x[100005];\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n>>e>>t;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i];\n\t}\n\t\n\t//dp[i]=min{dp[j]+max{t,2*(x[i]-x[j])}}\n\t//dp[i]=min{dp[j]+2*(x[i]-x[j])} or dp[i]=min{dp[j]+t} <-easy\n\t//dp[i]=2*x[i]+min{dp[j]-2*x[j])} \n\tll last=0,mn=-2*x[0];\n\tfor(int i=0;i<n;i++){\n\t\tif(2*(x[i]-x[0])<=t){\n\t\t\tdp[i]=t;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\twhile(2*(x[i]-x[last+1])>t){\n\t\t\tmn=min(mn,dp[last]-2*x[last+1]);\n\t\t\tlast++;\n\t\t}\n\t\t\n\t\tdp[i]=min(mn+2*x[i],dp[last]+t);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\treturn 0;\n}\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n#include <bits/stdc++.h>\n//#include \"testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n\nbool debug=true;\n\n/*    *************************************\n\t  * Written in New Computer           *\n\t  * The following code belongs to     *\n\t  * XiaoGeNintendo of HellHoleStudios *\n\t  *************************************\n*/\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,pair<T1,T2> ptt){\n\tos<<ptt.first<<\",\"<<ptt.second;\n\treturn os;\n}\ntemplate<typename T>ostream& operator<<(ostream& os,vector<T> vt){\n\tos<<\"{\";\n\tfor(int i=0;i<vt.size();i++){\n\t\tos<<vt[i]<<\" \";\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll n,t,e;\nll dp[100005];\nll x[100005];\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n>>e>>t;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i];\n\t}\n\t\n\t//dp[i]=min{dp[j]+max{t,2*(x[i]-x[j])}}\n\t//dp[i]=min{dp[j]+2*(x[i]-x[j])} or dp[i]=min{dp[j]+t} <-easy\n\t//dp[i]=2*x[i]+min{dp[j]-2*x[j])} \n\tll last=0,mn=-2*x[0];\n\tfor(int i=0;i<n;i++){\n\t\tif(2*(x[i]-x[0])<=t){\n\t\t\tdp[i]=t;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\twhile(2*(x[i]-x[last+1])>t){\n\t\t\tmn=min(mn,dp[last]-2*x[last+1]);\n\t\t\tlast++;\n\t\t}\n\t\t\n\t\tdp[i]=min(mn+2*x[i],dp[last]+t);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#define maxn 100009\n#define lson 1,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nconst long long INF=1e18;\nlong long tree[maxn];\nint n,E,T;\nlong long a[maxn],dp[maxn];\nlong long f[maxn];\nvoid pushup(int rt){\n\ttree[rt]=min(tree[rt<<1],tree[rt<<1|1]);\n}\nvoid build(int l,int r,int rt){\n\ttree[rt]=INF;\n\tif(l==r){\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n}\nvoid update(int L,int R,long long val,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\ttree[rt]=min(tree[rt],val);\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(L<=m)\n\t\tupdate(L,R,val,lson);\n\tif(R>m)\n\t\tupdate(L,R,val,rson);\n\tpushup(rt);\n}\nlong long query(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)\n\t\treturn tree[rt];\n\tlong long res1=INF,res2=INF;\n\tint m=(l+r)>>1;\n\tif(L<=m) res1=query(L,R,lson);\n\tif(R>m) res2=query(L,R,rson);\n\treturn min(res1,res2);\n}\nint main(){\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tbuild(1,n,1);\n\tdp[0]=0;\n\tupdate(1,1,dp[0]-a[0],1,n,1);\n\tdp[0]=0;\n\tf[0]=INF;\n\tfor(int i=1;i<=n;i++){\n\t\tint L=1,R=i;\n\t\twhile(L<R){\n\t\t\tint M=(L+R)>>1;\n\t\t\tif(2LL*(a[i]-a[M])<=T)\n\t\t\t\tR=M;\n\t\t\telse\n\t\t\t\tL=M+1;\n\t\t}\n\t\tlong long res=query(R,i,1,n,1);\n\t\tdp[i]=res+a[i]+T;\n\t\tif(R>1){\n\t\t\tdp[i]=min(dp[i],f[R-1]+3*a[i]);\n\t\t}\n\t\tf[i]=min(f[i-1],dp[i-1]+a[i]-a[i-1]-3*a[i]);\n\t\tupdate(i+1,i+1,dp[i]-a[i],1,n,1);\n\t}\n\tcout<<dp[n]+E-a[n]<<endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<numeric>\n#include<iomanip>\n#include<utility>\n#include<cstdlib>\n#include<typeinfo>\n#include<stack>\n#include<cassert>\n#include<functional>\n#define int long long int\n#define double long double\nusing namespace std;\n#define INT_MAX 1000000005\n#define INF 1000000005\nconst int MAX_N = 1 << 17;\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nsigned main()\n{\nint n,t,e;\nstd::cin >> n >> e >> t;\nstd::vector<int> x;\nfor(int i = 0; i < n; i++){\n    int temp;\n    std::cin >> temp;\n    x.push_back(temp);\n}\nint sum = 0;\nsum += n * t + e;\nfor(int i = 0; i < n - 1; i++){\n    if((x[i + 1] - x[i]) * 2 < 2 * t){\n        sum -= 2 * t - (x[i + 1] - x[i]) * 2; \n    }\n}\nstd::cout << sum << std::endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n;\nll E, T;\nvll x;\n\nll memo[2001][2001];\n\nll rec(int l, int r){\n    ll& ret = memo[l][r];\n    if(ret != -1) return ret;\n\n    ll dist = x[r - 1] - x[l];\n    ret = 2LL * dist + max(T - 2 * dist, 0LL);\n\n    rep(i, l + 1, r){\n        chmin(ret, rec(l, i) + rec(i, r));\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> n >> E >> T;\n    assert(n <= 2000);\n\n    rep(i, n + 1) rep(j, n + 1) memo[i][j] = -1;\n\n    x = vll(n);\n    for(auto& e : x) cin >> e;\n\n    cout << E + rec(0, n) << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=max(i+1,beg-5);j<=min(n,beg+8000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[2002];\nLL dp[2002];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e16;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 0;\n    ll now = 1e16;\n    for(int i = 1; i <= N; i++) {\n        now += 2 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before + 1]) > T) {\n            now = min(now, dp[before] + (x[i] - x[before]) + 2 * (x[i] - x[before + 1]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i] << endl;\n        if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,arr[MAX],dp[MAX],tot[MAX],pre[MAX],nxt[MAX];\n\n/*int cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}*/\n\nvoid solve()\n{\n\tdp[N]=T+E-arr[N];\n\ttot[N]=3*arr[N]+T-arr[N];\n\tfor(int A=N-1;A>=1;A--)\n\t{\n\t\tdp[A]=pre[A]+arr[nxt[A]+1]-arr[nxt[A]]+dp[nxt[A]+1];\n\t\tif(nxt[A]<N)\n\t\t\tdp[A]=min(dp[A],-3*arr[A]+tot[nxt[A]+1]);\n\t\ttot[A]=min(tot[A+1],3*arr[A]+arr[A+1]-arr[A]+dp[A+1]);\n\t}\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tfor(int A=1;A<=N;A++)\n\t{\n\t\tint low=A,high=N,mid,res=A;\n\t\twhile(low<=high)\n\t\t{\n\t\t\tmid=(low+high)/2;\n\t\t\tif(T-2*(arr[mid]-arr[A])>0)\n\t\t\t{\n\t\t\t\tres=mid;\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh=mid-1;\n\t\t}\n\t\tnxt[A]=res;\n\t\tpre[A]=T-2*(arr[res]-arr[A])+3*(arr[res]-arr[A]);\n\t}\n\tsolve();\n\tcout<<arr[1]+dp[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll p[2123];\nll cache[2123][2123];\nbool seen[2123][2123];\nll n, e, t;\n\n//x = curpos\n//y = first coin\n//x >= y\nll dp(ll x, ll y)\n{\n\tif (x == n) return 0;\n\tif (seen[x][y]) return cache[x][y];\n\tseen[x][y] = true;\n\n\tll ans1 = -1, ans2 = -1;\n\tif (x + 1 < n)\n\t\tans1 = p[x+1] - p[x] + dp(x+1, y);\n\tans2 = p[x] - p[y] + max(0ll, t - 2*(p[x] - p[y])) + p[x+1] - p[y] + dp(x+1, x+1);\n\tif (ans1 > -1) ans2 = min(ans2, ans1);\n\tcache[x][y] = ans2;\n\treturn ans2;\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> p[n] >> t;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tcout << dp(0, 0) + p[0] << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \nconst ll INF = 1ll<<50;\n \n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return seg[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n \nconst int MAXN = 100100;\nint N, E, T;\nint X[MAXN];\nll dp[MAXN];\n \nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i];\n\tconst ll INF = 1ll<<60;\n\tST<ll> seg(N+10);\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i] = INF;\n\t}\n\tX[N] = E;\n\tdp[N] = 0;\n\tseg.update(N, dp[N] + X[N] + 2*X[N-1]);\n\tfor (int i = N-1; i >= 0; i--) {\n\t\t// まず T が支配的な部分を探索\n\t\tint low = i, high = N;\n\t\twhile (high - low > 1) {\n\t\t\tconst int med = (low + high) / 2;\n\t\t\tif (2*(X[med]-X[i]) <= T) {\n\t\t\t\tlow = med;\n\t\t\t} else {\n\t\t\t\thigh = med;\n\t\t\t}\n\t\t}\n\t\t//cout << i << \" \" << low << endl;\n\t\tdp[i] = dp[low+1] + X[low+1] - X[i] + T;\n\t\tdp[i] = min(dp[i], seg.query(low+1, N) - 3ll*X[i]);\n\t\tif (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n\t\t//cout << i << \" \" << dp[i] << endl;\n\t}\n\tcout << X[0] + dp[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://discuss.codechef.com/t/robagain-editorial/20734\n#pragma GCC optimize(\"O3\")\n#include<queue>\n#include <cmath>\n#include <complex>\n#include<map>\n#include <string>\n#include<iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <stdio.h>\n#include<bits/stdc++.h>\n\n\n/*\n#define x real()\n#define y imag()\n#define angle(a)                (atan2((a).imag(), (a).real()))\n#define vec(a,b)                ((b)-(a))\n#define same(p1,p2)             (dp(vec(p1,p2),vec(p1,p2)) < EPS)\n#define dp(a,b)                 ( (conj(a)*(b)).real() )\t// a*b cos(T), if zero -> prep\n#define cp(a,b)                 ( (conj(a)*(b)).imag() )\t// a*b sin(T), if zero -> parllel\n#define length(a)               (hypot((a).imag(), (a).real()))\n#define normalize(a)            (a)/length(a)\n//#define polar(r,ang)            ((r)*exp(point(0,ang)))  ==> Already added in c++11\n#define rotateO(p,ang)          ((p)*exp(point(0,ang)))\n#define rotateA(p,ang,about)  (rotateO(vec(about,p),ang)+about)\n#define reflectO(v,m)  (conj((v)/(m))*(m))\n*/\n\n//#define pi 3.141592654\n#define forr(i,a,b) for(int i=a;i<=b;i++)\n#define F first\n#define S second\n#define input ios_base::sync_with_stdio(0);cin.tie(0);\n#define NOT(x) (1^x)\n\nconst double PI  = acos(-1.0);\nusing namespace std;\ntypedef pair<double,double>pdd;\ntypedef long long  ll;\ntypedef pair<ll, ll>pii;\ntypedef complex<double> point;\n\n//int x[8]={1,0,0,-1,-1,-1,1,1};\n//int y[8]={0,1,-1,0,-1,1,-1,1};\n//const int N=500009,M=1000000;\nconst double EPS= 1e-9,eps=-1e9;\nconst int N =100005;\n\nll n,e,t,mem[N][2],x;\nvector<ll>a,b;\nll dp(int i=0,int ck=0)\n{\n    if(i>=n)return 0;\n    ll&ret=mem[i][ck];\n    if(~ret)return ret;\n    ret=4e18;\n    auto it=upper_bound(a.begin(),a.end(),a[i]+t/2);\n    int j=it-a.begin();\n    if(ck==0){\n        ret=min(ret,dp(b[j],0)+t);\n        if(i+1!=n)ret=min(ret,dp(b[j],1)+(a[j]-a[i])*(ll)2);\n    }\n    else{\n        ret=min(ret,dp(i+1,0));\n        if(i+1!=n)ret=min(ret,dp(i+1,1)+(a[i+1]-a[i])*(ll)2);\n    }\n    return ret;\n}\n int main()\n{\n//freopen(\"travel.in\",\"r\",stdin);\n//freopen(\"travel.out\",\"w\",stdout);\n//__builtin_popcount()\ninput;\n\n\n      cin>>n>>e>>t;\n      for(int i=0;i<n;i++)\n      {\n          cin>>x;\n          a.push_back(x);\n          b.push_back(i);\n      }\n      a.push_back(4e18);\n      b.push_back(n);\n      memset(mem,-1,sizeof mem);\n      cout<<e+dp()<<endl;\n\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T>\nostream& operator<<(ostream& o, vector<T>& v) {\n    for (auto& x : v) o << x << ' ';\n    return o;\n}\nconst int MAXN = 100010;\nll n, T, E;\n\nll arr[MAXN];\n\nll memo_small[MAXN];\nll dp_small(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo_small[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    res = LLONG_MAX/2;\n    for (int i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        ll cur = pre + max(2LL * d, T) + d + dp_small(i + 1);\n        if (cur < res) res = cur;\n    }\n    return res;\n}\n\nvoid solve_small(){\n    memset(memo_small, -1, sizeof memo_small);\n    ll res = dp_small(0);\n    cout << res << endl;\n}\n\nll memo[MAXN];\nll dp(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    int i;\n    for (i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        if (i != id) {\n            ll di = arr[i] - arr[i-1];\n            if (di > T) break;\n        }\n        if (2LL * d > (i - id + 1) * T) break;\n    }\n    //cerr << id << ' ' << i-1 << endl;\n    ll d = arr[i-1] - arr[id];\n    res = pre + max(2LL * d, T) + d + dp(i);\n    return res;\n}\nvoid solve_large(){\n    memset(memo, -1, sizeof memo);\n    ll res = dp(0);\n    cout << res << endl;\n}\n\nint main(){\n    std::ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> E >> T;\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    if (n <= 2000) solve_small();\n    else solve_large();\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n#define inf 1LL << 60\n\n\nint n, i;\nll E, T;\nll x[maxN];\nll dp[maxN];\n\nint pp;\ndeque<int> far, close;\n\nll cost(ll l, ll r) {\n    return dp[l] + (x[r] - x[l]) + max(T, 2 * (x[r] - x[l + 1]));\n}\n\nvoid add(deque<int>& Q, int pos, int refe) {\n    while (!Q.empty()) {\n        int last = Q.back();\n        if (cost(last, refe) < cost(pos, refe)) break;\n        Q.pop_back();\n    }\n\n    Q.push_back(pos);\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%lld%lld\", &n, &E, &T);\n    for (i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n\n    pp = -1;\n    add(close, 0, 1);\n\n    for (i = 1; i <= n; i++) {\n        while (pp + 1 < i && T < 2LL * (x[i] - x[pp + 2])) {\n            pp++;\n            add(far, pp, i);\n        }\n\n        while (!close.empty()) {\n            if (close.front() > pp) break;\n            close.pop_front();\n        }\n\n        ll d1 = inf;\n        if (!far.empty()) d1 = cost(far.front(), i);\n\n        ll d2 = inf;\n        if (!close.empty()) d2 = cost(close.front(), i);\n\n        dp[i] = min(d1, d2);\n        add(close, i, i + 1);\n    }\n\n    printf(\"%lld\", dp[n] + E - x[n]);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\n#define LL long long\nint st1[MAXN],st2[MAXN],r,l,r2;\nLL dp[MAXN],a[MAXN],T;\nint n,m;\nint main()\n{\n//\tfreopen(\"computer.in\",\"r\",stdin);\n//\tfreopen(\"computer.out\",\"w\",stdout);\n\tscanf(\"%d%d%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tdp[1]=T;\n\tint j=1;\n\tst2[r2++]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile((a[i]-a[j])*2>=T)\n\t\t{\n\t\t\twhile(r)\n\t\t\t{\n\t\t\t\tint k=st1[r-1];\n\t\t\t\tif(dp[k-1]-a[k]*2>=dp[j-1]-a[j]*2)\n\t\t\t\t\tr--;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tst1[r++]=j;\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=dp[st1[0]-1]+2*(a[i]-a[st1[0]]);\n\t\twhile(st2[l]<j&&l<r2) l++;\n\t\twhile(l<r2&&dp[i-1]<=dp[st2[r2-1]-1])\n\t\t\tr2--;\n\t\tst2[r2++]=i;\n\t\tdp[i]=min(dp[i],dp[st2[l]-1]+T);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\nll g(ll l,ll r){\n    ll dis=d[r]-d[l];\n    return max(dis*2,t);\n}\nll f[N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    lol(i,n)cin>>d[i+1];\n    if(n>N)return 0;\n    lol(i,N)f[i]=1e18; f[0]=0;\n    lol(i,n){\n\tfor(ll j=i+1;j<=n;j++){\n\t    chmin(f[j],f[i]+g(i+1,j));\n\t}\n    }\n    cout<<f[n]+e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nint main(){\n  int n;\n  long long e,t;\n  scanf(\"%d%lld%lld\", &n,&e,&t);\n\n  vector<long long> x(n);\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  long long w = 1ll<<57;\n\n  for(int i=0, j=0; i<n; ++i){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      w = min(w, dp[j] + 2*(x[i] - x[j]));\n      j++;\n    }\n\n    dp[i+1] = min(dp[i+1], w);\n    if(j<=i) dp[i+1] = min(dp[i+1], dp[j] + max(2*(x[i]-x[j]) ,t));\n\n    w += 2*(x[i+1] - x[i]);\n  }\n  printf(\"%lld\\n\", dp[n] + e);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t &x, int64_t y) {\n    if (x > y) x = y;\n}\n\nint64_t dp[2020][2020];\n\nint main() {\n    int n;\n    int64_t T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<int64_t> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    if (n > 2000) return 0;\n\n    fill_n(*dp, 2020 * 2020, 1e17);\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            // wait\n            if (j == 0) {\n                chmin(dp[i + 1][0], dp[i][j] + T + d[i]);\n            }\n\n            // return\n            if (j > 0) {\n                int64_t dist = ds[i] - ds[i - j];\n                chmin(dp[i + 1][0], dp[i][j] + d[i] + max(0LL, T - 2 * dist) + dist * 2);\n            }\n\n            // ignore\n            if (i < n - 1) {\n                chmin(dp[i + 1][j + 1], dp[i][j] + d[i]);\n            }\n        }\n    }\n\n    int64_t ans = dp[n][0] + x[0] + (E - x[n - 1]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <ll> vi;\ntypedef pair <ll, ll> pi;\ntypedef vector <pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) (ll) x.size()\n#define f first\n#define s second\n#define MAXN 100100\nll INF = 1e18;\ndeque<pi> dq;\nll max_constant;\nll N,E,T;\nll off;\nll D[MAXN];\nll dp[MAXN];\nll d2[MAXN];\nqueue<pi> Q;\nmultiset<ll> S2;\nll X[MAXN];\n \nint main(){\n\tcin>>N>>E>>T;\n\tfor (int i=1;i<=N;++i)cin>>D[i];\n\t// X[0] = 0;\n\t// for (int i=1;i<=N;++i){\n\t// \tX[i] = INF;\n\t// \tfor (int j=0;j<i;++j){\n\t// \t\tX[i] = min(X[i], X[j] + D[i] - D[j] + max(T, 2*D[i] - 2*D[j+1]) );\n\t// \t}\n\t// }\n\n\tmax_constant = INF;\n\tQ.push(mp(T+2*D[1], -2*D[1]));\n\tS2.insert(T);\n \n\tfor (int i=1;i<=N;++i){\n\t\twhile (SZ(Q) && Q.front().f <= 2*D[i]){\n\t\t\tpi cur = Q.front();Q.pop();\n\t\t\tmax_constant = min(max_constant, cur.s);\n\t\t\tS2.erase(S2.find(cur.f+cur.s));\n\t\t}\n\t\t// cout<<max_constant<<'\\n';\n\t\tdp[i] = INF;\n\t\t// Case 1 is using the constant\n\t\tdp[i] = min(dp[i], 3*D[i]+max_constant);\n\t\t// Case 2: is waiting\n\t\tdp[i] = min(dp[i], T + D[i] - D[i-1] + dp[i-1]);\n\t\t// Case 3: Need to wait\n\t\tif (SZ(S2))dp[i] = min(dp[i], *S2.begin() + D[i]);\n\t\t// cout<<i<<' '<<-2*D[i+1]<<' '<<D[i]<<' '<<dp[i]<<' '<<-2*D[i+1] - D[i]+ dp[i]<<'\\n';\n\t\tQ.push(mp(T+2*D[i+1], -2*D[i+1] - D[i]+ dp[i]));\n\t\tS2.insert(T-D[i]+dp[i]);\n\t\t// cout<<\"Ins \"<<T-D[i]+dp[i]<<'\\n';\n\t\t// cout<<X[i]<<' '<<dp[i]<<'\\n';\n\t\t// assert(dp[i] == X[i]);\n\t}\n\tcout<<dp[N] + E-D[N];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <ll> vi;\ntypedef pair <ll, ll> pi;\ntypedef vector <pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) (ll) x.size()\n#define f first\n#define s second\n#define MAXN 100100\nll INF = 1e18;\ndeque<pi> dq;\nll max_constant;\nll N,E,T;\nll off;\nll D[MAXN];\nll dp[MAXN];\nqueue<pi> Q;\nmultiset<ll> S2;\n\nint main(){\n\tcin>>N>>E>>T;\n\tfor (int i=1;i<=N;++i)cin>>D[i];\n\tdp[0] = 0;\n\tmax_constant = -INF;\n\tQ.push(mp(T, 2*D[1]));\n\tS2.insert(T+2*D[1]);\n\n\tfor (int i=1;i<=N;++i){\n\t\twhile (SZ(Q) && Q.front().f <= 2*D[i]){\n\t\t\tpi cur = Q.front();Q.pop();\n\t\t\tmax_constant = max(max_constant, cur.s);\n\t\t\tS2.erase(S2.find(cur.f+cur.s));\n\t\t}\n\t\t// cout<<max_constant<<'\\n';\n\t\tdp[i] = INF;\n\t\t// Case 1 is using the constant\n\t\tdp[i] = min(dp[i], 3*D[i]-max_constant);\n\t\t// cout<<\"Case 1 \"<<i<<' '<<dp[i]<<'\\n';\n\t\t// Case 2: is waiting\n\t\tdp[i] = min(dp[i], T + D[i] - D[i-1] + dp[i-1]);\n\t\t// cout<<\"Case 2 \"<<i<<' '<<dp[i]<<'\\n';\n\t\t// Case 3: Need to wait\n\t\tif (SZ(S2))dp[i] = min(dp[i], *S2.begin() + D[i]);\n\t\tQ.push(mp(T+2*D[i], -2*D[i+1] - D[i]+ dp[i]));\n\t\tS2.insert(T+2*D[i]-2*D[i+1]-D[i]+dp[i]);\n\t\t// cout<<i<<' '<<dp[i]<<'\\n';\n\t}\n\tcout<<dp[N] + E-D[N];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ninline void gtmn(LL &a,LL b){\n\tif (a>b) a=b;\n}\nint a[100010];\nLL dp[100010];\nint main(void){\n\tmemset(dp,127,sizeof(dp));\n\tdp[0]=0;\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\ta[0]=0;\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tgtmn(dp[i+1],dp[i]+a[i+1]-a[i]+t);\n\t\tint l=i+1,r=n+1;\n\t\twhile(l+1<r){\n\t\t\tint md=(l+r)>>1;\n\t\t\tif (((a[md]-a[i+1])<<1)<t){\n\t\t\t\tl=md;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=md;\n\t\t\t}\n\t\t}\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t\t++l;\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\",dp[n]+e-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n\n  vector< T > seg;\n  int sz;\n\n  SegmentTree(int n) : INF(numeric_limits< T >::max())\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  int64 N, T, E, X[100002];\n\n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n\n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]-X[j+1]*2+X[i]*2\n  // dp2[j]=dp[j]-X[j+1]*2\n  */\n\n\n  SegmentTree< int64 > dp1(N + 1), dp2(N + 1);\n\n  dp1.update(0, 0);\n  dp1.update(1, E);\n  dp2.update(0, dp1.rmq(0, 1) - X[1] * 2);\n  dp2.update(1, dp1.rmq(1, 2) - X[2] * 2);\n  int tail = 0;\n\n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while((X[i] - X[tail + 1]) * 2 > E) ++tail;\n    dp1.update(i, min(dp1.rmq(tail, i) + E, X[i] * 2 + dp2.rmq(0, tail)));\n    dp2.update(i, dp1.rmq(i, i + 1) - X[i + 1] * 2);\n  }\n  cout << dp1.rmq(N, N + 1) + T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nvi dp,in;\nll n,e,t;\nll f(ll i,ll j){return dp[j]+in[j+1]-in[j]+max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];}\nint main(){\n\tcin>>n>>e>>t;\n\tin=vi(n+1);\n\trep(i,n)cin>>in[i+1];\n\tdp=vi(n+1,inf);\n\tdp[0]=0;\n\trep(i,n){\n//rep(j,i+1){\n\t\tll l=0,r=i;\n\t\twhile(r-l>5){\n\t\t\tll h1=(r-l)/3+l;\n\t\t\tll h2=(r-l)/3*2+l;\n\t\t\tll s1=f(i,h1);\n\t\t\tll s2=f(i,h2);\n\t\t\tif(s1>s2)l=h1;\n\t\t\telse r=h2;\n\t\t}\n\t\tll mi=inf;\n\t\tloop(j,max<ll>(l-5,0),min<ll>(i+1,r+5))mi=min<ll>(mi,f(i,j));\n\t\tdp[i+1]=mi;\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 1LL << 62;\n        for (int j = i - 1; j >= 0; --j) {\n            int64_t nval = dp[j] + X[j + 1] - X[j] + \n                    3LL * (X[i] - X[j + 1]) + max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n            dp[i] = min(dp[i], nval);\n        }\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, E, T, a[100001];\nlong long f[100001], g[100001];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tg[0] = 2 * -a[1];\n\tfor (int i = 1, j = 0; i <= N; i++)\n\t{\n\t\twhile (2 * (a[i] - a[j + 1]) > T)\n\t\t\tj++;\n\t\tf[i] = f[j] + T;\n\t\tif (j)\n\t\t\tf[i] = std::min(f[i], 2 * a[i] + g[j - 1]);\n\t\tif (i < N)\n\t\t\tg[i] = std::min(g[i - 1], f[i] - 2 * a[i + 1]);\n\t}\n\tprintf(\"%lld\\n\", f[N] + E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tf[i] = max(2 * (d[i] - d[1]),t);\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\twhile (2 * (d[i] - d[pp + 1]) > t) {\n\t\t\tf[i] = min(f[i],f[pp] + 2 * (d[i] - d[pp + 1]));\n\t\t\tpp++;\n\t\t}\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\tf[i] = min(f[i],f[pp] + t);\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n\t}\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 1E5 + 100;\nconst LL INF = 1E18;\nint x[N];\nLL f[N];\n\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    FOR (i, 1, n + 1) cin >> x[i];\n    FOR (i, 1, n + 1) {\n        f[i] = INF;\n        FOR (j, 1, i + 1) {\n            f[i] = min(f[i], f[j - 1] + max(2 * (x[i] - x[j]), t) + x[i] - x[j - 1]);\n        }\n        dbg(i, f[i]);\n    }\n    cout << f[n] + (e - x[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 4;\n\nint main()\n{\n    int n, e, t;\n    cin >> n >> e >> t;\n\n    vector<int> x(n+1);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n    x[n] = e;\n\n    vector<long long> dp(n+1, INF);\n    dp[0] = x[0];\n    int j = 0;\n    long long tmp = INF;\n    for(int i=0; i<n; ++i){\n        while(j < i && (x[i] - x[j]) * 2LL > t){\n            tmp = min(tmp, dp[j] - x[j] * 3LL);\n            ++ j;\n        }\n        dp[i+1] = min(tmp + x[i] * 3LL, dp[j] + t) + (x[i+1] - x[i]);\n    }\n    cout << dp[n] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long n,e,t,f[10001],a[10001];\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tf[i]=f[i-1]+(a[i]-a[i-1])+t;\n\t\tfor (int j=i-1; j>=1; --j)\n//\t\t\tf[i]=min(f[i],f[j-1]+(a[i]-a[j])*3+(a[j]-a[j-1])+max(1ll*0,t-2*(a[i]-a[j]))); \n\t\t\tf[i]=min(f[i],f[j-1]+3*a[i]-2*a[j]-a[j-1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = upper_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j > 0){\n            tmp1 = sgt2.query(0, min(j, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconstexpr LL INF = 1e18;\nLL dp[2001];\nLL N, T, E;\nLL x[2001];\n\nint main() {\n    scanf(\"%lld %lld %lld\", &N, &E, &T);\n    for(int i = 1; i<=N; ++i) scanf(\"%lld\", x+i);\n    dp[1] = x[1]+T;\n    for(int i = 2; i<=N; ++i) {\n        LL mn = dp[i-1]+x[i]-x[i-1]+T;\n        for(int j = 1; j<i; ++j) {\n            //cerr << i << \" \" << mn << endl;\n            mn = min(max(0LL, T-2*(x[i]-x[j]))*(j-i+1)+3*(x[i]-x[j])+dp[j]-T, mn);\n        }\n        //cerr << i << \" \" << mn << endl;\n        dp[i] = mn;\n    }\n    printf(\"%lld\\n\", dp[N]+E-x[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/* Karen {{{\n  ___  ____\n |_  ||_  _|\n   | |_/ /    ,--.   _ .--.  .---.  _ .--.\n   |  __'.   `'_\\ : [ `/'`\\]/ /__\\\\[ `.-. |\n  _| |  \\ \\_ // | |, | |    | \\__., | | | |\n |____||____|\\'-;__/[___]    '.__.'[___||__]\n}}} */\n/* cpp template {{{*/\nusing namespace std;\n\n#define endl '\\n'\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define REPS(i, a, n) for (int i = (a); i < (n); i++)\n#define RREP(i, n) for (int i = 1; i <= (n); i++)\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ALL(v) v.begin(), v.end()\n\ntypedef double D;\ntypedef int ll;\ntypedef long double lb;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\ntypedef pair<int, int> pii;\ntypedef pair<int, string> pis;\ntypedef pair<string, int> psi;\n\ninline bool inside(int y,int x,int H,int W){return(y>=0&&x>=0&&y<H&&x<W);}\ninline int in() {int x; std::cin >> x; return x;}\n\ntemplate <typename T>\nvoid print(std::vector<T>& v, char c = ' ') {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << c;\n    std::cout << v[i];\n  }\n  std::cout << endl;\n}\ntemplate <typename T>\nvoid print(T x) {\n  std::cout << x << '\\n';\n}\n/* }}} */\n/* 定数 {{{*/\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9 + 9;\nconst D EPS  = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n/* }}} */\n\n#define int long long\n\nint x[101010];\nint n, e, T;\n\nint cost;\n\nint dp[101010];\n\nint dfs(int i=1, int now=0, int t=T)\n{\n  int d = x[i] - x[now];\n  int dt = max(0ll, t - 2ll * d);\n  int dT = max(0ll, T - 2ll * d);\n  if (i == n) return t;\n  int &ret = dp[i];\n  if (ret != -1) return ret;\n  ret = min(t + d + dfs(i + 1, now + 1, T), dt + 3 * d + dfs(i + 1, now + 1, dT));\n\n  return ret;\n}\n\nsigned main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> n >> e >> T;\n  REP(i, n) cin >> x[i];\n\n  cost += x[0] + e - x[n - 1];\n\n  cout << dfs() + cost + n - 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e17;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    int n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    \n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=upper_bound(x,x+n,(x[i]-T))-x;\n        j--;\n        if(j>=0){\n            dp[i]=dp2[j]+x[i]*2;\n        }\n        \n        dp[i]=min(dp[i-1]+2*T,dp[i]);\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n       // cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n        \n    }\n    \n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll f[maxn],xx[maxn];\nll n,e,t;\nll store;//fj-2xj+1\nint main(){\n\tll b1,b2,b3,b4;\n\tll p;//定位\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\t\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\tfor (b1=1;b1<=n;b1++){\n\t\tf[maxn]=b1*t;\n\t}\n\tp=0;store=((ll)1<<60);\n\tfor (b1=1;b1<=n;b1++){\n\t\twhile (2*xx[p+1]<=2*xx[b1]-t){\n\t\t\tstore=min(store,f[p]-2*xx[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tf[b1]=min(2*xx[b1]+store,f[p]+t);\n\t\tf[b1]=min(f[b1-1]+t,f[b1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=2010;\n\tconst ll INF=9223372036854775807ll;\n\tint a[N],b[N];\n\tint n,m;\n\tll ans;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=a[n];\n\t\tfor(int i=1,j;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;get_dis(i,j+1)*2<=m;j++);\n\t\t\tans+=m;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n//\tfreopen(\"out\",\"w\",stdout);\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\nconst llint inf = 1e18;\n\nint x[MAX];\nllint f[MAX];\n\nint main(void) {\n  int N, E, T;\n  scanf(\"%d %d %d\", &N, &E, &T);\n  REP(i, N) scanf(\"%d\", &x[i]);\n  \n  f[0] = 0;\n  multiset<llint> S2;\n  S2.insert(f[0] - x[0]);\n  \n  int j = 0;\n  llint best = inf;\n  for (int i = 1; i <= N; ++i) {\n    while (j < i && 2*(x[i-1] - x[j]) > T) {\n      S2.erase(S2.find(f[j] - x[j]));\n      best = min(best, f[j] - 2*x[j]);\n      j++;\n    }\n\n    f[i] = best + 2*x[i-1];\n    if (S2.size()) f[i] = min(f[i], *S2.begin() + T + x[i-1]);\n    S2.insert(f[i] - x[i]);\n  }\n\n  llint ans = E + f[N];\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmultiset <int> C, D;\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0, cnt = 1000;\n\tint now = 0;\n\tC.insert(dp[0] - A[0] + T);\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\twhile((A[i] - A[now + 1]) * 2 >= T && now < i) {\n\t\t\tC.erase(C.find(dp[now] - A[now] + T));\n\t\t\tD.insert((dp[now] - A[now + 1] * 2 - A[now])); \n\t\t\t++ now;\n\t\t}\n\n\t\tif(C.size()) dp[i] = min(dp[i], *C.begin() + A[i]);\n\t\tif(D.size()) dp[i] = min(dp[i], *D.begin() + A[i] * 3);\n\n\t\tC.insert(dp[i] - A[i] + T);\n\t\tdp[i] = min(dp[i], calc(i - 1, i));\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define NMAX 100005\n\nll t[4*NMAX], a[NMAX];\nll n, e, T;\nvoid upd(int i, int s, int e, int indx, ll val){\n\tif(s == e){\n\t\tt[i] = val;\n\t\treturn;\n\t}\n\tint m = (s + e)/2;\n\tif(indx <= m) upd(i*2, s, m, indx, val);\n\telse upd(i*2+1, m+1, e, indx, val);\n\tt[i] = min(t[i*2], t[i*2+1]);\n}\n\nll query(int i, int s, int e, int l, int r){\n\tif(s >= l & e <= r){\n\t\treturn t[i];\n\t}\n\tif(s > r || e < l) return LONG_LONG_MAX;\n\tint m = (s + e)/2;\n\treturn min(query(i*2, s, m, l, r), query(i*2+1, m+1, e, l, r));\n}\n\nint main(){\n\tcin>>n>>e>>T;\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tll dp[n+1]; dp[n] = 0; dp[n-1] = T; upd(1, 0, n-1, n-1, 2*a[n-1]);\n\tfor(int i = n-2; i >= 0; i--){\n\t\tdp[i] = dp[i+1] + T;\n\t\tll sv = (T + 2LL*a[i] + 1)/2LL;\n\t\tint indx = lower_bound(a + i, a + n, sv) - a;\n\t\t//cout<<\"INDX: \"<<i<<\" \"<<indx<<endl;\n\t\tif(indx-1 > i) dp[i] = min(dp[i], dp[indx-1] + T);\n\t\tif(indx < n) dp[i] = min(dp[i], query(1, 0, n-1, indx, n) - 2*a[i]);\n\t\tupd(1, 0, n-1, i, dp[i+1] + 2*a[i]);\n\t\t//cout<<\"UPD : \"<<i<<\" : \"<<dp[i+1] + 2*a[i]<<endl;\n\t\t//cout<<\"DP \"<<i<<\" \"<<dp[i]<<endl;\n\t\t//dp[i] = min(dp[i], dp[indx+1] + max(2*(a[indx]-a[i]), T));\n\t}\n\tcout<<dp[0] + e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> ii;\ntypedef pair<ii,int> iii;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define RST(i,n) memset(i,n,sizeof i)\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define X first\n#define Y second\n#define eb emplace_back\n#ifdef cold66\n#define debug(...) do{\\\n    fprintf(stderr,\"LINE %d: (%s) = \",__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // cold66\n//}\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\n\nconst ll MAXn=2e3+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=0x3f3f3f3f;\n\nll dp[MAXn],sum[2][MAXn];\nll add(ll a,ll b){\n    ll ret = a + b;\n    if (ret >= MOD) ret -= MOD;\n    return ret;\n}\nint main(){\n    IOS();\n    ll S;\n    cin >> S;\n    bool roll = true;\n    sum[0][0] = 1;\n    for (int j=1;j<=S;++j) {\n        sum[0][j] = 1;\n    }\n    for (int i=1;i<=S/3;++i) {\n        sum[roll][0] = sum[roll][1] = sum[roll][2] = 1;\n        for (int j=3;j<=S;++j) {\n            dp[j] = sum[!roll][j-3];\n            sum[roll][j] = add(sum[roll][j-1],dp[j]);\n        }\n        roll = !roll;\n    }\n    cout << dp[S] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n,t,e,a[100005];\nlong long f[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tlong long cur=1e18;\n\tfor(int i=1,l=1;i<=n;i++){\n\t\twhile(2*(a[i]-a[l])>=t){\n\t\t\tcur=min(cur,f[l-1]-2*a[l]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[l-1]+t,cur+2*a[i]);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define xx first\n#define yy second\n#define i64 long long int\n#define MEM(a,x) memset(a,x,sizeof(x))\n#define INF 1000000000\n#define mod 998244353\n\nusing namespace std ;\n\n#define maxn 1000005\n\ni64 x[maxn] , mn[maxn] , dp[maxn] ;\ndeque< pair<i64,i64> > dq ;\n\nint main()\n{\n    i64 i , j , k , l , n , m , e , t ;\n\n    scanf(\"%lld %lld %lld\",&n,&e,&t) ;\n    for(i=1; i<=n ; i++) scanf(\"%lld\",&x[i]) ;\n\n    x[0] = 0 ; x[n+1] = e ;\n\n    dp[0] = 0 ;\n    mn[0] = -x[0]-2*x[1] + dp[0] ;\n    dq.push_front( mp(0,0) ) ;\n\n    i64 last = 0 ;\n\n    for(i=1 ; i<=n ; i++)\n    {\n        while( last < i && 2*(x[i]-x[last+1]) > t )\n        {\n            if( !dq.empty() && dq.back().yy==last ) dq.pop_back() ;\n            last++ ;\n        }\n        dp[i] = dp[i-1] + x[i]-x[i-1] + t ;\n        if(last>0) dp[i] = min( dp[i] , 3*x[i] + mn[last-1] ) ;\n        if( !dq.empty() ) dp[i] = min( dp[i] , x[i]+dq.back().xx+t ) ;\n\n        mn[i] = min( mn[i-1] , dp[i]-x[i]-2*x[i+1] ) ;\n\n        while( !dq.empty() && dq.front().xx >= dp[i]-x[i] ) dq.pop_front() ;\n        dq.push_front( mp( dp[i]-x[i],i ) ) ;\n    }\n\n //   for(i=1 ; i<=n ; i++) printf(\"%lld\\n\",dp[i]) ;\n\n    printf(\"%lld\\n\",dp[n]+x[n+1]-x[n]) ;\n\n    return 0 ;\n}\n/*\n4 20 3\n3 5 14 19\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long inf=(1ll<<63-1);\nlong long a[10005],dp[1005];    \nlong long n,e,t,maxn=inf;\nint main()\n{    \n\tmemset(dp,(long long)0x3f3f3f3f,sizeof(dp));\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    dp[0]=0;\n    int t=0;\n    for(int i=1;i<=n;i++)\n\t{\n        while(t<=2*(a[i]-a[t+1]))\n        {\n            maxn=min(maxn,dp[t]-2*a[t+1]);\n            t++;\n        }\n        dp[i]=dp[t]+t;\n        dp[i]=min(dp[i],maxn+2*a[i]);\n    }\n    dp[n]+=e;\n    cout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long i64;\n\nint n;\ni64 t;\ni64 e;\nvector<i64> x;\n\ni64 rec(int end_x)\n{\n\t//cout << \"end\" << end_x << endl;\n\tif(end_x == n)\n\t{\n\t\t//cout << \"n\" << endl;\n\t\treturn e - x[n];\n\t}\n\t\n\tauto ite = lower_bound(x.begin(),x.end(), x[end_x + 1] + t / 2 + t % 2);\n\tint i = ite - x.begin();\n\t//cout << \"ite : \" << i << endl;\n\ti64 v1 = (1LL << 60);\n\ti64 v2 = v1;\n\tif(i < n + 1)\n\t{\n\t\tv1 = rec(i) + (x[i] - x[end_x + 1]) * 3;\n\t}\n\ti--;\n\tif(i < n + 1)\n\t{\n\t\tv2 = rec(i) + (x[i] - x[end_x + 1]) * 2 + t;\n\t}\n\t\n\treturn min(v1,v2) + x[end_x + 1] - x[end_x];\n}\n\n\n\n\n\n\n\nint main()\n{\n\tcin >> n >> e >> t;\n\tx.assign(n +1,0);\n\tx[0] = 0;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\n\tcout << rec(0) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+5;\nconst long long inf=1LL<<61;\ntypedef long long LL;\nstruct sgt{\n\tLL mn[maxn*2];\n\tint id(int l,int r){return l+r|l!=r;}\n\n\tvoid build(int l,int r){\n\t\tmn[id(l,r)]=inf;\n\t\tif(l==r)return ;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid);\n\t\tbuild(mid+1,r);\n\t}\n\tLL Q(int l,int r,int l0,int r0){\n\t\tif(l0<=l&&r0>=r)\n\t\t\treturn mn[id(l,r)];\n\t\tint mid=(l+r)>>1;\n\t\tLL ans=inf;\n\t\tif(l0<=mid)ans=min(ans,Q(l,mid,l0,r0));\n\t\tif(r0>mid)ans=min(ans,Q(mid+1,r,l0,r0));\n\t\treturn ans;\n\t}\n\tvoid C(int l,int r,int ps,LL val){\n\t\tif(l==r){\n\t\t\tmn[id(l,r)]=val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(ps<=mid)C(l,mid,ps,val);\n\t\telse C(mid+1,r,ps,val);\n\t\tmn[id(l,r)]=min(mn[id(l,mid)],mn[id(mid+1,r)]);\n\t}\n}T1,T2;\nint n;\nLL T,E;\nLL d[maxn];\nLL dp[maxn],d2[maxn];\n\nLL bf(){\n\n\tdp[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=inf;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+d[i]-d[j-1]+max(T,2*(d[i]-d[j])));\n\t\t}\n\t\tprintf(\"dp[%d]=%lld\\n\",i,dp[i]);\n\t}\n\n\n\tLL ans=dp[n]+E-d[n];\n\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tn++;\n\td[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\td2[i]=d[i]*2;\n\t}\n\n\n\t//TODO\n//\tcout<< bf() <<endl;\n//\treturn 0;\n\tT1.build(1,n);\n\tT2.build(1,n);\n\n\n\tdp[1]=0;\n\tT1.C(1,n,1,0);\n\tT2.C(1,n,1,0);\n\n\tfor(int i=2;i<=n;i++){\n\n\t\tdp[i]=dp[i-1]+d[i]-d[i-1]+T;\n\n\n\t\tauto bin=[&](int lef,int rig){\n\t\t\tint l=1,r=rig-1;\n\n\t\t\twhile(l<r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(2*(d[rig]-d[mid])>=T)\n\t\t\t\t\tl=mid+1;\n\t\t\t\telse\n\t\t\t\t\tr=mid;\n\t\t\t}\n\n\t\t\tint ans=0;\n\t\t\tfor(int delta=-5;delta<=5;delta++){\n\t\t\t\tint ps=delta+l;\n\t\t\t\tif(1<=ps&&ps<rig){\n\t\t\t\t\tif(2*(d[rig]-d[ps])>=T){\n\t\t\t\t\t\tans=ps;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ans;\n\t\t};\n\t\tint ps=bin(1,i);\n\t\t/*\n\t\tint ps=0;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(2*(d[i]-d[j])>=T){\n\t\t\t\tps=j;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n*/\n//\t\tcerr<<ps<<\" \"<<bin(1,i)<<endl; \n//\t\tassert(bin(1,i)==ps);\n\n\t\t//assert(ps==bin(1,i));\n\n//\t\tcerr<<\"it is \"<<i<<\" \"<<ps<<endl;\n\t\tLL res1=inf,res2=inf;\n\n\t\tif(ps>=1)\n\t\t\tres1=T1.Q(1,n,1,ps)+3*d[i];\n\n\t\tif(ps+1<=i-1)\n\t\t\tres2=T2.Q(1,n,ps+1,i-1)+d[i]+T;\n//\t\tcerr<<res1<<\" \"<<res2<<endl;\n\n\t\tdp[i]=min(dp[i],res1);\n\t\tdp[i]=min(dp[i],res2);\n//\t\tcerr<<\"dp = \"<<dp[i]<<endl;\n\t\tT1.C(1,n,i,dp[i-1]-d[i-1]-2*d[i]);\n\t\tT2.C(1,n,i,dp[i-1]-d[i-1]);\n\t}\n\n\tLL ans=dp[n]+E-d[n];\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 200010\nll n,d[N],t,e;\nll BN(ll key){\n    ll l=-1,r=n,m=(l+r)/2;\n    for(;l<r-1;m=(l+r)/2){\n\tif(d[m+1]*2<key)l=m;\n\telse r=m;\n    }\n    return l;\n}\nll f[N],g[N];\nint main(){\n    cin>>n>>e>>t;\n    lol(i,n)cin>>d[i];\n    lol(i,N)f[i]=1e18; f[0]=0,g[0]=-2*d[0];\n    for(ll i=1;i<=n;i++){\n\tll surf=BN(d[i-1]*2-t);\n\tll res=1e17;\n\tif(surf+1<i)chmin(res,f[surf+1]+t);\n\tif(~surf)chmin(res,g[surf]+2*d[i-1]);\n\tf[i]=res;\n\tg[i]=min(g[i-1],f[i]-2*d[i]);\n    }\n    cout<<f[n]+e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, t, e, x[maxn];\nlong long f[maxn];\nstruct Seg {\n\tlong long tr[maxn << 2];\n\tinline void Upd(int o, int l, int r, int p, long long d) {\n\t\tif(l == r)\n\t\t\treturn tr[o] = d, void();\n\t\tint mid = (l + r) >> 1;\n\t\tif(p <= mid)\n\t\t\tUpd(o << 1, l, mid, p, d);\n\t\telse\n\t\t\tUpd(o << 1 | 1, mid + 1, r, p, d);\n\t\ttr[o] = min(tr[o << 1], tr[o << 1 | 1]);\n\t}\n\tinline long long Ask(int o, int l, int r, int ql, int qr) {\n\t\tif(ql > qr)\n\t\t\treturn 1e18;\n\t\tif(ql <= l && r <= qr)\n\t\t\treturn tr[o];\n\t\tint mid = (l + r) >> 1;\n\t\tlong long ans = 1e18;\n\t\tif(ql <= mid)\n\t\t\tans = min(ans, Ask(o << 1, l, mid, ql, qr));\n\t\tif(qr > mid)\n\t\t\tans = min(ans, Ask(o << 1 | 1, mid + 1, r, ql, qr));\n\t\treturn ans;\n\t}\n}g, h;\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &x[i]);\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0, g.Upd(1, 0, n, 0, 0), h.Upd(1, 0, n, 0, - 2 * x[1]);\n\tfor(int i = 1; i <= n; ++ i) {\n\t\t/*\n\t\tfor(int j = 0; j < i; ++ j) {\n\t\t\tif(t / 2 >= x[i] - x[j + 1])\n\t\t\t\tf[i] = min(f[i], f[j] - x[j] + t + x[i]);\n\t\t\tif(t / 2 <= x[i] - x[j + 1])\n\t\t\t\tf[i] = min(f[i], f[j] - 2 * x[j + 1] - x[j] + 3 * x[i]);\n\t\t}\n\t\t*/\n\t\t// p = j + 1\n\t\tint p = lower_bound(x, x + i, x[i] - t / 2) - x;\n\t\t// cerr << p <<\" \" << x[i] << \" \" << x[p] << endl;\n\t\tf[i] = min(g.Ask(1, 0, n, p - 1, i - 1) + t + x[i], h.Ask(1, 0, n, 0, p - 2) + 3 * x[i]);\n\t\tif(i < n)\n\t\t\t// g[i] = f[i] - x[i], h[i] = f[i] - x[i] - 2 * x[i + 1];\n\t\t\tg.Upd(1, 0, n, i, f[i] - x[i]), h.Upd(1, 0, n, i, f[i] - x[i] - 2 * x[i + 1]);\n\t\t\n\t}\n\t/*\n\tfor(int i = 0; i <= n; ++ i)\n\t\tcerr << f[i] <<\" \";\n\tcerr << endl;\n\t*/\n\tprintf(\"%lld\\n\", f[n] + e - x[n]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e3 + 3;\nconst long long inf = 1e16;\nint n , e , t;\nint x[N];\nlong long cost(int l , int r){\n    long long res = 0;\n    long long val = x[r] - x[l];\n    res += val + max(0LL , t - 2LL * val);\n    res += val;\n    return res;\n}\nlong long dp[N][N];\nlong long solve(int pos , int last){\n    if(pos > n){\n        if(last == n){\n            return 0;\n        }\n        return inf;\n    }\n    if(dp[pos][last] != -1){\n        return dp[pos][last];\n    }\n    long long res = inf;\n    res = min(res , solve(pos + 1 , last) + x[pos + 1] - x[pos]);\n    res = min(res , cost(last + 1 , pos) + solve(pos + 1 , pos) + x[pos + 1] - x[pos]);\n    return dp[pos][last] = res;\n}\nint main(){\n    scanf(\"%d %d %d\" , &n , &e , &t);\n    for(int i = 1 ; i <= n ; ++i){\n        scanf(\"%d\" , x + i);\n    }\n    x[0] = 0;\n    x[n + 1] = e;\n    memset(dp , -1 , sizeof(dp));\n    printf(\"%lld\\n\" , solve(1 , 0) + x[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <unordered_map>\n#include <map>\n#include <set>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(int argc, char const *argv[]) {\n  long long n,e,t;cin>>n>>e>>t;\n  vector<long long> dp(n+1,1ll<<62),x(n);\n  for(int i=0;i<n;++i)cin>>x[i];\n  dp[0]=x[0]+t;\n  for(int i=1;i<n;++i){\n    // dp[i]=dp[i-1]+x[i]-x[i-1]+t;\n    dp[i]=min(dp[i],x[0]+3*(x[i]-x[0])+max(0ll,t-2*(x[i]-x[0])));\n    int l=0,r=i;\n    while(r>l+1){\n      int m=(l+r)/2;\n      if(t-2*(x[i]-x[m])>=0)r=m;\n      else l=m;\n    }\n    for(int j=r-1;j<=r+1;++j){\n      if(j>0&&j<=i)dp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+3*(x[i]-x[j])+max(0ll,t-2*(x[i]-x[j])));\n    }\n  }\n  cout<<dp[n-1]+e-x[n-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[2010];\nint x[2010];\nint n,e;\nlong long t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tdp[i]=4e18;\n\t\tfor(int j=0;j+1<i;j++)\n\t\t{\n\t\t\tlong long tt=2*(x[i]-x[j+1]);\n\t\t\tdp[i]=min(dp[i],dp[j]+x[i]-x[j]+min((t+tt-1)/tt*tt,t*(i-j)));\n\t\t}\n\t\tdp[i]=min(dp[i],dp[i-1]+x[i]-x[i-1]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nvector<int>x, memo;\nint N, E, T;\n\nint solve(int posindex) {\n\t//x[posindex]の位置についた直後で、自分より手前の熊は処理済みで、自分より奥の熊は手付かず\n\n\tif (posindex == N)return 0;\n\tif (memo[posindex] != -1)return memo[posindex];\n\n\tint ans = intmax;\n\n\t//その場で待つ\n\tans = min(ans, solve(posindex + 1) + T + x[posindex + 1] - x[posindex]);\n\n\t//先まで行く\n\tREP(i, posindex+1, N) {\n\t\tint sol = solve(i + 1);\n\t\tint dist = x[i] - x[posindex];\n\t\tint gets = max(T + dist, dist * 3);\n\t\tint res = sol + gets + x[i + 1] - x[i];\n\t\tans = min(ans, res);\n\t}\n\tmemo[posindex] = ans;\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tx = vector<int>(N+1);\n\tmemo = vector<int>(N,-1);\n\trep(i, N)cin >> x[i];\n\tx[N] = E;\n\tsort(ALL(x));\n\n\n\t\n\tcout << x[0] + solve(0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\nconst int inf = 1000000001;\nconst ll INF = 2e18 * 2;\n#define MOD 1000000007\n#define mod 1000000009\n#define pi 3.14159265358979323846\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nint main() {\n\tll n, e, t, i, j, k;\n\tcin >> n >> e >> t;\n\tvl x(n + 1);\n\tfor (i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<vll> dp(n + 1, vll(n + 1, vl(2, INF)));\n\tdp[0][0][0] = dp[0][0][1] = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i; j <= n; j++) {\n\t\t\tif (j != n) {\n\t\t\t\tdp[i][j + 1][1] = min(dp[i][j + 1][1], dp[i][j][1] + x[j + 1] - x[j]);\n\t\t\t}\n\t\t\tif (i != j) {\n\t\t\t\tdp[j][j][1] = min(dp[j][j][1], max(dp[i][j][1] + 2 * (x[j] - x[i + 1]), dp[i][j][1] + t));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tcout << dp[i][j][1] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t//*/\n\tcout << dp[n][n][1] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll dp[MX], dp2[MX];\nint s, t, deq[MX];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, T; cin >> n;\n\tvi v(n + 2);\n\tcin >> v[n + 1] >> T;\n\trep(i, n) cin >> v[i + 1];\n\t\n\t// dp[i] := best - 2 * next - cur\n\t// dp2[i] := best - cur\n\tdp[0] = -2ll * v[1];\n\t\n\tll min1 = 1e18;\n\t\n\tfor(int i = 0, j = 0; i < n; i++){\n\t\twhile(2ll * (v[i + 1] - v[j + 1]) > T){\n\t\t\tmin1 = min(min1, dp[j]);\n\t\t\tif(s < t && deq[s] == j) s++;\n\t\t\tj++;\n\t\t}\n\t\tll tmp = 3ll * v[i + 1] + min1;\n\t\ttmp = min(tmp, v[i + 1] + dp2[deq[s]] + T);\n\t\tif(i == n - 1){\n\t\t\tcout << tmp + v[n + 1] - v[n] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tdp[i + 1] = tmp - 2ll * v[i + 2] - v[i + 1];\n\t\tdp2[i + 1] = tmp - v[i + 1];\n\t\t\n\t\twhile(s < t && dp2[deq[t - 1]] >= dp2[i + 1]) t--;\n\t\tdeq[t++] = i + 1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst long long INF = (long long) 1e18;\nconst int N = (int) 1e5 + 100;\nlong long x[N];\n\nlong long ans[N];\nlong long upd[N];\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n, e, t;\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld\", &x[i]);\n    x[n] = e;\n\n    upd[0] = INF;\n\n    for (int i = 0; i <= n; i++)\n    {\n        upd[i + 1] = min(upd[i + 1], upd[i]);\n        long long cur = 0;\n        if (i > 0)\n        {\n            cur = upd[i - 1] + 2LL * x[i - 1];\n            \n            long long z = x[i - 1] - t / 2;\n            int pos = lower_bound(x, x + n + 1, z) - x;\n            long long ccur = t;\n            ccur += ans[pos];\n\n            eprintf(\"i = %d, ccur = %lld\\n\", i, ccur);\n            cur = min(cur, ccur);\n        }\n        ans[i] = cur;\n        int pos = lower_bound(x, x + n + 1, x[i] + (t + 1) / 2) - x;\n        upd[pos] = min(upd[pos], ans[i] - 2 * x[i]);\n\n        eprintf(\"upd from %d with %lld\\n\", pos, upd[pos]);\n\n        eprintf(\"%d) %lld\\n\", i, ans[i]);\n    }\n\n    printf(\"%lld\\n\", ans[n] + e);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nint n,T,E;\nint x[N];\nLL dp[N],Min=1LL<<50;\nint main(){\n\tn=read(),E=read(),T=read();\n\tfor (int i=1;i<=n;i++)\n\t\tx[i]=read();\n\tint j=1;\n\tdp[0]=0;\n\tfor (int i=1;i<=n;i++){\n\t\twhile (2LL*(x[i]-x[j])>=T){\n\t\t\tMin=min(Min,dp[j-1]-2LL*x[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=min(Min+2LL*x[i],dp[max(j-1,0)]+T);\n\t}\n\tprintf(\"%lld\",dp[n]+E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> PII;\n\nint n, E, T, a[1<<17];\nlong long dp[1<<17], dp2[1<<17], mdp2 = (1<<30);\n\nint main() {\n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    dp2[0] = -2*a[1];\n    for (int i = 1, it = 1; i <= n; i++) {\n        while (2 * (a[i] - a[it]) > T) it++, mdp2 = min(mdp2, dp2[it-2]);\n        dp[i] = min(dp[it-1] + T, mdp2 + 2*a[i]);\n        dp2[i] = dp[i] - 2 * a[i+1];\n    }\n    cout << dp[n] + E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef long double DD;\nconst int inf = 1e9;\nconst int mo= 1e9+7;\nconst int N = 101010;\nint n;\nLL T, E, f[N], p[N];\n\nstruct sta{\n\tLL f,d;\n\tsta(){}\n\tsta(LL x, LL y){\n\t\tf = x;\n\t\td = y;\n\t}\n\tfriend bool operator <(sta a, sta b){\n\t\tif(a.f == b.f)\n\t\t\treturn a.d<b.d;\n\t\telse \n\t\t\treturn a.f < b.f;\n\t}\n};\nset<sta> s1,s2;\n\nint main(){\n\tscanf(\"%d%lld%lld\",&n, &E, &T);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", p + i);\n\tsort(p + 1, p + n + 1);\n\ts1.insert(sta(T, p[1]));\n\tfor(int i = 1; i <= n; i++){\n\t\twhile(!s1.empty() && (p[i] - (*s1.begin()).d) * 2 > T){\n\t\t\tsta t = *s1.begin();\n\t\t\ts1.erase(s1.begin());\n\t\t\ts2.insert( sta(t.f - T - t.d * 2, t.d) );\n\t\t}\n\t\tf[i]=1ll << 62;\n\t\tif(!s2.empty())\n\t\t\tf[i]=(*s2.begin()).f + p[i] * 3;\n\t\tif(!s1.empty())\n\t\t\tf[i] = min(f[i], (*s1.begin()).f + p[i]);\n\t\ts1.insert(sta(f[i] - p[i] + T, p[i + 1]));\n\t}\n//\tfor(int i = 1; i<= n; i++)\n//\t\tprintf(\"%lld\\n\", f[i]);\n\tprintf(\"%lld\\n\", f[n] + abs(E - p[n]));\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 0;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std;\nset<pair<long long,long long> > s; \nlong long x[100008],dp[100008];\nint main()\n{\n\tlong long n;cin>>n;long long t,e;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i],s.insert(make_pair(x[i],i));for(long long i=0;i<100005;i++) dp[i]=2e9;\n\tdp[0]=0;s.insert(make_pair(0,0));\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tint j;set<pair<long long,long long> >::iterator it=s.lower_bound(make_pair(x[i]-(t+1)/2,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\tit=s.lower_bound(make_pair(x[i]-t,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 101010;\nint N , E , T;\nint x[MAXN];\nll f[MAXN];\nint head = 1 , tail = 0;\nll minn = 1000000000000ll;\nint q[MAXN];\nll t[MAXN];\nvoid push(int p , ll now){\n\twhile(head <= tail && now <= t[tail])\n\t\ttail --;\n\tq[++ tail] = p;\n\tt[tail] = now;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin >> N >> E >> T;\n\tfor(int i = 1 ; i <= N ; ++ i)\n\t\tcin >> x[i];\n\tf[N + 1] = 0;\n\tx[N + 1] = E;\n\tfor(int i = N ; i >= 1 ; -- i){\n\t\twhile(head <= tail && 2 * (x[q[head]] - x[i]) >= T){\n\t\t\tminn = min(minn , f[q[head] + 1] + 2ll * x[q[head]] + x[q[head] + 1]);\n\t\t\thead ++;\n\t\t}\n\t\tpush(i , f[i + 1] + x[i + 1]);\n\t\tf[i] = minn - 3ll * x[i];\n\t\tif(head <= tail) f[i] = min(f[i] , t[head] + T - x[i]);\n\t}\n\tcout << f[1] + x[1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nlong long dp[100005];\nint arr[100005];\nint main()\n{\n\t// freopen(\"AGC007-D.in\", \"r\", stdin);\n\tint n, e, t;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tdp[i] = std::min(dp[i], dp[j] + std::max(t, arr[i] - arr[j + 1] << 1));\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tint mn=0x3f3f3f3f3f3f3f3fll;\n\tfz(i,1,n){\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n\t\t\tmn=min(mn,dp[j]-a[j]+2*(-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n\t\tdp[i]=min(dp[i],dp[q.front()]+a[i]-a[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn+3*a[i]);\n\t\twhile(!q.empty()&&dp[q.back()]-a[q.back()]>dp[i]-a[i])\tq.pop_back();\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+abs(a[n]-E)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst double pi = 3.141592653589793;\n\nll n,e,t;\nll x[2005];\nll dp[2005][2005];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> e >> t;\n    if (n>2000) return 0;\n    rep(i,n) cin >> x[i+1];\n    rep(i,n+2)rep(j,n+2) dp[i][j]=1e15;\n    dp[0][0]=0;\n    rep(i,n+1){\n        ll nx=x[i+1]-x[i];\n        rep(j,i+1){\n            dp[i+1][j]=min(dp[i+1][j],dp[i][j]+nx);\n            if (i==j) continue;\n            dp[i][i]=min(dp[i][i],dp[i][j]+max(2*(x[i]-x[j+1]),t));\n        }\n    }\n    cout << dp[n][n]+e-x[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (int i = 1; i <= n; ++i) a[i] = F();\n\tif (n > 2000) return 0;\n\tR long long ans = E;\n\tR int last = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = 1ll * i * T;\n\t\tfor (int j = last; j <= i; ++j)\n\t\t{\n\t\t\tlong long S = a[i] - a[j], temp = dmax(T - 2ll * S, 0);\n\t\t\tcmin(f[i], f[j - 1] + temp * (i - j + 1) + S * 2) ? last = j : 0;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nll dp[SZ],qzm[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tmemset(dp,127/3,sizeof(dp)); dp[0]=0;\n\tmemset(qzm,127/3,sizeof(qzm));\n\tint p=0; qzm[0]=dp[0]-2*x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile((x[i]-x[p+1])*2>t&&p<i) ++p;\n\t\t//for j>=p: (x[i]-x[j+1])*2<=t\n\t\tif(p<i) dp[i]=dp[p]+t;\n\t\tif(p) dp[i]=min(dp[i],qzm[p-1]+2*x[i]);\n\t\tqzm[i]=min(qzm[i-1],dp[i]-2*x[i+1]);\n\t}\n\tcout<<dp[n]+e<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]));\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tfor (int x=now+1; x<=n&&x-now<=500; ++x){\n\t\t\tf[x]=min(f[x],f[now]+max(2*(pos[x]-pos[now+1]),wait));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\n\nvoid check(int i,int j)\n{\n  long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-2*(a[i]-a[j+1]),h-a[j+1])+a[i]-a[j+1]);\n}\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  if (n<=1000) \n  {\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=0;j--)\n      {   \n        check(i,j);\n        \n      }\n    }  \n  }\n  else\n  {\n     for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=max(0,i-200);j--)\n      {   \n        \n        check(i,j);\n        \n      }\n    check(i,0);\n    check(i,i / 2);\n    \n    }  \n  }\n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(0, 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i],now_cost + 2 * inputs[i]);\n\t\twhile (next.empty() == false&&2 * (inputs[i] - inputs[next.top().second])> t) {\n\t\t\tnext.pop();\n\t\t}\n\t\tif (next.size() != 0) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\t/*\n\t\tfor (int q = now_back; q < i; ++q) {\n\t\t\tlong long cost = inputs[i] - inputs[q + 1] + t - (inputs[i] - inputs[q + 1]);\n\t\t\tdp[i] = min(dp[i], dp[q] + cost);\n\t\t}\n\t\t*/\n\t\tif(i != n-1)\n\t\tnext.push(make_pair(dp[i] - inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define mp make_pair\n#define fi first\n#define se second\nconst int N=100005;\nset<pair<int ,int> >s;\nint n,e,t,x[N],f[N],dp[N],d[N];\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&x[i]);\n\te-=x[n];x[n+1]=e;\n\tfor (int i=n;i;i--)x[i]-=x[i-1];\n\tfor (int i=1;i<=n;i++)f[i]=f[i-1]+x[i];\n\tint l=0,r=-1,k=0;\n\ts.insert(mp(0,0));\n\tfor (int i=1;i<=n;i++){\n\t\twhile (k<i&&(f[i]-f[k+1])*2>t){\n\t\t\ts.erase(mp(x[k+1]-f[k+1]+dp[k],k));\n\t\t\twhile (l<=r&&-3*f[k+1]+x[k+1]+dp[k]<=-3*f[d[r]+1]+x[d[r]+1]+dp[d[r]])r--;\n\t\t\td[++r]=k;\n\t\t\tk++;\n\t\t}\n\t\tpair<int ,int > now=*s.begin();\n\t\tdp[i]=t+now.fi+f[i];\n\t\tif (l<=r)dp[i]=min(dp[i],f[i]*3-3*f[d[r]+1]+x[d[r]+1]+dp[d[r]]);\n\t\ts.insert(mp(x[i+1]-f[i+1]+dp[i],i));\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\nconst int maxn = 1e5 + 20;\nconst ll inf = 1e15;\n\nll dp[maxn] , partial_min[maxn] , a[maxn];\n\nint main()\n{\n    fill(dp , dp + maxn , inf);\n    ll n , e , T;\n    cin >> n >> e >> T;\n    e *= 2;\n    T *= 2;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i] , a[i] *= 2;\n    dp[0] = 0;\n    int pt = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(pt + 1 < i && a[pt] <= a[i] - T / 2)\n            pt++;\n        if(!pt)\n            dp[i] = T;\n        else\n            dp[i] = min(dp[pt] + T , partial_min[pt] + a[i] * 2);\n        partial_min[i] = min(partial_min[i - 1] , dp[i - 1] - a[i] * 2);\n    }\n    cout << (dp[n] + e) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e5 + 10;\nconst int INF = 2e9;\n\nint dp[MAXN], seg[4 * MAXN], x[MAXN];\n\nvoid _set(int v, int l, int r, int p, int x) {\n    if (r - l == 1) {\n\tseg[v] = x;\n\treturn;\n    }\n    int mid = (r + l) / 2;\n    if (p < mid) \n\t_set(2 * v, l, mid, p, x);\n    else\n\t_set(2 * v + 1, mid, r, p, x);\n    seg[v] = min(seg[2 * v], seg[2 * v + 1]);\n}\n\nint query(int v, int l, int r, int s, int t) {\n    if (s <= l && r <= t)\n\treturn seg[v];\n    int mid = (l + r) / 2, res = INF;\n    if (s < mid)\n\tres = min(res, query(2 * v, l, mid, s, t));\n    if (t > mid)\n\tres = min(res, query(2 * v + 1, mid, r, s, t));\n    return res;\n}\n\nint lower(int val, int s, int t) {\n    if (t - s == 1)\n\treturn s;\n    int mid = (s + t) / 2;\n    if (x[mid-1] >= val)\n\treturn lower(val, s, mid);\n    else\n\treturn lower(val, mid, t);\n}\n\nmain() {\n    int N, T, E;\n    cin >> N >> E >> T;\n    T *= 2;\n    for (int i = 0; i < N; i ++) cin >> x[i], x[i] *= 2;\n    for (int i = 0; i < N; i ++) {\n\tint last = lower(x[i] - T/2, 0, N);\n\tif (last <= 1) {\n\t    dp[i] = (last?2 * x[i] - 2 * x[0] : T);\n\t    if(last)dp[i] = min(dp[i], dp[last - 1] + T);\n\t    _set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n\t    continue;\n\t}\n\tdp[i] = query(1, 0, N, 0, last-1) + 2 * x[i]; \n\tdp[i] = min(dp[i], dp[last- 1] + T);\n\tdp[i] = min(dp[i], 2 * (x[i] - x[0]));\n\t_set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n    }\n    cout << dp[N -1]/2 + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename Monoid>\nstruct SegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n\n    int sz;\n    vector<Monoid> seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n        sz = 1;\n        while(sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid &x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for(int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid &x) {\n        k += sz;\n        seg[k] = x;\n        while(k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if(a & 1) L = f(L, seg[a++]);\n            if(b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int &k) const {\n        return seg[k + sz];\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll e, t;\n    cin >> e >> t;\n    e *= 2;\n    t *= 2;\n    ll x[100005];\n    x[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        x[i] *= 2;\n    }\n    x[n + 1] = e;\n    SegmentTree<ll> seg(n + 1, [](ll a, ll b){return max(a, b);}, 0ll);\n    ll dp[100005];\n    for(int i = 0; i <= n; i++){\n        if(i == 0) dp[0] = x[1] * 2;\n        int l = upper_bound(x, x + n + 2, x[i] - t / 2) - x - 1;\n        if(l > 0) dp[i] = max(dp[i], seg.query(0, l) + (x[i + 1] - x[i]) * 2);\n        seg.update(i, dp[i]);\n        if(i == n) break;\n        int j = upper_bound(x, x + n + 2, x[i + 1] + t / 2) - x - 1;\n        j = min(j, n);\n        dp[j] = max(dp[j], dp[i] + (x[j + 1] - x[j]) * 2 - (x[i + 1] + t - x[j]));\n    }\n    cout << (e * 3 - dp[n]) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll n,t,e;\nll ans;\nll xx[maxn];\ninline ll max(ll aa,ll bb){\n\tif (aa>bb)return aa;\n\telse return bb;\n}\nint main(){\n\tll b1,b2,b3,b4,b5;\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\txx[n+1]=e;\n\tans=xx[1];\n\tb1=1;\n\twhile (b1<=n){\n\t\tb2=b1;\n\t\tif ((b2+1<=n)&&((xx[b2+1]-xx[b2])<t)){\n\t\t\tb2++;\n\t\t}\n\t\twhile ((b2+1<=n)&&((xx[b2+1]-xx[b2])*2<t)){\n\t\t\tb2++;\n\t\t}\n\t\tans+=max((xx[b2]-xx[b1])*2,t)+(xx[b2+1]-xx[b1]);\n\t\tb1=b2+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint d[N], T;\nlong long dp[N];\nlong long calc_big(int j) {\n\treturn T - d[j] + dp[j];\n}\nlong long calc_small(int j) {\n\treturn 2LL * (-d[j + 1]) - d[j] + dp[j];\n}\nstruct cmp_big {\n\tbool operator () (const int &i, const int &j) {\n\t\treturn calc_big(i) > calc_big(j);\n\t}\n};\nstruct cmp_small {\n\tbool operator () (const int &i, const int &j) {\n\t\treturn calc_small(i) > calc_small(j);\n\t}\n};\nint main() {\n\tint n, E;\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &d[i]);\n\tpriority_queue<int, vector<int>, cmp_big> q1;\n\tpriority_queue<int, vector<int>, cmp_small> q2;\n\tq1.push(0);\n\tfor (int i = 1; i <= n; ++ i) {\n\t\twhile (!q1.empty() && 2LL * (d[i] - d[q1.top() + 1]) >= T) {\n\t\t\tq2.push(q1.top());\n\t\t\tq1.pop();\n\t\t}\n\t\tdp[i] = 1e18;\n\t\tif (!q1.empty()) {\n\t\t\tint j = q1.top();\n\t\t\tdp[i] = min(dp[i], d[i] + calc_big(j));\n\t\t}\n\t\tif (!q2.empty()) {\n\t\t\tint j = q2.top();\n\t\t\tdp[i] = min(dp[i], 3LL * d[i] + calc_small(j));\n\t\t}\n\t\tq1.push(i);\n\t}\n\tcout << dp[n] + E - d[n] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) f=n; else f=ng[f];\n\t\tfor(int j=max(i+1,beg-5);j<=f;j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 1;\n\tlong long mi = (1 << 31) - 1;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\twhile (pp <= n && 2 * (d[i] - d[pp]) > t){\n\t\t\tmi = min(mi,f[pp - 1] - d[pp] * 2);\n\t\t\tpp++;\n\t\t}\n\t\tf[i] = min(f[pp - 1] + t,mi + d[pp] * 2);\n\t}\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nint n,e,t,x[N],i,j;\nll f[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",x+i);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tf[i]=1ll<<60;\n\t\tfor(j=i-1;j>=0;--j)\n\t\t\tf[i]=min(f[i],f[j]+x[j+1]-x[j]+max(t,2*(x[i]-x[j+1]))+x[i]-x[j+1]);\n\t}\n\tprintf(\"%lld\",f[n]+e-x[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt dp[108000];\nInt x[108000];\nInt l, n, e, t;\nint main(){\n  cin >> n >> e >> t;\n  fill(dp, dp + 108000, LINF);\n  dp[0] = 0;\n  for(int i = 1;i <= n;i++)cin >> x[i];\n  for(int i = 1;i <= n;i++){\n    dp[i] = dp[i-1] + t; \n    while((x[i] - x[l+1])*2>=t)l++;\n    if(l == 0)continue;\n    dp[i] = min(dp[i], dp[l-1] + (x[i] - x[l])*2);\n    dp[i] = min(dp[i], dp[l] + t);\n  }\n  cout << e + dp[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double \n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\nusing namespace :: std;\n\n\nconst ll  maxn=1e5+500;\nll dp[maxn];\nll a[maxn];\nll parminn[maxn];\nint main(){\n    ll n,e,t;\n    cin>>n>>e>>t;\n    t*=2;\n    e*=2;\n    ll ans=0;\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n        a[i]*=2;\n    }\n    ll p=0;\n    parminn[0]=0;\n    dp[0]=0;\n    for(ll i=1;i<=n;i++){\n        while(p+1<i && a[i]-a[p]>=t/2){\n            p++;\n        }\n        if(p==0){\n            dp[i]=t;\n        }else{\n            dp[i]=min(dp[p]+t,parminn[p]+a[i]*2);\n        }\n        parminn[i]=min(parminn[i-1],dp[i-1]-a[i]*2);\n    }\n    cout<<(dp[n]+e)/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nll p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<ll>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tint now=0;\n\tll Min=inf;\n\tFor(i,1,n)\n\t{\n\t\tdp[i]=dp[i-1]+T;\t\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tif(now<i)cmin(dp[i],dp[now]+T);\n\t\tcmin(dp[i],Min+2*p[i]);\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n,m,t;\n  cin >> n >> m >> t;\n  if(n>3000) return;\n  ll a[n+1];\n  rep(i,n) R a[i];\n  a[n]=m;\n  ll dp[n+1];\n  fill(dp,dp+n+1,MAXL);\n  dp[0]=a[0];\n  rep(i,n) {\n    REP(j,i,n) {\n      ll d=a[j]-a[i];\n      d=max(t+d,d*3);\n      dp[j+1]=min(dp[j+1],d+a[j+1]-a[j]+dp[i]);\n    }\n  }\n  pr(dp[n]);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[114514];\nlint dp[114514],mi[114514];\nint main()\n{\n\tint n,e,t,now=0;lint out=0,inf=1145141919810893LL,nmi=inf;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\trep(i,n) scanf(\"%d\",&x[i]);x[n]=2001001001;\n\trep(i,n+10) dp[i]=mi[i]=inf;dp[0]=0;\n\trep(i,n+1){\n\t\tif(i>1) nmi+=2*(x[i-1]-x[i-2]);\n\t\tnmi=min(nmi,mi[i]);\n\t\tdp[i]=min(dp[i],nmi);\n\t\tint ne=lower_bound(x,x+n+1,x[i]+t/2+1)-x;\n\t\tdp[ne]=min(dp[ne],dp[i]+t);\n\t\tif(ne<n) mi[ne+1]=min(mi[ne+1],dp[i]+2*(x[ne]-x[i]));\n\t}\n\tout=e+dp[n];\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[100005];\nint n,e,t;\nint x[100005];\nsigned main(){\n\tcin>>n>>e>>t;if(n>2000)return 0;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tmemset(dp,inf,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+max(3*(x[i]-x[j]),x[i]-x[j]+t));\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++)cerr<<i<<\" \"<<dp[i]<<endl;\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  const int N = 100000 + 10;\n  int n;\n  lli e, t;\n  while (cin >> n >> e >> t) {\n    lli x[N];\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i];\n    }\n    x[n] = e;\n\n    lli dp[N];\n    fill(dp, dp + N, 1LL << 60);\n    dp[0] = 0;\n   \n    for (int i = 0, j = -1; i < n; ++i) {\n      lli mn = 1LL << 60;\n      while (t < 2 * (x[i] - x[j + 1])) {\n        mn = min(mn, dp[j] - 2 * x[j + 1]);\n        ++j;\n      }\n      dp[i] = min(dp[j] + t, 2 * x[i] + mn);\n    }\n    cout << dp[n - 1] + e << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define sz(s) ((int) ((s).size()))\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int inf = (int) 1e9 + 100;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0L);\n\nmt19937 mrand(random_device{} ());\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 1e5 + 100;\nint n;\nint t, e;\nint x[maxn];\n\nll st[2][maxn * 4];\n\nvoid build(int t, int v, int vl, int vr) {\n  st[t][v] = 1e18;\n  if (vl == vr - 1) {\n    return;\n  }\n  int mid = (vl + vr) / 2;\n  build(t, v * 2, vl, mid);\n  build(t, v * 2 + 1, mid, vr);\n}\n\nvoid update(int t, int v, int vl, int vr, int pos, ll val) {\n  if (vl == vr - 1) {\n    st[t][v] = val;\n    return;\n  }\n  int mid = (vl + vr) / 2;\n  if (pos < mid) {\n    update(t, v * 2, vl, mid, pos, val);\n  } else {\n    update(t, v * 2 + 1, mid, vr, pos, val);\n  }\n  st[t][v] = min(st[t][v * 2], st[t][v * 2 + 1]);\n}\n\nll get(int t, int v, int vl, int vr, int l, int r) {\n  if (vr <= l || r <= vl) {\n    return 1e18;\n  }\n  if (l <= vl && vr <= r) {\n    return st[t][v];\n  } else {\n    int mid = (vl + vr) / 2;\n    return min(get(t, v * 2, vl, mid, l, r), get(t, v * 2 + 1, mid, vr, l, r));\n  }\n}\n\nbool read() {\n  if (scanf(\"%d%d%d\", &n, &e, &t) < 3) {\n    return false;\n  }\n  x[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", x + i);\n  }\n  x[n + 1] = e;\n  n += 2;\n  return true;\n}\n\nll dp[maxn];\n\nvoid solve() {\n  build(0, 1, 0, n);\n  build(1, 1, 0, n);\n  update(0, 1, 0, n, 0, -2 * x[1]);\n  update(1, 1, 0, n, 0, 0);\n  for (int i = 1; i < n; i++) {\n    int left = (int) (upper_bound(x, x + n, x[i] - (t + 1) / 2) - x);\n    left = max(0, left - 1);\n    dp[i] = 1e18;\n    if (left) {\n      dp[i] = min(dp[i], get(0, 1, 0, n, 0, left) + 2 * x[i]);\n    }\n    if (left < i) {\n      dp[i] = min(dp[i], get(1, 1, 0, n, left, i) + t);\n    }\n    update(0, 1, 0, n, i, dp[i] - 2 * x[i + 1]);\n    update(1, 1, 0, n, i, dp[i]);\n  }\n  printf(\"%lld\\n\", dp[n - 2] + e);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(\"text.in\", \"r\", stdin));\n  assert(freopen(\"text.out\", \"w\", stdout));\n#endif\n\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time: %.18f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef  long long int ll;\nconst int maxn=100005;\nconst ll inf = (1LL<<62) - 1 + (1LL<<62);\n\nint n,e,t,p[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll zz = query(1,ret,i-1,1);\n            if(zz!=inf) {\n                ll tmp=zz + p[i] + t;\n                tt = tmp;\n            }\n            if(ret>1) {\n                ll zz=query(1,1,ret-1,0);\n                if(zz!=inf) {\n                    if(tt==-1)tt = zz+3*p[i];\n                    else tt =min(tt,zz+3*p[i]);\n\n                }\n            }\n        } else {\n            if(1<=i-1) {\n                ll zz = query(1,1,i-1,0);\n                if(zz!=inf)\n                    tt = zz+3*p[i];\n            }\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, t, e, x[maxn];\nlong long f[maxn];\nstruct Seg {\n\tlong long tr[maxn << 2];\n\tinline void Upd(int o, int l, int r, int p, long long d) {\n\t\tif(l == r)\n\t\t\treturn tr[o] = d, void();\n\t\tint mid = (l + r) >> 1;\n\t\tif(p <= mid)\n\t\t\tUpd(o << 1, l, mid, p, d);\n\t\telse\n\t\t\tUpd(o << 1 | 1, mid + 1, r, p, d);\n\t\ttr[o] = min(tr[o << 1], tr[o << 1 | 1]);\n\t}\n\tinline long long Ask(int o, int l, int r, int ql, int qr) {\n\t\tif(ql > qr)\n\t\t\treturn 1e18;\n\t\tif(ql <= l && r <= qr)\n\t\t\treturn tr[o];\n\t\tint mid = (l + r) >> 1;\n\t\tlong long ans = 1e18;\n\t\tif(ql <= mid)\n\t\t\tans = min(ans, Ask(o << 1, l, mid, ql, qr));\n\t\tif(qr > mid)\n\t\t\tans = min(ans, Ask(o << 1 | 1, mid + 1, r, ql, qr));\n\t\treturn ans;\n\t}\n}g, h;\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &x[i]);\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0, g.Upd(1, 0, n, 0, 0), h.Upd(1, 0, n, 0, - 1ll * 2 * x[1]);\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tint p = lower_bound(x, x + i, x[i] - t / 2) - x;\n\t\tf[i] = min(g.Ask(1, 0, n, p - 1, i - 1) + t + x[i], h.Ask(1, 0, n, 0, p - 2) + 1ll * 3 * x[i]);\n\t\tif(i < n)\n\t\t\tg.Upd(1, 0, n, i, f[i] - x[i]), h.Upd(1, 0, n, i, f[i] - x[i] - 1ll * 2 * x[i + 1]);\n\t\t\n\t}\n\tprintf(\"%lld\\n\", f[n] + e - x[n]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\n\nvoid solve() {\n        long long n, e, t;\n        cin >> n >> e >> t;\n        vector<long long> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        vector<long long> dp(n, INFL);\n        dp[0] = t;\n        for (int i = 1; i < n; i ++) {\n                for (int j = 0; j < i; j ++) dp[i] = min(dp[i], dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n                dp[i] = min(dp[i], max(t, 2 * (x[i] - x[0])));\n        }\n        cout << dp[n - 1] + e << endl;\n        return;\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 100010;\nconst ll INFLL = 1e18;\nint _w;\n\nint n, e, t, x[N];\n\nnamespace SGT {\n\tll val[N*4], tag[N*4], ql, qr, qv;\n\t\n\tvoid _query( int o, int L, int R, ll adv ) {\n\t\tif( L >= ql && R <= qr ) {\n\t\t\tqv = min(qv, val[o] + adv);\n\t\t} else {\n\t\t\tint M = (L+R)/2, lc = o<<1, rc = lc|1;\n\t\t\tadv += tag[o];\n\t\t\tif( ql <= M ) _query(lc, L, M, adv);\n\t\t\tif( qr > M ) _query(rc, M+1, R, adv);\n\t\t}\n\t}\n\tll query( int l, int r ) {\n\t\tql = l, qr = r, qv = INFLL;\n\t\t_query(1, 1, n+1, 0);\n\t\treturn qv;\n\t}\n\tvoid _add( int o, int L, int R ) {\n\t\tif( L >= ql && R <= qr ) {\n\t\t\ttag[o] += qv;\n\t\t\tval[o] += qv;\n\t\t} else {\n\t\t\tint M = (L+R)/2, lc = o<<1, rc = lc|1;\n\t\t\tif( ql <= M ) _add(lc, L, M);\n\t\t\tif( qr > M ) _add(rc, M+1, R);\n\t\t\tval[o] = min(val[lc], val[rc]) + tag[o];\n\t\t}\n\t}\n\tvoid add( int l, int r, ll v ) {\n\t\tql = l, qr = r, qv = v;\n\t\t_add(1, 1, n+1);\n\t}\n}\n\nll f[N];\nvoid solve() {\n\tf[1] = x[1];\n\tSGT::add(1, 1, f[1]);\n\tint p = 1;\n\tfor( int i = 2; i <= n+1; ++i ) {\n\t\tf[i] = x[i] - x[i-1];\n\t\tSGT::add(i-1, i-1, t);\n\t\tif( i > 2 )\n\t\t\tSGT::add(1, i-2, x[i-1] - x[i-2]);\n\t\tif( p > 1 )\n\t\t\tSGT::add(1, p-1, x[i-1] - x[i-2] + x[i-1] - x[i-2]);\n\t\twhile( x[i-1] - x[p] + x[i-1] - x[p] > t ) {\n\t\t\tSGT::add(p, p, -t);\n\t\t\tSGT::add(p, p, x[i-1] - x[p] + x[i-1] - x[p]);\n\t\t\t++p;\n\t\t}\n\t\tf[i] += SGT::query(1, i-1);\n\t\tSGT::add(i, i, f[i]);\n\t}\n}\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor( int i = 1; i <= n; ++i )\n\t\tcin >> x[i];\n\tx[n+1] = e;\n\tsolve();\n\tcout << f[n+1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[1000010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+2010, 1e15);\n\n  dp[0] = 0;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tint j;\n\tfor(j=i;j<N;++j){\n\t  LL d = xs[j] - xs[i];\n\t  LL tmp = dp[i] + t + d*3 + max(0ll, T-2*d);\n\t  dp[j+1] = min(dp[j+1], tmp);\n\t  if(T - 2*d <= 0) break;\n\t}\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\td[0]=0;\n\tfoor(i,1,N){\n\t\tll t=e18;\n\t\tfoor(j,1,i){\n\t\t\tchmin(t,d[j-1]-x[j-1]+max(2*(x[i]-x[j]),T));\n\t\t}\n\t\td[i]=t+x[i];\n\t}\n\tprint(d[N]+E-x[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5e5+5;const ll inf=1e18;\nint n,t,e,a[N];ll f[N];\ninline ll min(R ll x,R ll y){return x<y?x:y;}\ninline ll max(R ll x,R ll y){return x>y?x:y;}\nstruct Queue{\n\tpriority_queue<ll,vector<ll>,greater<ll> >A,B;\n\tinline void push(R ll x){A.push(x);}\n\tinline void pop(R ll x){B.push(x);}\n\tinline ll top(){\n\t\twhile(!B.empty()&&A.top()==B.top())A.pop(),B.pop();\n\t\treturn A.empty()?inf:A.top();\n\t} \n}s1,s2;\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\ts2.push(0);\n\tfor(R int i=1,j=0;i<=n;++i){\n\t\twhile(j<i&&((a[i]-a[j+1])<<1)>=t)s1.push(f[j]-(a[j+1]<<1)),s2.pop(f[j]),++j;\n\t\tf[i]=inf,cmin(f[i],s1.top()+(a[i]<<1)),cmin(f[i],s2.top()+t);\n\t\ts2.push(f[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+6000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N], pre[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tsrand(time(0));\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\t//n = 5000, E = 1000000, T = 100000;\n\tfor(int i = 1; i <= n; ++ i) A[i] = rand() % (E - 1) + 1;\n\tsort(A + 1, A + n + 1);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0;\n\tdp[1] = A[1] + T;\n\tpre[1] = 0;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\tfor(int j = 0; j < i; ++ j)\n\t\tdp[i] = min(calc(j, i), dp[i]);\n\t\tfor(int j = 0; j < i; ++ j) if(calc(j, i) == dp[i]) pre[i] = j;\n\t\tassert(pre[i] >= pre[i - 1]);\n\t\t//cerr << pre[i] << endl;\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n\nunsigned readUnsigned() {\n    int c;\n    do { c = ::getchar_unlocked(); } while (c < '0');\n    unsigned result = c - '0';\n    while ((c = ::getchar_unlocked()) >= '0') {\n        result *= 10;\n        result += c - '0';\n    }\n    return result;\n}\n\n\nconst unsigned MAX_N = 100 * 1000;\nunsigned N, E, T;\nunsigned xs[MAX_N];\n\nlong long unsigned simpleDP() {\n    /*\n     * dp[i]: After just giving candy to bear xs[i] and given that all coins\n     *        from bears xs[0]...xs[i-1] have been collected, how long does it\n     *        take to end the game?\n     *\n     */\n    uint64_t dp[MAX_N];\n    dp[N - 1] = T + E - xs[N - 1];\n    for (unsigned i = N - 1; i--;) {\n        dp[i] = T + xs[i+1] - xs[i] + dp[i+1];\n\n        /*\n         * Try all routes xs[i] -> xs[i+k] -> xs[i] -> xs[i+k].\n         *\n         * 1) Instead of waiting at xs[i], we go walk xs[i+k].\n         * 2) We walk back to xs[i].\n         * 3) If the coin hasn't appeared yet, we wait for it.\n         * 4) We go to xs[i+k+1], if it exists.  The coin xs[i+k] is ready.\n         * 5) To finish the game, the cost is dp[i+k+1].\n         */\n        unsigned j = i + 1;\n        for (unsigned step = 1 + (N - j) / 2; step; step /= 2) {\n            for (; j + step < N; j += step) {\n                uint64_t distance = 2 * (xs[j] - xs[i]);\n                if (distance > T) {\n                    break;\n                }\n            }\n        }\n        for (; j < N; ++j) {\n            uint64_t cost = 2 * (xs[j] - xs[i]);\n            if (cost < T) cost = T;\n            if (j + 1 < N) {\n                cost += xs[j+1] - xs[i] + dp[j+1];\n            }\n            else {\n                cost += E - xs[i];\n            }\n            dp[i] = std::min(dp[i], cost);\n        }\n    }\n    return xs[0] + dp[0];\n}\n\nint main() {\n    N = readUnsigned();\n    E = readUnsigned();\n    T = readUnsigned();\n    for (unsigned i = 0; i < N; ++i) {\n        xs[i] = readUnsigned();\n    }\n\n    printf(\"%llu\\n\", simpleDP());\n}"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint a[N], b[N], dp[N], sum[N];\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tif(i == 1) {\n\t\t\tdp[1] = t + a[1];\n\t\t\tsum[1] = a[1];\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint cnt = dp[j] + sum[j + 1] - sum[j] + max(t, 2 * (sum[i] - sum[j + 1])) + sum[i] - sum[j + 1];\n\t\t\tdp[i] = min(dp[i], cnt);\n\t\t}\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  assert(n <= 2000);\n  lint E, T; cin >> E >> T;\n  V<lint> x(n); for (auto&& e : x) cin >> e;\n  V<lint> dp(n + 1, 9e18);\n  dp[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = i + 1; j <= n; ++j) {\n      lint d = x[j - 1] - x[i];\n      lint cost = 2 * d + max<lint>(T - 2 * d, 0) + (j < n ? x[j] : E) - x[i];\n      dp[i] = min(dp[i], cost + dp[j]);\n    }\n  }\n  cout << x[0] + dp[0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n    for(int d=idx-1;d<idx2&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint dp[100005];\n\n// ------------>8---------- LazySegmentTree ---------->8------------\n\n// ## write [ LST lst(n, SUM/MAX/MIN, ADD/UPD) ] when using this snippet.\nenum QUERY_SEG_LazySegmentTree { SUM, MAX, MIN };\nenum QUERY_LAZ_LazySegmentTree { ADD, UPD };\ntemplate<class SEG, class LAZ>\nclass LazySegmentTree {\nprivate:\n\tstd::vector<SEG> seg;\n\tstd::vector<LAZ> laz;\n\tstd::vector<bool> isUpdated;\n\tint ARY_SIZE;\n\tSEG eSeg;\n\tLAZ eLaz;\n\tstd::function<SEG(SEG&, SEG&)> mergeSeg;\n\tstd::function<LAZ(LAZ&, LAZ&)> mergeLaz;\n\tstd::function<SEG(SEG&, LAZ&, int)> applyLaz;\n\n\tvoid push(int k, int l, int r) {\n\t\tif (!isUpdated[k]) {\n\t\t\tapplyLaz(seg[k], laz[k], r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tmergeLaz(laz[k * 2 + 1], laz[k]); isUpdated[k * 2 + 1] = false;\n\t\t\t\tmergeLaz(laz[k * 2 + 2], laz[k]); isUpdated[k * 2 + 2] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = eLaz;\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n, QUERY_SEG_LazySegmentTree qSeg, QUERY_LAZ_LazySegmentTree qLaz) : ARY_SIZE(1) {\n\t\tARY_SIZE = 1;\n\t\twhile (ARY_SIZE < n) ARY_SIZE *= 2;\n\t\tseg.resize(ARY_SIZE * 2 - 1);\n\t\tlaz.resize(ARY_SIZE * 2 - 1);\n\t\tisUpdated.resize(ARY_SIZE * 2 - 1, true);\n\n\t\tswitch (qSeg) {\n\t\tcase SUM:\n\t\t\teSeg = 0;\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return l + r; };\n\t\t\tbreak;\n\t\tcase MAX:\n\t\t\teSeg = std::numeric_limits<SEG>::lowest();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::max(l, r); };\n\t\t\tbreak;\n\t\tcase MIN:\n\t\t\teSeg = std::numeric_limits<SEG>::max();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::min(l, r); };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (qLaz)\n\t\t{\n\t\tcase ADD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l += r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s += l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s += l; };\n\t\t\tbreak;\n\t\tcase UPD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l = r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s = l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s = l; };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid update(int a, int b, SEG v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tLAZ la(v);\n\t\t\tmergeLaz(laz[k], la);\n\t\t\tisUpdated[k] = false;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = mergeSeg(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\t// ## update [l, r) with v\n\tvoid update(int l, int r, SEG v) {\n\t\tupdate(l, r, v, 0, 0, ARY_SIZE);\n\t}\n\tSEG query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return eSeg;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tSEG vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tSEG vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn mergeSeg(vl, vr);\n\t}\n\t// ## return SUM/MAX/MIN in [l, r)\n\tSEG query(int l, int r) {\n\t\treturn query(l, r, 0, 0, ARY_SIZE);\n\t}\n};\n\nusing LST = LazySegmentTree<ll, ll>;\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nint solve(const std::vector<int>& x, int T) {\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l > r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tLST lst(n, MIN, ADD);\n\tdp[0] = T;\n\n\tFOR(i, 1, n) {\n\t\tint pre = std::lower_bound(ALL(x), x[i - 1] - T / 2) - x.begin();\n\t\tint t = std::lower_bound(ALL(x), x[i] - T / 2) - x.begin();\n\t\tlst.update(0, pre, (x[i] - x[i - 1]) * 2);\n\n\t\tFOR(j, std::max(0LL, pre - 2), std::min(i, t + 2)) {\n\t\t\tlst.update(j, j + 1, dp[j] + cost(j + 1, i) - lst.query(j, j + 1));\n\t\t}\n\t\tlst.update(i - 1, i, dp[i - 1] + T - lst.query(i - 1, i));\n\n\t\tdp[i] = std::min(lst.query(0, i), cost(0, i));\n\t}\n\treturn dp[n - 1];\n}\n\nint solve2(const std::vector<int>& x, int T) { // slow\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l > r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tFILL(dp, INFLL);\n\tREP(i, n) {\n\t\tCHMIN(dp[i], cost(0, i));\n\t\tREP(j, i) {\n\t\t\tCHMIN(dp[i], dp[j] + cost(j + 1, i));\n\t\t}\n\t}\n\treturn dp[n - 1];\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\n\tint ans = e;\n\tRREP(i, n) x[i] -= x[0];\n\tans += solve(x, t);\n\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n} \nconst int N = 2e5+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, t, e, px[N];\nint64 f[N], w = INF;\nint main()\n{\n    n = read(), e = read(), t = read();\n    for(int i = 1, j = 0; i <= n; ++i)\n    {\n        px[i] = read();\n        while(2*(px[i]-px[j+1]) >= t) w = min(f[j]-2*px[j+1], w), ++j;\n        f[i] = min(w+2*px[i], f[j]+t);\n    }\n    printf(\"%lld\\n\", f[n]+e);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    multiset<ll> As;\n    multiset<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>=t){\n            As.insert(A[iter]);\n            Bs.erase(Bs.find(B[iter]));\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \ntypedef pair<int,int> pii; \n\nconst int maxN = 10000 * 100 + 10; \nll a[maxN]; \nconst ll inf = 2e18; \nll dp[maxN]; \nset<pair<ll,int>> curr1, curr2; \n\nint main() { \n\tios::sync_with_stdio(false); cin.tie(0); \n\ta[0] = 0; \n\tint n,e,T; cin >> n >> e >> T;\n\tfor( int i = 0 ; i < n ; i++ ) { \n\t\tcin >> a[i+1]; \n\t\ta[i+1] = e - a[i+1]; \n\t}\n\treverse( a + 1 , a + n + 1 );\n\n\tcurr1.insert( { inf , -1 } ) ; \n\tcurr2.insert( { inf , -1 } ) ; \n\tfill( dp , dp + n + 1 , inf ) ; \n\tdp[0] = 0; \n\tint last = 0; \n\tcurr1.insert( { 0ll - a[1] , 0 } ); \n\tfor( int i = 1 ; i <= n ; i++ ) { \n\t\twhile( last < i && 2ll * (a[i] - a[last+1]) >= T ) { \n\t\t\tcurr1.erase( { 0ll + dp[last] - a[last+1] , last } ) ; \n\t\t\tcurr2.insert( { 0ll + dp[last] - 2ll * a[last+1] , last } ); \n\t\t\tlast++; \n\t\t}\n\t\tdp[i] = min( 0ll + curr1.begin()->first + 1ll * a[i] + T , \n\t\t\t\t0ll + curr2.begin()->first + 2ll * a[i] ); \n\t\tcurr1.insert( { dp[i] - a[i+1] , i } ); \n\t}\n\tcout << dp[n] + e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, t, e;\nint x[111111];\nlong long f[111111], g[111111];\n\nint main(){\n//\tfreopen(\"input.inp\", \"r\", stdin);\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\",&x[i]);\n\tint p = 0;\n\tg[0] = - 2 * x[1];\n\tfor(int i = 1; i <= n; ++i){\n\t\twhile (2ll * (x[i] - x[p + 1]) > t) ++p;\n\t\tf[i] = f[p] + t;\n\t\tif (p) f[i] = min(f[i], g[p - 1] + 2 * x[i]);\n\t\tg[i] = min(f[i] - 2 * x[i + 1], g[i - 1]);\n\t}\n\tprintf(\"%I64d\",f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<int(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, E, T;\nint X[100001];\nlong long dp[100001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> E >> T;\n  for (int i=1; i<=N; i++) cin >> X[i];\n\n  rep(i, N+1) dp[i] = INF;\n  dp[0] = 0;\n  for (int i=1; i<=N; i++) {\n    for (int j=0; j<i; j++) {\n      dp[i] = min(dp[i], dp[j] + (X[i]-X[j]) + max(T, 2*(X[i]-X[j+1])));\n    }\n  }\n  cout << dp[N] + (E - X[N]) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\n\ninline void chk_min(ll &a,ll b){ if(a>b) a=b;}\n\nstruct Queue\n{\n\tint q[MAXN],hd,tl;\n\tQueue(void){ hd=tl=0;}\n\tinline bool empty(void){ return hd>=tl;}\n\tinline int front(void){ return q[hd+1];}\n\tinline int back(void){ return q[tl];}\n\tinline void push(int x){ q[++tl]=x;}\n\tinline void pop_front(void){ ++hd;}\n\tinline void pop_back(void){ --tl;}\n}q;\n\nint a[MAXN];\nll dp[MAXN],preMn[MAXN];\n\nint main(void)\n{\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\n\tmemset(dp,0x3f,sizeof(dp));\n\t\n\tdp[1]=t;\n\tq.push(1);\n\tpreMn[1] = dp[1]-2*a[2];\n\tfor(int i=2; i<=n; ++i)\n\t{\n\t\twhile(!q.empty() && (a[i]-a[q.front()+1])*2 > t) q.pop_front();\n\t\t\n\t\tdp[i]=dp[i-1]+t;\n\t\tchk_min(dp[i], max(t, (a[i]-a[1])*2));\n\t\t\n\t\tif(!q.empty())\n\t\t\tchk_min(dp[i], dp[q.front()]+t),\n\t\t\tchk_min(dp[i], preMn[q.front()-1]+2*a[i]);\n\t\telse chk_min(dp[i], preMn[i-1]+2*a[i]);\n\t\t\n\t\tpreMn[i] = min(preMn[i-1], dp[i]-2*a[i+1]);\n\t\twhile(!q.empty() && dp[q.back()]>=dp[i]) q.pop_back();\n\t\tq.push(i);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nint n, T, E;\nll x[N], dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &E, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  x[n + 1] = E;\n  ll mv = 1ll * n * T + E;\n  for (int i = 1, j = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n    for (; 2 * (x[i] - x[j]) >= T; j++)\n      mv = min(mv, dp[j - 1] - x[j - 1] - 2 * x[j]);\n      dp[i] = min(dp[i], mv + x[i] * 3);\n    if (j < i) {\n      dp[i] = min(dp[i], dp[j - 1] + x[i] - x[j - 1] + T);\n    }\n  }\n  printf(\"%lld\\n\", dp[n] + E - x[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 1e18;\n\t\tfor (auto itr = dp[i - 1].begin(); itr != dp[i - 1].end(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\tif (besuto > jikan) {\n\t\t\t\tbesuto = jikan;\n\t\t\t\tif (D[i] * 2 < T) {\n\t\t\t\t\tdp[i][saizu + D[i] * 2] = jikan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t\t\tif (saizu < T) dp[i][saizu + D[i] * 2] = jikan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].begin(); itr != dp[N - 1].end(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n,e,t;\nint a[122222];\nll f[122222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(e);gn(t);\n\trep(i,1,n+1){\n\t\tgn(a[i]);\n\t\ta[i]*=2;\n\t}\n\trep(i,1,n+1){\n\t\tf[i]=inf;\n\t\trep(j,1,i+1){\n\t\t\tupmin(f[i],f[j-1]+max(a[i]-a[j],t));\n\t\t}\n\t}\n\tll an=f[n]+e;\n\tcout<<an<<endl;\n\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nstatic ll dp[1 << 20];\nstatic int pos[1 << 20];\nstatic int s[1 << 20];\nint n,S,T;\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    fi>>n>>S>>T;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    for (int i = 1;i <= n;++i)\n    {\n        pos[i] = pos[i - 1];\n        while (T < 2ll * (s[i] - s[pos[i]])) ++pos[i];\n    }\n    dp[0] = 0;\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = max(0ll,pos[i] - 5);j <= min(i - 1,pos[i] + 5);++j)\n                dp[i] = min(dp[i],3ll * s[i] + dp[j] - s[j] - 2ll * s[j + 1] - max(0ll,1ll * T - 2 * (s[i] - s[j + 1])));\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nstruct SegmentTree\n{\n    using T = int;\n\n    int N;\n    vector<T> dat;\n\n    T id = INF;\n    T F(T a, T b) { return min(a, b); }\n    \n    SegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n    }\n\n    SegmentTree(int n, vector<T> v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n        for(int i = 0; i < n; i++) dat[i + N - 1] = v[i];\n        for(int i = N - 2; i >= 0; i--) dat[i] = F(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n\n    void update(int k, T a){\n        k += N - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = F(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void reset() { fill(dat.begin(), dat.end(), id); }\n\n    T get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F(vl, vr);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, N); }\n\n    T val(int k){ return dat[k + N - 1]; }\n};\n\nsigned main(){\n\n    int N, E, T; cin >> N >> E >> T;\n    vec x(N + 1);\n    x[0] = 0; REP(i, N) cin >> x[i + 1];\n\n    SegmentTree dp(N + 1);\n    dp.update(0, -2 * x[1]);\n    int ans;\n    FOR(i, 1, N + 1){\n        int i0 = Lower_bound(x, x[i] - T / 2);\n        i0 = max(0LL, i0 - 1);\n        int v1 = dp.val(i0) + 2 * x[i0 + 1] + T;\n        int v2 = dp.get(0, i0) + 2 * x[i];\n        if(i < N) dp.update(i, min(v1, v2) - 2 * x[i + 1]);\n        else ans = min(v1, v2) + E;\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\td[0]=0;\n\tfoor(i,1,N){\n\t\tfoor(j,i,N){\n\t\t\tchmin(d[j],d[i-1]+x[i]-x[i-1]+max(2*(x[j]-x[i]),T)+x[j]-x[i]);\n\t\t}\n\t}\n\tprint(d[N]+E-x[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint st[800005][2]; \nvoid update(ll root, ll l, ll r, ll i, ll val, ll id){\n\tif (i < l || r < i) return;\n\tif (l == r){\n\t\tst[root][id] = val; return;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(root * 2 + 1, l, mid, i, val, id);\n\tupdate(root * 2 + 2, mid + 1, r, i, val, id);\n\tst[root][id] = min(st[root * 2 + 1][id], st[root * 2 + 2][id]);\n}\nll query(ll root, ll l, ll r, ll u, ll v, ll id){\n\tif (u > v) return 1e18;\n\tif (v < l || r < u) return 1e18;\n\tif (u <= l && r <= v) return st[root][id];\n\tll mid = (l + r) / 2;\n\treturn min(query(root * 2 + 1, l, mid, u, v, id), query(root * 2 + 2, mid + 1, r, u, v, id));\n}\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\t// dp[i]: shortest time to clear first i candies.\n\tdp[0] = 0;\n\t// 2 segtrees: one record dp[j] - 2 * a[j + 1] - a[j], one record dp[j] - a[j].\n\tupdate(0, 0, n - 1, 0, dp[0] - 2 * a[1], 0);\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tll lw; // lw: (a[i] - a[lw]) * 2 <= t, (a[i] - a[lw - 1]) * 2 > t. (lw - 1 -> 0)\n\t\t// manual binsearch? lw >= l, <= r\n\t\tll l = 0, r = i - 1;\n\t\twhile (l < r){\n\t\t\tll mid = (l + r) / 2;\n\t\t\tif ((a[i] - a[mid + 1]) * 2 <= t) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tlw = l;\n\t\t// so (dp[j] - 2 * a[j + 1] - a[j]) + 3 * a[i] with a from 0 to lw - 1, (dp[j] - a[j]) + a[i] + t to lw to i - 1\n\t\tdp[i] = min(query(0, 0, n - 1, 0, lw - 1, 0) + 3 * a[i], query(0, 0, n - 1, lw, i - 1, 1) + a[i] + t);\n\t\tupdate(0, 0, n - 1, i, dp[i] - 2 * a[i + 1] - a[i], 0); update(0, 0, n - 1, i, dp[i] - a[i], 1);\n\t\t// for (ll j = 0; j < i; j++) dp[i] = min(dp[i], dp[j] + max(2 * (a[i] - a[j + 1]), t) + a[i] - a[j]);\n\t}\n\t// hj, optimize nao\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\nconst ll oo = 1e18 + 10;\nstruct Tree {\n    vl t;\n    Tree() {\n        t.resize(N << 2, oo);\n    }\n\n    void upd(int v, int tl, int tr, int pos, ll val) {\n        if (tl == tr) {\n            t[v] = val;\n            return;\n        }\n        int tm = tl + tr >> 1;\n        if (pos <= tm)\n            upd(v << 1, tl, tm, pos, val);\n        else\n            upd(v << 1 | 1, tm + 1, tr, pos, val);\n        t[v] = min(t[v << 1], t[v << 1 | 1]);\n    }\n\n    ll get(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return oo;\n        if (tl == l && tr == r)\n            return t[v];\n        int tm = tl + tr >> 1;\n        return min(\n                get(v << 1, tl, tm, l, min(tm, r)),\n                get(v << 1 | 1, tm + 1, tr, max(tm  + 1, l), r)\n                );\n    }\n};\n\nll T, E;\n\nll dp[N];\nTree t1, t2;\n\nvoid smain() {\n    int n;\n    cin >> n >> E >> T;\n    vl x(n);\n    fori (i, n) {\n        cin >> x[i];\n    }\n    x.push_back(E);\n    n = x.size();\n\n    dp[0] = x[0];\n\n    t2.upd(1, 0, n, 0, -x[0] + dp[0]);\n    t1.upd(1, 0, n, 0, -x[0] * 3 + dp[0]);\n    for (int i = 0; i < n - 1; ++i) {\n        int l = -1, r = i;\n        while (r - l > 1) {\n            int m = r + l >> 1;\n            if (2 * (x[i] - x[m]) <= T) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        ll cur2 = t2.get(1, 0, n, r, i) + T + x[i];\n        ll cur1 = t1.get(1, 0, n, 0, r - 1) + x[i] * 3;\n        dp[i + 1] = min(cur1, cur2) + x[i + 1] - x[i];\n        t2.upd(1, 0, n, i + 1, -x[i + 1] + dp[i + 1]);\n        t1.upd(1, 0, n, i + 1, -x[i + 1] * 3 + dp[i + 1]);\n    }\n\n    fori (i, n) {\n        cerr << \"dp[\" << i << \"] = \" << dp[i] << endl;\n    }\n\n    cout << dp[n - 1];\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#define ll long long\n#define inf 1e9\n#define eps 1e-10\n#define mod 9901\n#define mkp make_pair\nusing namespace std;\nint i,j,k,m,s,t,n,ans1,ans2,n1,nn,m1,mx;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint kabs(int a)\n{\n   if (a<0) return -a;\n   return a; \n}\nvoid add(int &x,int y)\n{\n   x+=y;\n   if (x>=mod) x-=mod;\n}\nvoid dec(int &x,int y)\n{\n\tx-=y;\n\tif (x<0) x+=mod;\n}\nint a[101000];\nll f[101000];\nint main()\n{\n\tint e;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tj=0;\n\tll s=1e18;\n\tfor (i=1;i<=n;i++)\n\t\tf[i]=1e18;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\twhile (2*(a[i]-a[j+1])>=t)\n\t\t\ts=min(s,f[j]-2ll*a[j+1]),j++;\n\t\tf[i]=min(f[j]+t,2ll*a[i]+s);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \nconst ll INF = 1ll<<50;\n \n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b){\n            return seg[k];\n        }\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n \nconst int MAXN = 100100;\nll N, E, T;\nll X[MAXN];\nll dp[MAXN];\n \nint main() {\n    cin >> N >> E >> T;\n    for (int i = 0; i < N; i++)\n        cin >> X[i];\n    const ll INF = 1ll<<60;\n    ST<ll> seg(N+10);\n    for (int i = 0; i <= N; i++) {\n        dp[i] = INF;\n    }\n    X[N] = E;\n    dp[N] = 0;\n    //seg.update(N, dp[N] + X[N] + 2*X[N-1]);\n    for (int i = N-1; i >= 0; i--) {\n        // まず T が支配的な部分を探索\n        int low = i, high = N;\n        while (high - low > 1) {\n            const int med = (low + high) / 2;\n            if (2*(X[med]-X[i]) <= T) {\n                low = med;\n            } else {\n                high = med;\n            }\n        }\n        // cout << low+1 << \"a\" << N << endl;\n        dp[i] = dp[low+1] + X[low+1] - X[i] + T;\n        dp[i] = min(dp[i], seg.query(low+1, N) - 3*X[i]);\n        if (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << X[0] + dp[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <fstream>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n\n#define maxn 200010\n#define inf 1LL<<60\n\nusing namespace std;\nlong long x[maxn];\nlong long dp[maxn];\n\nint main() {\n    // freopen(\"POLYGON.in\", \"r\", stdin);\n    // freopen(\"POLYGON.out\", \"w\", stdout);\n    int n;\n    long long e, t;\n    cin >> n >> e >> t;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> x[i];\n    }\n    x[n+1] = e;\n    \n    dp[1] = x[1];\n    for (int i = 2; i <= n+1; ++i) {\n        dp[i] = inf;\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (dp[i] == inf)\n            continue;\n        int lo = i, hi = n+1;\n        /*while (hi - lo > 1) {\n            int mid = (lo + hi)/2;\n            if (2*(x[mid] - x[i]) <= t) {\n                lo = mid;\n            } else {\n                hi = mid;\n            }\n        }*/\n        for (int j = i; j <= n; ++j) {\n            dp[j+1] = min(dp[j+1], dp[i] + 3*(x[j] - x[i]) + max(0LL, t - 2*(x[j] - x[i])) + x[j+1] - x[j]);\n        }\n        /*\n        dp[lo+1] = min(dp[lo+1], dp[i] + 3*(x[lo] - x[i]) + (t - 2*(x[lo]-x[i])) + x[lo+1] - x[lo]);\n        if (lo+2 <= n+1) {\n            dp[lo+2] = min(dp[lo+2], dp[i] + 3*(x[lo+1] - x[i]) + x[lo+2] - x[lo+1]);\n        }*/\n    }\n    cout << dp[n+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n \nusing namespace std;\n \n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n#define ll long long\n#define ld double\n#define ull unsigned long long\n#define PI pair < int, int > \n \nconst int N = 123;\nconst int M = 123;\nconst ld Pi = acos(-1);\nconst ll Inf = 1e18;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nconst int Sz = 501;\nconst int MOD = 1e9 + 7;\n \nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint mult(int a, int b) {\n  return 1ll * a * b % mod;\n}\nint sum(int a, int b) {\n  add(a, b);\n  return a;\n}\n \nint n, a[N], t, m;\nll dp[N];\n\nll calc(int l, int r) {\n  ll ans = max((a[r] - a[l]) * 2ll, 1ll * t);\n  return ans;\n}\n \nvoid solve() { \n  cin >> n >> m >> t;\n  for (int i = 1;i <= n;i++) {\n    cin >> a[i];\n    dp[i] = 1e18;\n  }\n  for (int i = 1;i <= n;i++) {\n    for (int j = 1;j <= i;j++) {\n      ll cur = dp[j - 1] + calc(j, i);\n      dp[i] = min(dp[i], cur);\n    }\n  }\n  cout << dp[n] + m << endl;\n}\n  \nint main() {\n  #ifdef wws\n   freopen(\"in\", \"r\", stdin);\n   // freopen(\"in\", \"w\", stdout);\n  #endif \n  ios_base::sync_with_stdio(0);\n  int tt = 1; \n  while(tt--) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nvector<int> tree;\nint N = 1;\n\nvoid upd(int v) {\n\tif(v == 0) \n\t\treturn;\n\ttree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n\tupd(v / 2);\n}\n\nint get(int v, int l, int r, int vl, int vr) {\n\tif(vr <= l || r <= vl)\n\t\treturn inf;\n\tif(vl <= l && r <= vr) {\n\t\treturn tree[v];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(get(v * 2, l, m, vl, vr), get(v * 2 + 1, m, r, vl, vr));\n}\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\n\twhile(N < (n + 2)) \n\t\tN *= 2;\n\n\ttree = vector<int> (2 * N, inf);\n\tvector<int> suf(n + 1, inf);\n\tsuf[n - 1] = k;\n\tint uk = n - 2;\n\ttree[N + (n - 2)] = k + a[n - 1] + suf[n - 1];\n\tupd((N + (n - 2)) / 2);\n\n\tfor (int i = n - 2; i >= 0; i--) {\n\n\t\twhile(uk > 0 && 2 * (a[uk] - a[i]) >= k) {\n\t\t\ttree[N + uk] = 2 * a[uk] + a[uk + 1] + suf[uk + 1];\n\t\t\tupd((N + uk) / 2);\n\t\t\tuk--;\n\t\t}\n\t\tint ans = max(k, 2 * (a[n - 1] - a[i])) + (a[n - 1] - a[i]);\n\t\tint l = uk;\n\t\t// cout << ans << \" \" << i << \" \" << l << \" \" << get(1, 0, N, i, l + 1) << \" \" << uk << endl;\n\t\tans = min(ans, get(1, 0, N, i, l + 1) - a[i]);\n\t\tif(l + 1 < n - 1) {\n\t\t\tans = min(ans, get(1, 0, N, l + 1, n - 1) - 3LL * a[i]);\n\t\t}\n\t\tsuf[i] = ans;\n\t\tif(i != 0) {\n\t\t\ttree[N + (i - 1)] = k + a[i] + suf[i];\n\t\t\tupd((N + (i - 1)) / 2);\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}\n\n// j\n\n// "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\n// ll dfs(int p){\n//   if(dp[p]!=-1)return dp[p];\n//   dp[p] = INF;\n//   FOR(to,p,n){\n//     ll len = x[to] - x[p];\n//     ll add = max(t,2ll*len);\n//     CHMIN(dp[p],add+len+x[to+1]-x[to]+dfs(to+1));\n//   }\n//   return dp[p];\n// }\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  assert(n<=2000);\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = x[0];\n  REP(i,n)ans += x[i+1]-x[i];\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    int l = i;\n    int r = n-1;\n    while(l+2<r){\n      int midl = (2*l+r)/3;\n      int midr = (l+2*r)/3;\n      if(calc(i,midl) < calc(i,midr)){\n        r = midr;\n      }else{\n        l = midl;\n      }\n    }\n    dp[i] = INF;\n    FOR(j,l,r+1){\n      CHMIN(dp[i],calc(i,j));\n    }\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tfor(int j=Min;j>=0;j--){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif(max(t,(x[i]-x[j+1])*2)+dp[j]>dp[i])\n\t\t\tbreak;\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MAX_N = 100005;\nint64_t cache[MAX_N];\nint bpos[MAX_N];\nint N, E, T;\n\nint main() {\n  scanf(\"%d %d %d\", &N, &E, &T);\n  bpos[0] = 0;\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", bpos + i + 1);\n    cache[i + 1] = 10000000000LL;\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = i + 1; j <= N; ++j) {\n      int64_t d = bpos[j] - bpos[i + 1];\n      int64_t cost = bpos[i + 1] - bpos[i] + 3 * d + std::max(0LL, int64_t(T) - 2LL * d) + cache[i];\n      //printf(\"%d %d: %lld %s\\n\", i, j, cost, cost < cache[j] ? \"YE\" : \"NO\");\n      cache[j] = std::min(cache[j], cost);\n    }\n  }\n  printf(\"%lld\\n\", cache[N] + E - bpos[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 > T) L = mid;\n      else R = mid;\n    }\n    int pos = low;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main(void)\n{\n    long long int n,e,t;\n    long long int cost = 0;\n    vector<int> x;\n\n    cin>>n>>e>>t;\n\n    for(int i = 0;i < n;i++)\n    {\n\tint temp;\n\tcin>>temp;\n\n\tx.push_back(temp);\n    }\n    \n    cost = x[0];\n\n    for(int i = 0;i < n-1;i++)\n    {\n\tint temp;\n\ttemp = 0;\n\n\tif(x[i+1]-x[i] <= t / 2)\n\t{\n\t    temp += x[i-1]-x[i];\n\t    for(int j = i+1;j < n-1;j++) {\n\t\tif(x[j+1]-x[j]+temp <= t/2)\n\t\t{\n\t\t    temp += x[j+1]-x[j];\n\n\t\t    i = j - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tcost += 2*temp + (t-temp);\n    }\n\n    cost += x[n-1]+(e-x[n-1]);\n\n    cout<<cost<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <iostream>\n#include <sstream>\n#include <complex>\n#include <cassert>\n#include <bitset>\n\n#define enp     puts(\"**chkchkchkchkchk**\")\n#define A       first\n#define B       second\n#define MP      make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\n\nconst int INF = 0x60000000;\nconst int MINF = -1000000000;\nconst int mod = 1000000007;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\nconst int sqrtMax = 317;\nconst int blocks = cons / 3;\n\nll dp[100001];\nll pos[100001];\nint n;\nll e, t;\n\nll tree[400002];\nint lim;\n\nvoid upd(int pos, ll vl)\n{\n\tpos += lim;\n\ttree[pos] = vl;\n\n\twhile (pos > 1)\n\t{\n\t\tpos >>= 1;\n\t\ttree[pos] = min(tree[2 * pos], tree[2 * pos + 1]);\n\t}\n}\n\nll query(int L, int R)\n{\n\tif (L > R)return 1e18;\n\n\tL += lim;\n\tR += lim;\n\tll ret = 1e18;\n\n\twhile (L <= R)\n\t{\n\t\tret = min(ret, min(tree[L++], tree[R--]));\n\t\tL >>= 1;\n\t\tR >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint main() \n{\n\tscanf(\"%d%lld%lld\", &n, &e, &t);\n\n\tmemset(tree, 0x3f, sizeof(tree));\n\tfor (lim = 1; lim < n; lim <<= 1);\n\n\tfor (int i = 1; i <= n; i++)scanf(\"%lld\", &pos[i]);\n\n\tupd(0, -2 * pos[1]);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tll res = 1e18;\n\n\t\tint l = -1;\n\t\tint r = i;\n\n\t\twhile (l + 1 < r)\n\t\t{\n\t\t\tint mid = l + r >> 1;\n\n\t\t\tif (2 * (pos[i] - pos[mid + 1]) < t)r = mid;\n\t\t\telse l = mid;\n\t\t}\n\n\t\tif(r < i)res = min(res, dp[r] - pos[r] + pos[i] + t);\n\t\tll tmp = query(0, l);\n\t\tres = min(res, tmp + 3 * pos[i]);\n\t\tdp[i] = res;\n\n\t\tif (i == n)break;\n\t\tupd(i, dp[i] - pos[i] - 2 * pos[i + 1]);\n\t}\n\n\tprintf(\"%lld\\n\", e - pos[n] + dp[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N], pre[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tsrand(time(0));\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\t//n = 5000, E = 1000000, T = 100000;\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0;\n\tdp[1] = A[1] + T;\n\tpre[1] = 0;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\tfor(int j = 0; j < i; ++ j)\n\t\tdp[i] = min(calc(j, i), dp[i]);\n\t\tfor(int j = 0; j < i; ++ j) if(calc(j, i) == dp[i]) pre[i] = j;\n\t\tassert(pre[i] >= pre[i - 1]);\n\t\t//cerr << pre[i] << endl;\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n+1);\n\tvector<long long int> y(n+1, 0);\n\tx[0] = 0;\n\tfor (long long int i = 1; i < n+1; i++) {\n\t\tcin >> x[i];\n\t}\n\tlong long int c = 0;\n\tfor (long long int i = 1; i < n+1; i++) {\n\t\tif (y[i] == 0) {\n\t\t\tc += x[i]-x[i-1];\n\t\t\tlong long int m = t;\n\t\t\tlong long int m2 = 0;\n\t\t\tlong long int m3 = t;\n\t\t\tfor (long long int j = 1; i+j < n+1; j++) {\n\t\t\t\tm += (x[i+j]-x[i+j-1]);\n\t\t\t\tm += t;\n\t\t\t\tm2 = (x[i+j]-x[i])*3;\n\t\t\t\tif (m2 <= m) {\n\t\t\t\t\tm3 = m2;\n\t\t\t\t\ty[i+j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc += m3;\n\t\t}\n\t\t//cout << c << endl;\n\t}\n\tc += e-x[n];\n\tcout << c << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int MAXN = 100005;\ntypedef long long ll;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nll t,e,n,d[MAXN];\nll c[MAXN],f[MAXN];\ninline void update(int x,ll v)\n{\n\tfor(;x<=n;x+=lowbit(x))\n\t\tc[x]=min(c[x],v);\n}\ninline ll query(int x)\n{\n\tll ret=INF;\n\tfor(;x;x-=lowbit(x))\n\t\tret=min(ret,c[x]);\n\treturn min(ret,(ll)-2*d[1]);\n}\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",d+i);\n\tint p=0;\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(2*(d[i]-d[p+1])>=t)++p;\n\t\tif(p>0)f[i]=min(f[i],query(p-1)+2*d[i]);\n\t\tf[i]=min(f[i],f[p]+t);\n\t\tupdate(i,f[i]-2*d[i+1]);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rb(x) ((x)&(-(x)))\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100005;\nconst int MX = 131072;\n\nstruct SEG {\n\tSEG() { init(); }\n\tll d[MX*2];\n\tvoid init() { fill(d, d+MX*2, INFLL); }\n\tvoid upd(int x, ll r) {\n\t\tx += MX; d[x] = r;\n\t\tfor(x /= 2; x; x /= 2)\n\t\t\td[x] = min(d[x*2], d[x*2+1]);\n\t}\n\tll get(int s, int e) {\n\t\tll r = INFLL; for(s += MX, e += MX; s <= e; s /= 2, e /= 2) {\n\t\t\tif(s&1) upmin(r, d[s++]); if(~e&1) upmin(r, d[e--]);\n\t\t} return r;\n\t}\n} seg1, seg2;\n\nll dp[MAXN];\n\nint A[MAXN];\n\nint N, T, E;\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n\n\tseg1.upd(0, 0);\n\tseg2.upd(0, -2 * ll(A[1]));\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tll &ret = dp[i];\n\t\tret = INFLL;\n\n\t\tint li = max(0, (int)(lower_bound(A, A+i, A[i] - T/2) - A) - 1);\n\t\tif(li < i)\n\t\t\tupmin(ret, seg1.get(li, i-1) + A[i] + T);\n\t\tif(0 < li)\n\t\t\tupmin(ret, seg2.get(0, li-1) + ll(A[i])*3);\n\n\t\tseg1.upd(i, ret - A[i]);\n\t\tseg2.upd(i, ret - A[i] - ll(A[i+1])*2);\n\t}\n\n\tprintf(\"%lld\\n\", dp[N] + E - A[N]);\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2015\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint N, E;\nll a[MAXN], dp[MAXN], T;\nset<pair<ll, ll> > s[2];\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i=0; i<N; i++) scanf(\"%d\", &a[i]);\n\t\n\tfor (int i=0; i<N; i++) dp[i] = oo;\n\tint cur = 0;\n//\ts[0].insert(mp(T, 0));\n\tfor (int i=0; i<N; i++) {\n\t\twhile (cur <= i && (a[i] - a[cur]) * 2 >= T) {\n\t\t\tint now = T - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\t\n\t\t\tint nxt = -2 * a[cur] - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\tif (s[0].find(mp(now, cur)) != s[0].end()) {\n\t\t\t\ts[0].erase(mp(now, cur));\n\t\t\t\ts[1].insert(mp(nxt, cur));\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tdp[i] = a[i] - (i != 0 ? a[i-1] : 0) + (i != 0 ? dp[i-1] : 0) + T;\n//\t\tif (i == 1) cout << dp[1] << endl;\n\t\tif (!s[0].empty()) {\n\t\t\tint now = s[0].begin()->FI;\n\t\t\tdp[i] = min(dp[i], a[i] + now);\n\t\t}\n//\t\tif (i == 2) cout << dp[i] << endl;\n\t\tif (!s[1].empty()) {\n\t\t\tint now = s[1].begin()->FI;\n\t\t\tdp[i] = min(dp[i], 3 * a[i] + now);\t\t\t\n\t\t}\n\t\tint nxt = T - (i != 0 ? a[i - 1] : 0) + (i != 0 ? dp[i - 1] : 0);\n\t\ts[0].insert(mp(nxt, i));\n\t}\n//\tcout << dp[1] << endl;\n\tcout << E - a[N - 1] + dp[N - 1];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 1;\n\tlong long mi = 1;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\twhile (pp <= n && 2 * (d[i] - d[pp]) > t){\n\t\t\tmi = min(mi,f[pp - 1] - d[pp] * 2);\n\t\t\tpp++;\n\t\t}\n\t\tf[i] = min(f[pp - 1] + t,mi + d[i] * 2);\n\t}\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i+1;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 >= T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        /*\n        for (int j=1; j<i; j++)\n            if (T-(x[i]-x[j])*2 < 0)\n                A[i] = min(A[i], 3*x[i] +A[j-1]-x[j-1]-2*x[j]);\n            else\n                A[i] = min(A[i], T+x[i] +A[j-1]-x[j-1]);\n                */\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e5 + 7, INF = 1e18 + 7;\nint n, T, E, a[N], dp[N], pref[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    pref[0] = INF;\n    for (int i = 1; i <= n; ++i) {\n        //2 * a[i] - 2 * a[j] <= T\n        //2 * a[j] >= 2 * a[i] - T\n        //a[j] >= (2 * a[i] - T + 1) / 2\n        int l = lb(a + 1, a + n + 1, (2 * a[i] - T + 1) >> 1) - a;\n        dp[i] = min(dp[l - 1] + T, 2 * a[i] + pref[l - 1]);\n        pref[i] = min(pref[i - 1], dp[i - 1] - 2 * a[i]);\n    }   \n    cout << dp[n] + E << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint T, e;\nint n;\n\nint a[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &e, &T) < 3) {\n    return 0;\n  }\n  a[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i + 1);\n  }\n  ++n;\n  return 1;\n}\n\nlong long dp[maxn];\nlong long dpup[maxn];\n\nvoid solve() {\n  sort(a, a + n);\n\n  int pos = 0;\n\n  vector<pair<long long, int> > st;\n  int left = 0;\n\n  for (int i = 0; i < n; ++i) {\n    dpup[i] = 1e18;\n  }\n\n  for (int i = 0; i < n; ++i) {\n    long long &cur = dp[i];\n    if (!i) {\n      cur = 0;\n    } else {\n      cur = 1e18;\n      cur = min(cur, dpup[i] + 2 * a[i]);\n      while (left < sz(st) && st[left].second <= i) {\n        ++left;\n      }\n      if (left < sz(st)) {\n        cur = min(cur, st[left].first);\n      }\n    }\n    //eprintf(\"dp[%d] = %lld\\n\", i, cur);\n\n    if (i < n - 1) {\n      while (pos < n && (a[pos] - a[i + 1]) * 2 <= T) {\n        ++pos;\n      }\n      long long nval = cur + T;\n      while (sz(st) > 0 && st.back().first >= nval) {\n        st.pop_back();\n        if (left == sz(st)) {\n          --left;\n        }\n      }\n      st.push_back(mp(nval, pos));\n      //eprintf(\"nval = %lld, pos = %d\\n\", nval, pos);\n\n      dpup[pos] = min(dpup[pos], cur - 2 * a[i + 1]);\n      dpup[i + 1] = min(dpup[i + 1], dpup[i]);\n    }\n  }\n\n  long long res = dp[n - 1] + e;\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<62;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tll n,e,t;cin>>n>>e>>t;\n\tvector<ll> x(n+10);\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tvector<ll> dp(n+10,LINF);\n\tdp[0]=0;\n\tint id=0;\n\tll mix=LINF;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>1)mix+=2LL*(x[i]-x[i-1]);\n\t\twhile(id<i&&2LL*(x[i]-x[id+1])>t){\n\t\t\tchmin(mix,dp[id]+2LL*(x[i]-x[id+1]));\n\t\t\tid++;\n\t\t}\n\t\tchmin(dp[i],mix);\n\t\tchmin(dp[i],dp[id]+t);\n\t}\n\tcout<<e+dp[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define REP(i, k) for (decltype(k) i = 0; i < k; i++)\n#define LOOP(k) REP (ngtkana_is_a_genius, k)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\nauto cmn = [](auto& x, auto y){ if (x>y) { x=y; return true; } return false; };\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n; i64 E, T; std::cin >> n >> E >> T;\n    vec<i64> a(n+1);\n    for (usize i=1; i<=n; i++) std::cin >> a.at(i);\n\n    i64 inf = numr<i64>::max();\n    i64 min = inf;\n    vec<i64> dp(n+1, inf);\n    dp.at(0) = 0;\n    for (usize l=0, j=1; j<=n; j++) {\n        for (; T < 2 * (a.at(j) - a.at(l+1)); l++) {\n            cmn(min, dp.at(l) - 2 * a.at(l + 1));\n        }\n        if (l) cmn(dp.at(j), min + 2 * a.at(j));\n        cmn(dp.at(j), dp.at(l) + T);\n    }\n\n    i64 ans = dp.at(n) + E;\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    i64 g, t; cin >> g >> t;\n    vector<i64> a(n, 0LL);\n    for(auto& x : a) cin >> x;\n    assert(n <= 2000);\n    vector<i64> dp(n + 1, 1e18);\n    dp[0] = 0LL;\n    for(int i : in(n)) for(int j : in(i + 1))\n      dp[i + 1] = min(dp[i + 1], dp[j] + max(t, 2LL * (a[i] - a[j])));\n    cout << dp[n] + g << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint x[200000];\nll dp[3000][3000];\n\nint main(){\n\tint n,E,T;cin>>n>>E>>T;\n\tif(n>2000)abort();\n\trep(i,n)scanf(\"%d\",&x[i+1]);\n\tx[n+1]=E;\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[1][0]=x[1];\n\tfor(int i=1;i<=n;i++)rep(j,i){\n\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+(x[i+1]-x[i]));\n\t\tdp[i+1][i]=min(dp[i+1][i],max(dp[i][j]+(x[i]-x[j+1]),dp[i][j]-(x[i]-x[j+1])+T)+(x[i+1]-x[j+1]));\n\t}\n\tcout<<dp[n+1][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\tdp[i] = get(i, 0);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n,e,t,curpos;\nlong long arr[100010];\nlong long ans;\nlong long dp[100010];\ndeque<long long> dp2;\nint main() {\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(NULL);\n    cin>>n>>e>>t;\n    for (int i=1;i<=n;i++) cin>>arr[i];\n    dp2.push_back(1e16);\n    for (int k=1;k<=n;k++){\n        dp[k]=1e16;\n        int prevpos=curpos;\n        while (curpos<k-1 && t<=(arr[k]-arr[curpos])*2) curpos++;\n        dp[k]=dp[curpos]+t;\n        dp[k]=min(dp[k],arr[k]*2+dp2.front());\n        for (int i=prevpos;i<=curpos;i++){\n            while (!dp2.empty() && dp2.back()>dp[i]-arr[i+1]*2) dp2.pop_back();\n            dp2.push_back(dp[i]-arr[i+1]*2);\n        }\n        cout<<dp[k]+arr[k]<<'\\n';\n    }\n    cout<<e+dp[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nint n,e,T;\nll dp[100010];\nint dis[100010];\nll inf=1LL<<60;\n\nstruct node{\n    int s,e,m;\n    ll mini=0;\n    node *l,*r;\n    node(int a,int b){\n        s=a;e=b;m=(a+b)/2;\n        if(s==e)return;\n        l=new node(s,m);\n        r=new node(m+1,e);\n    }\n    void update(int pos,int val){\n        if(s==e){\n            mini=val;\n            return;\n        }\n        if(pos<=m)l->update(pos,val);\n        else r->update(pos,val);\n        mini=min(l->mini,r->mini);\n    }\n    ll query(int a,int b){\n        if(a>b)return inf;\n        if(s==a && b==e){\n            return mini;\n        }\n        if(b<=m)return l->query(a,b);\n        if(m<a)return r->query(a,b);\n        return min(l->query(a,m),r->query(m+1,b));\n    }\n};\n\nint main() {\n    //freopen(\"hi.txt\", \"r\", stdin);\n    scanf(\"%d%d%d\",&n,&e,&T);\n    /// dp[x] = dp[i] + 3(dis[x]-dis[i+1]) + (dis[i+1]-dis[i]) + max(0,T-2(dis[x]-dis[i+1]))\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&dis[i]);\n    }\n    node *wait,*nowait;\n    wait=new node(0,n);\n    nowait=new node(0,n);\n    int waitpos=0;\n    for(int x=1;x<=n;x++){\n        wait->update(x-1,dp[x-1]-2LL*dis[x]-dis[x-1]+2LL*dis[x]);\n        nowait->update(x-1,dp[x-1]-2LL*dis[x]-dis[x-1]);\n        while(waitpos<x && T-2*(dis[x]-dis[waitpos+1])<0){\n            waitpos++;\n        }\n        dp[x]=inf;\n        ///ll ans=dp[i] +3LL*dis[x]-2LL*dis[i+1]-dis[i];\n        ///ans+=max(0LL,(ll)T-2*(dis[x]-dis[i+1]));\n        ll ans=nowait->query(0,waitpos-1)+3LL*dis[x];\n        dp[x]=min(dp[x],ans);\n        ans=wait->query(waitpos,x-1)+3LL*dis[x]+T-2*dis[x];\n        dp[x]=min(dp[x],ans);\n        //printf(\"dp %d = %lld\\n\",x,dp[x]);\n    }\n    printf(\"%lld\\n\",dp[n]+e-dis[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1000000000000000007ll\nusing namespace std;\n\nint n,e,t,a[100010],dp[100010];\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>a[i]; \n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=INF;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j]+max(t,2*(a[i]-a[j+1])));\n\t\t}\n\t}\n\tcout<<dp[n]+e<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll T,E;\nll X[100010];\nll dp[100010] = {};\nconst ll inf = 1e18;\n\nint main(){\n    cin >> N >> E >> T;\n    assert(N<=2000);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i]-X[i-1]+T;\n        for(int j=1;j<=i-1;j++){\n            dp[i] = min(dp[i],dp[j-1]+X[j]-X[j-1]+3*(X[i]-X[j])+max(T-2*(X[i]-X[j]),0LL));\n        }\n    }\n/*    for(int i=0;i<=N;i++) cerr << dp[i] << \" \";\n    cerr << endl;\n*/    cout << dp[N]+(E-X[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p[100005];\nlong long pp[100005];\nmain()\n{\n\tint t;\n\tlong long ppp,q;\n\tscanf(\"%d%lld%lld\",&t,&q,&ppp);\n\tfor(int i = 0;i <= t+1;i++)\n\t{\n\t\tpp[i]=1e15;\n\t}\n\tfor(int i = 1;i <= t;i++)\n\t{\n\t\tscanf(\"%lld\",&p[i]);\n\t}\n\tpp[0]=0;\n\tpp[1]=p[1];\n\tp[t+1]=q;\n\tfor(int i = 1;i <= t;i++)\n\t{\n\t\tfor(int j = i;j <= t;j++)\n\t\t{\n\t\t\tif(2*(p[j]-p[i])>=ppp)\n\t\t\tpp[j+1]=min(pp[i]+3*(p[j]-p[i])+(p[j+1]-p[j]),pp[j+1]);\n\t\t\telse\n\t\t\tpp[j+1]=min(pp[i]+ppp+(p[j+1]-p[i]),pp[j+1]);\n\t\t}\n\t}\n\t//for(int i = 0;i <= t;i++)\n\t//printf(\"%lld \",pp[i+1]);\n\tprintf(\"%lld\",pp[t+1]);\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define MAXN 55\n# define MAXM 100005\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nint a[100005];\nLL dp[100005][2];\n\nint main()\n{\n    int n, E, T;\n    LL ans=0;\n    scanf(\"%d%d%d\",&n,&E,&T);\n    FO(i,0,n) scanf(\"%d\",a+i);\n    int i=1;\n    dp[0][0]=a[0]; dp[0][1]=a[0]+T;\n    while(i<n-1) {\n        dp[i][0]=dp[i-1][1]+a[i]-a[i-1];\n        dp[i][1]=dp[i-1][1]+a[i]-a[i-1]+T;\n        if (T>=(LL)2*(a[i]-a[i-1])) dp[i][1]=min(dp[i][1], dp[i-1][0]+T+a[i]-a[i-1]);\n        else if (T>=a[i+1]-a[i]) dp[i][1]=min(dp[i][1], dp[i-1][0]+(LL)3*(a[i]-a[i-1]));\n        ++i;\n    }\n    printf(\"%lld\\n\",dp[n-1][1]+E-a[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nstatic ll dp[1 << 20];\nstatic int pos[1 << 20];\nstatic int s[1 << 20];\nint n,S,T;\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    fi>>n>>S>>T;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    for (int i = 1;i <= n;++i)\n    {\n        pos[i] = pos[i - 1];\n        while (T < 2ll * (s[i] - s[pos[i]])) ++pos[i];\n    }\n    dp[0] = 0;\n    static ll mn[1 << 20];\n    mn[0] = -2ll * s[1];\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = max(0ll,pos[i] - 5);j <= min(i - 1,pos[i] + 5);++j)\n                dp[i] = min(dp[i],dp[j] + s[i] - s[j] + 2ll * (s[i] - s[j + 1]) + max(0ll,1ll * T - 2 * (s[i] - s[j + 1])));\n            if (pos[i] >= 5)\n                dp[i] = min(dp[i],3ll * s[i] + mn[pos[i] - 5]);\n            mn[i] = min(dp[i] - s[i] - 2ll * s[i + 1],mn[i - 1]);\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[100010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+100010, 1e15);\n\n  dp[0] = 0;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tint j;\n\tfor(j=i;j<N;++j){\n\t  LL d = xs[j] - xs[i];\n\t  LL tmp = dp[i] + t + d*3 + max(0ll, T-2*d);\n\t  dp[j+1] = min(dp[j+1], tmp);\n\t  if(T - 2*d <= 0) break;\n\t}\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\nstruct RMQ{\n  int n;\n  vl dat;\n  RMQ(int _n){\n    n=1;\n    while(n<_n)n<<=1;\n    dat.assign(2*n,INF);\n  }\n  void set(int x,int v){\n    x += n-1;\n    dat[x] = v;\n    while(x!=0){\n      x = (x-1)/2;\n      dat[x] = min(dat[2*x+1],dat[2*x+2]);\n    }\n  }\n  ll qmin(int l,int r,int a,int b,int k){\n    if(r<=a || b<=l)return INF;\n    if(l<=a && b<=r){\n      return dat[k];\n    }else{\n      int m = (a+b)/2;\n      return min(qmin(l,r,a,m,2*k+1),qmin(l,r,m,b,2*k+2));\n    }\n  }\n  ll qmin(int l,int r){\n    return qmin(l,r,0,n,0);\n    return dat[0];\n  }\n};\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = x[0];\n  REP(i,n)ans += x[i+1]-x[i];\n  RMQ aa(n),bb(n);\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    aa.set(i,2ll*x[i]+dp[i+1]);\n    bb.set(i,t       +dp[i+1]);\n    // find m s.t. 2dij<t\n    int l=i,r=n+1;\n    while(l+1<r){\n      int m = (l+r)/2;\n      int val = 2*(x[m]-x[i]);\n      if(val < t){\n        l = m;\n      }else{\n        r = m;\n      }\n    }\n    ll xx = aa.qmin(l+1,n) - 2ll*x[i];\n    ll yy = bb.qmin(0,l+1);\n    dp[i] = min(xx,yy);\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <bitset>\n#include <cassert>\n\nusing namespace std;\n\nint x[100009];\nlong long f[100009];\nconst long long INF = 1000000000000000000;\n\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    x[0] = 0;\n    f[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = INF;\n        for (int j = 1; j <= i; ++j) {\n            long long cur = f[j - 1] + x[j] - x[j - 1];\n            long long curt = x[i] - x[j];\n            cur += 2 * curt;\n            if (t <= 2 * curt) {\n                cur += curt;\n            } else {\n                cur += curt + (t - 2 * curt);\n            }\n            f[i] = min(f[i], cur);\n        }\n    }\n    long long ans = f[n] + e - x[n];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = x[i] - x[j + 1] + f[j];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\tfor (int j = max(0, i - 1000); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\n\nconst int MAXN = 1e5+5;\n\nll n, dp[MAXN], x[MAXN], e, t, ct;\nset<pii> dp1, dp2;\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> x[i];\n\tx[n] = e;\n\n\tdp[0] = x[0];\n\tdp1.insert(pii(dp[0]-x[0], 0));\n\tfor (int j = 1; j <= n; ++j) {\n\t\tdp[j] = 1e18;\n\t\twhile (2*(x[j-1]-x[ct]) > t) {\n\t\t\tdp1.erase(pii(dp[ct]-x[ct], ct));\n\t\t\tdp2.insert(pii(dp[ct]-3*x[ct], ct));\n\t\t\t++ct;\n\t\t}\n\n\t\tif (!dp1.empty())\n\t\t\tdp[j] = min(dp[j], (*dp1.begin()).first+t+x[j]);\n\t\tif (!dp2.empty())\n\t\t\tdp[j] = min(dp[j], (*dp2.begin()).first+x[j]+2*x[j-1]);\n\t\tdp1.insert(pii(dp[j]-x[j], j));\n\t}\n\n\tcout << dp[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\n\ntemplate<typename F>struct NoOp{void setup(ui, F){}void op(F&p,F n,ui,ui){p=n;}void down(F&,F&,F&,ui,ui) {}};\n\ntemplate<typename F,typename SetOp,typename PowerOp>struct Lazy{\n    void setup(ui s,F def){this->def=def;this->s=s;L=new F[s]();fill(L,L+s,def);}\n    void down(F&u,F&l,F&r,ui i,ui s){op(l,L[i],i<<1,s>>1);op(r,L[i],i<<1|1,s>>1);L[i]=def;}\n    void op(F&p,F n,ui i,ui s){p=sop(p,pop(n,s));if(i<this->s)this->L[i]=sop(this->L[i],n);}\n    SetOp sop;PowerOp pop;F*L;ui s;F def;\n};\n\ntemplate <typename F, typename CombineOp, typename ModifyOp = NoOp<F>> struct SegTree {\n\tvoid setup(ui s, F def) {\n\t\tn = 1<<logceil(s);\n\t\tT = vector<F>(2*n, def);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tvoid setup(vector<F> & data, F def = F()) {\n\t\tn = 1<<logceil(data.size());\n\t\tT = vector<F>(2*n, def);\n\t\tcopy(data.begin(), data.end(), T.begin() + n);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tinline void put(ui x, F n) { put(x, x, n); }\n\tinline void put(ui from, ui to, F v) { put2(from, to+1, v, 1, n); }\n\tinline F get(ui x) { return get(x, x); }\n\tinline F get(ui from, ui to) { return get2(from, to+1, 1, n); }\n\n\tvoid put2(ui from, ui to, F v, ui i, ui s) {\n\t\tif (from == 0 && to == s) { mop.op(T[i], v, i, s); return; }\n\t\tmop.down(T[i], T[i<<1], T[i<<1|1], i, s);\n        s>>=1;i<<=1;\n        if (to <= s) { put2(from, to, v, i, s); }\n        else if (from >= s) { put2(from-s, to-s, v, i|1, s); }\n        else {\n            put2(from, s, v, i, s);\n            put2(0, to-s, v, i|1, s);\n        }\n\t\tT[i>>1] = cop(T[i], T[i|1]);\n\t}\n\n\tF get2(ui from, ui to, ui i, ui s) {\n        while (true) {\n            if (from == 0 && to == s) return T[i];\n            mop.down(T[i], T[i << 1], T[i << 1 | 1], i, s);\n            s >>= 1;i <<= 1;\n            if (to > s) {\n                to -= s;\n                if (from >= s) { from -= s; i|=1; }\n                else return cop(get2(from, s, i, s), get2(0, to, i|1, s));\n            }\n        }\n    }\n\n\tui n;\n\tvector<F> T;\n\tCombineOp cop;\n    ModifyOp mop;\n};\n\n\ntemplate <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};\ntemplate <typename F> struct MinOp { F operator()(F a, F b) { return std::min(a,b); }};\ntemplate <typename F> struct MaxOp { F operator()(F a, F b) { return std::max(a,b); }};\ntemplate <typename F> struct MultiplyOp { F operator()(F a, F b) { return a*b; }};\ntemplate <typename F> struct MultOp { F operator()(F a, ui b) { return a*b; }};\ntemplate <typename F> struct IdempOp { F operator()(F a, ui b) { return a; }};\ntemplate <typename F> struct InverseOp { F operator()(F a, F b) { return b?b-a:a; }};\n\ntemplate<typename T> using AddSumTree = SegTree<T, AddOp<T>, Lazy<T, AddOp<T>, MultOp<T>>>;\ntemplate<typename T> using AddMaxTree = SegTree<T, MaxOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AddMinTree = SegTree<T, MinOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMinTree = SegTree<T, MinOp<T>, Lazy<T, MinOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMaxTree = SegTree<T, MaxOp<T>, Lazy<T, MaxOp<T>, IdempOp<T>>>;\ntemplate<typename T> using XorTree = SegTree<T, AddOp<T>, Lazy<T, InverseOp<T>, MultOp<T>>>;\n\ntemplate<typename T> using SetMinTree = SegTree<T, MinOp<T>>;\ntemplate<typename T> using SetMaxTree = SegTree<T, MaxOp<T>>;\ntemplate<typename T> using SetMulTree = SegTree<T, MultiplyOp<T>>;\n\n\nclass DShikAndGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, E, T; cin >> N >> E >> T;\n        vector<int> X(N+1, 0);\n        for (int i = 0; i < N; ++i) cin >> X[i+1];\n        vector<ll> D(N+1, 0);\n        vector<ll> W(N+1, 1e18);\n        SetMinTree<ll> F, G;\n        F.setup(W, 0); G.setup(W, 0);\n        for (int i = 1; i <= N; ++i) {\n            F.put(i-1, D[i-1] - X[i-1] - 2 * X[i]);\n            G.put(i-1, D[i-1] - X[i-1]);\n            D[i] = 1e18;\n            int z = bsl(0, i-1, [&](int t) { return 2*(X[i] - X[t+1]) < T; });\n            if (z != i) D[i] = X[i] + T + G.get(z, i-1);\n            if (z != 0) D[i] = min(D[i], F.get(0, z-1) + 3 * X[i]);\n        }\n\n        cout << D[N] + E - X[N] << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDShikAndGame solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(int u, int l, int r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(int u, int l, int r, int x, int val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nint query(int u, int l, int r, int b, int e)\n{\n\tif (r == l)\n\t\treturn inf;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tint mid = (l + r) / 2, tmp = inf;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tsort(x, x + n);\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind ? dp[ind - 1] : 0));\n\t\tupdate(0, 0, n, i + 1, dp[i]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define LINF ((ll)1 << 60)\n#define INF (1 << 28)\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n        if (a < b) a = b;\n}\ntemplate<typename T>\nvoid chmin(T& a,T b) {\n        if (a > b) a = b;\n}\n//.....................\null mod = (int)1e9 + 7;\nconst int MAX = (int)2e5 + 5;\n\nint T = 1;\nll N, E, t;\nvector<ll> x;\nll dp[MAX];\n\nll min_time(int i) {\n        if (i == -1) return 0;\n        if (dp[i] > 0) return dp[i];\n        ll tmp = LINF;\n        for (int j = i - 1; j > -2; j--) {\n                chmin(tmp, min_time(j) + max(t, 2*(x[i] - x[j+1])));\n        }\n        return dp[i] = tmp;\n}\n\nvoid solve() {\n        cin >> N >> E >> t;\n        x.resize(N);\n        rep(i, N) cin >> x[i];\n        cout << E + min_time(N-1) << endl;\n}\n\nsigned main() {\n        cout << fixed << setprecision(20);\n        rep(i, T) {\n                solve();\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+5);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 100005;\nconst ll INF = ll(1e18);\n\nint n, l, t, x[N];\nll d[N];\n\nint main(){\n    scanf(\"%d%d%d\", &n, &l, &t);\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d\", x + i);\n        d[i] = INF;\n        for(int j = 0; j < i; j++){\n            d[i] = min(d[i], d[j] + max(2 * (x[i] - x[j + 1]), t) + x[i] - x[j]);\n        }\n    }\n    printf(\"%lld\\n\", d[n] + l - x[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll n,t,e;\nll ans;\nll xx[maxn];\ninline ll max(ll aa,ll bb){\n\tif (aa>bb)return aa;\n\telse return bb;\n}\nint main(){\n\tll b1,b2,b3,b4,b5;\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\txx[n+1]=e;\n\tans=xx[1];\n\tb1=1;\n\twhile (b1<=n){\n\t\tb2=b1;\n\t\tif ((b2+1<=n)&&((xx[b2+1]-xx[b2])<=t)){\n\t\t\tb2++;\n\t\t}\n\t\twhile ((b2+1<=n)&&((xx[b2+1]-xx[b2])*2<=t)){\n\t\t\tb2++;\n\t\t}\n\t\tans+=max((xx[b2]-xx[b1])*2,t)+(xx[b2+1]-xx[b1]);\n\t\tb1=b2+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint dp[100020];\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tfor(int i=0;i<=100010;i++)dp[i]=inf*1000000000ll;\n\t\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\tassert(n<3000);\n\tvector<int> ve(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tint d=ve[i]-ve[j];\n\t\t\tint c;\n\t\t\tif(2*d>=t)c=2*d;\n\t\t\telse c=t;\n\t\t\tif(j==0) dp[i]=min(dp[i],c);\n\t\t\telse dp[i]=min(dp[i],dp[j-1]+c);\n\t\t}\n\t//\tcout<<dp[i]<<endl;\n\t}\n\tcout<<e+dp[n-1]<<endl;\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 202000;const ll inf = 1e16;\nint n,a[N],T;ll f[N];\nint main() {\n\tread(n);read(a[n+1]);read(T);\n\trep(i,1,n)read(a[i]);\n\tper(i,n,1){\n\t\tf[i]=inf;rep(j,i+1,n+1)umin(f[i],f[j]+2*(a[j-1]-a[i])+a[j]-a[i]+max(0,T-2*(a[j-1]-a[i])));\n\t}\n\tcout<<f[1]+a[1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  const int N = 100000 + 10;\n  int n;\n  lli e, t;\n  while (cin >> n >> e >> t) {\n    lli x[N];\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i];\n    }\n    x[n] = e;\n\n    lli dp[N];\n    fill(dp, dp + N, 1LL << 60);\n    dp[0] = 0;\n\n    lli mn = 1LL << 60;\n    for (int i = 0, j = -1; i < n; ++i) {\n      while (t < 2 * (x[i] - x[j + 1])) {\n        mn = min(mn, dp[j] - 2 * x[j + 1]);\n        ++j;\n      }\n      dp[i] = min(dp[j] + t, 2 * x[i] + mn);\n    }\n    cout << dp[n - 1] + e << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvll v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tv.PB(INFL);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\tint it = 0;\n\tint it2 = 0;\n\trep(i,n-1){\n\t\twhile(it<n){\n\t\t\tif(v[it]>v[i]+T/2) break;\n\t\t\tit++;\n\t\t}\n\t\tmins(dp[min(it,n-1)],dp[i]+T);\n\t\twhile(it2<n){\n\t\t\tif(v[it2]>v[i]+T) break;\n\t\t\tit2++;\n\t\t}\n\t\tmins(it2, n-1);\n\t\tll t = dp[i]-2*v[i];\n\t\treep(j,it+1,it2+1){\n\t\t\tmins(dp[j], t+v[j-1]+v[j-1]);\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[1234567];\nint x[1234567];\nlong long const INF = 1LL << 60;\nint main() {\n  int n, ex, T;\n  scanf(\"%d%d%d\", &n, &ex, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n  for (int i = 0; i <= n; i++) {\n    dp[i] = INF;\n  }\n  dp[0] = 0;\n  x[0] = 0;\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = i + 1; j <= n; j++) {\n  //     long long first = dp[i] + x[i + 1] - x[i] + T;\n  //     long long last = dp[i] + x[j] - x[i];\n  //     long long back = last + x[j] - x[i + 1];\n  //     back = std::max(back, first);\n  //     last = back + x[j] - x[i + 1];\n  //     dp[j] = std::min(dp[j], last);\n  //   }\n  // }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      dp[j] = std::min(dp[j], std::max(2 * (x[j] - x[i + 1]), T) + x[j] - x[i] + dp[i]);\n    }\n  }\n  // for (int i = 0; i < n; i++) {\n  //   long long end = (long long) i * T + x[n - 1];\n  //   long long next = std::max(end + x[n - 1] - x[i], x[i] + (long long) (i + 1) * T);\n  //   ans = std::min(ans, next + ex - x[i]);\n  // }\n  printf(\"%lld\\n\", ex - x[n] + dp[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define LL long long\nusing namespace std;\nmultiset<LL> s1, s2;\nLL dp[110000], dp2[110000];\nint x[110000], n, E, T;\nint main(){\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tdp2[0] = T;s1.insert(T);\n\tfor(int i = 1, j = 0; i <= n; i++){\n\t\tscanf(\"%d\", &x[i]);\n\t\twhile(j < i && 2 * (x[i] - x[j + 1]) >= T){\n\t\t\ts1.erase(s1.find(dp2[j]));\n\t\t\tdp2[j] = dp2[j] - T - 2 * (x[j + 1]);\n\t\t\ts2.insert(dp2[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp2[i] = (((LL)1)<<50);\n\t\tif(!s1.empty()) dp[i] = min(dp[i], *s1.begin() + x[i]);\n\t\tif(!s2.empty()) dp[i] = min(dp[i], *s2.begin() + (LL)3 * x[i]);\n\t\tdp2[i] = dp[i] - x[i] + T; \n\t\ts1.insert(dp2[i]);\n\t}\n\tcout<<dp[n] - x[n] + E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n#define int long long\nconst int N = (int) 1e5 + 5, mod = (int) 0;\nint a[N], dp[N];\nset<pair<int, int>> x, y;\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, e, t;\n    cin >> n >> e >> t;\n    a[n] = e;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    dp[0] = a[0];\n//    dp[1] = a[0] + t + a[1] - a[0];\n    int p = 0;\n    y.insert(make_pair(dp[0] - 2 * a[0] + t, 0));\n//    y.insert(make_pair(dp[1] - 2 * a[1] + t, 1));\n    for (int i = 0; i < n; ++i) {\n        while (p < i + 1 && (a[i] - a[p]) * 2 > t) {\n            y.erase(make_pair(dp[p] - 2 * a[p] + t, p));\n            x.insert(make_pair(dp[p] - 3 * a[p], p));\n            p++;\n        }\n        dp[i + 1] = 1e18;\n        if ((int) x.size()) {\n            auto d = *(x.begin());\n            dp[i + 1] = min(dp[i + 1], a[i + 1] - a[i] + 3 * a[i] + d.first);\n        }\n        if ((int) y.size()) {\n            auto d = *(y.begin());\n            dp[i + 1] = min(dp[i + 1], a[i + 1] - a[i] + 2 * a[i] + d.first);\n        }\n        //cout << i + 1 << ' ' << dp[i + 1] << endl;\n        y.insert(make_pair(dp[i + 1] - 2 * a[i + 1] + t, i + 1));\n    }\n    cout << dp[n] << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n\n  vector< T > seg;\n  int sz;\n\n  SegmentTree(int n) : INF(numeric_limits< T >::max())\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  int64 N, T, E, X[2002];\n\n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n\n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n*/\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n\n  /*\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]+X[i]*2-X[j+1]*2\n   // dp2[j]=dp[j]-X[j+1]*2\n  */\n\n\n  int64 dp[200002];\n  fill_n(dp, 200002, INF);\n  SegmentTree< int64 > dp2(N + 1);\n\n  dp[0] = 0;\n  dp[1] = E;\n  dp2.update(0, dp[0] - X[1] * 2);\n  dp2.update(1, dp[1] - X[2] * 2);\n\n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while(high - low > 0) {\n      int mid = (low + high) >> 1;\n      if((X[i] - X[mid + 1]) * 2 <= E) high = mid;\n      else low = mid + 1;\n    }\n/*\n    cout << (X[i] - X[low + 1]) * 2 << \" \" << E << endl;\n\n    for(int k = low; k < i; k++) cout << dp[k] << \" \";\n    cout << endl;\n*/\n    dp[i] = min(dp[low] + E, X[i] * 2 + dp2.rmq(0, low));\n    //cout << low << endl;\n    dp2.update(i, dp[i] - X[i + 1] * 2);\n  }\n  cout << dp[N] + T << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nlong long mn=4e18;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[st+1])>t)\n\t\t{\n\t\t\tmn=min(mn,dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=min(dp[i-1]+x[i]-x[i-1]+t,mn+3LL*x[i]);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n\n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n            now++;\n        mn=min(mn,dp[now]-2*a[now+1]);\n        if(now<i)\n            dp[i]=min(dp[i],dp[now]+t);\n        dp[i]=min(dp[i],mn+2*a[i]);\n\n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nconst int maxn = 1e5 + 5;\nll dp[maxn];\nll pre1[maxn];\nll x[maxn];\n\nint n;\nll T, E;\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> E >> T;\n    for(int i = 1;i <= n;i++){\n        cin >> x[i];\n    }\n    dp[0] = 0;\n    pre1[0] = dp[0] - 2 * x[1];\n    int l = -1;\n    for(int i = 1;i <= n;i++){\n        while(l + 1 < i and 2 * (x[i] - x[l + 2]) >= T){\n            l++;\n        }\n        dp[i] = 1e18;\n        if(l >= 0)\n            dp[i] = pre1[l] + 2 * x[i];\n        if(l + 1 < i){\n            dp[i] = min(dp[i], dp[l + 1] + T);\n        }\n        pre1[i] = pre1[i - 1];\n        pre1[i] = min(pre1[i - 1], dp[i] - 2 * x[i + 1]);\n    }\n    cout << E + dp[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nconst int mn = 1 << 17;\nll dp[mn],x[mn];\nint n, nn; ll dat[2][mn];\nvoid init() {\n\tnn = 1;\n\twhile (nn < n)nn *= 2;\n\trep(i, 2 * nn - 1)dat[0][i] = dat[1][i] = INF;\n}\nvoid update(int id, int k, ll a) {\n\tk += nn - 1;\n\tdat[id][k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[id][k] = min(dat[id][k * 2 + 1], dat[id][k * 2 + 2]);\n\t}\n}\nll query(int id,int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[id][k];\n\telse {\n\t\tll vl = query(id, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(id, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tcin >> n; n++;\n\tinit();\n\tll e, t; cin >> t >> e;\n\trep(i, n-1) {\n\t\tcin >> x[i];\n\t}\n\tx[n-1] = t;\n\tfill(dp, dp + n + 2, INF);\n\tdp[0] = x[0];\n\tupdate(0, 0, 0);\n\tupdate(1, 0, -2*x[0]);\n\trep1(i, n-1) {\n\t\tint loc = lower_bound(x, x + n, x[i-1] - e / 2) - x;\n\t\tll mi1 = query(1, 0, loc, 0, 0, nn) + x[i] + 2*x[i - 1];\n\t\tll mi2 = query(0, loc, i, 0, 0, nn) + e + x[i];\n\t\tdp[i] = min(mi1, mi2);\n\t\tupdate(0, i, dp[i] - x[i]);\n\t\tupdate(1, i, dp[i] - 3 * x[i]);\n\t}\n\tcout << dp[n-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nint main(){\n\tll n,e,t;\n\tcin>>n>>e>>t;\n\tif(n>3000)return -1;\n\tvi in(n+1);\n\trep(i,n)cin>>in[i+1];\n\tvi dp(n+1,inf);\n\tdp[0]=0;\n\trep(i,n)rep(j,i+1){\n\t\tll sum=dp[j]+in[j+1]-in[j];\n\t\tsum+=max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];\n\t\tdp[i+1]=min<ll>(dp[i+1],sum);\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=100010;\nint n,t,e,x[nMax];\nlong long time[nMax];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tsort(x+1,x+1+n);\n\tint last=1;\n\tlong long ans=time[1]=x[1];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(ans+2*(x[i+1]-x[i])+x[i]-x[last]<=time[last]+t)\n\t\t\ttime[i+1]=ans=ans+x[i+1]-x[i];\n\t\telse\n\t\t{\n\t\t\tlong long v1=max((time[last]+t)-(ans+x[i]-x[last]),(long long)0);\n\t\t\tv1+=(long long)2*(x[i]-x[last])+x[i+1]-x[i]+t;\n\t\t\tlong long v2=(long long)3*(x[i+1]-x[i])+(long long)2*(x[i]-x[last]);\n\t\t\tif(v1<=v2)\n\t\t\t{\n\t\t\t\ttime[i+1]=ans=ans+v1-t;\n\t\t\t\tlast=i+1;\n\t\t\t} else\n\t\t\t\ttime[i+1]=ans=ans+x[i+1]-x[i];\n\t\t}\n\t}\n\tans+=max((time[last]+t)-(ans+x[n]-x[last]),(long long)0)+(long long)2*(x[n]-x[last])+e-x[n];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T + (a[i] - a[opt]);\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\twhile(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) < cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tdp[i] = cost(i , opt);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define xx first\n#define yy second\n#define i64 long long int\n#define MEM(a,x) memset(a,x,sizeof(x))\n#define INF 1000000000\n#define mod 998244353\n\nusing namespace std ;\n\n#define maxn 1000005\n\ni64 x[maxn] , mn[maxn] , dp[maxn] ;\ndeque< pair<i64,i64> > dq ;\n\nint main()\n{\n    i64 i , j , k , l , n , m , e , t ;\n\n    scanf(\"%lld %lld %lld\",&n,&e,&t) ;\n    for(i=1; i<=n ; i++) scanf(\"%lld\",&x[i]) ;\n\n    x[0] = 0 ; x[n+1] = e ;\n\n    dp[0] = 0 ;\n    mn[0] = -x[0]-2*x[1] + dp[0] ;\n    dq.push_front( mp(0,0) ) ;\n\n    i64 last = 0 ;\n\n    for(i=1 ; i<=n ; i++)\n    {\n        while( last < i && 2*(x[i]-x[last+1]) > t )\n        {\n            if( !dq.empty() && dq.back().yy==last ) dq.pop_back() ;\n            last++ ;\n        }\n        dp[i] = dp[i-1] + x[i]-x[i-1] + t ;\n        if(last>0) dp[i] = min( dp[i] , 3*x[i] + mn[last-1] ) ;\n        if( !dq.empty() ) dp[i] = min( dp[i] , x[i]+dq.back().xx+t ) ;\n\n        mn[i] = min( mn[i-1] , dp[1]-x[1]-2*x[i+1] ) ;\n\n        while( !dq.empty() && dq.front().xx >= dp[i]-x[i] ) dq.pop_front() ;\n        dq.push_front( mp( dp[i]-x[i],i ) ) ;\n    }\n\n  //  for(i=1 ; i<=n ; i++) printf(\"%lld\\n\",dp[i]) ;\n\n    printf(\"%lld\\n\",dp[n]+x[n+1]-x[n]) ;\n\n    return 0 ;\n}\n/*\n4 20 3\n3 5 14 19\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Debug(x) cout<<#x<<\"=\"<<(x)<<endl;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL inf = 1LL << 61;\nconst LL mod = 1000000007;\nconst int max_n = 100010;\n\n\nint n;\nLL T, E;\nLL dp[max_n], d[max_n];\nint main()\n{\n    int i = 0, j = 0, k = 0;\n    Fill(d, 0);\n    Fill(dp, 0);\n    scanf(\"%d %I64d %I64d\", &n,&E,&T);\n    for(i = 1; i <= n; i++)\n    {\n        scanf(\"%I64d\", d+i);\n    }\n    dp[1] = d[1]+T;\n    LL ans;\n    for(i = 2; i <= n; i++)\n    {\n        dp[i] = dp[i-1]+d[i]-d[i-1]+T;\n        for(j = i-1; j >= 1; j--)\n        {\n            if(T<=2*(d[i]-d[j]))\n            {\n                ans = dp[j-1]+d[i]-d[j-1]+2*(d[i]-d[j]);\n            }\n            else\n            {\n                ans = dp[j-1]+d[i]-d[j-1]+T;\n            }\n            dp[i] = min(dp[i], ans);\n        }\n    }\n    /*\n    for(i = 1; i <= n; i++)\n    {\n        cout << dp[i] << \" \";\n    }\n    cout << endl;\n    */\n    ans = dp[n]+E-d[n];\n    printf(\"%I64d\\n\", ans);\n\n\n    return 0;\n}\n/*\n5 8 4\n1 3 4 6 7\n*/\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100000 + 10;\nconst long long oo = 0x3f3f3f3f3f3f3f3fll;\n\nstruct Node {\n\tlong long flag;\n\tNode *ls, *rs;\n}pool[N*4], *tail=pool, *root[2];\n\nint n, e, t;\nlong long xx[N];\nlong long dp[N];\n\nNode *build( int lf, int rg ) {\n\tNode *nd = ++tail;\n\tnd->flag = oo;\n\tif( lf < rg ) {\n\t\tint mid = (lf + rg) >> 1;\n\t\tnd->ls = build( lf, mid );\n\t\tnd->rs = build( mid+1, rg );\n\t}\n\treturn nd;\n}\nlong long query( Node *nd, int lf, int rg, int pos ) {\n\tif( lf == rg ) return nd->flag;\n\tint mid = (lf + rg) >> 1;\n\tif( pos <= mid )\n\t\treturn min( query(nd->ls,lf,mid,pos), nd->flag );\n\telse\n\t\treturn min( query(nd->rs,mid+1,rg,pos), nd->flag );\n}\nvoid modify( Node *nd, int lf, int rg, int L, int R, long long val ) {\n\tif( L <= lf && rg <= R ) {\n\t\tnd->flag = min( nd->flag, val );\n\t\treturn;\n\t}\n\tint mid = (lf + rg) >> 1;\n\tif( L <= mid ) modify( nd->ls, lf, mid, L, R, val );\n\tif( R > mid ) modify( nd->rs, mid+1, rg, L, R, val );\n}\ninline long long cdp( int i ) {\n\tlong long v0 = query(root[0],0,n,i);\n\tlong long v1 = query(root[1],0,n,i);\n//\tprintf( \"%d v0 = %lld v1 = %lld\\n\", i, v0, v1 );\n\treturn min( v0 + xx[i], v1 + xx[i] * 3 );\n}\nint main() {\n\tscanf( \"%d%d%d\", &n, &e, &t );\n\tfor( int i = 1; i <= n; i++ ) \n\t\tscanf( \"%lld\", xx + i );\n\txx[0] = 0;\n\troot[0] = build( 0, n );\n\troot[1] = build( 0, n );\n\tmodify( root[0], 0, n, 0, 0, -xx[0] );\n\tfor( int i = 0; i < n; i++ ) {\n\t\tdp[i] = cdp(i);\n//\t\tprintf( \"dp[%d] = %lld\\n\", i, dp[i] );\n\t\tint j;\n\t\tint lf = i + 1, rg = n;\n\t\twhile( lf < rg ) {\n\t\t\tint mid = (lf + rg + 1) >> 1;\n\t\t\tif( (xx[mid]<<1) <= (xx[i+1]<<1) + t )\n\t\t\t\tlf = mid;\n\t\t\telse\n\t\t\t\trg = mid - 1;\n\t\t}\n\t\tj = lf;\n\n\t\tif( i + 1 <= j ) modify( root[0], 0, n, i + 1, j, t - xx[i] + dp[i] );\n\t\tif( j + 1 <= n ) modify( root[1], 0, n, j + 1, n, dp[i] - (xx[i+1]<<1) - xx[i] );\n\t}\n\tdp[n] = cdp(n);\n\tlong long ans = dp[n] + e - xx[n];\n\tprintf( \"%lld\\n\", ans );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//dp[i]=min(dp[j]+max(T,(s[i]-s[j+1])*2)+(s[i]-s[j]));\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nconst long long inf=1LL<<60;\nint s[maxn];\nint n,E,T;\nint head,tail,que[maxn];\nlong long dp[maxn];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&s[i]);\n    head=1,tail=0;\n    que[++tail]=0;\n    for(int i=1;i<=n;i++)\n    {\n        long long tmp=inf;\n        while(head<=tail&&2*(s[i]-s[que[head]+1])>T)tmp=min(tmp,dp[que[head]]-2*s[que[head]+1]),head++;\n        dp[i]=min(dp[que[head]]+T,tmp+2*s[i]);\n        que[++tail]=i;\n    }\n    printf(\"%lld\\n\",dp[n]+E);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class Monoid, class OperatorMonoid, class FunctionM, class FunctionMO, class FunctionO>\nstruct LazySegmentTree {\n    int N; vector<Monoid> segment; vector<OperatorMonoid> lazy;\n    const FunctionM FuncM; const FunctionMO FuncMO; const FunctionO FuncO;\n    const Monoid idM; const OperatorMonoid idOM;\n\n    LazySegmentTree(int n, const FunctionM FuncM, const FunctionMO FuncMO, const FunctionO FuncO,\n        const Monoid idM, const OperatorMonoid idOM)\n    : FuncM(FuncM), FuncMO(FuncMO), FuncO(FuncO), idM(idM), idOM(idOM) {\n        N = 1;\n        while (N < n) N <<= 1;\n        segment.assign(2 * N, idM); lazy.assign(2 * N, idOM);\n    }\n\n    LazySegmentTree(int n, const FunctionM FuncM, const FunctionMO FuncMO, const FunctionO FuncO,\n        const Monoid idM, const OperatorMonoid idOM, const Monoid initVal)\n    : FuncM(FuncM), FuncMO(FuncMO), FuncO(FuncO), idM(idM), idOM(idOM) {\n        N = 1;\n        while (N < n) N <<= 1;\n        segment.assign(2 * N, initVal); lazy.assign(2 * N, idOM);\n    }\n\n    void set(int num, Monoid x) {\n        segment[N + num] = x;\n    }\n    void build() {\n        for (int k = N - 1; k > 0; k--) {\n            segment[k] = FuncM(segment[2*k], segment[2*k+1]);\n        }\n    }\n\n    inline void propagate(int k, int len){\n        if (lazy[k] != idOM) {\n            if (k < N) {\n                lazy[2*k] = FuncO(lazy[2*k], lazy[k]);\n                lazy[2*k+1] = FuncO(lazy[2*k+1], lazy[k]);\n            }\n            segment[k] = FuncMO(segment[k], lazy[k], len);\n            lazy[k] = idOM;\n        }\n    }\n\n    // update:[a, b)\n    Monoid update(int a, int b, const OperatorMonoid x) {\n        return update(a, b, x, 1, 0, N);\n    }\n    Monoid update(int a, int b, const OperatorMonoid x, int k, int l, int r){\n        propagate(k, r-l);\n        if (b <= l || r <= a) {\n            return segment[k];\n        } else if (a <= l && r <= b) {\n            lazy[k] = FuncO(lazy[k], x);\n            propagate(k, r-l);\n            return segment[k];\n        } else {\n            int m = (l + r) / 2;\n            return segment[k] = FuncM(update(a, b, x, 2*k, l, m), update(a, b, x, 2*k+1, m, r));\n        }\n    }\n\n    // query:[a, b)\n    Monoid query(int a, int b) {\n        return query(a, b, 1, 0, N);\n    }\n    Monoid query(int a, int b, int k, int l, int r) {\n        propagate(k, r-l);\n        if (b <= l || r <= a) {\n            return idM;\n        } else if (a <= l && r <= b) {\n            return segment[k];\n        } else {\n            int m = (l + r) / 2;\n            return FuncM(query(a, b, 2*k, l, m), query(a, b, 2*k+1, m, r));\n        }\n    }\n\n    // 0-indexed numbering;\n    inline Monoid operator[](const int &k) {\n        return query(k, k + 1);\n    }\n};\n\nauto F = [&](long long a, long long b) {return min(a, b);};\nauto G = [&](long long a, long long b, int len) {return a + b;};\nauto H = [&](long long a, long long b) {return a + b;};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, e, t; cin >> n >> e >> t;\n    vector<int> x(n+2, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i+1]; x[i+1] *= 2;\n    }\n    x[n+1] = 2 * e;\n    LazySegmentTree<long long, long long, decltype(F), decltype(G), decltype(H)> dp(n + 1, F, G, H, 1e16, 0);\n    LazySegmentTree<long long, long long, decltype(F), decltype(G), decltype(H)> lst(n + 1, F, G, H, 1e16, 0);\n    for (int i = 0; i <= n; i++) lst.set(i, 0), dp.set(i, 0);\n    dp.set(0, -x[1]);\n    lst.build(); dp.build();\n    int lf = 0;\n    for (int i = 0; i < n; i++) {\n        int d = (x[i+1] - x[i]) / 2;\n        lst.update(0, i+1, d);\n        dp.update(0, i+1, d);\n        int c = lower_bound(x.begin(), x.end(), x[i+1]-t) - x.begin();\n        long long p = dp.query(0, c-1);\n        long long q = lst.query(c-1, i+1);\n        auto w = min(p+x[i+1], q+t);\n        dp.update(i+1, i+2, w-x[i+2]);\n        lst.update(i+1, i+2, w);\n    }\n    cout << lst[n] + (e - x[n] / 2) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct BIT{\n  vector<int> bit;\n  int n;\n  //1-indexed\n  BIT(){init(-1);}\n  BIT(int n_){init(n_);}\n  void init(int n_){\n    n=n_;\n    bit.clear();\n    bit.resize(n+1,0);\n  }\n  int sum(int i){\n    int s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(int i,int x){\n    if(i==0) return;\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n  int sum0(int i){\n    return sum(i+1);\n  }\n  void add0(int i,int x){\n    add(i+1,x);\n  }\n};\n\nstruct StarrySky{\n  int n;\n  const int def=1LL<<55LL;\n  vector<int> datm,data;\n  StarrySky(){}\n  StarrySky(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    datm.clear();\n    datm.resize(n*2-1,def);\n    data.clear();\n    data.resize(n*2-1,0);\n  }\n  void add(int a,int b,int x,int k,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      data[k]+=x;\n      return;\n    }\n    add(a,b,x,k*2+1,l,(l+r)/2);\n    add(a,b,x,k*2+2,(l+r)/2,r);\n    datm[k]=min(datm[k*2+1]+data[k*2+1],\n\t\tdatm[k*2+2]+data[k*2+2]);\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return datm[k]+data[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr)+data[k];\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,0,n);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\nsigned main(){\n  int n,e,t;\n  cin>>n>>e>>t;\n  int x[n+1];\n  for(int i=0;i<n;i++) cin>>x[i];\n  x[n]=e;\n  \n  int dp[n+1];\n  int INF=1LL<<55LL;\n  fill_n(dp,n+1,INF);\n  dp[0]=x[0];\n\n  BIT bit(n+1);\n  StarrySky ss(n+1);\n  \n  for(int i=0;i<n;i++){\n    bit.add0(i,-x[i]*2);\n    bit.add0(i+1,x[i]*2);\n  }\n  ss.add(0,1,t-ss.def);\n  int k=0,pre=0;\n  for(int j=0;j<n;j++){\n    bit.add0(0,2*(x[j]-pre));\n    ss.add(0,k,2*(x[j]-pre));\n    pre=x[j];\n    while(k<=j&&bit.sum0(k)>=t){\n      ss.add(k,k+1,bit.sum0(k)-t);\n      k++;\n    }\n    /*\n    cout<<\"bit\"<<endl;\n    for(int i=0;i<=n;i++)\n      cout<<i<<\":\"<<bit.sum0(i)<<endl;\n    cout<<endl;\n    cout<<\"ss\"<<endl;\n    for(int i=0;i<=n;i++)\n      cout<<i<<\":\"<<ss.query(i,i+1)<<endl;\n    cout<<endl;\n    */\n    \n    int res=ss.query(0,j+1);\n    dp[j+1]=res+x[j+1];\n    ss.add(j+1,j+2,(res+t)-ss.query(j+1,j+2));\n    /*\n    cout<<\"k:\"<<k<<endl;\n    cout<<\"res:\"<<res<<endl;\n    cout<<\"dp[j+1]:\"<<dp[j+1]<<endl;\n    cout<<j<<\":\"<<res<<endl;\n    cout<<\"----------\"<<endl;\n    */\n  }\n  cout<<dp[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\n \nconst int64 INF = 1LL << 58;\n \ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n \n  vector< T > seg;\n  int sz;\n \n  SegmentTree(int n) : INF(numeric_limits< T >::max() / 10)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n \n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n \n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n \n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n \n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n \n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n \n \nint main()\n{\n  int64 N, T, E, X[2002];\n \n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n \n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n*/\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n \n  /*\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]+X[i]*2-X[j+1]*2\n   // dp2[j]=dp[j]-X[j+1]*2\n  */\n \n \n  int64 dp[200002];\n  fill_n(dp, 200002, INF);\n  SegmentTree< int64 > dp2(N + 1);\n \n  dp[0] = 0;\n  dp[1] = E;\n  dp2.update(0, dp[0] - X[1] * 2);\n  dp2.update(1, dp[1] - X[2] * 2);\n \n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while(high - low > 0) {\n      int mid = (low + high) >> 1;\n      if((X[i] - X[mid + 1]) * 2 <= E) high = mid;\n      else low = mid + 1;\n    }\n/*\n    cout << (X[i] - X[low + 1]) * 2 << \" \" << E << endl;\n \n    for(int k = low; k < i; k++) cout << dp[k] << \" \";\n    cout << endl;\n*/\n    dp[i] = min(dp[low] + E, X[i] * 2 + dp2.rmq(0, low));\n    //cout << low << endl;\n    dp2.update(i, dp[i] - X[i + 1] * 2);\n  }\n  cout << dp[N] + T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<climits>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 100005\n#define M 10005\n#define INF 10000000000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint is_mul_overflow(ll a, ll b) {\n        return LLONG_MAX / a < b;\n}\n\nint x[N];\nll dp[N],a[4*N],b[4*N];\nint n,e,t;\nll get(int a,int b)\n{\n    ll d = x[b]-x[a];\n    return t>2LL*d?t+d:3LL*d;\n}\n\nvoid push_up(int rt)\n{\n    a[rt] = min(a[rt<<1],a[rt<<1|1]);\n    b[rt] = min(b[rt<<1],b[rt<<1|1]);\n}\nvoid build(int l,int r,int rt)\n{\n    a[rt] = b[rt] = INF;\n    if(l == r)return;\n    int mid = (l+r)>>1;\n    build(l,mid,rt<<1);\n    build(mid+1,r,rt<<1|1);\n}\n\nvoid update(int l,int r,int rt,int p,ll x,int f)\n{\n    //cout<<l<<\" \"<<r<<\" \"<<p<<\" \"<<x<<endl;\n    if(l == r)\n    {\n        if(f)a[rt] = min(a[rt],x);\n        else b[rt] = min(b[rt],x);\n        return;\n    }\n    int mid = (l+r)>>1;\n    if(p<=mid)update(l,mid,rt<<1,p,x,f);\n    else update(mid+1,r,rt<<1|1,p,x,f);\n    push_up(rt);\n}\nll query(int l,int r,int rt,int L,int R,int f)\n{\n    if(L>R)return INF;\n    if(L<=l&&R>=r)return f?a[rt]:b[rt];\n    int mid = (l+r)>>1;\n    ll ret = INF;\n    if(L<=mid)ret = min(ret,query(l,mid,rt<<1,L,min(mid,R),f));\n    if(R>mid)ret = min(ret,query(mid+1,r,rt<<1|1,max(L,mid+1),R,f));\n    return ret;\n}\nint get(int p)\n{\n    int l = 0,r = p;\n    while(l<r-1)\n    {\n        int mid = (l+r)>>1;\n        if(2*(x[p]-x[mid+1])>=t)l = mid;\n        else r = mid;\n    }\n    return l;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n>>e>>t)\n    {\n        FOR(i,1,n)cin>>x[i];\n        FOR(i,0,n)dp[i] = INF;\n        build(1,n,1);\n        x[0] = 0;\n        dp[0] = 0;\n        int down = t%2?(t+1)/2:t/2;\n        FOR(i,1,n)\n        {\n            int ps = get(i);\n            dp[i] = min(dp[i],t+x[i]+query(1,n,1,ps+1,i-1,1));\n            dp[i] = min(dp[i],3*x[i]+query(1,n,1,1,ps,0));\n            dp[i] = min(dp[i],x[1]-x[0]+get(1,i));\n            update(1,n,1,i,dp[i]-x[i],1);\n            update(1,n,1,i,dp[i]-2*x[i+1]-x[i],0);\n            //cout<<i<<\" \"<<dp[i]<<\" \"<<ps<<endl;\n        }\n        cout<<dp[n]+e-x[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \ntypedef pair<int,int> pii; \n\nconst int maxN = 1000 * 100 + 10; \nll a[maxN]; \nconst ll inf = 1e18; \nll dp[maxN]; \nset<pair<ll,int>> curr1, curr2; \n\nint main() { \n\tios::sync_with_stdio(false); cin.tie(0); \n\ta[0] = 0; \n\tint n,e,T; cin >> n >> e >> T;\n\tfor( int i = 0 ; i < n ; i++ ) cin >> a[i+1]; \n\n\tcurr1.insert( { inf , -1 } ) ; \n\tcurr2.insert( { inf , -1 } ) ; \n\tfill( dp , dp + n + 1 , inf ) ; \n\tdp[0] = 0; \n\tint last = 0; \n\tcurr1.insert( { 0ll - a[1] , 0 } ); \n\tfor( int i = 1 ; i <= n ; i++ ) { \n\t\twhile( last < i && 2ll * (a[i] - a[last+1]) >= T ) { \n\t\t\tcurr1.erase( { 0ll + dp[last] - a[last+1] , last } ) ; \n\t\t\tcurr2.insert( { 0ll + dp[last] - 2ll * a[last+1] , last } ); \n\t\t\tlast++; \n\t\t}\n\t\t//dp[i] = min( 0ll + curr1.begin()->first + 1ll * a[i] + T , \n\t\t//\t\t0ll + curr2.begin()->first + 2ll * a[i] ); \n\t\tfor( int j = 0 ; j < i ; j++ ) \n\t\t\tif( 2 * (a[i] - a[j+1]) >= T ) \n\t\t\t\tdp[i] = min( dp[i] , dp[j] + 2 * ( a[i] - a[j+1] ) ); \n\t\t\telse \n\t\t\t\tdp[i] = min( dp[i] , dp[j] + a[i] - a[j+1] + T ); \n\t\tcurr1.insert( { dp[i] - a[i+1] , i } ); \n\n\t\t//cout << i << \" \"<< dp[i] << endl;\n\t}\n\tcout << dp[n] + e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nmultiset<long long>s1,s2;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\ts2.insert(t);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(st+1<i && 2*(x[i]-x[st+1])>=t)\n\t\t{\n\t\t\ts2.erase(s2.find(dp[st]-x[st]+t));\n\t\t\ts1.insert(dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=4e18;\n\t\tif(s1.size())dp[i]=min(dp[i],(*s1.begin())+3LL*x[i]);\n\t\tif(s2.size())dp[i]=min(dp[i],x[i]+(*s2.begin())),\n\t\ts2.insert(dp[i]-x[i]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[100001];\t//1-indexed, x[0] = 0\nint dp[100001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値 - x[i], Xiのコインは既に回収済み\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 1; i <= n; i++) {\n\t\tint st = 0, ed = i, mid;\t\t//[st, ed), oooxxx\n\t\twhile (ed - st >= 2) {\n\t\t\tmid = (st + ed) / 2;\n\t\t\tif (2 * (x[i] - x[mid + 1]) > t) st = mid;\n\t\t\telse ed = mid;\n\t\t}\n\t\tdp[i] = min(dp[i], dp[st + 1] + t);\n\t\tdp[i] = min(dp[i], dp[st] + max(t, 2 * (x[i] - x[st + 1])));\n\t}\n\t\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nstruct segtree{\n\t#define s (1<<18)\n\tll seg[s];\n\tvoid init(){ rep(i,s) seg[i] = 1e17; }\n\tvoid update(int k,ll a){\n\t\tk+=s/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l || a>b) return 1e17;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n}rmq,rmq2;\n\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\trmq.init(); rmq2.init();\n\trmq.update(0,0);\n\trmq2.update(0,-2LL*x[1]);\n\tfor(int i=1;i<=n;i++){\n\t\tll dp = 1e17;\n\t\tint y = x[i] - t/2;\n\t\tint f = lower_bound(x+1,x+n+1,y)-x;\n\t\t//f..i-1\n\t\tdp = min(dp,1LL*t+rmq.query(max(0,f-1),i-1,0,0,(1<<17)-1));\n\t\tdp = min(dp,2LL*x[i]+rmq2.query(0,f-2,0,0,(1<<17)-1));\n\t\tif(i==n){\n\t\t\tcout<<dp+1LL*e<<endl; return 0;\n\t\t}\n\t\trmq.update(i,dp);\n\t\trmq2.update(i,dp-2LL*x[i+1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n \n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n \n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll x[111111];\nll dp[111111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll lmin=ll(1e18); \n\tdeque<pair<ll,ll> > rmin;\n\tint n; cin>>n; ll e,t; cin>>e>>t;\n\tif(n>3000){return 0;}\n\tx[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t}\n\tint ptr=1;\n\trmin.pb(mp(dp[0]-x[0]+t,1));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ptr<=i&&x[i]>=t/2+x[ptr]+1) //this means that we need to remove ptr from the \"T - 2(x_i - x_{j+1})\" is large part\n\t\t{\n\t\t\tif(!rmin.empty()&&rmin.front().se==ptr) rmin.pop_front();\n\t\t\tlmin = min(lmin, dp[ptr-1]-2*x[ptr]-x[ptr-1]);\n\t\t\tptr++;\n\t\t}\n\t\tll best=lmin;\n\t\tif(!rmin.empty()) best=min(best,-2*x[i]+rmin.front().fi);\n\t\tdp[i]=best+3LL*x[i];\n\t\tll cost = dp[i]-x[i]+t;\n\t\twhile(!rmin.empty()&&rmin.back().fi>=cost) rmin.pop_back();\n\t\trmin.pb(mp(cost,i+1));\n\t}\n\tcout<<dp[n]+e-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,e,t,x[200000];\nlong long dp[200000];\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=1ll<<40;\n\t\tfor(int j=0;j<i;j++)dp[i]=min(dp[i],dp[j]+x[i]-x[j]+max(t,(x[i]-x[j+1])<<1));\n\t}\n\t//for(int i=1;i<=n;i++)printf(\"DP %d = %lld\\n\",i,dp[i]);\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int maxn = 1e5 + 5;\nconst ll INF = 1e18;\n\nint n, e, t;\nint x[maxn];\nll dp[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tdp[0] = 0;\n\tREP(i, 1, n)\n\t\tscanf(\"%d\", x + i);\n\tll mn = INF;\n\tfor(int i = 1, j = 1; i <= n; ++i){\n\t\tif(2 * (x[i] - x[1]) <= t)\n\t\t\tdp[i] = t;\n\t\telse{\n\t\t\tmn = min(mn, -2ll * x[1]);\n\t\t\tfor(; 2 * (x[i] - x[j + 1]) > t; ++j){\n\t\t\t\tmn = min(mn, dp[j] - 2 * x[j + 1]);\n\t\t\t}\n\t\t\tdp[i] = mn + 2 * x[i];\n\t\t\tdp[i] = min(dp[i], dp[j] + t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAX 100100\n#define ll long long\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,E,T,x[MAX];\nll ans,f[MAX],mn=1e18;\nint main()\n{\n\tn=read();E=read();T=read();\n\tfor(int i=1;i<=n;++i)x[i]=read();\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tfor(int i=1,j=0;i<=n;++i)\n\t{\n\t\tfor(;T<=(x[i]-x[j+1])<<1;++j)mn=min(mn,f[j]-2*x[j+1]);\n\t\tif(j<i)f[i]=min(f[i],f[j]+T);\n\t\tf[i]=min(f[i],mn+2*x[i]);\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FILE \"chad\"\n#define ll long long\n#define up(i,j,k) for(int i=(j);i<=(k);i++)\n#define pii pair<int,int>\ntemplate<class T> bool cmin(T& a,T b){return a>b?a=b,true:false;}\ntemplate<class T> bool cmax(T& a,T b){return a<b?a=b,true:false;}\ntemplate<class T> T max(T& a,T& b){return a>b?a:b;}\ntemplate<class T> T min(T& a,T& b){return a<b?a:b;}\nconst int maxn=255000,inf=1e9,mod=9901;\nint read(){\n\tint ch=getchar(),x=0,f=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn f*x;\n}\nll n,e,t,a[maxn];\nll f[maxn],g[maxn];\nint main(){\n\t//freopen(FILE\".in\",\"r\",stdin);\n\t//freopen(FILE\".out\",\"w\",stdout);\n\tn=read(),e=read(),t=read();\n\tup(i,1,n)a[i]=read();\n\tmemset(f,10,sizeof(f));\n\tmemset(g,10,sizeof(g));\n\tf[1]=a[1];g[1]=a[1]+t;\n\tint w=1;\n\tup(i,2,n){\n\t\tf[i]=g[i-1]+a[i]-a[i-1];\n\t\twhile((a[i]-a[w+1])*2>=t)w++;\n\t\tif(((a[i]-a[w])<<1)>=t)\n\t\t\tcmin(g[i],f[w]+3*(a[i]-a[w]));\n\t\tcmin(g[i],f[i]+t);\n\t}\n\tprintf(\"%lld\\n\",g[n]+e-a[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 500010, inf = 1e9 + 233;\n\nint n, T, e;\nll p[maxn], f[maxn], mn[maxn];\nmultiset<ll>s;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &T);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &p[i]);\n\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0; s.insert(0); mn[0] = - 2 * p[1];\n\tint now = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (now < i && 2 * (p[i] - p[now + 1]) >= T) s.erase(f[now] - p[now]), now++;\n\t\t\n\t\tif (s.size()) f[i] = min(f[i], *s.begin() + p[i] + T);\n\t\tif (now) f[i] = min(f[i], mn[now - 1] + p[i] + 2 * p[i]);\n\t\ts.insert(f[i] - p[i]);\n\t\tmn[i] = min(mn[i - 1], f[i] - p[i] - 2 * p[i + 1]);\n\t\t\n\t\t\n\t\t\t\t\n\t\t/*for (int j = 0; j < i; j++)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + p[i] - p[j] + max((ll)T, 2 * (p[i] - p[j + 1])));\n\t\t\tprintf(\"i:%d j:%d f[i]:%d %d %d\\n\", i, j, f[i], T, 2 * (p[i] - p[j + 1]));\n\t\t}*/\n\t\t\n\t\t//printf(\"i:%d f[i]:%lld\\n\", i, f[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[n] + e - p[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define debug(a) cerr<<#a <<' '<< a <<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    VLL dp(n+1,LINF),x(n+1);\n    REP(i,n) cin >> x[i+1];\n    dp[0]=0;\n    dp[1]=t;\n    int l=0;\n    LL r=0;\n    FOR(i,2,n+1){\n        if(t<=2*(x[i]-x[l+1]))dp[i]=dp[l]+(x[i]-x[l+1])*2;\n        /*for(int j= l; j<i ; ++j){\n            if(dp[i]>dp[j]+max((LL)t,(x[i]-x[j+1])*2)){\n                dp[i]=min(dp[i],dp[j]+max((LL)t,(x[i]-x[j+1])*2));\n                l=j;\n            }\n            if(t>(x[i]-x[j+1])*2){\n                break;\n            }\n        }*/\n        //debug(l)\n        //debug(dp[i])\n        for(int j=r ; j<i ; ++j){\n            r=j;\n            if(t>(x[i]-x[j+1])*2){\n                dp[i]=min(dp[i],dp[r]+t);\n                break;\n            }\n        }\n\n        //debug(r)\n        if(dp[l]+(x[i]-x[l+1])*2>dp[i-1]) l=i-1;\n        //debug(dp[i])\n    }\n    cout << dp[n]+e<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii four_Dir[4] = {\n\t{ 0,-1 },{ -1 ,0 },{ 0 ,1 },\n\t{ 1 ,0 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tll n,e,t;\n\tscanf(\"%lld %lld %lld\", &n, &e, &t);\n\tvector<ll> bear(n);\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &bear[i]);\n\t}\n\tll time = 0;\n\tREP(i, n) {\n\t\tif (i == n - 1) {\n\t\t\ttime += t;\n\t\t}\n\t\trep(j, i + 1, n) {\n\t\t\tif ((bear[j] - bear[i])>t) {\n\t\t\t\ttime += max(2 * (bear[j - 1] - bear[i]), t);\n\t\t\t\ti = j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (j == n - 1) {\n\t\t\t\ttime += max(2 * (bear[j] - bear[i]), t);\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",time + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mxn=1e6+6;\nint n,E,T,w[mxn];\nll d[mxn];\nmultiset<ll>s1,s2;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint pv=1;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;++i)cin>>w[i];\n\tw[n+1]=E,d[1]=w[1];\n\tfor(int i=1;i<=n;++i){\n\t\tll r=1e15,tp;\n\t\ts2.insert(d[i]-w[i]);\n\t\tfor(;pv<=i and (w[i]-w[pv])*2>T;){\n\t\t\ts2.erase(s2.find(d[pv]-w[pv]));\n\t\t\ts1.insert(d[pv]-1ll*3*w[pv]);\n\t\t\t++pv;\n\t\t}\n\t\tif(!s1.empty()){\n\t\t\ttp=*s1.begin();\n\t\t\tif(r>tp+w[i]*3ll)r=tp+w[i]*3ll;\n\t\t}\n\t\ttp=*s2.begin();\n\t\tif(r>tp+w[i]+T)r=tp+w[i]+T;\n\t\td[i+1]=w[i+1]-w[i]+r;\n\t}\n\tcout<<d[n+1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nconst int nmax = 2000 * 1000;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nint n;\nll e, t, x[nmax], dp[nmax], ans[nmax];\nmultiset<ll> now, now1;\nvector<ll> dela[nmax];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &x[i]);\n\t}\n\tx[0] = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tdp[i] = infl;\n\t\tans[i] = infl;\n\t}\n\tdp[0] = 0;\n\tnow.insert(infl);\n\tnow1.insert(infl);\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (auto it : dela[i]) {\n\t\t\tnow1.erase(now1.find(it));\n\t\t}\n\t\tnow.insert(ans[i]);\n\t\tint id = lower_bound(x, x + n + 1, t / 2 + t % 2 + x[i + 1]) - x;\n\t\tdp[i] = min(dp[i], *now.begin() + 3 * x[i]);\n\t\tdp[i] = min(dp[i], *now1.begin() + x[i]);\n\t\tans[id] = min(ans[id], dp[i] - 2 * x[i + 1] - x[i]);\n\t\tdela[id].pb(dp[i] + t - x[i]);\n\t\tnow1.insert(dp[i] + t - x[i]);\n\t}\n\tcout << dp[n] + e - x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nstruct StarrySkyTree {\n  vector<ll> seg, lazy;\n  int size;\n  StarrySkyTree() {}\n  StarrySkyTree(int n) {\n    init(n);\n  }\n  void init(int n) {\n    size = 1;\n    while (size < n) size *= 2;\n    seg.resize(size * 2);\n    lazy.resize(size * 2);\n    for(ll i=0;i<size*2;i++)seg[i]=INF;\n  }\n  void update(int k,ll v){\n    k += size-1;\n    seg[k] = v;\n    while(k > 0){\n      k = (k - 1)/2;\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void push(int k, int l, int r) {\n    seg[k] += lazy[k];\n    if (r - l > 1) {\n      lazy[k * 2 + 1] += lazy[k];\n      lazy[k * 2 + 2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n  void add(int a, int b, ll v, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += v;\n      push(k, l, r);\n    } else {\n      add(a, b, v, k * 2 + 1, l, (l + r) / 2);\n      add(a, b, v, k * 2 + 2, (l + r) / 2, r);\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void add(int a, int b, ll v) {\n    add(a, b, v, 0, 0, size);\n  }\n  ll query(int a, int b, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return INF*100; // caution\n    if (a <= l && r <= b) return seg[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return min(vl,vr);\n  }\n  ll query(int a, int b) {\n    return query(a, b, 0, 0, size);\n  }\n};\n\nll n,T,E;\nll x[101010];\nset<P> st;\nStarrySkyTree dp,dp1,dp2;\n\nint main(){\n\tcin>>n>>E>>T;\n  rep(i,n)cin>>x[i];\n  rep(i,n)st.insert(P(-2*x[i],i));\n  x[n]=E;\n  dp.init(n+1); dp1.init(n+1); dp2.init(n+1);\n  rep(i,n+1){\n    dp.update(i,0); dp1.update(i,0); dp2.update(i,0);\n  }\n  dp.update(0,x[0]); dp1.update(0,x[0]-x[0]); dp2.update(0,x[0]-2*x[0]);\n  rep(i,n){\n    ll k;\n    if(st.lower_bound(P(-2*x[i]+T,-INF))==st.end())k=-1;\n    else k=st.lower_bound(P(-2*x[i]+T,-INF))->se;\n    k++;\n    ll crt=INF;\n    // [0,k)\n    minch(crt,dp2.query(0,k)+2*x[i]);\n    // [k,i+1)\n    minch(crt,dp1.query(k,i+1)+x[i]+T);\n    crt+=x[i+1]-x[i];\n    dp.add(i+1,i+2,crt); dp1.add(i+1,i+2,crt-x[i+1]); dp2.add(i+1,i+2,crt-2*x[i+1]);\n    dp.add(0,i+1,x[i+1]-x[i]); dp1.add(0,i+1,x[i+1]-x[i]); dp2.add(0,i+1,x[i+1]-x[i]);\n  }\n  cout<<dp.query(n,n+1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 1;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            ll need=A[i+1]-A[i];\n            ll dis=(A[j]-A[i+1])*3;\n            chmin(dp[j],dp[i]+need+max(T,dis));\n        }\n    }\n    \n    cout<<dp[N]+E-A[N]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 2010;\nll d[N];\nint n, t, e;\nint x[N];\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\td[0] = 0ll;\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tforn(i, n) {\n\t\tscanf(\"%d\", &x[i + 1]);\n\t}\t\n\tforn(i, n + 1) {\n\t\td[i] = (1ll << 60);\n\t}\n\td[0] = 0ll;\n\tforn(i, n) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tll wait = t - (2ll * x[j] - 2ll * x[i + 1]);\n\t\t\tumx(wait, 0ll);\n\t\t\tumn(d[j], d[i] + 3ll * (x[j] - x[i]) - 2ll * (x[i + 1] - x[i]) + wait);\n\t\t}\n\t}\n\tdebug(d, d + n + 1);\n\tcout << d[n] + e - x[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nclass FenwickTree{  // All entries must be >= 0 even after decrement\npublic:             // Every function is O(log n)\n  FenwickTree(int n) : N(n), iBM(1), tree(n,0) {\n    while (iBM < N) iBM *= 2;\n  }\n  \n  // inc/dec the entry at position idx by val\n  void incEntry(int idx, int val) {\n    do tree[idx] += val; while(idx && (idx += (idx & (-idx))) < N);\n  }\n  \n  // return the cumulative sum val[0] + val[1] + ... + val[idx]\n  int cumulativeSum(int idx) const {\n    int sum = tree[0];\n    for( ; idx > 0 ; idx &= idx-1) sum += tree[idx];\n    return sum;\n  }\n  \nprivate:\n  int N, iBM; vector<int> tree;\n};\n\nll A[MAX_N];\nll N,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> N >> E >> T;\n  \n  for(int i=0;i<N;i++) cin >> A[i];\n  \n  vector<pair<ll,int> > d;\n  for(int i=1;i<N;i++)\n    d.emplace_back(A[i]-A[i-1],i-1);\n  \n  sort(d.rbegin(),d.rend());\n  \n  vector<pair<int,int> > ints;\n  ints.emplace_back(0ll,N-1);\n  \n  FenwickTree F(N+1);\n  \n  ll ans = E + f(A[N-1]-A[0]);\n  \n  ll best = ans;\n  \n  for(int i=0;i<N-1;i++){\n    int idx = d[i].second;\n    int where = F.cumulativeSum(idx);\n    \n    int len = A[ints[where].second] - A[ints[where].first];\n    ans -= f(len);\n    \n    ints.emplace_back(idx+1,ints[where].second);\n    ints[where].second = idx;\n    F.incEntry(idx+1,(int)ints.size()-1-where);\n    F.incEntry(ints.back().second+1,where+1-(int)ints.size());\n    \n    ans += f(A[ints[where].second]-A[ints[where].first]) + f(A[ints.back().second] - A[ints.back().first]);\n    if(best > ans) best = ans;\n    //cout << ans << \" \" << best << endl;\n  }\n  cout << best << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ninline void gtmn(LL &a,LL b){\n\tif (a>b) a=b;\n}\ninline void gtmx(LL &a,LL b){\n\tif (a<b) a=b;\n}\nint a[100010];\nLL coef[100010];\nLL dp[100010];\nint main(void){\n\tmemset(coef,255,sizeof(coef));\n\tmemset(dp,127,sizeof(dp));\n\tdp[0]=0;\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\ta[0]=0;\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (i) gtmx(coef[i],coef[i-1]);\n\t\tif (~coef[i]){\n\t\t\tgtmn(dp[i],3ll*a[i]-coef[i]);\n\t\t}\n\t\tgtmn(dp[i+1],dp[i]+a[i+1]-a[i]+t);\n\t\tint l=i+1,r=n+1;\n\t\twhile(l+1<r){\n\t\t\tint md=(l+r)>>1;\n\t\t\tif (((a[md]-a[i+1])<<1)<=t){\n\t\t\t\tl=md;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=md;\n\t\t\t}\n\t\t}\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t\t++l;\n\t\tif (l<=n){\n\t\t\tgtmx(coef[l],3ll*a[i]-dp[i]-a[i+1]+a[i]);\n\t\t}\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\",dp[n]+e-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define X first\n#define Y second\nusing namespace std;\nconst int max_n = 1e6 + 20, inf = 1e12;\nint a[max_n], DP[max_n];\npair<int, int> seg[max_n * 4];\nint n, e, t, INF = 1e12, L;\npair<int, int> Merge(pii x, pii y) {\n    if (x.X < y.X)\n        return x;\n    return y;\n}\nvoid update(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg[id].X = val;\n        seg[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update(x, val, mid, e, id << 1 | 1);\n    else\n        update(x, val, b, mid, id << 1);\n    seg[id] = Merge(seg[id << 1 | 1], seg[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, 0};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get(l, r, b, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\nvoid out() {\n    for (int i = 1; i < n * 4; i++)\n        cout << seg[i].Y << \">>>>>\" << seg[i].X << \"   \";\n    cout << endl;\n}\nvoid solve() {\n    for (int i = 1; i < n; i++) {\n        int tmp = (lower_bound(a, a + n, a[i] - L) - a);\n        pii x = get(tmp, i), y = get(0, tmp);\n        //cout << tmp << endl;\n        DP[i] = min(x.X + t, y.X + 2 * (a[i] - a[y.Y])) + a[i];\n       // DP[i] = min(DP[i] , DP[i - 1] + a[i] - a[i - 1] + t);\n  //      cout << DP[i] << endl;\n        update(i, DP[i - 1] - a[i - 1]);\n      //  cout << endl;\n        //out();\n    }\n}\nint32_t main() {\n    cin >> n >> e >> t;\n    L = (t) / 2;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < n * 4; i++)\n        seg[i].X = inf;\n    DP[0] = a[0] + t;\n    update(0, 0);\n    solve();\n    cout << DP[n - 1] + (e - a[n - 1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\n \nconst int64 INF = 1LL << 58;\n \ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n \n  vector< T > seg;\n  int sz;\n \n  SegmentTree(int n) : INF(numeric_limits< T >::max() / 10)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n \n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n \n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n \n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n \n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n \n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n \n \nint main()\n{\n  int64 N, T, E, X[200002];\n \n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n \n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n*/\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n \n  /*\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]+X[i]*2-X[j+1]*2\n   // dp2[j]=dp[j]-X[j+1]*2\n  */\n \n \n  int64 dp[200002];\n  fill_n(dp, 200002, INF);\n  SegmentTree< int64 > dp2(N + 1);\n \n  dp[0] = 0;\n  dp[1] = E;\n  dp2.update(0, dp[0] - X[1] * 2);\n  dp2.update(1, dp[1] - X[2] * 2);\n \n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while(high - low > 0) {\n      int mid = (low + high) >> 1;\n      if((X[i] - X[mid + 1]) * 2 <= E) high = mid;\n      else low = mid + 1;\n    }\n/*\n    cout << (X[i] - X[low + 1]) * 2 << \" \" << E << endl;\n \n    for(int k = low; k < i; k++) cout << dp[k] << \" \";\n    cout << endl;\n*/\n    dp[i] = min(dp[low] + E, X[i] * 2 + dp2.rmq(0, low));\n    //cout << low << endl;\n    dp2.update(i, dp[i] - X[i + 1] * 2);\n  }\n  cout << dp[N] + T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nint main() {\n  scanf(\"%d%lld%lld\", &n, &E, &T);\n  if (n > 2000) return cout << \"Fuck You Atcoder!\\n\", 0;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j < i; ++j) {\n      dp[i] = min(dp[i], dp[j] + max(T, 2 * (a[i] - a[j + 1])));\n    }\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100020\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\nll f[N], x[N];\nint main(int argc, char const *argv[]) {\n  // freopen(\"D:/1_00.txt\", \"r\", stdin);\n\n  int n = read();\n  ll E = read(), T = read();\n\n  for (int i = 1; i <= n; ++ i) {\n    x[i] = read();\n  }\n\n  memset(f, 0x3f, sizeof f);\n  f[0] = 0;\n\n  ll mn = 1ll << 60;\n  for (int i = 1, j = 0; i <= n; ++ i) {\n    while (T <= 2 * (x[i] - x[j + 1])) {\n      mn = min(mn, f[j] - 2 * x[j + 1]);\n      ++ j;\n    }\n    f[i] = min(f[j] + T, mn + 2 * x[i]);\n  }\n\n  printf(\"%lld\\n\", f[n] + E);\n\n  return 0;\n}\n/*\n\n只有两种情况。\n\n          | wait T )\n----------+------------>\n0         A            B            E\n\n\n-----------------------.\n          .------------`\n          `--------------->\n0         A            B            E\n\ndp 计算需要多走多少时间即可。\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nlong long dp[N], x[N], premin[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, T;\n    cin>>n>>m>>T;\n    premin[0] = 1e18;\n\n    for (int i=1; i<=n; i++) {\n        cin>>x[i];\n        premin[i] = min(dp[i-1]-2*x[i], premin[i-1]);\n\n        int idx = upper_bound(x+1, x+i, x[i]-(T+1)/2)-x-1;\n        dp[i] = min(premin[idx]+2*x[i], dp[idx]+T);\n//        cout<<i<<\" \"<<x[i]<<\" --> \"<<dp[i-1]-2*x[i]<<\" \"<<premin[i]<<\" \\t \"<<x[i]-T/2<<\" \"<<idx<<\" \\t= \"<<dp[i]<<endl;\n\n    }\n    cout<<dp[n]+m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl;\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=1e5+10;\nint q[MAXN],l,r;\nll d[MAXN],dp[MAXN];int n,E,T;\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor(int i=1;i<=n;i++) \n\t\tscanf(\"%d\",&d[i]),dp[i]=1ll<<60;\n\tll mn=1ll<<60;l=r=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(l<=r&&2*(d[i]-d[q[l]+1])>T)\n\t\t\tmn=min(mn,dp[q[l]]-d[q[l]]-2*d[q[l]+1]),l++;\n\t\tdp[i]=min(dp[i],3*d[i]+mn);\n\t\tif(l<=r)dp[i]=min(dp[i],d[i]+T+dp[q[l]]-d[q[l]]);\n\t\t\n\t\twhile(l<=r&&dp[i]-d[i]<=dp[q[r]]-d[q[r]]) r--;\n\t\tq[++r]=i;\n\t}\n\tprintf(\"%lld\",dp[n]+E-d[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nll dp[SZ],qzm[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tif(n>2000) exit(-1);\n\tmemset(dp,127/3,sizeof(dp)); dp[0]=0;\n\tmemset(qzm,127/3,sizeof(qzm));\n\tint p=0; qzm[0]=dp[0]-2*x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile((x[i]-x[p+1])*2>t&&p<i) ++p;\n\t\t//for j>=p: (x[i]-x[j+1])*2<=t\n\t\tif(p<i) dp[i]=dp[p]+t;\n\t\tif(p) dp[i]=min(dp[i],qzm[p-1]+2*x[i]);\n\t\tqzm[i]=min(qzm[i-1],dp[i]-2*x[i+1]);\n\t}\n\tcout<<dp[n]+e<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(){\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> ps(n);\n\tfor(auto& x : ps) cin >> x;\n\n\tvector<ll> d(n, 0);\n\n\tll best_left = 1000000001;\n\tmultiset<ll> inner_best;\n\n\tauto get_dyn_minus_unu = [&](const ll x){\n\t\treturn x == 0 ? 0 : d[x-1]; };\n\n\tfor(ll i = 0, st = 0; i < n; ++i){\n\t\tif(i != 0) best_left += 2 * (ps[i] - ps[i-1]);\n\t\tinner_best.insert(get_dyn_minus_unu(i));\n\t\twhile(2 * (ps[i] - ps[st]) >= t){\n\t\t\tinner_best.erase(inner_best.find(get_dyn_minus_unu(st)));\n\t\t\tbest_left = min(best_left, 2 * (ps[i] - ps[st]) + get_dyn_minus_unu(st));\n\t\t\t++st; }\n\t\tll rez = best_left;\n\t\tif(!inner_best.empty()){\n\t\t\trez = min(rez, *begin(inner_best) + t); }\n\t\td[i] = rez; }\n\n\tcout << d.back() + e << endl;\n\treturn 0; }\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,S,t;\n    fi>>n>>S>>t;\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    static ll dp[1 << 20];\n    dp[0] = 0;\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = i - 1;j + 1;--j)\n                dp[i] = min(dp[i],dp[j] + s[i] - s[j] + 2ll * (s[i] - s[j + 1]) + max(0ll,1ll * t - 2 * (s[i] - s[j + 1])));\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define debug(a) cerr << #a << \": \" << a << endl\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n \n#define x first\n#define y second\n \nconst int N = 1e5 + 10;\n\nint n, e, t;\nint x[N];\nll dp[N];\nll suffix_min[N];\n\nint main() {\n\t#ifdef LOCAL\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\t#endif\n \n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n \n\tsuffix_min[n + 1] = 2 * x[n];\n\tdp[n] = t;\n\tsuffix_min[n] = min(suffix_min[n + 1], dp[n] + 2 * x[n - 1]);\n \n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tll &res = dp[i];\n\t\tint nxt = upper_bound(x + 1, x + n + 1, x[i] + t / 2) - x;\n \n\t\tif (nxt > n) res = t;\n\t\telse {\n\t\t\tres = dp[nxt] + t;\n\t\t\tres = min(res, suffix_min[nxt + 1] - 2 * x[i]);\n\t\t}\n \n\t\tsuffix_min[i] = min(suffix_min[i + 1], res + 2 * x[i - 1]);\n\t}\n \n\tcout << dp[1] + e << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\n\nvoid smain() {\n\n    int n,e,t;\n    cin>>n>>e>>t;\n    vi x(n);\n    for(int i=0;i<n;i++){\n        cin>>x[i];\n    }\n\n    int ans=x[0]+e-x[n-1];\n    for(int i=0;i<n;i++){\n        int j=i,cur=0;\n        while(j+1<n&&x[j+1]-x[j]<=t){\n            cur+=(x[j+1]-x[j]);\n            j++;\n        }\n        ans+=cur+max(2*cur,t);\n        if(j+1<n)\n            ans+=x[j+1]-x[j];\n        i=j;\n    }\n\n    cout<<ans;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n#include <bits/stdc++.h>\n//#include \"testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n\nbool debug=true;\n\n/*    *************************************\n\t  * Written in New Computer           *\n\t  * The following code belongs to     *\n\t  * XiaoGeNintendo of HellHoleStudios *\n\t  *************************************\n*/\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,pair<T1,T2> ptt){\n\tos<<ptt.first<<\",\"<<ptt.second;\n\treturn os;\n}\ntemplate<typename T>ostream& operator<<(ostream& os,vector<T> vt){\n\tos<<\"{\";\n\tfor(int i=0;i<vt.size();i++){\n\t\tos<<vt[i]<<\" \";\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll n,t,e;\nll dp[100005];\nll x[100005];\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n>>e>>t;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i];\n\t}\n\t\n\t//dp[i]=min{dp[j]+max{t,2*(x[i]-x[j])}}\n\t//dp[i]=min{dp[j]+2*(x[i]-x[j])} or dp[i]=min{dp[j]+t} <-easy\n\t//dp[i]=2*x[i]+min{dp[j]-2*x[j])} \n\tll last=0,mn=-2*x[0];\n\tfor(int i=0;i<n;i++){\n\t\tif(2*(x[i]-x[0])<=t){\n\t\t\tdp[i]=t;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\twhile(2*(x[i]-x[last+1])>t){\n\t\t\tmn=min(mn,dp[last]-2*x[last+1]);\n\t\t\tlast++;\n\t\t}\n\t\t\n\t\tdp[i]=min(mn+2*x[i],dp[last]+t);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int MAXN = 100005;\ntypedef long long ll;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nint t,e,n,d[MAXN];\nll c[MAXN],f[MAXN];\ninline void update(int x,ll v)\n{\n\tfor(;x<=n;x+=lowbit(x))\n\t\tc[x]=min(c[x],v);\n}\ninline ll query(int x)\n{\n\tx=max(0,x);\n\tll ret=INF;\n\tfor(;x;x-=lowbit(x))\n\t\tret=min(ret,c[x]);\n\treturn min(ret,(ll)-2*d[1]);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",d+i);\n\tint p=0;\n\tmemset(f,0x3f,sizeof(f));\n\tf[1]=t;\n\tfor(int i=2;i<=n;++i){\n\t\twhile(p+1<i && 2*(d[i]-d[p+2])>=t)++p;\n\t\tif(2*(d[i]-d[p+1])>=t)f[i]=min(f[i],query(p)+2*d[i]);\t\t\n\t\tf[i]=min(f[i],f[p+1]+t);\n\t\tupdate(i,f[i]-2*d[i+1]);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n,e,t;\nvi x;\nll dp[MX];\n\nll f(int i, int j) {\n  return dp[j] + max((x[j-1]-x[i])*2, t) + (x[j]-x[i]);\n}\n\nint main() {\n  scanf(\"%d%d%d\",&n,&e,&t);\n  x = vi(n);\n  rep(i,n) scanf(\"%d\",&x[i]);\n  x.pb(e);\n  int j = n;\n  drep(i,n) {\n    while (j > i+1) {\n      if (f(i,j) < f(i,j-1)) break;\n      j--;\n    }\n    dp[i] = f(i,j);\n    // cout<<i<<\" \"<<j<<\" \"<<f(i,j)<<endl;\n  }\n  cout<<(dp[0]+x[0])<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n       \n          A FAN OF FIZZYDAVID\n           \n*/\n \n#include<bits/stdc++.h>\n \n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-20\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define debug puts(\"OK\");\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n \nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n \ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n \ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n \ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n \n#ifdef ONLINE_JUDGE\n#else\n//#define DEBUG\n#endif\n \n//---------------------------head----------------------------\n \nconst int N=1e5+100;\n \nint n;\nLL T;\nLL dp[N],x[N];\n \nnamespace seg1//dp[j]+2*x[j-1]+x[j]\n{\n\tLL num[N<<2];\n\tinline int L(int i){ return i<<1; }\n\tinline int R(int i){ return (i<<1)|1; }\n\tinline void update(int i){ num[i]=min(num[L(i)],num[R(i)]); return; }\n\tinline void modify(int i,LL x,int l=1,int r=n,int k=1)\n\t{\n\t\tif(l==r){ num[k]=x; return; }\n\t\tint mid=l+r>>1;\n\t\tif(i<=mid) modify(i,x,l,mid,L(k));\n\t\telse modify(i,x,mid+1,r,R(k));\n\t\treturn update(k);\n\t}\n\tinline LL query(int a,int b,int l=1,int r=n,int k=1)\n\t{\n\t\tif(a==l && b==r) return num[k];\n\t\tint mid=l+r>>1;\n\t\tif(a>mid) return query(a,b,mid+1,r,R(k));\n\t\tif(b<=mid) return query(a,b,l,mid,L(k));\n\t\treturn min(query(a,mid,l,mid,L(k)),query(mid+1,b,mid+1,r,R(k)));\n\t}\n}\n \nnamespace seg2//dp[j]+T+x[j]\n{\n\tLL num[N<<2];\n\tinline int L(int i){ return i<<1; }\n\tinline int R(int i){ return (i<<1)|1; }\n\tinline void update(int i){ num[i]=min(num[L(i)],num[R(i)]); return; }\n\tinline void modify(int i,LL x,int l=1,int r=n,int k=1)\n\t{\n\t\t#ifdef DEBUG\n\t\tcout<<i<<' '<<x<<' '<<l<<' '<<r<<' '<<k<<endl;\n\t\t#endif\n\t\tif(l==r){ num[k]=x; return; }\n\t\tint mid=l+r>>1;\n\t\tif(i<=mid) modify(i,x,l,mid,L(k));\n\t\telse modify(i,x,mid+1,r,R(k));\n\t\treturn update(k);\n\t}\n\tinline LL query(int a,int b,int l=1,int r=n,int k=1)\n\t{\n\t\t#ifdef DEBUG\n\t\tcout<<'['<<a<<','<<b<<']'<<' '<<l<<' '<<r<<' '<<k<<endl;\n\t\t#endif\n\t\tif(a==l && b==r) return num[k];\n\t\tint mid=l+r>>1;\n\t\tif(a>mid) return query(a,b,mid+1,r,R(k));\n\t\tif(b<=mid) return query(a,b,l,mid,L(k));\n\t\treturn min(query(a,mid,l,mid,L(k)),query(mid+1,b,mid+1,r,R(k)));\n\t}\n}\n \norz yjz()\n{\n\tscf(n); scf(x[(++n)]); scf(T);\n\tforn(i,1,n-1) scf(x[i]);\n\tseg1::modify(n,2*x[n-1]+x[n]);\n\tseg2::modify(n,T+x[n]);\n\tnrof(i,n-1,1)\n\t{\n\t\tdp[i]=linf;\n\t\tint lb=i+1,rb=n;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tint mid=lb+rb>>1;\n\t\t\tLL calc=2*(x[mid-1]-x[i]);\n\t\t\tif(calc>T) rb=mid-1; else lb=mid+1;\n\t\t}//rb\n\t\tLL t1=lb<=n?seg1::query(lb,n)-3*x[i]:linf;\n\t\tLL t2=i<rb?seg2::query(i+1,rb)-x[i]:linf;\n\t\tdp[i]=min(t1,t2);\n\t\t#ifdef DEBUG\n\t\tcout<<i<<' '<<rb<<'\\t'<<seg1::query(lb,n)<<' '<<t1<<'\\t'<<seg2::query(i+1,rb)<<' '<<t2<<' '<<dp[i]<<endl;\n\t\t#endif\n\t\tseg1::modify(i,dp[i]+2*x[i-1]+x[i]);\n\t\tseg2::modify(i,dp[i]+T+x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[1]+x[1]);\n\tfizzydavid ak la\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tfor(int j=0;j<vec[i+1].size();j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[vec[i+1][j]]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[vec[i+1][j]] = min(dp[vec[i+1][j]],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n\n    //手前のがt以下だった場合、\n    for(int d=idx-1;d<now+1000&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  //落ちるケース\n  //tが極端に大きく、間隔が極端に小さい\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tlong long a[N];\n\tlong long dp[N];\n\tqueue<pair<long long, long long> >q;\n\tf(i, N){\n\t\ta[i] = 0;\n\t\tdp[i] = 0;\n\t}\n\tint n, k;\n\tlong long x, y, z;\n\tlong long s, ans, t;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d %lld %lld\", &n,&s,&t);\n\tans = s;\n\tf(i, n){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tif (n == 1){\n\t\tprintf(\"%lld\\n\", s + t);\n\t\treturn 0;\n\t}\n\tdp[0] = t;\n\tq.push(make_pair(a[1], dp[0]));\n\ts = -(2 * a[0]);\n\tfor(int i=1;i<n;i++){\n\t\twhile (true){\n\t\t\tx = q.front().first;\n\t\t\tif ((a[i] - x)>t){\n\t\t\t\ty = q.front().second;\n\t\t\t\ts = min(s, y - (2 * x));\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tx = q.front().first;\n\t\ty = q.front().second;\n\t\tdp[i] = min(y + t+(a[i]-x), s + (2 * a[i]));\n\t\tif (i < n - 1)\tq.push(make_pair(a[i + 1], dp[i]));\n\t}\n\tans += dp[n - 1];\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+15&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nifstream fin (\"contest.in\");\nofstream fout (\"contest.out\");\n\n#define MAX 100000\nlong long n, e, t, x[MAX + 1], d, sum;\n\nlong long maxim (long long A, long long B)\n{\n    if (A > B)return A;\n    else return B;\n}\nint main()\n{\n    fin >> n >> e >> t;\n    for (int i = 1; i <= n; i++)fin >> x[i];\n\n    sum = x[1];\n    x[n + 1] = e;\n    for (int i = 1; i <= n; i++)\n    {\n        int ind = i + 1;\n        d = x[ind] - x[i];\n        while (d < t && ind <= n)\n        {\n            ind ++;\n            d = x[ind] - x[i];\n        }\n        ind--;\n        //if (i == ind && i == n- 1)sum +=t;\n\n        if (i == ind)sum += t, sum += x[i + 1] - x[i];\n        else\n        {\n            d = x[ind] - x[i];\n            sum += maxim(2 * d, t) + d;\n            sum += x[ind + 1] - x[ind];\n\n            i = ind;\n            //if (ind == n - 1)sum += t;\n        }\n    }\n    fout << sum;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nint n,e,t,x[N],i,j,k;\nll f[N],w=1ll<<60;\nmultiset<ll> st;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",x+i);\n\tfor(i=1,k=0;i<=n;++i)\n\t{\n\t\tst.insert(f[i-1]-x[i-1]+t);\n\t\twhile(k<i&&2*(x[i]-x[k+1])>=t)\n\t\t{\n\t\t\tw=min(w,f[k]-x[k]-2*x[k+1]);\n\t\t\tst.erase(st.find(f[k]-x[k]+t));\n\t\t\t++k;\n\t\t}\n\t\tf[i]=1ll<<60;\n\t\tif(w<(1ll<<60))\n\t\t\tf[i]=min(f[i],w+2*x[i]);\n\t\tif(!st.empty())\n\t\t\tf[i]=min(f[i],*(st.begin()));\n\t\t//for(j=i-1;j>=0;--j)\n\t\t\t//f[i]=min(f[i],f[j]-x[j]+max(t,2*(x[i]-x[j+1])));\n\t\tf[i]+=x[i];\n\t}\n\tprintf(\"%lld\",f[n]+e-x[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nvector<int> tree;\nint N = 1;\n\nvoid upd(int v) {\n\tif(v == 0) \n\t\treturn;\n\ttree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n\tupd(v / 2);\n}\n\nint get(int v, int l, int r, int vl, int vr) {\n\tif(vr <= l || r <= vl)\n\t\treturn inf;\n\tif(vl <= l && r <= vr) {\n\t\treturn tree[v];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(get(v * 2, l, m, vl, vr), get(v * 2 + 1, m, r, vl, vr));\n}\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\n\twhile(N < (n + 2)) \n\t\tN *= 2;\n\n\ttree = vector<int> (2 * N, inf);\n\tvector<int> suf(n + 1, inf);\n\tsuf[n - 1] = k;\n\tint uk = n - 2;\n\ttree[N + (n - 2)] = k + a[n - 1] + suf[n - 1];\n\tupd((N + (n - 2)) / 2);\n\n\tfor (int i = n - 2; i >= 0; i--) {\n\n\t\twhile(uk > 0 && 2 * (a[uk] - a[i]) >= k) {\n\t\t\ttree[N + uk] = 2 * a[uk] + a[uk + 1] + suf[uk + 1];\n\t\t\tupd((N + (uk - 1)) / 2);\n\t\t\tuk--;\n\t\t}\n\t\tint ans = max(k, 2 * (a[n - 1] - a[i])) + (a[n - 1] - a[i]);\n\t\tint l = i, r = n + 1;\n\t\twhile(r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(2 * (a[m] - a[i]) < k) \n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\t// cout << ans << \" \" << i << \" \" << l << \" \" << get(1, 0, N, i, l + 1) << \" \" << uk << endl;\n\t\tans = min(ans, get(1, 0, N, i, l + 1) - a[i]);\n\t\tif(r <= n - 2) {\n\t\t\tans = min(ans, get(1, 0, N, l + 1, r + 1) - 3 * a[i]);\n\t\t}\n\t\tsuf[i] = ans;\n\t\tif(i != 0) {\n\t\t\ttree[N + (i - 1)] = k + a[i] + suf[i];\n\t\t\tupd((N + (i - 1)) / 2);\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}\n\n// j\n\n// "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[2010];\nint x[2010];\nint n,e;\nlong long t;\nlong long mn=4e18;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)mn=min(mn,(t-x[i]+x[j]+1)/(x[i]-x[j])*(x[i]-x[j]));\n\t\tdp[i]=4e18;\n\t\tfor(int j=0;j+1<i;j++)\n\t\t{\n\t\t\tlong long tt=2*(x[i]-x[j+1]);\n\t\t\tdp[i]=min(dp[i],dp[j]+x[i]-x[j]+min(mn+tt,t*(i-j)));\n\t\t}\n\t\tdp[i]=min(dp[i],dp[i-1]+x[i]-x[i-1]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 111111\n#define M 444444\n#define LL long long\nusing namespace std;\nint n,i,k,j,a[N];LL f[N],V1[M],V2[M],E,T;\nvoid ins(int k,int l,int r,int x,LL z1,LL z2){\n\tif(l==r){V1[k]=z1;V2[k]=z2;return;}\n\tint md=l+r>>1;\n\tif(x<=md)ins(k<<1,l,md,x,z1,z2);else ins(k<<1|1,md+1,r,x,z1,z2);\n\tV1[k]=min(V1[k<<1],V1[k<<1|1]);\n\tV2[k]=min(V2[k<<1],V2[k<<1|1]);\n}\nLL qu1(int k,int l,int r,int x,int y){\n\tif(x>y)return 1e18;\n\tif(x<=l&&r<=y)return V1[k];\n\tint md=l+r>>1;\n\tif(y<=md)return qu1(k<<1,l,md,x,y);\n\tif(x>md)return qu1(k<<1|1,md+1,r,x,y);\n\treturn min(qu1(k<<1,l,md,x,y),qu1(k<<1|1,md+1,r,x,y));\n}\nLL qu2(int k,int l,int r,int x,int y){\n\tif(x>y)return 1e18;\n\tif(x<=l&&r<=y)return V2[k];\n\tint md=l+r>>1;\n\tif(y<=md)return qu2(k<<1,l,md,x,y);\n\tif(x>md)return qu2(k<<1|1,md+1,r,x,y);\n\treturn min(qu2(k<<1,l,md,x,y),qu2(k<<1|1,md+1,r,x,y));\n}\nint main(){\n\tfor(i=0;i<M;i++)V1[i]=V2[i]=1e18;\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor(i=0,k=0;i<=n;i++){\n\t\tf[i]=1e18;\n\t\tfor(;(a[i]-a[k+1])*2>T&&k<i;k++);\n\t\t//f[i]=f[k]+max(a[i]-a[k+1]+a[i]-a[k+1],T)+a[i]-a[k];\n\t\t//j<=k a[i]-a[j+1*2>T\n\t\t//f[i]=qu2(1,0,0,k)\n\t//\tprintf(\"%d %d\\n\",(a[i]-a[k+1])*2,T);\n\t\tif(i==0)f[i]=0;else \n\t\tf[i]=min(qu1(1,0,n,k,i-1)+T+a[i],qu2(1,0,n,0,k-1)+1ll*a[i]*3);\n\t\t//printf(\"%lld %lld\\n\",qu1(1,0,n,k,i-1)+T+a[i],qu2(1,0,n,0,k-1)+1ll*a[i]*3);\n\t\t//printf(\"%d %d %lld\\n\",i,k,f[i]);\n\t//\tprintf(\"%lld %lld %d\\n\",qu1(1,0,n,k,i-1),qu2(1,0,n,0,k-1),T+a[i]);\n\t\t//puts(\"-----------------------\");\n\t\t\t//f[i]=min(f[i],f[j]+a[i]-a[j]+max((a[i]-a[j+1])*2,T));\n\t\t\n\t\tins(1,0,n,i,f[i]-a[i],f[i]-a[i]-a[i+1]*2);\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int> t;\n\tint pre_x, x, pre_t;\n\tpre_x = 0;\n\tlong long ans = E;\n\tcin >> pre_x;\n\tans += T;\n\tpre_t = T;\n\tfor(int i=1;i<N;i++){\n\t\tcin >> x;\n\t\tif(x - pre_x >= T){\n\t\t\tans += T;\n\t\t\tpre_x = x;\n\t\t\tpre_t = T;\n\t\t}else{\n\t\t\tans-=pre_t;\n\t\t\tpre_t = max(T, 2*(x-pre_x));\n\t\t\tans+=pre_t;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = a; i <= n; i++)\nusing namespace std;\n\n\nconst int SIZE = 100001;\nint N;\nlong E, T;\nlong x[SIZE];\n\nint main(void) {\n  cin >> N >> E >> T;\n  REP(i, 1, N) {\n    cin >> x[i];\n  }\n\n  long ans = E + T * N;\n  for(int i = 1; i <= N;) {\n    int m = i;\n    long d = 0;\n    REP(j, i + 1, N) {\n      long d1 = (x[j] - x[i]) + (j - i + 1) * T;\n      long d2 = (x[j] - x[i]) * 3 + max(T - (x[j] - x[i]) * 2, 0l);\n      if(d < d1 - d2) {\n        m = j;\n        d = d1 - d2;\n      }\n    }\n    ans -= d;\n    i = m + 1;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cfloat>\n#define zero(x) (((x)>0?(x):-(x))<eps)\n\n#define pause cout << \" press ansy key to continue...\",  cin >> chh\n#define file_r(x) freopen(x,  \"r\",  stdin)\n#define file_w(x) freopen(x,  \"w\",  stdout)\n#define lowbit(x) ((x) & (-x))\n#define repit(i, c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repe(i, u) for (int i = head[u]; i != -1; i = nxt[i])\n#define repd(i, n) for (int i = (n - 1); i >= 0; i--)\n#define FOR(i, n, m) for (int i = (n); i <= (m); i++)\n#define FORD(i, n, m) for (int i = (n); i >= (m); i--)\n#define pb push_back\n#define X first\n#define Y second\n#define ins insert\n#define rb rbegin\n#define be begin\n#define er erase\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define SZ(c) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define sqr(r) ((r) * (r))\n#define dis(x1, y1, x2, y2) (((x1) - (x2)) * ((x1) - (x2)) + ((y1) - (y2)) * ((y1) - (y2)))\n#define FASTIO ios::sync_with_stdio(false);cin.tie(0)\n\n#define sc(x) cout << #x\" = \" << x << endl, system(\"pause\")\n#define sc2(x, y) cout << #x\" = \" << x << \" \" << #y\" = \" << y << endl, system(\"pause\")\n#define sc3(x, y, z) cout << #x\" = \" << x << \" \" << #y\" = \" << y << \" \" << #z\" = \" << z << endl, system(\"pause\")\n#define sc4(x, y, z, w) cout << #x\" = \" << x << \" \" << #y\" = \" << y << \" \" << #z\" = \" << z << \" \" << #w\" = \" << w << endl, system(\"pause\")\n\n#define in(n) scanf(\"%d\", &n)\n#define in2(n, m) scanf(\"%d %d\", &n, &m)\n#define in3(x, y, z) scanf(\"%d %d %d\", &x, &y, &z)\n\nusing namespace std;\nint chh;\n\ntypedef vector<int> vi;\ntypedef set<int> si;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pi3;\ntypedef vector< pair<int, int> > vpii;\ntypedef long long LL;\n\nconst int N = 100005;\n\nint n, e, t;\nint a[N], f[N];\n\nint main() {\n    int ans, p, tim, id, tmp, m, pre;\n    while (~in3(n, e, t)) {\n        a[0] = 0;\n        FOR (i, 1, n) in(a[i]);\n        memset(f, -1, sizeof(f));\n        ans = 0, id = 0;\n        FOR (i, 1, n) {\n            //sc4(i, f[i], ans, id);\n            ans += a[i] - a[i - 1];\n            if (f[i] == -1) tim = t, f[i] = ans, id = i;\n            else {\n                if (f[i] + t <= ans) continue;\n                else tim = f[i] + t - ans;\n            }\n            pre = ans + tim;\n            for (p = id + 1; p <= n; p++) {\n                tmp = a[p] - a[i];\n                if (tmp * 2 <= tim) f[p] = ans + tmp;\n                else {\n                    m = ans + tmp * 3;\n                    if (tmp < t) m += t - tmp;\n                    //sc2(p, m);\n                    if (m <= pre + tmp + tim) f[p] = ans + tmp;\n                    else break;\n                }\n                if (tmp * 2 <= tim) pre = ans + tim;\n                else pre = ans + tmp * 2;\n            }\n            id = p - 1;\n            ans = pre;\n        }\n        ans += e - a[n];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define maxn 100005\n#define INF (LL)1e16\nusing namespace std;\nint n,m,t,x[maxn];\nLL dp[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tsort(x+1,x+n+1);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0]=0;\n\tLL mn=INF; int now=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=dp[i-1]+t+x[i]-x[i-1];\n\t\twhile(2*(x[i]-x[now+1])>=t)\n\t\t{\n\t\t\tmn=min(mn,dp[now]-2ll*x[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tdp[i]=min(2*x[i]+mn,dp[now]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 10;\nconst long long INF = (long long)(1e18);\n\nstruct IT_min {\n    long long T[4 * MAXN];\n    int n;\n\n    void init(int _n) {\n        n = _n;\n        ++n;\n        for(int i = 0; i <= 4 * n; ++i) T[i] = INF;\n    }\n\n    void update(int x, int i, int j, int p, long long v) {\n        if ((j < p) || (i > p)) return;\n        if (i == j) {\n            T[x] = v;\n            return;\n        }\n        int mid = (i + j) >> 1;\n        update(x + x, i, mid, p, v);\n        update(x + x + 1, mid + 1, j, p, v);\n        T[x] = min(T[x + x], T[x + x +1]);\n    }\n\n    long long get_min(int x, int i, int j, int l, int r) {\n        if ((j < l) || (i > r)) return INF;\n        if ((i >= l) && (j <= r)) return T[x];\n        int mid = (i + j) >> 1;\n        return min(get_min(x + x, i, mid, l, r), get_min(x + x + 1, mid + 1, j, l, r));\n    }\n\n    long long get_min(int l, int r) {\n        ++l; ++r;\n        if (r < 1) return 0;\n        if (l > r) return 0;\n        return get_min(1, 1, n, l, r);\n    }\n\n    void update(int p, long long v) {\n        ++p;\n        update(1, 1, n, p, v);\n    }\n\n} T1, T2;\n\nint n, e;\nlong long t;\nlong long x[MAXN];\nlong long f[MAXN];\n\nvoid run() {\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++) cin >> x[i];\n\n    x[0] = 0;\n    f[0] = 0;\n\n    T1.init(n); T2.init(n);\n    T1.update(0, f[0] + -x[0]); T2.update(0, f[0] + -x[1] * 2 - x[0]);\n    for(int i = 1; i <= n; ++i) {\n        int j = upper_bound(x, x + n + 1, x[i] - (t / 2) - (t % 2)) - x;\n        f[i] = INF;\n        if (j <= i) {\n            f[i] = x[i] + T1.get_min(j - 1, i - 1) + t;\n            //cout << \">> \" << j << \" \" << x[i] << \" \" << f[i] << endl;\n        }\n        j = min(j - 1, i);\n        if (j > 0) {\n            f[i] = min(f[i], x[i] * 3 + T2.get_min(0, j - 1));\n        }\n        T1.update(i, f[i] + -x[i]);\n        T2.update(i, f[i] + -x[i + 1] * 2 - x[i]);\n        //cout << i << \" \" << f[i] << endl;\n    }\n\n    cout << f[n] + (e - x[n]) << endl;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    int ntests = 1;\n    //cin >> ntests;\n    for(int tc = 1; tc <= ntests; ++tc) {\n        run();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <ctime>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double lf;\ntypedef long double Lf;\ntypedef pair <int,int> pii;\ntypedef pair <ll, ll> pll;\n\n#define TRACE(x) cerr << #x << \"  \" << x << endl\n#define FOR(i, a, b) for (int i = (a); i < int(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define _ << \" \" <<\n\n#define fi first\n#define sec second\n#define mp make_pair\n\nconst int MAXN = 100100;\n\nint n;\n\nll t, e, p[MAXN];\n\nll solve(int x) {\n\tif (x == n) return 0;\n\tint lo = x + 1, hi = n, mid;\n\n\twhile (lo != hi) {\n\t\tmid = (lo + hi) / 2;\n\t\tif (3 * (p[mid] - p[x]) <= 2 * t + p[mid] - p[x]) lo = mid + 1;\n\t\telse hi = mid;\n\t}\n\n\tll ret = 0;\n\tif (lo == x + 1) ret = t;\n\telse ret = 3 * (p[lo - 1] - p[x]);\n\n\tret += p[lo] - p[lo - 1];\n\n\treturn ret + solve(lo);\n}\n\nint main() {\n\tscanf(\"%d %lld %lld\",&n,&e,&t);\n\tREP(i, n) scanf(\"%lld\",&p[i]);\n\tp[n] = e;\n\n\tprintf(\"%lld\\n\",solve(0) + p[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100020\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\nll f[N], x[N];\nint main(int argc, char const *argv[]) {\n  // freopen(\"D:/1_00.txt\", \"r\", stdin);\n\n  int n = read();\n  ll E = read(), T = read();\n\n  for (int i = 1; i <= n; ++ i) {\n    x[i] = read();\n  }\n\n  memset(f, 0x3f, sizeof f);\n  f[0] = 0;\n\n  ll mn = 1ll << 60;\n  for (int i = 1, j = 0; i <= n; ++ i) {\n    while (T <= 2 * (x[i] - x[j + 1])) {\n      mn = min(mn, f[j] - 2 * x[j + 1]);\n      ++ j;\n    }\n    f[i] = min(f[j] + T, mn + 2 * x[i]);\n  }\n\n  printf(\"%d\\n\", f[n] + E);\n\n  return 0;\n}\n/*\n\n只有两种情况。\n\n          | wait T )\n----------+------------>\n0         A            B            E\n\n\n-----------------------.\n          .------------`\n          `--------------->\n0         A            B            E\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 200005;\n\nlong long pos[DIM], dp1[DIM], dp2[DIM];\n\nint main(void)\n{\n    int n, e, t;\n    cin >> n >> e >> t;\n    \n    for (int i = 1; i <= n; ++i)\n        cin >> pos[i];\n    \n    dp2[0] = 1e17;\n    for (int i = 1, p = 1; i <= n; ++i) {\n        while ((pos[i] - pos[p]) * 2 >= t)\n            ++p;\n        \n        dp1[i] = min(dp1[p - 1] + t, dp2[p - 1] + pos[i] * 2);\n        dp2[i] = min(dp2[i - 1], dp1[i - 1] - pos[i] * 2);\n    }\n    \n    cout << dp1[n] + e << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nint n, e, t, x[100005];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\t\n\tll ans = e;\n\tint last = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (std::max((x[i] - x[last]) * 2, t) - std::max((x[i - 1] - x[last]) * 2, t) >= t) {\n\t\t\tans += std::max((x[i - 1] - x[last]) * 2, t);\n\t\t\tlast = i;\n\t\t}\n\t}\n\tans += std::max((x[n] - x[last]) * 2, t);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=1e18;\n\ntemplate<typename Monoid>\nstruct SegmentTree{\n    typedef function<Monoid(Monoid,Monoid)> F;\n    int n;\n    F f;\n    Monoid id;\n    vector<Monoid> dat;\n    SegmentTree(int n_,F f,Monoid id):f(f),id(id){init(n_);}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,id);\n    }\n    void build(const vector<Monoid> &v){\n        for (int i=0;i<v.size();++i) dat[i+n]=v[i];\n        for (int i=n-1;i;--i) dat[i]=f(dat[i<<1|0],dat[i<<1|1]);\n    }\n    void update(int k,Monoid x){\n        dat[k+=n]=x;\n        while(k>>=1) dat[k]=f(dat[k<<1|0],dat[k<<1|1]);\n    }\n    Monoid query(int a,int b){\n        if (a>=b) return id;\n        Monoid vl=id,vr=id;\n        for (int l=a+n,r=b+n;l<r;l>>=1,r>>=1){\n            if (l&1) vl=f(vl,dat[l++]);\n            if (r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    Monoid operator[](int i){\n        return dat[i+n];\n    }\n    // most left position that meets condition \"check\"\n    template<typename C>\n    int find(int a,int b,const C &check,int k,int l,int r){\n        if (!check(dat[k])||r<=a||b<=l) return -1;\n        if (l+1==r) return k-n;\n        int vl=find(a,b,check,k<<1|0,l,(l+r)>>1);\n        if (~vl) return vl;\n        return find(a,b,check,k<<1|1,(l+r)>>1,r);\n    }\n    template<typename C>\n    int find(int a,int b,const C &check){\n        return find(a,b,check,1,0,n);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; ll E,T; cin >> N >> E >> T;\n    vector<ll> x(N+1); x[0]=0;\n    for (int i=1;i<=N;++i) cin >> x[i];\n    vector<ll> x_2(N+1);\n    for (int i=0;i<=N;++i) x_2[i]=x[i]*2;\n    vector<ll> dp(N+1,INF),dp0(N+1);\n    SegmentTree<ll> seg(N+1,[](ll a,ll b){return min(a,b);},INF);\n    dp[0]=0; dp0[0]=-x_2[1];\n    seg.update(0,0);\n    for (int i=1;i<=N;++i){\n        int pos=upper_bound(x_2.begin(),x_2.end(),x_2[i]-T)-x_2.begin()-2;\n        if (pos>=0) dp[i]=min(dp[i],dp0[pos]+3*x[i]);\n        dp[i]=min(dp[i],seg.query(max(0,pos+1),i)+T+x[i]);\n        if (i==N) continue;\n        dp0[i]=min(dp0[i-1],dp[i]-x_2[i+1]-x[i]);\n        seg.update(i,dp[i]-x[i]);\n    }\n    cout << dp[N]+(E-x[N]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[2001];\t//1-indexed, x[0] = 0\nint dp[2001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値, Xiのコインは既に回収済み\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j <= n; j++) {\t//X_i -> X_i+1 -> X_j -> X_i+1 -> X_j\n\t\t\tdp[j] = min(dp[j], dp[i] + max(t, 2 * (x[j] - x[i + 1])) + x[j] - x[i]);\n\t\t}\n\t}\n\t\n\tcout << dp[n] + e - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=100005;\nconst ll INF=1e18;\n\nint n,m,T;\nint a[MAXN];\nll d[MAXN],mine=INF;\n\nint main(){\n\n    scanf(\"%d%d%d\",&n,&m,&T);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),d[i]=INF;\n    for(int i=1,last=0;i<=n;i++){\n        while(T<=2*(a[i]-a[last+1])){\n            mine=min(mine,d[last]-2*a[last+1]);\n            last++;\n        }\n        d[i]=d[last]+T;\n        d[i]=min(d[i],mine+2*a[i]);\n    }\n    printf(\"%lld\",m+d[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\n//pair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>=val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get(1,0,n,l,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nnamespace Segment_tree {\n\ttemplate<typename T>\n\tclass segment_tree {\n\t\tvector<T> dat;\n\t\tint n;\n\t\tT e;\n\t\tstd::function<T(T, T)> f;\n\t\tT query_implement(int a, int b, int k, int l, int r) {\n\t\t\tif (r <= a || b <= l) return e;\n\t\t\tif (a <= l && r <= b) return dat[k];\n\n\t\t\tT v1 = query_implement(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT v2 = query_implement(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn f(v1, v2);\n\t\t}\n\tpublic:\n\t\tsegment_tree(int n_, T _e, T(*calc)(T lhs, T rhs)) {\n\t\t\te = _e;\n\t\t\tf = calc;\n\t\t\tn = 1;\n\t\t\twhile (n < n_) n *= 2;\n\t\t\tdat.resize(2 * n - 1);\n\t\t\tfor (int i = 0; i < 2 * n - 1; i++)\n\t\t\t\tdat[i] = e;\n\t\t}\n\n\t\tvoid update(int k, int a) {\n\t\t\tk += n - 1;\n\t\t\tdat[k] = a;\n\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tdat[k] = f(dat[k * 2 + 2], dat[k * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT query(int a, int b) { return query_implement(a, b, 0, 0, n); }\n\t};\n}\nlong long int f(long long int i, long long int j) { return min(i, j); }\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\t\n\tSegment_tree::segment_tree<long long int> seg(n,1e10,f);\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tint index=lower_bound(ALL(x), x[i]-double(t)/2+0.001) - x.begin();\n\t\tif (index >= i)\n\t\t\tindex = i-1;\n\t\tindex--;\n\t\tif (index > 0)\n\t\t\tres = min(res, dp[index] - 2 * x[index] - x[index + 1]);\n\t\tindex = lower_bound(ALL(x), x[i] - double(t) / 2+0.001) - x.begin();\n\t\tif (index < i - 1) {\n\t\t\tlong long int a = seg.query(index, i - 1);\n\t\t\tres = min(res, a + x[i]);\n\t\t}\n\t\tdp[i] = res;\n\t\tif(i<n-1)\n\t\tseg.update(i,dp[i] - 2 * x[i] - x[i + 1] + t - 2 * x[i + 1]);\n\t}\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    multiset<ll> As;\n    multiset<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>t){\n            As.insert(A[iter]);\n            Bs.erase(B[iter]);\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nconst ll inf = (1LL<<62) - 1 + (1LL<<62);\n\nint n,e,t,p[maxn],ti[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<=t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i];\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]+t-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\nusing ulong = unsigned long;\nusing ll = long long;\nconst int M = 1e9 + 7;\n#pragma unused(M)\n\nint n, e, t;\nvector<ll> xs;\nll memo[100010][2];\nll solve(int pos, bool round){\n    if(memo[pos][round]){ return memo[pos][round]; }\n    ll time = round ? 2 * (xs[pos + 1] - xs[pos]) : 0;\n    if(pos == 0){\n        return xs[0] + max(0ll, t - time);\n    }\n    ll dx = xs[pos] - xs[pos - 1];\n    return memo[pos][round] = min(\n            solve(pos - 1, false) + dx + max(0ll, (t - time)),\n            solve(pos - 1, true) + 3 * dx);\n}\n\nint main(){\n\tcin >> n >> e >> t;\n    vector<ll> xs(n);\n    for(int i=0;i<n;i++){\n        cin >> xs[i];\n    }\n    ::xs = xs;\n\n    cout << solve(n - 1, false) + e - xs.back() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 100010;\ntypedef long long ll;\nint n, e, t;\nll a[maxn], f[maxn];\n\nint main(){\n  scanf(\"%d%d%d\", &n, &e, &t);\n  for(int i = 1;i <= n;++i)scanf(\"%lld\", &a[i]);\n  memset(f, 0x3f, sizeof(f));f[0] = 0;\n  ll mn = 0x3f3f3f3f3f3f3f3fLL;\n  for(int i = 1, j = 0;i <= n;++i){\n    while(j + 1 < i && t <= 2LL * (a[i] - a[j + 1])){\n      mn = min(mn, f[j] - 2LL * a[j + 1]);\n      j++;\n    }\n    if(t > 2LL * (a[i] - a[j + 1]))f[i] = f[j] + t;\n    f[i] = min(f[i], 2LL * a[i] + mn);\n    //  cout<<\"for \"<<i<<' '<<f[i]<<endl;\n  }\n  printf(\"%lld\\n\", f[n] + e);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 55;\nint x[100001];\nll dp[2010][2010];\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, T, E;\n\tcin >> N >> E >> T;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tx[N] = E;\n\n\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\tdp[0][0] = x[0];\n\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t// 戻る\n\t\t\tif(j < i) {\n\t\t\t\tll pre = dp[j][j];\n\t\t\t\tll tdiff = dp[i][j] - pre;\n\t\t\t\tll xdiff = x[i] - x[j];\n\t\t\t\tll rem = max(0LL, T - (tdiff + xdiff));\n\t\t\t\t// 戻る間にT経った\n\t\t\t\tif(xdiff * 2 + rem >= T) {\n\t\t\t\t\tdp[i + 1][i + 1] = min(dp[i + 1][i + 1], dp[i][j] + xdiff * 2 + rem + x[i + 1] - x[i]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + xdiff * 2 + rem + x[i + 1] - x[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 待つ\n\t\t\tif(i == j) {\n\t\t\t\tdp[i + 1][i + 1] = min(dp[i + 1][i + 1], dp[i][j] + T + x[i + 1] - x[i]);\n\t\t\t}\n\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + x[i + 1] - x[i]);\n\t\t}\n\t}\n\n\tcout << dp[N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,N) for(int i = 0;i < N;i++)\n#define int long long\nsigned main(){\n  int N,E,T;\n  cin >> N >> E >> T;\n  int kuma[100000];\n  int edge[100000];\n  Rep(i,N)cin >> kuma[i];\n  Rep(i,N - 1)edge[i] = kuma[i + 1] - kuma[i];\n  int sum = kuma[0];\n  int ruiseki = 0;\n  Rep(i,N - 1){\n    \n    if(max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki + edge[i] + T > (max(max((int)0,T - (ruiseki * 2 + 2 * edge[i])),ruiseki + 2 * edge[i])) + ruiseki + edge[i]) {\n      ruiseki += edge[i];\n      sum += edge[i];\n    }else {\n      sum += max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki + edge[i];\n      cout << ruiseki << endl;\n      ruiseki = 0;\n    }\n    cout << sum << \" \" << ruiseki << endl;\n  }\n  if(ruiseki) {\n    cout << sum + E - kuma[N - 1] + max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki << endl;\n  }else {\n    cout << sum + E - kuma[N - 1] + T << endl;\n  }\n  return 0;\n}\n      \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\nlong long f[100008];\nint x[100008];\ninline bool cmp(const int &a, const int &b){\n\treturn f[a] == f[b] ? a > b : f[a] > f[b];\n}\nstruct Heap{\n\tint h[100008], siz;\n\tHeap(){ \n\t\tsiz = 0;\n\t}\n\tvoid Push(const int &x) {\n\t\th[++siz] = x;\n\t\tpush_heap(h + 1, h + siz + 1, cmp);\n\t\treturn ;\n\t}\n\tvoid Pop() {\n\t\tpop_heap(h + 1, h + siz + 1, cmp);\n\t\t--siz;\n\t\treturn ;\n\t}\n\tint Top() {\n\t\treturn h[1];\n\t}\n}c;\nint main(){\n\tregister int n, e, t, i, j;\n\tregister long long fmin = 3000000000ll;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tf[0] = 0;\n\tc.Push(0);\n\tfor (j = 0, i = 1; i <= n; ++i) {\n\t\twhile (2 * (x[i] - x[j + 1]) > t) {\n\t\t\tcmin(fmin, f[j] - x[j + 1] * 2);\n\t\t\t++j;\n\t\t}\n\t\twhile (c.Top() < j) c.Pop();\n\t\tf[i] = dmin(fmin + 2 * x[i], f[c.Top()] + t);\n\t\tc.Push(i);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<long long> x(N);\n    for (long  long &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0LL, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<r)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, r));\n        if (r<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(r, i));\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nlong long DP[100001];\n\nint main()\n{\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int>x(N+1);\n\tfor (int i = 0; i < N; i++)cin >> x[i];\n\tx[N] = E;\n\tvector<long long>sum(N+1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum[i] = sum[i-1] + x[i] - x[i-1];\n\t}\n\n\tfor (int i = 0; i <= N; i++)DP[i] = INT64_MAX;\n\n\tDP[0] = x[0];\n\tint last = 0;\n\tfor (int i = 0; i < N; i++) {\t\n\t\tbool flag = true;\n\t\tfor (; last < N; last++) {\n\t\t\tif (2 * (sum[last] - sum[i]) > T)break;\n\t\t}\n\t\tfor (int j = last - 1; j < N; j++) {\n\t\t\tif (flag == false)break;\n\t\t\tif (2 * (sum[j] - sum[i]) > T)flag = false;\n\n\t\t\tDP[j+1] = min(DP[j+1], DP[i] + max((long long)0,(T-2*(sum[j]-sum[i]))) + 3*(sum[j]-sum[i]) + sum[j+1]-sum[j]);\n\t\t\t//cerr << i << \" \" << j << \" \" << DP[j + 1] << endl;\n\t\t}\n\n\t\tDP[i + 1] = min(DP[i+1], DP[i] + T + sum[i+1] - sum[i]);\n\n\t\t//cerr << DP[i] << endl;\n\t}\n\n\tcout << DP[N] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 100050;\nint x[MAXN];\nll dp[MAXN];\n\nint main() {\n\tint N, E, T;\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &x[i]);\n\tdeque<int> deq;\n\tdp[0] = 0;\n\tfor(int i=1;i<=N;i++) {\n\t\tdp[i]=1ll*(E+T)*MAXN*10;\n\t\tfor(int k=0;k<i;k++)\n\t\t\tdp[i]=min(dp[i], dp[k] + (x[k+1]-x[k]) + max( T, 2*(x[i]-x[k+1]) ) + (x[i]-x[k+1]));\n\t\tdebug(\"i %d %lld\\n\", i, dp[i]);\n\t}\n\tcout << dp[N] + E-x[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nint p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tint now=0;\n\tll Min;\n\tFor(i,1,n)\n\t{\n\t\tdp[i]=dp[i-1]+T;\t\n\t\tMin=inf;\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tif(now<i)cmin(dp[i],dp[now]+T);\n\t\tcmin(dp[i],Min+2*p[i]);\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n\treturn dp[j] + a[i] - a[j] + max(t, 2 * (a[i] - a[j + 1]));\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\tdp[i] = dp[i - 1] + a[i] - a[i - 1] + t;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}\n\t//\tcout << \"73 \" << i << \" \" << dp[i] << endl;\n\t//\tcout << \"72 \" << get(2, 0) << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, E, T, x[100009];\nlong long dp[100009], INF = 1LL << 50;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &E, &T);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nfor (int i=1; i<=N; i++)\n{\n    dp[i] = INF;\n    for (int j=1; j<=i; j++)\n    {\n        long long curr = dp[j - 1] + 3LL * (x[i] - x[j]) + x[j] - x[j - 1] + (2 * (x[i] - x[j]) >= T ? 0 : T - 2 * (x[i] - x[j]));\n        if (curr < dp[i]) dp[i] = curr;\n    }\n}\nprintf (\"%lld\\n\", dp[N] + E - x[N]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#define Rep(i,a) for(int i = 0; i < (a); i++)\n#define rep(i,a,b) for(int i = (a); i <= (b); i++)//(a)!\n#define dep(i,a,b) for(int i = (a); i >= (b); i--)\n#define ab(a) ((a) > 0 ? (a) : -(a))\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long uLL;\nconst int N = 100010;\nconst LL inf = 1LL << 61;\nint n, e, T;\nLL mn[N][18], f[N], s[N], x[N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&T);\n\trep(i,1,n) scanf(\"%lld\",&x[i]);\n\ts[0] = f[0] - 2 * x[1] - x[0]; mn[0][0] = f[0] - x[0];\n\trep(i,1,n) {\n\t\tint k = i - 1; f[i] = inf;\n\t\tdep(j,17,0) if (k - (1 << j) >= 0 && ((x[i] - x[k - (1 << j) + 1]) << 1) <= T ) \n\t\t\tf[i] = min(f[i], mn[k][j] + x[i] + T), k -= 1 << j;\n\t\tif ((x[i] - x[k + 1]) * 2 <= T) f[i] = min(f[i], mn[k][0] + x[i] + T); else k++;\n\n\t\tif (k) f[i] = min(f[i], s[k - 1] + 3 * x[i]);\n\t\ts[i] = min(s[i - 1], f[i] - 2 * x[i + 1] - x[i]);\n\t\tmn[i][0] = f[i] - x[i];\n\t\trep(j,1,17)if (i - (1 << j) + 1 >= 0) mn[i][j] = min(mn[i - (1 << (j - 1))][j - 1], mn[i][j - 1]);\n\t}\n\tprintf(\"%lld\\n\",f[n] + e - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, T, E, pl, x[100009]; long long dp[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i]);\n\tlong long best = 1LL << 60;\n\tfor (int i = 0; i < N; i++) {\n\t\twhile (x[pl] + T / 2 < x[i]) best = std::min(best, dp[pl]), pl++;\n\t\tdp[i + 1] = std::min(dp[pl] + T + x[pl] * 2, best + x[i] * 2) - x[i + 1] * 2;\n\t}\n\tprintf(\"%lld\\n\", dp[N] + E - x[0] * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: d.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;} template<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>ll dcmp(T a,T b){return a>b;}\ntemplate<ll *a>ll cmp_a(ll x,ll y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst ll SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; ll f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// prll the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed lleger\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// prll a signed lleger\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nll f[100005],s[100005];\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"d.in\",\"r\",stdin);\n\tfreopen(\"d.out\",\"w\",stdout);\n#endif\n\tll n,t,e;\n\tread(n);\n\tread(e,t);\n\tfor(ll i=1;i<=n;++i){\n\t\tread(s[i]);\n\t\tf[i]=inf;\n\t\tfor(ll j=1;j<=i;++j)chkmin(f[i],f[j-1]+max((s[i]-s[j])<<1,t));\n\t}\n\twrite(f[n]+e);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nconst int maxn=(int)(1e5)+5;\nconst LL INF=(LL)(1e18);\nLL x[maxn],f[maxn];\nbool ban[maxn];\npriority_queue<pii,vector<pii>,greater<pii> > h[2];\nint n,e,t;\n\n// f[i] = x[i] + min{ f[j-1]-x[j-1]+t} t-2(x[i]-x[j])>=0\n\n// f[i] = 3x[i] + min{ f[j-1]-x[j-1]-2x[j]} t-2(x[i]-x[j])<0\n\ninline LL calc(int i,int ty) {\n    if(ty==0) return f[i-1]-x[i-1]+t;\n    else return f[i-1]-x[i-1]-2*x[i];\n}\n\nint main() {\n    read(n);read(e);read(t);\n    REP(i,1,n) read(x[i]);\n    f[0]=0;x[0]=0;\n    int ps=1;\n    h[0].push(make_pair(calc(ps,0),ps));\n    REP(i,1,n) {\n        while(t-2*(x[i]-x[ps])<0) ban[ps]=1,h[1].push(make_pair(calc(ps,1),ps)),ps++;\n        pii nowa=make_pair(INF,0),nowb=make_pair(INF,0);\n        if(!h[0].empty()) nowa=h[0].top();\n        while(!h[0].empty() && ban[nowa.second]) h[0].pop(),nowa=h[0].top();\n        if(!h[1].empty()) nowb=h[1].top();\n        f[i]=min(x[i]+nowa.first,3*x[i]+nowb.first);h[0].push(make_pair(calc(i+1,0),i+1));\n\n    }\n    printf(\"%lld\\n\",f[n]+e-x[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MN = 1e5+5;\nint N, M, W, E, i, j;\nll dp[MN], arr[MN], ans;\n\nint main(){\n    for(scanf(\"%d%d%d\",&N,&E,&W),i=1;i<=N;i++){\n        scanf(\"%lld\",&arr[i]);\n    }\n    for(i=1;i<=N;i++){\n        if(arr[i]<=E) M++;\n    }\n    for(i=j=M;i>=1;i--){\n        while(2*(arr[j]-arr[i])>W) j--;\n        dp[i]=dp[j+1]+arr[j]-arr[i]+W;\n        if(j+1<=M) dp[i]+=arr[j+1]-arr[j];\n        if(j+2<=M) dp[i]=min(dp[i],dp[j+2]+2LL*(arr[j+1]-arr[i])+arr[j+2]-arr[i]);\n        else if(j+1<=M) dp[i]=min(dp[i],dp[j+2]+3LL*(arr[j+1]-arr[i]));\n    }\n    dp[1] += arr[1];\n    if(M<N) dp[1]+=2*arr[N]-arr[M]-E+W;\n    else dp[1] += E-arr[N];\n    printf(\"%lld\\n\",dp[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    multiset<ll> As;\n    multiset<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>=t){\n            As.insert(A[iter]);\n            Bs.erase(Bs.find(B[iter]));\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    multiset<ll> As;\n    multiset<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>=t){\n            As.insert(A[iter]);\n            Bs.erase(Bs.find(B[iter]));\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1e16;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 2010\nll n, t, e;\nll x[N];\nll dp[N];\n\nint main(){\n\tcin>>n>>e>>t;\n\trep(i, n) cin>>x[i];\n\tll res = e;\n\tfill(dp, dp+n+1, INF);\n\tdp[0] = 0;\n\trep(i, n){\n\t\trep(j, i+1){\n\t\t\tchmin(dp[i+1], dp[j]+max(t, 2*(x[i]-x[j])));\n\t\t}\n\t}\n\tres += dp[n];\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#define REP(i, a, n) for(int i = a; i <= n; i++)\nusing namespace std;\n\n\nconst int SIZE = 100001;\nint N;\nlong E, T;\nlong x[SIZE];\n\nint main(void) {\n  cin >> N >> E >> T;\n  REP(i, 1, N) {\n    cin >> x[i];\n  }\n\n  long dp[SIZE];\n  dp[0] = 0;\n  REP(i, 1, N) {\n    dp[i] = LONG_MAX;\n    REP(j, 1, i) {\n      dp[i] = min(dp[i], dp[j - 1] + max(T, (x[i] - x[j]) * 2));\n    }\n  }\n\n  cout << dp[N] + E << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t &x, int64_t y) {\n    if (x > y) x = y;\n}\n\nint64_t dp[2020][2020];\n\nint main() {\n    int n;\n    int64_t T, E;\n    cin >> n >> E >> T;\n    vector<int64_t> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%I64d\", &x[i]);\n    vector<int64_t> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    if (n > 2000) return 0;\n\n    fill_n(*dp, 2020 * 2020, 1e17);\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            // wait\n            if (j == 0) {\n                chmin(dp[i + 1][0], dp[i][j] + T + d[i]);\n            }\n\n            // return\n            if (j > 0) {\n                int64_t dist = ds[i] - ds[i - j];\n                chmin(dp[i + 1][0], dp[i][j] + d[i] + max(0LL, T - 2 * dist) + dist * 2);\n            }\n\n            // ignore\n            if (i < n - 1) {\n                chmin(dp[i + 1][j + 1], dp[i][j] + d[i]);\n            }\n        }\n    }\n\n    int64_t ans = dp[n][0] + x[0] + (E - x[n - 1]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\nconst llint inf = 1e18;\n\nint x[MAX];\nllint f[MAX];\n\nint main(void) {\n  int N, E, T;\n  scanf(\"%d %d %d\", &N, &E, &T);\n  REP(i, N) scanf(\"%d\", &x[i]);\n  \n  f[0] = 0;\n  multiset<llint> S2;\n  S2.insert(f[0]);\n  \n  int j = 0;\n  llint best = inf;\n  for (int i = 1; i <= N; ++i) {\n    while (2*(x[i-1] - x[j]) > T) {\n      S2.erase(S2.find(f[j]));\n      best = min(best, f[j] - 2*x[j]);\n      j++;\n    }\n\n    f[i] = min(best + 2*x[i-1], *S2.begin() + T);\n    S2.insert(f[i]);\n  }\n\n  llint ans = E + f[N];\n  //printf(\"%lld\\n\", ans);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005],dp2[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint p=0;\n\tdp[0]=t;\n\tdp2[0]=1e9;\n\tfor(int i=1;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\twhile(t<(x[i]-x[p+1])*2)p++;\n\t\tdp[i]=min(dp[i],t+dp[p]);\n\t\tdp2[i]=min(dp2[i-1],dp[i-1]-x[i]*2);\n\t\tif(p>0)\n\t\tdp[i]=min(dp[i],2*x[i]+dp2[p-1]);\n\t/*\tfor(int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t}*/\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=3e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tfor(int A=1;A<=N+3;A++)\n\t\tdp[A]=-1;\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]);\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//sobskdrbhvk\n//remember the flying, the bird dies ):(\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\n\n#define PB push_back\n#define MP make_pair\n#define L first\n#define R second\n#define sz(x) ((int)(x).size())\n#define smax(x, y) ((x) = max((x), (y)))\n#define smin(x, y) ((x) = min((x), (y)))\n#define all(x) x.begin(),x.end()\n\nconst int maxn = 1e5 + 85 - 69;\nconst LL Inf = 1e18;\nLL mn[maxn],\n\ta[maxn],\n\tn, E, T;\nLL dp[maxn];\ndeque<int> dq;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\ta[n + 1] = E;\n\tint ptr = 1;\n\tdq.push_front(0);\n\tfor(int i = 1; i <= n; i++){\n\t\twhile(2 * (a[i] - a[ptr]) > T) ptr++;\n\t\twhile(sz(dq) and dq.back() + 1 < ptr) dq.pop_back();\n\t\tdp[i] = Inf;\n\t\tif(sz(dq))\n\t\t\tdp[i] = dp[dq.back()] + (a[i] - a[dq.back()]) + T;\n\t\tif(ptr >= 2)\n\t\t\tsmin(dp[i], dp[mn[ptr - 2]] + 2 * (a[i] - a[mn[ptr - 2] + 1]) + a[i] - a[mn[ptr - 2]]);\n\t\twhile(sz(dq) and dp[i] - a[i] <= dp[dq.front()] - a[dq.front()])\n\t\t\tdq.pop_front();\n\t\tdq.push_front(i);\n\t\tmn[i] = mn[i - 1];\n\t\tif(dp[i] - 2 * a[i + 1] - a[i] < dp[mn[i]] - 2 * a[mn[i] + 1] - a[mn[i]])\n\t\t\tmn[i] = i;\n\t}\n\tcout << dp[n] + E - a[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 1e9 + 7;  // 924844033;\nconstexpr int N = 1e5 + 10;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n;\nll T, E, x[N], dp[N], seg[N << 1];\n\ninline void segAssign(int id, ll val) {\n  for (seg[id += n] = val; id > 1; id >>= 1)\n    seg[id >> 1] = min(seg[id], seg[id ^ 1]);\n}\n\ninline ll segGet(int l, int r) {\n  ll res = 1e18;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) smin(res, seg[l++]);\n    if (r & 1) smin(res, seg[--r]);\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n\n  cin >> n >> E >> T;\n  n++;\n  rep(i, 1, n) cin >> x[i];\n\n  int ptr = 0;\n  dp[0] = 0;\n  segAssign(0, dp[0] + T - x[1]);\n  rep(i, 1, n) {\n    while (2 * (x[i] - x[ptr + 1]) >= T) {\n      segAssign(ptr, dp[ptr] - 2 * x[ptr + 1]);\n      ptr++;\n    }\n    dp[i] = min(segGet(0, ptr) + 2 * x[i], segGet(ptr, i) + x[i]);\n    segAssign(i, dp[i] + T - x[i + 1]);\n  }\n\n  cout << E + dp[n - 1] << endl;\n\n  return 0;\n}\n\n// 1 2 0 1 2"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,t,x[100010];\nlong long f[100010],k=1e18;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\tfor(;2*(x[i]-x[j+1])>t;j++)\n\t\t\tk=min(k,f[j]-2*x[j+1]);\n\t\tf[i]=min(k+2*x[i],f[j]+t);\n\t}\n\tcout<<f[n]+m<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  const int N = 100000 + 10;\n  int n;\n  lli e, t;\n  while (cin >> n >> e >> t) {\n    lli x[N];\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i];\n    }\n    x[n] = e;\n    lli dp[N]; // 0~(i-1)まで全て回収してiにいる。\n    fill(dp, dp + N, 1LL << 60);\n    dp[0] = x[0];\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j <= n; ++j) {\n        lli cost = 0;\n        cost += x[j] - x[i];\n        cost += max(t, 2 * (x[j - 1] - x[i]));\n        dp[j] = min(dp[j], dp[i] + cost);\n      }\n    }\n\n    // for (int i = 0; i <= n; ++i) cout << i << \": \" << dp[i] << endl;\n    \n    cout << dp[n] << endl;\n    // cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint T, n, e, t;\n\nint main(int argc, char *argv[]){\n\tios::sync_with_stdio(false);\n\tcin >> n >> e >> t;\n\tvi x(n + 2);\n\tREPS(i, n) cin >> x[i];\n\tx[n + 1] = e;\n\tint captured = 0;\n\tll ans = x[1];\n\tREPS(i, n){\n\t\tll d = x[i] - x[captured + 1];\n\t\tll nd = x[i+1] - x[i];\n\t\tif(i == n || 2 * t - 2 * d < 2 * nd){\n\t\t\tans += 3 * d + max(0ll, t - 2 * d) + nd;\n\t\t\tcaptured = i;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\n\nlong long x[100005];\nlong long dp[100005];\n\nlong long min(long long a, long long b){ return a < b ? a : b; }\n\npriority_queue<long long> q; // -dp\npriority_queue<pair<long long, int>> qwait; // {-dp, ind}\n\nint main(){\n    int N, E, T;\n    scanf(\"%d%d%d\", &N, &E, &T);\n    for(int i=1; i<=N; i++) scanf(\"%lld\", &x[i]);\n    qwait.push({-T, 0});\n    for(int i=1; i<=N; i++){\n        while(!qwait.empty()){\n            if(T-2*(x[i]-x[qwait.top().second+1]) > 0) break;\n            int pos = qwait.top().second;\n            q.push(-(dp[pos] - 2*x[pos+1] - x[pos]));\n            qwait.pop();\n        }\n        dp[i] = dp[i-1] + x[i] - x[i-1] + T;\n        if(!qwait.empty()) dp[i] = min(dp[i], -qwait.top().first + x[i]);\n        if(!q.empty()) dp[i] = min(dp[i], -q.top() + 3*x[i]);\n        //printf(\"%lld \", dp[i]);\n        qwait.push({-T-dp[i]+x[i], i});\n    }\n    /*\n    for(int i=1; i<=N; i++){\n        for(int j=0; j<=i; j++) printf(\"%lld \", dp[i][j]);\n        printf(\"\\n\");\n    }\n     */\n    printf(\"%lld\", dp[N]+E-x[N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<long long> dq;\n  dq.push_back(0);\n  for(int i=0; i<n; i++){\n    while(dq.size() > 1 && (x[i] - x[dq.front()]) * 2 > t){\n      dp[i+1] = min( dp[i+1], dp[dq.front()] + 2*(x[i]-x[dq.front()]) );\n      dq.pop_front();\n    }\n    dp[i+1] = min(dp[i+1], dp[dq.front()] + t);\n    dq.push_back(i+1);\n  }\n\n  println(dp[n] + e);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=2e5+500;\nconst long long INF=1e18;\nint head,tail,n,E,T,x[N],q[N];\nlong long f[N],g1[N],g2[N];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    long long mi=INF;\n    for(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n    int j=0;g1[0]=-2*x[1],g2[0]=T;\n    int head=1,tail=1;q[1]=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(j<i&&2*x[j+1]<=2*x[i]-T)mi=min(mi,g1[j]),++j;\n        while(head<=tail&&q[head]<j)++head;\n        f[i]=3ll*x[i]+mi;\n        if(head<=tail)f[i]=min(f[i],x[i]+g2[q[head]]);\n        g1[i]=f[i]-x[i]-2*x[i+1];\n        g2[i]=f[i]+T-x[i];\n        while(head<=tail&&g2[i]<=g2[q[tail]])--tail;q[++tail]=i;\n    }\n    cout<<f[n]+E-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <vector>\n    #include <cstdio>\n    using namespace std;\n     \n    int n;\n    long long e,t;\n    long long x[100005];\n    long long dp[100005];\n     \n    int main(){\n      scanf(\"%d%lld%lld\", &n,&e,&t);\n      for(int i=0; i<n; ++i){\n        scanf(\"%lld\", &x[i]);\n        x[i]<<=1;\n      }\n      x[n] = e<<1;\n     \n      long long w = 1ll<<57;\n      for(int i=0, j=0; i<n; ++i){\n        while(j<i && t < (x[i] - x[j]) ){\n          w = min(w, dp[j] + (x[i] - x[j]) );\n          j++;\n        }\n        dp[i+1] = min(w, dp[j] + max((x[i]-x[j]) ,t));\n        w += (x[i+1] - x[i]);\n      }\n      printf(\"%lld\\n\", dp[n] + e);\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\n#define int ll\n\nconst int N = 1e5 + 10;\nconst int BINF = 1e18 + 10;\nint dp[N], a[N], t[4 * N][2];\n\nvoid update(int v, int l, int r, int need, int vl1, int vl2) {\n\tif (l == r) {\n\t\tt[v][0] = vl1;\n\t\tt[v][1] = vl2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (need <= mid) {\n\t\tupdate(2 * v, l, mid, need, vl1, vl2);\n\t}\n\telse {\n\t\tupdate(2 * v + 1, mid + 1, r, need, vl1, vl2);\n\t}\n\tt[v][0] = min(t[2 * v][0], t[2 * v + 1][0]);\n\tt[v][1] = min(t[2 * v][1], t[2 * v + 1][1]);\n}\n\nint get(int v, int l, int r, int a, int b, int id) {\n\tif (l > b || r < a) {\n\t\treturn BINF;\n\t}\n\tif (l >= a && r <= b) {\n\t\treturn t[v][id];\n\t}\n\tint mid = (l + r) / 2;\n\treturn min(get(2 * v, l,  mid, a, b, id), get(2 * v + 1, mid + 1, r, a, b, id));\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[1] = a[1] + t;\n\tupdate(1, 1, n, 1, 0, -2ll * a[1]);\n\tint ptr = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile (2ll * (a[i] - a[ptr + 1]) >= t) {\n\t\t\tptr++;\n\t\t}\n\t\t//cout << i << ' ' << ptr << '\\n';\n\t\tdp[i] = BINF;\n\t\tfor (int j = i; j <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[j - 1] + (a[i] - a[j - 1]) + max(2 * (a[i] - a[j]), t));\n\t\t}\n\t\tdp[i] = min(dp[i], get(1, 1, n, 1, ptr, 1) + 3ll * a[i]);\n\t\tdp[i] = min(dp[i], get(1, 1, n, ptr + 1, i - 1, 0) + t + a[i]);\n\t\tupdate(1, 1, n, i, dp[i - 1] - a[i - 1], dp[i - 1] - a[i - 1] - 2ll * a[i]);\n\t\t//cout << dp[i] << '\\n';\n\t}\n\t//cout << '\\n';\n\tcout << dp[n] + (e - a[n]) << '\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,e,t;\nll dp[N],x[N];\nstruct node {\n\tll s,fg;\n}nd[4*N];\nvoid upd(int p) {\n\tnd[p].s=min(nd[p+p].s,nd[p+p+1].s);\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v; nd[p].s+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nll query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return min(query(p+p,l,md,tl,md),query(p+p+1,md+1,r,md+1,tr));\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,1,n+1) scanf(\"%lld\",x+i);\n\tint r=0;\n\tmodify(1,0,n,0,0,t);\n\trep(i,1,n+1) {\n\t\tdp[i]=1ll<<60;\n\t\tmodify(1,0,n,0,r-1,3*(x[i]-x[i-1]));\n\t\tmodify(1,0,n,r,i-1,x[i]-x[i-1]);\n\t\twhile (2*(x[i]-x[r+1])>t) {\n\t\t\tmodify(1,0,n,r,r,(2*(x[i]-x[r+1]))-t);\n\t\t\tr++;\n\t\t}\n\t\tdp[i]=query(1,0,n,0,i-1);\n\t\tmodify(1,0,n,i,i,dp[i]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n#define MP make_pair \n#define PB push_back \n#define INF (1000000007) \n#define eps 1e-8\n#define MOD (1000003)\n#define IOS ios::sync_with_stdio(false)\n\ntypedef pair<int,int> pii ;\ntypedef pair<double,double> pdd ;\ntypedef long long ll ;\n\nll n,e,t;\nll dp[100005],p[100005];\nll mx=1e18;\nmultiset<ll>s;\n\nint main()\n{\n\tIOS;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tdp[0]=0;\n\tint pos=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif((p[i]-p[pos])*2>t) \n\t\t\t{\n\t\t\t\tmx=min(dp[pos-1]-p[pos]*2,mx);\n\t\t\t\ts.erase(dp[pos-1]);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mx+2*p[i]);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nlong long dp[N];\nint x[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, T;\n    cin>>n>>m>>T;\n\n    for (int i=1; i<=n; i++) {\n        dp[i] = 1e18;\n        cin>>x[i];\n        for (int l=1; l<=n; l++)\n            dp[i] = min(dp[i], dp[l-1] + max(2*x[i]-2*x[l], T));\n    }\n    cout<<dp[n]+m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N;\n\nll q (ll* x, int i) {\n        ll res = 1e18;\n        for (i += N+5; i; i /= 2) res = min(res, x[i]);\n        return res;\n}\n\nvoid u (ll* x, int l, int r, ll mn) {\n        for (l += N+5, r += N+5; l<r; l /= 2, r /= 2) {\n                if (l&1) x[l] = min(x[l], mn), l++;\n                if (r&1) --r, x[r] = min(x[r], mn);\n        }\n}\n\nll E, T, x[100100], dp[100100], close[200200], far[200200];\n\nint main () {\n        scanf(\"%d %lld %lld\", &N, &E, &T);\n        fo(i, 0, N) scanf(\"%lld\", &x[i]);\n        x[N] = E;\n\n        fo(i, 0, 200200) close[i] = far[i] = 1e18;\n\n        dp[0] = x[0];\n        fo(i, 0, N) {\n                int lo = i, hi = N-1, mid, v = -1;\n                while (lo <= hi) {\n                        mid = (lo+hi)/2;\n                        if (2*(x[mid]-x[i]) <= T) lo = mid+1, v = mid;\n                        else hi = mid-1;\n                }\n\n                u(close, i+1, v+2, dp[i] + T - x[i]);\n                u(far, v+2, N+1, dp[i] - 3*x[i]);\n\n                dp[i+1] = min(q(close, i+1) + x[i], q(far, i+1) + 3*x[i]);\n                dp[i+1] += x[i+1] - x[i];\n        }\n\n        printf(\"%lld\\n\", dp[N]);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nlong long e, t, dp[MAXN], mn = 1e17;\nint n, x[MAXN];\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tdp[1] = t;\n\tint j = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile ((x[i] - x[j]) * 2 > t) {\n\t\t\tmn = min(mn, dp[j - 1] - 2 * x[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i] = min(mn + 2 * x[i], dp[j - 1] + t);\n\t}\n\tcout << dp[n] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint x[2005];\nlong long dp[2005][2005];\n\nlong long min(long long a, long long b){ return a < b ? a : b; }\n\nint main(){\n    int N, E, T;\n    scanf(\"%d%d%d\", &N, &E, &T);\n    for(int i=1; i<=N; i++) scanf(\"%d\", &x[i]);\n    for(int i=1; i<=N; i++){\n        for(int last=0; last<i; last++) dp[i][last] = dp[i-1][last] + x[i] - x[i-1];\n        dp[i][i] = 1e18;\n        for(int pick=i; pick>=1; pick--){\n            long long ptime = 2*(x[i]-x[pick]);\n            long long addcst = T-ptime;\n            if(addcst < 0) addcst = 0;\n            dp[i][i] = min(dp[i][i], dp[i][pick-1] + addcst + 2*(x[i] - x[pick]));\n        }\n    }\n    /*\n    for(int i=1; i<=N; i++){\n        for(int j=0; j<=i; j++) printf(\"%lld \", dp[i][j]);\n        printf(\"\\n\");\n    }\n     */\n    printf(\"%lld\", dp[N][N]+E-x[N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 4;\n\nint main()\n{\n    int n, e, t;\n    cin >> n >> e >> t;\n\n    vector<int> x(n+1);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n    x[n] = e;\n\n    vector<long long> dp(n+1, INF);\n    dp[0] = x[0];\n    int j = 0;\n    long long tmp = INF;\n    for(int i=0; i<n; ++i){\n        while(j <= i && (x[i] - x[j]) * 2LL > t){\n            tmp = min(tmp, dp[j] - x[j] * 3LL);\n            ++ j;\n        }\n        dp[i+1] = min(tmp + x[i] * 3LL, dp[j] + t) + (x[i+1] - x[i]);\n    }\n    cout << dp[n] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  using F = function<T(T&, T&)>;\n  int n;\n  vector<T > dat;\n  T e; // �P�ʌ�\n  F query_func;\n  F update_func;\n  \n  SegmentTree(vector<T> a, F query_func, F update_func, T e) :n(a.size()), query_func(query_func), update_func(update_func), e(e) {\n    dat.resize(4 * n);\n    init(0, 0, n, a);\n  }\n\n  void init(int k, int l, int r, vector<T> &a) {\n    if (r - l == 1) {\n      dat[k] = a[l];\n    }\n    else {\n      int lch = 2 * k + 1, rch = 2 * k + 2;\n      init(lch, l, (l + r) / 2, a);\n      init(rch, (l + r) / 2, r, a);\n      dat[k] = query_func(dat[lch], dat[rch]);\n    }\n  }\n\n  //k�Ԗڂ̒l��a�ɕύX\n  void update(int k, T a, int v, int l, int r) {\n    if (r - l == 1) {\n      dat[v] = update_func(dat[v], a);\n    }\n    else {\n      if (k < (l + r) / 2)\n        update(k, a, 2 * v + 1, l, (l + r) / 2);\n      else {\n        update(k, a, 2 * v + 2, (l + r) / 2, r);\n      }\n      dat[v] = query_func(dat[v * 2 + 1], dat[v * 2 + 2]);\n    }\n  }\n    \n\n  //[a,b)�̍ŏ��l�����߂�\n  //���̂ق��̈����͌v�Z�̊ȒP�̂��߂̈���\n  //k�͐ړ_�̔ԍ�,l,r�͂��̐ړ_��[l,r)�ɑΉ����Ă��邱�Ƃ�\\��\n  //�]���āA�O�����query(a,b,0,0,n)�Ƃ��Ă��\n  T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return e;\n    }\n    if (a <= l && r <= b) {\n      return dat[k];\n    }\n    else {\n      T ul = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T ur = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return query_func(ul, ur);\n    }\n  }\n\n  // �����𖞂����ĉE��T��\n  int find(int a, int b, int k, int l, int r, int x) {\n    // �����𒼂�\n    if (dat[k] < x || r <= a || b <= l) return -1;\n    if (l + 1 == r) {\n      // �����𒼂�\n      if (dat[k] >= x) return l;\n      else return -1;\n    }\n    int rv = find(a, b, 2 * k + 2, (l + r) / 2, r, x);\n    if (rv != -1) return rv;\n    return find(a, b, 2 * k + 1, l, (l + r) / 2, x);\n  }\n};\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    auto f = [](ll a, ll b) {return min(a, b);};\n    auto g = [](ll, ll b) {return b;};\n    SegmentTree<ll> seg(vl(n + 1, INF), f, g, INF);\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    seg.update(0, dp[0] + t - x[0], 0, 0, seg.n);\n    ll mi = INF;\n    int ki = 0;\n    rep1 (i, n) {\n        int px = x[i] - t / 2 - 1;\n        auto itr = upper_bound(all(x), px);\n        itr--;\n        int pi = itr - x.begin();\n        pi -= 5;\n        rep (_, 10) {\n            if (pi >= 0) {\n                if ((x[i] - x[pi + 1]) * 2 < t) break;\n                // dp[i] = dp[pi] + (x[pi + 1] - x[pi]) + t + (x[i] - x[pi + 1]);\n                chmin(dp[i], dp[pi] + (x[pi + 1] - x[pi]) + (x[i] - x[pi + 1]) * 3);\n            }\n            pi++;\n        }\n        DEBUG(pi);\n\n        ll mi = seg.query(pi, i, 0, 0, seg.n);\n        chmin(dp[i], mi + x[i]);\n        if (i != n) {\n            seg.update(i, dp[i] + t - x[i], 0, 0, seg.n);\n        }\n    }\n    DEBUG_VEC(dp);\n\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  int query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    int left = query(ls, l, mid, L, R);\n    int right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  int query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    int left = query(ls, l, mid, L, R);\n    int right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nint main() {\n  scanf(\"%d%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i, pos = i;\n    while (low <= high) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 <= T) {\n        high = mid - 1, pos = mid;\n      }\n      else {\n        low = mid + 1;\n      }\n    }\n    if (pos) --pos;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn =  1e5 + 5;\n\nint n, E, T, pos;\nint a[maxn];\nll f[maxn], mn = 1e18;\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &E, &T);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n    {\n        while(T < 2 * (a[i] - a[pos + 1]))\n        {\n            mn = min(mn, f[pos] - 2 * a[pos + 1]);\n            pos++;\n        }\n        f[i] = min(f[i - 1] + T, mn + 2 * a[i]);\n        f[i] = min(f[pos] + T, f[i]);\n    }\n    printf(\"%lld\\n\", f[n] + E);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, E, T, r;\nint a[maxn];\nll Min1, Min2 = 1e18, f[maxn];\nint main()\n{\n\tmultiset<ll> S; \n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tS.insert(-a[1]);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\twhile((a[i] - a[r + 1]) * 2 >= T)\n\t\t{\n\t\t\tMin2 = min(Min2, f[r] - 2 * a[r + 1]);\n\t\t\tS.erase(S.find(f[r] - a[r + 1]));\n\t\t\t++r;\n\t\t}\n\t\tf[i] = min(Min1 + 1ll * i * T, Min2 + 2 * a[i]);\n\t\tif(!S.empty()) f[i] = min(f[i], *S.begin() + T + a[i]);\n\t\tMin1 = min(Min1, f[i] - 1ll * i * T);\n\t\tS.insert(f[i] - a[i + 1]); \n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans  << \"\\n\";\n\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pr pair<int,int>\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#ifdef DEBUG\n    #define GG(x) assert(x)\n#else\n    #define GG(x) (x)\n#endif\nnamespace mine\n{\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e>=0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e5+10;\n\n    ll f[N],a[N];\n    void main()\n\t{\n        ll n=qread(),E=qread(),T=qread();fo(i,1,n) a[i]=qread();a[n+1]=E;\n        memset(f,0x3f,sizeof f);f[0]=0;ll pre=bin(45);\n        for(int j=0,i=1;i<=n;i++)\n        {\n            while(a[j+1]+a[j+1]<=a[i]+a[i]-T) chmin(pre,f[j]-a[j+1]-a[j+1]),j++;\n            assert(j<=i);assert(f[i-1]<=f[i]);\n            f[i]=min(pre+a[i]+a[i],f[j]+T);\n        }\n        write(f[n]+E);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  1000000007;\n\n\n     signed main(){\n   int n,e,t;\n   cin>>n>>e>>t;\n   int x[n+1],ans[n+1];\n   for(int i=1;i<=n;i++)cin>>x[i];\n   ans[0]=e;int j=1,ansx=MOD*MOD;bool used[n+1]={};\n   priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\n   for(int i=1;i<=n;i++){\n     que.push(make_pair(2*x[i]+t,i));\n     while(que.top().first<=2*x[i]){\n       ansx=min(ans[que.top().second -1]-2*x[que.top().second],ansx);\n       used[que.top().second]=true;\n       que.pop();\n     }\n     while(used[j])j++;\n     ans[i]=min(ans[j-1]+t,ansx+2*x[i]);\n  \n   }\n\n   cout<<ans[n]<<endl;\n   \n                  \n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+15&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)(i-j)*(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* \n\tبسم الله الرحمن الرحیم\n\n\t(; طلا یک جهانی\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst long long INF = 1e18;\nconst int MAX_N = 100 * 1000 + 5;\nint n, e, t, a[MAX_N];\nlong long dp[MAX_N], seg[2][4 * MAX_N];\n\nvoid read_input() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n}\n\nvoid modify(int w, int p, long long x, int id = 1, int l = 0, int r = n + 1) {\n\tif (l == r - 1) {\n\t\tseg[w][id] = min(seg[w][id], x);\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (p < mid)\n\t\tmodify(w, p, x, id * 2, l, mid);\n\telse\n\t\tmodify(w, p, x, id*2+1, mid, r);\n\tseg[w][id] = min(seg[w][id * 2], seg[w][id*2+1]);\n}\n\nlong long get(int w, int x, int y, int id = 1, int l = 0, int r = n + 1) {\n\tif (x >= r || y <= l)\n\t\treturn INF;\n\tif (x <= l && y >= r)\n\t\treturn seg[w][id];\n\tint mid = (l + r) / 2;\n\treturn min(get(w, x, y, id * 2, l, mid), get(w, x, y, id*2+1, mid, r));\n}\n\nvoid solve() {\n\tmemset(seg, 63, sizeof seg);\n\tmodify(0, 0, 0);\n\tmodify(1, 0, -2 * a[1]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint p = lower_bound(a, a + n + 1, a[i] - t / 2) - a - 1;\n//\t\tcerr << \"* \" << i << \" : \" << p << endl;\n\t\tdp[i] = min(get(0, p, n + 1) + a[i] + t, get(1, 0, p) + 3 * a[i]);\n\t\tmodify(0, i, dp[i] - a[i]);\n\t\tmodify(1, i, dp[i] - 2 * a[i + 1] - a[i]);\n\t}\n}\n\nvoid print_output() {\n//\tfor (int i = 1; i <= n; i++)\n//\t\tcerr << i << \" : \" << dp[i] << endl;\n\tcout << dp[n] + e - a[n];\n}\n\nint32_t main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tread_input();\n\tsolve();\n\tprint_output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b), 1 : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b), 1 : 0)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n\n#define maxn 100010\n#define lowbit(_x) ((_x) & (-(_x)))\ntypedef long long ll;\ntypedef double db;\n\nconst ll inf = 0x7ffffffffff;\nll f[maxn];\nint x[maxn], hash[maxn], hcnt;\nll tr1[maxn], tr2[maxn];\nvoid modify1(int pos, ll val)\n{\n\tfor (; pos <= hcnt; pos += lowbit(pos)) cmin(tr1[pos], val);\n}\nvoid modify2(int pos, ll val)\n{\n\tfor (; pos; pos -= lowbit(pos)) cmin(tr2[pos], val);\n}\nll query1(int pos)\n{\n\tll ret = inf;\n\tfor (; pos; pos -= lowbit(pos)) cmin(ret, tr1[pos]);\n\treturn ret;\n}\nll query2(int pos)\n{\n\tll ret = inf;\n\tfor (; pos <= hcnt; pos += lowbit(pos)) cmin(ret, tr2[pos]);\n\treturn ret;\n}\nint main()\n{\n\tint n, E, T; scanf(\"%d%d%d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\tfor (int i = 0; i <= n; ++i) hash[++hcnt] = 2 * x[i];\n\n\tmemset(tr1, 63, sizeof (tr1));\n\tmemset(tr2, 63, sizeof (tr2));\n\tf[0] = 0;\n\tmodify1(2, -2 * x[1]);\n\tmodify2(2, 0);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = inf;\n\n\t\tint pos = std::upper_bound(hash + 1, hash + hcnt + 1, 2 * x[i] - T) - hash - 1;\n//\t\tprintf(\"pos %d\\n\", pos);\n\t\tll tmp = query1(pos) + 3ll * x[i];\n\t\tcmin(f[i], tmp);\n//\t\tprintf(\"tmp %lld\\n\", tmp);\n\n\t\tpos = std::lower_bound(hash + 1, hash + hcnt + 1, 2 * x[i] - T) - hash;\n//\t\tprintf(\"pos %d\\n\", pos);\n\t\ttmp = query2(pos) + T + x[i];\n\t\tcmin(f[i], tmp);\n//\t\tprintf(\"tmp %lld\\n\", tmp);\n\t\t\n\t\tmodify1(i + 2, f[i] - 2ll * x[i + 1] - x[i]);\n\t\tmodify2(i + 2, f[i] - x[i]);\n\t\t\n//\t\tprintf(\"f[%d] = %lld\\n\", i, f[i]);\n\t}\n\tprintf(\"%lld\\n\", f[n] + E - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Nurbakyt Madibek\n// Look at my code! IT'S AWESOME\n\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <algorithm>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <cassert>\n#include <unordered_map>\n#include <bitset>\n#include <unordered_set>\n\nusing namespace std;\n\n#define pb push_back\n#define pp pop_back\n#define f first\n#define s second\n#define mp make_pair\n#define sz(a) (int)((a).size())\n#ifdef _WIN32\n#  define I64 \"%I64d\"\n#else\n#  define I64 \"%lld\"\n#endif\n#define fname \".\"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int, int > pi;\ntypedef pair < int, ull > pu;\ntypedef pair < ll, ll > pl;\n\nconst int inf = (int)1e9 + 123;\nconst ll infl = (ll)1e18 + 123;\nconst double eps = 1e-9;\n\nconst int MAX_N = (int)1e5 + 5;\nconst int mod = (int)1e9 + 7;\n\nint n;\nint t, e;\nint x[MAX_N];\n\nll dp[MAX_N];\n\nset < pl > q, r;\n\nvoid add(ll x, ll y) {\n    q.insert(mp(x - y, x));\n\n    auto it = r.upper_bound(mp(x - y, infl));\n    if (it != r.begin()) {\n        it--;\n        if (it -> s <= y)\n            return;\n    }\n    \n    while(1) {\n        auto it = r.lower_bound(mp(x - y, -inf));\n        if (it != r.end() && it -> s >= y) {\n            r.erase(it);\n        } else {\n            break;\n        }\n    }\n    r.insert(mp(x - y, y));\n}\n\nll findF(ll x) {\n    auto it = q.lower_bound(mp(x, -inf));\n    if (it != q.end())\n        return it -> s;\n    return infl;\n}\n\nll findS(ll x) {\n    auto it = r.lower_bound(mp(x, -inf));\n    if (it != r.begin()) {\n        it--;\n        return it -> s;\n    }\n    return infl;\n}\n\nint main() {\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &x[i]);\n    x[0] = dp[0] = 0;\n    for (int i = 1; i <= n; i++)\n        dp[i] = infl;\n    \n//    for (int i = 0; i < n; i++) {\n//        for (int j = i + 1; j <= n; j++) {\n//            ll now = max(dp[i] + x[j] - x[i] + t, dp[i] + x[j] - x[i] + 2ll * (x[j] - x[i + 1]));\n//            dp[j] = min(dp[j], now);\n//        }\n//    }\n    \n    add(dp[0] - x[0] + t, dp[0] - x[0] - 2ll * x[1]);\n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = min(findF(2ll * x[i]) + x[i], findS(2ll * x[i]) + 3ll * x[i]);\n\n        if (i != n)\n            add(dp[i] - x[i] + t, dp[i] - x[i] - 2ll * x[i + 1]);\n    }\n\n    printf(\"%lld\\n\", dp[n] + e - x[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(-inputs[1], 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i],now_cost + 2 * inputs[i]);\n\t\twhile (next.empty() == false&&2 * (inputs[i] - inputs[next.top().second])> t) {\n\t\t\tnext.pop();\n\t\t}\n\t\t\n\t\tif (next.empty() == false) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\t\n\t\tif(i != n-1)\n\t\t\tnext.push(make_pair(dp[i] - 2* inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[114514];\nlint dp[114514];\nint main()\n{\n\tint n,e,t,now=0;lint out=0;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\trep(i,n) scanf(\"%d\",&x[i]);x[n]=2001001001;\n\trep(i,n+10) dp[i]=1145141919810893LL;dp[0]=0;\n\trep(i,n) REP(j,i+1,n+1){\n\t\tdp[j]=min(dp[j],dp[i]+max(t,2*(x[j-1]-x[i])));\n\t}\n\t//out+=e-x[n-1];\n\tout=e+dp[n];\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100010\nusing namespace std;\nint n,t;\nlong long m;\nlong long f[N],x[N]; \nint main()\n{\n\tscanf(\"%d%lld%d\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]),f[i]=100000000000;\n\tlong long minn=100000000000;\n\tint r=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(r<i && (x[i]-x[r+1])*2>=t)\n\t\t{\n\t\t\tminn=min(minn,f[r]-2*x[r+1]);\n\t\t\tr++;\n\t\t}\n\t\tf[i]=min(f[r]+t,minn+2*x[i]);\n\t}\n\tprintf(\"%lld\",f[n]+m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid M. Note that constructing this tree requires the identity\n * element of M and the operation of M.\n * Header requirement: vector, algorithm\n * Verified by AtCoder ABC017-D (http://abc017.contest.atcoder.jp/submissions/660402)\n */\ntemplate<class I, class BiOp = I (*) (I, I)>\nclass SegTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\npublic:\n  SegTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_) { n *= 2; } // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  void update_array(int k, int len, const I *vals) {\n    for (int i = 0; i < len; ++i) {\n      update(k + i, vals[i]);\n    }\n  }\n  /*\n    Updates all elements. O(n)\n   */\n  void update_all(const I *vals, int len) {\n    for (int k = 0; k < std::min(n, len); ++k) {\n      dat[k + n - 1] = vals[k];\n    }\n    for (int k = std::min(n, len); k < n; ++k) {\n      dat[k + n - 1] = e;\n    }\n    for (int b = n / 2; b >= 1; b /= 2) {\n      for (int k = 0; k < b; ++k) {\n\tdat[k + b - 1] = op(dat[k * 2 + b * 2 - 1], dat[k * 2 + b * 2]);\n      }\n    }\n  }\n  /* l,r are for simplicity */\n  I querySub(int a, int b, int k, int l, int r) const {\n    // [a,b) and  [l,r) intersects?\n    if (r <= a || b <= l) return e;\n    if (a <= l && r <= b) return dat[k];\n    I vl = querySub(a, b, 2 * k + 1, l, (l + r) / 2);\n    I vr = querySub(a, b, 2 * k + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n  /* [a, b] (note: inclusive) */\n  I query(int a, int b) const {\n    return querySub(a, b + 1, 0, 0, n);\n  }\n};\n\n\nconst int N = 200100;\nll dp[N];\nconst ll inf = 1e16;\n\nstruct max_fun {\n  ll operator()(ll x, ll y) const {\n    return min(x, y);\n  }\n};\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  assert (n < N);\n  VL x(n);\n  SegTree<ll, max_fun> raw(n + 1, max_fun(), inf); // dp[i]\n  SegTree<ll, max_fun> boiled(n + 1, max_fun(), inf); // dp[i] - 2 * x[i]\n  REP(i, 0, n) {\n    cin >> x[i];\n  }\n  dp[0] = 0;\n  raw.update(0, 0);\n  boiled.update(0, -2 * x[0]);\n  REP(i, 0, n) {\n    // Compute the range of j s.t. t <= 2 * (x[i] - x[j]) (0 <= j <= i)\n    int j_boundary =\n      upper_bound(x.begin(), x.begin() + i + 1, x[i] - (t+1)/2) - x.begin();\n    ll ret = inf;\n    ret = min(ret, boiled.query(0, j_boundary - 1) + 2 * x[i]);\n    ret = min(ret, raw.query(j_boundary, i) + t);\n    dp[i + 1] = ret;\n    raw.update(i + 1, ret);\n    if (i < n - 1) {\n      boiled.update(i + 1, ret - 2 * x[i + 1]);\n    }\n  }\n  cout << dp[n] + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T;\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\twhile(opt + 1 <= i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tdp[i] = cost(i , opt);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nlong long int dp2[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint p=0,mini=1e9;\n\tdp[0]=t;\n\tfor(int i=1;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i-1;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tif((x[i]-x[p+1])*2>t)\n\t\tp++;\n\t\tdp[i]=min(x[i]*2+dp2[p-1],t+dp[p]);\n\t\tif(i!=0)\n\t\tdp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n\t\telse\n\t\tdp2[i]=dp[i]-x[i+1]*2;\n\t//\tprintf(\"%d\\n\",dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __SEGMENT_TREE_H__\n#define __SEGMENT_TREE_H__\n\n/* updated: 2019-10-05 */\n\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <limits>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <sstream>\n\n/*-- てんぷれ --*/\nstruct HogeMonoid {\n\tusing Type = int;\n\tstatic Type identity() {\n\t\treturn Type();\n\t}\n\tstatic Type operate(const Type& left, const Type& right) {\n\t\treturn Type();\n\t}\n};\n\n/*--------------*/\n\nnamespace Monoid {\n\ttemplate <class T>\n\tstruct Sum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn T();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn left + right;\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Minimum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::max();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::min(left, right);\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Maximum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::min();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::max(left, right);\n\t\t}\n\t};\n}\n\n/* 注意: コンストラクタの引数は size でない */\ntemplate <class Monoid>\nclass SegmentTree {\n\tusing T = typename Monoid::Type;\n\n\tconst int level_m;\t\t// 段数 - 1\n\tconst size_t size_m;\t// 1 << level_m\n\tstd::vector<T> arr_m;\n\n\tstatic T identity();\n\tstatic T operate(const T& left, const T& right);\n\tbool isValidIndex(size_t pos) const;\n\t\n\tstatic const int Default = -1;\n\npublic:\n\tSegmentTree(int level);\n\n\tvoid update(size_t pos, const T& value);\n\tT query(size_t left, size_t right) const;\n\tT get(size_t pos) const;\n\tvoid debug(int level = Default, int cell_width = 4) const;\n};\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::identity() {\n\treturn Monoid::identity();\n}\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::operate(const T& left, const T& right) {\n\treturn Monoid::operate(left, right);\n}\n\ntemplate<class Monoid>\ninline bool SegmentTree<Monoid>::isValidIndex(size_t pos) const {\n\treturn pos >= 0 && pos < size_m;\n}\n\n/* 1 << level 要素の segment tree を作成 */\ntemplate<class Monoid>\nSegmentTree<Monoid>::SegmentTree(int level)\n\t: level_m(level), size_m(1 << level) {\n\tassert(level < 32);\n\tarr_m.resize(size_m * 2, identity());\n}\n\n/* pos 番目の要素を value に書き換える */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::update(size_t pos, const T& value) {\n\tpos += size_m;\n\tarr_m[pos] = value;\n\tpos >>= 1;\n\twhile (pos > 0) {\n\t\tarr_m[pos] = operate(arr_m[pos * 2], arr_m[pos * 2 + 1]);\n\t\tpos >>= 1;\n\t}\n}\n\n/* [left, right) に存在する全要素の(指定した演算に関する)積をとる */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::query(size_t left, size_t right) const {\n\tassert(left <= right);\n\n\tT tmp_left = identity();\n\tT tmp_right = identity();\n\tleft += size_m;\n\tright += size_m;\n\twhile (left < right) {\n\t\tif (left & 1) tmp_left = operate(tmp_left, arr_m[left++]);\n\t\tif (right & 1) tmp_right = operate(arr_m[--right], tmp_right);\n\t\tleft >>= 1;\n\t\tright >>= 1;\n\t}\n\n\treturn operate(tmp_left, tmp_right);\n}\n\n/* pos 番目の要素を直接取得 */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::get(size_t pos) const {\n\treturn arr_m[size_m + pos];\n}\n\n/* デバッグ出力用; level = -1 とすると全要素出力 */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::debug(int level, int cell_width) const {\n\t/* 値 value を幅 max_length になるように成形して文字列化 */\n\tauto to_str_fixed = [](const T& value, int max_length) -> std::string {\n\t\tstd::ostringstream osst;\n\t\tosst << value;\n\n\t\tstd::string str = osst.str();\n\t\tstd::string output;\n\t\tif (str.size() > max_length) {\n\t\t\tfor (int i = 0; i < max_length; ++i) {\n\t\t\t\toutput += '#';\n\t\t\t}\n\t\t} else {\n\t\t\tconst int remain_length = max_length - str.size();\n\t\t\tconst int right_blank = remain_length / 2;\n\t\t\tconst int left_blank = remain_length - right_blank;\n\t\t\tfor (int i = 0; i < left_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t\toutput += str;\n\t\t\tfor (int i = 0; i < right_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\n\tif (level == Default) {\t\t\t// デフォルト値への対処\n\t\tlevel = level_m;\n\t}\n\n\tif (level > level_m) {\n\t\tlevel = level_m;\n\t}\n\n\tstd::vector<std::string> output_strs;\n\n\tfor (int lev = 0; lev <= level; ++lev) {\n\t\tstd::string output;\n\t\tconst int front = size_m >> lev;\n\n\t\toutput += '|';\n\t\tfor (int i = 0; i < (1 << (level - lev)); ++i) {\n\t\t\toutput += to_str_fixed(arr_m[front + i], cell_width);\n\t\t\toutput += '|';\n\t\t}\n\t\toutput_strs.push_back(output);\n\n\t\tcell_width = cell_width * 2 + 1;\n\t}\n\n\treverse(output_strs.begin(), output_strs.end());\n\tfor (const std::string& output : output_strs) {\n\t\tstd::cout << output << std::endl;\n\t}\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nLL N, E, T;\nLL X[100001];\nLL DP[100002];\nSegmentTree<Monoid::Minimum<LL>> G(18);\nSegmentTree<Monoid::Minimum<LL>> H(18);\nint main() {\n\tcin >> N >> E >> T;\n\tREP(i, 0, N) {\n\t\tcin >> X[i + 1];\n\t}\n\n\tG.update(0, -2 * X[1]);\n\tH.update(0, 0);\n\tREP(i, 1, N + 1) {\n\t\tint k = max<int>(0, lower_bound(X, X + N + 1, X[i] - T / 2) - X - 1);\n\t\tLL a = 2 * X[i] + min(INFLL, G.query(0, k));\n\t\tLL b = T + min(INFLL, H.query(k, i));\n\t\tLL val = X[i] + min(a, b);\n\t\tDP[i] = val;\n\t\tG.update(i, val - X[i] - 2 * X[i + 1]);\n\t\tH.update(i, val - X[i]);\n\t}\n\tcout << DP[N] + (E - X[N]) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\nconst LL INF = 123456789012345;\n\nconst int ST_MAX = (1 << 20);\n\ntemplate <class T> class ST{\n\tT x[ST_MAX * 2];\n\t\n\tT eval(T a , T b){\n\t\treturn min(a , b);\n\t}\n\t\n\tvoid ren(int a){\n\t\tx[a] = eval(x[2 * a] , x[2 * a + 1]);\n\t\tif(a > 0) ren(a / 2);\n\t}\n\t\n\tT read_ST(int a , int b , int e , int s , int f){\n\t\tif(e <= s || f <= b) return INF;\n\t\tif(s <= b && e <= f) return x[a];\n\t\treturn eval(read_ST(2 * a , b , (b + e) / 2 , s , f) , read_ST(2 * a + 1 , (b + e) / 2 , e , s , f));\n\t}\n\t\npublic:\n\t\n\tST(){\n\t\tfill(x , x + 2 * ST_MAX , INF);\n\t}\n\t\n\tvoid put(int a , T b){\n\t\tx[a + ST_MAX] = b;\n\t\tren((a + ST_MAX) / 2);\n\t}\n\t\n\tT get(int s , int f){\n\t\treturn read_ST(1 , 0 , ST_MAX , s , f);\n\t}\n};\n\nST<LL> b;\nint N , E , T;\nLL x[100010];\nLL dp[100010];\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &E , &T);\n\trepp(i,1,N+1){\n\t\tscanf(\"%lld\" , x + i);\n\t}\n\tLL a = INF;\n\tb.put(0,0);\n\tint z = 1;\n\trepp(i,1,N+1){\n\t\twhile(z < i && T <= 2 * (x[i] - x[z])){\n\t\t\ta = min(a , dp[z-1] - 2 * x[z] - x[z-1]);\n\t\t\t++z;\n\t\t}\n\t\tdp[i] = min(a + 3 * x[i] , b.get(z-1,i) + (LL)T + x[i]);\n\t\tb.put(i , dp[i] - x[i]);\n\t}\n\tprintf(\"%lld\\n\" , dp[N] + (LL)E - x[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long n,t,e,x[111111],mnp,pos,dp[111111];\nmultiset<long long> s;\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tdp[0]=0;\n\tmnp=1e18;\n\tpos=1;\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif (2*(x[i]-x[pos])>t) \n\t\t\t{\n\t\t\t\tmnp=min(mnp,dp[pos-1]-2*x[pos]);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mnp+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint last=0,lastt=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\t//if(lastt!=0)\n\t\t//dp[i]=min(dp[i],(x[i]-x[last+1])*2+dp[last]);\n\t\tfor(int j=lastt;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif((x[i]-x[j+1])*2<t)\n\t\t\t{\t\n\t\t\t\tlastt=max(j-1,0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//if(dp[i]==(x[i]-x[j+1])*2+dp[j])\n\t\t\t//last=j;\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <functional>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <stdio.h>\n#include <memory.h>\n#include <sstream>\n#include <iterator>\n\nint main () {\n\tint n, t, e;\n\tscanf (\"%d%d%d\", &n, &e, &t);\n\tstd::vector <int> v (n);\n\tstd::vector <char> used(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &v[i]);\n\t\tused[i] = 0;\n\t}\n\tlong long tt = v[0];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (used[i]) {\n\t\t\ttt += v[i + 1] - v[i];\n\t\t} else {\n\t\t\tint cur = v[i] + t - 1;\n\t\t\tint j = std::lower_bound (v.begin() + i, v.end(), cur) - (v.begin() + i);\n\t\t\tif (j == v.size()) j--;\n\t\t\tfor (int ii = i; ii <= j; ii++)\n\t\t\t\tused[ii] = true;\n\t\t\ttt += std::max(t, (v[j] - v[i]) * 2);\n\t\t\ttt += v[i + 1] - v[i];\n\t\t}\n\t}\n\tif (used[n - 1] == false) {\n\t\ttt += t;\n\t}\n\ttt += e - v[n - 1];\n\tstd::cout << tt << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "//By Don4ick\n//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define y1 qwer1234\n\nconst double PI = acos(-1.0);\nconst int DIR = 4;\nconst int X[] = {1, 0, -1, 0};\nconst int Y[] = {0, 1, 0, -1};\n\nusing namespace std;\n\nconst int N = 1e5 + 123;\n\nll n, t, e, dp[N], x[N];\n\nll calc(int l,int r){\n\treturn dp[l] + 3 * (x[r] - x[l]) + max(0ll, t - 2 * (x[r] - x[l]));\n}\nint main()\n{\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(NULL);\n\t//cout.tie(NULL);\n\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tcin >> n;\n\tcin >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\t\n\tdp[1] = x[1];\n\tx[n + 1] = e;\n\tfor(int i = 1, j = 1; i <= n; i++){\n\t\twhile(j + 1 <= i && calc(j, i) > calc(j + 1, i))\n\t\t\tj++;\n\t\tdp[i + 1] = calc(j, i) + x[i + 1] - x[i];\n\t}\n\tcout << dp[n + 1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n;\nll E, T;\n\nll a[300000];\nint S;\n\nll it[300000];\nll d[300000];\nll e[300000];\n\nvoid update(int x)\n{\n\tfor(x/=2;x>0;x/=2) it[x]=min(it[x*2], it[x*2+1]);\n}\n\nll getmin(int x, int y)\n{\n\tll mi=MAX2;\n\twhile(x <= y)\n\t{\n\t\tif(x%2 == 1) mi=min(mi, it[x++]);\n\t\tif(y%2 == 0) mi=min(mi, it[y--]);\n\t\tx/=2, y/=2;\n\t}\n\treturn mi;\n}\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>E>>T;\n\tfor(i=0;i<n;i++) scanf(\"%lld\", &a[i]);\n\tfor(S=1;S<n;S*=2);\n\td[0]=a[0]+T;\n\te[0]=0-2*a[0]-0;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tll u=a[i]-T/2;\n\t\tint x=lower_bound(a, a+n, u)-a;\n\t\td[i]=MAX2;\n\t\tif(x > 0) d[i]=min(d[i], e[x-1]+3*a[i]);\n\t\td[i]=min(d[i], getmin(S+x, S+i-1)+a[i]+T);\n\t\td[i]=min(d[i], d[i-1]+a[i]-a[i-1]+T);\n\t\te[i]=d[i-1]-2*a[i]-a[i-1];\n\t\tit[S+i]=d[i-1]-a[i-1];\n\t\tupdate(S+i);\n\t}\n\tcout<<d[n-1]+E-a[n-1]<<endl;\n\treturn 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\td[0]=0;\n\tfoor(i,1,N){\n\t\tll t=e18;\n\t\tfoor(j,1,i){\n\t\t\tchmin(t,d[j-1]+max(2*(x[i]-x[j]),T));\n\t\t}\n\t\td[i]=t;\n\t}\n\tprint(d[N]+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        // if(j-1 > 0){\n            tmp1 = sgt2.query(0, min(j-1, i-1))+x[i]*3;\n        // }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 3123456\nint n,m,t,x[SZ];\nchar ch,B[1<<20],*S=B,*T=B;\n#define getc() (S==T&&(T=(S=B)+fread(B,1,1<<20,stdin),S==T)?0:*S++)\n#define isd(c) (c>='0'&&c<='9')\nint aa,bb;int F(){\n\tint x; scanf(\"%d\",&x); return x;\n    while(ch=getc(),!isd(ch)&&ch!='-');ch=='-'?aa=bb=0:(aa=ch-'0',bb=1);\n    while(ch=getc(),isd(ch))aa=aa*10+ch-'0';return bb?aa:-aa;\n}\n#define gi F()\n#define BUFSIZE 5000000\nnamespace fob {char b[BUFSIZE]={},*f=b,*g=b+BUFSIZE-2;}\n#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)\n#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)\nstruct foce {~foce() {pob; fflush(stdout);}} _foce;\nnamespace ib {char b[100];}\ninline void pll(ll x)\n{\n    if(x==0) {pc(48); return;}\n    //if(x<0) {pc('-'); x=-x;} //如果有负数就加上 \n    char *s=ib::b;\n    while(x) *(++s)=x%10, x/=10;\n    while(s!=ib::b) pc((*(s--))+48);\n}\nll qf[SZ],f[SZ];\nint main()\n{\n\tn=gi,m=gi,t=gi;\n\tfor(int i=1;i<=n;i++) x[i]=gi;\n\tint p=0; f[0]=qf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(p<=2*(x[i]-x[p+1])&&p<i) ++p;\n\t\tll c=1e18;\n\t\tif(p<i)\n\t\t\tc=min(c,f[p]+max(t,2*(x[i]-x[p+1])));\n\t\tif(p) c=min(c,qf[p-1]+2*x[i]);\n\t\tf[i]=c;\n\t\tqf[i]=min(qf[i-1],f[i]-2LL*x[i+1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint n;\nlong long e,t;\nlong long x[100005];\nlong long dp[100005];\n\nint main(){\n  scanf(\"%d%lld%lld\", &n,&e,&t);\n  for(int i=0; i<n; ++i){\n    scanf(\"%lld\", &x[i]);\n    x[i]<<=1;\n  }\n  x[n] = e<<1;\n\n  long long w = 1ll<<57;\n  for(int i=0, j=0; i<n; ++i){\n    while(j<i && t < (x[i] - x[j]) ){\n      w = min(w, dp[j] + (x[i] - x[j]) );\n      j++;\n    }\n    dp[i+1] = min(w, dp[j] + max((x[i]-x[j]) ,t));\n    w += (x[i+1] - x[i]);\n  }\n  printf(\"%lld\\n\", dp[n] + e);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N, E, T;\nint x[110000], dp[110000];\nsigned main() {\n    cin >> N >> E >> T;\n    for (int i = 0; i < N; i++)cin >> x[i];\n    x[N] = E;\n    dp[N] = 0;\n    int rmin=1e14;\n    queue<int> lque;\n    for (int i = N - 1; i >= 0; i--) {\n        \n        dp[i] = LLONG_MAX;\n        for (int j = i + 1; j <= N; j++) {\n            dp[i] = min(dp[i], dp[j] + max(T, 2 * (x[j - 1] - x[i])));\n        }\n    }\n    cout << E + dp[0] << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nconst ll INFLL = 0x3f3f3f3f3f3f3f3fLL;\nconst int MAXN = 100010;\nusing namespace std;\n\nint N, T, E, X[MAXN];\nll dp[MAXN];\n\ninline ll val(int x, int p) { return dp[p] + (X[p + 1] - X[p]) + max(T, 2 * (X[x] - X[p + 1])) + (X[x] - X[p + 1]); }\nint pt[MAXN], ptpos[MAXN], qH = 0, qT = 0;\n\nint main() {\n\tint i, j;\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(i = 1; i <= N; i++) scanf(\"%d\", &X[i]);\n\n\tdp[0] = 0, pt[qT] = 0, ptpos[qT] = 1, qT++;\n\tfor(i = 1; i <= N; i++) {\n\t\twhile(qT - qH >= 2 && i >= ptpos[qH + 1]) qH++;\n\t\t//printf(\"%d = %d\\n\", i, pt[qH]);\n\t\tdp[i] = val(i, pt[qH]);\n\n\t\t//insert i\n\t\tif( val(N, i) < val(N, pt[qT - 1]) ) {\n\t\t\t//printf(\"Try to insert %d\\n\", i);\n\t\t\twhile( qT - qH >= 2 && val(i + 1, i) <= val(i + 1, pt[qT - 1]) ) qT--;\n\n\t\t\tint L = i, R = N, M; //(L, R]\n\t\t\twhile(R - L > 1) {\n\t\t\t\tM = (L + R) >> 1;\n\t\t\t\tif(val(M, i) < val(M, pt[qT - 1])) R = M; else L = M;\n\t\t\t}\n\t\t\tpt[qT] = i, ptpos[qT] = R, qT++;\n\t\t\t//printf(\"Ins to %d\\n\", R);\n\t\t}\n\t}\n\n\tprintf(\"%lld\", dp[N] + (E - X[N]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mini=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[j]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint main(){\n\tll n, e, t; cin>>n>>e>>t;\n\tif(n > 2004) return;\n\tll a[n];\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tll dp[n+1]; dp[n] = 0;\n\tfor(int i = n-1; i >= 0; i--){\n\t\tdp[i] = dp[i+1] + t;\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tdp[i] = min(dp[i], dp[j+1] + max(2*(a[j]-a[i]), t));\n\t\t}\n\t}\n\tcout<<dp[0] + e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst long long INF = (long long) 1e18;\nconst int N = (int) 1e5 + 100;\nlong long x[N];\n\nlong long ans[N];\nlong long upd[N];\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n, e, t;\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld\", &x[i]);\n    x[n] = e;\n\n    for (int i = 0; i <= n; i++)\n        upd[i] = INF;\n\n    for (int i = 0; i <= n; i++)\n    {\n        upd[i + 1] = min(upd[i + 1], upd[i]);\n        long long cur = 0;\n        if (i > 0)\n        {\n            cur = upd[i - 1] + 2LL * x[i - 1];\n            \n            long long z = x[i - 1] - t / 2;\n            int pos = lower_bound(x, x + n + 1, z) - x;\n            long long ccur = t;\n            ccur += ans[pos];\n\n            eprintf(\"i = %d, ccur = %lld\\n\", i, ccur);\n            cur = min(cur, ccur);\n        }\n        ans[i] = cur;\n        int pos = lower_bound(x, x + n + 1, x[i] + (t + 1) / 2) - x;\n        upd[pos] = min(upd[pos], ans[i] - 2 * x[i]);\n\n        eprintf(\"upd from %d with %lld\\n\", pos, upd[pos]);\n\n        eprintf(\"%d) %lld\\n\", i, ans[i]);\n    }\n\n    printf(\"%lld\\n\", ans[n] + e);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mkp make_pair\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int MAXN = 100010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN], l, r;\nll dp[MAXN], pre;\npli q[MAXN*20];\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tl = r = 0;\n\tq[++r] = mkp(0, d[1]);\n\tpre = INF;\n\tint j = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tpli u = q[l+1];\n\t\twhile(2*(d[i]-u.snd) > T) {\n\t\t\tl++;\n\t\t\tif(l != r) u = q[l+1];\n\t\t\telse break;\n\t\t}\n\t\twhile(2*(d[i]-d[j+1]) > T) {\n\t\t\tpre = min(pre, dp[j]-(d[j+1]<<1));\n\t\t\tj++;\n\t\t}\n\t\tif(l != r) dp[i] = min(dp[i], u.fst+T);\n\t\tdp[i] = min(dp[i], pre+(d[i]<<1));\n\t\twhile(l != r && dp[i] < q[r].fst) r--;\n\t\tq[++r] = mkp(dp[i], d[i+1]);\n\t\t//printf(\"%lld %lld\\n\", dp[i], pre);\n\t}\n\tprintf(\"%lld\\n\", dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], st[444444] = {inf};\nvoid upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind or r < l)\n        return ;\n    if(l == r)\n    {\n        st[cur] = val;\n        return;\n    }\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl or r < l or sr < sl)\n        return inf;\n    if(l == r)\n        return st[cur];\n    if(sl <= l and r <= sr)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}\nint32_t main()\n{\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    upd(0, n, 0, 0, -2*x[1]);\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if(j <= 1)\n        {\n            dp[j] = t;\n        }\n        else\n        {\n            if((x[i]-x[j])*2 < t)\n                j--;\n            dp[i] = min(dp[j]+t, mn(0,n,0,j-1,0)+2*x[i]);\n        }\n        upd(0, n, 0, i, dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct Segtree {\n    int n;\n    T e;\n    vector<T> dat;\n    typedef function<T(T a, T b)> Func;\n    Func f;\n\n    Segtree(){}\n    Segtree(int n_input, Func f_input, T e_input){\n        initialize(n_input, f_input, e_input);\n    }\n    void initialize(int n_input, Func f_input, T e_input){\n        f = f_input;\n        e = e_input;\n        n = 1;\n        while(n < n_input) n <<= 1;\n        dat.resize(2*n-1, e);\n    }\n\n    void update(int k, T a){\n        k += n - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1)/2;\n            dat[k] = f(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n\n    T get(int k){\n        return dat[k+n-1];\n    }\n\n    T between(int a, int b){\n        return query(a, b+1, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return e;\n        if(a<=l && r<=b) return dat[k];\n        T vl = query(a, b, 2*k+1, l, (l+r)/2);\n        T vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n};\n\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nint main(){\n    int N, E, T, X[100001];\n    cin >> N >> E >> T;\n    X[0] = 0;\n    for(int i=1; i<=N; i++) cin >> X[i];\n\n    const int64_t INF = 1e18;\n    Segtree<int64_t> dp(N+1, [](int64_t a, int64_t b){ return min(a, b);}, INF);\n    Segtree<int64_t> sub(N+1, [](int64_t a, int64_t b){ return min(a, b);}, INF);\n    dp.update(0, 0);\n    sub.update(0, -2*X[1]);\n\n    int pt = 0;\n    for(int i=1; i<=N; i++){\n        while(T < 2*(X[i] - X[pt+1])) pt++;\n        int64_t result = INF;\n        if(pt < i) chmin(result, dp.between(pt, i-1) + T);\n        if(pt > 0) chmin(result, sub.between(0, pt-1) + 2*X[i]);\n        dp.update(i, result);\n        if(i < N) sub.update(i, result - 2*X[i+1]);\n    }\n    int64_t ans = dp.get(N) + E;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p[100005];\nlong long pp[100005];\nmain()\n{\n\tint t;\n\tlong long ppp,q;\n\tscanf(\"%d%lld%lld\",&t,&q,&ppp);\n\tfor(int i = 0;i <= t+1;i++)\n\t{\n\t\tpp[i]=1e15;\n\t}\n\tfor(int i = 1;i <= t;i++)\n\t{\n\t\tscanf(\"%lld\",&p[i]);\n\t}\n\tpp[0]=0;\n\tpp[1]=p[1];\n\tp[t+1]=q;\n\tfor(int i = 1;i <= t;i++)\n\t{\n\t\tfor(int j = i;j <= t;j++)\n\t\t{\n\t\t\tif(2*(p[j]-p[i])>=ppp)\n\t\t\tpp[j+1]=min(pp[i]+3*(p[j]-p[i])+(p[j+1]-p[j]),pp[j+1]);\n\t\t\telse\n\t\t\tpp[j+1]=min(pp[i]+ppp+(p[j+1]-p[i]),pp[j+1]);\n\t\t}\n\t}\n\t//for(int i = 0;i <= t;i++)\n\t//printf(\"%lld \",pp[i+1]);\n\tprintf(\"%lld\",pp[t+1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 300000;\nvel kai(max_kai, 1);\nvel inv_kai(max_kai, 1);\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nvel pa;\nvel siz;\nint root(int x) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x]); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai() {\n    rep(i, max_kai - 1) {\n        kai[i+1] = kai[i] * (i+1); kai[i+1] %= p;\n        inv_kai[i+1] = modinv(kai[i+1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)){return 0;}\n    int ans = (kai[n] * inv_kai[r])%p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nint inf = 100000;\nvel dijk(V<V<pin>>& way, int st) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin,vector<pin>,greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\nvoid sol(int n, int now_min, int now_max,vel &v) {\n    if (n == 1) {\n        return;\n    }\n    if (n % 2 == 1) {\n        v.push_back(now_max); now_max--;\n    }\n    v.push_back(now_min); now_min++;\n    sol(n / 2, now_min, now_max, v);\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nsigned main() {\n    int n,e,t; cin >> n>>e>>t;\n    SegmentTree< int > seg(n+1, [](int a, int b) { return min(a, b); }, INT_MAX);\n    SegmentTree< int > seg2(n+1, [](int a, int b) { return min(a, b); }, INT_MAX);\n    vel x(n + 1, 0);\n    rep(i, n) { cin >> x[i+1]; }\n    seg.update(0,0);\n    seg2.update(0, -2 * x[1]);\n    int ret;\n    for(int i=1;i<=n;i++) {\n        int l = lower_bound(x.begin(), x.end(), x[i] - t/2) - x.begin();\n        if (l > 0) { l--; }\n        int ans1 = x[i] + seg.query(l, i)+t;\n        mmin(ans1, 3 * x[i]+ seg2.query(0, l));\n        if (i == n) { ret = ans1 + e - x[i]; }\n        else {\n            seg.update(i, ans1 - x[i]);\n            seg2.update(i, ans1 - x[i] - 2 * x[i + 1]);\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tfor (int j = 0; j < i-1; j++) {\n\t\t\tlong long int loss=0;\n\t\t\tif ((x[i] - x[j + 1]) * 2 < t)\n\t\t\t\tloss = t - (x[i] - x[j]) * 2;\n\t\t\tres = min(res, dp[j] + x[i] - x[j] + x[i] - x[j + 1] + loss + x[i] - x[j + 1]);\n\t\t}\n\t\tdp[i] = res;\n\t}\n\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define oo 100005\nusing namespace std;\nint n, a[oo], e, t, q[oo];\nlong long dp[oo], sum[oo], f[oo];\nint main ()\n{\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for(int i = 1; i <= n; ++ i)\n    scanf(\"%d\", &a[i]);\n    memset(dp, 63, sizeof dp);\n    sum[0] = -2 * a[1]; dp[0] = 0;\n    for(int i = 1, lim = 0, l = 1, r = 1; i <= n; ++ i)\n    {\n        while(2 * (a[i] - a[lim + 1]) > t) ++ lim;\n        while(q[l] < lim && l <= r) ++ l;\n        if(l <= r) dp[i] = min(dp[i], f[l] + t + a[i]);\n        if(lim > 0) dp[i] = min(dp[i], sum[lim - 1] + 3ll * a[i]);\n        sum[i] = min(sum[i - 1], dp[i] - a[i] - 2ll * a[i + 1]);\n        while(f[r] >= dp[i] - a[i] && l <= r) -- r;\n        q[++ r] = i, f[r] = dp[i] - a[i];\n    }\n    printf(\"%lld\", dp[n] + e - a[n]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  assert(n <= 2000);\n  lint E, T; cin >> E >> T;\n  V<lint> x(n); for (auto&& e : x) cin >> e;\n  x.push_back(E);\n  V<lint> dp(n + 1, 9e18);\n  dp[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    int k = lower_bound(begin(x), end(x), x[i] + (T + 1) / 2) - begin(x) + 1;\n    for (int j = i + 1; j <= n; ++j) {\n      if (j < k) {\n        dp[i] = min(dp[i], T - x[i] + x[j] + dp[j]);\n      } else {\n        dp[i] = min(dp[i], -3 * x[i] + 2 * x[j - 1] + x[j] + dp[j]);\n      }\n    }\n  }\n  cout << x[0] + dp[0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define ran 111111\nint n,e,t;\nint x[ran];\nlong long int dp2[ran];\nlong long int pref[ran];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tx[0] = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1] = e;\n\tdp2[0] = 0;\n\tpref[0] = -2 * x[1];\n\tfor(int i=1; i<=n; i++){\n\t\tint lo = 0, hi = i-1;\n\t\twhile(lo!=hi){\n\t\t\tint mi = (lo+hi)/2;\n\t\t\tif((x[i] - x[mi]) * 2 <= t)\n\t\t\t\thi = mi;\n\t\t\telse\n\t\t\t\tlo = mi+1;\n\t\t}\n\t\tdp2[i] = dp2[lo] + t;\n\t\tif(lo > 0)dp2[i] = min(dp2[i], pref[lo-1] + 2 * x[i]);\n\t\tpref[i] = min(pref[i-1], dp2[i] - 2 * x[i+1]);\n\t}\n\tcout << dp2[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n,e,t;\nint a[122222];\nll f[122222];\nint g[122222];\nint stkv[122222],stki[122222],top,back;\n\nll val(int j,int i){\n\treturn f[j]+max(t,a[i]-a[j+1]);\n}\nll solve(){\n\tfil(f,63);\n\tf[0]=0;\n\n\ttop=1;back=1;\n\tstki[1]=1;\n\tstkv[1]=0;\n\tstki[2]=n+1;\n\n\trep(i,1,n+1){\n\t\tf[i]=val(stkv[back],i);\n\t\tif(stki[back+1]==i+1)back++;\n\t\telse stki[back]=i+1;\n\n\t\twhile(back<top){\n\t\t\tif(val(i,stki[top])<=val(stkv[top],stki[top])){\n\t\t\t\ttop--;\n\t\t\t\tstki[top+1]=n+1;\n\t\t\t}else break;\n\t\t}\n\t\tint l=stki[top],r=n;\n\t\twhile(l<=r){\n\t\t\tint mid=l+r>>1;\n\t\t\tif(val(i,mid)<=val(stkv[top],mid))r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(l==n+1)continue;\n\t\telse if(l==stki[top])stkv[top]=i;\n\t\telse{\n\t\t\ttop++;\n\t\t\tstki[top]=l;\n\t\t\tstkv[top]=i;\n\t\t\tstki[top+1]=n+1;\n\t\t}\n\t}\n\treturn f[n];\n}\n\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(e);gn(t);\n\trep(i,1,n+1){\n\t\tgn(a[i]);\n\t\t//a[i]=rand()%10000;\n\t\ta[i]*=2;\n\t}\n\tsort(a+1,a+1+n);\n\t/*rep(i,1,n+1){\n\t\tf[i]=inf;\n\t\trep(j,1,i+1){\n\t\t\tif(upmin(f[i],f[j-1]+max(a[i]-a[j],t))){\n\t\t\t\tg[i]=j;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\tif(g[i]>g[i+1]){\n\t\t\tprintf(\"233\");\n\t\t}\n\t}*/\n\tll an=solve()+e;\n\tcout<<an<<endl;\n\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <random>\n#include <cstdio>\nconst long long INF = 10000000000000000;\n\nusing namespace std;\n\nint main(){\n\tlong long N,E,T;\n\tcin>>N>>E>>T;\n\tvector<long long> x(N);\n\tfor(int i=0;i<N;i++) cin>>x[i];\n\tvector<long long> dp(N+1,INF);\n\tdp[0]=0;\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j]+max(T,2*(x[i-1]-x[j])));\n\t\t}\n\t}\n\tcout<<dp[N]+E<<endl;\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tLL mi = 1000000000000000LL;\n\tinc1(i, n) {\n\t\tincID(j, m[i - 1], m[i]) { setmin(mi, dp[j] - 2 * x[j + 1]); }\n\t\tdp[i] = min(mi + 2 * x[i], dp[ m[i] ] + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nint main(){\n    ll n,e,t;\n    cin >> n >> e >> t;\n    if(n>=2001)return 0;\n    vector<ll> a(n+1);\n    a[0] = 0;\n    rep(i,n){\n        cin >> a[i+1];\n    }\n    a.push_back(e);\n    n+=2;\n    vector<ll>dp(n,1LL<<60);\n    rep(i,n){\n        if(i==0){\n            dp[0] = 0;\n            continue;\n        }\n        rep(j,i-1){\n            dp[i] = min(dp[i],dp[j]+(a[j+1]-a[j])+max(3*(a[i]-a[j+1]),t+(a[i]-a[j+1])));\n        }\n        if(i!=n-1){\n            dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]+t);\n        }else{\n            dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]);    \n        }\n    }\n    // rep(i,n){\n    //     cerr << dp[i] << \" \";\n    // }\n    // cerr << endl;\n    cout << dp[n-1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi seg,seg2;\nll N;\nvoid init(vi v){\n    N=1;\n    while(N<v.size())N*=2;\n    seg=vi(N*2-1,inf);\n    seg2=seg;\n}\nvoid update(ll i,ll x){\n    i=N+i-1;\n    seg[i]=x;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=min(seg[i*2+1],seg[i*2+2]);\n    }\n}\nll getmi(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return inf;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getmi(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getmi(a,b,k*2+2,(l+r)/2,r);\n    return min(c1,c2);\n}\nvoid update2(ll i,ll x){\n    i=N+i-1;\n    seg2[i]=x;\n    while(i>0){\n        i=(i-1)/2;\n        seg2[i]=min(seg2[i*2+1],seg2[i*2+2]);\n    }\n}\nll getmi2(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return inf;\n    if(a<=l&&r<=b)return seg2[k];\n    ll c1=getmi2(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getmi2(a,b,k*2+2,(l+r)/2,r);\n    return min(c1,c2);\n}\nint main(){\n    ll n,e,t;cin>>n>>e>>t;\n    vi dis(n+1);\n    rep(i,n)cin>>dis[i+1];\n    vi dp(n+1,inf);\n    dp[0]=0;\n    init(dp);\n    update(0,0);\n    update2(0,-dis[1]*2);\n    REP(i,1,n+1){\n        ll f=lb(dis,dis[i]-t/2);\n        if(!f)f++;\n        chmin(dp[i],getmi(f-1,i,0,0,N)+dis[i]+t);\n        chmin(dp[i],getmi2(0,f-1,0,0,N)+dis[i]*3);\n        update(i,dp[i]-dis[i]);\n        if(i<n)update2(i,dp[i]-dis[i]-dis[i+1]*2);\n    }\n    out(dp[n]+e-dis[n]);\n}"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\tll dp1 = dp[opt - 1] + T;\n\tll dp2 = a[idx] * 2;\n\tif(opt - 1 >= 0)\n\t\tdp2 += dp[opt - 1];\n\treturn(min(dp1 , dp2));\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\t/*while(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}*/\n\t\tdp[i] = findDp(i);\n\t\t//for(int j = 0; j <= i; j++)\n\t\t\t//dp[i] = min(dp[i] , cost(i , j));\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\nvoid debug_impl() { std::cerr << '\\n'; }\ntemplate <class Head, class... Tail>\nvoid debug_impl(Head&& head, Tail&&... tail) {\n    std::cerr << ' ' << head;\n    debug_impl(std::forward<Tail>(tail)...);\n}\n\n#define ENABLE_DEBUG\n#ifdef ENABLE_DEBUG\n#define debug(...)\\\n    do { std::cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n         debug_impl(__VA_ARGS__); std::cerr << noboolalpha; } while (false)\n#else\n#define debug(...)\n#endif\n\ntypedef long long lint;\nconstexpr lint inf = 1ll << 60;\n\nint N;\nlint T;\nlint X[100001];\nlint dp[100002];\n\ntemplate <class Mn, class Op>\nstruct segment_tree {\nprivate:\n\n    int size;\n    std::vector<Mn> node;\n    const Mn unit;\n    const Op oper;\n\npublic:\n\n    segment_tree(const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { }\n    segment_tree(const int& size_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { init(size_); }\n    segment_tree(const std::vector<Mn>& node_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { build(node_); }\n\n    void init(const int& size_) {\n        for(size = 1; size < size_; size <<= 1);\n        node.assign(size << 1, unit);\n    }\n\n    void build(const std::vector<Mn>& node_) {\n        init(node_.size());\n        for (int i = 0; i < node_.size(); ++i) {\n            node[i + size] = node_[i];\n        }\n        for (int i = size - 1; i > 0; --i) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void set_value(const int& idx, const Mn& value) {\n        int i = idx + size;\n        for (node[i] = value; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void add_value(const int& idx, const Mn& plus) {\n        int i = idx + size;\n        for (node[i] += plus; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    Mn fold(const int& l, const int& r) const {\n        Mn result_l = unit, result_r = unit;\n        for(int tl = l + size, tr = r + size; tl < tr; tl >>= 1, tr >>= 1) {\n            if (tl & 1) { result_l = oper(result_l, node[tl]); ++tl; }\n            if (tr & 1) { --tr; result_r = oper(node[tr], result_r); }\n        }\n        return oper(result_l, result_r);\n    }\n\n    Mn operator [] (const int& idx) const {\n        return node[idx + size];\n    }\n\n};\n\nint main() {\n    \n    cin >> N >> X[N + 1] >> T;\n    rep(i, 1, N) cin >> X[i];\n\n    const auto getmin = [](const lint& x, const lint& y) { return x < y ? x : y; };\n    segment_tree<lint, decltype(getmin)> memo1(N + 1, inf, getmin), memo2(N + 1, inf, getmin);\n    memo1.set_value(0, 0);\n    memo2.set_value(0, - 2 * X[1]);\n\n    rep(i, 1, N) {\n        dp[i] = inf;\n        int l = 0, r = (X[i] - X[1]) * 2 < T ? 0 : i;\n        while(r - l > 1) {\n            int md = (l + r) / 2;\n            ((X[i] - X[md + 1]) * 2 >= T ? l : r) = md;\n        }\n        chmin(dp[i], memo1.fold(r, i) + T + X[i]);\n        chmin(dp[i], memo2.fold(0, r) + 3 * X[i]);\n        memo1.set_value(i, dp[i] - X[i]);\n        memo2.set_value(i, dp[i] - 2 * X[i + 1] - X[i]);\n    }\n    \n    cout << dp[N] + X[N + 1] - X[N] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://discuss.codechef.com/t/robagain-editorial/20734\n#pragma GCC optimize(\"O3\")\n#include<queue>\n#include <cmath>\n#include <complex>\n#include<map>\n#include <string>\n#include<iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <stdio.h>\n#include<bits/stdc++.h>\n\n\n/*\n#define x real()\n#define y imag()\n#define angle(a)                (atan2((a).imag(), (a).real()))\n#define vec(a,b)                ((b)-(a))\n#define same(p1,p2)             (dp(vec(p1,p2),vec(p1,p2)) < EPS)\n#define dp(a,b)                 ( (conj(a)*(b)).real() )\t// a*b cos(T), if zero -> prep\n#define cp(a,b)                 ( (conj(a)*(b)).imag() )\t// a*b sin(T), if zero -> parllel\n#define length(a)               (hypot((a).imag(), (a).real()))\n#define normalize(a)            (a)/length(a)\n//#define polar(r,ang)            ((r)*exp(point(0,ang)))  ==> Already added in c++11\n#define rotateO(p,ang)          ((p)*exp(point(0,ang)))\n#define rotateA(p,ang,about)  (rotateO(vec(about,p),ang)+about)\n#define reflectO(v,m)  (conj((v)/(m))*(m))\n*/\n\n//#define pi 3.141592654\n#define forr(i,a,b) for(int i=a;i<=b;i++)\n#define F first\n#define S second\n#define input ios_base::sync_with_stdio(0);cin.tie(0);\n#define NOT(x) (1^x)\n\nconst double PI  = acos(-1.0);\nusing namespace std;\ntypedef pair<double,double>pdd;\ntypedef long long  ll;\ntypedef pair<ll, ll>pii;\ntypedef complex<double> point;\n\n//int x[8]={1,0,0,-1,-1,-1,1,1};\n//int y[8]={0,1,-1,0,-1,1,-1,1};\n//const int N=500009,M=1000000;\nconst double EPS= 1e-9,eps=-1e9;\nconst int N =100005;\n\nll n,e,t,mem[N][2],x;\nvector<ll>a,b;\nmap<ll,ll>id;\nll dp(int i=0,int ck=0)\n{\n    if(i>=n)return 0;\n    ll&ret=mem[i][ck];\n    if(~ret)return ret;\n    ret=4e18;\n    auto it=upper_bound(a.begin(),a.end(),a[i]+t/2);\n    int j=it-a.begin();\n    if(ck==0){\n        ret=min(ret,dp(b[j],0)+t);\n        if(i+1!=n)ret=min(ret,dp(b[j],1)+(a[j]-a[i])*(ll)2);\n    }\n    if(ck){\n        ret=min(ret,dp(i+1,0));\n        if(i+1!=n)ret=min(ret,dp(i+1,1)+(a[i+1]-a[i])*(ll)2);\n    }\n    return ret;\n}\n int main()\n{\n//freopen(\"travel.in\",\"r\",stdin);\n//freopen(\"travel.out\",\"w\",stdout);\n//__builtin_popcount()\ninput;\n\n\n      cin>>n>>e>>t;\n      for(int i=0;i<n;i++)\n      {\n          cin>>x;\n          a.push_back(x);\n          b.push_back(i);\n      }\n      a.push_back(e);\n      b.push_back(n);\n      memset(mem,-1,sizeof mem);\n      cout<<e+dp()<<endl;\n\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tfor (int x=now+1; x<=n&&x-now<=500; ++x){\n\t\t\tlong long tmp=0;\n\t\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t\t}\n\t\t\telse f[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n + 10, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint l = 0;\n\tvi p(n + 1);\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\tvl dp(n + 10, INF);\n\tdp[0] = e;\n\tvl dp2(n + 10, INF);\n\tdp2[0] = INF; dp2[1] = INF; dp2[2] = e-2*x[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tdp[i] = dp[max(0,p[i]-1)] + t;\n\t\t/*for (int j = 0; j+1<p[i]; j++) {\n\t\t\tmi = min(mi, dp[j] -2 *  x[j + 1]);\n\t\t}*/\n\t\tmi = dp2[p[i]];\n\t\tdp[i] = min(dp[i],mi+2*x[i]);\n\t\tdp2[i + 2] = min(dp[i + 1], dp[i] - 2 * x[i + 1]);\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    deque<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = -LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = T + 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (cval <= pval) {\n                d.pop_back();\n                continue;\n            }\n            int64_t prevSteady = T + 2 * X[p + 1];\n            time = max(prevSteady, 2LL * X[i]) + cval - pval;\n            if (time > currSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = -LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (SZ(d) > 1 && 2 * X[i] >= d[1].second) {\n            d.pop_front();\n        }\n        d.front().second = -LINF;\n        int p = d.front().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long n,t,e,x[111111],mnp,pos,dp[111111];\nmultiset<long long> s;\nint main()\n{\n\tscanf(\"%I64d%I64d%I64d\",&n,&e,&t);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%I64d\",&x[i]);\n\t}\n\tdp[0]=0;\n\tmnp=1e18;\n\tpos=1;\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=n)\n\t\t{\n\t\t\tif (2*(x[i]-x[pos])>t) \n\t\t\t{\n\t\t\t\tmnp=min(mnp,dp[pos-1]-2*x[pos]);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mnp+2*x[i]);\n\t}\n\tprintf(\"%I64d\\n\",dp[n]+e);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            ll need=A[i+1]-A[i];\n            ll dis=(A[j]-A[i+1])*2;\n            chmin(dp[j],dp[i]+need+max(T,dis)+dis/2);\n        }\n    }\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+(A[it-A.begin()]-A[i])*2);\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+T);\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nvector<int> tree;\nint N = 1;\n\nvoid upd(int v) {\n\tif(v == 0) \n\t\treturn;\n\ttree[v] = max(tree[v * 2], tree[v * 2 + 1]);\n\tupd(v / 2);\n}\n\nint get(int v, int l, int r, int vl, int vr) {\n\tif(vr <= l || r <= vl)\n\t\treturn inf;\n\tif(vl <= l && r <= vr) {\n\t\treturn tree[v];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(get(v * 2, l, m, vl, vr), get(v * 2 + 1, m, r, vl, vr));\n}\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\n\twhile(N < (n + 2)) \n\t\tN *= 2;\n\n\ttree = vector<int> (2 * N, inf);\n\tvector<int> suf(n + 1, inf);\n\tsuf[n - 1] = k;\n\tint uk = n - 2;\n\ttree[N + (n - 2)] = k + a[n - 1] + suf[n - 1];\n\tupd((N + (n - 2)) / 2);\n\n\tfor (int i = n - 2; i >= 0; i--) {\n\n\t\twhile(uk > 0 && 2 * (a[uk] - a[i]) >= k) {\n\t\t\ttree[N + uk] = 2 * a[uk] + a[uk + 1] + suf[uk + 1];\n\t\t\tupd((N + (uk - 1)) / 2);\n\t\t\tuk--;\n\t\t}\n\t\tint ans = max(k, 2 * (a[n - 1] - a[i])) + (a[n - 1] - a[i]);\n\t\tint l = i, r = n + 1;\n\t\twhile(r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(2 * (a[m] - a[i]) < k) \n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\t// cout << ans << \" \" << i << \" \" << l << \" \" << get(1, 0, N, i, l + 1) << \" \" << uk << endl;\n\t\tans = min(ans, get(1, 0, N, i, l + 1) - a[i]);\n\t\tif(r <= n - 2) {\n\t\t\tans = min(ans, get(1, 0, N, l + 1, r + 1) - 3 * a[i]);\n\t\t}\n\t\tsuf[i] = ans;\n\t\tif(i != 0) {\n\t\t\ttree[N + (i - 1)] = k + a[i] + suf[i];\n\t\t\tupd((N + (i - 1)) / 2);\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}\n\n// j\n\n// "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int n,e,t;\n  cin>>n>>e>>t;\n  int x[n+1];\n  for(int i=0;i<n;i++) cin>>x[i];\n  if(n>2000) assert(0);\n  x[n]=e;\n  int dp[n+1];\n  int INF=1LL<<55LL;\n  fill_n(dp,n+1,INF);\n  dp[0]=x[0];\n  for(int i=0;i<n;i++){\n    //cout<<i<<\":\"<<dp[i]<<endl;\n    for(int j=i;j<n;j++){\n      int tmp=max(2*(x[j]-x[i]),t);\n      tmp+=x[j+1]-x[i];\n      dp[j+1]=min(dp[j+1],dp[i]+tmp);\n    }\n  }\n  cout<<dp[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    rep (i, n) {\n        if (dp[i] == INF) continue;\n        ll nx;\n        if (t % 2 == 0) nx = x[i + 1] + t / 2;\n        else nx = x[i + 1] + (t + 1) / 2;\n\n        auto itr = lower_bound(all(x), nx);\n        int ni = itr - x.begin();\n        if (ni <= n) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + (x[ni] - x[i + 1]) * 3);\n        }\n\n        ni--;\n        assert((x[ni] - x[i + 1]) * 2 <= t);\n        if (ni + 1 < x.size()) {\n            assert((x[ni + 1] - x[i + 1]) * 2 >= t);\n        }\n        if (ni > i) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + t + (x[ni] - x[i + 1]));\n        }\n    }\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nll N,E,T;\nconst ll MAX_N = 131072;\nll dp [MAX_N];\npair<ll,ll> seg_tree [MAX_N * 2];\nconst ll INF = 1e17;\n\nvoid update(int idx,pair<ll,ll> val)\n{\n\tidx += MAX_N - 1;\n\tseg_tree [idx] = val;\n\twhile(idx){\n\t\tidx = (idx - 1) / 2;\n\t\tseg_tree [idx] = min(seg_tree [idx * 2 + 1],seg_tree [idx * 2 + 2]);\n\t}\n}\n\nvoid init()\n{\n\tFOR(i,0,MAX_N){\n\t\tupdate(i,{INF,-1});\n\t}\n}\n\npair<ll,ll> query(int a,int b,int idx,int l,int r)\n{\n\tif(b <= l || r <= a) return {INF,-1};\n\tif(a <= l && r <= b) return seg_tree [idx];\n\tpair<ll,ll> res = query(a,b,idx * 2 + 1,l,(l + r) / 2);\n\tchmin(res,query(a,b,idx * 2 + 2,(l + r) / 2,r));\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tvector<ll> A(N);\n\tFOR(i,0,N){\n\t\tcin >> A [i];\n\t}\n\n\tinit();\n\tfill_n(dp,N + 1,INF);\n\tdp [0] = 0;\n\tupdate(0,make_pair(-A [0],0));\n\tfor(int i = 1;i <= N;i++){\n\t\tpair<ll,ll> nxt = query(0,i,0,0,MAX_N);\n\t\tdp [i] = dp [nxt.second];\n\t\tll a = A [i - 1] - (nxt.second > 0 ? A [nxt.second - 1] : 0);\n\t\tll b = A [nxt.second] - (nxt.second > 0 ? A [nxt.second - 1] : 0);\n\t\tdp [i] += max(a * 2 - b * 2,T) + a;\n\t\tif(i < N){\n\t\t\tupdate(i,{dp [i] - (A [i - 1] + A [i]),i});\n\t\t}\n\t}\n\n\tcout << dp [N] + (E - A.back()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconstexpr ll INF = 1e18;\n\nll dfs(int p){\n  if(dp[p]!=-1)return dp[p];\n  dp[p] = INF;\n  FOR(to,p,n){\n    ll len = x[to] - x[p];\n    ll add = max(t,2ll*len);\n    CHMIN(dp[p],add+len+x[to+1]-x[to]+dfs(to+1));\n  }\n  return dp[p];\n}\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  assert(n<=2000);\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  ll ans = dfs(0);\n  printf(\"%lld\\n\",ans+x[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repp(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dp[2010];\nconst int INF = 1e12;\n\nsigned main(){\n    int n, t, e;\n    cin >> n >> e >> t;\n    if(n > 2000) return 0;\n    vector<int> a(n + 1);\n    a[0] = 0;\n    rep(i, 1, n + 1) cin >> a[i];\n    rep(i, 0, 2010){\n        dp[i] = INF;\n    }\n    dp[0] = a[0];\n    rep(i, 1, n + 1){\n        rep(j, i, n + 1){\n            int tmp = 2 * (a[j] - a[i]);\n            tmp += tmp / 2;\n            if(tmp < t) tmp += (t - tmp) * (j - i + 1);\n            dp[j] = min(dp[j], dp[i - 1] + a[i] - a[i - 1] + tmp);\n            // cout << i << ' ' << j << ' ' << tmp << ' ' << dp[j] << endl;\n        }\n    }\n    // rep(i, 0, n + 1){\n    //     cout << dp[i] << \" \";\n    // }\n    cout << dp[n] + e - a[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\ntypedef long long LL;\nconst int MAXN = 100000+10;\nconst int INF = 0x3f3f3f3f;\nint n, t, e;\nLL x[MAXN], f[MAXN];\nint main(){\n   // freopen(\"t.in\", \"r\", stdin);\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for(int i=1; i<=n; ++i) scanf(\"%lld\", &x[i]);\n    int j=0;\n    LL mn = 1e14;\n    for(int i=1; i<=n; ++i){\n        while((x[i]-x[j+1])*2>=t){\n            mn = std::min(mn, f[j] - 2*x[j+1]);\n            j++;\n        }\n        f[i] = std::min(f[j]+t, mn + 2*x[i]);\n    }\n    printf(\"%lld\\n\", f[n]+e);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int, int> PP;\ntypedef long long LL;\n#define pb push_back\n#define fr first\n#define sc second\n#define bitcnt __builtin_popcount\n#define all(x) x.begin(), x.end()\ninline int ri() {int x; scanf(\"%d\", &x); return x;}\n#define rep2(i, n, ...) for (int i = 0; i < (n); i ++) \n#define rep3(i, a, b, ...) for (int i = (a); i < (b); i ++)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define drep2(i, n, ...) for (int i = (n) - 1; i >= 0; i --)\n#define drep3(i, a, b) for (int i = (a) - 1; i >= (b); i --)\n#define drep(...) GET_MACRO(__VA_ARGS__, drep3, drep2)(__VA_ARGS__)\ntemplate<typename T>inline bool smax(T&a, T b){if(a<b){a=b;return true;}return false;} \ntemplate<typename T>inline bool smin(T&a, T b){if(a>b){a=b;return true;}return false;} \n/*}}}*/\n\nconst int maxn = 100010;\n\nint s, n, m;\nLL a[maxn], p[maxn]; \nint main() {\n  #ifdef _TEST_\n  freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"out.txt\", \"w\", stdout);\n  #endif\n  n = ri(), m = ri(), s = ri();\n  rep(i, n) a[i] = ri();\n  set<LL> l, r;\n  int c = 0;\n  rep(i, n) {\n    while (c <= i && (a[i] - a[c]) * 2 > s) {\n      l.insert(p[c] - 2 * a[c]);\n      c ++;\n    }\n    //cerr << i << ' ' << c << endl;\n    p[i + 1] = s + p[c];\n    if (!l.empty()) p[i + 1] = min(2 * a[i] + (*l.begin()), p[i + 1]);\n  }\n  cout << p[n] + m << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,1,n+1)cin>>x[i];\n    int g=0;\n    up(1,0,n+1,0,-2*x[1]);\n    rep(i,1,n+1)\n    {\n        while(x[g+1]<=x[i]-t/2.0)g++;\n        dp[i]=min(t+dp[g],2*x[i]+query(1,0,n+1,0,g));\n        up(1,0,n+1,i,dp[i]-2*x[i+1]);\n        //cout<<i<<' '<<g<<' '<<dp[i]<<' '<<2*x[i]<<'+'<<query(1,0,n+1,0,g)<<' '<<t+dp[g]<<endl;\n    }\n    cout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long f[100010],c[100010],d[100010];\nint x[100010];\nint n,e,t,T;\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tT=t;\n\tif(t%2)T++;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(c,0x3f,sizeof(c));\n\tmemset(d,0x3f,sizeof(d));\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=min(f[i],f[i-1]+x[i]-x[i-1]+t);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif((x[j]-x[i])*2>=t)f[j]=min(f[j],f[i-1]+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t\telse f[j]=min(f[j],f[i-1]+t-2*(x[j]-x[i])+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t}\n\t}\n\tcout<<f[n]+e-x[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long n,t,e,x[111111],mnp,pos,dp[111111];\nmultiset<long long> s;\nint main()\n{\n\tscanf(\"%I64d%I64d%I64d\",&n,&e,&t);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%I64d\",&x[i]);\n\t}\n\tdp[0]=0;\n\tmnp=1e18;\n\tpos=1;\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=n)\n\t\t{\n\t\t\tif (2*(x[i]-x[pos])>t) \n\t\t\t{\n\t\t\t\tmnp=min(mnp,dp[pos-1]-2*x[pos]);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mnp+2*x[i]);\n\t}\n\tprintf(\"%I64d\\n\",dp[n]+e);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<long long> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        chmin(dp[i + 1], dp[i] + T);\n        for (int j = i; j < min(i + 10000, n); j++) {\n            chmin(dp[j + 1], dp[i] + 2 * (ds[j] - ds[i]) + max(0LL, T - 2 * (ds[j] - ds[i])));\n        }\n    }\n\n    cout << min(dp[n] + E, E + ds.back() * 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint INF = 1e16;\nint main()\n{\n    lint N, E, T;\n    cin >> N >> E >> T;\n    vector<lint> x(N);\n    cin >> x;\n\n    vector<lint> dp(N + 1, INF);\n    dp[0] = 0;\n    REP(i, N)\n    {\n        if (i > 0) mmin(dp[i + 1], dp[i] + (x[i] - x[i - 1]) * 2);\n        int y = (x[i] + T / 2);\n        auto itr = prev(upper_bound(ALL(x), y));\n        int d = distance(x.begin(), itr);\n        mmin(dp[d + 1], dp[i] + T);\n        if (d + 1 < N) mmin(dp[d + 2], dp[i] + (x[d + 1] - x[i]) * 2);\n    }\n    cout << dp.back() + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nint n,T,E;\nint a[100010];\nlong long ans;\nlong long f[100010],g[100010];\npair<int,long long> q[100010];\n\nint main()\n{int i,j,t,w;\n \n scanf(\"%d%d%d\",&n,&E,&T);\n for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n f[0]=0;\n j=1;\n a[n+1]=E;\n t=1;\n w=1;\n q[1]=make_pair(0,0);\n for(i=1;i<=n;i++)\n {\twhile(j+1<=i && (a[i]-a[j+1])*2>=T) j++;\n\tif((a[i]-a[j])*2>=T) f[i]=max(f[i],(a[i+1]-a[i])*2+g[j-1]);\n\twhile(t<=w && (a[i]-a[q[t].first])*2>=T) t++;\n\twhile(t<=w && q[w].second<=f[i-1]-a[i]*2) w--;\n\tq[++w]=make_pair(i,f[i-1]-a[i]*2);\n\tif(t<=w) f[i]=max(f[i],q[t].second+2*a[i]+2*(a[i+1]-a[i])-T);\n\tg[i]=max(g[i-1],f[i]);\n }\n ans=(ll)3*E-f[n]-2*a[1];\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    dp[1] = T;\n    for (ll i = 2, j = 0, k = 0; i <= N;) {\n        ll L = max(2 * (X[i] - X[j + 1]), T);\n        if (L == T) {\n            dp[i] = min(dp[j] + T, dp[k] + 2 * (X[i] - X[k + 1]));\n            i++;\n        } else {\n            ll dpj = dp[j] + L;\n            ll dpk = dp[k] + max(2 * (X[i] - X[k + 1]), T);\n            if (dpj < dpk) {\n                k = j;\n            }\n            j++;\n        }\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nll n, t, e;\nll x[100009];\n\nll dp[100009];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> e >> t;\n    assert(n <= 2000);\n    rep(i, n) cin >> x[i + 1];\n\n    fill(ALL(dp), inf);\n    dp[0] = 0;\n    FOR(i, 1, n + 1)\n    rep(j, i) chmin(dp[i], dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n\n    cout << dp[n] + e << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"bitset\"\n\nusing namespace std;\n\n//const long long int MOD = 998244353;\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass Segment_Tree {\n\tvector<long long int>v;\n\tvector<long long int>add;\n\tvector<long long int>modi;\n\tvector<int>l;\n\tvector<int>r;\n\tint num;\n\tlong long int ret;\n\tbool is_min;\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tif (is_min) {\n\t\t\tv[place] = min(Update(place * 2), Update(place * 2 + 1));\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = max(Update(place * 2), Update(place * 2 + 1));\n\t\treturn v[place];\n\t}\n\tvoid Modify(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tmodi[place] = num;\n\t\t\tv[place] = num;\n\t\t\tadd[place] = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place];\n\t\tadd[place * 2 + 1] += add[place];\n\t\tadd[place] = 0;\n\t\tModify(a, b, num, place * 2);\n\t\tModify(a, b, num, place * 2 + 1);\n\t\tif (is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid Add(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tadd[place] += num;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place];\n\t\tadd[place * 2 + 1] += add[place];\n\t\tadd[place] = 0;\n\t\tAdd(a, b, num, place * 2);\n\t\tAdd(a, b, num, place * 2 + 1);\n\t\tif (is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\n\tvoid RMQ(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tif (is_min)ret = min(ret, v[place] + add[place]);\n\t\t\telse ret = max(ret, v[place] + add[place]);\n\t\t\treturn;\n\t\t}\n\t\tif (l[place]>b || r[place]<a) return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place];\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place];\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place];\n\t\tadd[place * 2 + 1] += add[place];\n\t\tadd[place] = 0;\n\t\tRMQ(a, b, place * 2);\n\t\tRMQ(a, b, place * 2 + 1);\n\t\tif (is_min)v[place] = min(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\telse v[place] = max(v[place * 2] + add[place * 2], v[place * 2 + 1] + add[place * 2 + 1]);\n\t\treturn;\n\t}\npublic:\n\tSegment_Tree(int n, bool min) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2) {\n\t\t\tnum *= 2;\n\t\t}\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tis_min = min;\n\t\tif (min) {\n\t\t\tv.resize(num, MOD*MOD);\n\t\t}\n\t\telse v.resize(num, -MOD*MOD);\n\t\tadd.resize(num, 0);\n\t\tmodi.resize(num, MOD*MOD);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Insert(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] = num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tif (is_min)v[place] = min(v[place * 2], v[place * 2 + 1]);\n\t\t\telse v[place] = max(v[place * 2], v[place * 2 + 1]);\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid Modify(int a, int b, long long int num) {\n\t\tModify(a, b, num, 1);\n\t}\n\tvoid Add(int a, int b, long long int num) {\n\t\tAdd(a, b, num, 1);\n\t}\n\tvoid Init() {\n\t\tUpdate(1);\n\t}\n\tlong long int RMQ(int a, int b) {\n\t\tif (is_min)ret = LLONG_MAX;\n\t\telse ret = LLONG_MIN;\n\t\tRMQ(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> R >> K;\n\tvector<long long int>v(N + 1);\n\tfor (int i = 1; i <= N;i++)cin >> v[i];\n\tvector<long long int>dp(N + 1, MOD*MOD);\n\tdp[0] = 0;\n\tL = 1;\n\tSegment_Tree sg(N + 1, true);\n\tsg.Modify(0, N, 0);\n\tsg.Add(0, 0, v[1]);\n\t//cout << sg.RMQ(0, 0) << endl;\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = min(dp[i], dp[i - 1] + v[i] - v[i - 1] + K);\n\t\twhile ((v[i] - v[L]) * 2 > K)L++;\n\t\t//cout << i << \" \" << L << endl;\n\t\tif (L < i) {\n\t\t\tdp[i] = min(dp[i], dp[L - 1] + K + v[i] - v[L - 1]);\n\t\t}\n\t\tif(L>1)dp[i] = min(dp[i], sg.RMQ(0, L - 2));\n\t\tif (i != N) {\n\t\t\tsg.Add(i, i, v[i + 1] - v[i] + dp[i]);\n\t\t\tsg.Add(0, i - 1, (v[i + 1] - v[i]) * 3);\n\t\t}\n\t}\n\t//for (int i = 1; i <= N; i++) {\n\t//\tcout << dp[i] << endl;\n\t//}\n\tcout << dp.back()+R-v.back() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n#pragma warning (disable: 4996)\n\ntemplate<typename Type>\nclass RMQ {\nprivate:\n\tint size_; std::vector<Type> dat;\npublic:\n\tRMQ() : size_(0), dat(std::vector<Type>()) {};\n\tRMQ(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat.resize(size_ << 1, std::numeric_limits<Type>::max() / 2);\n\t}\n\ttemplate<class T>\n\tRMQ(T begin_, T end_) {\n\t\tint n = end_ - begin_;\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::numeric_limits<Type>::max() / 2);\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = *(begin_ + i);\n\t\tfor (int i = size_ - 1; i > 0; i--) dat[i] = std::min(dat[i << 1], dat[(i << 1) + 1]);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void update(int i, Type x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tdat[i] = std::min(dat[i << 1], dat[i << 1 | 1]);\n\t\t}\n\t}\n\tinline Type query(int l, int r) {\n\t\tType ret = std::numeric_limits<Type>::max() / 2;\n\t\tif (l >= r)return ret;\n\t\tl += size_; r += size_;\n\t\twhile (l != r) {\n\t\t\tif (l & 1) ret = std::min(ret, dat[l++]); l >>= 1;\n\t\t\tif (r & 1) ret = std::min(ret, dat[--r]); r >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nlong long dp[200009], x[200009], E, N, T;\n\nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 1; i <= N; i++) scanf(\"%lld\", &x[i]);\n\tx[N + 1] = E;\n\n\tRMQ<long long>X1(N + 5), X3(N + 5);\n\tdp[1] = x[1]; X1.update(1, dp[1] - x[1]); X3.update(1, dp[1] - 3LL * x[1]);\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tint pos1 = lower_bound(x, x + N + 2, x[i - 1] - (T / 2)) - x;\n\t\tlong long P1 = X1.query(pos1, i); P1 += T; P1 += x[i - 1];\n\t\tlong long P2 = X3.query(1, pos1); P2 += 3 * x[i - 1];\n\t\tdp[i] = min(P1, P2) + (x[i] - x[i - 1]);\n\t\tX1.update(i, dp[i] - x[i]);\n\t\tX3.update(i, dp[i] - 3LL * x[i]);\n\t}\n\tcout << dp[N + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,t,e,a[200005],dp[200005];\nint main(){\n\tn=read(),e=read(),t=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tmemset(dp,0x3f,sizeof(dp)),dp[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t\tdp[i]=min(dp[i],max(dp[j]+a[i]-a[j]+a[i]-a[j+1],dp[j]+a[j+1]-a[j]+t)+a[i]-a[j+1]);\n\tprintf(\"%lld\",dp[n]-a[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    //assert(N <= 2000);\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1);\n    // dp[0] = 0;\n    // auto calc=[&](int i, int j) {\n    //     return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2);\n    // };\n\n    int cur = 0;\n    ll val = 1e18;\n    for (int i = 1; i <= N; i++) {\n        while (cur < i-1 and T < (x[i]-x[cur+1])*2) {\n            chmin(val,dp[cur]-x[cur+1]*2);\n            cur++;\n        }\n        dp[i] = min(val+x[i]*2,dp[cur]+T);\n    }\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n       \n          A FAN OF FIZZYDAVID\n           \n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-20\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define debug puts(\"OK\");\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\n#ifdef ONLINE_JUDGE\n#else\n//#define DEBUG\n#endif\n\n//---------------------------head----------------------------\n\nconst int N=1e5+100;\n\nint n;\nLL T;\nLL dp[N],x[N];\n\nnamespace seg1//dp[j]+2*x[j-1]+x[j]\n{\n\tLL num[N<<2];\n\tinline int L(int i){ return i<<1; }\n\tinline int R(int i){ return (i<<1)|1; }\n\tinline void update(int i){ num[i]=min(num[L(i)],num[R(i)]); return; }\n\tinline void modify(int i,LL x,int l=1,int r=n,int k=1)\n\t{\n\t\tif(l==r){ num[k]=x; return; }\n\t\tint mid=l+r>>1;\n\t\tif(i<=mid) modify(i,x,l,mid,L(k));\n\t\telse modify(i,x,mid+1,r,R(k));\n\t\treturn update(k);\n\t}\n\tinline LL query(int a,int b,int l=1,int r=n,int k=1)\n\t{\n\t\tif(a==l && b==r) return num[k];\n\t\tint mid=l+r>>1;\n\t\tif(a>mid) return query(a,b,mid+1,r,R(k));\n\t\tif(b<=mid) return query(a,b,l,mid,L(k));\n\t\treturn min(query(a,mid,l,mid,L(k)),query(mid+1,b,mid+1,r,R(k)));\n\t}\n}\n\nnamespace seg2//dp[j]+T+x[j]\n{\n\tLL num[N<<2];\n\tinline int L(int i){ return i<<1; }\n\tinline int R(int i){ return (i<<1)|1; }\n\tinline void update(int i){ num[i]=min(num[L(i)],num[R(i)]); return; }\n\tinline void modify(int i,LL x,int l=1,int r=n,int k=1)\n\t{\n\t\t#ifdef DEBUG\n\t\tcout<<i<<' '<<x<<' '<<l<<' '<<r<<' '<<k<<endl;\n\t\t#endif\n\t\tif(l==r){ num[k]=x; return; }\n\t\tint mid=l+r>>1;\n\t\tif(i<=mid) modify(i,x,l,mid,L(k));\n\t\telse modify(i,x,mid+1,r,R(k));\n\t\treturn update(k);\n\t}\n\tinline LL query(int a,int b,int l=1,int r=n,int k=1)\n\t{\n\t\t#ifdef DEBUG\n\t\tcout<<'['<<a<<','<<b<<']'<<' '<<l<<' '<<r<<' '<<k<<endl;\n\t\t#endif\n\t\tif(a==l && b==r) return num[k];\n\t\tint mid=l+r>>1;\n\t\tif(a>mid) return query(a,b,mid+1,r,R(k));\n\t\tif(b<=mid) return query(a,b,l,mid,L(k));\n\t\treturn min(query(a,mid,l,mid,L(k)),query(mid+1,b,mid+1,r,R(k)));\n\t}\n}\n\norz yjz()\n{\n\tscf(n); scf(x[(++n)]); scf(T);\n\tforn(i,1,n-1) scf(x[i]);\n\tseg1::modify(n,2*x[n-1]+x[n]);\n\tseg2::modify(n,T+x[n]);\n\tnrof(i,n-1,1)\n\t{\n\t\tdp[i]=linf;\n\t\tint lb=i+1,rb=n;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tint mid=lb+rb>>1;\n\t\t\tLL calc=2*(x[mid-1]-x[i]);\n\t\t\tif(calc>T) rb=mid-1; else lb=mid+1;\n\t\t}//rb\n\t\tLL t1=lb<=n?seg1::query(lb,n)-3*x[i]:linf;\n\t\tLL t2=i<rb?seg2::query(i+1,rb)-x[i]:linf;\n\t\tdp[i]=min(t1,t2);\n\t\t#ifdef DEBUG\n\t\tcout<<i<<' '<<rb<<'\\t'<<seg1::query(lb,n)<<' '<<t1<<'\\t'<<seg2::query(i+1,rb)<<' '<<t2<<' '<<dp[i]<<endl;\n\t\t#endif\n\t\tseg1::modify(i,dp[i]+2*x[i-1]+x[i]);\n\t\tseg2::modify(i,dp[i]+T+x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[1]+x[1]);\n\tfizzydavid ak la\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nint p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tint now=0;\n\tll Min;\n\tFor(i,1,n)\n\t{\n\t\tdp[i]=dp[i-1]+T;\t\n\t\tMin=inf;\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tif(now<i)cmin(dp[i],dp[now+1]+T);\n\t\tcmin(dp[i],Min+2*p[i]);\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,t,e,a[200005],dp[200005];\nint main(){\n\tn=read(),e=read(),t=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tmemset(dp,0x3f,sizeof(dp)),dp[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\tif(k==j+1)\n\t\t\t\t\tdp[i]=min(dp[i],max(dp[j]+a[i]-a[j]+a[i]-a[k],dp[j]+a[k]-a[j]+t)+a[i]-a[k]);\n\tprintf(\"%lld\",dp[n]-a[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(0, 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i], now_cost + 2 * inputs[i]);\n\n\t\twhile (next.empty() == false && 2 * (inputs[i] - inputs[next.top().second]) > t) {\n\t\t\tnext.pop();\n\t\t}\n\n\t\tif (next.empty() == false) {\n\t\t\tdp[i] = min(dp[i], next.top().first + t);\n\t\t}\n\t\tif (i != n - 1) {\n\t\t\tnext.push(make_pair(dp[i], i + 1));\n\t\t}\n\t}\n\tcout << dp[n - 1] + e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tLL p2 = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos = p2;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n//\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tif(ans[i] >= ans[pos] + data) p2 = pos;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[j], ans[i] + getdist(x, T,i, j));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Grand Contest 007\n// D - Shik and Game\n\n#include <cstdio>\n#include <algorithm>\n#define MAX_N 100000\n#define MAX_ELEMENTS (1 << 17)\n#define INF 1e18\nusing namespace std;\n\n\ntypedef long long int ll;\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  int n;\n  T dat[2 * MAX_ELEMENTS - 1];\n  void init(int _n);\n  void update(int k, T a);\n  T query(int a, int b, int k, int l, int r);\n  T query(int a, int b);\n};\n\ntemplate <typename T>\nvoid SegmentTree<T>::init(int _n) {\n  n = 1;\n  while (n < _n) {\n    n <<= 1;\n  }\n  for (int i = 0; i < 2 * n - 1; i++) {\n    dat[i] = INF;\n  }\n  return;\n}\n\ntemplate <typename T>\nvoid SegmentTree<T>::update(int k, T a) {\n  k += n - 1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n  return;\n}\n\n// [a, b), [l, r)\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b, int k, int l, int r) {\n  if (r <= a || b <= l) {\n    return INF;\n  }\n  if (a <= l && r <= b) {\n    return dat[k];\n  }\n  return min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n}\n\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b) {\n  return query(a, b, 0, 0, n);\n}\n\n\nint N, E, T;\nSegmentTree<ll> st;\nint x[MAX_N + 1];\nll dp[MAX_N + 1];\n\nint main() {\n\n  int j;\n\n  scanf(\"%d%d%d\", &N, &E, &T);\n  x[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  dp[0] = 0;\n  st.init(N);\n  st.update(0, dp[0]);\n  j = 0;\n  for (int i = 1; i <= N; i++) {\n    dp[i] = INF;\n    for (; (x[i] - x[j + 1]) * 2 > T; j++) {\n      dp[i] = min(dp[i], dp[j] + (x[i] - x[j + 1]) * 2);\n    }\n    dp[i] = min(dp[i], st.query(j, i) + T);\n    st.update(i, dp[i]);\n  }\n\n  printf(\"%lld\\n\", dp[N] + E);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2 - 1;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid+1;\n    }\n    else{\n        r = mid+1;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans  << \"\\n\";\n\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define X first\n#define Y second\nusing namespace std;\nconst int max_n = 1e6 + 20, inf = 1e12;\nint a[max_n], DP[max_n];\npair<int, int> seg[max_n * 4];\nint n, e, t, INF = 1e12, L;\npair<int, int> Merge(pii x, pii y) {\n    if (x.X < y.X)\n        return x;\n    return y;\n}\nvoid update(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg[id].X = val;\n        seg[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update(x, val, mid, e, id << 1 | 1);\n    else\n        update(x, val, b, mid, id << 1);\n    seg[id] = Merge(seg[id << 1 | 1], seg[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, 0};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get(l, r, b, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\nvoid out() {\n    for (int i = 1; i < n * 4; i++)\n        cout << seg[i].Y << \">>>>>\" << seg[i].X << \"   \";\n    cout << endl;\n}\nvoid solve() {\n    for (int i = 1; i < n; i++) {\n        int tmp = (lower_bound(a, a + n, a[i] - L) - a);\n        pii x = get(tmp, i), y = get(0, tmp);\n        //cout << tmp << endl;\n        DP[i] = min(x.X + t, y.X + 2 * (a[i] - a[y.Y])) + a[i];\n        DP[i] = min(DP[i] , DP[i - 1] + a[i] - a[i - 1] + t);\n  //      cout << DP[i] << endl;\n        update(i, DP[i - 1] - a[i - 1]);\n      //  cout << endl;\n        //out();\n    }\n}\nint32_t main() {\n    cin >> n >> e >> t;\n    L = (t+1) / 2;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < n * 4; i++)\n        seg[i].X = inf;\n    DP[0] = a[0] + t;\n    update(0, 0);\n    solve();\n    cout << DP[n - 1] + (e - a[n - 1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N];\n    rep(i,n)x[i]=lin();\n    int now=0;\n    ll ans=x[0];\n    while(now<n){\n        int go=(upper_bound(x,x+n,x[now]+t))-x-1;\n        if(go<n)\n        ans+=(x[go]-x[now])*3+max((ll)0,t-(x[go]-x[now])*2);\n        else{\n            ans+=(x[go-1]-x[now])*3+e-x[n-1];\n            cout<<ans;return 0;\n        }\n        if(go+1<n)\n        {ans+=x[go+1]-x[go];\n        now=go+1;}\n        else{\n            cout<<ans+e-x[n-1];return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    for(int i = 0; i < N; i++){\n        cin >> x[i];\n        x_[i] = x[i]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]);\n    sgt2.update(0, dp[0]-2*x[0]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 0; i < N; i++){\n        int ut = upper_bound(x, x+N, x[i] - (T+1)/2)-x-1;\n        int lt = lower_bound(x, x+N, x[i] - (T-1)/2)-x;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        tmp1 = sgt2.query(0, min(ut+1, i+1))+x[i]*3;\n        \n        tmp2 = sgt1.query(lt, i+1)+x[i]+T;\n        dp[i+1] = min(tmp1, tmp2);\n        if(i+1 != N){\n            sgt1.update(i+1, dp[i+1]-x[i]);\n            sgt2.update(i+1, dp[i+1]-x[i]-2*x[i+1]);\n        }\n        // cout << ut << ' ' << lt << endl;\n        // cout << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i+1]-x[i] << ' ' << dp[i+1]-x[i]-2*x[i+1] << endl;\n        // cout << dp[i+1] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n, e, t;\nint x[maxn];\nlong long st[2][4 * maxn];\nlong long dp[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &e, &t) < 3) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  return true;\n}\n\nvoid buildst(int t, int v, int tl, int tr) {\n  st[t][v] = infll;\n  if (tl == tr - 1) {\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  buildst(t, 2 * v, tl, tm);\n  buildst(t, 2 * v + 1, tm, tr);\n}\n\nvoid update(int t, int v, int tl, int tr, int l, int r, long long val) {\n  if (l == tl && r == tr) {\n    st[t][v] = min(st[t][v], val);\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  if (l < tm) {\n    update(t, 2 * v, tl, tm, l, min(r, tm), val);\n  }\n  if (r > tm) {\n    update(t, 2 * v + 1, tm, tr, max(l, tm), r, val);\n  }\n}\n\nlong long get(int t, int v, int tl, int tr, int pos) {\n  long long res = st[t][v];\n  if (tl == tr - 1) {\n    return res;\n  }\n  int tm = (tl + tr) / 2;\n  if (pos < tm) {\n    res = min(res, get(t, 2 * v, tl, tm, pos));\n  } else {\n    res = min(res, get(t, 2 * v + 1, tm, tr, pos));\n  }\n  return res;\n}\n\nvoid solve() {\n  buildst(0, 1, 0, n + 1);\n  buildst(1, 1, 0, n + 1);\n  {\n    int l = 0, r = n;\n    while (l < r - 1) {\n      int m = (l + r) / 2;\n      if (2 * (x[m] - x[0]) >= t) {\n        r = m;\n      } else {\n        l = m;\n      }\n    }\n    int pos = r;\n    if (pos < n) {\n      update(0, 1, 0, n, pos, n, -2 * x[0]);\n    }\n    if (0 < pos) {\n      update(1, 1, 0, n, 0, pos, t);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    dp[i] = min(get(0, 1, 0, n, i) + 3ll * x[i], get(1, 1, 0, n, i) + x[i]);\n    if (i + 1 == n) {\n      break;\n    }\n    int pos;\n    {\n      int l = i + 1, r = n;\n      while (l < r - 1) {\n        int m = (l + r) / 2;\n        if (2 * (x[m] - x[i + 1]) >= t) {\n          r = m;\n        } else {\n          l = m;\n        }\n      }\n      pos = r;\n    }\n    if (pos < n) {\n      update(0, 1, 0, n, pos, n, dp[i] - 2ll * x[i + 1] - x[i]);\n    }\n    if (i + 1 < pos) {\n      update(1, 1, 0, n, i + 1, pos, dp[i] + t - x[i]);\n    }\n  }\n  long long res = dp[n - 1] + e - x[n - 1];\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 1e5 + 100;\n\nint n;\nint q[maxN + 1];\nLL x[maxN + 1], T, E, f[maxN + 1], ans;\n\nint main()\n{\n\tscanf(\"%d %lld %lld\", &n, &E, &T);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]), ans += x[i] - x[i - 1];\n\tans += E - x[n];\n\n\tint now = 0, head = 1, tail = 0;\n\tLL minT = 1e18; q[++ tail] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\twhile(head <= tail && 2 * (x[i] - x[ q[head] + 1 ]) >= T) head ++;\n\t\twhile(now < i && 2 * (x[i] - x[now + 1]) >= T) \n\t\t\tminT = min(minT, f[now] - 2 * x[now + 1]), now ++;\n\t\tf[i] = minT + 2 * x[i];\n\t\tif(head <= tail) f[i] = min(f[i], f[ q[head] ] + T);\n\t\twhile(head <= tail && f[i] <= f[ q[tail] ]) tail --;\n\t\tq[++ tail] = i;\n\t}\n\n\tprintf(\"%lld\", ans + f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\nusing namespace std;\nint n,E,T,t,a[100005];\nll dp[100005];\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tll mn=1ll<<60;\n\tFor(i,1,n){\n\t\tfor (;T<=2*(a[i]-a[t+1]);t++)\n\t\t\tmn=min(mn,dp[t]-2*a[t+1]);\n\t\tdp[i]=min(dp[t]+T,mn+2*a[i]);\n\t}\n\tprintf(\"%lld\",E+dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvint v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tit--;\n\t\tmins(dp[min(it+1,n-1)],dp[i]+T);\n\t\tint p = it+2;\n\t\twhile(p<n){\n\t\t\tif(dp[p]<=dp[i]+2*(v[p-1]-v[i])) break;\n\t\t\tdp[p]=dp[i]+2*(v[p-1]-v[i]);\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define rep(i,n) for(ll i=0;i<(n);i++)\n\nusing namespace std;\n\n\nint main(){\n    ll n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    rep(i, n)   cin >> x[i];\n\n    vector<vector<ll>> memo(n, vector<ll>(n, pow(10, 10)));\n\n    rep(i, n){\n        for(ll j = i+1; j < n; j++){\n            ll cost1 = t + x[j] - x[i] + (j-i+1)*t;\n            ll cost2 = 3 * (x[j] - x[i]) + 2*max(t- 2*(x[j]-x[i]), 0LL);\n            memo[i][j] = min(cost1, cost2);\n        }\n    }\n\n    rep(i, n){\n        for(ll j = i+1; j < n-1; j++){\n            for(ll k = j+1; k < n; k++){\n                memo[i][k] = min(memo[i][k], memo[i][j] + memo[j][k] - t);\n            }\n        }\n    }\n\n\n    cout << x[0] + memo[0][n-1] + (e-x[n-1]) - (n-2)*t << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\n\tll dp1 = T;\n\n\tif(opt - 1 >= 0)\n\t\tdp1 += dp[opt - 1];\n\n\tll dp2 = a[idx] * 2;\n\n\tif(opt - 1 >= 0)\n\t\tdp2 += min(dpRMQ[opt - 1] , 0LL);\n\telse\n\t\treturn dp1;\n\treturn(min(dp1 , dp2));\n\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = - a[0] * 2;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tdpRMQ[i] = min(dpRMQ[i - 1] , dp[i - 1] - a[i] * 2);\n\t\tdp[i] = findDp(i);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint N, E, T;\n\twhile(cin >> N >> E >> T){\n\t\tlong long res = E;\n\t\tvector<int> x(N);\n\t\tfor(int i=0;i<N;i++) cin >> x[i];\n\t\tvector<long long> dp(N+1);\n\t\tdp[N-1] = E+T; dp[N] = E;\n\t\tfor(int i=N-2;i>=0;i--){\n\t\t\tdp[i] = dp[i+1] + T;\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tdp[i] = min(dp[i], max(T, 2*(x[j]-x[i])) + dp[j+1]);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvll v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tv.PB(INFL);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tmins(dp[min(it,n-1)],dp[i]+T);\n\t\tint p = it+1;\n\t\tint it2 = upper_bound(ALL(v), v[i]+T)-v.begin();\n\t\treep(j,p,it2+1){\n\t\t\tmins(dp[min(j,n-1)], dp[i]+2*(v[j-1]-v[i]));\n\t\t\tif(p+100<j&&j%5==0){\n\t\t\t\tj += 10;\n\t\t\t}\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nnamespace Segment_tree {\n\ttemplate<typename T>\n\tclass segment_tree {\n\t\tvector<T> dat;\n\t\tint n;\n\t\tT e;\n\t\tstd::function<T(T, T)> f;\n\t\tT query_implement(int a, int b, int k, int l, int r) {\n\t\t\tif (r <= a || b <= l) return e;\n\t\t\tif (a <= l && r <= b) return dat[k];\n\n\t\t\tT v1 = query_implement(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT v2 = query_implement(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn f(v1, v2);\n\t\t}\n\tpublic:\n\t\tsegment_tree(int n_, T _e, T(*calc)(T lhs, T rhs)) {\n\t\t\te = _e;\n\t\t\tf = calc;\n\t\t\tn = 1;\n\t\t\twhile (n < n_) n *= 2;\n\t\t\tdat.resize(2 * n - 1);\n\t\t\tfor (int i = 0; i < 2 * n - 1; i++)\n\t\t\t\tdat[i] = e;\n\t\t}\n\n\t\tvoid update(int k, int a) {\n\t\t\tk += n - 1;\n\t\t\tdat[k] = a;\n\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tdat[k] = f(dat[k * 2 + 2], dat[k * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT query(int a, int b) { return query_implement(a, b, 0, 0, n); }\n\t};\n}\nlong long int f(long long int i, long long int j) { return min(i, j); }\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\t\n\tSegment_tree::segment_tree<long long int> seg(n,1e10,f);\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tint index=lower_bound(ALL(x), int(x[i]-double(t)/2+0.001)) - x.begin();\n\t\tif (index >= i)\n\t\t\tindex = i-1;\n\t\tindex--;\n\t\tindex--;\n\t\tif (index > 0)\n\t\t\tres = min(res, dp[index] - 2 * x[index] - x[index + 1]);\n\t\tindex = lower_bound(ALL(x), int(x[i] - double(t) / 2+0.001)) - x.begin();\n\t\tindex--;\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t\tif (index < i ) {\n\t\t\tlong long int a = seg.query(index, i-1 );\n\t\t\tres = min(res, a + x[i]);\n\t\t}\n\t\tdp[i] = res;\n\t\tif(i<n-1)\n\t\tseg.update(i,dp[i] - 2 * x[i] - x[i + 1] + t - 2 * x[i + 1]);\n\t}\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 8001;\nll dp[N];\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  assert (n < N);\n  VL x(n + 1);\n  x[0] = 0;\n  REP(i, 0, n) {\n    cin >> x[i + 1];\n  }\n  dp[0] = 0;\n  REP(i, 0, n) {\n    ll &ret = dp[i + 1];\n    REP(j, 0, i + 1) {\n      ret = min(ret, dp[j] + max(t, 2 * (x[i + 1] - x[j + 1])));\n    }\n  }\n  cout << dp[n] << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "\n// default code for competitive programming\n// ver 3.1415 {{{\n\n// Includes\n#include <bits/stdc++.h>\n\n// Defines\n#define NAME(x) #x\n#define SZ(c) (int)(c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i, e) for( int i = 0 ; i < (e) ; i++ )\n#define ITER(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define REP(i, s, e) for(int i = (s); i <= (e); i++)\n#define REPD(i, s, e) for(int i = (s); i >= (e); i--)\n#define IOS ios_base::sync_with_stdio( 0 )\n#define DEBUG 1\n#define fst first\n#define snd second\n#define PB push_back\n#ifdef ONLINE_JUDGE\n#define FILE( fn ) \\\n    freopen(fn\".in\",\"r\",stdin); \\\nfreopen(fn\".out\",\"w\",stdout);\n#else\n#define FILE( fn )\n#endif\n\n#ifdef AKAI\n#define debug( ... ) fprintf( stderr , __VA_ARGS__ )\n#else\n#define debug( ... )\n#endif\n\nusing namespace std;\n\n// Typedefs\ntypedef double real;\ntypedef long long ll;\ntypedef pair<ll, int> pli;\ntypedef tuple<ll, int> tli;\ntypedef pair<int, int> pii;\ntypedef tuple<int, int> tii;\ntypedef unsigned long long ull;\n\n// Some common const.\nconst double EPS = 1e-8;\nconst double Pi = acos(-1);\n\n// Equal for double\nbool inline equ(double a, double b)\n{return fabs(a - b) < EPS;}\n\nint _R( int& x ) { return scanf( \"%d\" , &x ); }\nint _R( ll& x ) { return scanf( \"%\" PRId64 , &x ); }\nint _R( double& x ) { return scanf( \"%lf\" , &x ); }\nint _R( char* s ) { return scanf( \"%s\" , s ); }\n\nint R() { return 0; }\n\n  template< typename T1 , typename... T2 >\nint R( T1& x , T2&... tail )\n{\n  int tmp = _R( x );\n  return tmp + R( tail... );\n}\n\n  template< typename Iter , typename F >\ninline void out( Iter s , Iter e , F of )\n{\n  bool flag = 0;\n  for( Iter it = s ; it != e ; it++ )\n  {\n    if( flag ) printf( \" \" );\n    else flag = 1;\n    of( *it );\n  }\n  puts( \"\" );\n}\n\n// }}}\n// start ~~QAQ~~\n\nconst int MAXN = 1e5+10;\nconst ll  INF  = 1000000000000000;\n\nint n;\nll E , T;\nll x[ MAXN ];\nll dp[ MAXN ] , mn[ MAXN ];\n\ninline ll f( int i ) {\n  return T+dp[ i ]-x[ i ];\n}\n\ninline ll g( int i ) {\n  return dp[ i ]-x[ i ]-2*x[ i+1 ];\n}\n\nint main() {\n  R( n , E , T );\n  REP( i , 1 , n ) R( x[ i ] );\n  dp[ 0 ] = 0;\n  deque<int> dq{ 0 };\n  int j = 0;\n  mn[ 0 ] = g( 0 );\n  REP( i , 1 , n ) {\n    while( SZ( dq ) && 2*x[ dq.front()+1 ] < 2*x[ i ]-T )\n      dq.pop_front();\n    while( j < i && 2*x[ j+1 ] < 2*x[ i ]-T ) j++;\n    dp[ i ] = INF;\n    if( SZ( dq ) ) dp[ i ] = x[ i ] + f( dq.front() );\n    if( j > 0 ) dp[ i ] = min( dp[ i ] , 3*x[ i ] + mn[ j-1 ] );\n    //printf( \"%lld dp %d %lld j %d\\n\" , x[ i ] , i , dp[ i ] , j );\n    while( SZ( dq ) && f( dq.back() ) >= f( i ) )\n      dq.pop_back();\n    dq.push_back( i );\n    mn[ i ] = min( mn[ i-1 ] , g( i ) );\n  }\n  printf( \"%lld\\n\" , dp[ n ] + E-x[ n ] );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n#define INF 1e17+7\nstruct SegmentTree {\nprivate:\n    int n; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+1),seg2(n+1);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-(x[i]-x[mid+1])*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long s64;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nconst int N=1e5+5;\nint x[N];s64 dp[N],mn[N];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\trep(i,1,n)scanf(\"%d\",x+i);\n\tmn[n+1]=1e18;\n\tint j=n;\n\tfor(int i=n;i;--i)\n\t{\n\t\twhile(2*(x[j]-x[i])>t)--j;\n\t\tdp[i]=min(dp[j+1]+t,mn[j+1]-2*x[i]);\n\t\tmn[i]=min(mn[i+1],dp[i+1]+2*x[i]);\n\t}\n\tcout<<dp[1]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N;\nll E, T, x[100100], dp[100100];\n\nint main () {\n        scanf(\"%d %lld %lld\", &N, &E, &T);\n        fo(i, 0, N) scanf(\"%lld\", &x[i]);\n        x[N] = E;\n\n        fo(i, 1, N+1) dp[i] = 1e18;\n        dp[0] = x[0];\n        fo(i, 0, N) {\n                fo(j, 1, N+1) {\n                        //let's finish to dp[j]\n                        //i.e. do i to j-1 inclusive\n                        ll tot = x[j-1] - x[i];\n                        if (tot*2 <= T) dp[j] = min(dp[j], dp[i] + T + tot + x[j] - x[j-1]);\n                        else dp[j] = min(dp[j], dp[i] + tot * 3 + x[j] - x[j-1]);\n                }\n        }\n\n        printf(\"%lld\\n\", dp[N]);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\nconst LL INF = 123456789012345;\n\nconst int ST_MAX = (1 << 20);\n\ntemplate <class T> class ST{\n\tT x[ST_MAX * 2];\n\t\n\tT eval(T a , T b){\n\t\treturn min(a , b);\n\t}\n\t\n\tvoid ren(int a){\n\t\tx[a] = eval(x[2 * a] , x[2 * a + 1]);\n\t\tif(a > 0) ren(a / 2);\n\t}\n\t\n\tT read_ST(int a , int b , int e , int s , int f){\n\t\tif(e <= s || f <= b) return INF;\n\t\tif(s <= b && e <= f) return x[a];\n\t\treturn eval(read_ST(2 * a , b , (b + e) / 2 , s , f) , read_ST(2 * a + 1 , (b + e) / 2 , e , s , f));\n\t}\n\t\npublic:\n\t\n\tST(){\n\t\tfill(x , x + 2 * ST_MAX , INF);\n\t}\n\t\n\tvoid put(int a , T b){\n\t\tx[a + ST_MAX] = b;\n\t\tren((a + ST_MAX) / 2);\n\t}\n\t\n\tT get(int s , int f){\n\t\treturn read_ST(1 , 0 , ST_MAX , s , f);\n\t}\n};\n\nST<LL> b;\nint N , E , T;\nint x[100010];\nLL dp[100010];\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &E , &T);\n\trepp(i,1,N+1){\n\t\tscanf(\"%d\" , x + i);\n\t}\n\tLL a = 0;\n\tb.put(0,0);\n\tint z = 1;\n\trepp(i,1,N+1){\n\t\twhile(z < i && T <= 2 * (x[i] - x[z])){\n\t\t\ta = min(a , dp[z-1] - 2 * x[z] - x[z-1]);\n\t\t\t++z;\n\t\t}\n\t\tdp[i] = min(a + 3 * x[i] , b.get(z-1,i) + T + x[i]);\n\t\tb.put(i , dp[i] - x[i]);\n\t}\n\tprintf(\"%lld\\n\" , dp[N] + E - x[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define PB push_back\n#define PF push_front\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn = 1e5 + 100;\nconst ll inf = 1e18;\n\nll x[maxn], dp[maxn];\n\nclass node {\n\tpublic:\n\t\tll mnm;\n\t\tll lzy;\n\t\tnode () {\n\t\t\tmnm = inf;\n\t\t}\n};\n\nnode seg[4 * maxn];\n\nvoid propagate (int, int, int);\n\nll get (int id, int L, int R, int l, int r) {\n\tif (L == l and R == r)\n\t\treturn seg[id].mnm;\n\tpropagate (id, L, R);\n\tint mid = (L + R) >> 1;\n\tll ret = inf;\n\tif (mid > l)\n\t\tret = min(ret, get(2 * id + 0, L, mid, l, min(mid, r)));\n\tif (mid < r)\n\t\tret = min(ret, get(2 * id + 1, mid, R, max(l, mid), r));\n\treturn ret;\n}\n\nvoid update(int id, int L, int R, int l, int r, ll val) {\n\tif (L == l and R == r) {\n\t\tseg[id].mnm += val;\n\t\tseg[id].lzy += val;\n\t\treturn;\n\t}\n\tpropagate (id, L, R);\n\tint mid = (L + R) >> 1;\n\tif (mid > l)\n\t\tupdate(2 * id + 0, L, mid, l, min (mid, r), val);\n\tif (mid < r)\n\t\tupdate(2 * id + 1, mid, R, max (l, mid), r, val);\n\tseg[id].mnm = min (seg[2 * id + 0].mnm, seg[2 * id + 1].mnm);\n}\n\nvoid propagate (int id, int L, int R) {\n\tif (seg[id].lzy == 0)\n\t\treturn;\n\tint mid = (L + R) >> 1;\n\tupdate(2 * id + 0, L, mid, L, mid, seg[id].lzy);\n\tupdate(2 * id + 1, mid, R, mid, R, seg[id].lzy);\n\tseg[id].lzy = 0;\n}\n\nll dis (int fi, int se) { return abs (x[fi] - x[se]); }\n\nint main () {\n\tios_base::sync_with_stdio (false);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tint ptr = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tupdate (1, 1, n + 1, i, i + 1, -inf + dp[i - 1] + dis(i - 1, i) + t);\n\t\tif (i != 1)\n\t\t\tupdate (1, 1, n + 1, 1, i, 3*dis (i - 1, i));\n\t\tif (ptr != i)\n\t\t\tupdate (1, 1, n + 1, ptr, i, -2 * dis (i - 1, i)); \n\t\twhile (2 * (x[i] - x[ptr]) > t) {\n\t\t\tupdate (1, 1, n + 1, ptr, ptr + 1, 2 * dis(ptr, i) - t);\n\t\t\tptr ++;\n\t\t}\n\t\tdp[i] = get (1, 1, n + 1, 1, i + 1);\n//\t\tcout << dp[i] << endl;\n//\t\tdp[i] = min (dp[i], dp[j-1] + dis(j-1, j) + 3*dis(j, i) + max(0ll,t-2*dis(j, i)));\n\t}\n\tcout << dp[n] + e - x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nconst int N=1e5+5;\nconst long long inf=2e12+7;\nlong long dp[N],dp1[4*N],lazy[4*N],pos[N];\nvoid upd(int idx,int l,int r,int lef,int rig,int val){\n\tif(l>rig||r<lef){\n\t\treturn;\n\t}\n\tif(l>=lef&&r<=rig){\n\t\tif(dp1[idx]<=val){\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif(dp1[idx]>val){\n\t\t\t\tlazy[idx]=val;\n\t\t\t\tdp1[idx]=val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif(lazy[idx]!=inf){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\tlazy[idx]=inf;\n\t}\n\tupd(2*idx,l,(l+r)/2,lef,rig,val);\n\tupd(2*idx+1,(l+r)/2+1,r,lef,rig,val);\n\tdp1[idx]=max(dp[2*idx],dp[2*idx+1]);\n}\nlong long getans(int idx,int l,int r,int pos1){\n\tif(l>pos1||r<pos1){\n\t\treturn inf;\n\t}\n\tif(l==r){\n\t\treturn dp1[idx];\n\t}\n\tif(lazy[idx]!=inf){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\tlazy[idx]=inf;\n\t}\n\treturn min(getans(2*idx,l,(l+r)/2,pos1),getans(2*idx+1,(l+r)/2+1,r,pos1));\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,end,time,i,j,k;\n\tcin>>n>>end>>time;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>pos[i];\n\t}\n\tfor(i=1;i<N;i++){\n\t\tdp[i]=inf;\n\t}\n\tfor(i=1;i<4*N;i++){\n\t\tdp1[i]=inf;\n\t}\n\tfor(i=1;i<4*N;i++){\n\t\tlazy[i]=inf;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(i!=0){\n\t\t\tdp[i]=min(dp[i],getans(1,1,n,i)+3*pos[i]);\n\t\t}\n\t\tk=upper_bound(pos+1,pos+1+n,(time+2*pos[i+1])/2)-pos-1;\n\t\tdp[k]=min(dp[k],dp[i]+time+pos[k]-pos[i]);\n\t\tif(k!=n){\n\t\t\tupd(1,1,n,k+1,n,dp[i]-2*pos[i+1]-pos[i]);\n\t\t}\n\t}\n\tdp[n]=min(dp[n],getans(1,1,n,n)+3*pos[n]);\n\tcout<<dp[n]+end-pos[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << (x) << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tassert(n <= 2000);\n\tvector<ll> a(n + 1);\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tvector<ll> dp(n + 1, INF);\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\trep(j, i) {\n\t\t\tll ma = max(2 * (a[i] - a[j + 1]), t);\n\t\t\tchmin(dp[i], dp[j] + ma);\n\t\t}\n\t}\n\tcout << dp[n] + e << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <typename T> inline void Read(T& x) {\n\tint si = 1; char c = getchar(); x = 0;\n\twhile(!isdigit(c)) si = c == '-' ? -1 : si, c = getchar();\n\twhile(isdigit(c)) x = x * 10 + c - 48, c = getchar();\n\tx *= si;\n}\ntemplate <typename T, typename... Args>\ninline void Read(T& x, Args&... args) { Read(x); Read(args...); }\n\ntypedef long long ll;\n\nconst int kN = 1e5 + 5, kInf = 0x3f3f3f3f;\n\nll x[kN], f[kN];\nstd::deque<int> que;\n\nint main() {\n\tmemset(f, 0xff, sizeof(f));\n\tint n; ll T, E; Read(n, E, T);\n\tfor(int i = 1; i <= n; ++i) Read(x[i]);\n\tx[n + 1] = E;\n\tint ptr = 0; ll min_fi = kInf;\n\tf[0] = x[1];\n\tque.push_back(0);\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(; 2 * (x[i] - x[ptr + 1]) >= T; ++ptr)\n\t\t\tmin_fi = std::min(min_fi, f[ptr] - 3 * x[ptr + 1]);\n\t\twhile(!que.empty() && que.front() < ptr) que.pop_front();\n\t\tif(!que.empty()) {\n\t\t\tint tmp = que.front();\n\t\t\tf[i] = f[tmp] - x[tmp + 1] + T;\n\t\t}\n\t\tf[i] = std::min(f[i], min_fi + 2 * x[i]) + x[i + 1];\n\t\twhile(!que.empty() && f[que.back()] - x[que.back() + 1] > f[i] - x[i + 1])\n\t\t\tque.pop_back();\n\t\tque.push_back(i);\n\t}\n\tprintf(\"%lld\", f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define all(c) c.begin(), c.end()\n#define gmax(x,y) x=max(x,y)\n#define gmin(x,y) x=min(x,y)\n#define gadd(x,y) x=add(x,y)\n#define gmul(x,y) x=mul(x,y)\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int N = 1e5 + 5;\nconst ll inf = 1e15;\nll dp[N];\n\nint main(){\n\tcin.tie(0);\n\tcout.tie(0);\n\tios_base::sync_with_stdio(0);\n\tll n,e,t;\n\tcin >> n >> e >> t;\t\n\tvector<ll> pos(n+1);\n\trep(i,0,n)cin >> pos[i];\n\tpos[n] = pos[n-1];\n\tll best = inf;\n\tint jp = n - 1;\n\tfor(int i = n - 1;i >= 0; --i){\n\t\tif(pos[n-1] - pos[i] <= t/2){\n\t\t\tdp[i] = t + pos[n-1] - pos[i];\n\t\t}\n\t\telse{\n\t\t\tif(i < n-1)best += 3 * (pos[i+1] - pos[i]);\n\t\t\twhile(jp >= 0 && pos[jp] - pos[i] >= (t+1)/2){\n\t\t\t\tgmin(best, 3 * (pos[jp] - pos[i]) + pos[jp+1] - pos[jp] + dp[jp+1]);\n\t\t\t\t--jp;\n\t\t\t}\n\t\t\tdp[i] = best;\n\t\t\tgmin(dp[i], t + pos[i+1] - pos[i] + dp[i+1]);\n\t\t}\n\t}\n\tcout << dp[0] + pos[0] + e - pos[n-1] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n \n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n \n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n} \nconst int N = 1e5+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, t, e, px[N];\nint64 f[N];\nint main()\n{\n    n = read(), e = read(), t = read();\n    for(int i = 1; i <= n; ++i) px[i] = read(); px[n+1] = e;\n    for(int i = 1; i <= n+1; ++i)\n    {\n        f[i] = f[i-1]+px[i]-px[i-1]+t*(i <= n);\n        for(int j = 1; j <= i; ++j)\n            if(2*(px[i]-px[j]) >= t) \n                f[i] = min(f[i], f[j-1]+px[j]-px[j-1]+3ll*(px[i]-px[j]));\n    }\n    printf(\"%lld\\n\", f[n]+e-px[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  X.push_back(e);\n  vector<ll> dp;\n  rep(i,n+1){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n\n  rep(i,n){\n    int j;\n    j = n;\n    chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j = lower_bound(all(X), X[i+1] + t + 0.1) - X.begin();\n    if(X[j] == X[i+1] + t/2.0) j++;\n\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j--;\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n  }\n\n  cout<<dp[n] + e - X[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n\nunsigned readUnsigned() {\n    int c;\n    do { c = ::getchar_unlocked(); } while (c < '0');\n    unsigned result = c - '0';\n    while ((c = ::getchar_unlocked()) >= '0') {\n        result *= 10;\n        result += c - '0';\n    }\n    return result;\n}\n\n\nconst unsigned MAX_N = 100 * 1000;\nunsigned N, E, T;\nunsigned xs[MAX_N];\n\nlong long unsigned simpleDP() {\n    /*\n     * dp[i]: After just giving candy to bear xs[i] and given that all coins\n     *        from bears xs[0]...xs[i-1] have been collected, how long does it\n     *        take to end the game?\n     *\n     */\n    uint64_t dp[MAX_N];\n    dp[N - 1] = T + E - xs[N - 1];\n    for (unsigned i = N - 1; i--;) {\n        dp[i] = T + xs[i+1] - xs[i] + dp[i+1];\n\n        /*\n         * Try all routes xs[i] -> xs[i+k] -> xs[i] -> xs[i+k].\n         *\n         * 1) Instead of waiting at xs[i], we go walk xs[i+k].\n         * 2) We walk back to xs[i].\n         * 3) If the coin hasn't appeared yet, we wait for it.\n         * 4) We go to xs[i+k+1], if it exists.  The coin xs[i+k] is ready.\n         * 5) To finish the game, the cost is dp[i+k+1].\n         */\n        unsigned j = i + 1;\n        /*\n        for (unsigned step = 1 + (N - j) / 2; step; step /= 2) {\n            for (; j + step < N; j += step) {\n                uint64_t distance = 2 * (xs[j] - xs[i]);\n                if (distance > T) {\n                    break;\n                }\n            }\n        }\n        */\n        for (; j < N; ++j) {\n            uint64_t cost = 2 * (xs[j] - xs[i]);\n            if (cost < T) cost = T;\n            if (j + 1 < N) {\n                cost += xs[j+1] - xs[i] + dp[j+1];\n            }\n            else {\n                cost += E - xs[i];\n            }\n            dp[i] = std::min(dp[i], cost);\n        }\n    }\n    return xs[0] + dp[0];\n}\n\nint main() {\n    N = readUnsigned();\n    E = readUnsigned();\n    T = readUnsigned();\n    for (unsigned i = 0; i < N; ++i) {\n        xs[i] = readUnsigned();\n    }\n\n    printf(\"%llu\\n\", simpleDP());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,E,T;\nint X[111111];\nint dp[111111];\n\nsigned main(){\n    cin>>N>>E>>T;\n    rep(i,N)cin>>X[i+1];\n\n    int ei=INF;\n    int L=1;\n    deque<pint>deq;\n    for(int i=1;i<=N;i++){\n        int tmp=dp[i-1]+X[i]-X[i-1];\n        while(deq.size()&&deq.back().fi>T+tmp-X[i])deq.pop_back();\n        deq.push_back({T+tmp-X[i],i});\n        while((X[i]-X[L])*2>T){\n            chmin(ei,dp[L-1]+X[L]-X[L-1]-3*X[L]);\n            if(deq.front().se==L)deq.pop_front();\n            L++;\n        }\n\n        dp[i]=min(deq.front().fi+X[i],ei+3*X[i]);\n    }\n\n    cout<<dp[N]+E-X[N]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nstruct LazySegmentTree\n{\n    //A: data, B: 作用素\n    using T_A = int;\n    using T_B = int;\n    T_A id_A = INF;\n    T_B id_B = INF;\n    int N;\n    vector<T_A> dat;\n    vector<T_B> ope;\n\n    T_A F_AA(T_A u, T_A v){\n        return min(u, v);\n    }\n\n    T_A F_AB(T_A u, T_B v, int sz){\n        return min(u, v);\n    }\n\n    T_B F_BB(T_B u, T_B v){\n        return min(u, v);\n    }\n\n    LazySegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T_A>(2 * N - 1, id_A);\n        ope = vector<T_B>(2 * N - 1, id_B);\n    }\n\n    LazySegmentTree(int n, vector<T_A> v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T_A>(2 * N - 1, id_A);\n        ope = vector<T_B>(2 * N - 1, id_B);\n        REP(i, n) dat[i + N - 1] = v[i];\n        IREP(i, N - 1) dat[i] = F_AA(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n    //遅延評価\n    void eval(int k, int l, int r){\n        if(ope[k] != id_B){\n            dat[k] = F_AB(dat[k], ope[k], r - l);\n            if(r - l > 1){\n                ope[k * 2 + 1] = F_BB(ope[k * 2 + 1], ope[k]);\n                ope[k * 2 + 2] = F_BB(ope[k * 2 + 2], ope[k]);\n            }\n            ope[k] = id_B;\n        }\n    }\n\n    void update(int a, int b, T_B x, int k, int l, int r){\n\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b){\n            ope[k] = F_BB(ope[k], x);\n            eval(k, l, r);\n        }else{\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n            dat[k] = F_AA(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n\n    }\n\n    T_A get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id_A;\n\n        eval(k, l, r);\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T_A vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T_A vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F_AA(vl, vr);\n        }\n    }\n\n    //[a,b)の区間更新\n    void update(int a, int b, T_B x){ update(a, b, x, 0, 0, N); }\n\n    //[a, b)の演算結果\n    T_A get(int a, int b){ return get(a, b, 0, 0, N); }\n\n    T_A val(int k){ return get(k, k + 1); }\n};\n\nsigned main(){\n\n    int N, E, T; cin >> N >> E >> T;\n    vec x(N); cin >> x;\n\n    LazySegmentTree ST1(N), ST2(N);\n    int t0 = 0;\n    REP(i, N){\n        int t;\n        if(i == 0) t = t0 + x[i];\n        else t = t0 + x[i] - x[i - 1];\n\n        int i0 = Upper_bound(x, x[i] + T / 2);\n        ST1.update(i, i0, t + T - x[i]);\n        ST2.update(i0, N, t - 3 * x[i]);\n\n        int v1 = ST1.val(i) + x[i];\n        int v2 = ST2.val(i) + 3 * x[i];\n        t0 = min(v1, v2);\n    }\n    int ans = t0 + E - x[N - 1];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int64 i = 0; i < (int64)(n); i++)\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nstruct SegNode\n{\n  int64 v;\n\n  SegNode(int64 v) : v(v) {}\n\n  SegNode operator*(const SegNode &r) const\n  {\n    return (v < r.v ? *this : r);\n  }\n} e(INF);\n\nstruct SegmentTree\n{\n  int sz;\n  vector< SegNode > seg;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, e);\n  }\n\n  void update(int k, const SegNode &x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = seg[2 * k + 1] * seg[2 * k + 2];\n    }\n  }\n\n  SegNode query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (e);\n    if(a <= l && r <= b) return (seg[k]);\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) * query(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n\n  SegNode query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nint main()\n{\n  int64 N, E, T, X[100001] = {};\n\n  cin >> N >> E >> T;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n  X[N] = E;\n\n  vector< int64 > dp1(N + 1, INF);\n  SegmentTree seg1(N + 1), seg2(N + 1);\n\n  auto update = [&](int idx, int64 cost)\n  {\n    if(dp1[idx] > cost) {\n      dp1[idx] = cost;\n      seg1.update(idx, dp1[idx] - X[idx] + T);\n      seg2.update(idx, dp1[idx] - 3 * X[idx]);\n    }\n  };\n  update(0, X[0]);\n\n\n  int ptr = 0;\n\n  for(int i = 1; i <= N; i++) {\n\n    while(ptr <= N && (X[i - 1] - X[ptr]) * 2 > T) {\n      ++ptr;\n    }\n\n    update(i, min(seg1.query(ptr, i).v + X[i], seg2.query(0, ptr).v + X[i] + 2 * X[i - 1]));\n  }\n\n  cout << dp1.back() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long f[101010];\nlong long x[101010];\nlong long E,T;\nlong long calc(int i,int j)\n{\n\treturn max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]);\n}\nint main()\n{\n\tint n;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]+T;\n\t\tint l=1,r=i-1;\n\t\twhile(r-l>2)\n\t\t{\n\t\t\tint m1=(2*l+r)/3,m2=(l+2*r+2)/3;\n\t\t\tif(calc(i,m1)<calc(i,m2))\n\t\t\t\tr=m2;\n\t\t\telse\n\t\t\t\tl=m1;\n\t\t}\n\t\tfor(int j=l;j<=r;j++)\n\t\t\tf[i]=min(f[i],max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]));\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tll ans=x[1];\n\tint pos=0; x[0]=x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint l=x[i]-x[pos];\n\t\tif(l<t) continue;\n\t\tif(l*2>(i-pos)*(ll)(t))\n\t\t{\n\t\t\tint g=i-1;\n\t\t\tint l2=x[g]-x[pos];\n\t\t\tif(2*l2>t) ans+=min(l2*3LL,(g-pos)*ll(t)+l2);\n\t\t\telse ans+=(g-pos)*ll(t)+l2;\n\t\t\tpos=g;\n\t\t}\n\t}\n\t{\n\t\tint g=n;\n\t\tint l2=x[g]-x[pos];\n\t\tif(2*l2>t) ans+=min(l2*3LL,(g-pos)*ll(t)+l2);\n\t\telse ans+=(g-pos)*ll(t)+l2;\n\t\tpos=g;\n\t}\n\tans+=e-x[n];\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint n, e, t;\nint x[101010];\nlong long f[101010];\n\nlong long calc(int a, int b)\n{\n\treturn max(f[b - 1] + t, f[b - 1] + 2 * x[a] - 2 * x[b]);\n}\n\npriority_queue<long long> q;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &x[i]);\n\tf[1] = t;\n\tint now = 0;\n\tfor(int i = 2; i <= n; ++i)\n\t{\n\t\tf[i] = f[i - 1] + t;\n\t\tint l = 1;\n\t\tint r = i - 1, mid, key = i;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = l + r;\n\t\t\tmid>>=1;\n\t\t\tif(t + 2 * x[mid] - 2 * x[i] >= 0)\n\t\t\t{\n\t\t\t\tr = mid - 1;\n\t\t\t\tkey = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tf[i] = min(f[i], max(f[key - 1] + 2 * x[i] - 2 * x[key], f[key - 1] + t));\n\t\tif(key > 1)\n\t\t{\n\t\t\twhile(now < key - 1)\n\t\t\t{\n\t\t\t\t++now;\n\t\t\t\tq.push(2 * x[now] - f[now - 1]);\n\t\t\t}\n\t\t\tf[i] = min(f[i], 2 * x[i] - q.top());\n\t\t}\n\t}\n\t\n//\tprintf(\"%d\\n\", f[n] + e);\n\tcout<<f[n] + e<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[2002];\nLL rem[2002];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i;\n\tfor(i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x,x+n);\n\tLL ans=0;\n\tLL cur=0;\n\t//\n\tbool ok=false;\n\twhile(!ok){\n\t\tans+=cur?(x[cur]-x[cur-1]):x[cur];\n\t\tfor(i=cur;i<n && x[i]-x[cur]<t;i++);\n\t\tint j=i-1;\n\t\t//printf(\"%d\\n\",j);\n\t\tif(j==n-1) ok=true;\n\t\tans+=2*(x[j]-x[cur]);\n\t\tfor(i=cur;i<=j;i++) rem[i]=t-(2*(x[j]-x[cur]))+(x[i]-x[cur]);\n\t\tLL add=0;\n\t\tfor(i=cur;i<=j;i++){\n\t\t\trem[i]-=add;\n\t\t\tif(rem[i]>0) ans+=rem[i];\n\t\t\tif(i+1<=j) ans+=x[i+1]-x[i];\n\t\t\tadd+=x[i+1]-x[i];\n\t\t}\n\t\t//printf(\"%d %lld\\n\",cur,ans);\n\t\tcur=j+1;\n\t}\n\tif(x[n-1]<e) ans+=e-x[n-1];\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 1e5 + 5;\n\nint X[N];\nll DP[N];\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\n\tint n, e, t; cin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) cin >> X[i];\n\tll mn = INF;\n\tint p = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (t <= 2 * (X[i] - X[p])) mn = min(mn, DP[p - 1] - 2 * X[p]), p++;\n\t\tDP[i] = min(mn + 2 * X[i], DP[p - 1] + t);\n\t}\n\tcout << e + DP[n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T;\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\twhile(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tdp[i] = cost(i , opt);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\td[0]=0;\n\tfoor(i,1,N){\n\t\tfoor(j,1,i){\n\t\t\tchmin(d[i],d[j-1]+x[j]-x[j-1]+max(2*(x[i]-x[j]),T)+x[i]-x[j]);\n\t\t}\n\t}\n\tprint(d[N]+E-x[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nint n, T, E;\nll x[N], dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &E, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  for (int i = 1, j = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n    for (; 2 * (x[i] - x[j]) >= T; j++)\n      dp[i] = min(dp[i], dp[j - 1] + x[j] - x[j - 1] + (x[i] - x[j]) * 3);\n    if (j < i) {\n      dp[i] = min(dp[i], dp[j - 1] + x[i] - x[j - 1] + T);\n    }\n  }\n  printf(\"%lld\\n\", dp[n] + E - x[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = 0;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\tfor( size_t i = idxmin; i < max( N + 1, idxmin + 10 ); i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long i64;\n\nint n;\ni64 t;\ni64 e;\nvector<i64> x;\n\ni64 dp[100010];\n\ni64 rec(int end_x)\n{\n\tif(dp[end_x] != -1) return dp[end_x];\n\t//cout << \"end\" << end_x << endl;\n\tif(end_x == n)\n\t{\n\t\t//cout << \"n\" << endl;\n\t\treturn (dp[end_x] = e - x[n]);\n\t}\n\t\n\n\ti64 v = (1LL << 60);\n\tfor(int i = end_x + 1;i <= n;i++)\n\t{\n\t\ti64 d = (x[i] - x[end_x + 1]) * 2;\n\t\td = max(d , t);\n\t\tv = min(v , rec(i) + d + (x[i] - x[end_x + 1]));\n\t}\n\t\t\n\treturn (dp[end_x] = v + x[end_x + 1] - x[end_x]);\n}\n\n\n\n\n\n\n\nint main()\n{\n\tfill(dp,dp + 100010,-1LL);\n\tcin >> n >> e >> t;\n\tx.assign(n +1,0);\n\tx[0] = 0;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\n\tcout << rec(0) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pr pair<int,int>\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#ifdef DEBUG\n    #define GG(x) assert(x)\n#else\n    #define GG(x) (x)\n#endif\nnamespace mine\n{\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e>=0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e5+10;\n\n    ll f[N],a[N];\n    void main()\n\t{\n        ll n=qread(),E=qread(),T=qread();fo(i,1,n) a[i]=qread();a[n+1]=E;\n        memset(f,0x3f,sizeof f);f[0]=0;\n        fo(i,1,n)\n        {\n            int jj=lower_bound(a,a+i+1,a[i]-T/2)-a;\n            fo(j,max(0,jj-10),min(i-1,jj+10))\n            // fo(j,0,i-1)\n                chmin(f[i],f[j]+max(T,2*(a[i]-a[j+1])));\n        }\n        write(f[n]+E);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <list>\n#include <string>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <deque>\n#include <stack>\n#include <cassert>\nusing namespace std;\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define ALL(x) (x).begin(),(x).end()\n#define CASET2 int ___T, case_n = 1; scanf(\"%d \", &___T); while ((___T > 0 ? printf(\"Case #%d:\\n\", case_n++) : 0), ___T-- > 0)\n#define CASET1 int ___T, case_n = 1; scanf(\"%d \", &___T); while ((___T > 0 ? printf(\"Case #%d: \", case_n++) : 0), ___T-- > 0)\n#define CASET int ___T; scanf(\"%d \", &___T); while (___T-- > 0)\n#define SZ(X) ((int)(X).size())\n#define LEN(X) strlen(X)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=(b);i--)\n#define REPL(i,x) for(int i=0;x[i];i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define RI1(x) scanf(\"%d\",&x)\n#define RI2(x,y) RI1(x), RI1(y)\n#define RI3(x,y...) RI1(x), RI2(y)\n#define RI4(x,y...) RI1(x), RI3(y)\n#define RI5(x,y...) RI1(x), RI4(y)\n#define RI6(x,y...) RI1(x), RI5(y)\n#define GET_MACRO(_1, _2, _3, _4, _5, _6, NAME, ...) NAME\n#define RI(argv...) GET_MACRO(argv, RI6, RI5, RI4, RI3, RI2, RI1)(argv)\n#define DRI(argv...) int argv;RI(argv)\n#define WRI(argv...) while (RI(argv) != EOF)\n#define DWRI(x...) int x; WRI(x)\n#define RS(x) scanf(\"%s\",x)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define X first\n#define Y second\n#define V(x) vector<x >\n\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef long long LL;\nconst int INF = 1000000000;\n\nvoid print(int i) { printf(\"%d\", i); }\ntemplate<class T> void PI(T i) { print(i); puts(\"\"); }\ntemplate<class T> void PIS(T i) { print(i); printf(\" \"); }\n\ntemplate<class T>\nvoid PV(T const &v, int N) {\n    REP(i, N) {\n        print(v[i]);\n        printf(\"%c\", i == N-1 ? '\\n' : ' ');\n    }\n}\n\ntemplate<class T> void PV(T const &v) { PV(v, SZ(v)); }\n\ntemplate<class T, class S> bool has_bit(T mask, S i) { return (mask >> i) & 1; }\nlong long shift(int i) { return 1ll << i; }\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\nint popcount(int x) { return __builtin_popcount(x); } \nint popcount(long long x) { return __builtin_popcountll(x); } \n\n#include <unordered_set>\n#include <unordered_map>\n#define EB emplace_back\n#define RL(x) scanf(\"%lld\", &(x))\n#define PL(x) printf(\"%lld\\n\", x)\n#define DRL(x) LL x; RL(x)\n\nint main() {\n  DRI(N, E, T);\n  VI x(N);\n  V(LL) dp(N+1, 1e18);\n  dp[0] = 0;\n  REP(i, N) {\n    RI(x[i]);\n    REP(j, i+1) {\n      mini(dp[i+1], dp[j] + max(T, 2 * (x[i] - x[j])));\n    }\n  }\n  PL(dp[N] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nlong long n, e, t;\n\nlong long f(const vector<long long> &a, int m) {\n    long long res = m * t;\n    long long res1 = res + a[n - 1] + (m == n ? 0 : t) + abs(a[n - 1] - a[m]) + abs(a[m] - e);\n    long long res2 = res + a[n - 1] + abs(a[n - 1] - a[m]);\n    res2 = (a[m] + t < res2 ? res2 : a[m] + t);\n    res2 += abs(a[n - 1] - a[m]) + abs(a[n - 1] - e);\n    return min(res1, res2);\n}\n\nint main()\n{\n    cin >> n >> e >> t;\n    vector<long long> a(n + 1);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    a[n] = e;\n    long long res = a[0];\n    int l = 0;\n\n    for (int i = 1; i < n; i++) {\n        long long loc1 = 2 * (a[i - 1] - a[l]);\n        loc1 = (loc1 < t ? t : loc1) + (a[i] - a[l]) + t;\n        long long loc2 = 2 * (a[i] - a[l]);\n        loc2 = (loc2 < t ? t : loc2) + (a[i] - a[l]);\n        if (loc1 < loc2) {\n            res += loc1 - t;\n            l = i;\n        }\n    }\n\n    long long loc1 = 2 * (a[n - 1] - a[l]);\n    loc1 = (loc1 < t ? t : loc1) + abs(e - a[l]);\n    res += loc1;\n    cout << res;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=1e5+10;\nconst long long INF=1e17;\nint n,t,e;\nlong long x[nMax],f[nMax],g[nMax];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&x[i]);\n\tlong long Min=INF;\n\tg[0]=-x[1]*2;\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(p<=i&&(x[i]-x[p+1])*2>=t)\n\t\t\tMin=min(Min,g[p++]);\n\t\tif(p<i)\n\t\t\tf[i]=f[p]+t;\n\t\telse\n\t\t\tf[i]=INF;\n\t\tf[i]=min(f[i],Min+x[i]*2);\n\t\tg[i]=f[i]-2*x[i+1];\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N];\n    rep2(i,1,n)x[i]=lin();\n    if(n>2000)return 0;\n    ll dp[2001]={};\n    rep2(i,1,n){\n        ll temp=1e15;\n        rep(j,i){\n                ll s=x[i]*3-x[j]-x[j+1]*2+max(0ll,t-(x[i]-x[j+1])*2);\n                temp=min(temp,s+dp[j]);\n        }\n        dp[i]=temp;\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,t,e,a[100100],f[100100];\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&e,&t),memset(f,0x3f3f3f3f,sizeof(f)),f[0]=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)for(int j=0;j<i;j++)f[i]=min(f[i],f[j]+(a[i]-a[j])+2*(a[i]-a[j+1])+max(0ll,t-2*(a[i]-a[j+1])));\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll ans;\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tans=e;\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tint now=0;\n\twhile (1){\n\t\tif (now==n) break;\n\t\tint x=now+1;\n\t\twhile (x<n&&2*(pos[x]-pos[now+1])<wait){\n\t\t\t++x;\n\t\t}\n\t\tif (2*(pos[x]-pos[now+1])>=wait){\n\t\t\tans+=min((ll)wait*(x-now),2ll*(pos[x]-pos[now+1]));\n\t\t\t//tmp1+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t}\n\t\telse ans+=(ll)wait*(x-now);\n\t\tnow=x;\n\t\t//cerr<<\"now\"<<now<<endl;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint E, T; cin >> E >> T;\n  V<lint> x(n); for (auto&& e : x) cin >> e;\n  V<lint> dp(n + 1, 9e18);\n  dp[n] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    int j = upper_bound(begin(x), end(x), x[i] + T) - begin(x);\n    lint d = x[j - 1] - x[i];\n    lint cost = 2 * d + max<lint>(T - 2 * d, 0) + (j < n ? x[j] : E) - x[i];\n    dp[i] = min(dp[i], cost + dp[j]);\n  }\n  cout << x[0] + dp[0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst long long maxn = 100010; const ll inf = 1LL<<60;\nlong long N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline long long gi()\n{\n\tchar ch; long long ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(long long now,long long l,long long r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tlong long mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,long long now,long long l,long long r,long long pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tlong long mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,long long now,long long l,long long r,long long ql,long long qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tlong long mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (long long i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (long long i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tlong long l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (long long j = r+1;j <= r+15&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)(i-j)*(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nstring to_str(ll x){string res; while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return res;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//template end\n\n\n\nint main(){\n   int n,e; ll t; scanf(\"%d%d%lld\",&n,&e,&t);\n   vector<int> a(n); rep(i,0,n)scanf(\"%d\",&a[i]);\n   if(n>2000){printf(\"どうせCHT\"); return 0;}\n   ll dp[2010]; rep(i,0,2010)dp[i]=INF;\n   dp[0]=0;\n   rep(i,0,n)rep(j,0,i+1)chmin(dp[i+1],dp[j]+max(t,(a[i]-a[j])*2LL));\n   printf(\"%lld\\n\",dp[n]+e);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n \n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n \n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    using namespace std;\n    const int MAX = (1e5)+1;\n     \n    int n;\n    long long E, T, x[MAX], dp[MAX], f[MAX];\n    multiset<long long> l, m;\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n    \tcin >> n >> E >> T;\n    \tl.insert(f[0] = T);\n    \tfor(int i = 1, j = 0; i <= n; i++) {\n    \t\tcin >> x[i];\n    \t\twhile(j < i && 2*(x[i]-x[j+1]) >= T) {\n    \t\t\tl.erase(l.find(f[j]));\n    \t\t\tf[j] = f[j]-T-2*(x[j+1]);\n    \t\t\tm.insert(f[j]);\n    \t\t\tj++;\n    \t\t}\n    \t\tdp[i] = LLONG_MAX;\n    \t\tif(!l.empty()) dp[i] = min(x[i]+*l.begin(), dp[i]);\n    \t\tif(!m.empty()) dp[i] = min(3*x[i]+*m.begin(), dp[i]);\n    \t\tl.insert(f[i] = dp[i]-x[i]+T);\n    \t}\n    \tcout << dp[n]+E-x[n];\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 20);\n\ntemplate<class T>\nstruct monotonous_queue_min\n{\n\tint len;\n\tdeque<pair<T, int> > Q;\n\n\tmonotonous_queue_min() { Q.clear(); len = 0; }\n\n\tvoid init(int _l)\n\t{\n\t\tlen = _l;\n\t\tQ.clear();\n\t}\n\n\tvoid push_back(T x, int X)\n\t{\n\t\twhile(!Q.empty() && X - Q.front().second > len) Q.pop_front();\n\t\twhile(!Q.empty() && x <= Q.back().first) Q.pop_back();\n\t\tQ.push_back({x, X});\n\t}\n\n\tT query()\n\t{\n\t\tif(Q.empty()) return (T)1e18;\n\t\treturn Q.front().first;\n\t}\n};\n\nint64_t n, t, e, L;\nint64_t x[MAXN];\n\nvoid read()\n{\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n}\n\nint64_t dp[MAXN];\n\n/*\n\n   dp[i] = MIN ( 2 * x[i] - 2 * x[j] + dp[j - 1] - x[j - 1] + x[i] + MAX(t - 2 * x[i] + 2 * x[j], 0) )\n   dp[i] = 3 * x[i] + MIN(dp[j - 1] - x[j] * 2 - x[j - 1])  \n   dp[i] = 3 * x[i] + MIN(dp[j - 1] - x[j] * 2 - x[j - 1] + t - 2 * x[i] + 2 * x[j])\n\n   dp[i] = dp[j - 1] + 2 * (x[i] - x[j]) + t - 2 * (x[i] - x[j]) + x[i] - x[i - 1]\n\n   t >= x[i] * 2 - x[j] * 2\n   floor(t / 2) >= x[i] - x[j]\n*/\n\nint64_t mn[MAXN];\n\nmonotonous_queue_min<int64_t> mq;\n\nvoid solve()\n{\n\tx[0] = 0;\n\tdp[0] = 0;\n\tmn[0] = (int64_t)1e18;\n\tL = t / 2;\n\n\tmq.init(L);\t\n\n\tint last = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\t/*for(int j = i; j >= 1; j--)\n\t\t{\n\t\t\tint64_t wait_t = max((int64_t)0, t - 2 * (x[i] - x[j]));\n\t\t\tchkmin(dp[i], -x[j - 1] + wait_t + (-x[j]) * (int64_t)2 + dp[j - 1]);\n\t\t}*/\n\n\t\tmn[i] = min(mn[i - 1], dp[i - 1] - x[i] * 2 - x[i - 1]);\n\t\tmq.push_back(dp[i - 1] - x[i - 1], x[i]);\n\t\tdp[i] = mq.query() + t - 2 * x[i];\n\t\twhile(i >= last && (x[i] - x[last]) > L) last++;\n\t\tchkmin(dp[i], mn[last - 1]);\n\t\tdp[i] += 3ll * x[i];\n\t}\n\n\tcout << dp[n] + e - x[n] << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nll e, t;\nll x[100010];\n\nll memo[100010];\n\nll calc(int k) {\n    if (memo[k] < 0) {\n        if (k == n) memo[k] = 0;\n        else {\n            // wait\n            ll res = t + x[k+1] - x[k] + calc(k+1);\n            int x0 = k+1, x3 = n-1, x1=k+1, x2=k+2;\n            ll v1, v2;\n            ll d;\n\n            while (x3 - x0 > 2) {\n                x1 = x0 + (x3-x0)/3;\n                x2 = x0 + 2*(x3-x0)/3;\n                d = x[x1] - x[x1];\n                v1 = 3*d + max(0LL, t-2*d) + calc(x1+1)+x[x1+1]-x[x1];\n                d = x[x2] - x[x2];\n                v2 = 3*d + max(0LL, t-2*d) + calc(x2+1)+x[x2+1]-x[x2];\n                if (v1 < v2) {\n                    x3 = x2;\n                } else {\n                    x0 = x1;\n                }\n            }\n\n\n            for (int i = x0; i <= x3; i++) {\n                ll d = x[i] - x[k];\n                res = min(res, 3*d + max(0LL, t-2*d) + calc(i+1)+x[i+1]-x[i]);\n            }\n\n            memo[k] = res;\n        }\n    }\n    return memo[k];\n}\n\nll solve() {\n    memset(memo, -1, sizeof(memo));\n    x[n] = e;\n    return calc(0) + x[0];\n}\n\nvoid input() {\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> x[i];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i-2;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tfor(int j=Max;j>0;j--){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t/*\tif(max(t,(x[i]-x[j+1])*2)+dp[j]>dp[i])\n\t\t\tbreak;*/\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <bitset>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAXN = 100009;\nconst long long INF = 1000000000000000000;\n\nstruct SegmentTree {\n    long long tr_min[4 * MAXN];\n    long long tr_add[4 * MAXN];\n    int n;\n\n    SegmentTree(int n) : n(n) {\n        memset(tr_min, 0, sizeof(tr_min));\n        memset(tr_add, 0, sizeof(tr_add));\n    }\n\n    void setVal(int id, long long val) {\n        setVal(0, 0, n, id, val);\n    }\n\n    void setVal(int v, int vl, int vr, int id, long long val) {\n        push(v, vl, vr);\n        if (vl > id || vr <= id) {\n            return;\n        }\n        if (vr - vl == 1) {\n            tr_min[v] = val;\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        setVal(2 * v + 1, vl, vm, id, val);\n        setVal(2 * v + 2, vm, vr, id, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    void addTree(int l, int r, long long val) {\n        if (l > r)\n            return;\n        addTree(0, 0, n, l, r + 1, val);\n    }\n\n    long long getMin(int l, int r) {\n        return getMax(0, 0, n, l, r + 1);\n    }\n\n    void push(int v, int vl, int vr) {\n        tr_min[v] += tr_add[v];\n        if (vr - vl > 1) {\n            tr_add[2 * v + 1] += tr_add[v];\n            tr_add[2 * v + 2] += tr_add[v];\n        }\n        tr_add[v] = 0;\n    }\n\n    void addTree(int v, int vl, int vr, int l, int r, long long val) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return;\n        }\n        if (vl >= l && vr <= r) {\n            tr_add[v] += val;\n            push(v, vl, vr);\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        addTree(2 * v + 1, vl, vm, l, r, val);\n        addTree(2 * v + 2, vm, vr, l, r, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    long long getMax(int v, int vl, int vr, int l, int r) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return INF;\n        }\n        if (vl >= l && vr <= r) {\n            return tr_min[v];\n        }\n        int vm = (vl + vr) / 2;\n        long long max1 = getMax(2 * v + 1, vl, vm, l, r);\n        long long max2 = getMax(2 * v + 2, vm, vr, l, r);\n        return min(max1, max2);\n    }\n};\n\nlong long x[MAXN];\nlong long f[MAXN];\n\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    x[0] = 0;\n    f[0] = 0;\n    SegmentTree tree(n);\n    tree.addTree(0, 0, x[1] - x[0] + t);\n    int idt = 0;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = tree.getMin(0, i - 1);\n        if (i == n)\n            break;\n        int pidt = idt;\n        while ((x[i + 1] - x[idt + 1]) * 2 > t) {\n            tree.setVal(idt, x[i + 1] - x[idt] + (x[i + 1] - x[idt + 1]) * 2);\n            ++idt;\n        }\n        tree.setVal(i, f[i] + x[i + 1] - x[i] + t);\n        tree.addTree(idt, i - 1, x[i + 1] - x[i]);\n        tree.addTree(0, pidt - 1, 3 * (x[i + 1] - x[i]));\n    }\n    long long ans = f[n] + e - x[n];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<62;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tll n,e,t;cin>>n>>e>>t;\n\tvector<ll> x(n+10);\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tvector<ll> dp(n+10,LINF);\n\tdp[0]=0;\n\tint id=0;\n\tll mix=LINF;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>1)mix+=x[i]-x[i-1];\n\t\twhile(id<i&&2LL*(x[i]-x[id+1])>t){\n\t\t\tchmin(mix,dp[id]+2LL*(x[i]-x[id+1]));\n\t\t\tid++;\n\t\t}\n\t\tchmin(dp[i],mix);\n\t\tchmin(dp[i],dp[id]+t);\n\t}\n\tcout<<e+dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define inf 10000000000000000\n#define int long long \n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, h, t, E, T, Min, x[N], q[N], dp[N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nsigned main(){\n    n = read(), E = read(), T = read();\n    rep(i, 1, n) x[i] = read();\n    q[h = t = 1] = 0, Min = inf;\n    rep(i, 1, n) dp[i] = inf;\n    rep(i, 1, n){\n        while(h <= t && 2 * x[i] >= T + 2 * x[q[h] + 1]) Min = min(Min, dp[q[h]] - x[q[h]] - 2 * x[q[h] + 1]), h++;\n        dp[i] = Min + 3 * x[i];\n        if(h <= t) dp[i] = min(dp[i], dp[q[h]] - x[q[h]] + T + x[i]);\n        while(h <= t && dp[i] - x[i] <= dp[q[t]] - x[q[t]]) t--;\n        q[++t] = i;\n    }\n    printf(\"%lld\", E - x[n] + dp[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <vector>\n#include <array>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <valarray>\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;Scan(__VA_ARGS__);\ntemplate<typename T> void Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void Scan(First& first, Rest&...rest) { std::cin >> first; Scan(rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\t\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& i : v){std::cerr << i << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr << j << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr<<'('<<j.first<<\", \"<<j.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& i:v){std::cerr<<'('<<i.first<<\", \"<<i.second<<\") \";}std::cout<<\"\\n\";}\n#define CHECKTIME(state) {auto start=std::chrono::system_clock::now();state();auto end=std::chrono::system_clock::now();auto res=std::chrono::duration_cast<std::chrono::nanoseconds>(end-start).count();std::cerr<<\"[Time:\"<<res<<\"ns  (\"<<res/(1.0e9)<<\"s)]\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\n#define CHMAX(a, b) a = (((a)<(b)) ? (b) : (a))\n#define CHMIN(a, b) a = (((a)>(b)) ? (b) : (a))\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^19\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238;\n\nint tt[100005];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\n\tauto calc = [&](int i, int j) {\n\t\treturn 3 * (x[j] - x[i]) + std::max(t - 2 * (x[j] - x[i]), 0LL);\n\t};\n\n\tstd::fill(tt, tt + n+1, INFLL);\n\ttt[0] = x[0];\n\n\tauto xx = [&](ll i) {\n\t\treturn (i == n) ? e : x[i];\n\t};\n\n\tREP(i, n+1) {\n\t\tif (i != 0) {\n\t\t\tCHMIN(tt[i], tt[i - 1] + t + xx(i) - x[i - 1]);\n\t\t}\n\t\tREP(j, i) {\n\t\t\tCHMIN(tt[i], tt[j] + calc(j, i-1) + xx(i) - x[i - 1]);\n\t\t}\n\t}\n\n\t/*REP(i, n) {\n\t\tREP(j, n) {\n\t\t\tOUT(dp[i][j])SP;\n\t\t}BR;\n\t}\n\tREP(i, n+1) {\n\t\tOUT(tt[i])SP;\n\t}BR*/;\n\n\tOUT(tt[n])BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r, x)     for (int i = l; i < r; i+=x)\n//#define ForE(i, l, r, x)    for (int i = l; i <= r; i+=x)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O \n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n//#define PrintV(a)           Fora(ii, a) cout << ii << ' '; cout << rl;\n//#define PrintVl(a)          Fora(ii, a) cout << ii << rl;\n//#define PrintA(a, l, r)     for (int ii = l; ii <= r; ii++) cout << a[ii] << ' '; cout << rl;\n//#define PrintAl(a, l, r)    for (int ii = l; ii <= r; ii++) cout << a[ii] << rl;\n//#define Ptest(x)            return cout << x, 0;\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calc    \n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 100005, MAX_M = 200010;\n// code\n#define int long long\nint n, x[MAXN], dp[MAXN], e, t;\n\nvoid Solve() {\n\tcin >> n >> e >> t; \n\tfor (int i = 1; i <= n; i++){\n        cin >> x[i];\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n        dp[i] = 1e18;\n        for (int j = 0; j < i; j++) \n            dp[i] = min(dp[i], dp[j] + max(2 * (x[i] - x[j+1]), t));\n\t}\n\t\n\tcout << dp[n] + e;\n}\n\nsigned main(){\n    FAST_IO;\n    int TC = 1; \n\t//cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\n\nvoid check(int i,int j)\n{\n  long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-2*(a[i]-a[j+1]),h-a[j+1])+a[i]-a[j+1]);\n}\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  if (n<=1000) \n  {\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=0;j--)\n      {   \n        check(i,j);\n        \n      }\n    }  \n  }\n  else\n  {\n     for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=max(0,i-100);j--)\n      {   \n        \n        check(i,j);\n        \n      }\n    check(i,0);\n    check(i,i / 2);\n    \n    }  \n  }\n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n \ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n \n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n \nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n \nconst int MaxN = 1e5 + 10;\n \nint N, E, T, x[MaxN];\n \nlong long f[MaxN];\n \nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && 2 * (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n\nstruct zkw\n{\n\tlong long s[MaxN << 2];\n\n\tint cnt;\n\n\tvoid build()\n\t{\n\t\tcnt = 1;\n\t\tfor (; cnt < N + 3; cnt <<= 1); --cnt;\n\t\tfor (int i = 1; i <= N + 1; ++i) s[cnt + i] = 1e18;\n\t\tfor (int i = cnt; i; --i) s[i] = 1e18;\n\t}\n\n\tvoid modify(int pos, long long x)\n\t{\n\t\t++pos;\n\t\tpos += cnt;\n\t\ts[pos] = min(s[pos], x);\n\t\tfor (pos >>= 1; pos; pos >>= 1) s[pos] = min(s[pos << 1], s[pos << 1 | 1]);\n\t}\n\n\tlong long query(int l, int r)\n\t{\n\t\tlong long ans = 1e18;\n\t\t++l, ++r;\n\t\tfor (l += cnt - 1, r += cnt + 1; l ^ r ^ 1; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (~l & 1) ans = min(ans, s[l ^ 1]);\n\t\t\tif (r & 1) ans = min(ans, s[r ^ 1]);\n\t\t}\n\t\treturn ans;\n\t}\n} s1, s2;\n\n\n \nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\ts1.build(), s2.build();\n\ts1.modify(0, 0);\n\ts2.modify(0, 0);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint k = find(i);\n\t\tf[i] = min(f[i], s1.query(0, k - 1) + 3LL * x[i]);\n\t\t/*for (int j = 0; j < k; ++j)\n\t\t\tf[i] = min(f[i], 3LL * x[i] + f[j] - x[j] - 2 * x[j + 1]));*/\n\t\tf[i] = min(f[i], s2.query(k, i - 1) + x[i] + T);\n\t\ts1.modify(i, f[i] - x[i] - 2 * x[i + 1]);\n\t\ts2.modify(i, f[i] - x[i]);\n\t\t/*for (int j = k; j < i; ++j)\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + T);*/\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define dump(a) cerr<<#a <<' '<< a <<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    VLL dp(n+1,LINF),x(n+1);\n    REP(i,n) cin >> x[i+1];\n    dp[0]=0;\n    dp[1]=t;\n    int l=0;\n    LL r=0;\n    FOR(i,2,n+1){\n        dp[i]=dp[l]+(x[i]-x[l+1])*2;\n        /*for(int j= l; j<i ; ++j){\n            if(dp[i]>dp[j]+max((LL)t,(x[i]-x[j+1])*2)){\n                dp[i]=min(dp[i],dp[j]+max((LL)t,(x[i]-x[j+1])*2));\n                l=j;\n            }\n            if(t>(x[i]-x[j+1])*2){\n                break;\n            }\n        }*/\n        for(int j=r ; j<i ; ++j){\n            if(t>(x[i]-x[j+1])*2){\n                dp[i]=min(dp[i],dp[j]+t);\n                r=j;\n                break;\n            }\n        }\n        if(dp[l]+(x[i]-x[l+1])*2>dp[i-1]) l=i-1;\n    }\n    cout << dp[n]+e<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    ll N, E, T;\n    cin >> N >> E >> T;\n    ll X[100010], Y[100010];\n    X[0] = 0;\n    for (int i = 1;i <= N;i++) cin >> X[i];\n    Y[0] = 0;\n    int idx = 0;\n    ll sum = 0;\n    ll total, tmp;\n    multiset<ll> S;\n    S.insert(T);\n    ll now = 1E18;\n    multiset<ll>::iterator it;\n    for (int i = 1;i <= N;i++) {\n    \tnow += 3 * (X[i] - X[i - 1]);\n    \tsum += X[i] - X[i - 1];\n    \twhile (X[i] - X[idx] > T / 2) {\n    \t\t// Eject X[idx].\n    \t\tif (idx != 0) total = T + X[i] - X[idx - 1] + Y[idx - 1];\n    \t\telse total = T + X[i];\n    \t\ttotal -= sum;\n    \t\tit = S.find(total);\n    \t\tS.erase(it);\n    \t\tif (idx > 0) tmp = (X[i] - X[idx]) * 3 + Y[idx - 1] + X[idx] - X[idx - 1];\n    \t\telse tmp = (X[i] - X[idx]) * 3 + X[1] - X[0];\n    \t\tnow = min(now, tmp);\n    \t\tidx++;\n    \t}\n        S.insert(T + Y[i - 1] + X[i] - X[i - 1] - sum);\n        it = S.begin();\n        Y[i] = min(now, *it + sum);\n    }\n    cout << Y[N] + E - X[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 100100;\nll x[maxn];\nll d[maxn];\nll f[maxn];\nll t;\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"d.in\", \"r\", stdin));\n    #else\n    #endif\n    ll n, e;\n    cin >> n >> e >> t;\n    forn (i, n) {\n        cin >> x[i];\n        x[i] *= 2;\n    }\n    forn (i, n + 1)\n        d[i] = infl;\n    d[0] = 0;\n    f[0] = -x[0];\n    for (int i = 1; i <= n; ++i) {\n        //forn (j, i) {\n            //d[i] = min(d[i], d[j] + max(t, x[i - 1] - x[j]));\n        //}\n        int p = lower_bound(x, x + i, x[i - 1] - t) - x;\n        d[i] = min(d[i], d[p] + t);\n        if (p > 0)\n            d[i] = min(d[i], f[p - 1] + x[i - 1]);\n        f[i] = min(f[i - 1], d[i] - x[i]);\n    }\n    cout << d[n] + e << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint l[N],x[N];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]),assert(x[i-1]<x[i]&&x[i]<e);\n\tl[n+1]=n;\n\tfor(int i=n;i>=1;i--){\n\t\tl[i]=min(i,l[i+1]);\n\t\twhile(l[i]>0&&2*(x[i]-x[l[i]])<=t) l[i]--;\n\t}\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(l[i]) dp[i]=min(dp[l[i]]+t,dp[l[i]-1]+2*(x[i]-x[l[i]]));\n\t\telse dp[i]=t;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i+1;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        /*\n        for (int j=1; j<i; j++)\n            if ((x[i]-x[j])*2 > T)\n                A[i] = min(A[i], A[j-1]-x[j-1]-2*x[j] + 3*x[i]);\n            else\n                A[i] = min(A[i], A[j-1]-x[j-1] + T+x[i]);\n                */\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n\nusing namespace std;\n\ninline void cmin(ll &x,ll y){y<x?x=y:0;}\n\nconst int N=1e5+10;\nconst ll inf=1e18;\nint n,e,t,a[N]; ll f[N],mi;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\tmemset(f,0x3f,sizeof(f)),f[0]=0;\n\tint p=0; mi=inf;\n\trep (i,1,n){\n\t\twhile (p<=i&&2ll*(a[i]-a[p+1])>t)\n\t\t\tmi=min(mi,f[p]-2*a[p+1]),p++;\n\t\tcmin(f[i],mi+2ll*a[i]);\n\t\tif (p<i) cmin(f[i],f[p]+t);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <iterator>\n#include <map>\n#include <array>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\nnamespace XX\n{   \n    template<template<typename> class Compare, typename T>\n    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}\n    template<typename Compare, typename T>\n    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}\n\n    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}\n    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}\n\n    template<typename T>\n    struct Mapper\n    {\n        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n        T rev(int idx){return rtable[idx + 1];}\n        std::map<T, int> table;\n        std::map<int, T> rtable;\n    };\n\n    template<typename T, int S>\n    struct ReferenceArray\n    {\n        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n        int size()const{return _ptr.size();}\n        It begin()const{return {_ptr.begin()};}\n        It end()const{return {_ptr.end()};}\n        T& operator[](int idx)const{return *_ptr[idx];}\n        mutable std::array<T*, S> _ptr;\n    };\n    template<typename T, typename... Args> \n    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\n    struct Range\n    {   \n        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n        Range(int ee):b(0),e(ee){}\n        Range(int bb, int ee):b(bb), e(ee){}\n        It begin(){return {b, (b < e? 1: -1)};}\n        It end(){return {e, 0};}\n        int b, e;\n    };\n\n}\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\ntemplate<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}\ntemplate<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}\nusing XX::UP; //(x,y) comp\nusing RG = XX::Range;\nusing XX::MAKEV;\nusing XX::Mapper;\n//template\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\n#include <queue>\nusing namespace std;\n\ntypedef long long int ll;\n\n\nint xs[200009];\n\nint main()\n{\n    int N, E, T;\n    RD(N, E, T);\n\n    RDV(xs + 1, xs + N + 1); \n    ll alc = 0;\n\n    pair<ll, ll> best = {0, -1000000000000000};\n    deque<pair<ll, ll>> que;\n    \n\n    ll last = 0;\n    for(int i: RG(1, N + 1))\n    {\n        int x = xs[i];\n\n        while(que.size() && 2 * (x - que.front().second) >= T)\n        {\n            if(best.first > que.front().first - 2 * (que.front().second - best.second))\n                best = que.front();\n            que.pop_front();\n        }\n\n        ll now = T + last;\n        UMIN(now, best.first + 2 * (x - best.second));\n        if(que.size())\n            UMIN(now, que.front().first + T);\n\n        while(que.size() && que.back().first > now)\n            que.pop_back();\n\n        que.emplace_back(last, x);\n        last = now;\n    }\n\n    WTL(last + E);\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tfz(i,1,n){\n\t\tint mn=0x3f3f3f3f3f3f3f3fll;\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n//\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\tmn=min(mn,dp[j]+2*(a[i]-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n//\t\tcout<<\"mn=\"<<mn<<endl;\n\t\tdp[i]=min(dp[i],dp[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn);\n//\t\tcout<<dp[i]<<endl;\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+E<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<r)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, r));\n        if (r<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(r, i));\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=100005;\ntypedef long long ll;\nconst ll INF=1e15;\nll d[N];\nint n,m,T;\nll a[N];\nint q[N];\nint s,t;\nint main()\n{\n    //freopen(\"computer.in\",\"r\",stdin);\n    //freopen(\"computer.out\",\"w\",stdout);\n    scanf(\"%d%d%d\",&n,&m,&T);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        d[i]=INF;\n    }\n    if(n<=1000){\n        for(int i=1;i<=n;i++)\n            for(int j=0;j<i;j++){\n                ll f=max(a[i]-a[j+1],T-(a[i]-a[j+1]));\n                d[i]=min(d[i],d[j]+a[i]-a[j]+f+max(a[i]-a[j+1],T-f));\n            }\n        ll ans=d[n]+m-a[n];\n        printf(\"%lld\\n\",ans);\n    }\n    else{\n        s=1,t=1;\n        ll z=INF;\n        for(int i=1;i<=n;i++){\n            while(s<=t&&2*(a[i]-a[q[s]+1])>T){\n                z=min(z,d[q[s]]-a[q[s]]-2*a[q[s]+1]);\n                s++;\n            }\n            d[i]=min(d[i],a[i]+z+2*a[i]);\n            //d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+2*(a[i]-a[q[s]+1]));\n            d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+T);\n            while(s<=t&&d[q[s]]-a[q[s]]>=d[i]-a[i])\n                t--;\n            q[++t]=i;\n        }\n        ll ans=d[n]+m-a[n];\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n; ll e, t;\n  cin>>n>>e>>t;\n  if(n>2000) return 0;\n  ll dp[100002], x[100002];\n  dp[0]=0; x[0]=0;\n  for(int i=1; i<=n; i++){\n    cin>>x[i];\n  }\n  for(int i=1; i<=n; i++){\n    dp[i]=1e18;\n    for(int j=0; j<i; j++){\n      dp[i]=min(dp[i], dp[j]+2*(x[i]-x[j+1])+x[i]-x[j]+max(t-2*(x[i]-x[j+1]), 0ll));\n    }\n  }\n  cout<<dp[n]+e-x[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define Lsn (x<<1)\n#define Rsn (x<<1|1)\n#define Mid (L+R>>1)\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst ll oo=1ll<<50;\n\nll f[N];\nint d[N],E,T,n,l,r,res;\n\nll Qv;\nint Ql,Qr,Qx;\n\nstruct SegTree{\n\tll mn[N*4];\n\tSegTree(){\n\t\tFor(i,0,N*4) mn[i]=oo;\n\t}\n\tvoid Modify(int x,int L,int R){\n\t\tmn[x]=min(mn[x],Qv);\n\t\tif (L==R) return;\n\t\tif (Qx<=Mid) Modify(Lsn,L,Mid);else Modify(Rsn,Mid+1,R);\n\t}\n\tll Query(int x,int L,int R){\n\t\tif (Ql<=L&&R<=Qr) return mn[x];\n\t\tll res=oo;\n\t\tif (Ql<=Mid) res=min(res,Query(Lsn,L,Mid));\n\t\tif (Qr>Mid) res=min(res,Query(Rsn,Mid+1,R));\n\t\treturn res;\n\t}\n} S1,S2;\n\nint main(){\n\tn=IN(),E=IN(),T=IN();\n\tFor(i,1,n+1) d[i]=IN();\n\tFor(i,0,N) f[i]=oo;\n\tf[0]=0;\n\tFor(i,1,n+1){\n\t\tQx=i,Qv=f[i-1]+d[i]-d[i-1]-3*d[i];\n\t\tS1.Modify(1,1,n);\n\t\tQx=i,Qv=f[i-1]+d[i]-d[i-1]-d[i];\n\t\tS2.Modify(1,1,n);\n\t\t\n\t\tl=1,r=i;res=0;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r>>1);\n\t\t\tif (2*(d[i]-d[mid])>T) res=mid,l=mid+1;else r=mid-1;\n\t\t}\n\t\tQl=1,Qr=res;\n\t\tif (Ql<=Qr) f[i]=min(f[i],S1.Query(1,1,n)+3ll*d[i]);\n\t\tQl=res+1,Qr=i;\n\t\tif (Ql<=Qr) f[i]=min(f[i],S2.Query(1,1,n)+T+d[i]);\n\t\t/*\n\t\tFor(j,1,i+1){\n\t\t\tf[i]=min(f[i],f[j-1]+d[j]-d[j-1]+max(2*(d[i]-d[j]),T)+d[i]-d[j]);\n\t\t}\n\t\t*/\n\t}\n\tcout<<f[n]+E-d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\nstruct SegmentTree {\nprivate:\n    int n; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+1),seg2(n+1);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-(x[i]-x[mid+1])*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 202000;const ll inf = 1e16;\nint n,a[N],T;ll f[N],q[N];int p[N];\nbool isright(int i, int j){return T-2LL*(a[j-1]-a[i])<0;}\nint main() {\n\tread(n);read(a[n+1]);read(T);\n\trep(i,1,n)read(a[i]);\n\tll x=inf;int F=1,R=1;\n\tfor(int i=n,j=n+2;i>=1;i--){\n\t\tf[i]=inf;\n\t\twhile(j-1>i+1&&isright(i,j-1)){\n\t\t\tj--;if(F!=R&&p[F]==j)F++;\n\t\t\tumin(x,f[j]+2*a[j-1]+a[j]);\n\t\t}\n\t\tif(isright(i,i+1))j=i+1,umin(x,f[j]+2*a[j-1]+a[j]);\n\t\telse{\n\t\t\tll val=f[i+1]+a[i+1];\n\t\t\twhile(F!=R&&q[R-1]>=val)R--;p[R]=i+1;q[R++]=val;\n\t\t}\n\t\tif(F!=R)umin(f[i],q[F]+T-a[i]);umin(f[i],x-3LL*a[i]);\n\t\t//rep(j,i+1,n+1)umin(f[i],f[j]+2*(a[j-1]-a[i])+a[j]-a[i]+max(0,T-2*(a[j-1]-a[i])));\n\t}\n\tcout<<f[1]+a[1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+3&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)(i-j)*(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\nint N;\nll E, T;\nint X[101010];\nint Y[101010];\nll YY[101010];\nll dp[101010][2];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\tY[0] = X[0];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\trep(i, 1, N + 1) {\n\t\trep(j, 0, i) {\n\t\t\tdp[i][0] = min(dp[i][0], dp[j][0] + (YY[i] - YY[j]) + T * (i - j));\n\t\t\tdp[i][0] = min(dp[i][0], dp[j][1] + (YY[i] - YY[j]) + T * (i - j - 1));\n\t\t\tdp[i][1] = min(dp[i][1], dp[j][0] + (YY[i] - YY[j]) + T * (i - j + 1));\n\t\t\tdp[i][1] = min(dp[i][1], dp[j][1] + (YY[i] - YY[j]) + T * (i - j));\n\n\t\t\t// Uターンする\n\t\t\tdp[i][1] = min(dp[i][1], dp[j][0] + (YY[i] - YY[j]) * 3);\n\t\t}\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n\n  vector< T > seg;\n  int sz;\n\n  SegmentTree(int n) : INF(numeric_limits< T >::max() / 10)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  int64 N, T, E, X[100002];\n\n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n\n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]-X[j+1]*2+X[i]*2\n  // dp2[j]=dp[j]-X[j+1]*2\n  */\n\n\n  SegmentTree< int64 > dp1(N + 1), dp2(N + 1);\n\n  dp1.update(0, 0);\n  dp1.update(1, E);\n  dp2.update(0, dp1.rmq(0, 1) - X[1] * 2);\n  dp2.update(1, dp1.rmq(1, 2) - X[2] * 2);\n  int tail = 0;\n\n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while((X[i] - X[tail + 1]) * 2 > E) ++tail;\n    dp1.update(i, min(dp1.rmq(tail, i) + E, X[i] * 2 + dp2.rmq(0, tail)));\n    dp2.update(i, dp1.rmq(i, i + 1) - X[i + 1] * 2);\n  }\n  cout << dp1.rmq(N, N + 1) + T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\ntemplate<class V, int NV> class SegTree {\npublic:\n\tstatic V const def = -(1LL << 60);\n\tV comp(V l, V r) { return max(l, r); };\n\n\tvector<V> val;\n\tSegTree() { val = vector<V>(NV * 2, def); }\n\n\tV getval(int l, int r) { //[l,r]\n\t\tl += NV; r += NV + 1;\n\t\tV ret = def;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) ret = comp(ret, val[l++]);\n\t\t\tif (r & 1) ret = comp(ret, val[--r]);\n\t\t\tl /= 2; r /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV;\n\t\tval[i] = v;\n\t\twhile (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n};\n//-----------------------------------------------------------------\nint N;\nll E, T;\nint X[101010];\nll Y[101010];\nll YY[101010];\nll dp[101010][2];\nSegTree<ll, 1 << 20> st;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\tY[0] = X[0];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\tst.update(0, dp[0][0] - YY[0] * 3);\n\trep(i, 1, N + 1) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\tdp[i][1] = min(dp[i][1], YY[i] * 3 + st.getval(0, i - 1));\n\t\tst.update(i, dp[i][0] - YY[i] * 3);\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nint p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tint now=0;\n\tll Min;\n\tFor(i,1,n)\n\t{\n\t\tdp[i]=dp[i-1]+T;\t\n\t\tMin=inf;\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tcmin(dp[i],Min+2*p[i]);\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto&\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\n\nlint dp[2020];\n\nlint brute() {}\n\nint main() {\n    cin >> n >> e >> t;\n\n    vector<lint> x(n + 1);\n    rep(i, n) cin >> x[i + 1];\n\n    if (n > 2020) return 0;\n\n    rep(i, n + 1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    //(val, range)\n    typedef pair<lint, lint> pll;\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n\n    for (int i = 0; i <= n; i++) {\n        while (!pq.empty()) {\n            auto p = pq.top();\n            pq.pop();\n            if (p.second <= i) continue;\n            chmin(dp[i], p.first + x[i]);\n            break;\n        }\n\n        for (int j = i + 1; j <= n; j++) {\n            int pos = (upper_bound(all(x), x[i + 1] + t / 2) - begin(x));\n            pq.push({dp[i] - x[i] + t, pos});\n\n            lint d = x[j] - x[i + 1];\n\n            if (2 * d >= t) {\n                chmin(dp[j], dp[i] + (x[i + 1] - x[i]) + 3 * d);\n            }\n        }\n    }\n    cout << dp[n] + (e - x[n]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\n\ninline void chk_min(ll &a,ll b){ if(a>b) a=b;}\n\nstruct Queue\n{\n\tint q[MAXN],hd,tl;\n\tQueue(void){ hd=tl=0;}\n\tinline bool empty(void){ return hd>=tl;}\n\tinline int front(void){ return q[hd+1];}\n\tinline int back(void){ return q[tl];}\n\tinline void push(int x){ q[++tl]=x;}\n\tinline void pop(void){ ++hd;}\n}q;\n\nint a[MAXN];\nll dp[MAXN];\n\nint main(void)\n{\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\n\tmemset(dp,0x3f,sizeof(dp));\n\t\n\tdp[0]=0;\n\tq.push(0);\n\tll mn=linf;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twhile(!q.empty() && (a[i]-a[q.front()+1])*2 > t)\n\t\t\tchk_min(mn, dp[q.front()] - 2*a[q.front()+1]),\n\t\t\tq.pop();\n\t\t\n\t\tif(!q.empty()) chk_min(dp[i], dp[q.front()]+t);\n\t\t\n\t\tchk_min(dp[i], mn+2*a[i]);\n\t\tq.push(i);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(int u, int l, int r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(int u, int l, int r, int x, int val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nint query(int u, int l, int r, int b, int e)\n{\n\tif (r == l)\n\t\treturn inf;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tint mid = (l + r) / 2, tmp = inf;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tsort(x, x + n);\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind ? dp[ind - 1] : 0));\n\t\tif (i)\n\t\t\tupdate(0, 0, n, i, dp[i - 1]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long n;\nlong long t,e;\nlong long a[100100];\nint use[100100];\n\nmain()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\t\n\t}\n\tlong long ans=0;\n\tlong long rt=0;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint d=0;\n\t\trt=0;\n\t\tif(use[i]==0)\n\t\t\tfor(int j=0;i-j-1>=0;j++)\n\t\t\t{\n\t\t\t\td=0;\n\t\t\t\t//printf(\"%lld %lld\\n\",a[i-j],a[i-j-1]);\n\t\t\t\tif(a[i-j]-a[i-j-1]<=t)\n\t\t\t\t{\n\t\t\t\t\td=1;\n\t\t\t\t\t//printf(\"op1\\n\");\n\t\t\t\t\tuse[i-j-1]=1;\n\t\t\t\t\trt=a[i-j]-a[i-j-1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op2 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op2.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d==1&&i-j-1==0)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op3 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op3.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t}\n\t\t\t}\n\t\tuse[i]=1;\n\t}\n\tif(use[0]==0)\n\t{\n\t\tans+=t;\n\t}\n\tans+=e;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[100010];\nlong long dp[100010];\n\nint main () {\n\tint n, E, T; scanf(\"%d%d%d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tint pos = 0;\n\tlong long minj = 0x3f3f3f3f3f3f3f3f;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (2 * (a[i] - a[pos + 1]) >= T) minj = min(minj, dp[pos] - 2 * a[pos + 1]), pos++;\n\t\tdp[i] = minj + 2 * a[i];\n\t\tif (pos != i) dp[i] = min(dp[i], dp[pos] + T);\n\t}\n\tprintf(\"%lld\\n\", dp[n] + E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N],p[N];int n,e,t;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%lld\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mn=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmn=min(mn,f[j]-2*p[j+1]);\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],mn+2*p[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 0;\n\t\tfor (auto itr = dp[i - 1].rbegin(); itr != dp[i - 1].rend(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\t\n\t\t\tif (D[i] * 2 < T) {\n\t\t\t\tdp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t\telse if (D[i] * 2 >= T * 2) {\n\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t\tif (saizu < T) dp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].rbegin(); itr != dp[N - 1].rend(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[2002];\nLL rem[2002];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i;\n\tfor(i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x,x+n);\n\tLL ans=0;\n\tLL cur=0;\n\t//\n\tbool ok=false;\n\twhile(!ok){\n\t\tans+=cur?(x[cur]-x[cur-1]):x[cur];\n\t\tfor(i=cur;i<n && x[i]-x[cur]<=t;i++);\n\t\tint j=i-1;\n\t\t//printf(\"%d\\n\",j);\n\t\tif(j==n-1) ok=true;\n\t\tans+=2*(x[j]-x[cur]);\n\t\tfor(i=cur;i<=j;i++) rem[i]=t-(2*(x[j]-x[cur]))+(x[i]-x[cur]);\n\t\tLL add=0;\n\t\tfor(i=cur;i<=j;i++){\n\t\t\trem[i]-=add;\n\t\t\tif(rem[i]>0) ans+=rem[i];\n\t\t\tif(i+1<=j) ans+=x[i+1]-x[i];\n\t\t\tadd+=x[i+1]-x[i];\n\t\t}\n\t\t//printf(\"%d %lld\\n\",cur,ans);\n\t\tcur=j+1;\n\t}\n\tif(x[n-1]<e) ans+=e-x[n-1];\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005],ml[100005];\nmultiset<ll> s;\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tml[0]=mem[0]-x[0]-x[1]-x[1];\n\tint cur=1;\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=max(t,x[i]+x[i]-x[0])+x[i]-x[0];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tif (i>1) {\n\t\t\twhile(cur<i && x[i]-x[cur]+x[i]-x[cur+1]>t) {\n\t\t\t\ts.erase(s.find(mem[cur]-x[cur+1]));\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tmem[i]=min(mem[i],ml[min(cur,i-1)-1]+3ll*x[i]);\n\t\t\tif (!s.empty()) mem[i]=min(mem[i],(*s.begin())+t+x[i]);\n\t\t}\n\t\tml[i]=min(ml[i-1],mem[i]-x[i]-x[i+1]-x[i+1]);\n\t\ts.insert(mem[i]-x[i+1]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct SegTree{\n\tllint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(llint size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = inf;\n\t}\n\t\n\tvoid update(llint i, llint val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tllint query(int a, int b)\n\t{\n\t\tif(a > b) return inf;\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint N, E, T;\nllint x[100005];\nSegTree seg(17), seg2(17);\n\nint main(void)\n{\n\tcin >> N >> E >> T;\n\tfor(int i = 1; i <= N; i++) cin >> x[i];\n\t\n\tseg.init(), seg.update(0, 0);\n\tseg2.init(), seg2.update(0, -2*x[1]);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tllint lb = lower_bound(x, x+N, x[i] - T/2) - x;\n\t\tllint tmp = seg.query(lb-1, i-1) + T;\n\t\ttmp = min(tmp, seg2.query(0, lb-2) + 2*x[i]);\n\t\tseg.update(i, tmp), seg2.update(i, tmp - 2*x[i+1]);\n\t}\n\tcout << seg.query(N, N) + E << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n, e, T;\nint x[MAXN];\n\nvoid input()\n{\n\tscanf(\"%d%d%d\", &n, &e, &T);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &x[i]);\n}\n\nll f[MAXN];\n\nvoid solve()\n{\n\tf[0] = 0;\n\tll minv = 1e18;\n\tint j = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tf[i] = f[i - 1] + T;\n\t\twhile(2 * (x[i] - x[j + 1]) > T)\n\t\t{\n\t\t\tminv = min(minv, f[j] - 2 * x[j + 1]);\n\t\t\tj++;\n\t\t}\n\t\tf[i] = min(f[i], f[j] + T);\n\t\tf[i] = min(f[i], minv + 2 * x[i]);\n\t}\n}\n\nvoid output()\n{\n\tprintf(\"%lld\\n\", f[n] + e);\n}\n\nint main()\n{\n\tinput();\n\tsolve();\n\toutput();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\nint N, T, E, X[2002];\nint64 dp[2003][2003];\n\nint64 getCost(int Left, int Right)\n{\n  return (max(T, (X[Right] - X[Left]) * 2));\n}\n\n// endd 回収済み(閉区間)\nint64 rec(int endd, int idx)\n{\n  if(idx == N - 1) return (getCost(endd, idx));\n  if(~dp[endd][idx]) return (dp[endd][idx]);\n  int64 ret = INF;\n  ret = min(ret, rec(idx + 1, idx + 1) + getCost(endd, idx) + X[idx + 1] - X[idx]);\n  ret = min(ret, rec(endd, idx + 1) + X[idx + 1] - X[idx]);\n  return (dp[endd][idx] = ret);\n}\n\nint main()\n{\n  cin >> N;\n  if(N > 2000) throw (0);\n  cin >> E >> T;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, 0) + X[0] + E - X[N - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n \ntypedef pair<int,int>  pii;\n \nconst int MAX=1e6;\nconst int INF=1e18;\n \nint N,E,T,arr[MAX],dp[MAX],tot[MAX],pre[MAX],nxt[MAX];\n \n/*int cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}*/\n \nvoid solve()\n{\n\tdp[N]=T+E-arr[N];\n\ttot[N]=3*arr[N]+E-arr[N];\n\t//cout<<dp[N]<<\" ha ha \\n\";\n\t//tot[N]=INF;\n\tfor(int A=N-1;A>=1;A--)\n\t{\n\t\tdp[A]=pre[A]+arr[nxt[A]+1]-arr[nxt[A]]+dp[nxt[A]+1];\n\t   \tif(nxt[A]<N)\n\t   \t    dp[A]=min(dp[A],-3*arr[A]+tot[nxt[A]+1]);\n\t\ttot[A]=min(tot[A+1],3*arr[A]+arr[A+1]-arr[A]+dp[A+1]);\n\t\t/*for(int B=nxt[A]+1;B<=N;B++)\n\t\t{\n\t\t\tcout<<dp[A]<<\"lol \\n\";\n\t\t\tdp[A]=min(dp[A],3*(arr[B]-arr[A])+arr[B+1]-arr[B]+dp[B+1]);\n\t\t\t//cout<<dp[A]<<\" \"<<3*(arr[B]-arr[A])<<\" \"<<arr[B+1]-arr[B]<<\" \"<<dp[B+1]<<\"lol \\n\";\n\t\t}*/\n\t\t//cout<<A<<\" \"<<dp[A]<<\"\\n\";\n\t\t//<<pre[A]<<\" \"<<dp[nxt[A]+1]<<\"\\n\";\n\t}\n\treturn ;\n}\n \nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n \n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t{\n\t\tint low=A,high=N,mid,res=A;\n\t\twhile(low<=high)\n\t\t{\n\t\t\tmid=(low+high)/2;\n\t\t\tif(T-2*(arr[mid]-arr[A])>0)\n\t\t\t{\n\t\t\t\tres=mid;\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh=mid-1;\n\t\t}\n\t\tnxt[A]=res;\n\t\tpre[A]=T-2*(arr[res]-arr[A])+3*(arr[res]-arr[A]);\n\t}\n\tsolve();\n\tcout<<arr[1]+dp[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nstruct RMQ {\n    int N;\n    vector<long long> seg;\n\n    RMQ(int n) {\n        N = 1 << (int)log2(n * 2 - 1);\n        seg.resize(N * 2, 1e18);\n    }\n\n    void update(int k, long long v) {\n        for (seg[k += N] = v; k > 1; k >>= 1) {\n            seg[k >> 1] = min(seg[k], seg[k ^ 1]);\n        }\n    }\n\n    long long minimum(int l, int r) {\n        long long res = 1e18;\n        for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = min(res, seg[l++]);\n            if (r & 1) res = min(res, seg[--r]);\n        }\n        return res;\n    }\n};\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n), d(n), ds(n + 1);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    RMQ L(n + 1), R(n + 1);\n    L.update(0, 0);\n    R.update(0, 0);\n\n    for (int i = 0; i < n; i++) {\n        // T >= 2 * (ds[i] - ds[j])\n        int ok = i;\n        int ng = -1;\n        while (ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if (T >= 2 * (ds[i] - ds[mid])) ok = mid;\n            else ng = mid;\n        }\n        chmin(dp[i + 1], L.minimum(ok, i + 1));\n        chmin(dp[i + 1], R.minimum(0, ok) + 2 * ds[i]);\n\n        L.update(i + 1, dp[i + 1] + T);\n        R.update(i + 1, dp[i + 1] - ds[i]);\n    }\n\n    cout << dp[n] + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[2010];\nint main() {\n    ll N, E, T; scanf(\"%lld%lld%lld\", &N, &E, &T);\n    if(N > 2000) return 1;\n\n    vector<ll> S(N+1);\n    for(int i=0; i<N; i++) {\n        scanf(\"%lld\", &S[i+1]);\n    }\n\n    fill(dp, dp + N + 1, LONGINF);\n    dp[0] = 0;\n    ll ans = (S[1] - 0) + (E - S[N]);\n    for(int i=0; i<=N; i++) {\n        if(i == N) continue;\n        for(int j=i; j<N; j++) {\n            ll d = S[j+1] - S[i+1], e = 0;\n            if(j+1 < N) e = S[j+2] - S[j+1];\n            ll c1 = dp[i] + 3*d, c2 = dp[i] + T + d;\n            chmin(dp[j+1], max(c1, c2) + e);\n        }\n    }\n    ans += dp[N];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// Verified: AOJ-DSL2A, AOJ-DSL2B\ntemplate <typename T>\nclass SegmentTree {\n private:\n  function<T(T, T)> merge_fn;\n  T empty_value;\n  vector<T> nodes;\n  int num_nodes;\n\n  // Returns the fold of overwrap between [node_l, node_r) and [l, r).\n  // nodes[node_index] needs to correspond to [node_l, node_r).\n  T GetRangeInternal(int node_index, int node_l, int node_r, int l, int r) {\n    if (node_r <= l || r <= node_l) return empty_value;\n    if (l <= node_l && node_r <= r) return nodes[node_index];\n    int node_m = (node_l + node_r) / 2;\n    return merge_fn(\n        GetRangeInternal(2 * node_index, node_l, node_m, l, r),\n        GetRangeInternal(2 * node_index + 1, node_m, node_r, l, r));\n  }\n\n public:\n  // Arguments:\n  // in_merge: The function to merge two values. It should be a monoid.\n  // in_empty_value: The identity of the monoid.\n  // xs: The initial values.\n  SegmentTree(\n      function<T(T, T)> merge_fn, T empty_value, const vector<T>& xs) :\n          merge_fn(merge_fn), empty_value(empty_value) {\n    int n = xs.size();\n    num_nodes = 1;\n    while (num_nodes < n) num_nodes *= 2;\n    num_nodes *= 2;\n    nodes = vector<T>(num_nodes, empty_value);\n    for (int i = 0; i < xs.size(); ++i) {\n      nodes[num_nodes / 2 + i] = xs[i];\n    }\n    for (int i = num_nodes / 2 - 1; i >= 1; i--) {\n      nodes[i] = merge_fn(nodes[2 * i], nodes[2 * i + 1]);\n    }\n  }\n\n  // Updates the i-th element to x.\n  void Update(int i, T x) {\n    nodes[num_nodes / 2 + i] = x;\n    for (int cur = (num_nodes / 2 + i) / 2; cur > 0; cur /= 2) {\n      nodes[cur] = merge_fn(nodes[2 * cur], nodes[2 * cur + 1]);\n    }\n  }\n\n  // Returns the value of the range [l, r) merged by merge_fn.\n  T GetRange(int l, int r) {\n    return GetRangeInternal(1, 0, num_nodes / 2, l, r);\n  }\n\n  T Get(int i) {\n    return nodes[num_nodes / 2 + i];\n  }\n};\n\nconstexpr int DEBUG = 0;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  int64 length;\n  int64 t;\n  cin >> n >> length >> t;\n  vector<int64> xs(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> xs[i];\n  }\n\n  vector<int64> dp(n + 1);\n\n  function<int64(int64, int64)> merge_fn = [](int64 x, int64 y) {\n    return min(x, y);\n  };\n  constexpr int64 EMPTY_VALUE = INT64_MAX / 4;\n  SegmentTree<int64> tree1(merge_fn, EMPTY_VALUE, vector<int64>(n + 1, EMPTY_VALUE));\n  SegmentTree<int64> tree2(merge_fn, EMPTY_VALUE, vector<int64>(n + 1, EMPTY_VALUE));\n  tree1.Update(0, dp[0] - xs[0]);\n  tree2.Update(0, dp[0] - xs[0] - 2 * xs[1]);\n\n  for (int i = 1; i <= n; i++) {\n    if (DEBUG) cout << \"i: \" << i << endl;\n    int k =\n        distance(xs.begin(), lower_bound(xs.begin(), xs.end(), xs[i] - t / 2));\n    if (DEBUG) cout << \"k: \" << k << endl;\n    int64 min1 = tree1.GetRange(k - 1, i) + xs[i] + t;\n    int64 min2 = tree2.GetRange(0, k - 1) + 3 * xs[i];\n    dp[i] = min(min1, min2);\n    if (DEBUG) cout << \"dp[i]: \" << dp[i] << endl;\n    if (i < n) {\n      tree1.Update(i, dp[i] - xs[i]);\n      tree2.Update(i, dp[i] - xs[i] - 2 * xs[i + 1]);\n    }\n  }\n\n  int64 ans = dp[n] + length - xs[n];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/2\n\n#define MAX_N 1000\n\nint n,e,T;\nll x[111111];\nll mem[111111];\n\nll dfs(ll l){\n\tif(mem[l]!=-1)return mem[l];\n\tif(l==n-1)return T;\n\tif(l==n)return 0;\n\tll res=T+(x[l+1]-x[l])+dfs(l+1);\n\trepl(r,l+1,n){\n\t\tll time=(x[r]-x[l])*2;\n\t\tll sum=0;\n\t\tif(time>T){\n\t\t\tsum+=time;\n\t\t}else{\n\t\t\tsum+=T-time;\n\t\t}\n\t\tsum+=(x[r+1]-x[l]);\n\t\tminch(res,sum+dfs(r+1));\n\t}\n\treturn mem[l]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>e>>T;\n\trep(i,n)cin>>x[i];\n\tx[n]=x[n-1];\n\tmemset(mem,-1,sizeof(mem));\n\tcout<<dfs(0)+x[0]+(e-x[n-1])<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], st[444444] = {inf};\nint upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind or r < l)\n        return inf;\n    if(l == r)\n        return st[cur] = val;\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    return st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl or r < l or sr < sl)\n        return inf;\n    if(sl <= l and r <= sr)\n        return st[cur];\n    if(l == r)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    upd(0, n, 0, 0, -2*x[1]);\n\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if((x[i]-x[j])*2 < t)\n            j--;\n        dp[i] = min(dp[j]+t, mn(0,n,0,j-1,0)+2*x[i]);\n        //cout << i << ' ' << j << ' ' << dp[i] << endl;\n\n        upd(0, n, 0, i, dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\ntemplate <class T>\nstruct SegmentTree {\n    using Merger = std::function<T(T, T)>;\n\n    int length;\n    std::vector<T> dat;\n    T unit;\n    Merger merge;\n\n    explicit SegmentTree(int n, T unit, Merger merge)\n        : length(1), unit(unit), merge(merge) {\n        while (length < n) length <<= 1;\n        dat.assign(length * 2, unit);\n    }\n\n    T query(int ql, int qr) {\n        ql = std::max(ql, 0);\n        qr = std::min(qr, length);\n        ql += length, qr += length;\n\n        T lacc = unit, racc = unit;\n        while (ql < qr) {\n            if (ql & 1) {\n                lacc = merge(lacc, dat[ql]);\n                ++ql;\n            }\n            if (qr & 1) {\n                --qr;\n                racc = merge(dat[qr], racc);\n            }\n            ql >>= 1, qr >>= 1;\n        }\n        return merge(lacc, racc);\n    }\n\n    void update(int nidx, T elem) {\n        nidx += length;\n        dat[nidx] = elem;\n\n        while (nidx > 0) {\n            nidx >>= 1;\n            T vl = dat[nidx * 2 + 0];\n            T vr = dat[nidx * 2 + 1];\n            dat[nidx] = merge(vl, vr);\n        }\n    }\n};\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 50;\n\nvoid solve() {\n    int n;\n    lint e, t;\n    std::cin >> n >> e >> t;\n\n    std::vector<lint> xs(n);\n    for (auto& x : xs) {\n        std::cin >> x;\n        x *= 2;\n    }\n    xs.push_back(e * 2);\n\n    std::vector<int> ls(n);\n    {\n        int l = 0;\n        for (int i = 0; i < n; ++i) {\n            while (xs[i] - xs[l] > t) ++l;\n            ls[i] = l;\n        }\n    }\n\n    SegmentTree<lint>\n        near_seg(n + 1, INF,\n                 [](auto a, auto b) { return std::min(a, b); }),\n        far_seg(n + 1, -INF,\n                [](auto a, auto b) { return std::max(a, b); });\n\n    auto update = [&](int i, lint c) {\n        near_seg.update(i, c);\n        far_seg.update(i, xs[i] - c);\n    };\n\n    update(0, 0);\n    for (int i = 0; i < n; ++i) {\n        lint nc = near_seg.query(ls[i], i + 1) + t;\n        lint fc = xs[i] - far_seg.query(0, ls[i]);\n\n        auto c = std::min(nc, fc);\n        update(i + 1, c);\n    }\n\n    lint ans = e + near_seg.query(n, n + 1);\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll n,t,e,i,x[100005],dp[100005],ans=0,tr[2][100005],pos;\nconst ll inf=1e18;\nll lowbit(ll p){return p&-p;}\nvoid modify(ll ty,ll p,ll v)\n{\n\twhile(p<=n)\n\t{\n\t\ttr[ty][p]=min(tr[ty][p],v);\n\t\tp+=lowbit(p);\n\t}\n}\nll ask(ll ty,ll p)\n{\n\tll ans=inf;\n\twhile(p)\n\t{\n\t\tans=min(ans,tr[ty][p]);\n\t\tp-=lowbit(p);\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);ans=e;\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&x[i]),tr[0][i]=tr[1][i]=inf;\n\tpos=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tdp[i]=dp[i-1]+t;\n\t\twhile(pos<=n&&2*x[pos]<=2*x[i]-t)pos++; \n\t\tif(pos<i)dp[i]=min(dp[i],t+ask(1,n-pos+1));\n\t\tif(pos>1)dp[i]=min(dp[i],2LL*x[i]+ask(0,pos-1));\n\t\tmodify(0,i,dp[i-1]-2LL*x[i]);\n\t\tmodify(1,n-i+1,dp[i-1]);\n\t\t//printf(\"%lld\")\n\t}\n\tprintf(\"%lld\\n\",ans+dp[n]);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, t, e;\nint x[111111];\nlong long f[111111], g[111111];\n\nint main(){\n//\tfreopen(\"input.inp\", \"r\", stdin);\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\",&x[i]);\n\tint p = 0;\n\tg[0] = - 2 * x[1];\n\tfor(int i = 1; i <= n; ++i){\n\t\twhile (2 * (x[i] - x[p + 1]) > t) ++p;\n\t\tf[i] = f[p] + t;\n\t\tif (p) f[i] = min(f[i], g[p - 1] + 2 * x[i]);\n\t\tg[i] = min(f[i] - 2 * x[i + 1], g[i - 1]);\n\t}\n\tprintf(\"%I64d\",f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst LL Infll = 0x3f3f3f3f3f3f3f3f;\nconst int MN = 200005;\n\nint N, E, T, A[MN];\nLL f[MN], g[MN];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tint j = 1;\n\tg[0] = Infll;\n\tfor (int i = 1; i <= N; ++i) {\n\t\twhile (2 * (A[i] - A[j]) > T) ++j;\n\t\tf[i] = std::min(f[j - 1] + T, 2 * A[i] + g[j - 1]);\n\t\tg[i] = std::min(g[i - 1], f[j - 1] - 2 * A[j]);\n\t}\n\tprintf(\"%lld\\n\", E + f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint main() {\nstd::cout << \"adsfafasdfafdasfasdfafdasf\" << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\n#define Set(a, b) memset(a, b, sizeof a)\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\n\nint n, e, t;\nLL f[N], g[N], p[N], d[N];\n\nint main() {\n\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &p[i]);\n\t\td[i - 1] = p[i] - p[i - 1];\n\t}\n\tSet(f, 60), Set(g, 60);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tf[i] = min(f[i - 1], g[i - 1]) + d[i - 1] + t;\n\t\tif (i - 1 >= 1)\n\t\t\tg[i] = g[i - 1] + 3 * d[i - 1];\n\t\tif (i - 2 >= 0) {\n\t\t\tLL x = min(f[i - 2], g[i - 2]);\n\t\t\tx += p[i] - p[i - 2] + 2 * d[i - 1];\n\t\t\tif (t > 2 * d[i - 1])\n\t\t\t\tx += t - 2 * d[i - 1];\n\t\t\tg[i] = min(g[i], x);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(f[n], g[n]) + e - p[n]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<algorithm>\n#define L long long\n#define min(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\nint n,m,t,x[100010],f[100010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=1,j=0,k=2e9;i<=n;i++)\n\t  {\n\t   for(;2*(x[i]-x[j+1])>t;j++)\n\t     k=min(k,f[j]-2*x[j+1]);\n\t   f[i]=min(k+2*x[i],f[j]+t);\n      }\n    cout<<(L)f[n]+m<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntypedef long long lint;\nconstexpr lint inf = 1ll << 60;\n\nint N;\nlint X[100001];\nlint T, E;\nlint dp[100001];\n\nint main() {\n\n    cin >> N >> E >> T;\n    rep(i, N) cin >> X[i + 1];\n\n    if(N > 2000) return 0;\n\n    rep(i, N + 1) dp[i] = inf;\n    dp[0] = 0;\n\n    rep(i, N) {\n        chmin(dp[i + 1], dp[i] + X[i + 1] - X[i] + T);\n        rep(j, i + 2, N) {\n            chmin(dp[j], dp[i] + max(2 * (X[j] - X[i + 1]), T) + X[j] - X[i]);\n        }\n    }\n\n    cout << dp[N] + E - X[N] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    //if(n > 2000) return 1;\n    sort(x, x + n + 1);\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << e - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INTMAX 2147483647LL\n#define PII pair<int,int>\n#define MK make_pair\n#define re register\nusing namespace std;\ntypedef long long ll;\nconst double Pi=acos(-1.0);\nconst int Inf=0x3f3f3f3f;\nconst int MAXN=1e5+10;\ninline int read(){\n\tre int x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\ninline ll readll(){\n\tre ll x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\n\nint n; \nll E,T;\nll a[MAXN],f[MAXN];\nint main(){\n\tn=read();E=readll();T=readll();\n\tfor(int i=1;i<=n;++i) a[i]=readll();\n\t\n\tf[0]=0;\n\tint now=0;ll mn=1e18+7;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(T<=2*(a[i]-a[now+1])){\n\t\t\tmn=min(mn,f[now]-2*a[now+1]);++now;\n\t\t}\n\t\tf[i]=min(f[now]+T,mn+2*a[i]);\n\t}\n\tprintf(\"%lld\",E+f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\n\nconst int maxn = 100000 + 10;\nint n, e, t;\nlong long x[maxn];\nint nxt[maxn];\nlong long f[maxn];\nlong long rmq[2][maxn << 1];\n\nvoid upd(int k, int p, long long val) {\n\tfor (rmq[k][p += maxn] = val; p > 1; ) p >>= 1, rmq[k][p] = min(rmq[k][p << 1], rmq[k][p << 1 | 1]);\n}\nlong long query(int k, int l, int r) {\n\tlong long res = LINF;\n\tfor (l += maxn, r += maxn + 1; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = min(res, rmq[k][l++]);\n\t\tif (r & 1) res = min(res, rmq[k][--r]);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n >> e >> t;\n\tFOR(i, 0, n) cin >> x[i];\n\tx[n] = e;\n\tfor (int i = 0; i < (maxn << 1); i++) {\n\t\trmq[0][i] = rmq[1][i] = LINF;\n\t}\n\tint ptr = 0;\n\tFOR(i, 0, n) {\n\t\twhile (ptr < n - 1 && 2 * (x[ptr + 1] - x[i]) <= t) ptr++;\n\t\tnxt[i] = ptr;\n\t}\n\tupd(0, n, f[n] + x[n] + t);\n\tupd(1, n, f[n] + 2 * x[n - 1] + x[n]);\n\tFORd(i, n, 0) {\n\t\tint ix = nxt[i];\n\t\tf[i] = query(0, i + 1, ix + 1) - x[i];\n\t\tchkmin(f[i], query(1, ix + 2, n) - 3 * x[i]);\n\t\tif (i) {\n\t\t\tupd(0, i, f[i] + x[i] + t);\n\t\t\tupd(1, i, f[i] + 2 * x[i - 1] + x[i]);\n\t\t}\n\t}\n\tcout << f[0] + x[0] << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Question:\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n\tint N;\n\tlong long E,T;\n\tcin>>N>>E>>T;\n\tint i;\n\tvector<long long> x(N,0);\n\tvector<long long> t(N,0);\n\tfor (i=0;i<N;i++){\n\t\tcin>>x[i];\n\t\tt[i]=T;\n\t}\n\tlong long dist=x[0];\n\tlong long d;\n\td=x[0];\n\tfor (i=1;i<N;i++){\n\t\td=x[i]-x[i-1];\n\t\tif (t[i-1]<=d){\n\t\t\tdist+=t[i-1]+d;\n\t\t\tt[i-1]=0;\n\t\t}else{\n\t\t\tdist+=2*d;\n\t\t\tt[i-1] -= 2*d;\n\t\t\tif (t[i-1]<0){\n\t\t\t\tt[i-1]=0;\n\t\t\t}\n\t\t\tdist+=t[i-1];\n\t\t\tdist+=d;\n\t\t\tt[i] -= 2*d;\n\t\t\tif (t[i]<0){\n\t\t\t\tt[i]=0;\n\t\t\t}\n\t\t\tdist+=t[i];\n\t\t}\n\t}\n\tdist += t[N-1]+E-x[N-1];\n\tcout<<dist<<endl;\n\tx.clear();\n\tt.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint dp[100020];\n\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=i-cor;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<=vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse vec[i]=vec[2*i+1];\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<=v2.first)return v1;\n\t\telse return v2;\n\t}\n\t\n};\n\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tfor(int i=0;i<=100010;i++)dp[i]=inf*1000000000ll;\n\t\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\t\n\tvector<int> ve(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\t\n\tSegmin ss;\n\tss.shoki1();\n\tss.shoki2();\n\t\n\tdp[0]=t;\n\tss.updchan(0,dp[0]-ve[1]);\n\tfor(int i=1;i<n;i++){\n\t\t// r miman\n\t\tint r =ve[i]-t/2;\n\t\tint it=lower_bound(ve.begin(),ve.end(),r)-ve.begin();\n\t\t// [ 0,it)\n\t\t// [it, i]\n\t\tif(it<=i)it=i;\n\t//\tcout<<it<<\" \"<<i<<endl;\n\t\tif(1){\n\t\t\tif(it)dp[i]=min(dp[i],t+dp[it-1]);\n\t\t\telse dp[i]=min(dp[i],t);\n\t\t}\n\t//cout<<dp[i]<<endl;\n\t\tif(it){\n\t\t\tdp[i]=min(dp[i],2*(ve[i]-ve[0]));\n\t\t\t\tif(it>1){\n\t\t\tint z=ss.segmin(0,it-1).first +2* ve[i];\n\t\t//\tcout<<z<<endl;\n\t\t\tdp[i]=min(dp[i],z);\n\t\t\t\t}\n\t\t}\t\n\t//\tcout<<dp[i]<<endl;\n\t\tss.updchan(i,dp[i]-2*ve[i+1]);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\t\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\nusing namespace std;\n#define rrep(i,m,n) for(int (i)=(int)(m);(i)>=(int)(n);(i)--)\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define M_PI 3.1415926535897932LL;\ntypedef pair<ll, ll> P;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 60;\nconstexpr long double EPS = 1e-10;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, Matrix& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid divisor_prime(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tinv[n] = mod_inv(fact[n]);\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tRmqTree seg1(n + 1), seg2(n + 1);\n\tseg1.update(0, 0);\n\tset<ll> st;\n\tst.insert(0);\n\tREP(i, n) {\n\t\twhile (st.size()) {\n\t\t\tll num = *st.begin();\n\t\t\tif (2 * (x[i] - x[num]) > t) {\n\t\t\t\tst.erase(num);\n\t\t\t\tll val = seg1.find(num, num + 1);\n\t\t\t\tseg2.update(num, val - 2 * x[num]);\n\t\t\t\tseg1.update(num, INF);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tst.insert(i + 1);\n\t\tll val = INF;\n\t\tchmin(val, seg1.find(0, n + 1) + x[i] + t);\n\t\tchmin(val, seg2.find(0, n + 1) + 3 * x[i]);\n\t\tseg1.update(i + 1, val - x[i]);\n\t}\n\tcout << e + seg1.find(n,n+1)<< endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/* Karen {{{\n  ___  ____\n |_  ||_  _|\n   | |_/ /    ,--.   _ .--.  .---.  _ .--.\n   |  __'.   `'_\\ : [ `/'`\\]/ /__\\\\[ `.-. |\n  _| |  \\ \\_ // | |, | |    | \\__., | | | |\n |____||____|\\'-;__/[___]    '.__.'[___||__]\n}}} */\n/* cpp template {{{*/\nusing namespace std;\n\n#define endl '\\n'\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define REPS(i, a, n) for (int i = (a); i < (n); i++)\n#define RREP(i, n) for (int i = 1; i <= (n); i++)\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ALL(v) v.begin(), v.end()\n\ntypedef double D;\ntypedef int ll;\ntypedef long double lb;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\ntypedef pair<int, int> pii;\ntypedef pair<int, string> pis;\ntypedef pair<string, int> psi;\n\ninline bool inside(int y,int x,int H,int W){return(y>=0&&x>=0&&y<H&&x<W);}\ninline int in() {int x; std::cin >> x; return x;}\n\ntemplate <typename T>\nvoid print(std::vector<T>& v, char c = ' ') {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << c;\n    std::cout << v[i];\n  }\n  std::cout << endl;\n}\ntemplate <typename T>\nvoid print(T x) {\n  std::cout << x << '\\n';\n}\n/* }}} */\n/* 定数 {{{*/\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9 + 9;\nconst D EPS  = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n/* }}} */\n\n#define int long long\n\nint x[101010];\nint n, e, T;\n\nint cost;\n\nint dp[101010];\n\nint dfs(int i=1, int now=0, int t=T)\n{\n  int d = x[i] - x[now];\n  int dt = max(0ll, t - 2ll * d);\n  int dT = max(0ll, T - 2ll * d);\n  if (i == n) return t;\n  int &ret = dp[i];\n  if (ret != -1) return ret;\n  ret = min(t + d + dfs(i + 1, now + 1, T), dt + 3 * d + dfs(i + 1, now + 1, dT));\n\n  return ret;\n}\n\nsigned main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> n >> e >> T;\n  REP(i, n) cin >> x[i];\n\n  cost += x[0] + e - x[n - 1];\n\n  cout << dfs() + cost + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Do you knOW what it feels like?\n\n\t\t// To be TorTured by your own MinD?\n\t\n\t// I don't wanna feel the PAIN.\n\n// I BeG you to KILL me, pleASE...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"Os\") \n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, lg=23, mod=1e9+7, inf=1e18;\n\nll n,m,t,a[maxn],dp[maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>m>>t;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tll mmm=inf;\n\tfor(int i=1,j=0;i<=n;i++){\n\t\twhile(2*(a[i]-a[j+1])>t){\n\t\t\tmmm=min(mmm,dp[j]-2*a[j+1]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=min(mmm+2*a[i],dp[j]+t);\n\t}\n\tcout<<dp[n]+m<<endl;\n\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t; if(n>3000) return  0;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto&\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\n\nlint dp[2020];\n\nlint brute() {}\n\nint main() {\n    cin >> n >> e >> t;\n\n    vector<lint> x(n + 1);\n    rep(i, n) cin >> x[i + 1];\n\n    //if (n > 2020) return 0;\n\n    rep(i, n + 1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    //(val, range)\n    typedef pair<lint, lint> pll;\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n\n    for (int i = 0; i <= n; i++) {\n        while (!pq.empty()) {\n            auto p = pq.top();\n            pq.pop();\n            if (p.second <= i) continue;\n            chmin(dp[i], p.first + x[i]);\n            break;\n        }\n\n        int pos = (upper_bound(all(x), x[i + 1] + t / 2) - begin(x));\n        pq.push({dp[i] - x[i] + t, pos});\n\n        for (int j = pos; j <= n; j++) {\n            lint d = x[j] - x[i + 1];\n\n            if (2 * d >= t) {\n                chmin(dp[j], dp[i] + (x[i + 1] - x[i]) + 3 * d);\n            }\n        }\n    }\n    cout << dp[n] + (e - x[n]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// LNU_Algotesters\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include <fstream>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 100 * 1000 + 47;\n\n\nint A[MAX];\nLL DP[MAX];\n\n\nint main()\n{\n    \n    //freopen(\"in.txt\", \"r\", stdin);\n    //ios::sync_with_stdio(false); cin.tie(0);\n    \n    int n, e, t;\n    scanf(\"%d%d%d\", &n, &e, &t);\n    FOR(i, 0, n)\n        scanf(\"%d\", A + i);\n    \n    FOR(i, 0, n+1)DP[i] = INF;\n    \n    DP[0] = 0;\n    multiset<LL> S, SS;\n    SS.insert(0);\n    int idx = 0;\n    FOR(i, 0, n)\n    {\n        DP[i+1] = DP[i] + t;\n        while(idx < i && 2 * (A[i] - A[idx]) > t)\n        {\n            SS.erase(SS.find(DP[idx]));\n            S.insert(DP[idx] - 2 * A[idx]);\n            idx++;\n        }\n        \n        if (!SS.empty())\n        {\n            DP[i+1] = min(DP[i+1], *SS.begin() + t);\n        }\n        if (!S.empty())\n        {\n            DP[i+1] = min(DP[i+1], *S.begin() + 2 * A[i]);\n        }\n        \n        SS.insert(DP[i+1]);\n        \n    }\n    cout << e + DP[n] << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = x[i] - x[j + 1] + f[j];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\tfor (int j = max(0, i - 100000000 / n); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t\tfor (int j = 0; j < min(i, 100000000 / n); j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\n\t\t}\n\t\twhile (p + 1 < i && calc(p, i) > calc(p + 1, i)) ++p;\n\t\tf[i] = min(f[i], calc(p, i));\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nconst num inf = 0x3f3f3f3f3f3f3f3f;\nint n, m, a[nsz + 5];\nnum t, dp[nsz + 5], ans;\n\nstruct segment_tree {\n\t#define ls  (u << 1)\n\t#define rs  (u << 1 | 1)\n\tint fm[4 * nsz + 5];\n\tnum mn[4 * nsz + 5], del[4 * nsz + 5];\n\t\n\tvoid inline down(int u) {\n\t\tif (!del[u])  return;\n\t\tmn[ls] += del[u];\n\t\tmn[rs] += del[u];\n\t\tdel[ls] += del[u];\n\t\tdel[rs] += del[u];\n\t\tdel[u] = 0;\n\t}\n\t\n\tvoid init(int u = 1, int l = 0, int r = n) {\n\t\tif (l == r) {\n\t\t\tfm[u] = l;\n\t\t\treturn;\n\t\t}\n\t\tint md = (l + r) >> 1;\n\t\tinit(ls, l, md);\n\t\tinit(rs, md + 1, r);\n\t\tfm[u] = fm[ls];\n\t}\n\t\n\tvoid upd(int el, int er, int val, int u = 1, int l = 0, int r = n) {\n\t\tif (l >= el && r <= er) {\n\t\t\tmn[u] += val;\n\t\t\tdel[u] += val;\n\t\t\treturn;\n\t\t}\n\t\tdown(u);\n\t\tint md = (l + r) >> 1;\n\t\tif (el <= md) {\n\t\t\tupd(el, er, val, ls, l, md);\n\t\t}\n\t\tif (er > md) {\n\t\t\tupd(el, er, val, rs, md + 1, r);\n\t\t}\n\t\tfm[u] = mn[ls] < mn[rs] ? fm[ls] : fm[rs];\n\t\tmn[u] = min(mn[ls], mn[rs]);\n\t}\n\t\n\tpair<num, int> qry(int el, int er, int u = 1, int l = 0, int r = n) {\n\t\tif (l >= el && r <= er)  return make_pair(mn[u], fm[u]);\n\t\tdown(u);\n\t\tint md = (l + r) >> 1, fm = -1;\n\t\tnum mn = inf;\n\t\tpair<num, int> res;\n\t\tif (el <= md) {\n\t\t\tres = qry(el, er, ls, l, md);\n\t\t\tmn = res.first, fm = res.second;\n\t\t}\n\t\tif (er > md) {\n\t\t\tres = qry(el, er, rs, md + 1, r);\n\t\t\tfm = mn < res.first ? fm : res.second, mn = min(mn, res.first);\n\t\t}\n\t\treturn make_pair(mn, fm);\n\t}\n};\nsegment_tree tr;\n\nnum f(int i, int j) {\n\treturn t - 2LL * (a[i] - a[j + 1]);\n}\n\nnum calc(int i, int j) {\n\treturn dp[j] + 3LL * a[i] - a[j] - 2LL * a[j + 1] + max(0LL, t - 2 * (a[i] - a[j + 1]));\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin >> n >> m >> t;\n\tcont (i, n) {\n\t\tcin >> a[i];\n\t}\n\ttr.init();\n\tint j = 0;\n\ttr.upd(0, 0, dp[0] - a[0] - 2 * a[1] + max(0LL, t - 2 * (a[0] - a[1])));\n\tcont (i, n) {\n\t\tfor (; j < i && f(i, j) <= 0; tr.upd(j, j, -f(i - 1, j)), ++j);\n\t\ttr.upd(j, i - 1, -2 * (a[i] - a[i - 1]));\n\t\tpair<num, int> tmp = tr.qry(0, i - 1);\n\t\tint p = tmp.second;\n\t\tdp[i] = calc(i, p);\n\t\ttr.upd(i, i, dp[i] - a[i] - 2 * a[i + 1] + max(0LL, t - 2 * (a[i] - a[i + 1])));\n\t}\n\tans = dp[n] + m - a[n];\n\tcout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], pmn[111111];\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    pmn[0] = -2*x[1];\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if((x[i]-x[j])*2 < t)\n            j--;\n        dp[i] = min(dp[j]+t, pmn[j-1]+2*x[i]);//mn(0,n,0,j-1,0)+2*x[i]);\n        pmn[i] = min(pmn[i-1], dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tfor(int A=1;A<=N+100;A++)\n\t\tdp[A]=-1;\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]);\n\t\t\t//cout<<A<<\" \"<<B<<\" \"<<pre[A][B]<<\"\\n\";\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,E,T;\nint x[100005];\nlong long f[100005];\nint main(){\n\tscanf(\"%d%d%d\",&N,&E,&T);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);x[0]=x[1];\n\tlong long ans=1e18,mn=1e18;\n\tfor(int i=1,p=1;i<=N;i++){\n\t\twhile(p<N&&(x[i]-x[p])>T/2) {\n\t\t\tmn=min(mn,f[p-1]-x[p]*2-x[p-1]);\n\t\t\tp++;\n\t\t}\n\t\tf[i]=min(f[p-1]+x[i]-x[p-1]+T,mn+x[i]*3LL);\n\t}\n\tans=min(ans,f[N]+x[1]+E-x[N]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst lint INF=1e18;\n\nint n;\nlint L,t;\nlint ar[100005];\nlint dp[100005];\nint main(){\n  cin>>n>>L>>t;\n  REP(i,n) scanf(\"%lld\",&ar[i]);\n  ar[n]=L;\n\n  ++n;\n  REP(i,n+1) dp[i]=INF;\n  dp[0]=ar[0];\n\n  int j=0;\n  REP(i,n){\n    while(j+1<n && (ar[j]-ar[i])*2<=t) ++j;\n    if(j+1<n) chmin(dp[j+1],dp[i]+(ar[j]-ar[i])*2+ar[j+1]-ar[i]);\n    chmin(dp[j],dp[i]+t+ar[j]-ar[i]);\n  }\n  lint res=dp[n-1];\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <Queue>\n#include <sstream>\n#include <utility>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n#define MP make_pair \n#define PB push_back \n#define INF (1000000007) \n#define eps 1e-8\n#define MOD (1000003)\n#define IOS ios::sync_with_stdio(false)\n\ntypedef pair<int,int> pii ;\ntypedef pair<double,double> pdd ;\ntypedef long long ll ;\n\nll n,e,t;\nll dp[100005],p[100005];\nll mx=1e18;\nmultiset<ll>s;\n\nint main()\n{\n\tIOS;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tdp[0]=0;\n\tint pos=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif((p[i]-p[pos])*2>t) \n\t\t\t{\n\t\t\t\tmx=min(dp[pos-1]-p[pos]*2,mx);\n\t\t\t\ts.erase(dp[pos-1]);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mx+2*p[i]);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Copyright 2016 AcrossTheSky */\n#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <cassert>\n#include <map>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#define REP(i, a, b) for (int i = (a); i <= (b); ++i)\n#define PER(i, a, b) for (int i = (a); i >= (b); --i)\n#define RVC(i, c) fot (int i = 0; i < (c).size(); ++i)\n#define RED(k, u) for (int k = head[(u)]; k; k = edge[k].next)\n#define SQR(k) (k) * (k)\n#define lowbit(x) ((x) & (-(x)))\n#define CL(x, v) memset(x, v, sizeof x)\n#define MP std::make_pair\n#define PB push_back\n#define FR first\n#define SC second\n#define rank rankk\n#define next nextt\n#define link linkk\n#define index indexx\n#define abs(x) ((x) > 0 ? (x) : (-(x)))\nusing namespace std;\ntypedef long long LL; typedef pair<int, int> PII;\n\ntemplate<class T> inline\nbool getmin(T *a, const T &b) {\n    if (b < *a) {\n        *a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline\nbool getmax(T *a, const T &b) {\n    if (b > *a) {\n        *a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline\nvoid read(T *a) {\n    char c;\n    while (isspace(c = getchar())) {}\n    bool flag = 0;\n    if (c == '-') flag = 1, *a = 0;\n    else\n        *a = c - 48;\n    while (isdigit(c = getchar())) *a = *a * 10 + c - 48;\n    if (flag) *a = -*a;\n}\n\nconst int mo = 1000000007;\ntemplate<class T>\nT pow(T a, T b, int c = mo) {\n    T res = 1;\n    for (T i = 1; i <= b; i <<= 1, a = 1LL * a * a % c) if (b & i) res = 1LL * res * a % c;\n    return res;\n}\n/*======================= TEMPLATE =======================*/\nconst int N = 210000;\nint n;\nLL f[N];\nmultiset<LL> S;\nLL T, E, x[N];\nint main() {\n    cin >> n >> E >> T;\n    REP(i, 1, n) read(x + i);\n    int j = 0;\n    LL tmp = 1e18;\n    S.insert(T);\n    REP(i, 1, n) {\n        while (2LL * (x[i] - x[j + 1]) >= T) {\n            getmin(&tmp, f[j] + x[j + 1] - x[j] -  x[j + 1] * 3);\n            multiset<LL>::iterator it = S.find(T + f[j] + x[j + 1] - x[j] - x[j + 1]);\n            S.erase(it);\n            ++j;\n        }\n        f[i] = 1e18;\n        if (!S.empty()) {\n            LL t1 = *S.begin();\n            getmin(&f[i], t1 + x[i]);\n        }\n        getmin(&f[i], tmp + x[i] * 3);\n        S.insert(T + f[i] + x[i + 1] - x[i] - x[i + 1]);\n    }\n    cout << f[n] + E - x[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt dp[108000];\nInt x[108000];\nInt l, n, e, t;\nint main(){\n  cin >> n >> e >> t;\n  fill(dp, dp + 108000, LINF);\n  dp[0] = 0;\n  for(int i = 1;i <= n;i++)cin >> x[i];\n  for(int i = 1;i <= n;i++){\n    dp[i] = dp[i-1] + t; \n    while((x[i] - x[l+1])*2>=t)l++;\n    if(l == 0)continue;\n    dp[i] = min(dp[i], dp[l-1] + (x[i] - x[l])*2);\n  }\n  cout << e + dp[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 9223372036854775807\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t;\nll dp[maxn];\nint x[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]);\n\trep(i,n){\n\t\tdp[i]=max((x[i]-x[0])*2LL,1LL*t);\n\t\trep(j,i){\n\t\t\tdp[i]=min(dp[j]+max(1LL*t,2LL*(x[i]-x[j+1])),dp[i]);\n\t\t}\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#define MAXN 2005\n#define INF 2000000000000000000LL\n#define LL long long\nusing namespace std;\nLL dp[MAXN];\nint num[MAXN];\nint n, e, t;\nLL work(int i, int j)\n{\n    LL res = 0, xx = 0;\n    for(int k = 0; k <= j; k++)\n    {\n        if((num[j] - num[i]) * 2 + xx < t)\n        {\n            res += t - (num[j] - num[i]) * 2 - xx;\n            xx += t - (num[j] - num[i]) * 2 - xx;\n        }\n    }\n    return res + 3LL * (num[j] - num[i]);\n}\nint main()\n{\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for(int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &num[i]);\n    }\n    num[0] = 0;\n    dp[0] = 0;\n    //cout << work(2, 3) << endl;\n    for(int i = 1; i <= n; i++)\n    {\n        LL tmp = dp[i - 1] + num[i] - num[i - 1] + t;\n        for(int j = 0; j < i - 1; j++)\n        {\n            tmp = min(tmp, dp[j] + num[j + 1] - num[j] + work(j + 1, i));\n            //cout << j << \" \" << i << \" \" << dp[j] + num[j + 1] - num[j] + work(j + 1, i) << endl;\n        }\n        dp[i] = tmp;\n    }\n    //for(int i = 0; i <= n; i++) cout << dp[i] << endl;\n    cout << dp[n] + e - num[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n    pushup(p);\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n    pushup(p);\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = n;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 >= T) low = mid;\n      else high = mid;\n    }\n    int pos = low;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    //assert(N <= 2000);\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1,1e18);\n    dp[0] = 0;\n    auto calc=[&](int i, int j) {\n        return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2);\n    };\n    vector<int> rev(N+1);\n    int cur = 0;\n    for (int i = 1; i <= N; i++) {\n        while (cur < i-1 and calc(i,cur) >= calc(i,cur+1)) cur++;\n        dp[i] = calc(i,cur);\n        rep(j,i) {\n            if (chmin(dp[i],calc(i,j))) rev[i] = j+1;\n        }\n    }\n    // for (int i = 1; i <= N; i++) {\n    //     cout << i << \" \";\n    // }\n    // cout << ln;\n    // for (int i = 1; i <= N; i++) {\n    //     cout << rev[i] << \" \";\n    // }\n    // cout << ln;\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\n\nLL getdist(vector<LL> &x, LL T, int i, int j, bool& param) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\tif(T < (x[j] - x[i]) * 2) param = true;\n\telse param = false;\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tLL p2 = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos = p2;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tbool a;\n\t\t\tLL data = getdist(x, T, pos , i, a);\n//\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tif(ans[i] > ans[pos] + data) p2 = pos;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tif(!a) break;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\tbool tmp;\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[j] = min(ans[j], ans[i] + getdist(x, T,i, j, tmp));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long ,int>seg[4*maxn];\npair<long long ,int>seg2[4*maxn];\nint a[maxn];\nlong long  dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long ,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long )1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long  val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long ,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long )1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint32_t main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<4*maxn;i++){\n\t\tseg[i]={(long long)1e18,(int)1e9};\n\t\tseg2[i]={(long long)1e18,(int)1e9};\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\tif(2*(a[i]-a[0])<d){\n\t\t\tr=0;\n\t\t}\n\t\tif(2*(a[i]-a[i-1])>=d){\n\t\t\tl=i-1;\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long)1e18+10;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*1*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*1*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 100005, sz = 131072;\nconst ll INF = ll(1e18);\n\nstruct Seg{\n    ll d[2 * sz];\n    void ini(){ fill(d, d + 2 * sz, INF); }\n    void upd(int x, ll v){\n        x += sz;\n        d[x] = min(d[x], v);\n        for(x >>= 1; x; x >>= 1) d[x] = min(d[2 * x], d[2 * x + 1]);\n    }\n    ll get(int s, int e){\n        ll r = INF;\n        for(s += sz, e += sz; s <= e; s >>= 1, e >>= 1){\n            if( s & 1) r = min(r, d[s++]);\n            if(~e & 1) r = min(r, d[e--]);\n        }\n        return r;\n    }\n} S, T;\n\nint n, l, t, x[N];\n\nint main(){\n    scanf(\"%d%d%d\", &n, &l, &t);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n    S.ini();\n    T.ini();\n    S.upd(0, 0);\n    T.upd(0, -2 * x[1]);\n    for(int i = 1, j = 0; i <= n; i++){\n        while(j < i - 1 && 2 * (x[i] - x[j + 1]) > t) j++;\n        ll v = min(S.get(j, i - 1) + t + x[i], T.get(0, j - 1) + 3 * x[i]);\n        S.upd(i, v - x[i]);\n        T.upd(i, v - x[i] - 2 * x[i + 1]);\n    }\n    printf(\"%lld\\n\", S.get(n, n) + l);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n, e, t;\nint x[100005];\nll f[100005];\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tll tmp = 0x3f3f3f3f3f3f3f3f;\n\tfor(int i = 1, j = 1; i <= n; i++)\n\t{\n\t\twhile(j <= n && (x[i] - x[j]) * 2 > t)\n\t\t{\n\t\t\ttmp = min(tmp, f[j - 1] - x[j] * 2);\n\t\t\tj++;\n\t\t}\n\t\tf[i] = min(f[j - 1] + t, tmp + x[i] * 2);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e);\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[2010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+2010, 1e15);\n\n  dp[0] = 0;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tFOR(j,i,N){\n\t  LL d = xs[j] - xs[i];\n\t  dp[j+1] = min(dp[j+1], dp[i] + t + d*3 + max(0ll, T-2*d));\n\t}\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005];\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=max(t,x[i]+x[i]-x[0])+x[i]-x[0];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tfor (int j=0;j<i-1;j++) mem[i]=min(mem[i],mem[j]+max(t,x[i]-x[j]+x[i]-x[j+1])+x[i]-x[j+1]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <ll> vi;\ntypedef pair <ll, ll> pi;\ntypedef vector <pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) (ll) x.size()\n#define f first\n#define s second\n#define MAXN 100100\nll INF = 1e18;\ndeque<pi> dq;\nll max_constant;\nll N,E,T;\nll off;\nll D[MAXN];\nll dp[MAXN];\nll d2[MAXN];\nqueue<pi> Q;\nmultiset<ll> S2;\n \nint main(){\n\tcin>>N>>E>>T;\n\tfor (int i=1;i<=N;++i)cin>>D[i];\n\tdp[0] = 0;\n\tfor (int i=1;i<=N;++i){\n\t\tdp[i] = INF;\n\t\tfor (int j=0;j<i;++j){\n\t\t\tdp[i] = min(dp[i], dp[j] + D[i] - D[j] + max(T, 2*D[i] - 2*D[j+1]) );\n\t\t}\n\t\t// cout<<dp[i]<<' ';\n\t}\n\tcout<<E-D[N] +dp[N];\n\t// max_constant = -INF;\n\t// Q.push(mp(T+2*D[1], 2*D[1]));\n\t// S2.insert(T+4*D[1]);\n \n\t// for (int i=1;i<=N;++i){\n\t// \twhile (SZ(Q) && Q.front().f <= 2*D[i]){\n\t// \t\tpi cur = Q.front();Q.pop();\n\t// \t\tmax_constant = max(max_constant, cur.s);\n\t// \t\tS2.erase(S2.find(cur.f+cur.s));\n\t// \t}\n\t// \t// cout<<max_constant<<'\\n';\n\t// \tdp[i] = INF;\n\t// \t// Case 1 is using the constant\n\t// \tdp[i] = min(dp[i], 3*D[i]-max_constant);\n\t// \t// Case 2: is waiting\n\t// \tdp[i] = min(dp[i], T + D[i] - D[i-1] + dp[i-1]);\n\t// \t// Case 3: Need to wait\n\t// \tif (SZ(S2))dp[i] = min(dp[i], *S2.begin() + D[i]);\n\t// \tQ.push(mp(T+2*D[i+1], -2*D[i+1] - D[i]+ dp[i]));\n\t// \tS2.insert(T-D[i]+dp[i]);\n\t// }\n\t// cout<<dp[N] + E-D[N];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cctype>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n\tint x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;\n}\n\nconst int N = 1000005;\nLL f[N], p[N];\n\nint main() {\n//\tfreopen(\"a.in\", \"r\", stdin);\n\tint n = read(), E = read(), T = read();\n\tfor (int i = 1; i <= n; ++i) p[i] = read();\n\tLL Mn = 1e18;\n\tint j = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (j <= i && 2 * (p[i] - p[j + 1]) > T) {\n\t\t\tMn = min(Mn, f[j] - 2 * p[j + 1]);\n\t\t\t++ j;\n\t\t}\n\t\tif (j < i) f[i] = f[j] + T;\n\t\tf[i] = min(f[i], Mn + 2 * p[i]);\n\t}\n\tcout << f[n] + E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\n\ninline void chk_min(ll &a,ll b){ if(a>b) a=b;}\n\nstruct Queue\n{\n\tint q[MAXN],hd,tl;\n\tQueue(void){ hd=tl=0;}\n\tinline bool empty(void){ return hd>=tl;}\n\tinline int front(void){ return q[hd+1];}\n\tinline int back(void){ return q[tl];}\n\tinline void push(int x){ q[++tl]=x;}\n\tinline void pop(void){ ++hd;}\n}q;\n\nint a[MAXN];\nll dp[MAXN],preMn[MAXN];\n\nint main(void)\n{\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\n\tmemset(dp,0x3f,sizeof(dp));\n\t\n\tdp[1]=t;\n\tq.push(1);\n\tpreMn[1] = dp[1]-2*a[2];\n\tfor(int i=2; i<=n; ++i)\n\t{\n\t\twhile(!q.empty() && (a[i]-a[q.front()+1])*2 > t) q.pop();\n\t\t\n\t\tdp[i]=dp[i-1]+t;\n\t\tchk_min(dp[i], max(t, (a[i]-a[1])*2));\n\t\t\n\t\tif(!q.empty())\n\t\t\tchk_min(dp[i], dp[q.front()]+t),\n\t\t\tchk_min(dp[i], preMn[q.front()-1]+2*a[i]);\n\t\telse chk_min(dp[i], preMn[i-1]+2*a[i]);\n\t\t\n\t\tpreMn[i] = min(preMn[i-1], dp[i]-2*a[i+1]);\n\t\tq.push(i);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint a[100010],q[100010];\nll dp[100010],ma[100010];\n\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tint n,E,T;scanf(\"%d%d%d\",&n,&E,&T);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);a[0]=0;\n\tdp[0]=0;ma[0]=-a[1]*2;int f=1,r=1,k=0;q[1]=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (2*(a[i]-a[k+1])>T)\n\t\t{\n\t\t\tif (q[f]==k) f++;\n\t\t\tk++;\n\t\t}\n\t\tdp[i]=dp[q[f]]+a[q[f]+1]-a[q[f]]+T+a[i]-a[q[f]+1];\n\t\tif (k) dp[i]=min(dp[i],ma[k-1]+ll(a[i])*3);\n\t\tma[i]=min(ma[i-1],dp[i]-a[i]-a[i+1]-a[i+1]);\n\t\twhile (f<=r&&dp[q[r]]-a[q[r]]>=dp[i]-a[i]) r--;\n\t\tq[++r]=i;\n\t}\n\tcout<<dp[n]+E-a[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 100050;\nint x[MAXN];\nll dp[MAXN];\n\nint N, E, T;\nll f(int i,int k) {\n\treturn x[i] + dp[k]-x[k] + max( T, 2*(x[i]-x[k+1]) );\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &x[i]);\n\tdp[0] = 0;\n\tdeque<int> deq;\n\tdeq.PB(0);\n\tfor(int i=1;i<=N;i++) {\n\t\tdp[i]=1ll*(E+T)*MAXN*10;\n\t\twhile(SZ(deq)>1 && f(i, deq[0])>=f(i, deq[1])) deq.pop_front();\n\t\tdp[i]=f(i, deq[0]);\n\t\t//while(SZ(deq)>=1 && f(i, deq.back()>=f(i, i))) deq.pop_back();\n\t\tdeq.PB(i);\n\t\t/*for(int k=0;k<i;k++)\n\t\t\tdp[i]=min(dp[i], x[i] + dp[k]-x[k] + max( T, 2*(x[i]-x[k+1]) ));*/\n\t\tdebug(\"i %d %lld\\n\", i, dp[i]);\n\t}\n\tcout << dp[N] + E-x[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V> v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return LLONG_MAX;\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nll dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,E,T;\n    cin >> n >> E >> T;\n    vl vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    segtree<ll> st(vl(n,0));\n    dp[0] = 0;\n    st.range(0,1,-2*vec[0]);\n    rep(i,n){\n        int id = lower_bound(all(vec),vec[i]-T/2)-vec.begin();\n        if(id == 0){\n            dp[i+1] = dp[id]+T;\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n            // cout << \"OO \" << i+1 << \" \" << dp[i+1]-2*vec[i+1] << \"\\n\";\n            continue;\n        }else if(id <= i){\n            dp[i+1] = dp[id]+T;\n        }\n        cmn(dp[i+1],st.query(0,i)+2*vec[i]);\n        // show(st.query(0,i+1));\n        if(i < n-1){\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n        }\n    }\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << \"\\n\";\n    // }\n    cout << dp[n]+E << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0, cnt = 1000;\n\tdp[1] = A[1] + T;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\t//for(int j = 0; j < i; ++ j)\n\t\twhile(cur + 1 < i && calc(cur, i) >= calc(cur + 1, i)) ++ cur;\n\t\tbool ok = 0;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 1000; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t\telse ok = 1;\n\t\t}\n\t\tif(n >= 1e4 && cnt) {\n\t\t\t-- cnt;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 100000; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t\telse ok = 1;\n\t\t}\t\t\t\n\t\t}\n\t\tdp[i] = min(calc(cur, i), dp[i]);\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DShikAndGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, E, T; cin >> N >> E >> T;\n        vector<ll> X(N+1, 0);\n        for (int i = 0; i < N; ++i) cin >> X[i+1];\n        vector<ll> D(N+1, 1e18);\n        D[0] = E;\n        int j = 0;\n        ll lo = 1e18;\n        for (int i = 1; i <= N; ++i) {\n            while (2*(X[i]-X[j+1]) >= T) { lo = min(lo, D[j] - 2 * X[j+1]); ++j; }\n            if (j != i) D[i] = D[j] + X[i] + T;\n            if (j != 0) D[i] = min(D[i], lo + 3 * X[i]);\n            D[i] -= X[i];\n        }\n\n        cout << D[N] << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDShikAndGame solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2e5;\nll dp[N];\nint dis[N];\nconst ll oo=2e18;\nstruct node{\n\tll v;\n\tint x;\n\tnode(){}\n\tnode(ll vv,int xx){\n\t\tv=vv;x=xx;}\n\tbool operator <(const node &b)const{\n\t\treturn v>b.v;}\n};\npriority_queue<node> Dui;\nint main(){\n\tdp[0]=0;\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&dis[i]);\n\tint l=0;\n\tDui.push(node(dp[0],0));\n\tll nowmin=oo;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\twhile (((dis[i]-dis[l+1])*2)>=t)\n\t\t{\n\t\t\tl++;\n\t\t\tnowmin=min(dp[l-1]-2*dis[l],nowmin);\n\t\t}\n\t//\tprintf(\"%d %d %lld\\n\",i,l,nowmin);\n\t\tdp[i]=nowmin+2*dis[i];\n\t\tif (!Dui.empty())\n\t\t{\n\t\t\tnode P=Dui.top();\n\t\t\twhile (!Dui.empty() && P.x<l)\n\t\t\t{\n\t\t\t\tDui.pop();\n\t\t\t\tP=Dui.top();\n\t\t\t}\t\t\n\t\t\tif (!Dui.empty())\n\t\t\t\tdp[i]=min(dp[i],P.v+t);\n\t\t}\n\t\tDui.push(node(dp[i],i));\n\t}/*\n\tfor (int i=1;i<=n;i++)\n\t\tprintf(\"%lld \",dp[i]);\n\tprintf(\"\\n\");*/\n\tprintf(\"%lld\\n\",e+dp[n]);\n}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=100010;\n\tconst ll INF=214748364700000ll;\n\tstruct Increasing_queue\n\t{\n\t\tll dl[N];\n\t\tint pos[N];\n\t\tint head,tail;\n\t\tvoid init(){head=0,tail=1;}\n\t\tvoid insert(ll x,int p)\n\t\t{\n\t\t\twhile(head>=tail && dl[head]>=x)head--;\n\t\t\tdl[++head]=x;\n\t\t\tpos[head]=p;\n\t\t}\n\t\tvoid del(int p)\n\t\t{\n\t\t\twhile(head>=tail && pos[tail]<=p)tail++;\n\t\t}\n\t\tll query(){return head>=tail?dl[tail]:INF;}\n\t}d;\n\tint a[N],b[N];\n\tll f[N],tmp;\n\tint n,m;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n//\tinline ll calc(int i,int j)\n//\t{\n//\t\tll dis=get_dis(i,j),ret=dis*3+b[j];\n//\t\tret+=std::max(0ll,m-dis*2);\n//\t\treturn ret;\n//\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\td.init(),tmp=INF;\n\t\tf[0]=a[0],d.insert(f[0]-a[0],0);\n\t\tint ind=0;\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(;ind<i && get_dis(ind,i)*2>m;ind++)\n\t\t\t\td.del(ind),check_min(f[ind]-3*a[ind],tmp);\n\n\t\t\tf[i]=d.query()+a[i]+m;\n\t\t\tcheck_min(tmp+3*a[i]-2*b[i],f[i]);\n\n\t\t\td.insert(f[i]-a[i],i);\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]);\n\t}\n}\nint main()\n{\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) f=n; else f=ng[f];\n\t\tfor(int j=max(i+1,beg-5);j<=min(f,beg+9000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node; \npublic:\n    SegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, inf);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    SegmentTree seg1(vector<ll>(N+2,inf)),seg2(vector<ll>(N+2,inf));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.update(0,dp[0]-X[1]);\n    seg2.update(0,dp[0]-3*X[1]);\n    for(int i=1;i<=N;i++){\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        dp[i] = min(dp[i],seg1.getmin(max(id-1,0),i)+T+X[i+1]);\n        if(id>0) dp[i] = min(dp[i],seg2.getmin(0,id-1)+2*X[i]+X[i+1]);\n        seg1.update(i,dp[i]-X[i+1]);\n        seg2.update(i,dp[i]-3*X[i+1]);\n    }\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <climits>\n\nint T;\nint x[100010];\nlong long dp[100010];\n\nlong long val(int i, int j){\n  int d1 = x[j] - x[j - 1];\n  int d2 = 2 * (x[i] - x[j]); if(d2 < T) d2 = T;\n  int d3 = x[i] - x[j];\n\n  return dp[j - 1] + d1 + d2 + d3;\n}\n\nint main(){\n  int N, E; scanf(\"%d%d%d\", &N, &E, &T);\n  for(int i = 1; i <= N; i++) scanf(\"%d\", &x[i]);\n\n  for(int i = 1; i <= N; i++) dp[i] = LLONG_MAX;\n\n  for(int i = 1; i <= N; i++){\n    int rs = 1, re = i;\n    long long res = LLONG_MAX;\n\n    for(;;){\n      if(re - rs < 3){\n        for(int r = rs; r <= re; r++){\n          long long v = val(i, r);\n          if(v < res) res = v;\n        }\n        break;\n      }\n\n      int r1 = (rs * 2 + re) / 3, r2 = (rs + re * 2) / 3;\n      long long v1 = val(i, r1), v2 = val(i, r2);\n\n      if(v1 < v2){ res = v1; re = r2; }\n      else{ res = v2; rs = r1; }\n    }\n\n    dp[i] = res;\n  }\n\n  printf(\"%lld\\n\", dp[N] + E - x[N]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef DEBUG\n    #define debug(...) printf(__VA_ARGS__)\n#else\n    #define debug(...) (void)0\n#endif\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define pii pair<int,int>\n#define PII pair<long long, long long>\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconst int inf = 0x7fffffff; //beware overflow\nconst LL INF = 0x7fffffffffffffff; //beware overflow\n#define mem(x, y) memset(x, (y), sizeof(x) );\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\ntemplate<typename A, typename B>\nostream& operator <<(ostream &s, const pair<A,B> &p) {\n     return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n}\ntemplate<typename T>\nostream& operator <<(ostream &s, const vector<T> &c) {\n    s << \"[ \";\n    for (auto it : c) s << it << \" \";\n    s << \"]\";\n    return s;\n}\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    o << \"{\";\n    for (auto it=st.begin(); it!=st.end(); it++) o << (it==st.begin() ? \"\" : \", \") << *it;\n    return o << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << \"{\";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?\"\":\", \") << it->fi << \":\" << it->se;\n    }\n    o << \"}\";\n    return o;\n}\ninline LL getint(){\n   LL _x=0,_tmp=1; char _tc=getchar();\n   while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n   if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n   while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n   return _x*_tmp;\n}\n#define maxn 100005\nLL dp[maxn];int x[maxn];\nint main() {\n    int n = getint();\n    int e = getint();\n    int T = getint();\n\n    x[0] = 0;\n    for(int i=1;i<=n;i++) x[i]=getint();\n    dp[0] = 0;\n    for(int i=1;i<=n;i++) {\n        //fill dp[i]\n        LL mn = dp[i-1] + x[i]-x[i-1] + T;\n\n        for(int j=0;j<i-1;j++) {\n            LL cans = dp[j] + x[j+1]-x[j] + max( (x[i]-x[j+1])*2, T) + x[i]-x[j+1] ;\n            mn = min(mn, cans);\n        }\n        debug(\"%lld\\n\", mn);\n        dp[i] = mn;\n    }\n    cout << 1LL*e-x[n] + dp[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\t//freopen(\"i.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long n, e, t;\n\tcin >> n >> e >> t;\n\t\n\tlong long arr[n+2];\n\tfor(int i = 1;i <= n;i++) cin >> arr[i];\n\tarr[0] = 0;\n\tlong long far[n+2];\n\tlong long dp[n+2];\n\tmultiset<long long> close;\n\tdp[0] = 0;\n\tfar[0] = -2 * arr[1];\n\tclose.insert(0);\n\t\n\tint c = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\t///from c onwards, add t, before c, add 2 * (arr[i] - arr[j+1]);\n\t\twhile(2 * (arr[i] - arr[c+1]) > t){\n\t\t\tclose.erase(close.find(dp[c] - arr[c]));\n\t\t\tc++;\n\t\t}\n\t\t\n\t\tdp[i] = 10234567890123242;\n\t\tif(c != 0){\n\t\t\tdp[i] = min(dp[i], far[c-1] + 3 * arr[i]);\n\t\t}\n\t\tif(!close.empty()){\n\t\t\tlong long v = *(close.begin());\n\t\t\t//cout << i << \" \" << v << \"\\n\";\n\t\t\tdp[i] = min(dp[i], v + t + arr[i]);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfar[i] = dp[i] - 2 * arr[i+1] - arr[i];\n\t\tfar[i] = min(far[i],far[i-1]);\n\t\tclose.insert(dp[i] - arr[i]);\n\t}\n\t\n\t//for(int i = 1;i <= n;i++) cout << dp[i] << \" \";\n\t\n\tcout << dp[n] + (e-arr[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+20];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+20];\n\tint x[100000+20];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>=T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n\t\tif(i==N) break;\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3)/3,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3);\n\t}\n\tif(dp[N]+E-x[N]<0){\n\t\twhile(1);\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\t//freopen(\"i.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long n, e, t;\n\tcin >> n >> e >> t;\n\t\n\tlong long arr[n+2];\n\tfor(int i = 1;i <= n;i++) cin >> arr[i];\n\tarr[0] = 0;\n\tlong long far[n+2];\n\tlong long dp[n+2];\n\tmultiset<long long> close;\n\tdp[0] = 0;\n\tfar[0] = -2 * arr[1];\n\tclose.insert(0);\n\t\n\tint c = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\t///from c onwards, add t, before c, add 2 * (arr[i] - arr[j+1]);\n\t\twhile(2 * (arr[i] - arr[c+1]) > t){\n\t\t\tclose.erase(dp[c] - arr[c]);\n\t\t\tc++;\n\t\t}\n\t\t\n\t\tdp[i] = 10234567890123242;\n\t\tif(c != 0){\n\t\t\tdp[i] = min(dp[i], far[c-1] + 3 * arr[i]);\n\t\t}\n\t\tif(!close.empty()){\n\t\t\tlong long v = *(close.begin());\n\t\t\tdp[i] = min(dp[i], v + t + arr[i]);\n\t\t}\n\t\t\n\t\tfar[i] = dp[i] - 2 * arr[i+1] - arr[i];\n\t\tfar[i] = min(far[i],far[i-1]);\n\t\tclose.insert(dp[i] - arr[i]);\n\t}\n\t\t\n\tcout << dp[n] + (e-arr[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nint x[2002];\nint rem[2002];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i;\n\tfor(i=0;i<n;i++) scanf(\"%d\",&x[i]);\n\tsort(x,x+n);\n\tLL ans=0;\n\tint cur=0;\n\t//\n\tbool ok=false;\n\twhile(!ok){\n\t\tans+=cur?(x[cur]-x[cur-1]):x[cur];\n\t\tfor(i=cur;i<n && x[i]-x[cur]<t;i++);\n\t\tint j=i-1;\n\t\t//printf(\"%d\\n\",j);\n\t\tif(j==n-1) ok=true;\n\t\tans+=2*(x[j]-x[cur]);\n\t\tfor(i=cur;i<=j;i++) rem[i]=t-(2*(x[j]-x[cur]))+(x[i]-x[cur]);\n\t\tint add=0;\n\t\tfor(i=cur;i<=j;i++){\n\t\t\trem[i]-=add;\n\t\t\tif(rem[i]>0) ans+=rem[i];\n\t\t\tif(i+1<=j) ans+=x[i+1]-x[i];\n\t\t\tadd+=x[i+1]-x[i];\n\t\t}\n\t\t//printf(\"%d %lld\\n\",cur,ans);\n\t\tcur=j+1;\n\t}\n\tif(x[n-1]<e) ans+=e-x[n-1];\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register ll i=(a);i<=(b);i++)\n#define For(i,a,b) for (register ll i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+5;\nll n,E,T,x[N],f[N],Ans,k=1e18;\nll l=1,r=1,q[N];\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\nint main()\n{\n\tmem(f,0x3f);\n\tn=read(),E=read(),T=read();\n\tFOR(i,1,n) x[i]=read();\n\tf[0]=0;\n\tFOR(i,1,n)\n\t{\n\t\twhile (l<=r&&2*(x[i]-x[q[l]+1])>T)\n\t\t{\n\t\t\tk=min(k,f[q[l]]-2*x[q[l]+1]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[i],f[q[l]]+T);\n\t\tf[i]=min(f[i],k+2*x[i]);\n\t\tq[++r]=i;\n\t}\n\tAns=f[n]+E;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tf[i] = max(2 * (d[i] - d[1]),t);\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\twhile (2 * (d[i] - d[pp + 1]) > t) {\n\t\t\tf[i] = min(f[i],f[pp] + 2 * (d[i] - d[pp + 1]));\n\t\t\tpp++;\n\t\t}\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\tif (f[pp] + t < f[i]) f[i] = f[pp] + t;\n\t\tif (pp > 0) pp--;\n\t\tif (pp > 0) pp--;\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n\t}\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DIF(i) pos[i]-pos[i-1]\nusing namespace std;\nlong long dp[200005],n,e,t,pos[200005];\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&pos[i]);\n\tdp[0]=0;\n\tdp[1]=(long long)1e18;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=min(dp[i-1]+DIF(i)+t,dp[i]);\n\t\tdp[i+1]=dp[i-1]+DIF(i)+DIF(i+1)+max(t,(DIF(i+1))*2);\n\t}\n\t//for(int i=1;i<=n;i++)printf(\"%lld\\n\",dp[i]);\n\tprintf(\"%lld\",dp[n]+e-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n          #define int long long\n            #define inf  1000000007\n            #define pa pair<int,int>\n    #define ll long long\n            #define pal pair<ll,ll>\n            #define ppa pair<int,pa>\n            #define  mp make_pair\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     \n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \n            //----------------kokomade temple------------\nint n,e,t;\nint x[200020];\nint dp[200010]={0};\nint dp2[200010]={0};\nint mod=100000000000000000ll;\nint z[200021];\n    signed main(){\n    \tcin>>n>>e>>t;\n    \t\n    \tfor(int i=1;i<=n;i++) cin>>x[i];\n    dp[0]=0;\n    \tdp2[0]=-2*x[1];\n    \tx[0]=-mod;\n\n    \tint d=0;\n    \tfor(int i=1;i<=n;i++){\n    \t\twhile(2*x[i]-2*x[d+1]>t)d++;\n    \t\tz[i]=d;\n    //\t\tcout<<\"z\"<<i<<\" \"<<z[i]<<endl;\n    \t}\n    \t\n    \tfor(int i=1;i<=n;i++){\n    \t\tint u=dp[z[i]]+t;\n    \t\tif(z[i]>0)\tu=min(u, dp2[z[i]-1]+2*x[i] );\n    \t\tdp[i]=u;\n    //\t\tcout<<\"dp\"<<i<<\" \"<<dp[i]<<endl;\n    \t\t\tdp2[i]=min(dp2[i-1],dp[i]-2*x[i+1]);\n    \t}\n    \t\n    \t\n    \tcout<<dp[n]+e<<endl;\n    \t\n    \t\t\treturn 0;\n    \t\n    //\tprintf(\"%.10f\\n\",ans);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\ntemplate<class V, int NV> class SegTree {\npublic:\n\tstatic V const def = -(1LL << 60);\n\tV comp(V l, V r) { return max(l, r); };\n\n\tvector<V> val;\n\tSegTree() { val = vector<V>(NV * 2, def); }\n\n\tV getval(int l, int r) { //[l,r]\n\t\tl += NV; r += NV + 1;\n\t\tV ret = def;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) ret = comp(ret, val[l++]);\n\t\t\tif (r & 1) ret = comp(ret, val[--r]);\n\t\t\tl /= 2; r /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV;\n\t\tval[i] = v;\n\t\twhile (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n};\n//-----------------------------------------------------------------\nint N;\nll E, T;\nll X[101010];\nll Y[101010];\nll YY[101010];\nll dp[101010][2];\nSegTree<ll, 1 << 20> st;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\tY[0] = X[0];\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\tst.update(0, dp[0][0] - YY[0] * 3);\n\trep(i, 1, N) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\tdp[i][1] = min(dp[i][1], YY[i] * 3 + st.getval(0, i - 1));\n\t\tst.update(i, dp[i][0] - YY[i] * 3);\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N - 1][1] + Y[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\nll BN(ll key){\n    ll l=-1,r=n,m=(l+r)/2;\n    for(;l<r-1;m=(l+r)/2){\n\tif(d[m+1]*2<key)l=m;\n\telse r=m;\n    }\n    return l;\n}\nll f[N],g[N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    lol(i,n)cin>>d[i+1];\n    lol(i,N)f[i]=1e18; f[0]=0,g[0]=-2*d[1];\n    for(ll i=1;i<=n;i++){\n\tll surf=BN(d[i]*2-t);\n\tll res=1e17;\n\tif(surf+1<i)chmin(res,f[surf+1]+t);\n\tif(~surf)chmin(res,g[surf]+2*d[i]);\n\tf[i]=res;\n\tg[i]=min(g[i-1],f[i]-2*d[i+1]);\n    }\n    cout<<f[n]+e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\ni64 E, T;\ni64 X[101010];\ni64 dp[101010];\ni64 adp[101010];\nint main()\n{\n\tscanf(\"%d%lld%lld\", &N, &E, &T);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", X + i);\n\n\ti64 ret = 0;\n\tdp[0] = adp[0] = -2 * X[1];\n\tfor (int i = 1; i <= N; ++i) {\n\t\tdp[i] = 1LL << 60LL;\n\n\t\tint left = 1, right = i;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif (2 * (X[i] - X[mid]) > T) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\n\t\tdp[i] = min(dp[i], dp[left - 1] + 2 * X[left] + T);\n\t\tif (left - 2 >= 0) dp[i] = min(dp[i], 2 * X[i] + adp[left - 2]);\n\n\t//\tprintf(\"%d: %lld\\n\", i, dp[i]);\n\t\tif (i != N) {\n\t\t\tdp[i] -= 2 * X[i + 1];\n\t\t}\n\t\tadp[i] = min(adp[i - 1], dp[i]);\n\t}\n\n\tret = dp[N];\n\tret += E;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n + 10, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint l = 0;\n\tvi p(n + 1);\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\tvl dp(n + 10, INF);\n\tdp[0] = e;\n\tvl dp2(n + 10, INF);\n\tdp2[0] = INF; dp2[1] = INF; dp2[2] = e-2*x[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tdp[i] = dp[max(0,p[i]-1)] + t;\n\t\t/*for (int j = 0; j+1<p[i]; j++) {\n\t\t\tmi = min(mi, dp[j] -2 *  x[j + 1]);\n\t\t}*/\n\t\tmi = dp2[p[i]];\n\t\tdp[i] = min(dp[i],mi+2*x[i]);\n\t\tdp2[i + 2] = min(dp[i + 1], dp[i] - 2 * x[i + 1]);\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, E, T, r;\nint a[maxn];\nll Min1, Min2 = 1e18, f[maxn];\nint main()\n{\n\tdeque<ll> Q; \n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tQ.push_back(0);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\twhile((a[i] - a[r + 1]) * 2 >= T)\n\t\t{\n\t\t\tMin2 = min(Min2, f[r] - 2 * a[r + 1]);\n\t\t\tif(Q.front() <= r) Q.pop_front();\n\t\t\t++r;\n\t\t}\n\t\tf[i] = min(Min1 + 1ll * i * T, Min2 + 2 * a[i]);\n\t\tif(!Q.empty()) f[i] = min(f[i], f[Q.front()] + T);\n\t\tMin1 = min(Min1, f[i] - 1ll * i * T);\n\t\twhile(!Q.empty() && f[i] <= f[Q.back()]) Q.pop_back();\n\t\tQ.push_back(i);\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n    #include <iostream>\n    #include <algorithm>\n    #include <cstring>\n    #include <set>\n    #define N 100010\n    #define INF (1LL << 60)\n    #define LL long long\n    using namespace std;\n    int n, e, t, x[N];\n    LL dp[N], preMin[N];\n    multiset<LL> st;\n     \n    int main() {\n    \tscanf(\"%d%d%d\", &n, &e, &t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\tscanf(\"%d\", &x[i]);\n    \t}\n    \t\n    \tdp[0] = 0;\n    \tx[0] = 0;\n    \tint last = 0;\n    \tpreMin[0] = - 2 * x[1];\n    \tst.insert(t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n    \t\t\tst.erase(st.find(dp[last] - x[last] + t));\n    \t\t\t++last;\n    \t\t}\n\t\t\tdp[i] = (((LL)1)<<50);\n\t\t\tif(last - 1 >= 0) dp[i] = min(dp[i], preMin[last - 1] + 3LL * x[i]);\n\t\t\tif(!st.empty()) dp[i] = min(dp[i], *st.begin() + x[i]);\n    \t\t//if (last - 1 >= 0) dp[i] = min(preMin[last - 1] + 3LL * x[i], *st.begin() + x[i]);\n    \t\t//else dp[i] = *st.begin() + x[i];\n    //cout << last << ' ' << preMin[last - 1] << ' ' << *st.begin() << ' ' << dp[i] << endl;\n    \t\tif (i < n) st.insert(dp[i] - x[i] + t);\n    \t\tpreMin[i] = min(dp[i] - x[i] - 2LL * x[i + 1], preMin[i - 1]);\n    //cout << dp[i] << ' ';\n    \t}\n    //cout << endl;\n    \t\n    \tprintf(\"%lld\\n\", dp[n] + e - x[n]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 1e5 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long t, n, a[N], mn, dp[N], e, en, ps[N];\n\nvoid upd (int x) {\n    if (!mn)\n        mn = x;\n    long long ghabli = 2 * a[mn] + a[mn + 1] + dp[mn + 1];\n    long long jadid = 2 * a[x] + a[x + 1] + dp[x + 1];\n    if (jadid < ghabli)\n        mn = x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    en = n;\n    a[n + 1] = e;\n    for (int i = n; i; i--) {\n        while (2 * (a[en] - a[i]) > t) {\n            upd (en);\n            en--;\n        }\n        // ta en berim va bargardim\n        dp[i] = t + a[en + 1] - a[i] + dp[en + 1];\n        // ta min berim va bargardim\n        if (mn)\n            dp[i] = min (dp[i], 2 * a[mn] + a[mn + 1] + dp[mn + 1] - 3 * a[i]);\n    }\n    cout << dp[1] + a[1] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define FF first\n#define SS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\n\nint n, T, L;\nint a[MAXN];\nLL dp[MAXN];\nPLI q[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d%d%d\", &n, &L, &T );\n\tlpi ( i, 1, n ) scanf ( \"%d\", &a[i] );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tdp[0] = 0;\n\tint l = 1, r = 0;\n\tint nl = 0;\n\tLL vl = LINF;\n\tq[++r] = MP ( dp[0], 0 );\n\tlpi ( i, 1, n ){\n\t\twhile ( ( ( a[i] - a[nl+1] ) << 1 ) > T ){\n\t\t\tvl = min ( vl, dp[nl] - ( a[nl+1] << 1 ) );\n\t\t\t++nl;\n\t\t}\n\t\twhile ( l <= r && ( ( a[i] - a[q[l].SS+1] ) << 1 ) > T ) ++l;\n\t\tdp[i] = min ( vl + ( a[i] << 1 ), ( l <= r ) ? ( q[l].FF + T ) : LINF );\n\t\twhile ( l <= r && ( q[r].FF >= dp[i] ) ) --r;\n\t\tq[++r] = MP ( dp[i], i );\n\t}\n\t\n//\tlpi ( i, 1, n ) cerr << dp[i] << \" \"; cerr << endl;\n\t\n\tcout << dp[n] + L << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\ntypedef long long ll;\nint n, e, t;\nll x[100005];\nll f[100005];\nll mf[100005];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &e, &t);\n    FO(i,0,n) scanf(\"%lld\", x+i);\n    x[n] = e;\n\n    f[n] = 0;\n    mf[n] = 1ll<<60;\n    for (int i = n-1; i >= 0; i--) {\n        f[i] = 1ll<<60;\n        int s = i, _e = n-1, b = i;\n        while (s <= _e) {\n            int m = (s+_e)/2;\n            if (2*(x[m]-x[i]) <= t) {\n                b = m;\n                s = m+1;\n            } else {\n                _e = m-1;\n            }\n        }\n        f[i] = min(f[i], f[b+1] + t+x[b+1]-x[i]);\n        f[i] = min(f[i], mf[b+1] - 3*x[i]);\n        mf[i] = min(mf[i+1], f[i+1] + 2*x[i]+x[i+1]);\n    }\n    printf(\"%lld\\n\", x[0]+f[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nint main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[2002];\n\tint x[2002];\n\trb(i,1,N)\n\t\tcin>>x[i];\n//\tdp[0]\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n//\tcout<<dp[1]<<endl;\n\trb(i,2,N){\n\t\trb(k,0,i-1){\n\t\t\tint j=k+1;\n\t\t\tdp[i]=min(dp[i],dp[k]+x[j]-x[k]+max(T,(x[i]-x[j])*2)+x[i]-x[j]);\n\t\t}\n//\t\tcout<<dp[i]<<endl;\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define dump(a) cerr<<#a <<' '<< a <<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    VLL dp(n+1,LINF),x(n+1);\n    REP(i,n) cin >> x[i+1];\n    dp[0]=0;\n    dp[1]=t;\n    int l=0;\n    LL r=0;\n    FOR(i,2,n+1){\n        dp[i]=dp[l]+(x[i]-x[l+1])*2;\n        /*for(int j= l; j<i ; ++j){\n            if(dp[i]>dp[j]+max((LL)t,(x[i]-x[j+1])*2)){\n                dp[i]=min(dp[i],dp[j]+max((LL)t,(x[i]-x[j+1])*2));\n                l=j;\n            }\n            if(t>(x[i]-x[j+1])*2){\n                break;\n            }\n        }*/\n        for(int j=r ; j<i ; ++j){\n            r=j;\n            if(t>(x[i]-x[j+1])*2){\n                dp[i]=min(dp[i],dp[j]+t);\n                break;\n            }\n        }\n        if(dp[l]+(x[i]-x[l+1])*2>dp[i-1]) l=i-1;\n    }\n    cout << dp[n]+e<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto &\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\nlint x[100020];\n\nlint dp[2020];\n\nlint brute(){\n    rep(i, n+1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    for(int i = 0; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            lint d = x[j] - x[i+1];\n            if(2*d >= t) {\n                chmin(dp[j], dp[i] + (x[i+1] - x[i]) + max<lint>(t, d * 3));\n            } else {\n                chmin(dp[j], dp[i] + (x[i+1] - x[i]) + t + d);\n            }\n        }\n    }\n    return dp[n] + (e - x[n]);\n}\n\nint main() {\n    cin >> n >> e >> t;\n    rep(i, n) cin >> x[i+1];\n\n    if(n > 2020) exit(1);\n\n    cout << brute() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t;\nint x[100005];\nll dp[100005];\nint main(){\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++){\n        /*dp[i] = 1000000000000000000;\n        while (pivot < i && 2*(x[i]-x[pivot+1]) < t) {\n            if (pivot >= 1) mn = min(mn,dp[pivot-1]-2*x[pivot]);\n            pivot++;\n        }\n        printf(\"pivot for %d = %d\\n\",i,pivot);\n        dp[i] = min(2*x[i]+mn,dp[pivot-1]+t);\n        printf(\"%lld first\\n\",dp[i]);*/\n        dp[i] = 1000000000000000000;\n        for (int j = 0; j < i; j++){\n            //printf(\"%lld + %d\\n\",dp[j],max(t,(x[i]-x[j+1])*2));\n            dp[i] = min(dp[i],dp[j]+max(t,(x[i]-x[j+1])*2));\n        }\n        //printf(\"%lld second\\n\",dp[i]);\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pr pair<int,int>\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#ifdef DEBUG\n    #define GG(x) assert(x)\n#else\n    #define GG(x) (x)\n#endif\nnamespace mine\n{\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e>=0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e5+10;\n\n    ll f[N],a[N];\n    void main()\n\t{\n        ll n=qread(),E=qread(),T=qread();fo(i,1,n) a[i]=qread();a[n+1]=E;\n        if(n>=2000) return;\n        memset(f,0x3f,sizeof f);f[0]=0;\n        fo(i,1,n)\n        {\n            int jj=lower_bound(a,a+i+1,a[i]-T/2)-a;\n            fo(j,0,i-1)\n                chmin(f[i],f[j]+max(T,2*(a[i]-a[j+1])));\n        }\n        write(f[n]+E);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\n\tll dp1 = T;\n\n\tif(opt - 1 >= 0)\n\t\tdp1 += dp[opt - 1];\n\n\tll dp2 = a[idx] * 2;\n\n\tif(opt - 1 >= 0)\n\t\tdp2 += min(dpRMQ[opt - 1] , 0LL);\n\telse\n\t\treturn dp1;\n\treturn(min(dp1 , dp2));\n\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = - a[0] * 2;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tdpRMQ[i] = min(dpRMQ[i - 1] , dp[i - 1] - a[i] * 2);\n\t\tdp[i] = findDp(i);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nconst int INF = 2e18;\n\nint N, E, T;\nint x[100010];\n\nint dp[2010]; // dp[i] = i番目まで(inclusiv)を全て回収するのにかかるコスト\n\nsigned main(){\n    while(cin >> N >> E >> T){\n        rep(i,2010) dp[i] = INF;\n        rep(i,N) cin >> x[i];\n        x[N] = E;\n\n        dp[0] = 0;\n        rep(i,N){\n            int premove = x[i] - (i == 0 ? 0 : x[i-1]);\n            // dump(premove);\n            for(int j = i; j < N; ++j){\n                int dist = x[j] - x[i];\n                int cost = max(T, dist*2) + dist;\n                dp[j+1] = min(dp[j+1], dp[i] + premove + cost);\n            }\n        }\n\n        // rep(i,N+1){\n        //     dump(dp[i]);\n        // }\n        \n        cout << dp[N] + E - x[N-1] << endl;\n\n        // ll cur = 0;\n        // ll ans = x[0];\n        // while(cur < N){\n        //     dump(cur);\n        //     dump(ans);\n        //     int lb = cur;\n        //     int ub = N;\n        //     // if(ok(cur, E)){\n        //     //     ans += T;\n        //     //     ans += E - x[cur];\n        //     // }\n        //     while(lb + 1 < ub){\n        //         int mid = (lb + ub) / 2;\n        //         // src -> dst -> src\n        //         bool ok = 2*(x[mid] - x[cur]) <= T;\n        //         if(ok){\n        //             lb = mid;\n        //         } else {\n        //             ub = mid;\n        //         }\n        //     }\n        //     dump(ub);\n        //     dump(T);\n        //     dump(x[ub] - x[cur]);\n        //     ans += T;\n        //     ans += x[ub] - x[cur];\n        //     cur = ub;\n        // }\n\n        // cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 1000 * 1000 + 47;\n\nint n, e, t;\nint X[MAX];\nLL dp[MAX];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> X[i];\n\t}\n\n\tFOR(i, 0, n + 1) dp[i] = INF;\n\tdp[0] = 0;\n\tint p = 0;\n\tLL minn = LINF;\n\n\tif (X[0] > t)\n\t{\n\t\tp++;\n\t\tminn = 0;\n\t}\n\n\tFOR(i, 1, n + 1)\n\t{\n\t\twhile (2 * (X[i - 1] - X[p]) > t)\n\t\t{\n\t\t\tminn = min(dp[p] - 2 * X[p], minn);\n\t\t\tp++;\n\t\t}\n\n\t\tdp[i] = minn + 2 * X[i - 1];\n\t\tdp[i] = min(dp[i], dp[p] + t);\n\t}\n\n\tcout << dp[n] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 1e5 + 100;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n;\nll T, E, x[maxn], dp[maxn], seg[4 * maxn], lazy[4 * maxn];\n\ninline void pushDown(int u, int l, int r)\n{\n\tif (r - l > 1)\n\t{\n\t\tseg[2 * u] += lazy[u];\n\t\tseg[2 * u + 1] += lazy[u];\n\t\tlazy[2 * u] += lazy[u];\n\t\tlazy[2 * u + 1] += lazy[u];\n\t}\n\tlazy[u] = 0;\n}\n\nvoid update(int u, int l, int r, int b, int e, ll val)\n{\n\tif (lazy[u])\n\t\tpushDown(u, l, r);\n\tif (b <= l && r <= e)\n\t{\n\t\tseg[u] += val;\n\t\tlazy[u] += val;\n\t\tpushDown(u, l, r);\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (b < mid)\n\t\tupdate(2 * u, l, mid, b, e, val);\n\tif (e > mid)\n\t\tupdate(2 * u + 1, mid, r, b, e, val);\n\tseg[u] = min(seg[2 * u], seg[2 * u + 1]);\n}\n\nvoid updateSet(int u, int l, int r, int x, ll val)\n{\n\tif (lazy[u])\n\t\tpushDown(u, l, r);\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdateSet(2 * u, l, mid, x, val);\n\telse\n\t\tupdateSet(2 * u + 1, mid, r, x, val);\n\tseg[u] = min(seg[2 * u], seg[2 * u + 1]);\n}\n\nll query(int u, int l, int r, int b, int e)\n{\n\tif (lazy[u])\n\t\tpushDown(u, l, r);\n\tif (b <= l && r <= e)\n\t{\n\t\t//cerr << \"QUERY \" << l << ' ' << r << ':' << seg[u] << endl;\n\t\treturn seg[u];\n\t}\n\tint mid = (l + r) / 2;\n\tll res = inf;\n\tif (b < mid)\n\t\tres = min(res, query(2 * u, l, mid, b, e));\n\tif (e > mid)\n\t\tres = min(res, query(2 * u + 1, mid, r, b, e));\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tfill(seg, seg + 4 * maxn, inf);\n\n\tcin >> n >> E >> T;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\tint pos = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (pos)\n\t\t\tupdate(1, 0, n + 2, 0, pos + 1, 2 * (x[i] - x[i - 1]));\n\t\tupdateSet(1, 0, n + 2, i + 1, T + dp[i]);\n\t\twhile (2 * (x[i] - x[pos]) >= T)\n\t\t{\n\t\t\tupdateSet(1, 0, n + 2, pos + 1, 2 * (x[i] - x[pos]) + dp[pos]);\n\t\t\tpos++;\n\t\t}\n\t\t//cerr << \"___________ \" << i + 1 << endl;\n\t\tdp[i + 1] = query(1, 0, n + 2, 0, i + 2);\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tcerr << '_' << dp[i];\n\tcerr << endl;\n\tcout << dp[n] + E << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    //if(n > 2000) return 1;\n   // sort(x, x + n + 1);\n    for(int i = 0; i < n; i++){\n        int *p = lower_bound(x + i, x + n + 1, x[i + 1] + t / 2 + 1);\n        p--;\n        if(p <= x + i) p = x + i + 1;\n        for(int j = p - x; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << e - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int dp[100010];\n\nint x[100010];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i];\n\tlong long int trans = 1e18;\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t\tdp[i]=1e18;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(p+1<=i&&(x[i]-x[p+1])*2>=t)\n\t\t\ttrans=min(trans,dp[p]-2*x[p+1]),p++;\n\t\tdp[i]=min(x[i]*2+trans,dp[i]);\n\t\tif(p!=i)\n\t\t\tdp[i]=min(dp[i],t+dp[p]);\n\t}\n\tcout<<dp[n]+e<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600123456789\n\nint main(){\n  long n,e,t;\n  cin>>n>>e>>t;\n  vector<long> vec(n+1);\n  vec[0]=0;\n  rep(i,n) scanf(\"%ld\", &vec[i+1]);\n\n  long res=0;\n  int last=0; //どこまでとったか\n  repl(i,1,n){\n    long d1 = vec[i]-vec[last+1];\n    long d2 = vec[i+1]-vec[last+1];\n    if(t >= 2*d1 && t <= 2*d2){\n      if(t-2*d1 >= 2*d2-t){\n        res += 2*d2;\n        last = i+1;\n        i++;\n      } else {\n        res += t;\n        last = i;\n      }\n    }\n  }\n  if(last != n) res += max(t-2*(vec[n]-vec[last+1]), 0L) + 2*(vec[n]-vec[last+1]);\n  res += e;\n  cout << res << endl;\n\n/*\n  if(n>2000){ cout<<-1<<endl; return 0; }\n  vector<vector<long> > dp(n+1, vector<long>(n+1, INF));\n  dp[0][0]=0;\n  rep(j,n+1) repl(i,j,n+1) if(dp[i][j]!=INF){\n    // すすむ\n    if(i<n && dp[i][j] + vec[i+1] - vec[i] < dp[i+1][j]){\n      dp[i+1][j] = dp[i][j] + vec[i+1] - vec[i];\n    }\n    // もどる\n    if(i>0 && i!=j){\n      long tim = max(t-2*(vec[i]-vec[j+1]), 0L) + 2*(vec[i]-vec[j+1]) + dp[i][j];\n      if(tim < dp[i][i]){\n        dp[i][i] = tim;\n      }\n    }\n  }\n//  rep(i,n+1) {rep(j,n+1) cout<<dp[i][j]<<\" \"; cout<<endl;}\n\n  cout<< dp[n][n] + e-vec[n] << endl;\n*/\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint main(){\n\tll n, e, t; cin>>n>>e>>t;\n\tll a[n];\n\tfor(int i = 0; i < n; i++) cin>>a[i];\n\tll dp[n+1]; dp[n] = 0;\n\tfor(int i = n-1; i >= 0; i--){\n\t\tdp[i] = dp[i+1] + t;\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tdp[i] = min(dp[i], dp[j+1] + max(2*(a[j]-a[i]), t));\n\t\t}\n\t}\n\tcout<<dp[0] + e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, E, T, x[100009];\nlong long dp[100009], INF = 1LL << 50;\nmultiset < long long > S1, S2;\n\nvoid push (int lin, long long val)\n{\n    if (lin == 1) S1.insert (val);\n    else S2.insert (val);\n}\n\nvoid pop (int lin, long long val)\n{\n    if (lin == 1) S1.erase (S1.find (val));\n    else S2.erase (S2.find (val));\n}\n\nlong long getVal (int lin, int k)\n{\n    if (lin == 1) return (long long) dp[k - 1] - x[k] - x[k] - x[k - 1];\n    return (long long) dp[k - 1] - x[k - 1] + T;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &E, &T);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nint k = 1;\nfor (int i=1; i<=N; i++)\n{\n    while (2 * (x[i] - x[k]) >= T)\n    {\n        push (1, getVal (1, k));\n        pop (2, getVal (2, k));\n        k ++;\n    }\n    push (2, getVal (2, i));\n    ///pe [1, k - 1] am dp[k - 1] - x[k] - x[k] - x[k - 1]     +3x[i]\n    ///pe [k, i] am dp[k - 1] - x[k - 1] + T    +x[i]\n    long long val1 = INF, val2 = INF;\n    if (!S1.empty ()) val1 = (*S1.begin ()) + 3LL * x[i];\n    if (!S2.empty ()) val2 = (*S2.begin ()) + x[i];\n    dp[i] = min (val1, val2);\n}\nprintf (\"%lld\\n\", dp[N] + E - x[N]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N, E, T;\nint x[110000], dp[110000];\nsigned main() {\n    cin >> N >> E >> T;\n    for (int i = 0; i < N; i++)cin >> x[i];\n    x[N] = E;\n    dp[N] = 0;\n    int rmin = 1e14;\n    int lidx = N;\n    for (int i = N - 1; i >= 0; i--) {\n        rmin += 2 * (x[i + 1] - x[i]);\n        while (T < 2 * (x[lidx - 1] - x[i]))rmin = min(rmin, dp[lidx] + 2 * (x[lidx - 1] - x[i])), lidx--;\n        dp[i] = min(rmin, dp[lidx] + T);\n    }\n    cout << E + dp[0] << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\n\nll f[N][N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    if(n>N)return 0;\n    lol(i,n)cin>>d[i+1];\n    lol(i,N)lol(j,N)f[i][j]=1e17; f[1][0]=0;\n    lol(i,n+1){\n\tlol(j,i+1){\n\t    if(i>j){\n\t\tchmin(f[i+1][j],f[i][j]+d[i+1]-d[i]);\n\t\tll dis=d[i]-d[j+1];\n\t\tchmin(f[i+1][i],f[i][j]+max(dis,t-dis));\n\t    }\n\t    //cout<<f[i][j]<<\" \";\n\t}//cout<<endl;\n    }\n    cout<<e+f[n+1][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    assert(N <= 2000);\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1,1e18);\n    dp[0] = 0;\n    auto calc=[&](int i, int j) {\n        return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2);\n    };\n    vector<int> rev(N+1);\n    int cur = 0;\n    for (int i = 1; i <= N; i++) {\n        //while (cur < i-1 and calc(i,cur) >= calc(i,cur+1)) cur++;\n        //dp[i] = calc(i,cur);\n        rep(j,i) {\n            if (chmin(dp[i],calc(i,j))) rev[i] = j+1;\n        }\n    }\n    // for (int i = 1; i <= N; i++) {\n    //     cout << i << \" \";\n    // }\n    // cout << ln;\n    // for (int i = 1; i <= N; i++) {\n    //     cout << rev[i] << \" \";\n    // }\n    // cout << ln;\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Daniel Grzegorzewski\n#include <bits/stdc++.h>\n\n#define MP make_pair\n#define PB push_back\n#define ST first\n#define ND second\n#define int long long\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef long long LL;\n\nvoid init_ios()\n{\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n}\n\nconst int N = (int)1e5 + 10;\n\nint n, e, t;\nint x[N], dp[N];\n\nsigned main()\n{\n    init_ios();\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++i)\n    \tcin >> x[i];\n    dp[n] = t+e-x[n];\n    for (int i = n-1; i >= 1; --i) {\n    \tdp[i] = 1e18;\n    \tfor (int j = i; j <= n; ++j) {\n    \t\tint tmp = max(t, 2*(x[j]-x[i]))+(x[j]-x[i]);\n    \t\tif (j < n)\n    \t\t\ttmp += x[j+1]-x[j]+dp[j+1];\n    \t\telse\n    \t\t\ttmp += e-x[n];\n    \t\tdp[i] = min(dp[i], tmp);\n    \t}\n    }\n    cout<<x[1]+dp[1]<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int inf = 0x3f3f3f3f3f3f3f3f;\nconst int N = 100000;\n\nint n, m, s;\nint a[N + 1];\nint dp[N + 1];\nint q[N], head, tail;\n\n#undef int\nsigned main() {\n#define int long long\n  cin >> n >> m >> s;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  q[tail++] = 0;\n  int now = -1, mn = inf;\n  for (int i = 1; i <= n; i++) {\n    while (now + 1 < i && 2 * a[now + 2] < 2 * a[i] - s)\n      now++, mn = min(mn, dp[now] - a[now] - 2 * a[now + 1]);\n    while (head < tail && q[head] <= now) head++;\n    while (head < tail &&\n           dp[q[tail - 1]] - a[q[tail - 1]] >= dp[i - 1] - a[i - 1])\n      tail--;\n    q[tail++] = i - 1;\n    dp[i] = min(dp[q[head]] - a[q[head]] + a[i] + s, mn + 3 * a[i]);\n  }\n  cout << dp[n] + m - a[n] << \"\\n\";\n#undef int\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* In the name of Allah */\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nstruct node {\n\tlong long mn_d, mx_d;\n\tlong long mn_x, mn_y;\n} seg[N << 2];\nint n, e, t, x[N];\nlong long dp[N];\n\ninline node merge(node a, node b) {\n\treturn {min(a.mn_d, b.mn_d), max(a.mx_d, b.mx_d), min(a.mn_x, b.mn_x), min(a.mn_y, b.mn_y)};\n}\n\nvoid update(int p, long long x, long long d, int id = 1, int st = 0, int en = n) {\n\tif (en - st == 1) {\n\t\tseg[id] = {d, d, x, x + d};\n\t\treturn;\n\t}\n\tint mid = st + en >> 1;\n\tif (p < mid)\n\t\tupdate(p, x, d, id << 1, st, mid);\n\telse\n\t\tupdate(p, x, d, id << 1 | 1, mid, en);\n\tseg[id] = merge(seg[id << 1], seg[id << 1 | 1]);\n}\n\nlong long get(int l, int r, int d, int id = 1, int st = 0, int en = n) {\n\tif (r <= st || en <= l)\n\t\treturn 1e18;\n\tif (l <= st && en <= r) {\n\t\tif (seg[id].mx_d <= d)\n\t\t\treturn seg[id].mn_x + d;\n\t\tif (seg[id].mn_d >= d)\n\t\t\treturn seg[id].mn_y;\n\t}\n\tint mid = st + en >> 1;\n\treturn min(get(l, r, d, id << 1, st, mid), get(l, r, d, id << 1 | 1, mid, en));\n}\n\ninline void read_input() {\n\tcin >> n >> e >> t;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n}\n\ninline void solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tupdate(i, dp[i] - x[i - 1] - 2 * x[i], t + 2LL * x[i]);\n\t\tdp[i + 1] = get(0, i + 1, 2 * x[i]) + x[i];\n\t}\n\tcout << dp[n] + e - x[n - 1];\n}\n\nint main() {\n\tios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tread_input(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nll n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(ll u, ll l, ll r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tll mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(ll u, ll l, ll r, ll x, ll val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tll mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nll query(ll u, ll l, ll r, ll b, ll e)\n{\n\tif (e <= b)\n\t\treturn b==e?-x[0] * 2:inf;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tll mid = (l + r) / 2, tmp = inf;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tif (2 * (x[i] - x[ind]) < T)\n\t\t\tind--;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind >= 0 ? dp[ind] : 0));\n\t\tupdate(0, 0, n, i + 1, dp[i]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll, int> P;\n\nint main(){\n\tll N, E, T; cin >> N >> E >> T;\n\tll x[N+1];\n\tfor(int i=0; i<N; i++) cin >> x[i];\n\tx[N] = E;\n\tll dp[N+1];\n\tdp[N-1] = T + E - x[N-1];\n\tdp[N] = 0;\n\tint now = N-1, prev = N-1;\n\tpriority_queue<ll, vector<ll>, greater<ll> > pq;\n\tll mi = 1e18;\n\tfor(int i=N-2; i>=0; i--){\n\t\twhile(2*(x[now] - x[i]) >= T){\n\t\t\tnow--;\n\t\t}\n\t\tfor(; prev>=now+1; prev--){\n//\t\t\tpq.push(dp[prev] + 2*x[prev-1] + x[prev]);\n\t\t\tif(mi > dp[prev+1] + 2*x[prev] + x[prev+1]) mi = dp[prev+1] + 2*x[prev] + x[prev+1];\n\t\t}\n\t\tif(now != N-1){\n\t\t\tdp[i] = min(mi - 3*x[i], T + x[now+1] - x[i] + dp[now+1]);\n\t\t}else{\n\t\t\tdp[i] = min(mi - 3*x[i], T + E - x[i]);\n\t\t}\n\t}\n\tcout << dp[0] + x[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tint pnt=n+1;\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\twhile (2*(A[pnt-1]-A[i])>=T) pnt--;\n\t\tdp[i]=min(dp[i], T+dp[pnt]);\n\t\tfor (int j=pnt; j<=n; j++){\n\t\t\tdp[i]=min(dp[i], (A[j]-A[i])*2+dp[j+1]);\n\t\t}\n\t\t\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 120000\n#define INF 0x3f3f3f3f3f3f3f3fLL\n\nLL a[N],n,m,t,f[N],g[N];\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&t);\n\tfor (LL i=1;i<=n;++i) scanf(\"%lld\",a+i);\n\tg[0]=-a[1]*2;\n\tfor (LL i=1,j=0;i<=n;++i){\n\t\tfor (;t<2*(a[i]-a[j+1]);++j);\n\t\tf[i]=min(j>0?g[j-1]+a[i]*3:INF,f[j]+a[i]-a[j]+t);\n\t\tg[i]=min(g[i-1],f[i]-a[i]-a[i+1]*2);\n\t}\n\tprintf(\"%lld\\n\",f[n]+m-a[n]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\nconst ll inf=1LL<<60;\nll x[200010];\nll dp[200010];\n\n// Description: セグメント木　点更新 区間クエリ \n// TimeComplexity: 初期化$\\mathcal{O}(n \\log n)$ 更新とクエリ$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_2_A\n\nstruct Segment_tree{\n    using T=ll;\n\n    int n;\n    vector<T> data;\n    const T out=(1LL<<50)-1;\n\n    inline T vmerge(T l,T r){return min(l,r);}\n\n    Segment_tree(int n):n(n){data.assign(2*n,out);}\n\n    void update(int p,T x) {  // set value at position p\n        for(data[p+=n]=x; p > 1; p >>= 1) data[p>>1]=vmerge(data[p],data[p^1]);\n    }\n\n    T query(int l, int r) {  // sum on interval [l, r)\n        T resl = out,resr = out;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l&1) resl = vmerge(data[l++], resl);\n            if (r&1) resr = vmerge(resr, data[--r]);\n        }\n        return vmerge(resl,resr);\n    }\n};\n\n\nint main(void){\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,1,n+1) cin >> x[i];\n    x[n+1]=e;\n\n    Segment_tree seg(n+1);\n\n    int lft=0;\n    seg.update(0,-2*x[1]);\n\n\trep(i,1,n+1){\n        dp[i]=inf;\n        while(lft<i and 2*(x[i]-x[lft+1])>t) lft++;\n\t\tdp[i]=min(2*x[i]+seg.query(0,lft),dp[lft]+t);\n        seg.update(i,dp[i]-2*x[i+1]);\n\t}\n\n\tcout << dp[n]+e << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node; \npublic:\n    SegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, inf);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    SegmentTree seg1(vector<ll>(N+1,inf)),seg2(vector<ll>(N+1,inf));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.update(0,dp[0]-X[1]);\n    seg2.update(0,dp[0]-3*X[1]);\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i+1]-X[i]+T;\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        //cerr << i << \" \" << id << \" \" << seg1.getmin(id,i) << \" \" << seg2.getmin(0,id) << endl;\n        if(id>0) dp[i] = min(dp[i],seg1.getmin(id-1,i)+T+X[i+1]);\n        dp[i] = min(dp[i],seg2.getmin(0,id-1)+2*X[i]+X[i+1]);\n        seg1.update(i,dp[i]-X[i+1]);\n        seg2.update(i,dp[i]-3*X[i+1]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}\n\tLL pos = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n#define MP make_pair \n#define PB push_back \n#define INF (1000000007) \n#define eps 1e-8\n#define MOD (1000003)\n#define IOS ios::sync_with_stdio(false)\n\ntypedef pair<int,int> pii ;\ntypedef pair<double,double> pdd ;\ntypedef long long ll ;\n\nll n,e,t;\nll dp[100005],p[100005];\nll mx=-1;\nmultiset<ll>s;\n\nint main()\n{\n\tIOS;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tdp[0]=0;\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif((p[i]-p[pos])*2>t) \n\t\t\t{\n\t\t\t\tif(mx==-1) mx=dp[pos-1]-p[pos]*2;\n\t\t\t\telse mx=min(dp[pos-1]-p[pos]*2,mx);\n\t\t\t\ts.erase(dp[pos-1]);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mx+2*p[i]);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mkp make_pair\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int MAXN = 100010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN];\nll dp[MAXN], pre;\nqueue<pli> q;\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tq.push(mkp(0, d[1]));\n\tpre = INF;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tpli u = q.front();\n\t\twhile(2*(d[i]-u.snd) > T) {\n\t\t\tpre = min(pre, u.fst-2*u.snd);\n\t\t\tq.pop();\n\t\t\tif(!q.empty()) u = q.front();\n\t\t\telse break;\n\t\t}\n\t\tif(!q.empty()) dp[i] = u.fst+T;\n\t\tdp[i] = min(dp[i], pre+(d[i]<<1));\n\t\tq.push(mkp(dp[i], d[i+1]));\n\t}\n\tprintf(\"%I64d\\n\", dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nvector<long long> g[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tmultiset<long long> s;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\tfor (auto j:g[now]){\n\t\t\ts.erase(s.find(j));\n\t\t}\n\t\tf[now]=min(f[now],*s.begin());\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ts.insert(f[now]+wait);\n\t\t\tg[x+1].push_back(f[now]+wait);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tint tx=x+1;\n\t\tfor (int x=tx; x<=n&&x-tx<=2000; ++x){\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint p[100001],s[100001],a[100001];\nlong long f[100001];\nbool cj(int x,int y,int z){\n\treturn 1ll*(x-z)*(p[y]-p[z])>=1ll*(y-z)*(p[x]-p[z]);\n}\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<=n;a[i]=s[s[0]],s[++s[0]]=i++)\n\t\tfor(;s[0]>1&&cj(i,s[s[0]],s[s[0]-1]);s[0]--);\n\ta[1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1]+t;\n\t\tfor(int j=1;j<=i;j++)\n\t\tf[i]=min(f[i],max(t,2*(p[i]-p[j]))+f[j-1]);\n\t}\n\t//\tfor(int i=1;i<=n;i++)cout<<f[i]<<\" \";\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return; int mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; } int mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now]; int mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n//\tfreopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]-2LL*(ll)X[i]-(ll)X[i-1]);\n\t\tmodify(tree2,1,1,N,i,f[i-1]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) > 0) r = mid-1;\n\t\t\telse l = mid+1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tif (r+2 <= i) f[i] = min(f[i],query(tree2,1,1,N,r+2,i)+(ll)X[i]+(ll)T);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,e,t,a[100005],k;\nll o,f[100005];\nint main(){\n    o=orz*4ll;\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;++i){\n        while((a[i]-a[k+1])*2>t)o=min(o,f[k]-a[k]-a[k+1]*2ll),++k;\n        f[i]=min(f[k]+a[i]-a[k]+t,o+a[i]*3ll);\n    }\n    printf(\"%lld\\n\",f[n]+e-a[n]);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst int N=2005;\nconst ll inf=1000000000000000000ll;\n\nint n;\nll e,T;\nll dp[N][N],x[N];\n\nint main(){\n\tint i,j;\n\tscanf(\"%d%lld%lld\",&n,&e,&T);\n\tfor (i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tx[n+1]=e;\n\tfor (i=0;i<=n+1;i++)\n\t\tfor (j=0;j<=n+1;j++) dp[i][j]=inf;\n\tdp[1][1]=x[1];\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=i;j++) if (dp[i][j]<inf){\n\t\t\tdp[i+1][i+1]=min(dp[i+1][i+1],dp[i][j]+max(2*(x[i]-x[j]),T)+x[i+1]-x[i]);\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t}\n\tprintf(\"%lld\\n\",dp[n+1][n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<climits>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 100005\n#define M 10005\n#define INF 1000000000000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint is_mul_overflow(ll a, ll b) {\n        return LLONG_MAX / a < b;\n}\n\nll x[N];\nll dp[N],a[4*N],b[4*N];\nll n,e,t;\nll get(int a,int b)\n{\n    ll d = x[b]-x[a];\n    return t>2LL*d?t+d:3LL*d;\n}\n\nvoid push_up(int rt)\n{\n    a[rt] = min(a[rt<<1],a[rt<<1|1]);\n    b[rt] = min(b[rt<<1],b[rt<<1|1]);\n}\nvoid build(int l,int r,int rt)\n{\n    a[rt] = b[rt] = INF;\n    if(l == r)return;\n    int mid = (l+r)>>1;\n    build(l,mid,rt<<1);\n    build(mid+1,r,rt<<1|1);\n}\n\nvoid update(int l,int r,int rt,int p,ll x,int f)\n{\n    if(l == r)\n    {\n        if(f)a[rt] = min(a[rt],x);\n        else b[rt] = min(b[rt],x);\n        return;\n    }\n    int mid = (l+r)>>1;\n    if(p<=mid)update(l,mid,rt<<1,p,x,f);\n    else update(mid+1,r,rt<<1|1,p,x,f);\n    push_up(rt);\n}\nll query(int l,int r,int rt,int L,int R,int f)\n{\n    if(L>R)return INF;\n    if(L<=l&&R>=r)return f?a[rt]:b[rt];\n    int mid = (l+r)>>1;\n    ll ret = INF;\n    if(L<=mid)ret = min(ret,query(l,mid,rt<<1,L,min(mid,R),f));\n    if(R>mid)ret = min(ret,query(mid+1,r,rt<<1|1,max(L,mid+1),R,f));\n    return ret;\n}\nint get(int p)\n{\n    int l = 0,r = p;\n    while(l<r-1)\n    {\n        int mid = (l+r)>>1;\n        if(2*(x[p]-x[mid+1])>=t)l = mid;\n        else r = mid;\n    }\n    return l;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n>>e>>t)\n    {\n        FOR(i,1,n)cin>>x[i];\n        FOR(i,0,n)dp[i] = INF;\n        build(1,n,1);\n        x[0] = 0;\n        dp[0] = 0;\n        FOR(i,1,n)\n        {\n            int ps = get(i);\n            dp[i] = min(dp[i],t+x[i]+query(1,n,1,ps+1,i-1,1));\n            dp[i] = min(dp[i],3*x[i]+query(1,n,1,1,ps,0));\n            dp[i] = min(dp[i],x[1]-x[0]+get(1,i));\n            update(1,n,1,i,dp[i]-x[i],1);\n            update(1,n,1,i,dp[i]-2*x[i+1]-x[i],0);\n        }\n        cout<<dp[n]+e-x[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  using F = function<T(T&, T&)>;\n  int n;\n  vector<T > dat;\n  T e; // �P�ʌ�\n  F query_func;\n  F update_func;\n  \n  SegmentTree(vector<T> a, F query_func, F update_func, T e) :n(a.size()), query_func(query_func), update_func(update_func), e(e) {\n    dat.resize(4 * n);\n    init(0, 0, n, a);\n  }\n\n  void init(int k, int l, int r, vector<T> &a) {\n    if (r - l == 1) {\n      dat[k] = a[l];\n    }\n    else {\n      int lch = 2 * k + 1, rch = 2 * k + 2;\n      init(lch, l, (l + r) / 2, a);\n      init(rch, (l + r) / 2, r, a);\n      dat[k] = query_func(dat[lch], dat[rch]);\n    }\n  }\n\n  //k�Ԗڂ̒l��a�ɕύX\n  void update(int k, T a, int v, int l, int r) {\n    if (r - l == 1) {\n      dat[v] = update_func(dat[v], a);\n    }\n    else {\n      if (k < (l + r) / 2)\n        update(k, a, 2 * v + 1, l, (l + r) / 2);\n      else {\n        update(k, a, 2 * v + 2, (l + r) / 2, r);\n      }\n      dat[v] = query_func(dat[v * 2 + 1], dat[v * 2 + 2]);\n    }\n  }\n    \n\n  //[a,b)�̍ŏ��l�����߂�\n  //���̂ق��̈����͌v�Z�̊ȒP�̂��߂̈���\n  //k�͐ړ_�̔ԍ�,l,r�͂��̐ړ_��[l,r)�ɑΉ����Ă��邱�Ƃ�\\��\n  //�]���āA�O�����query(a,b,0,0,n)�Ƃ��Ă��\n  T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return e;\n    }\n    if (a <= l && r <= b) {\n      return dat[k];\n    }\n    else {\n      T ul = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T ur = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return query_func(ul, ur);\n    }\n  }\n\n  // �����𖞂����ĉE��T��\n  int find(int a, int b, int k, int l, int r, int x) {\n    // �����𒼂�\n    if (dat[k] < x || r <= a || b <= l) return -1;\n    if (l + 1 == r) {\n      // �����𒼂�\n      if (dat[k] >= x) return l;\n      else return -1;\n    }\n    int rv = find(a, b, 2 * k + 2, (l + r) / 2, r, x);\n    if (rv != -1) return rv;\n    return find(a, b, 2 * k + 1, l, (l + r) / 2, x);\n  }\n};\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    auto f = [](ll a, ll b) {return min(a, b);};\n    auto g = [](ll, ll b) {return b;};\n    SegmentTree<ll> seg(vl(n + 1, INF), f, g, INF);\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    seg.update(0, dp[0] + t - x[0], 0, 0, seg.n);\n    int nei = 0;\n    ll mi = INF;\n    int ki = 0;\n    rep1 (i, n) {\n        while (nei < i) {\n            if ((x[i] - x[nei + 1]) * 2 >= t) {\n                seg.update(nei, dp[nei] - x[nei] - 2 * x[nei + 1], 0, 0, seg.n);\n                nei++;\n            }\n            else break;\n        }\n\n        ll mi1 = seg.query(0, nei, 0, 0, seg.n);\n        ll mi2 = seg.query(nei, i, 0, 0, seg.n);\n        dp[i] = min(mi1 + 3 * x[i], mi2 + x[i]);\n\n        // int px = x[i] - t / 2 - 1;\n        // auto itr = upper_bound(all(x), px);\n        // itr--;\n        // int pi = itr - x.begin();\n        // pi -= 5;\n        // rep (_, 10) {\n        //     if (pi >= 0) {\n        //         if ((x[i] - x[pi + 1]) * 2 < t) break;\n        //         // dp[i] = dp[pi] + (x[pi + 1] - x[pi]) + t + (x[i] - x[pi + 1]);\n        //         chmin(dp[i], dp[pi] + (x[pi + 1] - x[pi]) + (x[i] - x[pi + 1]) * 3);\n        //     }\n        //     pi++;\n        // }\n        // DEBUG(pi);\n\n        // ll mi = seg.query(pi, i, 0, 0, seg.n);\n        // chmin(dp[i], mi + x[i]);\n        if (i != n) {\n            seg.update(i, dp[i] + t - x[i], 0, 0, seg.n);\n        }\n    }\n    DEBUG_VEC(dp);\n\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint p[100001],s[100001],a[100001];\nlong long f[100001];\nbool cj(int x,int y,int z){\n\treturn 1ll*(x-z)*(p[y]-p[z])>=1ll*(y-z)*(p[x]-p[z]);\n}\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<=n;a[i]=s[s[0]],s[++s[0]]=i++)\n\t\tfor(;s[0]>1&&cj(i,s[s[0]],s[s[0]-1]);s[0]--);\n\ta[1]=1;\n\tif(n<=2000)for(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1]+t;\n\t\tfor(int j=1;j<=i;j++)\n\t\tf[i]=min(f[i],max(t,2*(p[i]-p[j]))+f[j-1]);\n\t}\n\t//\tfor(int i=1;i<=n;i++)cout<<f[i]<<\" \";\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std;\nset<pair<long long,long long> > s; \nlong long x[100008],dp[100008];\nint main()\n{\n\tlong long n;cin>>n;long long t,e;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i],s.insert(make_pair(x[i],i));for(long long i=0;i<100005;i++) dp[i]=2e9;\n\tdp[0]=0;s.insert(make_pair(0,0));\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tint j;set<pair<long long,long long> >::iterator it=s.lower_bound(make_pair(x[i]-(t+1)/2,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\tit=s.lower_bound(make_pair(x[i]-t,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nmultiset<long long>s1,s2;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\ts2.insert(t);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[st+1])>=t)\n\t\t{\n\t\t\ts2.erase(dp[st]-x[st]+t);\n\t\t\ts1.insert(dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=4e18;\n\t\tif(s1.size())dp[i]=min(dp[i],(*s1.begin())+3LL*x[i]);\n\t\tif(s2.size())dp[i]=min(dp[i],x[i]+(*s2.begin())),\n\t\ts2.insert(dp[i]-x[i]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n\n  vector< T > seg;\n  int sz;\n\n  SegmentTree(int n) : INF(numeric_limits< T >::max())\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  int64 N, T, E, X[100002];\n\n  cin >> N >> T >> E;\n  if(N > 2000) throw (0);\n  for(int i = 1; i <= N; i++) cin >> X[i];\n\n\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]+X[i]*2-X[j+1]*2\n  // dp2[j]=dp[j]-X[j+1]*2\n  cout << dp[N][N] + T << endl;\n\n\n/*\n  SegmentTree< int64 > dp1(N + 1), dp2(N + 1);\n\n  dp1.update(0, 0);\n  dp1.update(1, E);\n  dp2.update(0, dp1.rmq(0, 1) - X[1] * 2);\n  dp2.update(1, dp1.rmq(1, 2) - X[2] * 2);\n\n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while(high - low > 0) {\n      int mid = (low + high) >> 1;\n      if((X[i] - X[mid + 1]) * 2 <= E) high = mid;\n      else low = mid + 1;\n    }\n/*\n    cout << (X[i] - X[low + 1]) * 2 << \" \" << E << endl;\n\n    for(int k = low; k < i; k++) cout << dp[k] << \" \";\n    cout << endl;\n\n    dp1.update(i, min(dp1.rmq(low, i) + E, X[i] * 2 + dp2.rmq(0, low)));\n    //cout << low << endl;\n    dp2.update(i, dp1.rmq(i, i + 1) - X[i + 1] * 2);\n  }\n  cout << dp1.rmq(N, N + 1) + T << endl;\n*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int N = 1e5 + 10; \nint a[N], nxt[N], n, e, t;\nlong long val;\nlong long seg[N << 2], lazy[N << 2], dp[N];\nvector<int> fnd[N];\nvoid relax(int id) {\n\tint lc = id * 2, rc = lc + 1;\n\tseg[lc] += lazy[id], lazy[lc] += lazy[id];\n\tseg[rc] += lazy[id], lazy[rc] += lazy[id];\n\tlazy[id];\n\treturn;\n}\nvoid add(int l, int r, int id = 1, int s = 0, int e = n) {\n\tif (l == r)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn;\n\t}\n\tif (e <= l || r <= s)\n\t\treturn;\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tadd(l, r, lc, s, mid);\n\tadd(l, r, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n}\nvoid upd(int p, int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tseg[id] = val;\n\t\tlazy[id] = 0;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\tif (p < mid)\n\t\tupd(p, lc, s, mid);\n\telse\n\t\tupd(p, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n\treturn;\n}\nint main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint st = -1;\n\tn++;\n\tfor (int i = 0; i < n; i++) {\n\t\tval = inf;\n\t\tupd(i);\n\t\twhile ((a[i] - a[st + 1]) * 2 >= t)\n\t\t\tst++;\n\t\tif (st != -1)\n\t\t\tfnd[st].push_back(i);\n\t}\n\tst = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile ((a[st - 1] - a[i]) >= t)\n\t\t\tst--;\n\t\tnxt[i] = st;\n\t}\n//\tcout << \"HO\" << endl;\n\tval = t;\n\tupd(n - 1);\n\tfor (int i = n - 2; i >= 0; i--) {\n//\t\tcout << \"i = \" << i << endl;\n\t\tlong long toall = a[i + 1] - a[i], tosome = a[i + 2] - a[i + 1];\n\t\tval = toall, add(i + 1, n);\n\t\tif (tosome > 0)\n\t\t\tval = tosome, add(nxt[i + 1], n);\n\t\tfor (auto plc : fnd[i + 1]) {\n\t\t\tlong long dis = 1ll * (a[plc] - a[i + 1]) * 3 + 1ll * toall;\n\t\t\tval = dis + dp[plc], upd(plc);\n//\t\t\tcout << \"plc = \" << plc << \" : \" << dis << \" val = \" << val << endl;\n\t\t}\n\t\tdp[i] = seg[1], val = dp[i] + t;\n//\t\tcout << \"i = \" << i << \" : \" << a[i] << \" : \" << dp[i] << \" toall = \" << toall << \" tosome = \" << tosome << \" : \" << nxt[i + 1] << endl;\n\t\tupd(i);\n\t}\n\tcout << dp[0] + e - a[n - 1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+5;\nconst long long INF=100000000000ll;\nint n,T,E;\nint a[N],p[N];\n\nstruct Tree{\n\tint left,right;\n\tlong long val,tag;\n\tTree *left_child,*right_child;\n};\n\nvoid build(Tree *pos,int x,int y){\n\tpos->left=x;pos->right=y;pos->val=pos->tag=0ll;\n\tif(x==y) return;\n\tint mid=(x+y)>>1;\n\tpos->left_child=new Tree();\n\tpos->right_child=new Tree();\n\tbuild(pos->left_child,x,mid);\n\tbuild(pos->right_child,mid+1,y);\n}\n\nlong long VAL(Tree *pos){\n\treturn pos->val+pos->tag;\n}\n\nvoid pushdown(Tree *pos){\n\tpos->left_child->tag+=pos->tag;\n\tpos->right_child->tag+=pos->tag;\n\tpos->tag=0ll;\n}\n\nvoid pushup(Tree *pos){\n\tpos->tag=0ll;\n\tpos->val=min(VAL(pos->left_child),VAL(pos->right_child));\n}\n\nlong long query(Tree *pos,int x,int y){\n\tif(x>y) return INF;\n\tif(pos->left>=x&&pos->right<=y) return VAL(pos);\n\tif(pos->left>y||pos->right<x) return INF;\n\tpushdown(pos);\n\tlong long ret=min(query(pos->left_child,x,y),query(pos->right_child,x,y));\n\tpushup(pos);\n\treturn ret;\n}\n\nvoid modify(Tree *pos,int x,int y,long long v){\n\tif(pos->left>=x&&pos->right<=y){\n\t\tpos->tag+=v;\n\t\treturn;\n\t}\n\tif(pos->left>y||pos->right<x) return;\n\tpushdown(pos);\n\tmodify(pos->left_child,x,y,v);\n\tmodify(pos->right_child,x,y,v);\n\tpushup(pos);\n}\n\nTree *rt,*dp;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=0,r=i;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif((a[i]-a[mid])*2<=T) r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tp[i]=r;\n\t}\n//\tfor(int i=1;i<=n;i++) printf(\"%d \",p[i]);puts(\"\");\n\trt=new Tree();\n\tdp=new Tree();\n\tbuild(rt,0,n);\n\tbuild(dp,0,n);\n\tfor(int i=1;i<=n;i++){\n\t\tif(i!=1) modify(rt,0,i-2,2ll*(a[i]-a[i-1]));\n\t\tlong long DP=min(query(rt,0,p[i]-1),query(dp,p[i],i-1)+T);\n//\t\tprintf(\"%d %lld\\n\",i,DP);\n\t\tmodify(dp,i,i,DP);\n\t\tmodify(rt,i,i,DP);\n\t}\n\tprintf(\"%lld\\n\",query(rt,n,n)+E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\tdp[i] = get(i, 0);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nconst ll inf = (1LL<<62) - 1 + (1LL<<62);\n\nint n,e,t,p[maxn],ti[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*3];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n    //freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<=t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i];\n            tt =  tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,1)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n            tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]+t-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int maxn = 1e5 + 20;\n\nint N, E, T;\nint x[maxn];\nlong long f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tfor(int i = 1; i <= N; i++) f[i] = 1e18;\n\t\n\tfor(int i = 1, j = 1; i <= N; i++)\n\t{\n\t\twhile(j <= N && x[j] - x[i] <= T) j++;\n\t\n\t\tf[j] = std::min(f[j], f[i - 1] + 2 * (x[j] - x[i]));\n\t\tf[j - 1] = std::min(f[j - 1], f[i - 1] + T);\n\t\tf[i] = std::min(f[i], f[i - 1] + T);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[N] + E);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,t,e,a[100100],f[100100],mn=0x3f3f3f3f;\ndeque<int>q;\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tq.push_back(0);\n\tfor(int i=1,j=0;i<=n;i++){\n\t\twhile(j+1<i&&t-2*a[i]+2*a[j+1]<0)mn=min(mn,f[j]-a[j]-2*a[j+1]),j++;\n\t\twhile(!q.empty()&&q.front()<j)q.pop_front();\n\t\twhile(!q.empty()&&f[i-1]-a[i-1]<=f[q.back()]-a[q.back()])q.pop_back();\n\t\tq.push_back(i-1);\n\t\tf[i]=min(f[q.front()]-a[q.front()]+a[i]+t,mn+3*a[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvint v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tn++;\n\tvll dp(n+1,INFL);\n\tdp[0]=0;\n\trep(i,n){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tit--;\n\t\tmins(dp[min(it+1,n-1)],dp[i]+T);\n\t\trep(j,100){\n\t\t\tmins(dp[j+it+2],dp[i]+2*(v[j+it+1]-v[i]));\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll dp[2016];\n\nint main() {\n\tll n,e,t;\n\tcin>>n>>e>>t;\n\tvector<ll> vx;\n\trep(i,0,n){\n\t\tll a;\n\t\tcin>>a;\n\t\tvx.pb(a);\n\t}\n\trep(i,0,2016)dp[i] = 1000000000000000000LL;\n\tdp[0] = 0;\n\tdp[1] = t;\n\tif(n==1){\n\t\tcout << e+t << endl;\n\t\treturn 0;\n\t}\n\trep(i,2,vx.sz+1){\n\t\tdp[i] = dp[i-1]+t;\n\t\trep(j,0,i){\n\t\t\tdp[i] = min(dp[i], dp[j] + max(t,(vx[i-1] - vx[j])*2));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Debug(x) cout<<#x<<\"=\"<<(x)<<endl;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL inf = 1LL << 61;\nconst LL mod = 1000000007;\nconst int max_n = 100010;\n\n\nint n;\nLL T, E;\nLL dp[max_n], d[max_n], dp2[max_n], p[max_n];\nint main()\n{\n    int i = 0, j = 0, k = 0;\n    LL ans;\n    Fill(d, 0), Fill(dp, 0);\n    Fill(dp2, 0), Fill(p, 0);\n    cin >> n >> E >> T;\n    //scanf(\"%d %I64d %I64d\", &n,&E,&T);\n    for(i = 1; i <= n; i++)\n    {\n        cin >> d[i];//scanf(\"%I64d\", d+i);\n    }\n    if(n==1)\n    {\n        ans = E+T;\n        cout << ans << endl;//printf(\"%I64d\\n\", ans);\n        return 0;\n    }\n    int tp;\n    for(i = 1; i <= n; i++)\n    {\n        for(tp = p[i-1]; tp < i; tp++)\n        {\n            if(T>2*(d[i]-d[tp+1]))\n                break;\n        }\n        p[i] = tp;\n    }\n    /*\n    cout << \"p:\\n\";\n    for(i = 1; i <= n; i++)\n    {\n        cout << p[i] << \" \";\n    }\n    cout << endl;\n    */\n    dp[1] = T;\n    dp2[1] = dp[1]-2*d[2];\n    for(i = 2; i <= n; i++)\n    {\n        tp = p[i];\n        dp[i] = max(T, 2*(d[i]-d[1]));\n        if(tp>0)\n        {\n            ans = min(dp[tp]+T, 2*d[i]+dp2[tp-1]);\n        }\n        else\n        {\n            ans = dp[tp]+T;\n        }\n        dp[i] = min(dp[i], ans);\n        if(i < n)\n            dp2[i] = min(dp2[i-1], dp[i]-2*d[i+1]);\n    }\n    /*\n    cout << \"dp:\\n\";\n    for(i = 1; i <= n; i++)\n    {\n        cout << dp[i] << \" \";\n    }\n    cout << endl;\n    */\n    ans = dp[n]+E;\n    cout << ans << endl;//printf(\"%I64d\\n\", ans);\n\n\n\n\n    return 0;\n}\n/*\n5 8 4\n1 3 4 6 7\n*/\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n//BEGIN CUT HERE\ntemplate <typename T>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  int n;  //セグ木の幅\n  F f;  //モノイドの作用\n  T ti;  //初期値\n  vector<T> dat;  //セグ木で使う配列 一番上に使われるのがdat[1] 一番下の段の左端がdat[n]\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}  //fがモノイドとしての作用、tiが単位元\n  SegmentTree(F f,T ti,int n_):f(f),ti(ti){\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n  SegmentTree(F f,T ti,const vector<T> &v):f(f),ti(ti){\n    int n_=v.size();\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n    for(int i=0;i<n_;i++)dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  T get(int x){\n    return dat[x+n];\n  }\n\n  void init(int n_){  //ただの初期化\n    n=1;\n    while(n<n_) n<<=1;  //nが実際にとる２べきの幅\n    dat.assign(n<<1,ti);  //dat配列は幅の２倍あってその全てにtiを代入\n  }\n\n  void build(const vector<T> &v){  //vector vに合わせた初期化\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];  //v[i]を一番子の所に代入\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);  //iの子供は2*i、2*i+1\n  }\n\n  void set_val(int k,T x){  //（0-indexedで）kにxを代入\n    dat[k+=n]=x;\n    while(k>>=1)  //kがどんどん自分の親になっていく、0になったらおしまい\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n\n  T query(int a,int b){  //[a,b)の範囲のモノイドの作用を返す\n    T vl=ti,vr=ti;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);  //左端を使いたくなるのはブロックが奇数の時\n      if(r&1) vr=f(dat[--r],vr);  //右端〃偶数の時（開区間なのでr:奇数で反応）\n    }\n    return f(vl,vr);\n  }\n\n  template<typename C>\n  int find(int st,C &check,T &acc,int k,int l,int r){  //dat[k]:[l,r)の間にいるenを返す\n    //下のfind用なので先にそっち読むべき\n    //accはst~lとかで確定している値\n    if(l+1==r){  //答えがちゃんと存在するならこのlが答え\n      acc=f(acc,dat[k]);\n      return check(acc)?k-n:-1; //入るならk-n(==l)を、入らないなら-1を返す\n    }\n    int m=(l+r)>>1;  //にぶたんのそれ\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);  //mがstより後ろなら明らかにl=m;\n    if(st<=l&&!check(f(acc,dat[k]))){  //今見てるk全部でもダメ(mだと足りないのでl=mにする）\n      acc=f(acc,dat[k]);  //kは全部accに加えた上で-1を返す\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);  //まず[l,m)の中にenがいるか探す\n    if(~vl) return vl;  //いたならそれを返す(if(~vl)は-1以外にのみ反応する)\n    return find(st,check,acc,(k<<1)|1,m,r);  //いなかったら[m,r)の中にenがいるのでそれを返す\n    //acc=f(acc,dat[k]);がここで効いてる\n  }\n\n  template<typename C>\n  int find(int st,C &check){\n    //check(f(dat[st]~dat[en-1]))=false,check(f(dat[st]~dat[en]))＝trueとなるenを返す\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }\n};\n//END CUT HERE\nconst int INF=1e9;\nauto f=[](int a,int b){return min(a,b);};\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\nsigned main(){\n  int n,e,t;cin>>n>>e>>t;\n  vector<int> x(n+1,0);\n  REP(i,0,n)cin>>x[i+1];\n  SegmentTree<int> seg1(f,INF,n),seg2(f,INF,n);\n  seg1.set_val(0,-2*x[1]);\n  seg2.set_val(0,0);\n  REP(i,1,n+1){\n    int l=-1,r=i;//2(x[i+1]-x[l])>T\n    while(r-l>1){\n      int mid=(l+r)>>1;\n      (2*(x[i]-x[mid])>t?l:r)=mid;\n    }\n    int a=min(seg1.query(0,l)+3*x[i],seg2.query(l,i)+x[i]+t);\n    if(i<n){\n      seg1.set_val(i,-2*x[i+1]-x[i]+a);\n      seg2.set_val(i,a-x[i]);\n    }\n    else fin(e-x[n]+a);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)\n#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)\n\nmt19937 Rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\ntemplate <typename T>\ninline void chkmax(T &x, T y) { if (x < y) x = y; }\n\ntemplate <typename T>\ninline void chkmin(T &x, T y) { if (x > y) x = y; }\n\ninline int read() {\n  #define nc getchar()\n  int x = 0;\n  char c = nc;\n  while (c < 48) c = nc;\n  while (c > 47) x = (x << 3) + (x << 1) + (c ^ 48), c = nc;\n  return x;\n  #undef nc\n}\n\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, m, T, a[maxn];\n\nll dp[maxn];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &T);\n  rep(i, 1, n) a[i] = read();\n  int l = 1, r = 1;\n  static int Q[maxn];\n  int tpos = -1; ll tmin = 1e18;\n  rep(i, 1, n) {\n    for (; tpos < i && 2 * a[tpos + 1] <= 2 * a[i] - T; tpos++) {\n      if (~tpos) chkmin(tmin, dp[tpos] - 2 * a[tpos + 1]);\n    }\n    while (l <= r && 2 * a[Q[l] + 1] <= 2 * a[i] - T) l++;\n    dp[i] = tmin + 2 * a[i];\n    if (l <= r) {\n      chkmin(dp[i], dp[Q[l]] + T);\n    }\n    while (l <= r && dp[Q[r]] >= dp[i]) r--;\n    Q[++r] = i;\n  }\n  printf(\"%lld\", dp[n] + m);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(s...)  fprintf(stderr, s)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n\ntemplate<class T> struct RMQ {\n    int n;\n    vector<T> A; vector<int> I;\n    RMQ(int n_=0): n(n_), A(n), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = I[2*i];\n    }\n    RMQ(const vector<T> &a): n(a.size()), A(a), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    void modify(int i, const T &v) {\n\tA[i] = v;\n\tfor (i+=n; i>>=1;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    int min_i(int x, int y) {\n\tx += n; y += n;\n\tint p = -1;\n\tfor (; x<y; x>>=1, y>>=1) {\n\t    if (y & 1) { --y; if (p < 0 || A[I[y]] < A[p]) p = I[y]; }\n\t    if (x & 1) { if (p < 0 || A[I[x]] < A[p]) p = I[x]; x++; }\n\t}\n\treturn p;\n    }\n    T min_v(int x, int y) { return A[min_i(x, y)]; }\n};\n\nint N, T, E;\nint A[100111];\nLL dp[100111];\n\nint main() {\n\n    scanf(\"%d%d%d\", &N, &E, &T);\n    REP (i, N) scanf(\"%d\", A+i+1);\n\n    RMQ<LL> X1(N + 10), X2(N + 10);\n    X1.modify(0, -2LL * A[1]);\n\n\n    int mid = 0;\n    LL cst = 0;\n    for (int i=1; i<=N; i++) {\n\n\twhile (2LL * (A[i] - A[mid]) > T) mid++;\n\tcst = 1LL << 60;\n\n\tif (0 < mid-1) amin(cst, X1.min_v(0, mid-1) + 3LL * A[i]);\n\tif (mid-1 < i) amin(cst, X2.min_v(max(0, mid-1), i) + T + A[i]);\n\tamin(cst, X2.min_v(i-1, i) + T + A[i]);\n\n\tX1.modify(i, cst - 2 * A[i+1] + A[i]);\n\tX2.modify(i, cst - A[i]);\n\n//\teprintf(\"%d %lld %d\\n\", i, cst, mid);\n    }\n\n    LL ans = cst + E - A[N];\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=1e5+10;\nconst long long INF=1e17;\nint n,t,e;\nlong long x[nMax],f[nMax],g[nMax];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&x[i]);\n\tlong long Min=INF;\n\tg[0]=-x[1]*2;\n\tint p=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(p<=i&&(x[i]-x[p+1])*2>=t)\n\t\t\tMin=min(Min,g[p++]);\n\t\tif(p<i)\n\t\t\tf[i]=f[p]+t;\n\t\telse\n\t\t\tf[i]=INF;\n\t\tf[i]=min(f[i],Min+x[i]*2);\n\t\tg[i]=f[i]-2*x[i+1];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%lld \",f[i]);\n\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 > T) low = mid;\n      else high = mid;\n    }\n    int pos = low;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 10000000000000000;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    ll ans = e;\n    vector<ll> dp(n + 1, INF);\n    dp[0] = 0;\n    vector<ll> dp2(n + 1, INF);\n    for (int i = 1; i <= n; i++) {\n        dp2[i] = min(dp2[i - 1], dp[i - 1] - x[i - 1] * 2);\n        int j = upper_bound(x.begin(), x.begin() + i, (2 * x[i - 1] - t) / 2) - x.begin();\n        dp[i] = min(dp[j] + t, 2 * x[i - 1] + dp2[j]);\n    }\n    ans += dp[n];                    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+20];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+20];\n\tint x[100000+20];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>=T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n\t\tif(i==N) break;\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3)/3,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3);\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nint n ;\nll e , t ;\nll s[ 100005 ] ;\n\nvoid init() {\n  scanf( \"%d%lld%lld\" , &n , &e , &t ) ;\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    scanf( \"%lld\" , &s[ i ] ) ;\n  }\n  s[ 0 ] = 0 , s[ n + 1 ] = e ;\n}\n\nll dp[ 100005 ] ;\nll dp1[ 100005 ] ;\n\nvoid process() {\n  ll mn = 0 ;\n  int pt = 0 ;\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    while ( ( s[ i ] - s[ pt + 1 ] ) * 2 > t ) {\n      mn = min( ( -2 * s[ pt + 1 ] ) + dp[ pt ] , mn ) ;\n      pt ++ ;\n    }\n    ll tmn = 100000000000000000LL ;\n    if ( pt > 0 ) {\n      tmn = min( tmn , 2 * s[ i ] + mn ) ;\n    }\n    tmn = min( tmn , dp[ pt ] + t ) ;\n    dp[ i ] = tmn ;\n  }\n  printf( \"%lld\\n\" , dp[ n ] + e ) ;\n}\n\nint main() {\n  init() ;\n  process() ;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,E,T; cin >> N >> E >> T;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n\n    vector<ll> dp(N+1);\n    int cur = 0;\n    ll val = 1e18;\n    for (int i = 1; i <= N; i++) {\n        while (cur < i-1 and T < (x[i]-x[cur+1])*2) {\n            chmin(val,dp[cur]-x[cur+1]*2);\n            cur++;\n        }\n        dp[i] = min(val+x[i]*2,dp[cur]+T);\n    }\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll E,T;\nll X[100010];\nll dp[100010] = {0};\nint id = 0;\nll INF = 1001001001001001;\nll MIN;\n\nint main()\n{\n    scanf(\"%d%lld%lld\",&N,&E,&T);\n\n    MIN = INF;\n    for(int i = 1; i <= N; i++)\n    {\n        scanf(\"%lld\",X + i);\n        while(id != i && (X[i] - X[id + 1]) * 2 >= T)\n        {\n            MIN = min(MIN,dp[id] - X[id + 1] * 2);\n            id++;\n        }\n        dp[i] = MIN + X[i] * 2;\n        if(id != i)dp[i] = min(dp[i],dp[id] + T);\n    }\n    printf(\"%lld\\n\",dp[N] + E);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tint pnt=n+1;\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\twhile (2*(A[pnt-1]-A[i])>=T) pnt--;\n\t\tfor (int j=i; j<pnt; j++){\n\t\t\tdp[i]=min(dp[i], T+dp[j+1]);\n\t\t}\n\t\tfor (int j=pnt; j<=n; j++){\n\t\t\tdp[i]=min(dp[i], (A[j]-A[i])*2+dp[j+1]);\n\t\t}\n\t\t\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 , inf = 1e18 + 20;\nint n , e , t , x[N] , dp[N] , p , mn = inf ;\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> e >> t ;\n\tfor (int i = 0 ; i < n ; i ++) cin >> x[i] ;\n\n\tp = n ;\n\n\tdp[n - 1] = e - x[n - 1] + t ;\n\tfor (int i = n - 2 ; ~i ; i --) {\n\t\twhile (2 * (x[p - 1] - x[i]) > t){\n\t\t\tp -- ;\n\t\t\tmn = min(mn , dp[p + 1] + ((p == n - 1 ? e : x[p + 1]) - x[p]) + 3 * x[p]) ;\n\t\t}\n\n\t\tdp[i] = mn - 3 * x[i] ;\n\n\t\tint len = x[p - 1] - x[i] ;\n\t\tdp[i] = min(dp[i] , 3 * len + (p - i) * (t - 2 * len) + (p == n ? e - x[n - 1] : x[p] - x[p - 1] + dp[p])) ;\n\t}\n\n\tcout << x[0] + dp[0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define DIF(i) (pos[i]-pos[i-1])\nusing namespace std;\nlong long dp[100005];\nlong long pos[100005],n,tt,e;\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&tt);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&pos[i]);\n\t}\n\tpos[0]=0;\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=dp[i-1]+min(tt+DIF(i),DIF(i)*3);\n\t}\n\tprintf(\"%lld\",dp[n]+e-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,ppp,pp\t,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = (1 << 31) - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tf[i] = min(f[i],f[j] + max(2 * (d[i] - d[j + 1]),t));\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%lld \",f[i]);\n\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nconst int maxn=(int)(1e5)+5;\nconst LL INF=(LL)(1e18);\nLL x[maxn],f[maxn];\n\nint main() {\n    int n,e,t;\n    read(n);read(e);read(t);\n    REP(i,1,n) read(x[i]);\n    f[0]=0;x[0]=0;\n    REP(i,1,n) {\n        f[i]=INF;\n        REP(j,1,i) f[i]=min(f[i],f[j-1]+x[j]-x[j-1]+3*(x[i]-x[j])+max(0LL,t-2*(x[i]-x[j])));\n    }\n    printf(\"%lld\\n\",f[n]+e-x[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nint n,T,E;\nint a[100010];\nlong long ans;\nlong long f[100010],g[100010];\n\nint main()\n{int i,j;\n \n scanf(\"%d%d%d\",&n,&E,&T);\n for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n f[0]=0;\n j=1;\n a[n+1]=E;\n for(i=1;i<=n;i++)\n {\twhile(j+1<=i && (a[i]-a[j+1])*2>=T) j++;\n\tif((a[i]-a[j])*2>=T) f[i]=max(f[i],(a[i+1]-a[i])*2+g[j-1]);\n\tf[i]=max(f[i],g[i-1]+2*(a[i+1]-a[i])-T);\n\tg[i]=max(g[i-1],f[i]);\n }\n ans=(ll)3*E-f[n]-2*a[1];\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll T,E;\nll dp[100010] = {};\nconst ll inf = 1e18;\n\nint main(){\n    cin >> N >> E >> T;\n    assert(N<=2000);\n    vector<ll> X(N+1,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i]-X[i-1]+T;\n        int id = upper_bound(X.begin(),X.end(),X[i]-T)-X.begin();\n        if(id<i-1) dp[i] = min(dp[i],dp[id]+X[id+1]-X[id]+3*(X[i]-X[id+1])+max(T-2*(X[i]-X[id+1]),0LL));\n        if(id>0) dp[i] = min(dp[i],dp[id-1]+X[id]-X[id-1]+3*(X[i]-X[id])+max(T-2*(X[i]-X[id]),0LL));\n        if(id>1) dp[i] = min(dp[i],dp[id-2]+X[id-1]-X[id-2]+3*(X[i]-X[id-1])+max(T-2*(X[i]-X[id-1]),0LL));\n    }\n/*    for(int i=0;i<=N;i++) cerr << dp[i] << \" \";\n    cerr << endl;\n*/    cout << dp[N]+(E-X[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        /*\n        for (int j=1; j<i; j++)\n            if ((x[i]-x[j])*2 > T)\n                A[i] = min(A[i], A[j-1]-x[j-1]-2*x[j] + 3*x[i]);\n            else\n                A[i] = min(A[i], A[j-1]-x[j-1] + T+x[i]);\n                */\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long f[101010];\nlong long x[101010];\nlong long E,T;\nlong long calc(int i,int j)\n{\n\treturn max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]);\n}\nint main()\n{\n\tint n;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i];\n\tf[1]=T;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]+T;\n\t\tint l=1,r=i-1;\n\t\twhile(r>l)\n\t\t{\n\t\t\tint m=(l+r)/2;\n\t\t\tif(T-2*x[i]+2*x[m]>=0)\n\t\t\t\tr=m;\n\t\t\telse\n\t\t\t\tl=m+1;\n\t\t}\n\t\tf[i]=min(f[i],max(f[l-1]+T,f[l-1]+2*x[i]-2*x[l]));\n\t\tif(l>1)\n\t\t\tf[i]=min(f[i],f[l-2]+2*x[i]-2*x[l-1]);\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100005\n#define cmax(_i,_j) ((_i)<(_j)?(_i)=(_j):0)\n#define cmin(_i,_j) ((_i)>(_j)?(_i)=(_j):0)\nusing namespace std;\nnamespace runzhe2000\n{\n\ttypedef long long ll;\n\tint q[N], head, tail; ll f[N], x[N];\n\tvoid main()\n\t{\n\t\tint n, E, T; scanf(\"%d%d%d\",&n,&E,&T);\n\t\tfor(int i = 1; i <= n; i++) scanf(\"%lld\",&x[i]); sort(x+1,x+1+n);\n\t\t\n\t\tll pre = 1ll<<60; int cur = 1; head = 1;\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(; 2*(x[i]-x[cur]) >= T; cur++)\n\t\t\t{\n\t\t\t\tcmin(pre,f[cur-1]-2*x[cur]);\n\t\t\t\tif(head <= tail && q[head] == cur) head++;\n\t\t\t}\n\t\t\tfor(; head <= tail && f[q[tail]-1]-x[q[tail]] >= f[i-1]-x[i]; --tail);\n\t\t\tq[++tail] = i;\n\t\t\t\n\t\t\tf[i] = pre + 2 * x[i];\n\t\t\tif(head <= tail) cmin(f[i], f[q[head]-1]-x[q[head]]+x[i]+T);\n\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]+E);\n\t}\n}\nint main()\n{\n\trunzhe2000::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint N, E, T, x[112345];\nconst long long int INF = 2147483647;\nint memo[112345];\nint dp[112345];\n\n// dp(i) = 座標x[i]でコインを得るまでの最短時間\n// dp(i) = min((x[i]-x[i-1])+T,min((x[i]-x[i-1])+dp(i+1),(x[i+1]-x[i])+dp(i-1)))\n// 上の場合、0<i<Nでないと範囲外アクセス スタックオーバーフロー？\nint do_dp() {\n\t// メモ化再帰じゃだめ？\n\t/*if (i == 0) { return INF; }\n\tif (memo[i] != -1) { return memo[i]; }\n\telse {\n\t\tif (i == N - 1) {\n\t\t\treturn memo[i] = std::min((x[i] - x[i - 1]) + T, (x[i] - x[i - 1]) + dp(i - 1));\n\t\t}\n\t\treturn memo[i] = std::min((x[i] - x[i - 1]) + T, std::min((x[i + 1] - x[i]) + dp(i + 1), (x[i] - x[i - 1]) + dp(i - 1)));\n\t}*/\n\n\t// とにかくループ\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (i == N - 1) { dp[i] = std::min((x[i] - x[i - 1]) + T, (x[i] - x[i - 1]) + dp[i - 1]); }\n\t\telse { dp[i] = std::min((x[i] - x[i - 1]) + T, std::min((x[i + 1] - x[i]) + dp[i + 1], (x[i] - x[i - 1]) + dp[i - 1])); }\n\t}\n\n\treturn dp[N - 1];\n}\n\nint main(void) {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 0; i < N; ++i) { scanf(\"%d\", &x[i]); }\n\n\tfor (int i = 0; i < N; ++i) { memo[i] = -1; }\n\n\tprintf(\"%d\\n\", do_dp() + (E - (x[N - 1])));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <ll> vi;\ntypedef pair <ll, ll> pi;\ntypedef vector <pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) (ll) x.size()\n#define f first\n#define s second\n#define MAXN 100100\nll INF = 1e18;\ndeque<pi> dq;\nll max_constant;\nll N,E,T;\nll off;\nll D[MAXN];\nll dp[MAXN];\nll d2[MAXN];\nqueue<pi> Q;\nmultiset<ll> S2;\nll X[MAXN];\n \nint main(){\n\tcin>>N>>E>>T;\n\tfor (int i=1;i<=N;++i)cin>>D[i];\n\t// X[0] = 0;\n\t// for (int i=1;i<=N;++i){\n\t// \tX[i] = INF;\n\t// \tfor (int j=0;j<i;++j){\n\t// \t\tX[i] = min(X[i], X[j] + D[i] - D[j] + max(T, 2*D[i] - 2*D[j+1]) );\n\t// \t}\n\t// }\n\n\tmax_constant = INF;\n\tQ.push(mp(T+2*D[1], 2*D[1]));\n\tS2.insert(T+4*D[1]);\n \n\tfor (int i=1;i<=N;++i){\n\t\twhile (SZ(Q) && Q.front().f <= 2*D[i]){\n\t\t\tpi cur = Q.front();Q.pop();\n\t\t\tmax_constant = min(max_constant, cur.s);\n\t\t\tS2.erase(S2.find(cur.f+cur.s));\n\t\t}\n\t\t// cout<<max_constant<<'\\n';\n\t\tdp[i] = INF;\n\t\t// Case 1 is using the constant\n\t\tdp[i] = min(dp[i], 3*D[i]+max_constant);\n\t\t// Case 2: is waiting\n\t\tdp[i] = min(dp[i], T + D[i] - D[i-1] + dp[i-1]);\n\t\t// Case 3: Need to wait\n\t\tif (SZ(S2))dp[i] = min(dp[i], *S2.begin() + D[i]);\n\t\t// cout<<i<<' '<<-2*D[i+1]<<' '<<D[i]<<' '<<dp[i]<<' '<<-2*D[i+1] - D[i]+ dp[i]<<'\\n';\n\t\tQ.push(mp(T+2*D[i+1], -2*D[i+1] - D[i]+ dp[i]));\n\t\tS2.insert(T-D[i]+dp[i]);\n\t\t// cout<<\"Ins \"<<T-D[i]+dp[i]<<'\\n';\n\t\t// cout<<X[i]<<' '<<dp[i]<<'\\n';\n\t\t// assert(dp[i] == X[i]);\n\t}\n\tcout<<dp[N] + E-D[N];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint p[100001],s[100001],a[100001];\nlong long f[100001];\nbool cj(int x,int y,int z){\n\treturn 1ll*(x-z)*(p[y]-p[z])>=1ll*(y-z)*(p[x]-p[z]);\n}\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<=n;a[i]=s[s[0]],s[++s[0]]=i++)\n\t\tfor(;s[0]>1&&cj(i,s[s[0]],s[s[0]-1]);s[0]--);\n\ta[1]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tf[i]=min(t+f[i-1],max(t,2*(p[i]-p[a[i]]))+f[a[i]-1]);\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n+1,0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvl dp(n+1,INF);\n\tdp[0] = e;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tfor (int j =0; j<i; j++) {\n\t\t\tmi = min(mi, dp[j]+max(t, 2 * (x[i]-x[j+1])));\n\t\t}\n\t\tdp[i] = mi;\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconstexpr LL INF = 1e18;\nLL dp[2001], wt[2001];\nLL N, T, E;\nLL x[2001];\n\nint main() {\n    scanf(\"%lld %lld %lld\", &N, &E, &T);\n    for(int i = 1; i<=N; ++i) scanf(\"%lld\", x+i);\n    dp[1] = x[1]+T;\n    wt[1] = T;\n    for(int i = 2; i<=N; ++i) {\n        LL mn = INF;\n        int mnj;\n        //LL mn = dp[i-1]+x[i]-x[i-1]+T;\n        for(int j = 1; j<i; ++j) {\n            //cerr << i << \" \" << mn << endl;\n            LL val = max(0LL, T-2*(x[i]-x[j]))*(j-i+1)+3*(x[i]-x[j])+dp[j]-wt[j];\n            if( val < mn ) mn = val, mnj = j;\n        }\n        if( mn < dp[i-1]+x[i]-x[i-1]+T ) wt[i] = max(0LL, T-2*(x[i]-x[mnj]));\n        else {\n            wt[i] = T;\n            mn = dp[i-1]+x[i]-x[i-1]+T;\n        }\n        //cerr << i << \" \" << mn << \" \" << wt[i] << endl;\n        dp[i] = mn;\n    }\n    printf(\"%lld\\n\", dp[N]+E-x[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<=n; j++){\n      dp[j] = min(dp[j], dp[i] + max(t, 2*(x[j-1] - x[i])) );\n    }\n  }\n\n  println(dp[n] + e);\n\n  //println(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPD(i, a, b) for(int i = a; i >= b; -- i)\n# define REPG(i, h, x) for(int i = h[x]; ~i; i = edge[i].next)\n\nconst int N = 1e5 + 5;\ntypedef long long LL;\n\nint q[N], he, ta;\nint n, t, e, var;\nLL d[N], f[N];\n\n# define gc getchar\ninline int rd() {\n\tchar ch = gc();int ret = 0;\n\twhile(ch < '0' || ch > '9') ch = gc();\n\twhile(ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = gc();\n\treturn ret;\n}\n\nvoid solve() {\n\tCLR(f, -1);\n\tint lm = 0;\n\tf[0] = 0;\n\tvar = -1;\n\the = 1;\n\tq[++ ta] = 0;\n\tREP(i, 1, n) {\n\t\twhile(he <= ta && (d[i] - d[q[he] + 1]) * 2 >= t) ++ he;\n\t\tfor(lm; lm < q[he]; ++ lm) if(var == -1 || (f[lm] - 2 * d[lm + 1] < f[var] - 2 * d[var + 1])) var = lm;\n\t\tif(~var) f[i] = f[var] + 2 * (d[i] - d[var + 1]);//, printf(\"1[%d %d+%d], \", var, f[var], 2 * (d[i] - d[var + 1])); \n\t\tif(he <= ta) { \n\t\t\tif(~f[i]) f[i] = min(f[i], f[q[he]] + t);\n\t\t\telse f[i] = f[q[he]] + t;\n//\t\t\tprintf(\"2[%d %d],\", q[he], f[q[he]]);\n\t\t}\n\t\twhile(he <= ta && f[q[ta]] > f[i]) -- ta;\n\t\tq[++ ta] = i; \n//\t\tprintf(\"%lld\\n\", f[i]);\n\t}\n\tprintf(\"%lld\\n\", e + f[n]);\n}\n\nint main() {\n\tn = rd(), e = rd(), t = rd();\n\tREP(i, 1, n) d[i] = rd();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint E, T; cin >> E >> T;\n  V<lint> x(n); for (auto&& e : x) cin >> e;\n  lint p = 0;\n  int i = 0;\n  lint res = 0;\n  while (true) {\n    res += x[i] - p;\n    p = x[i];\n    while (i + 1 < n and x[i + 1] <= x[i] + T) ++i;\n    lint d = x[i] - p;\n    res += 3 * d + max<lint>(T - 2 * d, 0);\n    p = x[i];\n    if (++i == n) break;\n  }\n  res += E - p;\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tfz(i,1,n){\n\t\tint mn=0x3f3f3f3f3f3f3f3fll;\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n//\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\tmn=min(mn,dp[j]+a[i]-a[j]+2*(a[i]-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n//\t\tcout<<\"mn=\"<<mn<<endl;\n\t\tdp[i]=min(dp[i],dp[q.front()]+a[i]-a[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn);\n//\t\tcout<<dp[i]<<endl;\n\t\twhile(!q.empty()&&dp[q.back()]-a[q.back()]>dp[i]-a[i])\tq.pop_back();\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+abs(a[n]-E)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> VL;\n\ntemplate <class I, class BiOp> class SegmentTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\n\npublic:\n  typedef int size_type;\n  typedef I value_type;\n  SegmentTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_)\n      n *= 2; // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  /* http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/\n   * [a, b)\n   */\n  I query(int a, int b) const {\n    I left = e;\n    I right = e;\n    a += n - 1;\n    b += n - 1;\n    while (a < b) {\n      if ((a & 1) == 0) {\n        left = op(left, dat[a]);\n      }\n      if ((b & 1) == 0) {\n        right = op(dat[b - 1], right);\n      }\n      a = a / 2;\n      b = (b - 1) / 2;\n    }\n    return op(left, right);\n  }\n  I operator[](int idx) const {\n    return dat[idx + n - 1];\n  }\n};\n\n\nconst int N = 200100;\nconst ll inf = 1e16;\n\nstruct min_fun {\n  ll operator()(ll x, ll y) const {\n    return min(x, y);\n  }\n};\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  VL x(n);\n  SegmentTree<ll, min_fun> raw(n + 1, min_fun(), inf); // dp[i]\n  SegmentTree<ll, min_fun> boiled(n + 1, min_fun(), inf); // dp[i] - 2 * x[i]\n  REP(i, 0, n) {\n    cin >> x[i];\n  }\n  raw.update(0, 0);\n  boiled.update(0, -2 * x[0]);\n  REP(i, 0, n) {\n    // Compute the range of j s.t. t <= 2 * (x[i] - x[j]) (0 <= j <= i)\n    int j_boundary =\n      upper_bound(x.begin(), x.begin() + i + 1, x[i] - (t+1)/2) - x.begin();\n    ll ret = inf;\n    ret = min(ret, boiled.query(0, j_boundary) + 2 * x[i]);\n    ret = min(ret, raw.query(j_boundary, i + 1) + t);\n    raw.update(i + 1, ret);\n    if (i < n - 1) {\n      boiled.update(i + 1, ret - 2 * x[i + 1]);\n    }\n  }\n  cout << raw[n] + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define qwq(x) cerr<<\" #\"<<#x<<\" = \"<<x<<endl;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005;\nll f[N],g[N],x[N],E,T;\nint n;\n\nint main(){\n\tread(n),read(E),read(T);\n\trep(i,1,n)read(x[i]);\n\tmemset(f,0x3f,sizeof f);\n\tmemset(g,0x3f,sizeof g);\n\tf[0]=0;\n\trep(i,1,n){\n\t\tint t=lower_bound(x+1,x+n+1,x[i]+(T+1)/2)-x;\n//\t\tprintf(\"%d  ->  %d\\n\",i-1,t);\n\t\tg[t]=min(g[t],f[i-1]+x[i]-x[i-1]+3ll*(x[t]-x[i]));\n\t\tf[t-1]=min(f[t-1],f[i-1]+x[i]-x[i-1]+T+(x[t-1]-x[i]));\n\t\tg[i]=min(g[i],g[i-1]+3ll*(x[i]-x[i-1]));\n\t\tf[i]=min(f[i],g[i]);\n//\t\tprintf(\"%d   %lld  %lld\\n\",i,f[i],g[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-x[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// <<<<GOD>>>> lET'S gO\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll N = 1e5 + 100, inF = 1e15;\n\nll n, e, t, mini = inF, a[N], dp[N];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile(2 * (a[i] - a[p]) > t) {\n\t\t\tmini = min(mini, dp[p - 1] - 2 * a[p]);\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = dp[p - 1] + t;\n\t\tdp[i] = min(dp[i], 2 * a[i] + mini);\n\t}\n\tcout << e + dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nconstexpr ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n, e, t; scanf(\"%d%d%d\", &n, &e, &t);\n    vector<int> x(n); repeat (i, n) scanf(\"%d\", &x[i]);\n    // solve\n    vector<ll> dp(n + 1, inf);\n    dp[n] = e;\n    int m = n;\n    ll acc = inf;\n    repeat_reverse (l, n) {\n        for (; m - 1 >= l + 1 and t <= 2ll * (x[m - 1] - x[l]); -- m) {\n            setmin(acc, 2ll * x[m - 1] + dp[m]);\n        }\n        dp[l] = min(acc - 2ll * x[l], t + dp[m]);\n    }\n    // output\n    printf(\"%lld\\n\", dp[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+8000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*+lmake\n * STD = c++14\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#ifdef WAAUTOMATON\n     #define debug(args...)            {dbg,args; cerr<<endl;}\n#else\n    #define debug(args...)              // Just strip off all debug tokens\n#endif\n\nstruct debugger\n{\n    template<typename T> debugger& operator , (const T& v)\n    {    \n        cerr<<v<<\" \";    \n        return *this;    \n    }\n} dbg;\n#define MAXN 100000\nLL f[MAXN+10],g[MAXN+10];\nvoid solve(long long n, long long e, long long t, vector<long long> x){\n\tg[n+1]=LLONG_MAX/3;\n\tint j=n;\n\tfor(int i=n; i>=1; --i) {\n\t\twhile(2*(x[j-1]-x[i-1])>t) --j;\n\t\tf[i]=min(f[j+1]+t,g[j+1]-2*x[i-1]);\n\t\tg[i]=min(g[i+1],f[i+1]+2*x[i-1]);\n\t}\n\tcout<<f[1]+e<<endl;\n}\n\nint main(){\t\n#ifdef WAAUTOMATON\n\t//freopen(\"in.txt\",\"r\",stdin);\n#endif\n\tlong long T;\n\tlong long E;\n\tlong long N;\n\tscanf(\"%lld\",&N);\n\tvector<long long> x(N-1+1);\n\tscanf(\"%lld\",&E);\n\tscanf(\"%lld\",&T);\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tsolve(N, E, T, x);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]));\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\t/*for (int x=now+1; x<=n&&x-now<=500; ++x){\n\t\t\tlong long tmp=0;\n\t\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t\t}\n\t\t\telse f[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}*/\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, E, T, r;\nint a[maxn];\nll Min1, Min2 = 1e18, f[maxn];\nint main()\n{\n\tmultiset<ll> S; \n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tS.insert(0);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\twhile((a[i] - a[r + 1]) * 2 >= T)\n\t\t{\n\t\t\tMin2 = min(Min2, f[r] - 2 * a[r + 1]);\n\t\t\tS.erase(S.find(f[r]));\n\t\t\t++r;\n\t\t}\n\t\tf[i] = min(Min1 + 1ll * i * T, Min2 + 2 * a[i]);\n\t\tif(!S.empty()) f[i] = min(f[i], *S.begin() + T);\n\t\tMin1 = min(Min1, f[i] - 1ll * i * T);\n\t\tS.insert(f[i]); \n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int> t;\n\tint pre_x, x, pre_t;\n\tpre_x = 0;\n\tlong long ans = E;\n\tcin >> pre_x;\n\tans += T;\n\tpre_t = T;\n\tfor(int i=1;i<N;i++){\n\t\tcin >> x;\n\t\tif(x - pre_x >= T){\n\t\t\tans += T;\n\t\t\tpre_x = x;\n\t\t\tpre_t = T;\n\t\t}else{\n\t\t\tans-=pre_t;\n\t\t\tpre_t = max(T, 2*(x-pre_x));\n\t\t\tans+=pre_t;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nvector<int> tree;\nint N = 1;\n\nvoid upd(int v) {\n\tif(v == 0) \n\t\treturn;\n\ttree[v] = max(tree[v * 2], tree[v * 2 + 1]);\n\tupd(v / 2);\n}\n\nint get(int v, int l, int r, int vl, int vr) {\n\tif(vr <= l || r <= vl)\n\t\treturn inf;\n\tif(vl <= l && r <= vr) {\n\t\treturn tree[v];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(get(v * 2, l, m, vl, vr), get(v * 2 + 1, m, r, vl, vr));\n}\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\n\twhile(N < (n + 2)) \n\t\tN *= 2;\n\n\ttree = vector<int> (2 * N, inf);\n\tvector<int> suf(n + 1, inf);\n\tsuf[n - 1] = k;\n\tint uk = n - 2;\n\ttree[N + (n - 2)] = k + a[n - 1] + suf[n - 1];\n\tupd((N + (n - 2)) / 2);\n\n\tfor (int i = n - 2; i >= 0; i--) {\n\n\t\twhile(uk > 0 && 2 * (a[uk] - a[i]) >= k) {\n\t\t\ttree[N + uk] = 2 * a[uk] + a[uk + 1] + suf[uk + 1];\n\t\t\tupd((N + (uk - 1)) / 2);\n\t\t\tuk--;\n\t\t}\n\t\tint ans = max(k, 2 * (a[n - 1] - a[i])) + (a[n - 1] - a[i]);\n\t\tint l = i, r = n + 1;\n\t\twhile(r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(2 * (a[m] - a[i]) < k) \n\t\t\t\tl = m;\n\t\t\telse\n\t\t\t\tr = m;\n\t\t}\n\t\t// cout << ans << \" \" << i << \" \" << l << \" \" << get(1, 0, N, i, l + 1) << \" \" << uk << endl;\n\t\tans = min(ans, get(1, 0, N, i, l + 1) - a[i]);\n\t\tif(r <= n - 2) {\n\t\t\tans = min(ans, get(1, 0, N, l + 1, r + 1) - 3 * a[i]);\n\t\t}\n\t\tsuf[i] = ans;\n\t\tif(i != 0) {\n\t\t\ttree[N + (i - 1)] = k + a[i] + suf[i];\n\t\t\tupd((N + (i - 1)) / 2);\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}\n\n// j\n\n// "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,t,w;\nlong long dp[2500];\nint x[2500];\nint main(){\n\tcin>>n>>w>>t;\n\tdp[0]=0,x[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i+1];\n\t\tdp[i+1]=1145141919810;\n\t}\n\tfor(int len=1;len<n;len++){\n\t\tfor(int org=0;org<=n-len;org++){\n\t\t\tdp[len+org]=dp[org]+min(2*(x[org+len]-x[org]),t)+min(x[org+len],t);\n\n\t\t}\n\t}\n\tcout<<dp[n]+w-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define INF 0x3FFFFFFF\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN],pos[MAXN],m,t,pre=INF;\npriority_queue<pair<ll,int> > q;\nint n;\nint main(){\n\tSF(\"%d%lld%lld\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%lld\",&pos[i]);\n\tq.push(make_pair(0,0));\n\tint las=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]+t+pos[i]-pos[i-1];\n\t\twhile(1){\n\t\t\tpair<ll,int> x=q.top();\n\t\t\tif(2ll*(pos[i]-pos[x.second+1])<=t){\n\t\t\t\tdp[i]=min(dp[i],-x.first+pos[i]+t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\twhile(2ll*(pos[i]-pos[las+1])>t){\n\t\t\tpre=min(pre,dp[las]-pos[las]-2ll*pos[las+1]);\n\t\t\tlas++;\n\t\t}\n\t\tif(pre!=INF)\n\t\t\tdp[i]=min(dp[i],pre+3ll*pos[i]);\n\t\tq.push(make_pair(-dp[i]+pos[i],i));\n\t}\n\tPF(\"%lld\",dp[n]+m-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define pii pair<int,int>\n#define iiii pair<int,pii >\n#define ld double \n#define MAXN 100100\n#define inf 1000000000000000000ll\nusing namespace std;\n\nll treeA[4*MAXN],treeB[4*MAXN],Dp[MAXN],e,t,a[MAXN],b[MAXN];\nint n,p[MAXN],m;\n\nvoid fModify(int x,ll y,ll tree[])\n{\n\tx+=m-1;\n\ttree[x]=y;\n\twhile(x>0)\n\t{\t\n\t\tx=(x-1)/2;\n\t\ttree[x]=min(tree[2*x+1],tree[2*x+2]);\n\t}\n}\n\nvoid fInit()\n{\n\ta[0]=0;\n\tDp[0]=0;\n\tn++;m=1;\n\twhile (m<n)m*=2;\n\tfModify(0,0,treeA);\n\tfModify(0,-2*a[1],treeB);\n}\n\nll fQuery(int x,int y,int l,int r,int k,ll tree[])\n{                       \n\tif(x>=y)return inf;\n\tif(l>=y||r<=x)return inf;\n\tif(x<=l&&r<=y)return tree[k];\n\telse\n\t{\n\t\tint mid=(l+r)/2;\n\t\tll lx=fQuery(x,y,l,mid,2*k+1,tree);\n\t\tll ly=fQuery(x,y,mid,r,2*k+2,tree);\n\t\treturn min(lx,ly);\n\t}\n}\n\nvoid fChange(int x)\n{\n\tDp[x]+=a[x];\n\tint P=p[x];                        \n\tll res1=fQuery(0,P,0,m,0,treeB)+b[x];\n\tll res2=fQuery(max(P,0),x,0,m,0,treeA)+t;\n\n\tDp[x]+=min(res1,res2);\n\tfModify(x,Dp[x]-a[x],treeA);\n\t\n\tfModify(x,Dp[x]-a[x]-a[x+1]*2,treeB);\n}\n\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",a+i);\n\t\n\tfInit();\n\tfor(int i=0;i<n;i++)b[i]=2*a[i];\n\tfor(int i=1;i<n;i++)p[i]=lower_bound(b,b+i+1,b[i]-t)-b-1;\n\tfor(int i=1;i<n;i++)fChange(i);//cout<<Dp[i]<<\" \"<<i<<endl;\n\t\n\t \n\tprintf(\"%lld\\n\",Dp[n-1]-a[n-1]+e);\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std; \nlong long x[100008],dp[100008];long long t,e;\nvoid update(long long i,long long j)\n{\n\tdp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n}\nint main()\n{\n\tlong long n;cin>>n;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i];for(long long i=0;i<100005;i++) dp[i]=2e9;x[n+1]=2e9;\n\tdp[0]=0;long long j=0;long long mst=2e9,msi=0;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tupdate(i,i-1);\n\t\twhile((x[i]-x[j+1])*2>t and j<i-1)\n\t\t{\n\t\t\tj++;long long tt=dp[j]+2*(x[n+1]-x[j+1]);\n\t\t\tif(tt<mst) mst=tt,msi=j;\n\t\t}\n\t\tupdate(i,j);\n\t\tupdate(i,msi);\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int M = 100100;\n\nint n;\nll t, e;\nll x[M], d[M];\n\nvoid read() {\n  cin >> n >> e >> t;\n  x[0] = 0;\n  for (int i = 1; i <= n; ++i)\n    cin >> x[i];\n}\n\n\nvoid kill() {\n  d[0] = 0;\n  int l = 0;\n  ll mn = 0;\n  for (int i = 1; i <= n; ++i) {\n    d[i] = d[i - 1] + t;\n    for (int j = 0; j < i; ++j)\n      d[i] = min(d[i], d[j] + max(t, 2 * (x[i] - x[j + 1])));\n    continue;\n    while (l < i && 2 * (x[i] - x[l + 1]) >= t) {\n      mn = min(mn, d[l] + 2 * (x[i] - x[l + 1]));\n      ++l;\n    }\n    d[i] = min(d[i], mn + 2 * x[i]);\n  }\n\n  ll ans = d[n] + e;\n  \n  cout << ans << endl;\n}\n\nint main() {\n  cout.precision(20);\n  cout << fixed;\n  ios_base::sync_with_stdio(false);\n  read();\n  kill();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T>\nostream& operator<<(ostream& o, vector<T>& v) {\n    for (auto& x : v) o << x << ' ';\n    return o;\n}\nconst int MAXN = 100010;\nll n, T, E;\n\nll arr[MAXN];\n\nll memo_small[MAXN];\nll dp_small(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo_small[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    res = LLONG_MAX/2;\n    for (int i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        ll cur = pre + max(2LL * d, T) + d + dp_small(i + 1);\n        if (cur < res) res = cur;\n    }\n    return res;\n}\n\nvoid solve_small(){\n    memset(memo_small, -1, sizeof memo_small);\n    ll res = dp_small(0);\n    cout << res << endl;\n}\n\nll memo[MAXN];\nll dp(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    int i;\n    for (i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        if (2LL * d > (i - id + 1) * T) break;\n    }\n    ll d = arr[i-1] - arr[id];\n    res = pre + max(2LL * d, T) + d + dp(i);\n    return res;\n}\nvoid solve_large(){\n    memset(memo, -1, sizeof memo);\n    ll res = dp(0);\n    cout << res << endl;\n}\n\nint main(){\n    std::ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> E >> T;\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    if (n <= 2000) solve_small();\n    else solve_large();\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint32_t main() {\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tint a[n + 10], dp[n + 10] = {};\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tset <pair <int, int>> st1 = {{t - a[0] + dp[0], 0}};\n\tint st3 = 1ll << 60, ptr = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (ptr < i && 2 * (a[i] - a[ptr + 1]) >= t) {\n\t\t\tst3 = min(st3, -(2 * a[ptr + 1] + a[ptr]) + dp[ptr]);\n\t\t\tst1.erase({t - a[ptr] + dp[ptr], ptr});\n\t\t\tptr++;\n\t\t}\n\t\tdp[i] = min(st3 + 3 * a[i], st1.size()? st1.begin() -> first + a[i]: 1ll << 60);\n\t\tst1.insert({t - a[i] + dp[i], i});\n\t}\n\tcout << e - a[n] + dp[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i, m, n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(x) begin(x), end(x)\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n, e, t; scanf(\"%d%d%d\", &n, &e, &t);\n    vector<int> x(n); repeat (i, n) scanf(\"%d\", &x[i]);\n    x.push_back(e);\n    vector<ll> dp(n + 1, inf);\n    dp[n] = 0;\n    repeat_reverse (l, n) {\n        repeat_from (r, l + 1, n + 1) {\n            setmin(dp[l], max<ll>(t, 2ll * (x[r - 1] - x[l])) + (x[r] - x[l]) + dp[r]);\n        }\n    }\n    // output\n    printf(\"%lld\\n\", x[0] + dp[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005],ml[100005];\nmultiset<ll> s;\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tml[0]=mem[0]-x[0]-x[1]-x[1];\n\tint cur=1;\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=max(t,x[i]-x[0]+x[i]-x[0])+x[i];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tif (i>1) {\n\t\t\twhile(x[i]-x[cur+1]+x[i]-x[cur+1]>t) {\n\t\t\t\ts.erase(s.find(mem[cur]-x[cur]));\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\t//printf(\"i = %d, cur = %d\\n\", i,cur);\n\t\t\t//for (ll x:s) printf(\"%lld \", x);\n\t\t\t//printf(\"\\n\");\n\t\t\t//printf(\"%d: %lld\\n\", i,mem[i]);\n\t\t\tif (cur>1 || x[i]-x[1]+x[i]-x[1]>t) mem[i]=min(mem[i],ml[min(cur,i-1)-1]+3ll*x[i]);\n\t\t\telse mem[i]=min(mem[i],mem[0]+t+x[i]-x[0]);\n\t\t\t//printf(\"%d: %lld\\n\", i,mem[i]);\n\t\t\tif (!s.empty()) mem[i]=min(mem[i],(*s.begin())+t+x[i]);\n\t\t\t//printf(\"%d: %lld\\n\", i,mem[i]);\n\t\t}\n\t\tml[i]=min(ml[i-1],mem[i]-x[i]-x[i+1]-x[i+1]);\n\t\ts.insert(mem[i]-x[i]);\n\t\t//printf(\"%d: %lld\\n\", i,mem[i]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll n,t,e;\nll ans;\nll xx[maxn];\ninline ll max(ll aa,ll bb){\n\tif (aa>bb)return aa;\n\telse return bb;\n}\nint main(){\n\tll b1,b2,b3,b4,b5;\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\txx[n+1]=e;\n\tans=xx[1];\n\tb1=1;\n\twhile (b1<=n){\n\t\tb2=b1;\n\t\tif ((b2+1<=n)&&((xx[b2+1]-xx[b2])<=t)){\n\t\t\tb2++;\n\t\t}\n\t\twhile ((b2+1<=n)&&((xx[b2+1]-xx[b2])*2<=t)){\n\t\t\tb2++;\n\t\t}\n\t\tans+=max((xx[b2]-xx[b1])*2,t)+(xx[b2+1]-xx[b1]);\n\t\tb1=b2+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 200007;\nconst int K = 5000;\nint dp[N], x[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; i++){\n        cin >> x[i];\n    }\n    dp[n] = e - x[n] + t;\n    x[n + 1] = e;\n    for (int i = n - 1; i >= 1; i--){\n        dp[i] = 1e15;\n        for (int j = i; j <= n; j++){\n            dp[i] = min(dp[i], 3 * (x[j] - x[i]) + x[j + 1] - x[j] + dp[j + 1] + max(t - 2 * x[j] + 2 * x[i], 0LL));\n        }\n    }\n    cout << x[1] + dp[1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nint T;\nint a[maxn]; \nlong long f[maxn];\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    for (int j=0;j<=i-2;j++)\n      {   \n        long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-2*(a[i]-a[j+1]),0)+2*(a[i]-a[j+1]));\n      }\n    }  \n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\npublic:\n    segtree(const vector<T>& v) : n(1), sz((int)v.size()), h(0){\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, numeric_limits<T>::max());\n        lazy_update.resize(2*n, 0); lazyFlag.resize(2*n, false);\n        lazy_add.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i=n-1; i>=1; i--) node[i] = min(node[2*i],node[2*i+1]);\n    }\n    void eval(int k) {\n        if(lazyFlag[k]){\n            lazy_update[k] += lazy_add[k];\n            node[k] = lazy_update[k];\n            if(k < n) {\n                lazy_add[2*k] = lazy_add[2*k+1] = 0;\n                lazy_update[2*k] = lazy_update[2*k+1] = lazy_update[k];\n                lazyFlag[2*k] = lazyFlag[2*k+1] = true;\n            }\n            lazy_add[k] = 0, lazyFlag[k] = false;\n        }else if(lazy_add[k] != 0){\n            node[k] += lazy_add[k];\n            if(k < n){\n                lazy_add[2*k] += lazy_add[k]; lazy_add[2*k+1] += lazy_add[k];\n            }\n            lazy_add[k] = 0;\n        }\n    }\n    void update(int a, int b, T x, int k=1, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true; eval(k);\n        }else{\n            update(a, b, x, 2*k, l, (l+r)/2); update(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = min(node[2*k],node[2*k+1]);\n        }\n    }\n    void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy_add[k] += x; eval(k);\n        }else{\n            add(a, b, x, 2*k, l, (l+r)/2); add(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = min(node[2*k],node[2*k+1]);\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = numeric_limits<T>::max(), res2 = numeric_limits<T>::max();\n        while(a < b) {\n            if(a & 1) eval(a), res1 = min(res1, node[a++]);\n            if(b & 1) eval(--b), res2 = min(res2, node[b]);\n            a >>= 1, b >>= 1;\n        }\n        return min(res1, res2);\n    }\n    void print(){\n        for(int i = 0; i < sz; i++){\n            cout<<query(i,i+1)<< \" \";\n        }\n        cout<<endl;\n    }\n};\n\n\nint main(){\n    ll n,e,t;\n    cin >> n >> e >> t;\n    //if(n>=2001)return 0;\n    vector<ll> a(n+1);\n    a[0] = 0;\n    rep(i,n){\n        cin >> a[i+1];\n    }\n    a.push_back(e);\n    n+=2;\n    vector<ll>dp(n,1LL<<60);\n    segtree<ll> sg(dp);\n    int p = 0;\n    rep(i,n-1){\n        if(i==0){\n            sg.update(0,1,a[1]-a[0]);\n            continue;\n        }\n        ll k = sg.query(0,i);\n        //k += a[i+1]-a[i];\n        sg.update(i,i+1,k+t);\n        \n        // rep(j,i-1){\n        //     dp[i] = min(dp[i],dp[j]+(a[j+1]-a[j])+max(3*(a[i]-a[j+1]),t+(a[i]-a[j+1])));\n        // }\n        sg.add(0,p,3*(a[i+1]-a[i]));\n        sg.add(p,i+1,(a[i+1]-a[i]));\n        while(1){\n            if(3*(a[i+1]-a[p+1]) > t+(a[i+1]-a[p+1])){\n                sg.add(p,p+1,-(t+(a[i+1]-a[p+1])));\n                sg.add(p,p+1,3*(a[i+1]-a[p+1]));\n                p++;\n            }else{\n                break;\n            }\n        }\n        cerr << p << endl;\n        // if(i!=n-1){\n        //     dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]+t);\n        //     k = min(k,sg.query(i-1,i)+a[i]-a[i-1]+t);\n        // }else{\n        //     dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]);    \n        // }\n        //sg.print();\n    }\n    cout << sg.query(n-2,n-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,t,x[100005],dp[100005];\nmultiset<long long>s;\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&m,&t);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&x[i]);\n\tdp[0]=0;\n\tlong long mn=1e18,pos=1;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i&&2*(x[i]-x[pos])>t)\n\t\t{\n\t\t\tmn=min(mn,dp[pos-1]-2*x[pos]);\n\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\tpos++;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mn+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n;\nll T,E,pos[100111];\nll dp[100111];\npair<ll,int> q[100111];\nint qb,qe;\nvoid add(int id)\n{\n\twhile(qe>qb&&q[qe-1].FF<=dp[id])qe--;\n\tq[qe++]=MP(dp[id],id);\n}\nvoid del(int id)\n{\n\tif(qb<qe&&q[qb].SS==id)qb++;\n}\nint main()\n{\n\tint tmp;\n\tgetiii(n,tmp,T);\n\tfor(int i=1;i<=n;i++)geti(pos[i]),pos[i]*=2;\n\tll mn=1ll*mod*mod;\n\tint it=-1;\n\tadd(0);\n\tfor(int i=1;i<=n;i++)\n\t{\n//\t\tcerr<<\"i=\"<<i<<endl;\n\t\twhile(pos[i]-pos[it+2]>T)\n\t\t{\n\t\t\tit++;del(it);\n\t\t\tmn=min(mn,dp[it]-pos[it+1]);\n\t\t}\n//\t\tcerr<<\"it=\"<<it<<\" mn=\"<<mn<<endl;\n\t\tdp[i]=mn+pos[i];\n//\t\tcerr<<\"dp=\"<<dp[i]<<endl;\n\t\tif(qb<qe)dp[i]=min(dp[i],q[qb].FF+T);\n\t\tadd(i);\n\t}\n\tcout<<dp[n]+tmp<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b), 1 : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b), 1 : 0)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n\n#define maxn 100010\n#define lowbit(_x) ((_x) & (-(_x)))\ntypedef long long ll;\ntypedef double db;\n\nconst ll inf = 0x7ffffffffff;\nll f[maxn];\nint x[maxn], hash[maxn], hcnt;\nll tr1[maxn], tr2[maxn];\nvoid modify1(int pos, ll val)\n{\n\tfor (; pos <= hcnt; pos += lowbit(pos)) cmin(tr1[pos], val);\n}\nvoid modify2(int pos, ll val)\n{\n\tfor (; pos; pos -= lowbit(pos)) cmin(tr2[pos], val);\n}\nll query1(int pos)\n{\n\tll ret = inf;\n\tfor (; pos; pos -= lowbit(pos)) cmin(ret, tr1[pos]);\n\treturn ret;\n}\nll query2(int pos)\n{\n\tll ret = inf;\n\tfor (; pos <= hcnt; pos += lowbit(pos)) cmin(ret, tr2[pos]);\n\treturn ret;\n}\nint main()\n{\n\tint n, E, T; scanf(\"%d%d%d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\tfor (int i = 0; i <= n; ++i) hash[++hcnt] = 2 * x[i];\n\n\tmemset(tr1, 63, sizeof (tr1));\n\tmemset(tr2, 63, sizeof (tr2));\n\tf[0] = 0;\n\tmodify1(2, -2 * x[1]);\n\tmodify2(2, 0);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = inf;\n\n\t\tint pos = std::upper_bound(hash + 1, hash + hcnt + 1, 2 * x[i] - T) - hash - 1;\n//\t\tprintf(\"pos %d\\n\", pos);\n\t\tll tmp = query1(pos) + 3ll * x[i];\n\t\tcmin(f[i], tmp);\n//\t\tprintf(\"tmp %lld\\n\", tmp);\n\n\t\tpos = std::lower_bound(hash + 1, hash + hcnt + 1, 2 * x[i] - T) - hash;\n//\t\tprintf(\"pos %d\\n\", pos);\n\t\ttmp = query2(pos) + T + x[i];\n\t\tcmin(f[i], tmp);\n//\t\tprintf(\"tmp %lld\\n\", tmp);\n\t\t\n\t\tmodify1(i + 2, f[i] - 2ll * x[i + 1] - x[i]);\n\t\tmodify2(i + 2, f[i] - x[i]);\n\t\t\n//\t\tprintf(\"f[%d] = %lld\\n\", i, f[i]);\n\t}\n\tprintf(\"%lld\\n\", f[n] + E - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t;\nll dp[maxn];\nint x[maxn],y[maxn];\nclass segtree{\npublic:\n\tll tree[maxn*4];\n\tint leaf[maxn];\n\tvoid build(int l,int r,int node){\n\t\tif(l==r){\n\t\t\tleaf[l]=node;\n\t\t\ttree[node]=Inf;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,node*2);\n\t\tbuild(mid+1,r,node*2+1); \n\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t}\n\tvoid upd(int node,ll val){\n\t\tnode=leaf[node];\n\t\ttree[node]=val;\n\t\tnode>>=1;\n\t\twhile(node){\n\t\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t\t\tnode>>=1;\n\t\t}\n\t}\n\tll query(int l,int r,int vl,int vr,int node){\n\t\tif(r<l||vr<vl)return Inf;\n\t\tif(l>vr||r<vl)return Inf;\n\t\tif(l>=vl&&r<=vr)return tree[node];\n\t\tint mid=(l+r)>>1;\n\t\treturn min(query(l,mid,vl,vr,node*2),query(mid+1,r,vl,vr,node*2+1));\n\t}\n}t1,t2;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]),y[i]=2*x[i];\n\tt1.build(0,n-1,1);\n\tt2.build(0,n-1,1);\n\trep(i,n){\n\t\tdp[i]=max((x[i]-x[0])*2LL,1LL*t);\n\t\tint pos=lower_bound(y,y+n,2*x[i]-t)-y;\n\t\tdp[i]=min(dp[i],min(t1.query(0,n-1,0,pos-2,1)+2LL*x[i],t2.query(0,n-1,max(pos-1,0),n-1,1)+t));\n\t\tt1.upd(i,dp[i]-2LL*x[i+1]);\n\t\tt2.upd(i,dp[i]);\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n          #define int long long\n            #define inf  1000000007\n            #define pa pair<int,int>\n    #define ll long long\n            #define pal pair<ll,ll>\n            #define ppa pair<int,pa>\n            #define  mp make_pair\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     \n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \n            //----------------kokomade temple------------\nint n,e,t;\nint x[2020];\nint dp[2010]={0};\n\nvector<int> ve[4000005];\n    signed main(){\n    \tcin>>n>>e>>t;\n    \tif(n>2010){\n    \t\treturn 0;\n    \t}\n    \tfor(int i=1;i<=n;i++) cin>>x[i];\n    x[0]=0;\n    \tdp[0]=0;\n\n    \t\n    \tfor(int i=1;i<=n;i++){\n    \t\t\n    \t\tint u=100000000000000000ll;\n    \t\tfor(int j=0;j<i;j++){\n    \t\t\t\n    \t\t\tu=min(u, dp[j]+max(t,2*(x[i]-x[j+1])) );\n    \t\t\t\n    \t\t}\n    \t\tdp[i]=u;\n    \t\t\n    \t\t\n    \t}\n    \tcout<<dp[n]+e<<endl;\n    \t\n    \t\t\treturn 0;\n    \t\n    //\tprintf(\"%.10f\\n\",ans);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    for (ll i = 1; i <= N; i++) {\n        ll m = INF;\n        for (ll j = 0; j < i; j++) {\n            ll d = dp[j] + max(2 * (X[i] - X[j + 1]), T);\n            if (d < m) {\n                m = d;\n            }\n        }\n        dp[i] = m;\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1,1e18);\n    dp[0] = 0;\n    auto calc=[&](int i, int j) {\n        return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2)*(i-j);\n    };\n    vector<int> rev(N+1);\n    int cur = 0;\n    for (int i = 1; i <= N; i++) {\n        while (cur < i-1 and calc(i,cur) >= calc(i,cur+1)) cur++;\n        dp[i] = calc(i,cur);\n        // rep(j,i) {\n        //     if (chmin(dp[i],calc(i,j))) rev[i] = j+1;\n        // }\n    }\n    // for (int i = 1; i <= N; i++) {\n    //     cout << i << \" \";\n    // }\n    // cout << ln;\n    // for (int i = 1; i <= N; i++) {\n    //     cout << rev[i] << \" \";\n    // }\n    // cout << ln;\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> x[n + 1] >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    if(n > 2000) return 1;\n    sort(x, x + n + 1);\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << x[n + 1] - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,e,t;\n  cin >> n >> e >> t;\n\n  vector<int> a(n+1,0);\n  REP(i,n) cin >> a[i+1];\n\n  vec dp(n+1,INF);\n  dp[0] = 0;\n  REP(i,n){\n    int j = lower_bound(a.begin(),a.end(),a[i]+t) - a.begin();\n    j = min(j,n);\n    int dist1 = a[j]-a[i], dist2 = a[j]-a[i+1];\n    dp[j] = min(dp[j],dp[i]+dist1+dist2*2+max(0LL,t-dist2*2));\n  }\n\n  cout << dp[n]+e-a.back() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r, x)     for (int i = l; i < r; i+=x)\n//#define ForE(i, l, r, x)    for (int i = l; i <= r; i+=x)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O \n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n//#define PrintV(a)           Fora(ii, a) cout << ii << ' '; cout << rl;\n//#define PrintVl(a)          Fora(ii, a) cout << ii << rl;\n//#define PrintA(a, l, r)     for (int ii = l; ii <= r; ii++) cout << a[ii] << ' '; cout << rl;\n//#define PrintAl(a, l, r)    for (int ii = l; ii <= r; ii++) cout << a[ii] << rl;\n//#define Ptest(x)            return cout << x, 0;\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calc    \n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 100005, MAX_M = 200010;\n// code\n#define int long long\nint n, x[MAXN], dp[MAXN], e, t;\n\nvoid Solve() {\n\tcin >> n >> e >> t; \n\tfor (int i = 1; i <= n; i++){\n\t    cin >> x[i];\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t    dp[i] = 1e18;\n\t    for (int j = 0; j < i; j++) \n\t        dp[i] = min(dp[i], dp[j] + max(2 * (x[i] - x[j+1]), t) + x[i] - x[j]);\n\t}\n\t\n\tcout << dp[n] + e - x[n];\n}\n\nsigned main(){\n    FAST_IO;\n    int TC = 1; \n\t//cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll dp[MX], dp2[MX];\nint s, t, deq[MX];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, T; cin >> n;\n\tvi v(n + 2);\n\tcin >> v[n + 1] >> T;\n\trep(i, n) cin >> v[i + 1];\n\t\n\t// dp[i] := best - 2 * next - cur\n\t// dp2[i] := best - cur\n\tdp[0] = -2ll * v[1];\n\t\n\tll min1 = 1e18;\n\t\n\tfor(int i = 0, j = 0; i < n; i++){\n\t\twhile(2ll * (v[i + 1] - v[j + 1]) > T){\n\t\t\tmin1 = min(min1, dp[j]);\n\t\t\tif(s < t && deq[s] == j) s++;\n\t\t\tj++;\n\t\t}\n\t\tll tmp = 3ll * v[i + 1] + min1;\n\t\ttmp = min(tmp, v[i + 1] + dp2[deq[s]] + T);\n\t\tif(i == n - 1){\n\t\t\tcout << tmp + v[n + 1] - v[n] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tdp[i + 1] = tmp - 2ll * v[i + 2] - v[i + 1];\n\t\tdp2[i + 1] = tmp - v[i + 1];\n\t\t\n\t\twhile(s < t && dp2[deq[t - 1]] < dp2[i + 1]) t--;\n\t\tdeq[t++] = i + 1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = lower_bound(a, a + n + 1, a[i] - t / 2) - a;\n\t\tdp[i] = 1ll * N * N;\n\t\tif (x < i) {\n\t\t\tdp[i] = get(i, x);\n\t\t}\n\t\tif (x > 0) {\n\t\t\tdp[i] = min(dp[i], get(i, x - 1));\n\t\t}\t\n\t//\tcout << \"73 \" << i << \" \" << x << \" \" << dp[i] << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n\n        int l = 1;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        /*\n        for (int j=1; j<i; j++)\n            if ((x[i]-x[j])*2 > T)\n                A[i] = min(A[i], A[j-1]-x[j-1]-2*x[j] + 3*x[i]);\n            else\n                A[i] = min(A[i], A[j-1]-x[j-1] + T+x[i]);\n                */\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\tfor (int j=i; j<=n; j++){\n\t\t\tll len=2*(A[j]-A[i]);\n\t\t\tll cost=max(len, T);\n\t\t\tdp[i]=min(dp[i], cost+dp[j+1]);\n\t\t}\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll t,e;\nll x[100005];\nll dp[2005][2005];\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tif(n>=2001)return 0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdp[i][j]=(ll)x[n]+n*t;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t\tif(i<n)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t\tif(i>=1 && j<i){\n\t\t\t\tll ela=dp[i][j]-dp[j+1][j];\n\t\t\t\t//printf(\"%lld\\n\",ela);\n\t\t\t\tif(ela+x[i]-x[j+1]>=t){\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL);\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[j+1]);\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL+rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]+e-x[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\nint N, T, E, X[2002];\nint64 dp[2003][2003];\n\nint64 getCost(int Left, int Right)\n{\n  if(Left > Right) {\n    return (0);\n  } else if(Left == Right) {\n    return (T);\n  } else {\n    int64 Time = X[Right] - X[Left];\n    int64 ret = Time * 2;\n    ret += max(0LL, T - Time * 2);\n    return (ret);\n  }\n}\n\n// endd 回収済み(閉区間)\nint64 rec(int endd, int idx)\n{\n  if(idx >= N) return (INF);\n  if(idx == N - 1) return (getCost(endd, idx));\n  if(~dp[endd][idx]) return (dp[endd][idx]);\n  int64 ret = INF;\n  ret = min(ret, rec(idx + 1, idx + 1) + getCost(endd, idx) + X[idx + 1] - X[idx]);\n  ret = min(ret, rec(endd, idx + 1) + X[idx + 1] - X[idx]);\n  return (dp[endd][idx] = ret);\n}\n\nsigned main()\n{\n  cin >> N;\n  if(N > 2000) throw (0);\n  cin >> E >> T;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, 0) + X[0] + T - X[N - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 200010\nll n,d[N],t,e;\nll BN(ll key){\n    ll l=-1,r=n,m=(l+r)/2;\n    for(;l<r-1;m=(l+r)/2){\n\tif(d[m]*2<key)l=m;\n\telse r=m;\n    }\n    return l;\n}\nll f[N],g[N];\nint main(){\n    cin>>n>>e>>t;\n    lol(i,n)cin>>d[i];\n    lol(i,N)f[i]=1e18; f[0]=0,g[0]=-2*d[0];\n    for(ll i=1;i<=n;i++){\n\tll surf=BN(d[i-1]*2-t);\n\tll res=1e17;\n\tif(surf+1<i)chmin(res,f[surf+1]+t);\n\tif(~surf)chmin(res,g[surf]+2*d[i-1]);\n\tf[i]=res;\n\tg[i]=min(g[i-1],f[i]-2*d[i]);\n    }\n    cout<<f[n]+e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\n\nvoid solve() {\n        long long n, e, t;\n        cin >> n >> e >> t;\n        vector<long long> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        vector<long long> dp(n, INFL);\n        dp[0] = t;\n        int now = 0;\n        long long mi = -2 * x[0];\n        for (int i = 1; i < n; i ++) {\n                while (2 * (x[i] - x[now + 1]) > t) {\n                        mi = min(mi, dp[now] - 2 * x[now + 1]);\n                        now ++;\n                }\n                dp[i] = mi + 2 * x[i];\n                dp[i] = min(dp[i], dp[now] + t);\n        }\n        cout << dp[n - 1] + e << endl;\n        return;\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\nconst lint linf = 0x3f3f3f3f3f3f3f3f;\n\nint n,tar,que[_]={0},he,ta;\nlint tim,loc[_],f[_]={0};\n\nint main()\n{\n\tn=ty(),tar=ty(),tim=ty();\n\tfor(int i=1;i<=n;i++)loc[i]=ty();\n\n\tlint temp=linf;\n\tloc[0]=0,he=1,ta=0,que[++ta]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(he<=ta && 2*(loc[i]-loc[que[he]+1])>tim)\n\t\t\ttemp=min(temp,f[que[he]]-loc[que[he]]-2*loc[que[he]+1]),he++;\n\t\tf[i]=min(3*loc[i]+temp,tim+f[que[he]]+loc[i]-loc[que[he]]);\n\t\twhile(he<=ta && f[que[ta]]-loc[que[ta]]>=f[i]-loc[i])ta--;\n\t\tque[++ta]=i;\n\t}\n\n\tprintf(\"%lld\\n\",f[n]+tar-loc[n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define dump(a) cerr<<#a <<' '<< a <<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    VLL dp(n+1,LINF),x(n+1);\n    REP(i,n) cin >> x[i+1];\n    dp[0]=0;\n    dp[1]=t;\n    int l=0;\n    FOR(i,2,n+1){\n        for(int j= l; j<i ; ++j){\n            if(dp[i]>dp[j]+max((LL)t,(x[i]-x[j+1])*2)){\n                dp[i]=min(dp[i],dp[j]+max((LL)t,(x[i]-x[j+1])*2));\n                l=j;\n            }\n            if(t>(x[i]-x[j+1])*2)break;\n        }\n    }\n    cout << dp[n]+e<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(int u, int l, int r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(int u, int l, int r, int x, int val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nint query(int u, int l, int r, int b, int e)\n{\n\tif (r == l)\n\t\treturn mod;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tint mid = (l + r) / 2, tmp = mod;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tsort(x, x + n);\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind ? dp[ind - 1] : 0));\n\t\tif (i)\n\t\t\tupdate(0, 0, n, i, dp[i - 1]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n#define ll long long\n#define ld double\n#define ull unsigned long long\n#define PI pair < int, int > \n\nconst int N = 123;\nconst int M = 123;\nconst ld Pi = acos(-1);\nconst ll Inf = 1e18;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nconst int Sz = 501;\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint mult(int a, int b) {\n  return 1ll * a * b % mod;\n}\nint sum(int a, int b) {\n  add(a, b);\n  return a;\n}\n\nint n, a[N], t, m;\nll dp[N];\n\nvoid solve() { \n  cin >> n >> m >> t;\n  assert(n <= 500);\n  for (int i = 1;i <= n;i++) {\n    cin >> a[i];\n    dp[i] = 1e18;\n  }\n  for (int i = 1;i <= n;i++) {\n    for (int j = 1;j <= i;j++) {\n      ll tmp = 2ll * (a[i] - a[j]);\n      ll now = tmp;\n      for (int it = j;it <= i;it++) {\n        ll avail = 1ll * a[it] - a[j] + t;\n        if (now < avail) now = avail;\n        if (it < i) now += a[it + 1] - a[it];\n      }\n      ll cur = dp[j - 1] + now + a[j] - a[j - 1];\n   //   cout << \"j = \" << j << \" now = \" << now << \" cur = \" << cur << endl;\n      dp[i] = min(dp[i], cur);\n    }\n //   cout << \"i = \" << i << \" dp = \" << dp[i] << endl;\n  }\n  cout << dp[n] + m - a[n] << endl;\n}\n  \nint main() {\n  #ifdef wws\n   freopen(\"in\", \"r\", stdin);\n   // freopen(\"in\", \"w\", stdout);\n  #endif \n  ios_base::sync_with_stdio(0);\n  int tt = 1; \n  while(tt--) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=4000+5,inf=1e18+1;\nll mod=924844033;\n\nll n,e,t;\nll dp[M];\nll x[M];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> e >> t;\n\tFor(i,0,n)\n\t{\n\t    cin >> x[i];\n\t}\n\tFor(i,1,n+1)\n\t{\n\t    dp[i]=(x[i-1]-x[0])*3+i*max(0LL,t-2*(x[i-1]-x[0]))+x[0];\n\t    For(j,1,i)\n\t    {\n\t        smin(dp[i],(x[i-1]-x[j])*3+\n\t            (i-j)*max(0LL,t-2*(x[i-1]-x[j]))+\n\t            dp[j]+x[j]-x[j-1]);\n\t    }\n\t    //ER(i);ER(dp[i]);\n\t}\n\tcout << dp[n]+e-x[n-1];\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register ll i=(a);i<=(b);i++)\n#define For(i,a,b) for (register ll i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+5;\nll n,E,T,x[N],f[N],Ans,k=1e18;\nll l=1,r=1,q[N];\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\nint main()\n{\n\tmem(f,0x3f);\n\tn=read(),E=read(),T=read();\n\tFOR(i,1,n) x[i]=read();\n\tf[0]=0;\n\tFOR(i,1,n)\n\t{\n\t\twhile (l<=r&&2*(x[i]-x[q[l]+1])>T)\n\t\t{\n\t\t\tk=min(k,f[q[l]]-2*x[q[l]+1]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[i],f[q[l]]+T);\n\t\tf[i]=min(f[i],k+2*x[i]);\n\t\twhile (l<=r&&f[q[l]]-x[q[l]]>=f[i]-x[i]) r--;\n\t\tq[++r]=i;\n\t}\n\tAns=f[n]+E;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 100005\ntypedef long long LL;\nint n,x[maxn],T,E;\nLL f[maxn],ans;   \n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    for (int i=1;i<=n;i++) scanf(\"%d\",x+i);\n    for (int i=1;i<=n;i++) f[i]=1e16;\n    for (int i=1;i<=n;i++) \n        for (int j=1;j<=i;j++)\n            f[i]=min(f[i],f[j-1]+max(T,(x[i]-x[j])*2));\n    ans=E+f[n];\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t;\nll dp[maxn];\nint x[maxn],y[maxn];\nclass segtree{\npublic:\n\tll tree[maxn*4];\n\tint leaf[maxn];\n\tvoid build(int l,int r,int node){\n\t\tif(l==r){\n\t\t\tleaf[l]=node;\n\t\t\ttree[node]=Inf;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,node*2);\n\t\tbuild(mid+1,r,node*2+1); \n\t}\n\tvoid upd(int node,ll val){\n\t\tnode=leaf[node];\n\t\ttree[node]=val;\n\t\tnode>>=1;\n\t\twhile(node){\n\t\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t\t\tnode>>=1;\n\t\t}\n\t}\n\tll query(int l,int r,int vl,int vr,int node){\n\t\tif(r<l||vr<vl)return Inf;\n\t\tif(l>vr||r<vl)return Inf;\n\t\tif(l>=vl&&r<=vr)return tree[node];\n\t\tint mid=(l+r)>>1;\n\t\treturn min(query(l,mid,vl,vr,node*2),query(mid+1,r,vl,vr,node*2+1));\n\t}\n}t1,t2;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]),y[i]=2*x[i];\n\tt1.build(0,n-1,1);\n\tt2.build(0,n-1,1);\n\trep(i,n){\n\t\tdp[i]=max((x[i]-x[0])*2LL,1LL*t);\n\t\tint pos=lower_bound(y,y+n,2*x[i]-t)-y;\n\t\tdp[i]=min(dp[i],min(t1.query(0,n-1,0,pos-2,1)+2LL*x[i],t2.query(0,n-1,pos-1,n-1,1)+t));\n//\t\tcout<<t1.query(0,n-1,0,pos-1,1)+2LL*x[i]<<\" \"<<t2.query(0,n-1,pos,n-1,1)+t<<endl;\n\t\tt1.upd(i,dp[i]-2LL*x[i+1]);\n\t\tt2.upd(i,dp[i]);\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: d.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;} template<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>ll dcmp(T a,T b){return a>b;}\ntemplate<ll *a>ll cmp_a(ll x,ll y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst ll SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; ll f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// prll the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed lleger\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// prll a signed lleger\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nll f[100005],s[100005],mx[100005];\nll q[100005],*l,*r;\nvoid add(ll w){\n\twhile(l<=r&&w<*r)--r;\n\t*(++r)=w;\n}\nvoid del(ll w){\n\tif(*l==w)++l;\n}\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"d.in\",\"r\",stdin);\n\tfreopen(\"d.out\",\"w\",stdout);\n#endif\n\tll n,t,e;\n\tread(n);\n\tread(e,t);\n\tfor(ll i=1;i<=n;++i)read(s[i]);\n\tmx[0]=-2*s[1];\n\tf[1]=t;\n\t*(l=r=q)=t;\n\tmx[1]=min(-2*s[1],t-2*s[2]);\n\tfor(ll i=2,j=0;i<=n;++i){\n\t\twhile((s[i]-s[j+1])*2>t){del(f[j]);++j;}\n\t\tf[i]=*l+t;\n\t\tif(j)chkmin(f[i],mx[j-1]+s[i]*2);\n\t\tadd(f[i]);\n\t\tmx[i]=min(mx[i-1],f[i]-2*s[i+1]);\n\t}\n\twrite(f[n]+e,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n//#define debug\n//#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 100010;\nconst llint INF = 1e18;\n\nint n, t, e, x[MAXN];\nllint f[MAXN], val[MAXN];\n\nstruct cmpf {\n  bool operator()(const int& i, const int& j) {\n    if (val[i] != val[j]) return val[i] < val[j];\n    return i < j;\n  }\n};\n\nset<int, cmpf> s1, s2;\n\nint main(void) {\n  scanf(\"%d %d %d\",&n,&e,&t);\n  REP(i, n) scanf(\"%d\",&x[i]);\n\n  int j = n - 1;\n  \n  for (int i = n - 1; i >= 0; --i) {\n    val[i] = f[i+1] + t;\n    s1.insert(i);\n    \n    for (; 2*(x[j] - x[i]) > t; --j) {\n      s1.erase(j);\n      val[j] = f[j+1] + 2*(x[j] - x[i]);\n      s2.insert(j);\n    }\n\n    f[i] = INF;\n    if (!s1.empty()) f[i] = min(f[i], val[*s1.begin()]);\n    if (!s2.empty()) f[i] = min(f[i], val[*s2.begin()]);\n  }\n\n  printf(\"%lld\\n\",f[0] + e);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint son[N][2],len[N],dis[N],siz[N];\nLL ans,mid;\nvector< pair<LL,LL> >v[N];\npair<LL,LL>p1[N],p2[N];\n#define lc son[k][0]\n#define rc son[k][1]\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ninline void init(int k,LL &pre) {\n\tif (!len[k]) ans=max(ans,pre),pre=dis[k],siz[k]=1;\n\telse {\n\t\tinit(lc,pre+=dis[lc]);\n\t\tinit(rc,pre+=dis[rc]);\n\t\tsiz[k]=siz[lc]+siz[rc];\n\t\tpre+=dis[k];\n\t}\n}\ninline void dfs(int k) {\n\tv[k].clear();\n\tif (!len[k]) { v[k].pb(mp(dis[k],dis[k])); return; }\n\tdfs(lc);\n\tdfs(rc);\n\tint ls=v[lc].size(),rs=v[rc].size(),i,j,l1=0,l2=0,len=-1;\n\tfor (i=0,j=rs;i<ls;i++) {\n\t\twhile (j&&v[lc][i].y+v[rc][j-1].y<=mid) j--;\n\t\tif (j==rs) continue;\n\t\tif (!l1||v[rc][j].x<p1[l1].y) p1[++l1]=mp(v[lc][i].x,v[rc][j].x);\n\t}\n\tswap(ls,rs);\n\tswap(lc,rc);\n\tfor (i=0,j=rs;i<ls;i++) {\n\t\twhile (j&&v[lc][i].y+v[rc][j-1].y<=mid) j--;\n\t\tif (j==rs) continue;\n\t\tif (!l2||v[rc][j].x<p2[l2].y) p2[++l2]=mp(v[lc][i].x,v[rc][j].x);\n\t}\n\tfor (i=j=1;i<=l1||j<=l2;)\n\t\tif (i<=l1&&(j>l2||p1[i].x<p2[j].x)) {\n\t\t\tif (len==-1||p1[i].y<v[k][len].y) v[k].pb(p1[i]),len++;\n\t\t\ti++;\n\t\t} else if (i>l1||p1[i].x>p2[j].x) {\n\t\t\tif (len==-1||p2[j].y<v[k][len].y) v[k].pb(p2[j]),len++;\n\t\t\tj++;\n\t\t} else v[k].pb(mp(p1[i].x,min(p1[i].y,p2[j].y))),i++,j++;\n\tfor (i=0;i<=len;i++) v[k][i].x+=dis[k],v[k][i].y+=dis[k];\n}\nint main()\n{\n\tint n=gi(),i,k;LL t=0,l,r;\n\tfor (i=2;i<=n;i++) k=gi(),son[k][len[k]++]=i,dis[i]=gi();\n\tinit(1,t);\n\tfor (l=0,r=ans;l!=r;) {\n\t\tmid=(l+r)>>1;\n\t\tdfs(1);\n\t\tif (v[1].size()) r=mid;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[100001];\t//1-indexed, x[0] = 0\nint dp[100001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値 - x[i], Xiのコインは既に回収済み\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < i; j++) {\t//[Xj -> Xi] -> Xj+1 -> Xi\n\t\t\tdp[i] = min(dp[i], dp[j] + max(2 * (x[i] - x[j+1]), t));\n\t\t}\n\t}\n\t\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define INF (1LL << 60)\n#define LL long long\nusing namespace std;\nint n, e, t;\nLL x[N];\nLL dp[N];\nset<LL> st1;\nset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] + t);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tprintf(\"%lld\\n\", dp[n] + e - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <functional>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <stdio.h>\n#include <memory.h>\n#include <sstream>\n#include <iterator>\n\nint main () {\n\tint n, t, e;\n\tscanf (\"%d%d%d\", &n, &e, &t);\n\tstd::vector <int> v (n);\n\tstd::vector <char> used(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &v[i]);\n\t\tused[i] = 0;\n\t}\n\tlong long tt = v[0];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (used[i]) {\n\t\t\ttt += v[i + 1] - v[i];\n\t\t} else {\n\t\t\tint cur = v[i] + t;\n\t\t\tint j = std::lower_bound (v.begin() + i, v.end(), cur) - (v.begin() + i);\n\t\t\tif (j == v.size()) j--;\n\t\t\tif (v[j] - v[i] > t) j--;\n\t\t\tfor (int ii = i; ii <= j; ii++)\n\t\t\t\tused[ii] = true;\n\t\t\ttt += std::max(t, (v[j] - v[i]) * 2);\n\t\t\ttt += v[i + 1] - v[i];\n\t\t}\n\t}\n\tif (used[n - 1] == false) {\n\t\ttt += t;\n\t}\n\ttt += e - v[n - 1];\n\tstd::cout << tt << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N];\n    rep2(i,1,n)x[i]=lin();\n    if(n>2000)return 0;\n    ll dp[2001]={};\n    rep2(i,1,n){\n        ll temp=1e15;\n        rep(j,i){\n            if(j==0){\n                temp=min(temp,x[i]+t);\n            }\n            else{\n                ll s=x[i]*3-x[j]+x[j+1]*2+max(0ll,t-(x[i]-x[j+1])*2);\n                temp=min(temp,s+dp[j]);\n            }\n        }\n        dp[i]=temp;\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nusing int64 = long long;\n\nint64 N, E, T;\n\nvector<int64> pref;\nvector<int64> dp;\nvector<int64> x;\n\nint main() {\n    cin >> N >> E >> T;\n\n    pref.resize(N + 1);\n    x.resize(N + 1);\n\n    for (int i = 0; i < N; i++) {\n        cin >> x[i];\n    }\n    x[N] = E;\n\n    for (int i = N - 1; i >= 0; i--) {\n        pref[i] = pref[i + 1] + (x[i + 1] - x[i]);\n    }\n\n    dp.resize(N + 1);\n\n    for (int i = N - 1; i >= 0; i--) {\n        // Query max T\n\n        // Query max distance\n        \n        // Update\n\n        dp[i] = (1LL<<60);\n\n        for (int j = i + 1; j <= N; j++) {\n            int64 d = pref[i] - pref[j-1];\n            int64 l = pref[i] - pref[j];\n\n            if (2 * d <= T) {\n                dp[i] = min(dp[i], T + l + dp[j]);\n            } else {\n                dp[i] = min(dp[i], 2 * d + l + dp[j]);\n            }\n        }\n\n        //cerr << i << \" \" << dp[i] << \"\\n\";\n    }\n\n    cout << dp[0] + x[0] << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"bits:stdc++.h\"\nusing namespace std;\n#define pb push_back\n#define LLINF 1234567890987654321\n#define INF 1234567890\n#define f first\n#define s second\n#define flase false\n#define db 0\n#define rep(i, l, r)for(ll i = l; i < r; i++)\ntypedef long long ll;\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair<pi, pi>dpi;\nll n, en, ti, pos[100000], dp[100000];\nmultiset <ll> ms, tris;\nint main()\n{\n//  \tfreopen(\"inputfile.cpp\", \"r\", stdin);\n\tcin >> n >> en >> ti;\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin >> pos[i];\n\t}\n\tsort(pos, pos+n);\n\trep(i, 0, n)dp[i] = LLINF;\n\tll nexty = 0;\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\twhile(nexty < n && i > 0 && 2*(pos[i] - pos[nexty]) >= ti)\n\t\t{\n\t\t\tif(nexty == 0)ms.insert(-(2*pos[nexty]));\n\t\t\telse ms.insert(dp[nexty-1]-(2*pos[nexty]));\n\t\t\t++nexty;\n\t\t}\n\t\t//else ;ms.insert(pi(-(2*pos[i]), 0));\n\t\t\n\t\tif(i == 0)dp[i] = ti;\n\t\t//else dp[i] = min(dp[i], dp[j-1] + max(ti, 2*(pos[i]-pos[j])));\n// \t\tif(i == 0){}\n\t\telse\n\t\t{\n\t\t    if(ms.empty())\n\t\t    {\n\t\t        dp[i] = min((max(0LL, ti-(2*(pos[i] - pos[0]))) + (2*(pos[i] - pos[0]))), ti+dp[i-1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dp[i] = min(ti+dp[i-1], *ms.begin()+(2*pos[i]));\n\t\t\t}\n\t\t}\n\t\tif(i > 0)tris.insert(dp[i-1]);\n\t\telse tris.insert(0);\n\t}\n\tif(db)rep(i, 0, n)cout << dp[i] << \"\\n\";\n\tcout << dp[n-1] + en << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = now-1;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\tfor( size_t i = idxmin; i < max( N + 1, idxmin + 5 ); i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nlong long x[N],d[N],z=INT_MAX,e,t;\nint main()\n{\n\tint n;\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\twhile((x[i]-x[j+1])*2>t){z=min(z,d[j]-x[j+1]*2);j++;} \n\t\td[i]=min(z+x[i]*2,d[j]+t);\n\t}\n\tprintf(\"%lld\\n\",d[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef  long long int ll;\nconst int maxn=200005;\nconst ll inf = (1LL<<60) - 1;\n\nint n,e,t,p[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i] + t;\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll dp[2016];\n\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vx;\n\trep(i, 0, n) {\n\t\tll a;\n\t\tcin >> a;\n\t\tvx.pb(a);\n\t}\n\trep(i, 0, 2016)dp[i] = 1000000000000000000LL;\n\tdp[0] = 0;\n\tdp[1] = t;\n\tif (n == 1) {\n\t\tcout << e + t << endl;\n\t\treturn 0;\n\t}\n\trep(i, 2, vx.sz + 1) {\n\t\tdp[i] = dp[i - 1] + t;\n\t\tlong long low = 0;\n\t\tlong long high = i-1;\n\n\t\twhile (low < high) {\n\t\t\tlong long mid = (high + low) >> 1;\n\n\t\t\tif (t <= (vx[i - 1] - vx[mid]) * 2) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\tdp[i] = min(dp[i], dp[low] + max(t, (vx[i - 1] - vx[low]) * 2));\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, t, e, x[maxn];\nlong long f[maxn];\nstruct Seg {\n\tlong long tr[maxn << 2];\n\tinline void Upd(int o, int l, int r, int p, long long d) {\n\t\tif(l == r)\n\t\t\treturn tr[o] = d, void();\n\t\tint mid = (l + r) >> 1;\n\t\tif(p <= mid)\n\t\t\tUpd(o << 1, l, mid, p, d);\n\t\telse\n\t\t\tUpd(o << 1 | 1, mid + 1, r, p, d);\n\t\ttr[o] = min(tr[o << 1], tr[o << 1 | 1]);\n\t}\n\tinline long long Ask(int o, int l, int r, int ql, int qr) {\n\t\tif(ql > qr)\n\t\t\treturn 1e18;\n\t\tif(ql <= l && r <= qr)\n\t\t\treturn tr[o];\n\t\tint mid = (l + r) >> 1;\n\t\tlong long ans = 1e18;\n\t\tif(ql <= mid)\n\t\t\tans = min(ans, Ask(o << 1, l, mid, ql, qr));\n\t\tif(qr > mid)\n\t\t\tans = min(ans, Ask(o << 1 | 1, mid + 1, r, ql, qr));\n\t\treturn ans;\n\t}\n}g, h;\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &x[i]);\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0, g.Upd(1, 0, n, 0, 0), h.Upd(1, 0, n, 0, - 1ll * 2 * x[1]);\n\tfor(int i = 1; i <= n; ++ i) {\n\t\t/*\n\t\tfor(int j = 0; j < i; ++ j) {\n\t\t\tif(t / 2 >= x[i] - x[j + 1])\n\t\t\t\tf[i] = min(f[i], f[j] - x[j] + t + x[i]);\n\t\t\tif(t / 2 <= x[i] - x[j + 1])\n\t\t\t\tf[i] = min(f[i], f[j] - 2 * x[j + 1] - x[j] + 3 * x[i]);\n\t\t}\n\t\t*/\n\t\t// p = j + 1\n\t\tint p = lower_bound(x, x + i, x[i] - t / 2) - x;\n\t\t// cerr << p <<\" \" << x[i] << \" \" << x[p] << endl;\n\t\tf[i] = min(g.Ask(1, 0, n, p - 1, i - 1) + t + x[i], h.Ask(1, 0, n, 0, p - 2) + 1ll * 3 * x[i]);\n\t\tif(i < n)\n\t\t\t// g[i] = f[i] - x[i], h[i] = f[i] - x[i] - 2 * x[i + 1];\n\t\t\tg.Upd(1, 0, n, i, f[i] - x[i]), h.Upd(1, 0, n, i, f[i] - x[i] - 1ll * 2 * x[i + 1]);\n\t\t\n\t}\n\t/*\n\tfor(int i = 0; i <= n; ++ i)\n\t\tcerr << f[i] <<\" \";\n\tcerr << endl;\n\t*/\n\tprintf(\"%lld\\n\", f[n] + e - x[n]);\n\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"factories.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e5 + 10, INF = 1e9 * 1e9;\nll dp[SZ], push[SZ * 8][4], tree[SZ * 8][4];\n\nvoid p(int v, int ind) {\n\ttree[v * 2 + 1][ind] += push[v][ind];\n\ttree[v * 2 + 2][ind] += push[v][ind];\n\tpush[v * 2 + 1][ind] += push[v][ind];\n\tpush[v * 2 + 2][ind] += push[v][ind];\n\tpush[v][ind] = 0;\n}\n\nll get(int v, int l, int r, int askl, int askr, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) {\n\t\treturn INF;\n\t}\n\n\tif (l >= askl && r <= askr) {\n\t\treturn tree[v][ind];\n\t}\n\tint mid = (l + r) / 2;\n\tll q = get(v * 2 + 1, l, mid, askl, askr, ind), q2 = get(v * 2 + 2, mid, r, askl, askr, ind);\n\treturn min(q, q2);\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int add, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\ttree[v][ind] += add;\n\t\tpush[v][ind] += add;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, add, ind);\n\tupd(v * 2 + 2, mid, r, askl, askr, add, ind);\n\ttree[v][ind] = min(tree[v * 2 + 1][ind], tree[v * 2 + 2][ind]);\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vec(n);\n\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\n\tvec.push_back(vec.back());\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tdp[i] = dp[i + 1] + (vec[i + 1] - vec[i]) + t;\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 1, 0);\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 3, 1);\n\t\tint l = i, r = n;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif ((vec[mid] - vec[i]) * 2 >= t) {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\n\t\tll q = INF;\n\t\tif (i + 1 < r - 1) q = get(0, 0, n + 1, i + 1, r - 1, 0) + t;\n\t\tif (r != n) q = min(q, get(0, 0, n + 1, r, n, 1));\n\t\tdp[i] = min(dp[i], q);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 0);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 1);\n\t}\n\n\tcout << dp[0] + (e - vec.back()) + vec.front();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 8001;\nll dp[N];\nconst ll inf = 1e16;\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  assert (n < N);\n  VL x(n + 1);\n  x[0] = 0;\n  REP(i, 0, n) {\n    cin >> x[i + 1];\n  }\n  dp[0] = 0;\n  REP(i, 0, n) {\n    ll ret = inf;\n    REP(j, 0, i + 1) {\n      ret = min(ret, dp[j] + max(t, 2 * (x[i + 1] - x[j + 1])));\n    }\n    dp[i + 1] = ret;\n  }\n  cout << dp[n] + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\ntypedef long long LL;\nconst int N = 1e5 + 10;\nconst LL inf = 1e18 + 10;\nint n, e, t, x[N]; LL f[N], g[N];\n\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\nint main() {\n\tin(n), in(e), in(t), g[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i) in(x[i]);\n\tfor (int i = n, j = n; i; --i) {\n\t\tfor (;(x[j] - x[i] << 1) > t;) --j;\n\t\tf[i] = min(f[j + 1] + t, g[j + 1] - 2 * x[i]);\n\t\tg[i] = min(g[i + 1], f[i + 1] + 2 * x[i]);\n\t}\n\tprintf(\"%lld\\n\", f[1] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t;\nint x[100005];\nll dp[100005];\nint main(){\n    int n,e,t;\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++){\n        dp[i] = 1000000000000000000;\n        while (pivot < i && 2*(x[i]-x[pivot+1]) < t) {\n            if (pivot >= 1) mn = min(mn,dp[pivot-1]-2*x[pivot]);\n            pivot++;\n        }\n        //printf(\"pivot for %d = %d\\n\",i,pivot);\n        dp[i] = min(2*x[i]+mn,dp[pivot-1]+t);\n        //printf(\"%lld first\\n\",dp[i]);\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N = 2e5 + 10;\nconst LL inf = 1e18;\n\nint n;\nLL E, t, a[N], dp[N];\n\nint main() {\n\tcin >> n >> E >> t;\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", &a[i]);\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdp[i] = inf;\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tdp[i] = min(dp[i], dp[j - 1] + max(t, 2 * (a[i] - a[j])));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n] + E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define INF (1LL << 60)\n#define LL long long\nusing namespace std;\nint n, e, t, x[N];\nLL dp[N], preMin[N];\nset<LL> st;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tpreMin[0] = - 2 * x[1];\n\tst.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(preMin[last - 1] + 3LL * x[i], *st.begin() + x[i]);\n\t\telse dp[i] = *st.begin() + x[i];\n//cout << last << ' ' << preMin[last - 1] << ' ' << *st.begin() << ' ' << dp[i] << endl;\n\t\tif (i < n) st.insert(dp[i] - x[i] + t);\n\t\tpreMin[i] = min(dp[i] - x[i] - 2LL * x[i + 1], preMin[i - 1]);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tprintf(\"%lld\\n\", dp[n] + e - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll D[101010], dp[101010];\nll T1[303030], T2[303030];\nll n, t, sz;\n\nvoid update(ll* T, ll p, ll v)\n{\n\tp += sz;\n\tT[p] = v;\n\t\n\tfor(p>>=1;p;p>>=1){\n\t\tT[p] = min(T[p<<1], T[p<<1|1]);\n\t}\n}\n\nll get_min(ll* T, ll l, ll r)\n{\n\tll ret = 1e18;\n\tl += sz, r += sz;\n\t\n\tfor(;l<r;){\n\t\tif(l & 1) ret = min(ret, T[l]);\n\t\tif(~r & 1) ret = min(ret, T[r]);\n\t\tl = l+1>>1;\n\t\tr = r-1>>1;\n\t}\n\tif(l == r) ret = min(ret, T[l]);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tll i, j;\n\t\n\tscanf(\"%lld\", &n);\n\tscanf(\"%lld%lld\", D+n+1, &t);\n\t\n\tfor(i=1;i<=n;i++) scanf(\"%lld\", D+i);\n\t\n\tfor(sz=1;sz<=n;sz<<=1);\n\t\n\tfor(i=1;i<=sz+n;i++){\n\t\tT1[i] = T2[i] = 1e18;\n\t}\n\t\n\tupdate(T1, 1, 0 - 2*D[1]);\n\tupdate(T2, 1, 0);\n\tfor(i=1,j=1;i<=n;i++){\n\t\tfor(;2 * (D[i]-D[j]) > t;j++);\n\t\tdp[i] = min(get_min(T1, 1, j-1) + 3*D[i], get_min(T2, j, i) + t + D[i]);\n\t\tupdate(T1, i+1, dp[i] - D[i] - 2*D[i+1]);\n\t\tupdate(T2, i+1, dp[i] - D[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\",dp[n] + D[n+1] - D[n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e5 + 10, INF = 1e9 * 1e9;\nll dp[SZ], push[SZ * 8][4], tree[SZ * 8][4];\n\nvoid p(int v, int ind) {\n\ttree[v * 2 + 1][ind] += push[v][ind];\n\ttree[v * 2 + 2][ind] += push[v][ind];\n\tpush[v * 2 + 1][ind] += push[v][ind];\n\tpush[v * 2 + 2][ind] += push[v][ind];\n\tpush[v][ind] = 0;\n}\n\nll get(int v, int l, int r, int askl, int askr, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) {\n\t\treturn INF;\n\t}\n\n\tif (l >= askl && r <= askr) {\n\t\treturn tree[v][ind];\n\t}\n\tint mid = (l + r) / 2;\n\tll q = get(v * 2 + 1, l, mid, askl, askr, ind), q2 = get(v * 2 + 2, mid, r, askl, askr, ind);\n\treturn min(q, q2);\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int add, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\ttree[v][ind] += add;\n\t\tpush[v][ind] += add;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, add, ind);\n\tupd(v * 2 + 2, mid, r, askl, askr, add, ind);\n\ttree[v][ind] = min(tree[v * 2 + 1][ind], tree[v * 2 + 2][ind]);\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vec(n);\n\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\n\tvec.push_back(e);\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 1, 0);\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 3, 1);\n\n\t\tdp[i] = dp[i + 1] + (vec[i + 1] - vec[i]) + t;\n\t\t\n\t\tint l = i, r = n + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif ((vec[mid] - vec[i]) * 2 >= t) {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\n\t\tll q = INF;\n\t\tif (i + 1 < r - 1) q = get(0, 0, n + 1, i + 1, r - 1, 0) + t;\n\t\tif (r < n + 1) q = min(q, get(0, 0, n + 1, r, n + 1, 1));\n\n\t\tdp[i] = min(dp[i], q);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 0);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 1);\n\t}\n\n\tcout << dp[0] + vec.front();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define fore(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define pb push_back\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef long double ld;\ntypedef long long ll;\nconst i64 infl = 4e18;\n\nconst int maxn = 100500;\nconst int N = 100010;\n\nstruct Fen {\n    i64 a[maxn];\n    Fen() {\n        forn(i, maxn) a[i] = infl;\n    }\n    void add(int i, i64 x) {\n        for (; i < maxn; i |= (i+1)) {\n            a[i] = min(a[i], x);\n        }\n    }\n    i64 get(int i) {\n        i64 mn = infl;\n        for (; i >= 0; i = (i&(i+1))-1) {\n            mn = min(mn, a[i]);\n        }\n        return mn;\n    }\n} f1, f2;\n\nint n, T, m;\nint x[maxn];\ni64 d[maxn];\n\nvoid scan() {\n    scanf(\"%d%d%d\", &n, &m, &T);\n    forn(i, n) scanf(\"%d\", &x[i]);\n    x[n] = m;\n}\n\nint f(int i, int j) {\n    int d = x[i-1] - x[j];\n    return 2*d >= T;\n}\n\nvoid solve() {\n    d[0] = x[0];\n    f1.add(0, d[0] - 3ll*x[0]);\n    f2.add(N-0, d[0] - 1ll*x[0]);\n\n    fore(i, 1, n) {\n        d[i] = infl;\n\n        int l = 0, r = i;\n        assert(!f(i, r));\n        while (r-l > 1) {\n            int m = (l+r)/2;\n            if (f(i, m)) l = m;\n            else r = m;\n        }\n        if (f(i, l)) {\n            d[i] = min(d[i], f1.get(l) + 2ll*x[i-1] + x[i]);\n        } else {\n            r = l;\n        }\n        d[i] = min(d[i], f2.get(N-r) + T + x[i]);\n\n        f1.add(i, d[i] - 3ll*x[i]);\n        f2.add(N-i, d[i] - 1ll*x[i]);\n//         cerr << i << \": \" << d[i] << endl;\n    }\n\n    cout << d[n] << endl;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"d.in\", \"r\", stdin);\n#endif\n\n    scan();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << clock() / 1000 << \" ms\" << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], st[444444] = {inf}, pmn[111111] = {inf};\n/*void upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind or r < l)\n        return ;\n    if(l == r)\n    {\n        st[cur] = val;\n        return;\n    }\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl or r < l or sr < sl)\n        return inf;\n    if(l == r)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}*/\nint32_t main()\n{\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    pmn[0] = -2*x[1];\n    //upd(0, n, 0, 0, -2*x[1]);\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if(j <= 1)\n        {\n            dp[j] = t;\n        }\n        else\n        {\n            if((x[i]-x[j])*2 < t)\n                j--;\n            dp[i] = min(dp[j]+t, pmn[j-1]+2*x[i]);//mn(0,n,0,j-1,0)+2*x[i]);\n        }\n        //upd(0, n, 0, i, dp[i]-2*x[i+1]);\n        pmn[i] = min(pmn[i-1], dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define MAXN 55\n# define MAXM 100005\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nint a[100005];\n\nint main()\n{\n    int n, E, T;\n    LL ans=0;\n    scanf(\"%d%d%d\",&n,&E,&T);\n    FO(i,0,n) scanf(\"%d\",a+i);\n    ans+=a[0];\n    int i=0, flag=1;\n    while(i<n-1) {\n        if (flag) {\n            if ((LL)T>=(LL)2*(a[i+1]-a[i])) ans+=(LL)T+a[i+1]-a[i], flag=0;\n            else if (T>=a[i+1]-a[i]) ans+=(LL)3*(a[i+1]-a[i]), flag=0;\n            else ans+=(LL)(a[i+1]-a[i])+T, flag=1;\n        }\n        else {\n            ans+=(LL)a[i+1]-a[i], flag=1;\n        }\n        ++i;\n    }\n    if (flag==1) ans+=T;\n    ans+=(LL)E-a[n-1];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int M = 100100;\n\nint n;\nll t, e;\nll x[M], d[M];\n\nvoid read() {\n  cin >> n >> e >> t;\n  x[0] = 0;\n  for (int i = 1; i <= n; ++i)\n    cin >> x[i];\n}\n\n\nvoid kill() {\n  d[0] = 0;\n  int l = 0;\n  ll mn = 1e18;\n  for (int i = 1; i <= n; ++i) {\n    d[i] = d[i - 1] + t;\n    /*\n    for (int j = 0; j < i; ++j)\n      d[i] = min(d[i], d[j] + max(t, 2 * (x[i] - x[j + 1])));\n    continue;\n    */\n    while (l < i && 2 * (x[i] - x[l + 1]) >= t) {\n      mn = min(mn, d[l] - 2 * x[l + 1]);\n      ++l;\n    }\n    //cerr << \"i = \" << i << \", l = \" << l << endl;\n    d[i] = min(d[i], d[l] + t);\n    d[i] = min(d[i], mn + 2 * x[i]);\n  }\n\n  ll ans = d[n] + e;\n  \n  cout << ans << endl;\n}\n\nint main() {\n  cout.precision(20);\n  cout << fixed;\n  ios_base::sync_with_stdio(false);\n  read();\n  kill();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\n#define gpf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nll n, e, T;\nll x[110000], f[110000];\nll ans;\n\nint main(){\n\tscanf(\"%lld%lld%lld\", &n, &e, &T);\n\trep(i, 1, n) scanf(\"%lld\", x + i);\n\tll tmn = 1ll << 60;\n\tint j = 1;\n\trep(i, 1, n){\n\t\twhile (j <= n && (x[i] - x[j]) * 2 > T){\n\t\t\ttmn = min(tmn, f[j - 1] - 2 * x[j]);\n\t\t\tj++;\n\t\t}\n\t\tf[i] = f[i - 1] + T;\n\t\tf[i] = min(f[i], f[j - 1] + T);\n\t\tf[i] = min(f[i], tmn + 2 * x[i]);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n  int N, E, T, tot = 0;\n  cin >> N >> E >> T;\n  int x[N];\n\n  for(int i; i<N; i++){\n    int A;\n    int B;\n    A = max(0, T-(x[i+1]-x[i]));\n    B = max(0, T-2*(x[i+1]-x[i]));\n    tot += min(2*T+x[i+1]-x[i], 2*(x[i+1]-x[i])+ A + B);\n  }\n  tot+=x[0]+(E-x[N-1]);\n\n  cout << tot << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << (x) << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate<class T> class segtree {\n\tint n;\n\tvector<T> data;\n\tT id = INF;\n\tT operation(T a, T b) { return min(a, b); };\npublic:\n\tsegtree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n + 2) n <<= 1;\n\t\tdata = vector<T>(2 * n, id);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n;\n\t\tdata[i] = x;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tdata[i] = operation(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t}\n\tvoid add(int i, T x) { change(i, data[i + n] + x); }\n\tT get(int a, int b) {\n\t\tT left = id; T right = id;\n\t\ta += n; b += n;\n\t\twhile (a < b) {\n\t\t\tif (a & 1) left = operation(left, data[a++]);\n\t\t\tif (b & 1) right = operation(data[--b], right);\n\t\t\ta >>= 1; b >>= 1;\n\t\t}\n\t\treturn operation(left, right);\n\t}\n\tT get_all() { return data[1]; }\n\tT operator[](int i) { return data[i + n]; }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> a(n + 1);\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tvector<vector<int>> ch(n + 2, vector<int>());\n\trep(i, n) {\n\t\tll sum = 2 * a[i + 1] + t;\n\t\tint ng = -1, ok = n + 1;\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (2 * a[mid] > sum) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tch[ok].pb(i);\n\t}\n\tsegtree<ll> dp(n + 1), seg(n + 1);\n\tdp.change(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j : ch[i]) {\n\t\t\tseg.change(j, dp[j] - 2 * a[j + 1]);\n\t\t\tdp.change(j, INF);\n\t\t}\n\t\tll mi = dp.get(0, i) + t;\n\t\tchmin(mi, seg.get(0, i) + 2 * a[i]);\n\t\tdp.change(i, mi);\n\t}\n\tcout << dp[n] + e << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <functional>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <stdio.h>\n#include <memory.h>\n#include <sstream>\n#include <iterator>\n\nint main () {\n\tint n, t, e;\n\tscanf (\"%d%d%d\", &n, &e, &t);\n\tstd::vector <int> v (n);\n\tstd::vector <char> used(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &v[i]);\n\t\tused[i] = 0;\n\t}\n\tlong long tt = v[0];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (used[i]) {\n\t\t\ttt += v[i + 1] - v[i];\n\t\t} else {\n\t\t\tint cur = v[i] + t / 2;\n\t\t\tint j = std::lower_bound (v.begin() + i, v.end(), cur) - (v.begin() + i);\n\t\t\tfor (int ii = i; ii <= j; ii++)\n\t\t\t\tused[ii] = true;\n\t\t\ttt += std::max(t, (v[j] - v[i]) * 2);\n\t\t\ttt += v[i + 1] - v[i];\n\t\t}\n\t}\n\tif (used[n - 1] == false) {\n\t\ttt += t;\n\t}\n\ttt += e - v[n - 1];\n\tstd::cout << tt << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\n\nstruct RMQ {\n\tint n; vector<int>node;\n\tvoid init(int N) {\n\t\tn = 1;\n\t\twhile (n < N)n *= 2;\n\t\tnode.resize(2 * n, inf);\n\t}\n\n\tvoid update(int x, int a) {\n\t\tx += n - 1;\n\t\tnode[x] = a;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[x * 2 + 1], node[x * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tint get(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\nRMQ dp1, dp2;\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\tdp1.init(n + 2);\n\tdp2.init(n + 2);\n\n\tx[n] = x[n - 1];\n\tdp1.update(0, 0);\n\tdp2.update(0, -2*x[0]);\n\trep(i,n){\n\t\tint lb = -1, ub = i+1;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mi = (ub + lb) / 2;\n\t\t\tif (2 * (x[i] - x[mi]) > t)lb = mi;\n\t\t\telse ub = mi;\n\t\t}\n\n\t\t//[0,i]を分ける\n\t\t//[0,lb]は2(x[i]-x[j]), [ub,i]はt\n\t\tint X1, X2;\n\t\tX1 = dp1.get(ub, i+1) + t;\n\t\tX2 = dp2.get(0, ub) + 2 * x[i];\n\t\tdp1.update(i+1, min(X1, X2));\n\t\tdp2.update(i+1, min(X1,X2)-2 * x[i+1]);\n\t}\n\tcout << dp1.get(n, n+1)+e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 100003;\nLL dp[MaxN];\nint n,e,t,x[MaxN];\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tint ptr=1;\n\tLL mn=0x7fffffff;\n\tdp[0]=0;\n\tfor (int i=1;i<=n;i++) {\n\t\twhile (ptr<=n && 2*(x[i]-x[ptr])>t) {\n\t\t\tmn=min(mn,dp[ptr-1]-x[ptr]*2);\n\t\t\tptr++;\n\t\t}\n\t\tdp[i]=min(dp[ptr-1]+t,mn+x[i]*2);\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\n#define REDIRECT(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n#define CLOSEALL() fclose(stdin), fclose(stdout)\n\nconst int MAXN = 1e5 + 10;\n\ntypedef long long i64;\n\ni64 tmp = 0x7F7F7F7F7F7F7F7F;\ni64 N, M, T;\ni64 a[MAXN];\ni64 dp[MAXN];\n\nint main()\n{\n\t//REDIRECT(\"computer\");\n\n\ti64 t = 0;\n\tscanf(\"%lld%lld%lld\", &N, &M, &T);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\twhile (T <= (a[i] - a[t + 1]) * 2)\n\t\t\ttmp = std::min(tmp, dp[t] - 2 * a[t + 1]), t++;\n\t\tdp[i] = std::min(dp[t] + T, tmp + 2 * a[i]);\n\t}\n\n\tprintf(\"%lld\\n\", dp[N] + M);\n\n\tCLOSEALL();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n;\nll x[2005],e,t;\nll dp[2005];\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&x[i]);\n\t\tdp[i]=dp[i-1]+x[i]-x[i-1]+t;\n//\t\tcerr<<\"--tmp\\n\";\n\t\tfor(int j=0;j<i-1;j++) {\n\t\t\tdp[i]=min(dp[i],dp[j]+x[j+1]-x[j]+3*(x[i]-x[j+1])+max(0ll,t-2*(x[i]-x[j+1])));\n//\t\t\tcerr<<j<<\":\"<<dp[i]<<endl;\n\t\t}\n//\t\tcerr<<\"--\\\\tmp\\n\";\n//\t\tcerr<<dp[i]<<endl;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e-x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n#define y0 I_love_Ryougi_Shiki_0\n#define y1 I_love_Ryougi_Shiki_1\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ntemplate<typename T>\ninline void cmin(T& x,T y)\n{\n\tif(!(x<y)) x=y;\n}\n\ntemplate<typename T>\ninline void cmax(T& x,T y)\n{\n\tif(x<y) x=y;\n}\n\nconst int inf=5000000000000000ll;\n\nint N,E,T;\nint a[100010];\nint dp[100010];\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>E>>T;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tint mint=inf,pos=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\twhile(2*(a[i]-a[pos+1])>=T)\n\t\t{\n\t\t\tcmin(mint,dp[pos]-2*a[pos+1]);\n\t\t\tpos++;\n\t\t}\n\t\tdp[i]=mint+2*a[i];\n\t\tif(pos!=i) cmin(dp[i],dp[pos]+T);\n\t\t\n//\t\tcout<<i<<\" : \"<<pos<<\" \"<<dp[i]<<endl;\n\t}\n\tcout<<dp[N]+E<<endl;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nvector<int>x, memo;\nint N, E, T;\n\nint solve(int posindex) {\n\t//x[posindex]の位置についた直後で、自分より手前の熊は処理済みで、自分より奥の熊は手付かず\n\n\tif (posindex == N)return 0;\n\tif (memo[posindex] != -1)return memo[posindex];\n\n\tint ans = intmax;\n\n\t//その場で待つ\n\tans = min(ans, solve(posindex + 1) + T + x[posindex + 1] - x[posindex]);\n\n\t//先まで行く\n\tREP(i, posindex+1, N) {\n\t\tint sol = solve(i + 1);\n\t\tint dist = x[i] - x[posindex];\n\t\tint gets = max(T + dist, dist * 3);\n\t\tint res = sol + gets + x[i + 1] - x[i];\n\t\tif (ans < res)break;\n\t\tans = res;\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tx = vector<int>(N+1);\n\tmemo = vector<int>(N,-1);\n\trep(i, N)cin >> x[i];\n\tx[N] = E;\n\tsort(ALL(x));\n\n\n\t\n\tcout << x[0] + solve(0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n), d(n), ds(n + 1);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        chmin(dp[i + 1], dp[i] + T);\n        for (int j = i; j < n; j++) {\n            chmin(dp[j + 1], dp[i] + max(T, 2 * (ds[j] - ds[i])));\n        }\n    }\n\n    cout << min(dp[n] + E, E + ds.back() * 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e5 + 10;\nconst int INF = 2e9;\n\nint dp[MAXN], seg[4 * MAXN], x[MAXN];\n\nvoid _set(int v, int l, int r, int p, int x) {\n    if (r - l == 1) {\n\tseg[v] = x;\n\treturn;\n    }\n    int mid = (r + l) / 2;\n    if (p < mid) \n\t_set(2 * v, l, mid, p, x);\n    else\n\t_set(2 * v + 1, mid, r, p, x);\n    seg[v] = min(seg[2 * v], seg[2 * v + 1]);\n}\n\nint query(int v, int l, int r, int s, int t) {\n    if (s <= l && r <= t)\n\treturn seg[v];\n    int mid = (l + r) / 2, res = INF;\n    if (s < mid)\n\tres = min(res, query(2 * v, l, mid, s, t));\n    if (t > mid)\n\tres = min(res, query(2 * v + 1, mid, r, s, t));\n    return res;\n}\n\nint lower(int val, int s, int t) {\n    if (t - s == 1)\n\treturn s;\n    int mid = (s + t) / 2;\n    if (x[mid-1] >= val)\n\treturn lower(val, s, mid);\n    else\n\treturn lower(val, mid, t);\n}\n\nmain() {\n    int N, T, E;\n    cin >> N >> E >> T;\n    T *= 2;\n    for (int i = 0; i < N; i ++) cin >> x[i], x[i] *= 2;\n    for (int i = 0; i < N; i ++) {\n\tint last = lower(x[i] - T/2, 0, N);\n\tif (last <= 1) {\n\t    dp[i] = (last?2 * x[i] - 2 * x[0] : T);\n\t    if(last)dp[i] = min(dp[i], dp[last - 1] + T);\n\t    _set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n\t    continue;\n\t}\n\tdp[i] = query(1, 0, N, 0, last-1) + 2 * x[i]; dp[i] = min(dp[i], dp[last- 1] + T);\n\t_set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n    }\n    cout << dp[N -1]/2 + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nll dp[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tif(n>2000) exit(-1);\n\tmemset(dp,127/3,sizeof(dp)); dp[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tdp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t}\n\t}\n\tcout<<dp[n]+e<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define X first\n#define Y second\nusing namespace std;\nconst int max_n = 1e6 + 20, inf = 1e12;\nint a[max_n], DP[max_n];\npair<int, int> seg[max_n * 4];\nint n, e, t, INF = 1e12, L;\npair<int, int> Merge(pii x, pii y) {\n    if (x.X < y.X)\n        return x;\n    return y;\n}\nvoid update(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg[id].X = val;\n        seg[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update(x, val, mid, e, id << 1 | 1);\n    else\n        update(x, val, b, mid, id << 1);\n    seg[id] = Merge(seg[id << 1 | 1], seg[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, 0};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get(l, r, b, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\nvoid out() {\n    for (int i = 1; i < n * 4; i++)\n        cout << seg[i].Y << \">>>>>\" << seg[i].X << \"   \";\n    cout << endl;\n}\nvoid solve() {\n    for (int i = 1; i < n; i++) {\n        int tmp = (lower_bound(a, a + n, a[i] - L) - a);\n        pii x = get(tmp, i), y = get(0, tmp);\n        //cout << tmp << endl;\n        DP[i] = min(x.X + t, y.X + 2 * (a[i] - a[y.Y])) + a[i];\n       // DP[i] = min(DP[i] , DP[i - 1] + a[i] - a[i - 1] + t);\n  //      cout << DP[i] << endl;\n        update(i, DP[i - 1] - a[i - 1]);\n      //  cout << endl;\n        //out();\n    }\n}\nint32_t main() {\n    cin >> n >> e >> t;\n    L = (t+1) / 2;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < n * 4; i++)\n        seg[i].X = inf;\n    DP[0] = a[0] + t;\n    update(0, 0);\n    solve();\n    cout << DP[n - 1] + (e - a[n - 1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\nconst ll inf=1LL<<60;\nll x[200010];\nll dp[2010];\n\nint main(void){\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\tif(n>2000) return 0;\n\trep(i,1,n+1) cin >> x[i];\n\n\trep(i,1,n+1){\n\t\tdp[i]=inf;\n\t\trep(j,i){\n\t\t\tll d=x[i]-x[j];\n\t\t\tchmin(dp[i],dp[j]+d+max(t,2*(x[i]-x[j+1])));\n\t\t}\n\t}\n\n\trep(i,n+1) cout << dp[i] << endl;\n\tcout << dp[n]+e-x[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n,e,t;\nvi x;\nll dp[MX];\n\nll f(int i, int j) {\n  return dp[j] + max((x[j-1]-x[i])*2, t) + (x[j]-x[i]);\n}\n\nint main() {\n  scanf(\"%d%d%d\",&n,&e,&t);\n  x = vi(n);\n  rep(i,n) scanf(\"%d\",&x[i]);\n  x.pb(e);\n  drep(i,n) {\n    dp[i] = LINF;\n    for (int j = i+1; j <= n; ++j) mins(dp[i], f(i,j));\n  }\n  cout<<(dp[0]+x[0])<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], st[444444] = {inf};\nint upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind or r < l)\n        return inf;\n    if(l == r)\n        return st[cur] = val;\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    return st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl or r < l or sr < sl)\n        return inf;\n    if(l == r)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    upd(0, n, 0, 0, -2*x[1]);\n\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if((x[i]-x[j])*2 < t)\n            j--;\n        dp[i] = min(dp[j]+t, mn(0,n,0,j-1,0)+2*x[i]);\n        //cout << i << ' ' << j << ' ' << dp[i] << endl;\n\n        upd(0, n, 0, i, dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nlint cost(int l, int r) {\n    return d[l] - d[l - 1] + (d[r] - d[l]) * 3 + ((d[r] - d[l]) * 2 <= t ? t - (d[r] - d[l]) * 2 : 0);\n}\n\nint main() {\n    n = read();\n    if (n > 2000)\n        return 0;\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    for (int i = 1; i <= n; ++i) {\n        f[i] = INF;\n        for (int j = 0; j < i; ++j)\n            f[i] = min(f[i], f[j] + cost(j + 1, i));\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX_N = 1e5 + 5, inf = 1000000LL * 1000000LL * 1000000LL;\nll n, E, T;\nll x[MAX_N];\nll dp[MAX_N];\nll seg[MAX_N << 2];\nll lazy[MAX_N << 2];\n\nvoid shift (ll id) {\n\tseg[id << 1] += lazy[id];\n\tlazy[id << 1] += lazy[id];\n\n\tseg[id << 1 | 1] += lazy[id];\n\tlazy[id << 1 | 1] += lazy[id];\n\tlazy[id] = 0;\n}\n\nvoid add (ll l, ll r, ll val, ll s = 0, ll e = n, ll id = 1) {\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn ;\n\t}\n\n\tif (r <= s || e <= l)\n\t\treturn ;\n\n\tshift(id);\n\n\tll mid = e + s >> 1;\n\tadd(l, r, val, s, mid, id << 1);\n\tadd(l, r, val, mid, e, id << 1 | 1);\n\tseg[id] = min(seg[id << 1], seg[id << 1 | 1]);\n}\n\nll get (ll l, ll r, ll s = 0, ll e = n, ll id = 1) {\n\tif (l <= s && e <= r)\n\t\treturn seg[id];\n\n\tif (r <= s || e <= l)\n\t\treturn inf;\n\n\tshift(id);\n\tll mid = e + s >> 1;\n\treturn min(get(l, r, s, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> E >> T;\n\tfor (ll i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tdp[n - 1] = T;\n\tfor (ll i = n - 2; ~i; i--) {\n\t\tadd(i + 1, n, 2 * (x[i + 1] - x[i]));\n\t\tadd(i, i + 1, dp[i + 1]);\n\t\tll ind = lower_bound(x, x + n, x[i] + (T + 1) / 2) - x;\n\t\tind--;\n\n\t\tdp[i] = T + dp[ind + 1];\n\t\tif (ind + 1 < n)\n\t\t\tdp[i] = min(dp[i], get(ind + 1, n));\n\t}\n\n\tcout << dp[0] + E << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN], v[MAXN];\ndeque<int> p, q;\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nvoid pushp(int x) {\n    while (!p.empty() && f[x] + v[x + 1] - d[x + 1] < f[p.back()] + v[p.back() + 1] - d[p.back() + 1])\n        p.pop_back();\n    p.push_back(x);\n}\n\nvoid pushq(int x) {\n    while (!q.empty() && f[x] + v[x + 1] - 3 * d[x + 1] < f[q.back()] + v[q.back() + 1] - 3 * d[q.back() + 1])\n        q.pop_back();\n    q.push_back(x);\n}\n\nint main() {\n    n = read();\n    if (n > 2000)\n        return 0;\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i) {\n        d[i] = read();\n        v[i] = d[i] - d[i - 1];\n    }\n    p.push_back(0);\n    for (int i = 1, j; i <= n; ++i) {\n        while (!p.empty() && (d[i] - d[p.front() + 1]) * 2 > t) {\n            pushq(p.front());\n            p.pop_front();\n        }\n        f[i] = INF;\n        if (!p.empty()) {\n            j = p.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] + d[i] + t);\n        }\n        if (!q.empty()) {\n            j = q.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - 3 * d[j + 1] + 3 * d[i]);\n        }\n        pushp(i);\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint n, p[2020];\nll d[2020];\nint E, T;\n\nvoid solve(){\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\", p+i);\n\tfor(int i=1;i<=n;i++){\n\t\td[i] = 1e18;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\td[i] = min(d[i], d[j-1] + (p[i] - p[j-1]) + max(T, 2*(p[i] - p[j])));\n\t\t}\n\t}\n\tprintf(\"%lld\", (E - p[n]) + d[n]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//fold\n#ifndef KHALIL\n#include <bits/stdc++.h>\n#else\n#include \"header.h\"\n#endif\n#define endl '\\n'\n#define mp make_pair\n#define tostr(x) static_cast<ostringstream&>((ostringstream()<<dec<<x)).str()\n#define rep(i,begin,end) for(auto i = begin;i < end;i++)\n#define repr(i,begin,end) for(auto i = begin-1;i >= end;i--)\n#define pb push_back\n#define sz(a) ((int)(a).size())\n#define fi first\n#define se second\n#define abs(a) ((a) < (0) ? (-1)*(a) : (a))\n#define SQ(a) ((a)*(a))\n#define eqd(a,b) (abs(a-b)<1e-9)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate <typename t> t in(t q){cin >> q;return q;}\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v){os << \"[\";for (int i = 0; i < sz(v); ++i) { os << v[i]; if (i != sz(v) - 1) os << \",\";}os << \"]\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const map<T, S>& v){for (auto it : v)os << \"(\" << it.first << \":\" << it.second << \")\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const pair<T, S>& v){os << \"(\" << v.first << \",\" << v.second << \")\";return os;}\nconst long double PI = acosl(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\ninline int rand(int l,int r){return uniform_int_distribution<int>(l, r)(rng);}\ninline ll rand(ll l,ll r){return uniform_int_distribution<ll>(l, r)(rng64);}\n//endfold\n#define  N  (100'005)\n#define MOD (1'000'000'007ll)\n#define OO (1'050'000'000)\n#define OOL (1'100'000'000'000'000'000ll)\n\n//global\nll x[N];\nll dp[N];\n\nint main(){\n\t//fold\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcout << setprecision(10);\n\t//endfold\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,0,n){\n\t\tcin >> x[i];\n\t}\n\tdp[n] = 0;\n\tx[n] = e;\n\tqueue<pair<ll,ll>> q;\n\tll mi = OOL;\n\tfor (int i = n-1; i >= 0; --i){\n\t\tll k = lower_bound(x+i+1,x+n,x[i]+(t+1)/2)-x;\n\t\tif(sz(q)) while(q.front().first >= k){\n\t\t\tmi = min(mi,q.front().second);\n\t\t\tq.pop();\n\t\t\tif(q.empty()) break;\n\t\t}\n\t\tll ans = mi-3*x[i];\n\t\tk--;\n\t\tans = min(ans,t+x[k+1]-x[i]+dp[k+1]);\n\t\tdp[i] = ans;\n\t\tq.push({i,2*x[i]+x[i+1]+dp[i+1]});\n\t}\n\tcout << dp[0]+x[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define INF 1000000000000000000LL\nusing namespace std;\ntypedef long long LL;\nLL p[MAXN+5];\nLL dp[MAXN+5];\nint N;\nLL M;\nLL T;\nvoid Init()\n{\n\tmemset(dp,-1,sizeof(dp));\n}\nLL GetVal(int i,int j)\n{\n\treturn dp[j-1]+T-2LL*(p[i]-p[j])+3LL*(p[i]-p[j])+p[j]-p[j-1];\n}\nint main()\n{\n//\tfreopen(\"computer.in\",\"r\",stdin);\n//\tfreopen(\"computer.out\",\"w\",stdout);\n\tInit();\n\tdp[0]=0;\n\tscanf(\"%d %lld %lld\",&N,&M,&T);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%lld\",&p[i]);\n\tLL minval=INF;\n\tint pn=-1;\n\tdp[0]=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint pos=lower_bound(p+1,p+1+N,p[i]-T/2)-p;\n\t\tif(2*(p[i]-p[pos])==T)\n\t\t\tpos++;\n\t\tif(2*(p[i]-p[pos-1])>=T)\n\t\t\twhile(pn<pos-1)\n\t\t\t{\n\t\t\t\tpn++;\n\t\t\t\tif(pn!=0)\tminval=min(dp[pn-1]-2LL*p[pn]-p[pn-1],minval);\n\t\t\t\telse\t\tminval=min(-3LL*p[pn],minval);\n\t\t\t}\n\t\tdp[i]=GetVal(i,pos);\n\t\tdp[i]=min(dp[i],minval+3LL*p[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[N]+M-p[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 2048\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint main()\n{\n  int n;\n  ll x[MAX],e,t;\n\n  cin>>n>>e>>t;\n\n  FOR(i,0,n)cin>>x[i];\n  if(n>MAX)return 0;\n\n  ll ans=e;\n\n  sort(x,x+n);\n  RFOR(i,n,0){\n    bool flag=true;\n    FOR(j,0,i){\n      if((x[i]-x[j])*2<t*(i-j+1)){\n        ans+=(x[i]-x[j])*2;\n        i=j+1;\n        flag=false;\n        break;\n      }\n    }\n    if(flag)ans+=t;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n \ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n \n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n \nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n \nconst int MaxN = 1e5 + 10;\n \nint N, E, T, x[MaxN];\n \nlong long f[MaxN];\n \nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && 2 * (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n \nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint k = find(i);\n\t\tfor (int j = 0; j < k; ++j)\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + 2 * (x[i] - x[j + 1]));\n\t\tfor (int j = k; j < i; ++j)\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + T);\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1000100;\n\nint x[N], n, e, t;\nLL f[N];\n\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tRep(i, n) scanf(\"%d\", &x[i]);\n\t\n\tint j = 0;\n\tLL tmp = 1e18;\n\tRep(i, n) {\n\t\tf[i] = 1e18;\n        while (t <= (x[i] - x[j + 1]) * 2){\n            tmp = min(tmp, f[j] - 2 * x[j + 1]);\n        \tj ++;\t\n\t\t}\n        if(j < i) f[i] = min(f[i], f[j] + t);\n        f[i] = min(f[i], tmp + 2 * x[i]);\n    }\n    printf(\"%lld\\n\", f[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long f[100010],c[100010],d[100010];\nint x[100010];\nint n,e,t,T;\n\ninline void add1(int x,long long o)\n{\n\twhile(x<=n)\n\t{\n\t\tc[x]=min(c[x],o);\n\t\tx+=x&-x;\n\t}\n}\n\ninline long long ask1(int x)\n{\n\tlong long nowans=0x3f3f3f3f3f3f3f3fll;\n\twhile(x)\n\t{\n\t\tnowans=min(nowans,c[x]);\n\t\tx-=x&-x;\n\t}\n\treturn nowans;\n}\n\ninline void add2(int x,long long o)\n{\n\twhile(x)\n\t{\n\t\td[x]=min(d[x],o);\n\t\tx-=x&-x;\n\t}\n}\n\ninline long long ask2(int x)\n{\n\tlong long nowans=0x3f3f3f3f3f3f3f3fll;\n\twhile(x<=n)\n\t{\n\t\tnowans=min(nowans,d[x]);\n\t\tx+=x&-x;\n\t}\n\treturn nowans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tT=t;\n\tif(t%2)T++;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(c,0x3f,sizeof(c));\n\tmemset(d,0x3f,sizeof(d));\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=min(f[i],f[i-1]+x[i]-x[i-1]+t);\n\t\tint now=upper_bound(x+1,x+1+i,x[i]-T/2)-x;\n\t\tif(x[i]-T/2>=x[1])\n\t\t{\n\t\t\tnow--;\n\t\t\tlong long nowans=ask1(now);\n\t\t\tf[i]=min(f[i],3ll*x[i]+nowans);\n\t\t}\n\t\tif(x[i]-T/2<x[1])now=0;\n\t\tnow++;\n\t\tlong long nowans=ask2(i);\n\t\tf[i]=min(f[i],x[i]+nowans);\n\t\t/*for(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif((x[j]-x[i])*2>=t)f[j]=min(f[j],f[i-1]+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t\telse f[j]=min(f[j],f[i-1]+t-2*(x[j]-x[i])+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t}*/\n\t\tadd1(i,-3ll*x[i]+f[i-1]+x[i]-x[i-1]);\n\t\tadd2(i,0ll+t-x[i]+x[i]+f[i-1]-x[i-1]);\n\t}\n\tcout<<f[n]+e-x[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 1e9 + 7;  // 924844033;\nconstexpr int N = 1e5 + 10;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n;\nll T, E, x[N], dp[N], seg[N << 1];\n\ninline void segAssign(int id, ll val) {\n  for (seg[id += n] = val; id > 1; id >>= 1)\n    seg[id >> 1] = min(seg[id], seg[id ^ 1]);\n}\n\ninline ll segGet(int l, int r) {\n  ll res = 1e18;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) smin(res, seg[l++]);\n    if (r & 1) smin(res, seg[--r]);\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n\n  cin >> n >> E >> T;\n  n++;\n  rep(i, 1, n) cin >> x[i];\n\n  int ptr = 0;\n  dp[0] = 0;\n  segAssign(0, dp[0] + T);\n  rep(i, 1, n) {\n    while (2 * (x[i] - x[ptr + 1]) >= T) {\n      segAssign(ptr, dp[ptr] - 2 * x[ptr + 1]);\n      ptr++;\n    }\n    dp[i] = min(segGet(0, ptr) + 2 * x[i], segGet(ptr, i));\n    segAssign(i, dp[i] + T);\n  }\n\n  cout << E + dp[n - 1] << endl;\n\n  return 0;\n}\n\n// 1 2 0 1 2"
  },
  {
    "language": "C++",
    "code": "/*\tAtCoder 2171 Shik and Game\n    1st Edition:2017.11.25 Saturday\n    Algorithm:DP,╣╔╣В╤сап\n*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cstdlib>\n#include <ctime>\n#include <cctype>\nusing namespace std;\n\n#define For(a,b,c) for(int (a)=(b);(a)<=(c);++a)\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define shl(x,y) ((x)<<(y))\n#define shr(x,y) ((x)>>(y))\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef double db;\nconst ll inf=2000000007LL;\nconst double EPS=1e-10;\nconst ll inf_ll=(ll)1e18;\nconst ll maxn=100005LL;\nconst ll mod=1000000007LL;\n\n//input\nint n;\nll T,E;\nll x[maxn];\n\nvoid input(){\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tFor(i,1,n) scanf(\"%lld\",x+i);\n}\n\n//DP\nll f[maxn];\n\nvoid dp_init(){\n\tf[0]=0;\n\tFor(i,1,n) f[i]=inf_ll;\n}\n\nvoid dp_test(){\n\tputs(\"\\ndp tests begin\");\n\tFor(i,1,n) printf(\"%d \",f[i]);\n\tputs(\"\");\n\tputs(\"dp tests end\\n\");\n}\n\nvoid dp_main(){\n\tdp_init();\n\tint divl=0;\n\tll min2=inf_ll;\n\tif(x[1]*2>T) min2=0;\n\tFor(i,1,n){\n\t\tmin2+=2*(x[i]-x[i-1]);\n\t\twhile(divl<i && 2*(x[i]-x[divl+1])>T){\n\t\t\tmin2=min(min2,f[divl]+(x[i]-x[divl+1])*2);\n\t\t\t++divl;\n\t\t}\n//\t\tprintf(\"%d %lld %lld\\n\",divl,f[divl]+T,min2);\n\t\tf[i]=min(min2,f[divl]+T);\n\t}\n\tprintf(\"%lld\\n\",E+f[n]);\n//\tdp_test();\n}\n\n//main\nint main(){\n\tinput();\n\tdp_main();\n\treturn 0;\n}\n\n/*\n3 9 1\n1 3 8\n\n3 9 3\n1 3 8\n\n2 1000000000 1000000000\n1 999999999\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = x[i] - x[j + 1] + f[j];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\tfor (int j = max(0, i - 100000000 / n); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t\tfor (int j = 0; j < min(i, 100000000 / n); j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\n\t\t}\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<ll, int> ii;\n\nconst int len = 1e5+5;\nconst ll inf = 1e15;\nint a[len], n, en, t, nex[len];\nll dp[len], suf[len];\ndeque<ii> deq;\n\nint main(){\n    scanf(\"%d %d %d\", &n, &en, &t);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n\n    for (int i = 1, j = 1; i <= n; i++){\n        while (j <= n && 2*(a[j]-a[i]) <= t)\n            j++;\n        nex[i] = j;\n    }\n\n    deq.push_back(mp(0, n+1));\n    suf[n+1] = inf;\n    for (int i = n; i >= 1; i--){\n        int j = nex[i];\n\n        dp[i] = min(deq.front().fi+t, suf[j]-2*a[i]);\n\n        suf[i] = min(suf[i+1], dp[i+1]+2*a[i]);\n        while (!deq.empty() && dp[i] <= deq.back().fi)\n            deq.pop_back();\n        deq.push_back(mp(dp[i], i));\n        while(!deq.empty() && deq.front().se > nex[i-1])\n            deq.pop_front();\n    }\n\n    printf(\"%lld\\n\", dp[1]+en);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+(A[it-A.begin()]-A[i])*2);\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+T);\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> x[n + 1] >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << x[n + 1] - x[n] + dist[n];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rb(x) ((x)&(-(x)))\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100005;\nconst int MX = 131072;\nstruct SEG {\n   \tSEG() { init(); }\n   \tll d[MX*2];\n   \tvoid init() { fill(d, d+MX*2, INFLL); }\n   \tvoid upd(int x, ll r) {\n   \t\tx += MX; d[x] = r;\n   \t\tfor(x /= 2; x; x /= 2)\n   \t\t\td[x] = min(d[x*2], d[x*2+1]);\n   \t}\n   \tll get(int s, int e) {\n   \t\tll r = INFLL; for(s += MX, e += MX; s <= e; s /= 2, e /= 2) {\n   \t\t\tif(s&1) upmin(r, d[s++]); if(~e&1) upmin(r, d[e--]);\n   \t\t} return r;\n   \t}\n}seg1, seg2;\nll dp[MAXN];\nint A[MAXN];\nint N, T, E;\nint main() {\n  \tscanf(\"%d%d%d\", &N, &E, &T);\n   \tfor(int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n   \tseg1.upd(0, 0);\n   \tseg2.upd(0, -2 * ll(A[1]));\n   \tfor(int i = 1; i <= N; i++) {\n   \t\tll &ret = dp[i];\n   \t\tret = INFLL;\n   \t\tint li = max(0, (int)(lower_bound(A, A+i, A[i] - T/2) - A) - 1);\n   \t\tif(li < i)\n   \t\t\tupmin(ret, seg1.get(li, i-1) + A[i] + T);\n   \t\tif(0 < li)\n  \t\t\tupmin(ret, seg2.get(0, li-1) + ll(A[i])*3);\n   \t\tseg1.upd(i, ret - A[i]);\n   \t\tseg2.upd(i, ret - A[i] - ll(A[i+1])*2);\n   \t}\n   \tprintf(\"%lld\\n\", dp[N] + E - A[N]);\n  \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll dp[2001];\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    ll n,e,t;\n    cin>>n>>e>>t;\n    vector<ll> v;\n    v.pb(0);\n    for(ll i=0;i<n;i++){\n        ll k;\n        cin>>k;\n        v.pb(k);\n    }\n    for(ll i=1;i<=n;i++){\n        dp[i]=9999999999999999;\n    }\n    dp[0]=0;\n    for(ll i=1;i<=n;i++){\n        for(ll j=0;j<i;j++){\n            ll u=3*(v[i]-v[j+1]);\n\n            if(u/3*2<t)\n                u+=(t-u/3*2);\n\n            dp[i]=min(v[j+1]-v[j]+dp[j]+u,dp[i]);\n\n        }\n    }\n    if(e>v[n])\n        dp[n]+=e-v[n];\n    else\n        dp[n]+=v[n]-e;\n    cout<<dp[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconst ll INF = 1e18;\n\nll dfs(int p){\n  if(dp[p]!=-1)return dp[p];\n  dp[p] = INF;\n  FOR(to,p,n){\n    ll len = x[to] - x[p];\n    ll add = max(t,2ll*len);\n    CHMIN(dp[p],add+len+x[to+1]-x[to]+dfs(to+1));\n  }\n  return dp[p];\n}\n\nint main(){\n  scanf(\"%d%lld%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  assert(n<=2000);\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  ll ans = dfs(0);\n  printf(\"%lld\\n\",ans+x[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\ntemplate< typename T >\nstruct SegmentTree\n{\n  const T INF;\n\n  vector< T > seg;\n  int sz;\n\n  SegmentTree(int n) : INF(numeric_limits< T >::max())\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  T merge(T a, T b)\n  {\n    return (min(a, b));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  T rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (merge(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                  rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  T rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, T x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = merge(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  int64 N, T, E, X[100002];\n\n  cin >> N >> T >> E;\n  for(int i = 1; i <= N; i++) cin >> X[i];\n\n  /*\n  int64 dp[2002][2002]; // curr, pending\n  fill_n(*dp, 2002 * 2002, INF);\n  dp[1][0] = 0;\n  dp[1][1] = E;\n*/\n  auto chmin = [](int64 &a, int64 b)\n  {\n    a = min(a, b);\n  };\n\n  /*\n  for(int i = 2; i <= N; i++) {\n    for(int j = 0; j < i; j++) {\n      chmin(dp[i][j], dp[i - 1][j]);\n      chmin(dp[i][i], dp[i - 1][j] + max(E, (X[i] - X[j + 1]) * 2));\n    }\n  }\n  // dp[j]+(X[i]-X[j+1])*2 = dp[j]+X[i]*2-X[j+1]*2\n   // dp2[j]=dp[j]-X[j+1]*2\n  */\n\n\n  SegmentTree< int64 > dp1(N + 1), dp2(N + 1);\n\n  dp1.update(0, 0);\n  dp1.update(1, E);\n  dp2.update(0, dp1.rmq(0, 1) - X[1] * 2);\n  dp2.update(1, dp1.rmq(1, 2) - X[2] * 2);\n\n  for(int i = 2; i <= N; i++) {\n    int low = 0, high = i - 1;\n    while(high - low > 0) {\n      int mid = (low + high) >> 1;\n      if((X[i] - X[mid + 1]) * 2 <= E) high = mid;\n      else low = mid + 1;\n    }\n/*\n    cout << (X[i] - X[low + 1]) * 2 << \" \" << E << endl;\n\n    for(int k = low; k < i; k++) cout << dp[k] << \" \";\n    cout << endl;\n*/\n    dp1.update(i, min(dp1.rmq(low, i) + E, X[i] * 2 + dp2.rmq(0, low)));\n    //cout << low << endl;\n    dp2.update(i, dp1.rmq(i, i + 1) - X[i + 1] * 2);\n  }\n  cout << dp1.rmq(N, N + 1) + T << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,0,n)cin>>x[i];\n    int v=0;\n    while(v<n&&x[v]-x[0]<(t+1)/2)v++;\n    if(v==n)\n    {\n    \tcout<<t+e;\n    \texit(0);\n    }\n    int g=0;\n    if(v!=0)up(1,0,n,0,-2*x[0]);\n    rep(i,v,n)\n    {\n        while(x[i]-x[g+1]>=(t+1)/2)g++;\n    \tdp[i]=2*x[i]+query(1,0,n,0,g+2);\n    \tup(1,0,n,i,dp[i-1]-2*x[i]);\n    \tif(g>=v)dp[i]=min(dp[i],dp[g]+t);\n        else dp[i]=min(dp[i],2*t);\n    }\n    cout<<dp[n-1]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\nlong long dp[MAXN][MAXN];\nint n, a[MAXN], e, t;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tmemset(dp, 127/3, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < i; j++) dp[i][j] = dp[i-1][j]+a[i]-a[i-1];\n\t\tfor (int j = 0; j < i; j++) dp[i][i] = min(dp[i][i], dp[i-1][j]+a[i]-a[i-1]+max(t, 2*(a[i]-a[j+1])));\n\t}\n\tcout << dp[n][n]+e-a[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()]>=dp[xx]-2*x[xx]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\nconst ll inf=1LL<<60;\nll x[200010];\nll dp[2010];\n\nint main(void){\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\tif(n>2000) return 0;\n\trep(i,1,n+1) cin >> x[i];\n\n\trep(i,1,n+1){\n\t\tdp[i]=inf;\n\t\trep(j,i){\n\t\t\tll d=x[i]-x[j];\n\t\t\tchmin(dp[i],dp[j]+d+max(t,2*(x[i]-x[j+1])));\n\t\t}\n\t}\n\n\t//rep(i,n+1) cout << dp[i] << endl;\n\tcout << dp[n]+e-x[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define inf 10000000000000000\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, E, T, x[N], dp[N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nsigned main(){\n    n = read(), E = read(), T = read();\n    rep(i, 1, n) x[i] = read();\n    rep(i, 1, n) dp[i] = inf;\n    rep(i, 1, n){\n        rep(j, 0, i - 1){\n            dp[i] = min(dp[i], dp[j] - x[j] - 2 * x[j + 1] + max(2 * x[i], T + 2 * x[j + 1]) + x[i]);\n        }\n        //printf(\"now here is %lld %lld\\n\", i, dp[i]);\n    } \n    printf(\"%lld\", E - x[n] + dp[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n\tint N;\n\tlong long E,T;\n\tcin>>N>>E>>T;\n\tint i;\n\tvector<long long> x(N,0);\n\tvector<long long> t(N,0);\n\tfor (i=0;i<N;i++){\n\t\tcin>>x[i];\n\t\tt[i]=T;\n\t}\n\tlong long dist=0;\n\tlong long d=0;\n\tfor (i=1;i<N;i++){\n\t\td=x[i]-x[i-1];\n\t\tif (t[i-1]<d){\n\t\t\tdist+=t[i-1];\n\t\t\tt[i-1]=0;\n\t\t}else{\n\t\t\tdist +=max(T,2*d);\n\t\t\tt[i-1] -= 2*d;\n\t\t\tif (t[i-1]<0){\n\t\t\t\tt[i-1]=0;\n\t\t\t}\n\t\t\tt[i] -= 2*d;\n\t\t\tif (t[i]<0){\n\t\t\t\tt[i]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (x[N-1]<E){\n\t\tdist +=t[N-1];\n\t\tt[N-1]=0;\n\t}\n\tdist+=E;\n\tcout<<dist<<endl;\n\tx.clear();\n\tt.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nvector<int>x, memo;\nint N, E, T;\n\nint solve(int posindex) {\n\t//x[posindex]の位置についた直後で、自分より手前の熊は処理済みで、自分より奥の熊は手付かず\n\n\tif (posindex == N)return 0;\n\tif (memo[posindex] != -1)return memo[posindex];\n\n\tint ans = intmax;\n\n\t//その場で待つ\n\tans = min(ans, solve(posindex + 1) + T + x[posindex + 1] - x[posindex]);\n\n\t//先まで行く\n\tREP(i, posindex+1, N) {\n\t\tint sol = solve(i + 1);\n\t\tint dist = x[i] - x[posindex];\n\t\tint gets = max(T + dist, dist * 3);\n\t\tans = min(ans, sol + gets + x[i + 1] - x[i]);\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tx = vector<int>(N+1);\n\tmemo = vector<int>(N,-1);\n\trep(i, N)cin >> x[i];\n\tx[N] = E;\n\tsort(ALL(x));\n\n\n\t\n\tcout << x[0] + solve(0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 2048\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint main()\n{\n  int n;\n  ll x[MAX],e,t;\n\n  cin>>n>>e>>t;\n\n  FOR(i,0,n)cin>>x[i];\n  if(n>MAX)return 0;\n\n  ll ans=e;\n\n  sort(x,x+n);\n  RFOR(i,n,0){\n    bool flag=true;\n    FOR(j,0,i){\n      if((x[i]-x[j])*2<t*(i-j+1)){\n        ans+=(x[i]-x[j])*2;\n        i=j;\n        flag=false;\n        break;\n      }\n    }\n    if(flag)ans+=t;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ninline void gtmn(LL &a,LL b){\n\tif (a>b) a=b;\n}\ninline void gtmx(LL &a,LL b){\n\tif (a<b) a=b;\n}\nint a[100010];\nLL coef[100010];\nLL dp[100010];\nint main(void){\n\tmemset(coef,255,sizeof(coef));\n\tmemset(dp,127,sizeof(dp));\n\tdp[0]=0;\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\ta[0]=0;\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (i) gtmx(coef[i],coef[i-1]);\n\t\tif (~coef[i]){\n\t\t\tgtmn(dp[i],3ll*a[i]-coef[i]);\n\t\t}\n\t\tgtmn(dp[i+1],dp[i]+a[i+1]-a[i]+t);\n\t\tint l=i+1,r=n+1;\n\t\twhile(l+1<r){\n\t\t\tint md=(l+r)>>1;\n\t\t\tif (((a[md]-a[i+1])<<1)<=t){\n\t\t\t\tl=md;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=md;\n\t\t\t}\n\t\t}\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t\t++l;\n\t\tif (l<=n){\n\t\t\tgtmx(coef[l],3ll*a[i]+dp[i]+a[i+1]-a[i]);\n\t\t}\n\t\tif (l>i+1&&l<=n){\n\t\t\tgtmn(dp[l],0ll+dp[i]+a[i+1]-a[i]+(a[l]-a[i+1])*2+max(t-a[l]+a[i+1],a[l]-a[i+1]));\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\",dp[n]+e-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <iostream>\n#include <sstream>\n#include <complex>\n#include <cassert>\n#include <bitset>\n\n#define enp     puts(\"**chkchkchkchkchk**\")\n#define A       first\n#define B       second\n#define MP      make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\n\nconst int INF = 0x60000000;\nconst int MINF = -1000000000;\nconst int mod = 1000000007;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\nconst int sqrtMax = 317;\nconst int blocks = cons / 3;\n\nll dp[2001];\nll pos[2001];\nint n;\nll e, t;\n\nint main() \n{\n\tscanf(\"%d%lld%lld\", &n, &e, &t);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lld\", &pos[i]);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tdp[i] = 1e18;\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tll st = dp[j];\n\t\t\tll diff = pos[i] - pos[j];\n\t\t\tll diff2 = pos[i] - pos[j + 1];\n\n\t\t\tll cur = st + pos[j + 1] - pos[j];\n\t\t\tll tmp = (cur + t) - (st + diff + diff2);\n\t\t\tll wait = tmp >= 0 ? tmp : 0;\n\n\t\t\tdp[i] = min(dp[i], st + diff + diff2 * 2 + wait);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", e - pos[n] + dp[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (R int i = 1; i <= n; ++i) a[i] = F();\n\tfor (R int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = 1ll * i * T;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tlong long S = a[i] - a[j];\n\t\t\tcmin(f[i], f[j - 1] + dmax(S * 2, T));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + E );\n\treturn 0;\n}\n/*\n4 8 2\n1 2 6 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst long long INF = 1e18;\nint x[N];\nlong long f[N];\nlong long calc(int j) {\n\treturn f[j] - x[j];\n}\nint main() {\n\tint n, E, T;\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &x[i]);\n\tdeque<int> q;\n\tx[0] = 0;\n\tq.push_back(0);\n\tlong long MIN = INF;\n\tint r = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\twhile (2 * (x[i] - x[r + 1]) >= T) {\n\t\t\tMIN = min(MIN, - 2LL * x[r + 1] - x[r] + f[r]);\n\t\t\t++ r;\n\t\t}\n\t\twhile (q.front() < r) q.pop_front();\n\t\tint t = q.front();\n\t\tf[i] = min(3LL * x[i] + MIN, x[i] + T + calc(t));\n\t\twhile (!q.empty() && calc(q.back()) > calc(i)) q.pop_back();\n\t\tq.push_back(i);\n\t}\n\tlong long ans = E - x[n] + f[n];\n\tprintf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N],p[N];int n,e,t;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&e,&t);\n    fo(i,1,n) scanf(\"%lld\",&p[i]);\n    memset(f,63,sizeof(f));f[0]=0;\n    ll mn=inf;\n    for(int i=1,j=0;i<=n;i++) {\n        for(;t<=(p[i]-p[j+1])<<1;j++)\n            mn=min(mn,f[j]-2*p[j+1]);\n            if(j<i) f[i]=min(f[i],f[j]+t);\n            f[i]=min(f[i],mn+2*p[i]);\n    }\n    printf(\"%lld\\n\",f[n]+e);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\nconst ll INF = (1ll << 60) - 1;\n\nint n,E,T;\nint head,tail;\nint Q[MAXN];\n\nll MIN;\nll x[MAXN];\nll f[MAXN];\nll g1[MAXN];\nll g2[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> E >> T;\n\tfor (int i = 1;i <= n;i++)\n\t\tcin >> x[i];\n\tMIN = INF;\n\thead = tail = 1;\n\tg1[0] = -2 * x[1];\n\tg2[0] = T;\n\tfor (int i = 1,j = -1;i <= n;i++)\n\t{\n\t\twhile (j + 1 < i && 2 * (x[i] - x[j + 2]) >= T)\n\t\t\tMIN = min(MIN,g1[++j]);\n\t\twhile (head <= tail && Q[head] <= j)\n\t\t\thead++;\n\t\tf[i] = MIN + 3 * x[i];\n\t\tif (head <= tail)\n\t\t\tf[i] = min(f[i],g2[Q[head]] + x[i]);\n\t\tg1[i] = f[i] - x[i] - 2 * x[i + 1];\n\t\tg2[i] = f[i] - x[i] + T;\n\t\twhile (head <= tail && g2[Q[tail]] >= g2[i])\n\t\t\ttail--;\n\t\tQ[++tail] = i;\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n// 600pt\n\nconstexpr int MOD = 1000000007;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nconstexpr LL INF = 1LL << 60;\n\nLL N, E, T;\nLL x[2000];\nLL dp[2005][2005];\n\nint main() {\n\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for (int j = 1; j <= N; ++j) {\n        cin >> x[j];\n    }\n\n    if (N > 2000) {\n        assert(false);\n    }\n\n    for (int j = 0; j <= N; ++j) {\n        fill(dp[j], dp[j]+N+1, INF);\n    }\n\n    for (int j = 0; j <= N; ++j) {\n        dp[j][0] = x[j];\n    }\n\n    for (int j = 1; j <= N; ++j) {\n        for (int k = 1; k < j; ++k) {\n            dp[j][j] = min(\n                    dp[j][j],\n                    max(dp[j][k-1] + T,\n                        dp[k][k-1] + max(T, 2*(x[j]-x[k])) + x[j]-x[k])\n                    );\n        }\n        dp[j][j] = min(dp[j][j], dp[j][j-1] + T);\n\n        for (int k = j+1; k <= N; ++k) {\n            dp[k][j] = dp[j][j] + (x[k]-x[j]);\n        }\n    }\n\n    cout << (dp[N][N] + E - x[N]) << endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif(max(t,(x[i]-x[j+1])*2)+dp[j]>dp[i])\n\t\t\tbreak;\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream> \nusing namespace std;\nlong long d[100003],a[100003],q[100003];\nint n,m,T,s,t;\nint main(){\n\tcin>>n>>m>>T;\n    for(int i=1;i<=n;i++){\n    \tcin>>a[i];\n        d[i]=1e15;\n    }\n    s=1,t=1;\n    long long z=1e15;\n    for(int i=1;i<=n;i++){\n        while(s<=t&&2*(a[i]-a[q[s]+1])>T){\n            z=min(z,d[q[s]]-a[q[s]]-2*a[q[s]+1]);\n            s++;\n        }\n        d[i]=min(d[i],a[i]+z+2*a[i]);\n        d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+T);\n        while(s<=t&&d[q[s]]-a[q[s]]>=d[i]-a[i]){\n        \tt--;\n\t\t}\n        q[++t]=i;\n    }\n    long long ans=d[n]+m-a[n];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nifstream fin (\"contest.in\");\nofstream fout (\"contest.out\");\n\n#define MAX 100000\nlong long n, e, t, x[MAX + 1], d, sum;\n\nlong long maxim (long long A, long long B)\n{\n    if (A > B)return A;\n    else return B;\n}\nint main()\n{\n    fin >> n >> e >> t;\n    for (int i = 1; i <= n; i++)fin >> x[i];\n\n    sum = e;\n    for (int i = 1; i < n; i++)\n    {\n        int ind = i + 1;\n        d = x[ind] - x[i];\n        while (d < t && ind <= n)\n        {\n            ind ++;\n            d = x[ind] - x[i];\n        }\n        ind--;\n        if (i == ind)sum += t;\n        else\n        {\n            d = x[ind] - x[i];\n            sum += maxim(t - 2 * d, 0) + 2 * d;\n            i = ind;\n        }\n        if (i == ind && i == n- 1)sum +=t;\n    }\n    fout << sum;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <vector>\n#include <array>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <valarray>\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;Scan(__VA_ARGS__);\ntemplate<typename T> void Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void Scan(First& first, Rest&...rest) { std::cin >> first; Scan(rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\t\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& i : v){std::cerr << i << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr << j << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr<<'('<<j.first<<\", \"<<j.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& i:v){std::cerr<<'('<<i.first<<\", \"<<i.second<<\") \";}std::cout<<\"\\n\";}\n#define CHECKTIME(state) {auto start=std::chrono::system_clock::now();state();auto end=std::chrono::system_clock::now();auto res=std::chrono::duration_cast<std::chrono::nanoseconds>(end-start).count();std::cerr<<\"[Time:\"<<res<<\"ns  (\"<<res/(1.0e9)<<\"s)]\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\n#define CHMAX(a, b) a = (((a)<(b)) ? (b) : (a))\n#define CHMIN(a, b) a = (((a)>(b)) ? (b) : (a))\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^19\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238;\n\nint dp[2003][2003];\nint tt[2003];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\tassert(n <= 2000);\n\n\tauto calc = [&](int i, int j) {\n\t\treturn 3 * (x[j] - x[i]) + std::max(t - 2 * (x[j] - x[i]), 0LL);\n\t};\n\n\tREP(i, n) FOR(j, i, n) {\n\t\tdp[i][j] = calc(i, j);\n\t}\n\n\tstd::fill(tt, tt + n+1, INFLL);\n\ttt[0] = x[0];\n\n\tauto xx = [&](ll i) {\n\t\treturn (i == n) ? e : x[i];\n\t};\n\n\tREP(i, n+1) {\n\t\tif (i != 0) {\n\t\t\tCHMIN(tt[i], tt[i - 1] + t + xx(i) - x[i - 1]);\n\t\t}\n\t\tREP(j, i) {\n\t\t\tCHMIN(tt[i], tt[j] + dp[j][i-1] + xx(i) - x[i - 1]);\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tOUT(dp[i][j])SP;\n\t\t}BR;\n\t}\n\tREP(i, n+1) {\n\t\tOUT(tt[i])SP;\n\t}BR;\n\n\tOUT(tt[n])BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint st[800005][2]; \nvoid update(ll root, ll l, ll r, ll i, ll val, ll id){\n\tif (i < l || r < i) return;\n\tif (l == r){\n\t\tst[root][id] = val; return;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(root * 2 + 1, l, mid, i, val, id);\n\tupdate(root * 2 + 2, mid + 1, r, i, val, id);\n\tst[root][id] = min(st[root * 2 + 1][id], st[root * 2 + 2][id]);\n}\nll query(ll root, ll l, ll r, ll u, ll v, ll id){\n\tif (v < l || r < u) return 1e12;\n\tif (u <= l && r <= v) return st[root][id];\n\tll mid = (l + r) / 2;\n\treturn min(query(root * 2 + 1, l, mid, u, v, id), query(root * 2 + 2, mid + 1, r, u, v, id));\n}\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\tdp[0] = 0;\n\tupdate(0, 0, n - 1, 0, dp[0] - 2 * a[1], 0);\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tll lw; \n\t\tll l = 0, r = i - 1;\n\t\twhile (l < r){\n\t\t\tll mid = (l + r) / 2;\n\t\t\tif ((a[i] - a[mid]) * 2 <= t) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tlw = l;\n\t\tdp[i] = min(query(0, 0, n - 1, 0, lw - 1, 0) + 3 * a[i], query(0, 0, n - 1, lw, i - 1, 1) + a[i] + t);\n\t\tupdate(0, 0, n - 1, i, dp[i] - 2 * a[i + 1] - a[i], 0); update(0, 0, n - 1, i, dp[i] - a[i], 1);\n\t}\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tfz(i,1,n){\n\t\tint mn=0x3f3f3f3f3f3f3f3fll;\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n//\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\tmn=min(mn,dp[j]+2*(a[i]-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n//\t\tcout<<\"mn=\"<<mn<<endl;\n\t\tdp[i]=min(dp[i],dp[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn);\n//\t\tcout<<dp[i]<<endl;\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+E<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n;\nll E, T, dp[maxN], minF[maxN], x[maxN];\n\nint main () {\n    cin >> n >> E >> T;\n    fto(i, 1, n) cin >> x[i];\n    x[n+1] = E;\n\n    dp[0] = x[1];\n    int j = 1;\n    fto(i, 1, n) {\n        while (2*(x[i]-x[j]) >= T) ++j;\n        dp[i] = dp[j-1] + x[i+1] + x[i] - 2*x[j] + T;\n        if (j > 1) dp[i] = min(dp[i], minF[j-1] + x[i+1] + 2*x[i]);\n        minF[i] = min(minF[i-1], dp[i-1]-3*x[i]);\n    }\n\n    printf(\"%lld\", dp[n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nlong long DP[100001];\n\nint main()\n{\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int>x(N+1);\n\tfor (int i = 0; i < N; i++)cin >> x[i];\n\tx[N] = E;\n\tvector<long long>sum(N+1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum[i] = sum[i-1] + x[i] - x[i-1];\n\t}\n\n\tfor (int i = 0; i <= N; i++)DP[i] = INT64_MAX;\n\n\tDP[0] = x[0];\n\tfor (int i = 0; i < N; i++) {\t\n\t\tfor (int j = i; j < N; j++) {\n\t\t\tif (sum[j] - sum[i] > T)break;\n\n\t\t\tDP[j+1] = min(DP[j+1], DP[i] + max((long long)0,(T-2*(sum[j]-sum[i]))) + 3*(sum[j]-sum[i]) + sum[j+1]-sum[j]);\n\t\t\t//cerr << i << \" \" << j << \" \" << DP[j + 1] << endl;\n\t\t}\n\n\t\t//cerr << DP[i] << endl;\n\t}\n\n\tcout << DP[N] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Grand Contest 007\n// D - Shik and Game\n\n#include <cstdio>\n#include <algorithm>\n#define MAX_N 100000\n#define MAX_ELEMENTS (1 << 17)\n#define INF 1e18\nusing namespace std;\n\n\ntypedef long long int ll;\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  int n;\n  T dat[2 * MAX_ELEMENTS - 1];\n  void init(int _n);\n  void update(int k, T a);\n  T query(int a, int b, int k, int l, int r);\n  T query(int a, int b);\n};\n\ntemplate <typename T>\nvoid SegmentTree<T>::init(int _n) {\n  n = 1;\n  while (n < _n) {\n    n <<= 1;\n  }\n  for (int i = 0; i < 2 * n - 1; i++) {\n    dat[i] = INF;\n  }\n  return;\n}\n\ntemplate <typename T>\nvoid SegmentTree<T>::update(int k, T a) {\n  k += n - 1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n  return;\n}\n\n// [a, b), [l, r)\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b, int k, int l, int r) {\n  if (r <= a || b <= l) {\n    return INF;\n  }\n  if (a <= l && b <= r) {\n    return dat[k];\n  }\n  return min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n}\n\ntemplate <typename T>\nT SegmentTree<T>::query(int a, int b) {\n  return query(a, b, 0, 0, n);\n}\n\n\nint N, E, T;\nSegmentTree<ll> st;\nint x[MAX_N + 1];\nll dp[MAX_N + 1];\n\nint main() {\n\n  int j;\n\n  scanf(\"%d%d%d\", &N, &E, &T);\n  x[0] = 0;\n  for (int i = 1; i <= N; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  dp[0] = 0;\n  st.init(N);\n  st.update(0, dp[0]);\n  j = 0;\n  for (int i = 1; i <= N; i++) {\n    dp[i] = INF;\n    for (; (x[i] - x[j + 1]) * 2 > T; j++) {\n      dp[i] = min(dp[i], dp[j] + (x[i] - x[j + 1]) * 2);\n    }\n    dp[i] = min(dp[i], st.query(j, i) + T);\n    st.update(i, dp[i]);\n  }\n\n  printf(\"%lld\\n\", dp[N] + E);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[100005];\nint n,e,t;\nint x[100005];\nstruct SGT{\n\t#define SIZE 131072\n\tint f[SIZE<<1],ql,qr;\n\tvoid modify(int x,int v){\n\t\tx+=SIZE;f[x]=v;\n\t\twhile(x!=1){\n\t\t\tx>>=1;\n\t\t\tf[x]=min(f[x<<1],f[x<<1|1]);\n\t\t}\n\t}\n\tint _query(int L,int R,int k){\n\t\tif(R<ql||qr<L)return inf*inf;\n\t\tif(ql<=L&&R<=qr)return f[k];\n\t\treturn min(_query(L,(L+R)/2,k<<1),_query((L+R)/2+1,R,k<<1|1));\n\t}\n\tint query(int l,int r){\n\t\tif(l>r)return inf*inf;\n\t\tql=l;qr=r;return _query(0,SIZE-1,1);\n\t}\n}T1,T2;\nsigned main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tmemset(dp,inf,sizeof dp);\n\tdp[0]=0;T1.modify(0,-x[1]*2);T2.modify(0,-x[1]);\n\tfor(int i=1;i<=n;i++){\n\t\t/*\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+max(3ll*(x[i]-x[j]),x[i]-x[j]+t));\n\t\t}*/\n\t\tint L=0,R=i+1;\n\t\twhile(R-L>1){\n\t\t\tint mid=(L+R)/2;\n\t\t\tif(2ll*(x[i]-x[mid])>=t)L=mid;\n\t\t\telse R=mid;\n\t\t}\n\t\t//[0,L-1]\n\t\tdp[i]=min(dp[i],T1.query(0,L-1)+x[i]*3);\n\t\t//[L,i-1]\n\t\tdp[i]=min(dp[i],T2.query(L,i-1)+t+x[i]);\n\t\tT1.modify(i,dp[i]-x[i]-x[i+1]-x[i+1]); \n\t\tT2.modify(i,dp[i]-x[i]);\n\t}\n//\tfor(int i=1;i<=n;i++)cerr<<i<<\" \"<<dp[i]<<endl;\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tassert(n <= 2000);\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int q = 0; q < i; ++q) {\n\t\t\tlong long cost = max(inputs[i] - inputs[q + 1], t - (inputs[i] - inputs[q + 1]));\n\t\t\tcost += inputs[i] - inputs[q + 1];\n\t\t\tdp[i] = min(dp[i], dp[q] + cost);\n\t\t}\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "v#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <int> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    ll go = 0;\n    for (int j = i + 1; j <= n; ++j) {\n      go += x[j] - x[j - 1];\n      dp[j] = min(dp[j], dp[i] + go + (ll)t * (j - i));\n      ll back = 2 * (go - (x[i + 1] - x[i]));\n      ll extra = max(0LL, t - back);\n      dp[j] = min(dp[j], dp[i] + go + 2 * (go - (x[i + 1] - x[i])) + extra);\n    }\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[200010];\nint main() {\n    ll N, E, T; scanf(\"%lld%lld%lld\", &N, &E, &T);\n\n    vector<ll> S(N+1);\n    for(int i=0; i<N; i++) {\n        scanf(\"%lld\", &S[i+1]);\n    }\n\n    fill(dp, dp + N + 1, LONGINF);\n    dp[0] = 0;\n    vector<ll> f1(N+1, -LONGINF), f2(N+1, -LONGINF);\n    \n    ll ans = (S[1] - 0) + (E - S[N]), j = 0, d = 0;\n    for(int i=0; i<=N; i++) {\n        if(i == N) continue;\n        ll e = (i+1 < N ? S[i+2] - S[i+1] : 0);\n        while(j <= i and 2*(S[i+1] - S[j+1]) >= T) {\n            ll v = dp[j] - 3*S[j+1];\n            f1[j] = v - 3*d;\n            if(j > 0) chmin(f1[j], f1[j-1]);\n            j++;\n        }\n        {\n            ll v = dp[i] + T;\n            f2[i] = v - d;\n        }\n        /*\n        for(int j=0; j<=i; j++) {\n            ll d = S[i+1] - S[j+1];\n            ll c1 = dp[j] + 3*d, c2 = dp[j] + T + d;\n            chmin(dp[i+1], max(c1, c2) + e);\n        }\n        */\n        \n        // fprintf(stderr, \"min_v_1 = %lld, min_v_2 = %lld\\n\", min_v_1, min_v_2);\n        chmin(dp[i+1], min((j ? f1[j-1] + 3*(S[i+1]+d) : LONGINF), f2[j]+d) + e);\n        // fprintf(stderr, \"dp[%d] = %lld\\n\", i+1, dp[i+1]);\n        \n        d += S[i+2] - S[i+1];\n        // fprintf(stderr, \"d = %lld\\n\", d);\n        /*\n        c1 += 3*d;\n        c2 += d;\n        */\n        // fprintf(stderr, \"after: c1 = %lld, c2 = %lld\\n\", c1, c2);\n    }\n    ans += dp[N];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,S,T,i,la,now,f[200001],a[200001];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&S,&T);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tla=0;now=1e9;\n\tfor(i=1;i<=n;i++){\n\t\twhile(la<i&&2*(a[i]-a[la+1])>T){\n\t\t\tnow=min(now,f[la]-2*a[la+1]);\n\t\t\tla++;\n\t\t}\n\t\tf[i]=min(2*a[i]+now,f[la]+T);\n\t}\n\tf[n]+=a[n]+abs(a[n]-S);\n\tprintf(\"%lld\",f[n]);\n}\n/*\n最后肯定被分成一段段 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\n\ninline void chk_min(ll &a,ll b){ if(a>b) a=b;}\n\nstruct Queue\n{\n\tint q[MAXN],hd,tl;\n\tQueue(void){ hd=tl=0;}\n\tinline bool empty(void){ return hd>=tl;}\n\tinline int front(void){ return q[hd+1];}\n\tinline int back(void){ return q[tl];}\n\tinline void push(int x){ q[++tl]=x;}\n\tinline void pop(void){ ++hd;}\n}q;\n\nint a[MAXN];\nll dp[MAXN];\n\nint main(void)\n{\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\n\tmemset(dp,0x3f,sizeof(dp));\n\t\n\tdp[0]=0;\n\tq.push(0);\n\tll mn=linf;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twhile(!q.empty() && (a[i]-a[q.front()+1])*2 > t)\n\t\t\tchk_min(mn, dp[q.front()] - 2*a[q.front()+1]),\n\t\t\tq.pop();\n\t\t\n\t\tif(!q.empty()) chk_min(dp[i], dp[q.front()]+t);\n\t\telse chk_min(dp[i],t);\n\t\t\n\t\tchk_min(dp[i], mn+2*a[i]);\n\t\tq.push(i);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nlong long mn=3e18;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[st+1])>t)\n\t\t{\n\t\t\tmn=min(mn,dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=min(dp[i-1]+x[i]-x[i-1]+t,mn+3LL*x[i]);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, E, T, a[100001];\nlong long f[100001];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tf[i] = 1LL << 60;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tf[i] = std::min(f[i], f[j] + (a[i] - a[j]) + 2 * (a[i] - a[j + 1]) + std::max(0, T - 2 * (a[i] - a[j + 1])));\n\t}\n\tprintf(\"%lld\\n\", f[N] + E - a[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tfor(int j=Max;j>=0;j--){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t/*\tif(max(t,(x[i]-x[j+1])*2)+dp[j]>dp[i])\n\t\t\tbreak;*/\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n + 10, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint l = 0;\n\tvi p(n + 1);\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\tvl dp(n + 10, INF);\n\tdp[0] = e;\n\tvl dp2(n + 10, INF);\n\tdp2[0] = INF; dp2[1] = INF; dp2[2] = e-2*x[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tdp[i] = dp[max(0,p[i]-1)] + t;\n\t\t/*for (int j = 0; j+1<p[i]; j++) {\n\t\t\tmi = min(mi, dp[j] -2 *  x[j + 1]);\n\t\t}*/\n\t\tmi = dp2[p[i]];\n\t\tdp[i] = min(dp[i],mi+2*x[i]);\n\t\tdp2[i + 2] = min(dp2[i + 1], dp[i] - 2 * x[i + 1]);\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\nusing namespace std;\nint n,t,e;\nint loc[2005];\nlong long dp[2005];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&loc[i]);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tdp[i]=1e18;\n\t\tfor (int j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[j]+(loc[i]-loc[j])+max(t,2*(loc[i]-loc[j+1])),dp[i]);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n]+e-loc[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0, cnt = 1000;\n\tdp[1] = A[1] + T;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\t//for(int j = 0; j < i; ++ j)\n\t\twhile(cur + 1 < i && calc(cur, i) >= calc(cur + 1, i)) ++ cur;\n\t\tbool ok = 0;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 1000; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t\telse ok = 1;\n\t\t}\n\t\tif(!ok && cnt) {\n\t\t\t-- cnt;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 100000; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t\telse ok = 1;\n\t\t}\t\t\t\n\t\t}\n\t\tdp[i] = min(calc(cur, i), dp[i]);\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint dp[100005];\n\n// ------------>8---------- LazySegmentTree ---------->8------------\n\n// ## write [ LST lst(n, SUM/MAX/MIN, ADD/UPD) ] when using this snippet.\nenum QUERY_SEG_LazySegmentTree { SUM, MAX, MIN };\nenum QUERY_LAZ_LazySegmentTree { ADD, UPD };\ntemplate<class SEG, class LAZ>\nclass LazySegmentTree {\nprivate:\n\tstd::vector<SEG> seg;\n\tstd::vector<LAZ> laz;\n\tstd::vector<bool> isUpdated;\n\tint ARY_SIZE;\n\tSEG eSeg;\n\tLAZ eLaz;\n\tstd::function<SEG(SEG&, SEG&)> mergeSeg;\n\tstd::function<LAZ(LAZ&, LAZ&)> mergeLaz;\n\tstd::function<SEG(SEG&, LAZ&, int)> applyLaz;\n\n\tvoid push(int k, int l, int r) {\n\t\tif (!isUpdated[k]) {\n\t\t\tapplyLaz(seg[k], laz[k], r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tmergeLaz(laz[k * 2 + 1], laz[k]); isUpdated[k * 2 + 1] = false;\n\t\t\t\tmergeLaz(laz[k * 2 + 2], laz[k]); isUpdated[k * 2 + 2] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = eLaz;\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n, QUERY_SEG_LazySegmentTree qSeg, QUERY_LAZ_LazySegmentTree qLaz) : ARY_SIZE(1) {\n\t\tARY_SIZE = 1;\n\t\twhile (ARY_SIZE < n) ARY_SIZE *= 2;\n\t\tseg.resize(ARY_SIZE * 2 - 1);\n\t\tlaz.resize(ARY_SIZE * 2 - 1);\n\t\tisUpdated.resize(ARY_SIZE * 2 - 1, true);\n\n\t\tswitch (qSeg) {\n\t\tcase SUM:\n\t\t\teSeg = 0;\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return l + r; };\n\t\t\tbreak;\n\t\tcase MAX:\n\t\t\teSeg = std::numeric_limits<SEG>::lowest();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::max(l, r); };\n\t\t\tbreak;\n\t\tcase MIN:\n\t\t\teSeg = std::numeric_limits<SEG>::max();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::min(l, r); };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (qLaz)\n\t\t{\n\t\tcase ADD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l += r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s += l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s += l; };\n\t\t\tbreak;\n\t\tcase UPD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l = r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s = l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s = l; };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid update(int a, int b, SEG v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tLAZ la(v);\n\t\t\tmergeLaz(laz[k], la);\n\t\t\tisUpdated[k] = false;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = mergeSeg(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\t// ## update [l, r) with v\n\tvoid update(int l, int r, SEG v) {\n\t\tupdate(l, r, v, 0, 0, ARY_SIZE);\n\t}\n\tSEG query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return eSeg;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tSEG vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tSEG vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn mergeSeg(vl, vr);\n\t}\n\t// ## return SUM/MAX/MIN in [l, r)\n\tSEG query(int l, int r) {\n\t\treturn query(l, r, 0, 0, ARY_SIZE);\n\t}\n};\n\nusing LST = LazySegmentTree<ll, ll>;\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nint solve(std::vector<int> x, int T) {\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l >= r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tLST lst(n, MIN, ADD);\n\tdp[0] = T;\n\n\tFOR(i, 1, n) {\n\t\tint pre = std::lower_bound(ALL(x), x[i - 1] - T / 2) - x.begin();\n\t\tint t = std::lower_bound(ALL(x), x[i] - T / 2) - x.begin();\n\t\tFOR(j, pre, t) {\n\t\t\tlst.update(j, j + 1, dp[j] + cost(j + 1, i) - lst.query(j, j + 1));\n\t\t}\n\t\tlst.update(0, pre, (x[i] - x[i - 1]) * 2);\n\t\tlst.update(i - 1, i, dp[i - 1] + T - lst.query(i - 1, i));\n\n\t\tdp[i] = std::min(lst.query(0, i), cost(0, i));\n\t}\n\treturn dp[n - 1];\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\n\tint ans = e;\n\tRREP(i, n) x[i] -= x[0];\n\tans += solve(x, t);\n\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define P pair<LL,LL>\nconst LL inf = 0x3f3f3f3f;\nconst LL mod = 924844033;\nconst LL N = 1e5+10;\ntemplate <typename tp> inline void read(tp &x)\n{\n\tx=0;char c=getchar();int f=0;\n\tfor(;c>'9'||c<'0';f|=(c=='-'),c=getchar());\n\tfor(;c<='9'&&c>='0';x=(x<<3)+(x<<1)+c-'0',c=getchar());\n\tif(f) x=-x;\n}\nLL n,e,t;\nLL x[N],dp[N];\nsigned main()\n{\n\tread(n),read(e),read(t);\n\tfor(int i=1;i<=n;i++) read(x[i]);\n\tmemset(dp,inf,sizeof(dp));\n\tLL flag=inf;dp[0]=0;\n\tfor(int i=1,now=0;i<=n;i++)\n\t{\n\t\twhile(t<=2*(x[i]-x[now+1]))\n\t\t\tflag=min(flag,dp[now]-2*x[now+1]),now++;\n\t\tdp[i]=min(dp[now]+t,flag+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long p[1100000];\nlong long dp[1100000];\nlong long dp2[1100000];\nlong long T;\nlong long calc(int a,int b){\n\tlong long ret=max(T,(p[b]-p[a+1])*2);\n//\tprintf(\"%d %d: %lld\\n\",a,b,ret);\n\treturn ret;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tT=c;\n\tfor(int i=0;i<a;i++)scanf(\"%lld\",p+i+1);\n\tfor(int i=0;i<=a;i++)dp[i]=dp2[i]=99999999999999999LL;\n\tdp[0]=0;\n\t//dp2[0]=0;\n\tint t=1;\n \n\tfor(int i=1;i<=a;i++){\n\t\twhile((p[i]-p[t])*2>T){\n\t\t\tt++;\n\t\t}\n\t\tdp[i]=min(dp[t-1]+T,dp2[t-1]+p[i]*2);\n\t\tdp2[i]=min(dp2[i-1],dp[i-1]-p[i]*2);\n\t//\tprintf(\"%lld %lld\\n\",dp[i],dp2[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[a]+b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+15;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, 0), sgt2(N+1, 0);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j != 0){\n            tmp1 = sgt2.query(0, min(j, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(st2.find(dp[last] - x[last] + t));\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FILE \"chad\"\n#define ll long long\n#define up(i,j,k) for(int i=(j);i<=(k);i++)\n#define pii pair<int,int>\ntemplate<class T> bool cmin(T& a,T b){return a>b?a=b,true:false;}\ntemplate<class T> bool cmax(T& a,T b){return a<b?a=b,true:false;}\ntemplate<class T> T max(T& a,T& b){return a>b?a:b;}\ntemplate<class T> T min(T& a,T& b){return a<b?a:b;}\nconst int maxn=255000,inf=1e9,mod=9901;\nint read(){\n\tint ch=getchar(),x=0,f=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn f*x;\n}\nll n,e,t,a[maxn];\nll f[maxn],g[maxn];\nint main(){\n\t//freopen(FILE\".in\",\"r\",stdin);\n\t//freopen(FILE\".out\",\"w\",stdout);\n\tn=read(),e=read(),t=read();\n\tup(i,1,n)a[i]=read();\n\tmemset(f,10,sizeof(f));\n\tmemset(g,10,sizeof(g));\n\tf[1]=a[1];g[1]=a[1]+t;\n\tup(i,2,n){\n\t\tf[i]=g[i-1]+a[i]-a[i-1];\n\t\tup(j,1,i-1){\n\t\t\tif(((a[i]-a[j])<<1)>=t)\n\t\t\t\tcmin(g[i],f[j]+3*(a[i]-a[j]));\n\t\t\telse break;\n\t\t}\n\t\tcmin(g[i],f[i]+t);\n\t}\n\t//up(i,1,n)cout<<f[i]<<\" \"<<g[i]<<endl;\n\tcout<<g[n]+e-a[n]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nstring to_str(ll x){string res; while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return res;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//template end\n\n\n\nint main(){\n   int n,e,t; scanf(\"%d%d%d\",&n,&e,&t);\n   vector<int> a(n+1,0); rep(i,1,n+1)scanf(\"%d\",&a[i]);\n   ll dp[100010]; rep(i,0,n+1)dp[i]=INF; dp[0]=0;\n   int idx=0; ll mi=INF;\n   rep(i,1,n+1){\n      while((a[i]-a[idx+1])*2>=t){\n         chmin(mi,dp[idx]-2*a[idx+1]); idx++;\n      }\n      chmin(dp[i],min(mi+a[i]*2LL,dp[idx]+t));\n   }\n   printf(\"%lld\\n\",dp[n]+e);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/2\n\n#define MAX_N 1000\n\nint n,e,T;\nll x[111111];\nll mem[111111];\n\nll dfs(ll l){\n\tif(mem[l]!=-1)return mem[l];\n\tif(l==n-1)return T;\n\tif(l==n)return 0;\n\tll res=T+(x[l+1]-x[l])+dfs(l+1);\n\trepl(r,l+1,n){\n\t\tll time=(x[r]-x[l])*2;\n\t\tll sum=0;\n\t\tif(time>T){\n\t\t\tsum+=time;\n\t\t}else{\n\t\t\tsum+=T;\n\t\t}\n\t\tsum+=(x[r+1]-x[l]);\n\t\tminch(res,sum+dfs(r+1));\n\t}\n\treturn mem[l]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>e>>T;\n\trep(i,n)cin>>x[i];\n\tx[n]=x[n-1];\n\tmemset(mem,-1,sizeof(mem));\n\tcout<<dfs(0)+x[0]+(e-x[n-1])<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,E,T;\nint X[100000];\n\nint dp[2222];\n\nsigned main(){\n    cin>>N>>E>>T;\n    if(N>2000)return 0;\n    X[0]=0;\n    for(int i=1;i<=N;i++)cin>>X[i];\n\n    fill_n(dp,2222,1001001001001001001ll);\n    dp[0]=0;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            if(2*(X[j]-X[i+1])>=T)chmin(dp[j],dp[i]+X[j]-X[i]+2*(X[j]-X[i+1]));\n            else chmin(dp[j],dp[i]+X[i+1]-X[i]+T+X[j]-X[i+1]);\n        }\n    }\n    cout<<dp[N]+E-X[N]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll f[maxn],xx[maxn];\nll n,e,t;\nll store;//fj-2xj+1\nint main(){\n\tll b1,b2,b3,b4;\n\tll p;//定位\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\t\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\tfor (b1=1;b1<=n;b1++){\n\t\tf[maxn]=b1*t;\n\t}\n\tp=0;store=((ll)1<<60);\n\tfor (b1=1;b1<=n;b1++){\n\t\twhile (2*xx[p+1]<=2*xx[b1]-t){\n\t\t\tstore=min(store,f[p]-2*xx[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tf[b1]=min(2*xx[b1]+store,f[p]+t);\n\t\tf[b1]=min(f[b1-1]+t,f[b1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int MAXN = 100005;\ntypedef long long ll;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nll t,e,n,d[MAXN];\nll c[MAXN],f[MAXN];\ninline void update(int x,ll v)\n{\n\tfor(;x<=n;x+=lowbit(x))\n\t\tc[x]=min(c[x],v);\n}\ninline ll query(int x)\n{\n\tll ret=INF;\n\tfor(;x;x-=lowbit(x))\n\t\tret=min(ret,c[x]);\n\treturn min(ret,(ll)-2*d[1]);\n}\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",d+i);\n\tint p=0;\n\tmemset(f,0x3f,sizeof(f));\n\tf[1]=t;\n\tfor(int i=2;i<=n;++i){\n\t\twhile(p+1<i && 2*(d[i]-d[p+2])>=t)++p;\n\t\tif(2*(d[i]-d[p+1])>=t)f[i]=min(f[i],query(p)+2*d[i]);\t\t\n\t\tif(2*(d[i]-d[p+1])==t)\n\t\t\tf[i]=min(f[i],f[p]+t);\n\t\tf[i]=min(f[i],f[p+1]+t);\n\t\tupdate(i,f[i]-2*d[i+1]);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100, mod = 1e9 + 7, maxa = 1e6 + 100, maxb = 23;\nconst long long inf = 2e18 + 13;\nint max(int x, int y){return (x > y ? x : y);}\nint min(int x, int y){return (x < y ? x : y);}\n\nlong long dp[maxn];\nlong long pm[maxn];\nlong long x[maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    long long n, e, t;\n    cin >> n >> e >> t;\n    fill(dp, dp + maxn, inf);\n    t *= 2;\n    e *= 2;\n    int p1 = 0;\n    for(int i = 1; i <= n; i++){cin >> x[i]; x[i] *= 2;}\n    dp[0] = 0;\n\n    for(int i = 1; i <= n; i++)\n    {\n        while(p1 + 1 < i && x[p1 + 1] <= x[i] - t / 2){p1++;}\n        if(!p1){dp[i] = t;}\n        else{dp[i] = min(dp[p1] + t, pm[p1] + x[i] * 2);}\n        pm[i] = min(pm[i - 1], dp[i - 1] - 2 * x[i]);\n       // cout << p1<<\" \"<< i << ' ' << dp[i] << ' ' << pm[i] << endl;\n    }\n\n    cout << (dp[n] + e) / 2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\ntypedef long long ll;\nconst ll INF=1e15;\nll d[N],a[N];\nint n,m,T,q[N],s,t;\nint main() {\n    scanf(\"%d%d%d\",&n,&m,&T); for(int i=1;i<=n;i++){ scanf(\"%lld\",&a[i]); d[i]=INF; }\n    s=1,t=1;\n    ll z=INF;\n    for(int i=1;i<=n;i++){\n        while(s<=t&&2*(a[i]-a[q[s]+1])>T){ z=min(z,d[q[s]]-a[q[s]]-2*a[q[s]+1]); s++; }\n        d[i]=min(d[i],a[i]+z+2*a[i]); d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+T);\n        while(s<=t&&d[q[s]]-a[q[s]]>=d[i]-a[i]) t--; q[++t]=i;\n    }\n    ll ans=d[n]+m-a[n];\n    printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    for (int j=0;j<=i-2;j++)\n      {   \n        long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-2*(a[i]-a[j+1]),h-a[j+1])+a[i]-a[j+1]);\n      }\n    }  \n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\nlong long f[100008];\nint x[100008];\nint main(){\n\tregister int n, e, t, i, j;\n\tregister long long fmin = 3000000000ll;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tf[0] = 0;\n\tfor (j = 0, i = 1; i <= n; ++i) {\n\t\twhile (2 * (x[i] - x[j + 1]) > t) {\n\t\t\tcmin(fmin, f[j] - x[j + 1] * 2);\n\t\t\t++j;\n\t\t}\n\t\tf[i] = dmin(fmin + 2 * x[i], f[j] + t);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()]>=dp[xx]-2*x[xx]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t\t}\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 0;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        for(int j=i;j<=N;j++){\n            chmin(dp[j],dp[i-1]+max((A[j]-A[i])*2,T));\n        }\n        /*auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));*/\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\n#define mid ((s + e) / 2)\n#define int long long\n\nint n, ed, tad;\nint x[N];\nint dp[N];\nint seg[N * 4];\nint laz[N * 4];\nint get(int l, int r, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn 2e18;\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\treturn min(get(l, r, v * 2, s, mid), get(l, r, v * 2 + 1, mid, e));\n}\nvoid add(int l, int r, int val, int v = 1, int s = 0, int e = N) {\n/*\tif (v == 1)\n\t\tcout << \"\t\t\tadd : \" << l << ' ' << r << ' ' << val << endl;*/\n\tif (r <= s || e <= l)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[v] += val;\n\t\tlaz[v] += val;\n\t\treturn;\n\t}\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v * 2] += laz[v];\n\tlaz[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\tadd(l, r, val, v * 2, s, mid);\n\tadd(l, r, val, v * 2 + 1, mid, e);\n\tseg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> ed >> tad;\n\tint pnt = -1;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tadd(0, 1, 0 + x[1] - 0 + tad);\n\t\t}\n\t\tadd(0, pnt + 1, (x[i] - x[i - 1]) * 2);\n\t\twhile ((x[i] - x[pnt + 1]) * 2 >= tad) {\n\t\t\tadd(pnt, pnt + 1, (x[i] - x[pnt + 1]) * 2 - tad);\n\t\t\tpnt++;\n\t\t}\n\t\tadd(0, i - 1, x[i] - x[i - 1]);\n/*\t\tcout << \"all done : \" << endl;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tcout << j << \" > \" << get(j, j + 1) << \"    \"; \n\t\tcout << endl;\n*/\t\tdp[i] = get(0, i);\n//\t\tcout << \"dp[i] : \" << i << \" \" << dp[i] << \" \" << dp[i] + x[i + 1] - x[i] + tad << endl;\n\t\tadd(i, i + 1, dp[i] + x[i + 1] - x[i] + tad);\n\t}\n\tcout << ed - x[n] + dp[n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll INF = 1e18;\n\nint main() {\n    ll n, e, t;\n    cin >> n >> e >> t;\n    if (n > 3000) return 0;\n    VL x(n);\n    REP(i,n) x[i] = in();\n    VL dp(n + 1, INF);\n    dp[0] = 0;\n    FOR(i,1,n){\n        REP(j,i){\n            chmin(dp[i], dp[j] + max(t, 2 * (x[i - 1] - x[j])));\n        }\n    }\n    // REP(i,n+1) cout << dp[i] << endl;\n    ll ans = e + dp[n];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint N, T, E, x[100009]; long long dp[100009];\nint main() {\n\tscanf(\"%d %d %d\", &N, &E, &T);\n\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i]);\n\tint pl = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\twhile (x[pl] + T / 2 < x[i]) pl++;\n\t\tdp[i + 1] = dp[pl] + T;\n\t\tfor (int j = 0; j < pl; j++) {\n\t\t\tlong long val = dp[j] + (x[i] - x[j]) * 2;\n\t\t\tif (dp[i + 1] > val) dp[i + 1] = val;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[N] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n#define LOCAL\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<typename Monoid>\nstruct SegmentTree{\n    typedef function<Monoid(Monoid,Monoid)> F;\n    int n;\n    F f;\n    Monoid id;\n    vector<Monoid> dat;\n    SegmentTree(int n_,F f,Monoid id):f(f),id(id){init(n_);}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,id);\n    }\n    void build(const vector<Monoid> &v){\n        for (int i=0;i<v.size();++i) dat[i+n]=v[i];\n        for (int i=n-1;i;--i) dat[i]=f(dat[i<<1|0],dat[i<<1|1]);\n    }\n    void update(int k,Monoid x){\n        dat[k+=n]=x;\n        while(k>>=1) dat[k]=f(dat[k<<1|0],dat[k<<1|1]);\n    }\n    Monoid query(int a,int b){\n        if (a>=b) return id;\n        Monoid vl=id,vr=id;\n        for (int l=a+n,r=b+n;l<r;l>>=1,r>>=1){\n            if (l&1) vl=f(vl,dat[l++]);\n            if (r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    Monoid operator[](int i){\n        return dat[i+n];\n    }\n    // most left position that meets condition \"check\"\n    template<typename C>\n    int find(int a,int b,const C &check,int k,int l,int r){\n        if (!check(dat[k])||r<=a||b<=l) return -1;\n        if (l+1==r) return k-n;\n        int vl=find(a,b,check,k<<1|0,l,(l+r)>>1);\n        if (~vl) return vl;\n        return find(a,b,check,k<<1|1,(l+r)>>1,r);\n    }\n    template<typename C>\n    int find(int a,int b,const C &check){\n        return find(a,b,check,1,0,n);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; ll E,T; cin >> N >> E >> T;\n    vector<ll> x(N+1); x[0]=0;\n    for (int i=1;i<=N;++i) cin >> x[i];\n    vector<ll> x_2(N+1);\n    for (int i=0;i<=N;++i) x_2[i]=x[i]*2;\n    vector<ll> dp(N+1,IINF),dp0(N+1);\n    SegmentTree<ll> seg(N+1,[](ll a,ll b){return min(a,b);},IINF);\n    dp[0]=0; dp0[0]=-x_2[1];\n    seg.update(0,0);\n    for (int i=1;i<=N;++i){\n        int pos=upper_bound(x_2.begin(),x_2.end(),x_2[i]-T)-x_2.begin()-2;\n        if (pos>=0) dp[i]=min(dp[i],dp0[pos]+3*x[i]);\n        dp[i]=min(dp[i],seg.query(max(0,pos+1),i)+T+x[i]);\n        if (i==N) continue;\n        dp0[i]=min(dp0[i-1],dp[i]-x_2[i+1]-x[i]);\n        seg.update(i,dp[i]-x[i]);\n    }\n    cout << dp[N]+(E-x[N]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,0,n)cin>>x[i];\n    int v=0;\n    while(v<n&&x[v]-x[0]<(t+1)/2)v++;\n    if(v==n)\n    {\n    \tcout<<t+e;\n    \texit(0);\n    }\n    int g=0;\n    if(v!=0)up(1,0,n,0,-2*x[0]);\n    rep(i,v,n)\n    {\n        while(x[i]-x[g+1]>=(t+1)/2)g++;\n    \tdp[i]=2*x[i]+query(1,0,n,0,g+1);\n    \tup(1,0,n,i,dp[i-1]-2*x[i]);\n    \tif(g>=v)dp[i]=min(dp[i],dp[g]+t);\n        else dp[i]=min(dp[i],2*t);\n    }\n    cout<<dp[n-1]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tif( N > 2000 ) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = 0;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\t//cout << idxmin << endl;\n\t\tfor( size_t i = idxmin; i < N + 1; i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t\t//DP[now + 1] = min( DP[now + 1], DP[now] + X[now + 1] - X[now] + T );\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n\t/*\n\tfor( size_t i = 0; i < N + 2; i++ ) {\n\t\tcout << DP[i] << \" \";\n\t}\n\tcout << endl;\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    if(n > 2000) return 1;\n    sort(x, x + n + 1);\n    for(int i = 0; i < n; i++){\n        int *p = lower_bound(x + i, x + n + 1, x[i + 1] + t / 2 + 1);\n        p--;\n        if(p <= x + i) p = x + i + 1;\n        for(int j = p - x; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << e - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt dp[108000];\nInt x[108000];\nInt l, n, e, t;\nint main(){\n  cin >> n >> e >> t;\n  fill(dp, dp + 108000, LINF);\n  dp[0] = 0;\n  for(int i = 1;i <= n;i++)cin >> x[i];\n  for(int i = 1;i <= n;i++){\n    while((x[i] - x[l+1])*2>=t)l++;\n    dp[i] = dp[l] + t;\n    if(l)dp[i] = min(dp[i], dp[l-1] + (x[i] - x[l])*2);\n  }\n  cout << e + dp[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n\n#define llint long long int\n#define N 100005\n#define MAX(x,y) ((x)<(y)?(y):(x))\n\nint main(void){\n  llint n,e,t;\n  //std::priority_queue<int, std::vector<int>, std::greater<int> > x;\n  llint x[N];\n  llint total = 0;\n  llint now = 0;\n  \n  std::cin >> n >> e >> t;\n\n  //int temp;\n  for(llint i=1; i<=n; i++){\n    std::cin >> x[i];\n    //  std::cin >> temp;\n    //    x.push(temp);\n  }\n\n  for(llint i=1; i<=n; i++){\n    llint nnext = i;\n    while(1){\n      if(x[nnext+1] - x[i] <= t and nnext != n){\n\tnnext++;\n      }else break;\n    }\n\n    \n    total += (x[i]-now) + MAX(0, t-2*(x[nnext]-x[i])) + 3*(x[nnext]-x[i]);\n    i = nnext;\n    now = x[nnext];\n  }\n  std::cout << (total+e-x[n]) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define R register\n#define MIN(_A,_B) (_A<_B?_A:_B)\nusing namespace std;\nlong long n,m,t,s[3000010],kl=-1;\nlong long f[3000010],g=192608170817;\nlong long read()\n{\n\tR long long x=0;R char ch=getchar();\n\tfor(;ch>'9'||ch<'0';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';return x;\n}\nint main()\n{\n\tn=read(),m=read(),t=read();\n\tfor(R int i=1;i<=n;i++) s[i]=read();\n\tsort(s+1,s+n+1);\n\tfor(R int i=1;i<=n;i++){\n\t\twhile(kl<i&&2*(s[i]-s[kl+2])>=t){\n\t\t\tkl++;\n\t\t\tg=MIN(g,f[kl]-s[kl]-2*s[kl+1]);\n\t\t}\n\t\tf[i]=MIN(g+3*s[i],f[kl+1]+s[i]-s[kl+1]+t);\n\t}\n\tprintf(\"%lld\\n\",f[n]+m-s[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint T, n, e, t;\n\nint main(int argc, char *argv[]){\n\tios::sync_with_stdio(false);\n\tcin >> n >> e >> t;\n\tassert(n <= 2000);\n\tvi x(n);\n\tREP(i, n){\n\t\tcin >> x[i];\n\t}\n\tvector<vector<ll>> dp1(n+1, vector<ll>(n+1, 1ll << 60));\n\tvector<ll> dp2(n+1, 1ll << 60);\n\tdp2[0] = 0;\n\tREPS(r, n){\n\t\tREP(l, r){\n\t\t\tll d = x[r-1] - x[l];\n\t\t\tchmin(dp1[l][r], 3ll * d + max(0ll, t - 2 * d));\n\t\t}\n\t\tREP(l, r){\n\t\t\tchmin(dp2[r], dp2[l] + dp1[l][r] + (l ? x[l] - x[l-1] : 0));\n\t\t}\n\t}\n\tcout << x[0] + dp2[n] + e - x[n-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        if(it!=A.begin()) it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it=upper_bound(all(A),A[i]+T);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        if(it!=A.begin()) it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Do you knOW what it feels like?\n\n\t\t// To be TorTured by your own MinD?\n\t\n\t// I don't wanna feel the PAIN.\n\n// I BeG you to KILL me, pleASE...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"Os\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, lg=22, mod=1e9+7, inf=1e18;\n\n\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint x[100010];\nll f[100010];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),E=gi(),T=gi();\n\tfor(int i=1;i<=n;++i)x[i]=gi();x[++n]=E;\n\tfor(int i=n-1;i;--i){\n\t\tf[i]=9e18;\n\t\tfor(int j=i;j<n;++j)f[i]=std::min(f[i],f[j+1]+x[j+1]-x[i]+std::max(T,2*(x[j]-x[i])));\n\t}\n\tprintf(\"%lld\\n\",f[1]+x[1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+3000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define MAXIN 1000000\n#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)\ntypedef long long LL;\nconst int N=1e5+5;\n\nint p[N];\nLL f[N];\nchar IN[MAXIN],*SS=IN,*TT=IN;\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-'0',c=gc());\n\treturn now;\n}\n\nint main()\n{\n\tint n=read(),E=read(),T=read();\n\tfor(int i=1; i<=n; ++i) p[i]=read();\n\tLL mn=1e16;\n\tfor(int i=1,j=0; i<=n; ++i)\n\t{\n\t\twhile(T<=2*(p[i]-p[j+1])) mn=std::min(mn,f[j]-2*p[j+1]), ++j;\n\t\tif(j!=i) f[i]=std::min(f[j]+T,mn+2*p[i]);\n\t\telse f[i]=mn+2*p[i];\n\t}\n\tprintf(\"%lld\\n\",f[n]+E);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst llong inf = 1e16;\nint n, e, t;\nint x[100002];\nllong seg1[1 << 18];\nllong seg2[1 << 18];\n\nvoid update(llong seg[], int i, int s, int e, int x, llong v) {\n    if (s == e) {\n        seg[i] = v;\n        return;\n    }\n    int m = (s + e) / 2;\n    if (x <= m) update(seg, i << 1, s, m, x, v);\n    else update(seg, i << 1 | 1, m + 1, e, x, v);\n    seg[i] = min(seg[i << 1], seg[i << 1 | 1]);\n}\n\nllong query(llong seg[], int i, int s, int e, int x, int y) {\n    if (e < x || y < s) return inf;\n    if (x <= s && e <= y) return seg[i];\n    int m = (s + e) / 2;\n    return min(query(seg, i << 1, s, m, x, y)\n               , query(seg, i << 1 | 1, m + 1, e, x, y));\n}\n\nint main() {\n    for (int i = 0; i < (1 << 18); ++i) seg1[i] = seg2[i] = inf;\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", x + i);\n    }\n    llong dp;\n    update(seg1, 1, 0, n, 0, 0);\n    update(seg2, 1, 0, n, 0, -2 * x[1]);\n    for (int i = 1; i <= n; ++i) {\n        int j = lower_bound(x + 1, x + (n + 1), x[i] - t / 2) - x;\n        llong dp1 = query(seg1, 1, 0, n, j - 1, i - 1) + t;\n        llong dp2 = query(seg2, 1, 0, n, 0, j - 2) + 2 * x[i];\n        dp = min(dp1, dp2);\n        update(seg1, 1, 0, n, i, dp);\n        update(seg2, 1, 0, n, i, dp - 2 * x[i + 1]);\n    }\n    \n    printf(\"%lld\\n\", dp + e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1 << 17;\ntypedef long long ll;\n\nint n;\nint t, e;\nint x[N];\nll dp[N];\n\nstruct SegT {\n\tll Min[N << 1], Lazy[N << 1];\n\n\tvoid pushdown(int i) {\n\t\tif (!Lazy[i]) return ;\n\t\tMin[i] += Lazy[i];\n\t\tif (i < N) {\n\t\t\tLazy[i << 1] += Lazy[i];\n\t\t\tLazy[i << 1 | 1] += Lazy[i];\n\t\t}\n\t\tLazy[i] = 0;\n\t}\n\n\tvoid upd(int l, int r, int v, int i = 1, int a = 0, int b = N) {\n\t\tif (l <= a && b <= r) {Lazy[i] += v; pushdown(i); return ;}\n\t\tpushdown(i); if (r <= a || b <= l) return ;\n\t\tint m = (a + b) >> 1;\n\t\tif (l < m) upd(l, r, v, i << 1, a, m);\n\t\tif (m < r) upd(l, r, v, i << 1 | 1, m, b);\n\t\tMin[i] = min(Min[i << 1], Min[i << 1 | 1]);\n\t}\n\n\tll qry(int l, int r, int i = 1, int a = 0, int b = N) {\n\t\tpushdown(i); if (l <= a && b <= r) return Min[i];\n\t\tif (r <= a || b <= l) return 1e18;\n\t\tint m = (a + b) >> 1; ll ans = 1e18;\n\t\tif (l < m) ans = min(ans, qry(l, r, i << 1, a, m));\n\t\tif (m < r) ans = min(ans, qry(l, r, i << 1 | 1, m, b));\n\t\treturn ans;\n\t}\n} segt;\n\nint main() {\n\tcin >> n >> e >> t;\n\t++ n;\n\tfor (int i = 1; i < n; ++ i) cin >> x[i];\n\tdp[0] = 0;\n\tsegt.upd(0, 1, dp[0] + t);\n\tfor (int i = 1, j = 0; i < n; ++ i) {\n\t\tsegt.upd(0, j, (x[i] - x[i - 1]) * 2);\n\t\twhile (j < i && (x[i] - x[j + 1]) * 2 >= t) {\n\t\t\tsegt.upd(j, j + 1, (x[i] - x[j + 1]) * 2 - t);\n\t\t\t++ j;\n\t\t}\n\t\tdp[i] = segt.qry(0, i);\n\t\tsegt.upd(i, i + 1, dp[i] + t);\n\t}\n\tcout << dp[n - 1] + e << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nint n, e, t, x[100005];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\t\n\tll ans = e;\n\tint last = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (std::max((x[i] - x[last]) * 2, t) - std::max((x[i - 1] - x[last]) * 2, t) > t) {\n\t\t\tans += std::max((x[i - 1] - x[last]) * 2, t);\n\t\t\tlast = i;\n\t\t}\n\t}\n\tans += std::max((x[n] - x[last]) * 2, t);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nlong long e, t, dp[MAXN], mn = 1e17;\nmultiset<int> S;\nint n, x[MAXN];\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tdp[1] = t;\n\tS.insert(0);\n\tint j = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile (j <= i && (x[i] - x[j]) * 2 > t) {\n\t\t\tmn = min(mn, dp[j - 1] - 2 * x[j]);\n\t\t\tS.erase(dp[j - 1]);\n\t\t\tj++;\n\t\t}\n\t\tS.insert(dp[i - 1]);\n\t\tdp[i] = min(mn + 2 * x[i], *S.begin() + t);\n\t}\n\tcout << dp[n] + e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        for(int j=i;j<=N;j++){\n            if((A[j]-A[i])>T) break;\n            chmin(dp[j],dp[i-1]+max((A[j]-A[i])*2,T));\n        }\n        /*auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));*/\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 210110;\nconst int MOD = 998244353;\nconst double eps = 1e-8;\n\nll n, e, t;\nll a[N];\n\nll dp[N];\nll kek, j = -1;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    kek = 1e18;\n    set<pair<int, int> > ss;\n    for (int i = 0; i < n; i++)\n    {\n        dp[i] = (i > 0 ? dp[i - 1] : 0) + t;\n        while (2 * (a[i] - a[j + 1]) >= t)\n        {\n            ss.erase({dp[j + 1], j + 1});\n            kek = min(kek, (j ? dp[j] : 0) - 2 * a[j + 1]);\n            j++;\n        }\n        pair<int, int> it = *(ss.begin());\n        dp[i] = min(dp[i], min(it.first + t, kek + 2 * a[i]));\n        ss.insert({dp[i], i});\n        //cout << j << \" \" << kek << \" \" << dp[i] << endl;\n    }\n    cout << dp[n - 1] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\ntemplate <class T>\nclass RMQ{\n\tprivate:\n\tint n;\n\tvector<T> rmq;\n\tT dfs(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF;\n\t\tif(a<=l&&r<=b) return rmq[k];\n\t\tint m=(l+r)/2;\n\t\treturn min(dfs(a,b,k*2+1,l,m),dfs(a,b,k*2+2,m,r));\n\t}\n\tpublic:\n\tRMQ(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\trmq=vector<T>(2*n-1,inf);\n\t}\n\tvoid Update(int k,T x){\n\t\tk+=n-1;\n\t\trmq[k]=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\trmq[k]=min(rmq[k*2+1],rmq[k*2+2]);\n\t\t}\n\t}\n\tT Query(int a,int b){\n\t\treturn dfs(a,b,0,0,n);\n\t}\n\tT Open(int k){\n\t\treturn rmq[k+n-1];\n\t}\n};\n\nll n,m,t;\nvl a;\n\nint main(){\n\tcin>>n>>m>>t;\n\ta=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tRMQ<ll> r(n+1),R(n+1);\n\tr.Update(0,0);\n\tR.Update(0,-2*a[0]);\n\tfor(int i=0;i<n;i++){\n\t\tint it=lower_bound(a.begin(),a.end(),a[i]-t/2)-a.begin();\n\t\tll res=min(R.Query(0,it)+2*a[i],r.Query(it,i+1)+t);\n\t\tr.Update(i+1,res);\n\t\tif(i!=n-1) R.Update(i+1,res-2*a[i+1]);\n\t}\n\tcout<<r.Open(n)+m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst long long MAXN=100005;\n\nlong long dp[MAXN];\nlong long N,M,T,A[MAXN];\nlong long que[MAXN],hd,tl;\nlong long stk[MAXN],tp;\n\nvoid push_back2(long long i)\n{\n    while(tp>0&&dp[i]-A[i+1]*3<=dp[stk[tp]]-A[stk[tp]+1]*3)\n        tp--;\n    stk[++tp]=i;\n}\nvoid push_back1(long long i)\n{\n    while(hd<=tl&&dp[i]-A[i+1]<=dp[que[tl]]-A[que[tl]+1])\n        tl--;\n    que[++tl]=i;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%lld\",&N,&M,&T);\n    for(long long i=1;i<=N;i++)\n        scanf(\"%lld\",&A[i]);\n    A[N+1]=M;\n    memset(dp,0x3F,sizeof dp);\n    dp[0]=A[1];\n    que[1]=0;\n    hd=tl=1;\n    for(long long i=1;i<=N;i++)\n    {\n        while(hd<=tl&&(A[i]-A[que[hd]+1])*2>T)\n        {\n            push_back2(que[hd]);\n            hd++;\n        }\n        if(hd<=tl)\n            dp[i]=dp[que[hd]]+T+A[i+1]-A[que[hd]+1];\n        if(tp)\n            dp[i]=min(dp[i],dp[stk[1]]+A[i]*2+A[i+1]-A[stk[1]+1]*3);\n        push_back1(i);\n    }\n    printf(\"%lld\\n\",dp[N]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  X.push_back(e);\n  vector<ll> dp;\n  rep(i,n+1){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n\n  rep(i,n){\n    int j;\n    j = n;\n    chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j = lower_bound(all(X), X[i+1] + t/2.0 + 0.1) - X.begin();\n    if(X[j] == X[i+1] + t/2.0) j++;\n\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j--;\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n  }\n\n  cout<<dp[n] + e - X[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(s...)  fprintf(stderr, s)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n\ntemplate<class T> struct RMQ {\n    int n;\n    vector<T> A; vector<int> I;\n    RMQ(int n_=0): n(n_), A(n), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = I[2*i];\n    }\n    RMQ(const vector<T> &a): n(a.size()), A(a), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    void modify(int i, const T &v) {\n\tA[i] = v;\n\tfor (i+=n; i>>=1;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    int min_i(int x, int y) {\n\tx += n; y += n;\n\tint p = -1;\n\tfor (; x<y; x>>=1, y>>=1) {\n\t    if (y & 1) { --y; if (p < 0 || A[I[y]] < A[p]) p = I[y]; }\n\t    if (x & 1) { if (p < 0 || A[I[x]] < A[p]) p = I[x]; x++; }\n\t}\n\treturn p;\n    }\n    T min_v(int x, int y) { return A[min_i(x, y)]; }\n};\n\nint N, T, E;\nint A[100111];\nLL dp[100111];\n\nint main() {\n\n    scanf(\"%d%d%d\", &N, &E, &T);\n    REP (i, N) scanf(\"%d\", A+i+1);\n\n    RMQ<LL> X1(N + 10), X2(N + 10);\n    X1.modify(0, - 2 * A[1]);\n\n\n    int mid = 0;\n    LL cst = 0;\n    for (int i=1; i<=N; i++) {\n\n\twhile (mid < i && 2LL * (A[i] - A[mid+1]) > T) mid++;\n\tcst = 1LL << 60;\n\n\tif (0 < mid) amin(cst, X1.min_v(0, mid) + 3LL * A[i]);\n\tif (min(i-1, mid) < i) amin(cst, X2.min_v(min(i-1, mid), i) + T + A[i]);\n\n\tX1.modify(i, cst - 2 * A[i+1] + A[i]);\n\tX2.modify(i, cst - A[i]);\n\n//\teprintf(\"%d %lld %d\\n\", i, cst, mid);\n    }\n\n    LL ans = cst + E - A[N];\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e18;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    ll n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    dp[0]=0;\n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=upper_bound(x+1,x+n+1,(x[i]-T))-x;\n        j-=2;\n        dp[i]=dp[i-1]+T*2;\n\n        if(j>=0){\n            dp[i]=min(dp[i],dp2[j]+x[i]*2);\n        }\n\n\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n      //  cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n\n    }\n\n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\t//cout << opt << endl;\n\tll dp1 = T;\n\tif(opt - 1 >= 0)\n\t\tdp1 += dp[opt - 1];\n\tll dp2 = a[idx] * 2;\n\tif(opt - 1 >= 0)\n\t\tdp2 += min(dpRMQ[opt - 1] , 0);\n\t//cout << dp1 << \" \" << dp2 << endl;\n\t//if(opt < idx)\n\t\treturn(min(dp1 , dp2));\n\t//else\n\t\t//return dp2;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = - a[0] * 2;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tdp[i] = findDp(i);\n\t\tdpRMQ[i] = min(dpRMQ[i - 1] , dp[i - 1] - a[i] * 2);\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n+1,0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvl dp(n+1,INF);\n\tvl dp2(n + 1, INF);\n\tdp[0] = e;\n\tvi p(n + 1);\n\tint l = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tif(p[i]<i)mi = dp[p[i]] + t;\n\t\tfor (int j =0; j<l; j++) {\n\t\t\tmi = 2 * dp[i] + min(mi - 2 * dp[i], dp[j] - 2 * x[j + 1]);\n\t\t}\n\t\tdp[i] = mi;\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tint pnt=n+1;\n\tll mn=INF;\n\tfor (int i=n; i; i--){\n\t\twhile (2*(A[pnt-1]-A[i])>=T){\n\t\t\tpnt--;\n\t\t\tmn=min(mn, 2*A[pnt]+dp[pnt+1]);\n\t\t}\n\t\tdp[i]=T+dp[pnt];\n\t\tdp[i]=min(dp[i], mn - 2*A[i]);\n\t\t\n\t}\n\tcout<<A[n+1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\n\ntypedef long long i64;\n\nconst int N = 100000 + 10;\nconst i64 INF = 1LL << 60;\n\nint n, t, e, x[N];\ni64 f[N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &e, &t);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n  std::multiset<i64> a, b;\n  for (int i = 1, j = 1; i <= n; ++i) {\n    b.insert(f[i - 1]);\n    for (; 2 * (x[i] - x[j]) > t; ++j) {\n      b.erase(b.find(f[j - 1]));\n      a.insert(f[j - 1] - 2 * x[j]);\n    }\n    f[i] = INF;\n    if (!a.empty()) f[i] = 2 * x[i] + *a.begin();\n    if (!b.empty()) f[i] = std::min(f[i], *b.rbegin() + t);\n  }\n  printf(\"%lld\\n\", f[n] + e);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N, E, T;\nint x[100010];\n\nint main() {\n  cin >> N >> E >> T;\n  for (int i=0; i<N; i++) cin >> x[i];\n  cout << E + N*T << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tstatic ll N,E,T;\n\tstatic ll x[100010];\n\tscanf(\"%lld%lld%lld\",&N,&E,&T);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\t\n\tstatic ll dp[2002];\n\tfor(int i = 0 ; i < 2002 ; i ++)dp[i] = 1000000000000000000;\n\tdp[0] = 0;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tfor(int j = 0 ; j <= i-1 ; j ++){\n\t\t\tdp[i] = min( dp[i] , dp[j]+max(2*(x[i]-x[j+1]),T) );\n\t\t}\n\t}\n\tcout << dp[N]+E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int64 i = 0; i < (int64)(n); i++)\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nstruct SegNode\n{\n  int64 v;\n\n  SegNode(int v) : v(v) {}\n\n  SegNode operator*(const SegNode &r) const\n  {\n    return (v < r.v ? *this : r);\n  }\n} e(INF);\n\nstruct SegmentTree\n{\n  int sz;\n  vector< SegNode > seg;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, e);\n  }\n\n  void update(int k, const SegNode &x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = seg[2 * k + 1] * seg[2 * k + 2];\n    }\n  }\n\n  SegNode query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (e);\n    if(a <= l && r <= b) return (seg[k]);\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) * query(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n\n  SegNode query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nint main()\n{\n  int64 N, E, T, X[100001] = {};\n\n  cin >> N >> E >> T;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n  X[N] = E;\n\n  vector< int64 > dp1(N + 1, INF);\n  SegmentTree seg1(N + 1), seg2(N + 1);\n\n  auto update = [&](int idx, int64 cost)\n  {\n    if(dp1[idx] > cost) {\n      dp1[idx] = cost;\n      seg1.update(idx, dp1[idx] - X[idx]);\n    }\n  };\n  update(0, X[0]);\n\n\n  int ptr = 0;\n  for(int i = 1; i <= N; i++) {\n    while(ptr <= N && (X[i - 1] - X[ptr]) * 2 > T) ++ptr;\n\n    for(int j = i - 1; j >= ptr; j--) {\n      int64 need = dp1[j] - X[j] + T;\n      dp1[i] = min(dp1[i], need + X[i]);\n    }\n\n    for(int j = ptr - 1; j >= 0; j--) {\n      int64 need = 2 * (X[i - 1] - X[j]);\n      need = dp1[j] - X[j] + 2 * (X[i - 1] - X[j]);\n      dp1[i] = min(dp1[i], need + X[i]);\n    }\n  }\n\n  cout << dp1.back() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tf[i] = max(2 * (d[i] - d[1]),t);\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\twhile (2 * (d[i] - d[pp + 1]) > t) {\n\t\t\tf[i] = min(f[i],f[pp] + 2 * (d[i] - d[pp + 1]));\n\t\t\tpp++;\n\t\t}\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t\tif (f[pp] + t < f[i]) f[i] = f[pp] + t;\n\t\telse if (pp > 0) pp--;\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n\t}\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 1;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            ll need=A[i+1]-A[i];\n            ll dis=(A[j]-A[i+1])*2;\n            chmin(dp[j],dp[i]+need+max(T,dis)+dis);\n        }\n    }\n    \n    cout<<dp[N]+E-A[N]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nstruct seg {\n\tint min[N << 2];\n\tvoid modify(int u, int k, int v, int l = 0, int r = n) {\n\t\t// printf(\"modify %d %d %d %d %d\\n\", u, k, v, l, r);\n\t\tif (l == r) { min[u] = v; return; }\n\t\tint mid = (l + r) >> 1;\n\t\tif (k <= mid) modify(u << 1, k, v, l, mid);\n\t\telse modify(u << 1 | 1, k, v, mid + 1, r);\n\t\tmin[u] = std::min(min[u << 1], min[u << 1 | 1]);\n\t}\n\tint query(int u, int ql, int qr, int l = 0, int r = n) {\n\t\t// printf(\"query %d %d %d %d %d : %d\\n\", u, ql, qr, l, r, min[u]);\n\t\tif (ql > qr) return f[N - 1];\n\t\tif (ql == l && qr == r) return min[u];\n\t\tint mid = (l + r) >> 1;\n\t\tif (qr <= mid) return query(u << 1, ql, qr, l, mid);\n\t\tif (ql > mid) return query(u << 1 | 1, ql, qr, mid + 1, r);\n\t\treturn std::min(query(u << 1, ql, mid, l, mid), query(u << 1 | 1, mid + 1, qr, mid + 1, r));\n\t}\n} s[2];\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tmemset(s[0].min, 0x3f, sizeof(s[0].min));\n\tmemset(s[1].min, 0x3f, sizeof(s[1].min));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\ts[0].modify(1, 0, -2 * a[1]);\n\ts[1].modify(1, 0, 0);\n\tfor (int i = 1, from; i <= n; i++) {\n\t\tint j = std::lower_bound(a, a + i, (a[i] * 2 - k + 1) >> 1) - a - 1;\n\t\tf[i] = std::min(f[i], 3 * a[i] + s[0].query(1, std::max((int)0, (int)0), std::min(n, j - 1)));\n\t\tf[i] = std::min(f[i], a[i] + k + s[1].query(1, std::max((int)0, (int)j), std::min(n, i - 1)));\n\t\ts[0].modify(1, i, f[i] - a[i] - 2 * a[i + 1]);\n\t\ts[1].modify(1, i, f[i] - a[i]);\n\t\t// printf(\"[%d %d] %d %d | [%d %d] %d %d\\n\",\n\t\t// \t0, j - 1, 3 * a[i], s[0].query(1, 0, j - 1),\n\t\t// \tj, i - 1, a[i] + k, s[1].query(1, j, i - 1));\n\t}\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(13) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 1 << 18, B = 400, oo = 1e18 + 100, M = 2520;\n\n\nvoid smain() {\n    int n;\n    cin >> n;\n\n    int t, e;\n    cin >> e >> t;\n\n    n++;\n    vi kek(n);\n\n    for (int i = 0; i + 1 < n; ++i)\n        cin >> kek[i];\n\n    kek.back() = e;\n    vi dp(n, oo);\n    dp[0] = kek[0];\n\n    for (int i = 0; i < n; ++i)\n    {\n        if (i)\n            dp[i] = min(dp[i], dp[i - 1] + kek[i] - kek[i - 1] + t);\n\n        if (i + 1 == n)\n            continue;\n\n        int l = i, r = n - 1;\n        while (r - l > 1)\n        {\n            int m = l + r >> 1;\n            if (2 * (kek[m] - kek[i]) < t)\n                l = m;\n            else\n                r = m;\n        }\n\n        for (int j = max(i + 1, l - 5); j < min(n - 1, l + 5); ++j)\n        {\n            int v = max(2 * (kek[j] - kek[i]), t) + kek[j + 1] - kek[i];\n            dp[j + 1] = min(dp[j + 1], dp[i] + v);\n        }\n    }\n\n    cout << dp.back();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF      5000000000000000000\n#define EPS      1e-10\n#define MOD      1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\nll n, e, t;\nll x[100001];\nll dp[100001];\nll pos = 0;\npriority_queue<P,vector<P>,greater<P> > que1, que2;\n\nint main(){\n    cin >> n >> e >> t;\n    rep(i,n) cin >> x[i+1];\n    rep(i,n+1) dp[i] = INF;\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++){\n        que1.push(P(dp[i-1]-x[i-1],i-1));\n        while((x[i]-x[pos+1])*2 > t){\n            que2.push(P(dp[pos]-x[pos]-2*x[pos+1],pos+1));\n            pos++;\n        }\n        while(true){\n            if(que1.size() == 0) break;\n            P p = que1.top();\n            if(p.second < pos) que1.pop();\n            else break;\n        }\n        if(que1.size() > 0){\n            P p = que1.top();\n            dp[i] = min(dp[i],x[i]+t+p.first);\n        }\n        if(que2.size() > 0){\n            P p = que2.top();\n            dp[i] = min(dp[i],3*x[i]+p.first);\n        }\n    }\n    cout << dp[n]+e-x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t,l=-1;\nll cur=Inf;\nll dp[maxn];\nint x[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]);\n\trep(i,n){\n\t\twhile(2LL*(x[i]-x[l+1])>=t){\n\t\t\tcur=min(cur,(l<0?0:dp[l])-2LL*x[l+1]);\n\t\t\tl++;\n\t\t}\n\t\tdp[i]=min(cur+2LL*x[i],(l<0?0:dp[l])+t);\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[100003];\nLL dp[100003];\nLL mn1[100003], mn2[100003];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tmn1[0]=mn2[0]=0;\n\t/*for(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}*/\n\tfor(i=1;i<=n;i++){\n\t\t//rintf(\"%d %d %d\\n\",i,mn1[i-1],mn2[i-1]);\n\t\tdp[i]=dp[mn1[i-1]]+max(2*(x[i]-x[mn1[i-1]+1]),(LL)t);\n\t\tdp[i]=min(dp[i],dp[mn2[i-1]]+max(2*(x[i]-x[mn2[i-1]+1]),(LL)t));\n\t\tmn1[i]=dp[mn1[i-1]]<dp[i] ? mn1[i-1]:i;\n\t\tmn2[i]=dp[mn2[i-1]]-2*x[mn2[i-1]+1]<dp[i]-2*x[i+1] ? mn2[i-1]:i;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nusing namespace std;\n\nint n;\nint a[N];\nlong long d[N];\nlong long E, T;\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> E >> T;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        if(n > 2020){\n                return 0;\n        }\n        long long inf = 1e18;\n        for(int i = 1; i <= n; i++){\n                d[i] = inf;\n                for(int j = 1; j <= i; j++){\n                        long long D = a[i] - a[j];\n                        d[i] = min(d[i], d[j - 1] + D + max(D * 2, T) + a[j] - a[j - 1]);\n                }\n        }\n        cout << d[n] + E - a[n] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = double;\nconst ld EPS = 1e-7;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 300001;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../kolya_input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n\n    fast_io();\n\n    cout.precision(6);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n    ll n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n    ll ans = x[0];\n    for (int i = 0; i < n;) {\n        int j = i;\n        if (i) {\n            ans += x[i] - x[i - 1];\n        }\n        while (j + 1 < n && x[j + 1] - x[i] <= t) {\n            ++j;\n        }\n        ans += max(2 * (x[j] - x[i]), t) + (x[j] - x[i]);\n        i = j + 1;\n    }\n    ans += e - x.back();\n    cout << ans;\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define PB push_back\n#define PF push_front\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn = 1e5 + 100;\n\nll x[maxn], dp[maxn];\n\nll dis (int fi, int se) { return abs (x[fi] - x[se]); }\n\nint main () {\n\tios_base::sync_with_stdio (false);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tmemset (dp, 63, sizeof dp);\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j >= 1; j--) {\n\t\t\tdp[i] = min (dp[i], dp[j-1] + dis(j-1, j) + 3*dis(j, i) + max(0ll,t-2*dis(j, i)));\n\t\t}\n\t}\n\tcout << dp[n] + e - x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvll v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tv.PB(INFL);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tmins(dp[min(it,n-1)],dp[i]+T);\n\t\tint p = it+1;\n\t\tint it2 = upper_bound(ALL(v), v[i]+T)-v.begin();\n\t\treep(j,p,it2){\n\t\t\tmins(dp[j], dp[i]+2*(v[j-1]-v[i]));\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "// Nurbakyt Madibek\n// Look at my code! IT'S AWESOME\n\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <algorithm>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <cassert>\n#include <unordered_map>\n#include <bitset>\n#include <unordered_set>\n\nusing namespace std;\n\n#define pb push_back\n#define pp pop_back\n#define f first\n#define s second\n#define mp make_pair\n#define sz(a) (int)((a).size())\n#ifdef _WIN32\n#  define I64 \"%I64d\"\n#else\n#  define I64 \"%lld\"\n#endif\n#define fname \".\"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int, int > pi;\ntypedef pair < int, ull > pu;\n\nconst int inf = (int)1e9 + 123;\nconst ll infl = (ll)1e18 + 123;\nconst double eps = 1e-9;\n\nconst int MAX_N = (int)1e5 + 5;\nconst int mod = (int)1e9 + 7;\n\nint n;\nint t, e;\nint x[MAX_N];\n\nll dp[MAX_N];\n\nint main() {\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &x[i]);\n    x[0] = dp[0] = 0;\n    for (int i = 1; i <= n; i++)\n        dp[i] = infl;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            ll now = max(dp[i] + x[j] - x[i] + t, dp[i] + x[j] - x[i] + 2ll * (x[j] - x[i + 1]));\n            dp[j] = min(dp[j], now);\n        }\n    }\n    printf(\"%lld\\n\", dp[n] + e - x[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n\n    //手前のがt以下だった場合、\n    for(int d=idx-1;d<now+10000&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  //落ちるケース\n  //tが極端に大きく、間隔が極端に小さい\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define _p(...) (void)printf(__VA_ARGS__)\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define fst first\n#define snd second\nusing ll=long long;using pii=pair<int,int>;using vb=vector<bool>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate <typename T> T read() {T t; cin >> t; return t;}\n\ntemplate<class T> bool amin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nvoid Main() {\n  int n = read<int>();\n  int e = read<int>();\n  int t = read<int>();\n  vector<int> X(n);\n  rep(i, n) X[i] = read<int>();\n\n  // sub\n  if (n > 2000) return;\n\n  const ll inf = 1e18+7;\n\n  vl dp(n+2, inf);\n  dp[0] = 0;\n\n  rep(i, n) if (dp[i] < inf) {\n    //cout<<\"dp[\"<<i<<\"]: \"<<dp[i]<<endl;\n    int pos = (i == 0 ? 0 : X[i-1]);\n\n    rep(j, i, n+1) {\n      int a = X[j] - pos;\n      int b = X[j] - X[i];\n      int c;\n      if (b * 2 >= t) c = 0;\n      else c = t - b * 2;\n      //_p(\"i:%d, j:%d: %d,%d,%d\\n\", i,j,a,b,c);\n      amin(dp[j + 1], dp[i] + a + 2LL * b + c);\n    }\n  }\n\n  //cout << \"dp:\"; rep(ii,sz(dp)) cout << ' ' << dp[ii]; cout << endl;\n\n  ll ans = dp[n] + abs(e - X[n-1]);\n\n  cout << ans << endl;\n}\nint main() { cin.tie(nullptr); ios::sync_with_stdio(false); Main(); return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint N,E,T,X[100100];\nlong long D[100100],W[100100];\n\nint main()\n{\n\tscanf (\"%d %d %d\",&N,&E,&T);\n\tfor (int i=1;i<=N;i++) scanf (\"%d\",&X[i]);\n\tW[0] = -2 * X[1];\n\tfor (int i=1;i<=N;i++){\n\t\tint j = lower_bound(X,X+i,X[i]-T/2) - X;\n\t\tif (j){\n\t\t\tj--;\n\t\t\tD[i] = D[j] + T;\n\t\t\tif (j){\n\t\t\t\tj--;\n\t\t\t\tif (D[i] > W[j] + 2 * X[i])\n\t\t\t\t\tD[i] = W[j] + 2 * X[i];\n\t\t\t}\n\t\t}\n\t\telse D[i] = T;\n\n\t\tW[i] = D[i] - 2 * X[i+1];\n\t\tif (W[i] > W[i-1])\n\t\t\tW[i] = W[i-1];\n\t}\n\n\tprintf (\"%lld\\n\",D[N]+E);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n \nstruct SegtreeRMQ {\n    ll n;\n    ll inf;\n    vector<ll> dat;\n \n    void init(ll n_input, ll inf_input){\n        inf = inf_input;\n        n = 1;\n        while(n < n_input)n <<= 1;\n        dat.resize(2*n-1);\n        for(int i = 0; i<2*n-1; i++) dat[i] = inf;\n    }\n \n    void update(ll k, ll a){\n        k += n - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1)/2;\n            dat[k] = min(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n \n    ll query(ll a, ll b, ll k, ll l, ll r){\n        if(r<=a || b<=l)return inf;\n        if(a<=l && r<=b)return dat[k];\n        ll vl = query(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint main()\n{\n    ll n, e, t;\n    cin >> n >> e >> t;\n    SegtreeRMQ st1, st2;\n    ll INF = 1e18;\n    st1.init(n+10, INF);\n    st2.init(n+10, INF);\n    vector<ll> x(n+10);\n    for(int i = 1; i <= n; i++) cin >> x[i];\n    int pos = 0;\n    x[n+1] = e;\n    vector<ll> ans(n+10);\n    st1.update(0, 0);\n    st2.update(0, -2 * x[1]);\n    for(int i = 1; i <= n; i++)\n    {\n        while(x[i] - x[pos+1] > t / 2) pos++;\n        ans[i] = min(x[i] + t + st1.query(pos, i, 0, 0, st1.n), 3*x[i] + st2.query(0, pos, 0, 0, st2.n));\n        st1.update(i, ans[i] - x[i]);\n        st2.update(i, ans[i] - x[i] - 2 * x[i+1]);\n    }\n    cout << ans[n] + e - x[n] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200006\n#define ll long long\nll n,t,e;\nll x[nn];ll f[nn];\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tdeque<int> q;ll oops=1e17;\n\tq.push_back(0);x[0]=0;int ls=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ls<i and 2*(x[i]-x[ls+1])>t)\n\t\t{\n\t\t\tif(q.size() and ls==q.front()) q.pop_front();\n\t\t\toops=min(oops,f[ls]-x[ls+1]*2-x[ls]);\n\t\t\tls++;\n\t\t}\n\t\t\n\t\tif(q.size()) f[i]=f[q.front()]+t+x[i]-x[q.front()];\n\t\telse f[i]=1e17;\n\t\tf[i]=min(f[i],oops+x[i]*3);\n\t\twhile(q.size() and f[q.back()]-x[q.back()]>=f[i]-x[i]) \n\t\t\tq.pop_back();\n\t\tq.push_back(i);\n\t}\t\n\t\n\tprintf(\"%lld\\n\",f[n]+e-x[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,ppp,pp\t,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = (1 << 31) - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tf[i] = min(f[i],f[j] + max(2 * (d[i] - d[j + 1]),t));\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 1e18;\n\t\tfor (auto itr = dp[i - 1].begin(); itr != dp[i - 1].end(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\tif (besuto > jikan) {\n\t\t\t\tbesuto = jikan;\n\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t\tdp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].begin(); itr != dp[N - 1].end(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int N = 1 << 17;\n\nconst llong inf = 1e15;\n\nstruct segtree {\n    llong T[2 * N];\n\n    segtree() {\n        for (int i = 0; i < 2 * N; i++)\n            T[i] = inf;\n    }\n\n    void put(int i, llong x) {\n        int v = i + N;\n        T[v] = min(T[v], x);\n        while ((v >>= 1) > 0) {\n            T[v] = min(T[2 * v], T[2 * v + 1]);\n        }\n    }\n    llong get(int l, int r) {\n        l += N;\n        r += N;\n        llong ans = inf;\n        while (l <= r) {\n            ans = min(ans, T[l]);\n            ans = min(ans, T[r]);\n            l = (l + 1) / 2;\n            r = (r - 1) / 2;\n        }\n        return ans;\n    }\n} T1, T2;\n\nllong D[N];\nllong X[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    llong E, T;\n    scanf(\"%lld %lld\", &E, &T);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &X[i]);\n    }\n    X[n] = E;\n\n    D[0] = X[0];\n    T1.put(0, D[0] - X[0]);\n    T2.put(0, D[0] - 3 * X[0]);\n\n    int pt = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (2 * (X[i - 1] - X[pt]) > T)\n            pt++;\n        llong A = T1.get(pt, i - 1) + X[i] + T;\n        llong B = T2.get(0, pt - 1) + 2 * X[i - 1] + X[i];\n        llong cur = min(A, B);\n        D[i] = cur;\n        T1.put(i, D[i] - X[i]);\n        T2.put(i, D[i] - 3 * X[i]);\n    }\n    llong ans = D[n];\n    printf(\"%lld\\n\", ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nconst int N=2e5+3,M=1e9+7;\nint n,x,y,a,b,ans,sum,t[N],invf[N],c[N],d,f[N];\nstd::vector<int>h[N];\nbool Cmp(const int&i,const int&j){\n\tif(!h[i].size())return 0;\n\tif(!h[j].size())return 1;\n\treturn h[i][0]<h[j][0];\n}\ninline int Pow(int a,int m){int s=1;for(;m;m>>=1)m&1?s=1ll*s*a%M:0,a=1ll*a*a%M;return s;}\nvoid InC(){\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++)f[i]=1ll*f[i-1]*i%M;\n\tinvf[n]=Pow(f[n],M-2);\n\tfor(int i=n;i;i--)invf[i-1]=1ll*invf[i]*i%M;\n}\ninline int C(int n,int m){return 1ll*f[n]*invf[m]%M*invf[n-m]%M;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tInC();\n\tfor(int i=1;i<=n;i++)\n\t  scanf(\"%d%d\",&a,&b),h[a].push_back(b),\n\t  t[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t  std::sort(h[i].begin(),h[i].end());\n\t  for(int j=1;j<h[i].size();j++)\n\t\tif(h[i][0]+h[i][j]<=x)c[i]=j;\n\t}\n\tstd::sort(t+1,t+1+n,Cmp);\n\tif(!h[t[2]].size())return 0*puts(\"1\");\n\tfor(int i=1,k;h[t[i]].size();i++){\n\t  k=i==1?2:1;\n\t  for(int j=0;j<h[t[i]].size();j++)\n\t\tif(h[t[k]][0]+h[t[i]][j]<=y&&j>c[t[i]])c[t[i]]=j;\n\t  if(h[t[i]][0]+h[t[k]][0]<=y)d=i;\n\t}\n\tans=1;sum=0;\n\tfor(int i=1;i<=d;i++)sum+=c[t[i]]+1;\n\tfor(int i=1;i<=d;i++)\n\t  ans=1ll*ans*C(sum,c[t[i]]+1)%M,\n\t  sum-=c[t[i]]+1;\n\tprintf(\"%d\",ans);\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n;\nLL E, T, p[MAXN], dp[MAXN];\n\nvoid init() {\n    read(n);\n    read(E); read(T);\n    for (int i = 1; i <= n; ++i) {\n        read(p[i]);\n    }\n}\n\nvoid solve() {\n    LL mn = 1e18;\n    for (int i = 1, j = 0; i <= n; ++i) {\n        while (T <= (p[i] - p[j + 1]) * 2) {\n            mn = min(mn, dp[j] - p[j + 1] * 2);\n            ++j;\n        }\n        if (j < i) {\n            dp[i] = min(mn + p[i] * 2, dp[j] + T);\n        } else {\n            dp[i] = mn + p[i] * 2;\n        }\n    }\n    printf(\"%lld\\n\", dp[n] + E);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define X first\n#define Y second\nusing namespace std;\nconst int max_n = 1e6 + 20, inf = 1e12;\nint a[max_n], DP[max_n];\npair<int, int> seg[max_n * 4];\nint n, e, t, INF = 1e12, L;\npair<int, int> Merge(pii x, pii y) {\n    if (x.X < y.X)\n        return x;\n    return y;\n}\nvoid update(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg[id].X = val;\n        seg[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update(x, val, mid, e, id << 1 | 1);\n    else\n        update(x, val, b, mid, id << 1);\n    seg[id] = Merge(seg[id << 1 | 1], seg[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, -1};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get(l, r, b, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\nvoid out() {\n    for (int i = 1; i < n * 4; i++)\n        cout << seg[i].Y << \">>>>>\" << seg[i].X << \"   \";\n    cout << endl;\n}\nvoid solve() {\n    for (int i = 1; i < n; i++) {\n        int tmp = (lower_bound(a, a + n, a[i] - L) - a);\n        pii x = get(tmp, i), y = get(0, tmp);\n        //cout << tmp << endl;\n        DP[i] = min(x.X + t, y.X + 2 * (a[i] - a[y.Y])) + a[i];\n        DP[i] = min(DP[i] , DP[i - 1] + a[i] - a[i - 1] + t);\n  //      cout << DP[i] << endl;\n        update(i, DP[i - 1] - a[i - 1]);\n      //  cout << endl;\n        //out();\n    }\n}\nint32_t main() {\n    cin >> n >> e >> t;\n    L = (t / 2);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < n * 4; i++)\n        seg[i].X = inf;\n    DP[0] = a[0] + t;\n    update(0, 0);\n    solve();\n    cout << DP[n - 1] + (e - a[n - 1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nconst int INF = 2e18;\n\nint N, E, T;\nint x[100010];\n\nint dp[2010]; // dp[i] = i番目まで(inclusiv)を全て回収するのにかかるコスト\n\nsigned main(){\n    while(cin >> N >> E >> T){\n        rep(i,2010) dp[i] = INF;\n        rep(i,N) cin >> x[i];\n        x[N] = E;\n\n        dp[0] = 0;\n        rep(i,N){\n            int premove = x[i] - (i == 0 ? 0 : x[i-1]);\n            // dump(premove);\n            for(int j = i; j < N; ++j){\n                int dist = x[j] - x[i];\n                int cost = max(T, dist*2) + dist;\n                dp[j+1] = min(dp[j+1], dp[i] + premove + cost);\n            }\n        }\n\n        // rep(i,N+1){\n        //     dump(dp[i]);\n        // }\n        \n        cout << dp[N] + E - x[N-1] << endl;\n\n        // ll cur = 0;\n        // ll ans = x[0];\n        // while(cur < N){\n        //     dump(cur);\n        //     dump(ans);\n        //     int lb = cur;\n        //     int ub = N;\n        //     // if(ok(cur, E)){\n        //     //     ans += T;\n        //     //     ans += E - x[cur];\n        //     // }\n        //     while(lb + 1 < ub){\n        //         int mid = (lb + ub) / 2;\n        //         // src -> dst -> src\n        //         bool ok = 2*(x[mid] - x[cur]) <= T;\n        //         if(ok){\n        //             lb = mid;\n        //         } else {\n        //             ub = mid;\n        //         }\n        //     }\n        //     dump(ub);\n        //     dump(T);\n        //     dump(x[ub] - x[cur]);\n        //     ans += T;\n        //     ans += x[ub] - x[cur];\n        //     cur = ub;\n        // }\n\n        // cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int MaxN = 1e5 + 10;\n\nint N, E, T, x[MaxN];\n\nlong long f[MaxN];\n\nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n\nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint j = find(i);\n\t\tif (j != i)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}\n\t\tif (j)\n\t\t{\n\t\t\t--j;\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename Monoid>\nstruct SegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n\n    int sz;\n    vector<Monoid> seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n        sz = 1;\n        while(sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid &x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for(int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid &x) {\n        k += sz;\n        seg[k] = x;\n        while(k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if(a & 1) L = f(L, seg[a++]);\n            if(b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int &k) const {\n        return seg[k + sz];\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll e, t;\n    cin >> e >> t;\n    e *= 2;\n    t *= 2;\n    ll x[100005];\n    x[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        x[i] *= 2;\n    }\n    x[n + 1] = e;\n    SegmentTree<ll> seg(n + 1, [](ll a, ll b){return max(a, b);}, 0ll);\n    ll dp[100005];\n    for(int i = 0; i <= n; i++){\n        if(i == 0) dp[0] = x[1] * 2;\n        int l = upper_bound(x, x + n + 2, x[i] - t / 2) - x - 1;\n        if(l > 0) dp[i] = max(dp[i], seg.query(0, l) + (x[i + 1] - x[i]) * 2);\n        seg.update(i, dp[i]);\n        int j = upper_bound(x, x + n + 2, x[i + 1] + t / 2) - x - 1;\n        j = min(j, n);\n        dp[j] = max(dp[j], dp[i] + (x[j + 1] - x[j]) * 2 - (x[i + 1] + t - x[j]));\n    }\n    cout << (e * 3 - dp[n]) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 2048\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint main()\n{\n  int n,e,t;\n  ll x[MAX];\n\n  cin>>n>>e>>t;\n\n  FOR(i,0,n)cin>>x[i];\n  if(n>MAX)return 0;\n\n  ll ans=e;\n\n  sort(x,x+n);\n  RFOR(i,n,0){\n    bool flag=true;\n    FOR(j,0,i){\n      if((x[i]-x[j])*2<t*(i-j+1)){\n        ans+=(x[i]-x[j])*2;\n        i=j;\n        flag=false;\n        break;\n      }\n    }\n    if(flag)ans+=t;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint i,j,k,n,m,x,y,t,a[100010];\nlong long f[100010];\nint E,T;\nlong long work(int x,int y){\n\tif ((a[y]-a[x+1])*2>=T)return 3ll*(a[y]-a[x+1]); else return T+a[y]-a[x+1];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor (i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)f[i]=1ll<<60;\n\tfor (i=0;i<n;i++){\n\t\tfor (j=i+1;j<=n;j++)\n\t\t\tf[j]=min(f[j],f[i]+a[i+1]-a[i]+work(i,j));\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T>\nostream& operator<<(ostream& o, vector<T>& v) {\n    for (auto& x : v) o << x << ' ';\n    return o;\n}\nconst int MAXN = 100010;\nll n, T, E;\n\nll arr[MAXN];\n\nll memo_small[MAXN];\nll dp_small(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo_small[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    res = LLONG_MAX/2;\n    for (int i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        ll cur = pre + max(2LL * d, T) + d + dp_small(i + 1);\n        if (cur < res) res = cur;\n    }\n    return res;\n}\n\nvoid solve_small(){\n    memset(memo_small, -1, sizeof memo_small);\n    ll res = dp_small(0);\n    cout << res << endl;\n}\n\nll memo[MAXN];\nll dp(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    int i;\n    for (i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        if (d > T) break;\n    }\n    ll d = arr[i-1] - arr[id];\n    res = pre + max(2LL * d, T) + d + dp(i);\n    return res;\n}\nvoid solve_large(){\n    memset(memo, -1, sizeof memo);\n    ll res = dp(0);\n    cout << res << endl;\n}\n\nint main(){\n    std::ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> E >> T;\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    if (n <= 2000) solve_small();\n    else solve_large();\n\n\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, E, T, r;\nint a[maxn];\nll Min1, Min2 = 1e18, f[maxn];\nint main()\n{\n\tdeque<ll> Q; \n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tQ.push_back(0);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\twhile((a[i] - a[r + 1]) * 2 >= T)\n\t\t{\n\t\t\tMin2 = min(Min2, f[r] - 2 * a[r + 1]);\n\t\t\twhile(Q.front() <= r) Q.pop_front();\n\t\t\t++r;\n\t\t}\n\t\tf[i] = min(Min1 + 1ll * i * T, Min2 + 2 * a[i]);\n\t\tif(!Q.empty()) f[i] = min(f[i], f[Q.front()] + T);\n\t\tMin1 = min(Min1, f[i] - 1ll * i * T);\n\t\twhile(!Q.empty() && f[i] <= f[Q.back()]) Q.pop_back();\n\t\tQ.push_back(i);\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=100010;\n\tconst ll INF=9223372036854775807ll;\n\tint a[N],b[N];\n\tint n,m;\n\tll ans;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=a[n];\n\t\tfor(int i=1,j;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;j<n && get_dis(i,j+1)*2<=m;j++);\n\t\t\tans+=m;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n//\tfreopen(\"out\",\"w\",stdout);\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\ntemplate<class V, int NV> class SegTree {\npublic:\n\tstatic V const def = (1LL << 61) - 1;\n\tV comp(V l, V r) { return min(l, r); };\n\n\tvector<V> val;\n\tSegTree() { val = vector<V>(NV * 2, def); }\n\n\tV getval(int l, int r) { //[l,r]\n\t\tl += NV; r += NV + 1;\n\t\tV ret = def;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) ret = comp(ret, val[l++]);\n\t\t\tif (r & 1) ret = comp(ret, val[--r]);\n\t\t\tl /= 2; r /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV;\n\t\tval[i] = v;\n\t\twhile (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n};\n//-----------------------------------------------------------------\nint N;\nll E, T;\nll X[101010];\nll Y[101010];\nll YY[101010];\nll dp[101010][2];\nSegTree<ll, 1 << 20> st;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\tY[0] = X[0];\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\tst.update(0, dp[0][0] - YY[0] * 3);\n\trep(i, 1, N) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\tdp[i][1] = min(dp[i][1], YY[i] * 3 + st.getval(0, i - 1));\n\t\tst.update(i, dp[i][0] - YY[i] * 3);\n\t}\n\n\t//rep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N - 1][1] + Y[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tlong long a[N];\n\tlong long dp[N];\n\tpriority_queue<pair<long long, long long> >q;\n\tf(i, N){\n\t\ta[i] = 0;\n\t\tdp[i] = 0;\n\t}\n\tint n, k;\n\tlong long x, y, z;\n\tlong long s, ans, t;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d %lld %lld\", &n, &s, &t);\n\tans = s;\n\tf(i, n){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tif (n == 1){\n\t\tprintf(\"%lld\\n\", s + t);\n\t\treturn 0;\n\t}\n\tdp[0] = t;\n\tq.push(make_pair(a[1] - dp[0], a[1]));\n\tq.push(make_pair(a[0], a[0]));\n\ts = 100000000000000000;\n\tfor (int i = 1; i<n; i++){\n\t\twhile (true){\n\t\t\tx = -q.top().first;\n\t\t\ty = q.top().second;\n\t\t\tif ((a[i] - y)>t){\n\t\t\t\ts = min(s, x - y);\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tx = -q.top().first;\n\t\tdp[i] = min(t + x + a[i], s + (2 * a[i]));\n\t\tif (i < n - 1)\tq.push(make_pair(a[i + 1] - dp[i], a[i + 1]));\n\t}\n\tans += dp[n - 1];\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=2e5+500;\nconst long long INF=1e9;\nint head,tail,n,E,T,x[N],q[N];\nlong long f[N],g1[N],g2[N];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    long long mi=INF;\n    for(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n    int j=0;g1[0]=-2*x[1],g2[0]=T-x[1];\n    int head=1,tail=1;q[1]=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(j<i&&2*x[j+1]<=2*x[i]-T)mi=min(mi,g1[j]),++j;\n        while(head<=tail&&q[head]<j)++head;\n        f[i]=3ll*x[i]+mi;\n        if(head<=tail)f[i]=min(f[i],2ll*x[i]+g2[q[head]]);\n        g1[i]=f[i]-x[i]-2*x[i+1];\n        g2[i]=f[i]-x[i]-x[i+1]+T;\n        while(head<=tail&&g2[i]<=g2[q[tail]])--tail;q[++tail]=i;\n    }\n    cout<<f[n]+E-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nvi dp,in;\nll n,e,t;\nll f(ll i,ll j){return dp[j]+in[j+1]-in[j]+max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];}\nint main(){\n\tcin>>n>>e>>t;\n\tin=vi(n+1);\n\trep(i,n)cin>>in[i+1];\n\tdp=vi(n+1,inf);\n\tdp[0]=0;\n\trep(i,n){\n//rep(j,i+1){\n\t\tll l=0,r=i+1;\n\t\twhile(r-l>3){\n\t\t\tll h1=(r-l)/3+l;\n\t\t\tll h2=(r-l)/3*2+l;\n\t\t\tll s1=f(i,h1);\n\t\t\tll s2=f(i,h2);\n\t\t\tif(s1>s2)l=h1;\n\t\t\telse r=h2;\n\t\t}\n\t\tll mi=inf;\n\t\tloop(j,max<ll>(l-3,0),min<ll>(i+1,r+3))mi=min(mi,f(i,j));\n\t\tdp[i+1]=mi;\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rb(x) ((x)&(-(x)))\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nll dp[MAXN];\n\nint A[MAXN];\n\nint N, T, E;\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tll &ret = dp[i];\n\t\tret = INFLL;\n\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tll t = dp[j] - A[j] - A[j+1]*2 + max(0ll, ll(T) - ll(A[i] - A[j+1])*2);\n\t\t\tt += ll(A[i]) * 3;\n\t\t\tupmin(ret, t);\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", dp[N] + E - A[N]);\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\nstruct RMQ{\n  int n;\n  vl dat;\n  RMQ(int _n){\n    n=1;\n    while(n<_n)n<<=1;\n    dat.assign(2*n,INF);\n  }\n  void set(int x,int v){\n    x += n-1;\n    dat[x] = v;\n    while(x!=0){\n      x = (x-1)/2;\n      dat[x] = min(dat[2*x+1],dat[2*x+2]);\n    }\n  }\n  ll qmin(int l,int r,int a,int b,int k){\n    if(r<=a || b<=l)return INF;\n    if(l<=a && b<=r){\n      return dat[k];\n    }else{\n      int m = (a+b)/2;\n      return min(qmin(l,r,a,m,2*k+1),qmin(l,r,m,b,2*k+2));\n    }\n  }\n  ll qmin(int l,int r){\n    return qmin(l,r,0,n,0);\n  }\n};\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = x[0];\n  REP(i,n)ans += x[i+1]-x[i];\n  RMQ aa(n),bb(n);\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    aa.set(i,2ll*x[i]+dp[i+1]);\n    bb.set(i,t       +dp[i+1]);\n    // find m s.t. 2dij<t\n    int l=i,r=n+1;\n    while(l+1<r){\n      int m = (l+r)/2;\n      int val = 2*(x[m]-x[i]);\n      if(val < t){\n        l = m;\n      }else{\n        r = m;\n      }\n    }\n    ll xx = aa.qmin(max(l+1+5,0),n) - 2ll*x[i];\n    ll yy = bb.qmin(0,min(l+1-5,n));\n    dp[i] = min(xx,yy);\n    FOR(j,min(l+1-5,n),max(l+1+5,0)){\n      if(i<=j && j<n)CHMIN(dp[i],calc(i,j));\n    }\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL inf=1LL<<60;\nLL f[100010],n,a[100010],e,t;\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tf[i]=inf;\n\t\tfor(LL j=0;j<i;j++) f[i]=min(f[i],f[j]+a[i]-a[j]+max(t,2*(a[i]-a[j+1])));\n\t}\n\tprintf(\"%lld\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "# include <cstdio>\n# include <algorithm>\nusing namespace std;\n\n# define REP(i, n) for (int i = 1; i <= n; ++ i)\n# define NR 101000\n\ntypedef long long ll;\n\nint n, E, T;\nll f[NR], x[NR];\n\nint main() {\n\tscanf (\"%d%d%d\", &n, &E, &T);\n\tint p = 0;\n\tll s = 1e12;\n\tREP (i, n) {\n\t\tscanf (\"%lld\", &x[i]);\n\t\t\n\t\twhile (p < i && 2 * (x[i] - x[p + 1]) >= T) {\n\t\t\ts = min (s, f[p] - x[p] - 2 * x[p + 1]);\n\t\t\t++ p;\n\t\t\t\n\t\t}\n\t\tf[i] = s + 3 * x[i];\n\t\t//printf (\"(p:%d) \", p);\n\t\tif (p != i) f[i] = min (f[i], f[p] - x[p] + x[i] + T);\n\t\t//printf (\"%I64d \", f[i]);\n\t}\n\t\n\tprintf (\"%lld\\n\", f[n] + E - x[n]);\n\t\n\treturn 0;\n}\n\n//j -> i -> j+1 -> i\n\n//f[i] = f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T)\n//f[i] = f[j] - x[j] + x[i] + T\n//f[i] = f[j] - x[j] - 2 * x[j + 1] + 3 * x[i]\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V> v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return LLONG_MAX;\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nll dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,E,T;\n    cin >> n >> E >> T;\n    vl vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    segtree<ll> st(vl(n,0));\n    dp[0] = 0;\n    st.range(0,1,-2*vec[0]);\n    rep(i,n){\n        int id = lower_bound(all(vec),vec[i]-T/2)-vec.begin();\n        if(id == 0){\n            dp[i+1] = dp[i]+T;\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n            continue;\n        }else if(id <= i){\n            dp[i+1] = dp[id]+T;\n        }\n        cmn(dp[i+1],st.query(0,i)+2*vec[i]);\n        if(i < n-1){\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n        }\n    }\n    cout << dp[n]+E << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, t, e;\nint x[111111];\nlong long f[111111], g[111111];\n\nint main(){\n//\tfreopen(\"input.inp\", \"r\", stdin);\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\",&x[i]);\n\tint p = 0;\n\tg[0] = - 2 * x[1];\n\tfor(int i = 1; i <= n; ++i){\n\t\twhile (2ll * (x[i] - x[p + 1]) > t) ++p;\n\t\tf[i] = f[p] + t;\n\t\tif (p) f[i] = min(f[i], g[p - 1] + 2 * x[i]);\n\t\tg[i] = min(f[i] - 2 * x[i + 1], g[i - 1]);\n\t}\n\tprintf(\"%lld\",f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e17\n\nstruct StarrySkyTree {\n  vector<ll> seg, lazy;\n  int size;\n  StarrySkyTree() {}\n  StarrySkyTree(int n) {\n    init(n);\n  }\n  void init(int n) {\n    size = 1;\n    while (size < n) size *= 2;\n    seg.resize(size * 2);\n    lazy.resize(size * 2);\n    for(ll i=0;i<size*2;i++)seg[i]=INF;\n  }\n  void update(int k,ll v){\n    k += size-1;\n    seg[k] = v;\n    while(k > 0){\n      k = (k - 1)/2;\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void push(int k, int l, int r) {\n    seg[k] += lazy[k];\n    if (r - l > 1) {\n      lazy[k * 2 + 1] += lazy[k];\n      lazy[k * 2 + 2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n  void add(int a, int b, ll v, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += v;\n      push(k, l, r);\n    } else {\n      add(a, b, v, k * 2 + 1, l, (l + r) / 2);\n      add(a, b, v, k * 2 + 2, (l + r) / 2, r);\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void add(int a, int b, ll v) {\n    add(a, b, v, 0, 0, size);\n  }\n  ll query(int a, int b, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return INF*10; // caution\n    if (a <= l && r <= b) return seg[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return min(vl,vr);\n  }\n  ll query(int a, int b) {\n    return query(a, b, 0, 0, size);\n  }\n};\n\nll n,T,E;\nll x[101010];\nset<P> st;\nStarrySkyTree dp,dp1,dp2;\n\nint main(){\n\tcin>>n>>E>>T;\n  rep(i,n)cin>>x[i];\n  rep(i,n)st.insert(P(-2*x[i],i));\n  x[n]=E;\n  dp.init(n+1); dp1.init(n+1); dp2.init(n+1);\n  rep(i,n+1){\n    dp.update(i,0); dp1.update(i,0); dp2.update(i,0);\n  }\n  dp.update(0,x[0]); dp1.update(0,x[0]-x[0]); dp2.update(0,x[0]-2*x[0]);\n  rep(i,n){\n    ll k;\n    if(st.lower_bound(P(-2*x[i]+T,-INF))==st.end())k=-1;\n    else k=st.lower_bound(P(-2*x[i]+T,-INF))->se;\n    k++;\n    ll crt=INF;\n    // [0,k)\n    minch(crt,dp2.query(0,k)+2*x[i]);\n    // [k,i+1)\n    minch(crt,dp.query(k,i+1)+T);\n    crt+=x[i+1]-x[i];\n    dp.add(i+1,i+2,crt); dp1.add(i+1,i+2,crt-x[i+1]); dp2.add(i+1,i+2,crt-2*x[i+1]);\n    dp.add(0,i+1,x[i+1]-x[i]); dp1.add(0,i+1,x[i+1]-x[i]); dp2.add(0,i+1,x[i+1]-x[i]);\n  }\n  cout<<dp.query(n,n+1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 101010;\nconst ll inf = 1ll<<50;\nll f[N] , x[N] , q[N];\nint n , T , E , l , r;\n\nll Dp(int i,int j){\n    return (x[j - 1] - x[i]) * 3 + max(0ll , T - 2 * (x[j - 1] - x[i])) + x[j] - x[j - 1] + f[j];\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&E,&T);\n    rep(i,1,n+1) scanf(\"%lld\",x + i);\n    x[n + 1] = E;\n    ll A = inf;\n    q[r++] = n + 1;\n    for(int i=n;i>=1;--i){\n        f[i] = f[i + 1] + x[i + 1] - x[i] + T;\n        while(2 * (x[q[l] - 1] - x[i]) >= T) A = min(A , x[q[l] - 1] * 2 + x[q[l]] + f[q[l]]) , ++l;\n        if(l < r) f[i] = min(f[i] , Dp(i , q[l]));\n        f[i] = min(f[i] , A - x[i] * 3);\n        while(l < r && Dp(i , i) <= Dp(i , q[r - 1])) --r;\n        q[r++] = i;\n    }\n    printf(\"%lld\\n\",x[1] + f[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,e,t,x[200000];\nlong long dp[200000];\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tfor(long long i=1,j=0,buf=1ll<<40;i<=n;i++)\n\t{\n\t\twhile(t<(x[i]-x[j+1])*2)\n\t\t{\n\t\t\tbuf=min(buf,dp[j]-x[j]-x[j+1]*2);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=min(buf+x[i]*3ll,dp[j]+x[i]-x[j]+t);\n\t\t//for(int j=0;j<i;j++)dp[i]=min(dp[i],dp[j]+x[i]-x[j]+max(t,(x[i]-x[j+1])<<1));\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double \n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\nusing namespace :: std;\n\n\nconst ll  maxn=1e5+500;\nconst ll inf=1e15+7;\n\nll dp[maxn];\nll a[maxn];\nll parminn[maxn];\nint main(){\n    fill(dp,dp+maxn,inf);\n    ll n,e,t;\n    cin>>n>>e>>t;\n    t*=2;\n    e*=2;\n    ll ans=0;\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n        a[i]*=2;\n    }\n    ll p=0;\n    parminn[0]=0;\n    dp[0]=0;\n    for(ll i=1;i<=n;i++){\n        while(p+1<i && a[i]-a[p]>=t/2){\n            p++;\n        }\n        if(p==0){\n            dp[i]=t;\n        }else{\n            dp[i]=min(dp[p]+t,parminn[p]+a[i]*2);\n        }\n        parminn[i]=min(parminn[i-1],dp[i-1]-a[i]*2);\n    }\n    cout<<(dp[n]+e)/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst llint big=1e15+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\nint main(void){\n\tllint n,ans,T,has=big;cin>>n>>ans>>T;\n\tqueue<pair<llint,llint>>mati;\n\twhile(n--){\n\t\tllint x;cin>>x;x*=2;\n\t\tmati.push(mp(x,ans));\n\t\twhile(x-mati.front().fir>=T){\n\t\t\tmineq(has,mati.front().sec-mati.front().fir);\n\t\t\tmati.pop();\n\t\t}\n\t\t//cout<<has<<\" \"<<ans<<endl;\n\t\tans=min(has+x,mati.front().sec+T);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x \": \" << x << \" \"\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << \"{\"; for(const T &a : v) out << a << \", \"; out << \"}\"; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << \"(\" << p.st << \", \" << p.nd << \")\"; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, t, e;\nlong long X[100010];\nlong long T[100010];\nmultiset<long long> D, G;\n\nlong long minS(const multiset<long long> &M){\n\tif(M.empty()) return 1000LL*1000*1000*1000 + 3;\n\treturn *M.begin();\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tFWD(i,1,n+1) scanf(\"%lld\", &X[i]);\n\n\tT[0] = 0;\n\t//D.insert(T[0] - X[0] + t);\n\n\tint p = 1;\n\tFWD(k,1,n+1){\n\t\twhile(2*(X[k] - X[p+1]) > t){\n\t\t\tD.erase(D.find(T[p] - X[p] + t));\n\t\t\tG.insert(T[p] - X[p+1] - X[p]);\n\t\t\t++p;\n\t\t}\n\t\tT[k] = min(minS(G) + 3*X[k], minS(D) + X[k]);\n\t\tT[k] = min(T[k], max(3*X[k] - 2*X[1], t+X[k]));\n\t\tD.insert(T[k] - X[k] + t);\n\t}\n\tprintf(\"%lld\\n\", T[n] + e - X[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst long long inf = 1e17 + 7;\n\nint n, E, T, d[N];\n\nstruct node {\n\tint l, r;\n\tlong long max;\t\n};\n\t\nstruct segTree {\n\tnode h[N << 2];\n\tint p[N];\n\t\n\tvoid build(int x, int l, int r) {\n\t\th[x].l = l; h[x].r = r; h[x].max = -inf;\n\t\tif (l == r) {\n\t\t\tp[l] = x;\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) / 2, L = x * 2, R = L + 1;\n\t\tbuild(L, l, m); build(R, m + 1, r);\n\t}\n\tvoid init(int n) {\n\t\tbuild(1, 1, n);\n\t}\n\t\n\tvoid modify(int x, int l, int r, long long k) {\n\t\tif (l > r) return;\n\t\tif (h[x].l == l && h[x].r == r) {\n\t\t\th[x].max = max(h[x].max, k);\n\t\t\treturn;\t\n\t\t}\n\t\t\n\t\tint m = (h[x].l + h[x].r) / 2;\n\t\tint L = x * 2, R = L + 1;\n\t\th[L].max = max(h[L].max, h[x].max);\n\t\th[R].max = max(h[R].max, h[x].max);\n\t\t\n\t\tif (r <= m) modify(L, l, r, k);\n\t\telse if (l >= m + 1) modify(R, l, r, k);\n\t\telse {\n\t\t\tmodify(L, l, m, k);\n\t\t\tmodify(R, m + 1, r, k);\t\n\t\t}\n\t}\n\t\n\tlong long getmax(int id) {\n\t\tint x = p[id];\n\t\tlong long res = -inf;\n\t\twhile (x) {\n\t\t\tres = max(res, h[x].max);\n\t\t\tx /= 2;\n\t\t}\n\t\treturn res;\n\t}\n} a, b;\n\nint Find(int l, int r, long long k) {\n\twhile (l < r) {\n\t\tint m = (l + r) / 2;\n\t\tif (m == n + 1 || 2 * d[m] >= k) r = m;\n\t\telse l = m + 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\td[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &d[i]);\t\n\ta.init(n); b.init(n);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint t;\n\t\tt = Find(i, n + 1, 1LL * T + 2 * d[i]);\n\t\t//printf(\"...%d %d\\n\", i, t);\n\t\ta.modify(1, i, t - 1, ans - 2 * d[i - 1] - T);\n\t\tb.modify(1, t, n, ans + 2 * d[i] - 2 * d[i - 1]);\n\t\tans = max(a.getmax(i) + 2 * d[i], b.getmax(i));\n\t\t//printf(\"%d %lld\\n\", i, ans);\n\t}\n\t//printf(\"%lld\\n\", ans);\n\tprintf(\"%lld\\n\", -ans + 2 * d[n] + E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\ntypedef long long ll;\n\nint n, e, t, x[100005];\nll dp[100005];\n\nnamespace SegTree {\n\tll mn[100005 << 2];\n\t\n\tvoid init() { memset(mn, 0x3f, sizeof mn); }\n\t\n\tvoid modify(int k, int l, int r, int pos, ll val) {\n\t\tif (l == r) {\n\t\t\tmn[k] = val; return;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (pos <= mid) modify(k << 1, l, mid, pos, val);\n\t\telse modify(k << 1 | 1, mid + 1, r, pos, val);\n\t\tmn[k] = std::min(mn[k << 1], mn[k << 1 | 1]);\n\t}\n\t\n\tll query(int k, int l, int r, int L, int R) {\n\t\tif (L > R) return 0x3f3f3f3f3f3f3f3fll;\n\t\tif (L <= l && r <= R) return mn[k];\n\t\tint mid = (l + r) >> 1;\n\t\tll res = 0x3f3f3f3f3f3f3f3fll;\n\t\tif (L <= mid) res = std::min(res, query(k << 1, l, mid, L, R));\n\t\tif (mid < R) res = std::min(res, query(k << 1 | 1, mid + 1, r, L, R));\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\t\n\tSegTree::init();\n\t\n\tint l = 1;\n\tdp[1] = t;\n\tSegTree::modify(1, 1, n, 1, dp[1]);\n\tfor (int i = 2; i <= n; ++i) {\n\t\twhile ((x[i] - x[l + 1]) * 2 >= t) {\n\t\t\tSegTree::modify(1, 1, n, l, dp[l] - x[l + 1] * 2);\n\t\t\t++l;\n\t\t}\n\t\tdp[i] = std::min(t + SegTree::query(1, 1, n, l, i - 1), \n\t\t\t\t\t\t x[i] * 2 + SegTree::query(1, 1, n, 1, l - 1));\n\t\tSegTree::modify(1, 1, n, i, dp[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e16;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 1;\n    ll now = 1e16;\n    for(int i = 1; i <= N; i++) {\n        now += 2 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before]) > T) {\n            now = min(now, dp[before - 1] + (x[i] - x[before - 1]) + 2 * (x[i] - x[before]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i] << endl;\n        //if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        dp[i] = min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + 2 * T + x[i] - x[before]);\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,cnt;\nstring s,t;\nvector<int>pos[26];\nvector<P>vec;\nint val[1000005],ans;\nint main(){\n\tcin>>n>>s>>t;\n\tfor(int i=0;i<n;i++) pos[s[i]-'a'].pb(i);\n\trep(i,26) assert(pos[i].size()<=1);\n\tfor(int i=0;i<t.size();){\n\t\tint nxt = t.size();\n\t\tfor(int j=i;j<t.size();j++){\n\t\t\tif(t[j] != t[i]){\n\t\t\t\tnxt = j; break;\n\t\t\t}\n\t\t}\n\t\t//i...nxt-1\n\t\t//cout<<i<<\" \"<<nxt-1<<endl;\n\t\tint x = POSU(pos[t[i]-'a'],i);\n\t\tx--;\n\t\tif(x == -1){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tfor(int y=x;y<pos[t[i]-'a'].size();y++){\n\t\t\tint g = pos[t[i]-'a'][y]; if(g >= nxt) break;\n\t\t\tint h;\n\t\t\tif(y==pos[t[i]-'a'].size()-1){\n\t\t\t\th = nxt-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(pos[t[i]-'a'][y+1]>=nxt-1) h = nxt-1;\n\t\t\t\telse h = pos[t[i]-'a'][y+1]-1;\n\t\t\t}\n\t\t\tif(g<h){\n\t\t\t\tval[g]++; val[h+1]--;\n\t\t\t}\n\t\t}\n\t\ti=nxt;\n\t}\n\tfor(int i=1;i<n;i++) val[i] += val[i-1];\n\tfor(int i=0;i<n;i++) ans=max(ans,val[i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define debug(a) cerr<<#a <<' '<< a <<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    VLL dp(n+1,LINF),x(n+1),dp2(n+1,LINF);\n    REP(i,n) cin >> x[i+1];\n    dp[0]=0;\n    dp[1]=t;\n    int l=0;\n    LL r=0;\n    FOR(i,2,n+1){\n        if(t<=2*(x[i]-x[l+1]))dp[i]=dp[l]+(x[i]-x[l+1])*2;\n        /*for(int j= l; j<i ; ++j){\n            if(dp[i]>dp[j]+max((LL)t,(x[i]-x[j+1])*2)){\n                dp[i]=min(dp[i],dp[j]+max((LL)t,(x[i]-x[j+1])*2));\n                l=j;\n            }\n            if(t>(x[i]-x[j+1])*2){\n                break;\n            }\n        }*/\n        //debug(l)\n        //debug(dp[i])\n        for(int j=r ; j<i ; ++j){\n            r=j;\n            if(t>(x[i]-x[j+1])*2){\n                dp[i]=min(dp[i],dp[r]+t);\n                break;\n            }\n        }\n\n        //debug(r)\n        if(dp[l]+(x[i+1]-x[l+1])*2>dp[i]) l=i;\n        //debug(dp[i])\n    }\n    cout << dp[n]+e<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N],p[N];int n,e,t;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%lld\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mn=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmn=min(mn,f[j]-2*p[j+1]);\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],mn+2*p[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=100100;\nconst ll inf=1e18;\nll a[N],f[N],mn,T,L;\nint n,q[N];\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>L>>T;\n\tfor(int i=1;i<=n;++i)cin>>a[i],f[i]=i*T;\n\tmn=inf;\n\tint t=0,w=0;q[0]=0;\n\tfor(int i=1,j=0;i<=n;++i){\n\t\tfor(;j<i&&2*(a[i]-a[j+1])>T;++j)mn=min(mn,f[j]-2*a[j+1]);\n\t\tf[i]=min(f[i],mn+2*a[i]);\n\t\tfor(;t<=w&&2*(a[i]-a[q[t]+1])>T;++t);\n\t\tif(t<=w)f[i]=min(f[i],f[q[t]]+T);\n\t\tfor(;t<=w&&f[q[w]]>f[i];--w);\n\t\tq[++w]=i;\n\t}\n\tcout<<L+f[n]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(13) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 1 << 18, B = 400, oo = 1e18 + 100, M = 2520;\n\n\nvoid smain() {\n    int n;\n    cin >> n;\n\n    int t, e;\n    cin >> e >> t;\n\n    n++;\n    vi kek(n);\n\n    for (int i = 0; i + 1 < n; ++i)\n        cin >> kek[i];\n\n    kek.back() = e;\n    vi dp(n, oo);\n    dp[0] = kek[0];\n\n    for (int i = 0; i + 1 < n; ++i)\n    {\n        int l = i, r = n - 1;\n        while (r - l > 1)\n        {\n            int m = l + r >> 1;\n            if (2 * (kek[m] - kek[i]) < t)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (l != i)\n            dp[l + 1] = min(dp[l + 1], dp[i] + t + (kek[l + 1] - kek[i]));\n        else\n            dp[i + 1] = min(dp[i + 1], dp[i] + t + kek[i + 1] - kek[i]);\n\n        if (r != n - 1)\n            dp[r + 1] = min(dp[r + 1], dp[i] + 2 * (kek[r] - kek[i]) + (kek[r + 1] - kek[i]));\n        else\n            dp.back() = min(dp.back(), dp[i] + max(t, 2 * (kek[n - 2] - kek[i])) + (kek[n - 1] - kek[i]));\n    }\n\n    cout << dp.back() + e - kek.back();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nlint cost(int l, int r) {\n    return d[l] - d[l - 1] + (d[r] - d[l]) * 3 + ((d[r] - d[l]) * 2 <= t ? t - (d[r] - d[l]) * 2 : 0);\n}\n\nint main() {\n    n = read();\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    for (int i = 1; i <= n; ++i) {\n        f[i] = INF;\n        for (int j = 0; j < i; ++j)\n            f[i] = min(f[i], f[j] + cost(j + 1, i));\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <int> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    ll go = 0;\n    for (int j = i + 1; j <= n; ++j) {\n      go += x[j] - x[j - 1];\n      dp[j] = min(dp[j], dp[i] + go + (ll)t * (j - i));\n      ll back = 2 * (go - (x[i + 1] - x[i]));\n      ll extra = max(0LL, t - back);\n      dp[j] = min(dp[j], dp[i] + go + 2 * (go - (x[i + 1] - x[i])) + extra);\n    }\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint a[N], b[N], dp[N], sum[N];\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tif(i == 1) {\n\t\t\tdp[1] = t + a[1];\n\t\t\tsum[1] = a[1];\n\t\t\tcontinue;\n\t\t}\n\t\tsum[i] = sum[i - 1] + a[i] - a[i - 1];\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint cnt = dp[j] + sum[j + 1] - sum[j] + max(t, 2 * (sum[i] - sum[j + 1])) + sum[i] - sum[j + 1];\n\t\t\tdp[i] = min(dp[i], cnt);\n\t\t}\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,e,t;\n  cin >> n >> e >> t;\n\n  vector<int> a(n);\n  REP(i,n) cin >> a[i];\n  a.push_back(e);\n  \n  int ans = a[0], cur = a[0], id = 0;\n  while(id < n){\n    while(id+1 < n && a[id+1]-cur <= t) id++;\n    ans += (a[id]-cur)*3;\n    ans += max(0LL,t-(a[id]-cur)*2);\n    \n    ans += a[id+1] - a[id];\n    cur = a[++id];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  using F = function<T(T&, T&)>;\n  int n;\n  vector<T > dat;\n  T e; // �P�ʌ�\n  F query_func;\n  F update_func;\n  \n  SegmentTree(vector<T> a, F query_func, F update_func, T e) :n(a.size()), query_func(query_func), update_func(update_func), e(e) {\n    dat.resize(4 * n);\n    init(0, 0, n, a);\n  }\n\n  void init(int k, int l, int r, vector<T> &a) {\n    if (r - l == 1) {\n      dat[k] = a[l];\n    }\n    else {\n      int lch = 2 * k + 1, rch = 2 * k + 2;\n      init(lch, l, (l + r) / 2, a);\n      init(rch, (l + r) / 2, r, a);\n      dat[k] = query_func(dat[lch], dat[rch]);\n    }\n  }\n\n  //k�Ԗڂ̒l��a�ɕύX\n  void update(int k, T a, int v, int l, int r) {\n    if (r - l == 1) {\n      dat[v] = update_func(dat[v], a);\n    }\n    else {\n      if (k < (l + r) / 2)\n        update(k, a, 2 * v + 1, l, (l + r) / 2);\n      else {\n        update(k, a, 2 * v + 2, (l + r) / 2, r);\n      }\n      dat[v] = query_func(dat[v * 2 + 1], dat[v * 2 + 2]);\n    }\n  }\n    \n\n  //[a,b)�̍ŏ��l�����߂�\n  //���̂ق��̈����͌v�Z�̊ȒP�̂��߂̈���\n  //k�͐ړ_�̔ԍ�,l,r�͂��̐ړ_��[l,r)�ɑΉ����Ă��邱�Ƃ�\\��\n  //�]���āA�O�����query(a,b,0,0,n)�Ƃ��Ă��\n  T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return e;\n    }\n    if (a <= l && r <= b) {\n      return dat[k];\n    }\n    else {\n      T ul = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T ur = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return query_func(ul, ur);\n    }\n  }\n\n  // �����𖞂����ĉE��T��\n  int find(int a, int b, int k, int l, int r, int x) {\n    // �����𒼂�\n    if (dat[k] < x || r <= a || b <= l) return -1;\n    if (l + 1 == r) {\n      // �����𒼂�\n      if (dat[k] >= x) return l;\n      else return -1;\n    }\n    int rv = find(a, b, 2 * k + 2, (l + r) / 2, r, x);\n    if (rv != -1) return rv;\n    return find(a, b, 2 * k + 1, l, (l + r) / 2, x);\n  }\n};\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    auto f = [](ll a, ll b) {return min(a, b);};\n    auto g = [](ll, ll b) {return b;};\n    SegmentTree<ll> seg(vl(n + 1, INF), f, g, INF);\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    seg.update(0, dp[0] - x[0] + t, 0, 0, seg.n);\n    ll mi = INF;\n    int ki = 0;\n    rep1 (i, n) {\n        int px = x[i] - t / 2 - 1;\n        auto itr = upper_bound(all(x), px);\n        itr--;\n        int pi = itr - x.begin();\n        pi--;\n        if (pi >= 0) {\n            dp[i] = dp[pi] + (x[pi + 1] - x[pi]) + (x[i] - x[pi + 1]) * 3;\n        }\n\n        ll mi = seg.query(pi + 1, i, 0, 0, seg.n);\n        chmin(dp[i], mi + x[i]);\n        seg.update(i, dp[i] - x[i] + t, 0, 0, seg.n);\n    }\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Debug(x) cout<<#x<<\"=\"<<(x)<<endl;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL inf = 1LL << 61;\nconst LL mod = 1000000007;\nconst int max_n = 100010;\n\n\nint n;\nLL T, E;\nLL dp[max_n], d[max_n], dp2[max_n], p[max_n];\nint main()\n{\n    int i = 0, j = 0, k = 0;\n    LL ans;\n    Fill(d, 0), Fill(dp, 0);\n    Fill(dp2, 0), Fill(p, 0);\n    scanf(\"%d %I64d %I64d\", &n,&E,&T);\n    for(i = 1; i <= n; i++)\n    {\n        scanf(\"%I64d\", d+i);\n    }\n    if(n==1)\n    {\n        ans = E+T;\n        printf(\"%I64d\\n\", ans);\n        return 0;\n    }\n    int tp;\n    for(i = 1; i <= n; i++)\n    {\n        for(tp = p[i-1]; tp < i; tp++)\n        {\n            if(T>2*(d[i]-d[tp+1]))\n                break;\n        }\n        p[i] = tp;\n    }\n    /*\n    cout << \"p:\\n\";\n    for(i = 1; i <= n; i++)\n    {\n        cout << p[i] << \" \";\n    }\n    cout << endl;\n    */\n    dp[1] = T;\n    dp2[1] = dp[1]-2*d[2];\n    for(i = 2; i <= n; i++)\n    {\n        tp = p[i];\n        dp[i] = max(T, 2*(d[i]-d[1]));\n        if(tp>0)\n        {\n            ans = min(dp[tp]+T, 2*d[i]+dp2[tp-1]);\n        }\n        else\n        {\n            ans = dp[tp]+T;\n        }\n        dp[i] = min(dp[i], ans);\n        if(i < n)\n            dp2[i] = min(dp2[i-1], dp[i]-2*d[i+1]);\n    }\n    /*\n    cout << \"dp:\\n\";\n    for(i = 1; i <= n; i++)\n    {\n        cout << dp[i] << \" \";\n    }\n    cout << endl;\n    */\n    ans = dp[n]+E;\n    printf(\"%I64d\\n\", ans);\n\n\n\n\n    return 0;\n}\n/*\n5 8 4\n1 3 4 6 7\n*/\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 100005\ntypedef long long LL;\nint n,x[maxn],T,E;\nLL f[maxn],ans;   \n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    for (int i=1;i<=n;i++) scanf(\"%d\",x+i);\n    for (int i=1;i<=n;i++) f[i]=1e16;\n/*    for (int i=1;i<=n;i++) \n        for (int j=1;j<=i;j++)\n            f[i]=min(f[i],f[j-1]+max(T,(x[i]-x[j])*2));*/\n    int p=1;LL t=1e16;;\n    for (int i=1;i<=n;i++)\n    {\n        while ((x[i]-x[p])*2>T&&p<=i) \n        {\n            t=min(t,f[p-1]-2*x[p]);\n            p++;   \n        }\n        f[i]=min(f[i],min(f[p-1]+T,t+2*x[i]));\n    }\n    ans=E+f[n];\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nstruct RMQ {\n    int N;\n    vector<long long> seg;\n\n    RMQ(int n) {\n        N = 1 << (int)log2(n * 2 - 1);\n        seg.resize(N * 2, 1e18);\n    }\n\n    void update(int k, long long v) {\n        for (seg[k += N] = v; k > 1; k >>= 1) {\n            seg[k >> 1] = min(seg[k], seg[k ^ 1]);\n        }\n    }\n\n    long long minimum(int l, int r) {\n        long long res = 1e18;\n        for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = min(res, seg[l++]);\n            if (r & 1) res = min(res, seg[--r]);\n        }\n        return res;\n    }\n};\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n), d(n), ds(n + 1);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    RMQ L(n + 1), R(n + 1);\n    L.update(0, 0);\n    R.update(0, 0);\n\n    for (int i = 0; i < n; i++) {\n        // T >= 2 * (ds[i] - ds[j])\n        int ok = i + 1;\n        int ng = -1;\n        while (ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if (T >= 2 * (ds[i] - ds[mid])) ok = mid;\n            else ng = mid;\n        }\n        chmin(dp[i + 1], L.minimum(ok, i + 1));\n        chmin(dp[i + 1], R.minimum(0, ok) + 2 * ds[i]);\n\n        L.update(i + 1, dp[i + 1] + T);\n        R.update(i + 1, dp[i + 1] - 2 * ds[i]);\n    }\n\n    cout << dp[n] + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e18;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    ll n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    dp[0]=0;\n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=lower_bound(x+1,x+n+1,(x[i]-T))-x;\n        j-=2;\n        dp[i]=dp[i-1]+T*2;\n\n        if(j>=0){\n            dp[i]=min(dp[i],dp2[j]+x[i]*2);\n        }\n\n\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n      //  cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n\n    }\n\n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, E, T, r;\nint a[maxn];\nll Min1, Min2 = 1e18, f[maxn];\nint main()\n{\n\tmultiset<ll> S; \n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tS.insert(a[1]);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\twhile((a[i] - a[r + 1]) * 2 >= T)\n\t\t{\n\t\t\tMin2 = min(Min2, f[r] - 2 * a[r + 1]);\n\t\t\tS.erase(S.find(f[r] + a[r + 1]));\n\t\t\t++r;\n\t\t}\n\t\tf[i] = min(Min1 + 1ll * i * T, Min2 + 2 * a[i]);\n\t\tif(!S.empty()) f[i] = min(f[i], *S.begin() + T - a[i]);\n\t\tMin1 = min(Min1, f[i] - 1ll * i * T);\n\t\tS.insert(f[i] + a[i + 1]); \n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define mp make_pair\n#define fi first\n#define se second\nconst int N=100005;\nset<pair<int ,int> >s;\nint n,e,t,x[N],f[N],dp[N],d[N];\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&x[i]);\n\te-=x[n];x[n+1]=e;\n\tfor (int i=n;i;i--)x[i]-=x[i-1];\n\tfor (int i=1;i<=n;i++)f[i]=f[i-1]+x[i];\n\tint l=0,r=-1,k=0;\n\ts.insert(mp(0,0));\n\tfor (int i=1;i<=n;i++){\n\t\twhile (k<i&&(f[i]-f[k+1])*2>t){\n\t\t\ts.erase(mp(x[k+1]-f[k+1]+dp[k],k));\n\t\t\twhile (l<=r&&-3*f[k+1]+x[k+1]+dp[k]<=-3*f[d[r]+1]+x[d[r]+1]+dp[d[r]])r--;\n\t\t\td[++r]=k;\n\t\t\tk++;\n\t\t}\n\t\tpair<int ,int > now=*s.begin();\n\t\tdp[i]=t+now.fi+f[i];\n\t\tif (l<=r)dp[i]=min(dp[i],f[i]*3-3*f[d[l]+1]+x[d[l]+1]+dp[d[l]]);\n\t\ts.insert(mp(x[i+1]-f[i+1]+dp[i],i));\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "//In the Name of God\n//Ya Ali\n\n#include<bits/stdc++.h>\n\n#define int long long\n\n#define lc (seg+seg+1)\n#define rc (seg+seg+2)\n\n#define err(A) cout<<#A<<\" = \"<<(A)<<endl\n\nusing namespace std;\n\nconst int inf=1e16+10;\nconst int maxn=100100;\n\nint n,e,t;\n\nint x[maxn];\n\nint mn[maxn*4];\n\nint dp[maxn];\n\nvoid cng(int seg,int ls,int rs,int ind,int x)\n{\n  if(ind+1<=ls or rs<=ind)\n    return;\n  if(ls==rs-1)\n    {\n      mn[seg]=x;\n      return;\n    }\n  int mid=(ls+rs)>>1;\n  cng(lc,ls,mid,ind,x);\n  cng(rc,mid,rs,ind,x);\n  mn[seg]=min(mn[lc],mn[rc]);\n}\n\nint mnr(int seg,int ls,int rs,int l,int r)\n{\n  if(r<=ls or rs<=l or r<=l)\n    return inf;\n  if(l<=ls and rs<=r)\n    return mn[seg];\n  int mid=(ls+rs)>>1;\n  return min(mnr(lc,ls,mid,l,r),\n\t     mnr(rc,mid,rs,l,r));\n}\n\nint32_t main()\n{\n  memset(mn,63,sizeof mn);\n  \n  ios::sync_with_stdio(0);cin.tie(0);\n\n  cin>>n>>e>>t;\n  t+=t;\n\n  int N=n+3;\n\n  x[0]=-inf;\n  for(int i=1;i<=n;i++)\n    {\n      cin>>x[i];\n      x[i]+=x[i];\n    }\n\n  for(int i=1;i<=n;i++)\n    {\n      int j=lower_bound(x,x+n+1,x[i]-t/2)-x;\n      dp[i]=dp[j-1]+t;\n      if(x[j]==x[i]-t/2)\n\tj++;\n      dp[i]=min(dp[i],mnr(0,0,N,0,j)+x[i]*2);\n      cng(0,0,N,i,dp[i-1]-x[i]-x[i]);\n    }\n\n  cout<<dp[n]/2+e<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre,p;\nint64 T,E;\nint64 x[100005];\nint N;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tdp[i] = min(dp[i],dp[i - 1] + T);\n\tif(p != -1) dp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front() + 1]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\nint dp[100006];\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\trep(i, n + 1)dp[i] = inf;\n\n\tif (n>2000)return 0;\n\n\tdp[0] = 0;\n\tx[n] = x[n - 1];\n\trep(i, n) {\n\t\tfor (int j = i; j<n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + max(2 * (x[j] - x[i]), t));\n\t\t}\n\t}\n\n\tcout << dp[n] + e<< endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#define ll long long\n#define inf 1e9\n#define eps 1e-10\n#define mod 9901\n#define mkp make_pair\nusing namespace std;\nint i,j,k,m,s,t,n,ans1,ans2,n1,nn,m1,mx;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint kabs(int a)\n{\n   if (a<0) return -a;\n   return a; \n}\nvoid add(int &x,int y)\n{\n   x+=y;\n   if (x>=mod) x-=mod;\n}\nvoid dec(int &x,int y)\n{\n\tx-=y;\n\tif (x<0) x+=mod;\n}\nint a[101000];\nll f[101000];\nint main()\n{\n\tint e;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tj=0;\n\tll s=1e18;\n\tfor (i=1;i<=n;i++)\n\t\tf[i]=1e18;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\twhile (2*(a[i]-a[j+1])>=t)\n\t\t\ts=min(s,f[j]-2ll*a[j+1]),j++;\n\t\tf[i]=min(f[j]+t,2ll*a[i]+s);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nll x[120000];\nint n;\nll e, t;\nll dp[120000];\n\nint main() {\n\tscanf(\"%d%lld%lld\", &n, &e, &t);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%lld\", x + i);\n\tint now = 0;\n\tll mn = 1e10;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (2 * (x[i] - x[0]) <= t) {\n\t\t\tdp[i] = t;\n\t\t\tcontinue;\n\t\t}\n\t\tmn = min(mn, -2 * x[0]);\n\t\twhile (2 * (x[i] - x[now + 1]) > t) {\n\t\t\tmn = min(mn, dp[now] - 2 * x[now + 1]);\n\t\t\tnow += 1;\n\t\t}\n\t\tdp[i] = mn + 2 * x[i];\n\t\tdp[i] = min(dp[i], dp[now] + t);\n\t}\n\tcout << e + dp[n - 1] << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nvector<long long> g[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tmultiset<long long> s;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\tfor (auto j:g[now]){\n\t\t//cerr<<\"J\"<<j<<endl;\n\t\t\ts.erase(s.find(j));\n\t\t\t//cerr<<\"J\"<<j<<endl;\n\t\t}\n\t\tf[now]=min(f[now],*s.begin());\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\t//f[x]=min(f[x],f[now]+wait);\n\t\t\ts.insert(f[now]+wait);\n\t\t\tg[x+1].push_back(f[now]+wait);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,t,x[100010];\nlong long f[100010],k;\nint main()\n{\n\tint i,j;\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tfor(i=1,j=0,k=1e18;i<=n;i++)\n\t{\n\t\tfor(;2*(x[i]-x[j+1])>t;j++)\n\t\t\tk=min(k,f[j]-2*x[j+1]);\n\t\tf[i]=min(k+2*x[i],f[j]+t);\n\t}\n\tcout<<f[n]+m<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nint n, e, t, x[100005];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\t\n\tll ans = e;\n\tint last = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (x[i] - x[i - 1] >= t) {\n\t\t\tans += std::max((x[i - 1] - x[last]) * 2, t);\n\t\t\tlast = i;\n\t\t}\n\t}\n\tans += std::max((x[n] - x[last]) * 2, t);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pr pair<int,int>\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#ifdef DEBUG\n    #define GG(x) assert(x)\n#else\n    #define GG(x) (x)\n#endif\nnamespace mine\n{\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=998244353;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e>=0);while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e5+10;\n\n    ll f[N],a[N];\n    void main()\n\t{\n        ll n=qread(),E=qread(),T=qread();fo(i,1,n) a[i]=qread();a[n+1]=E;\n        memset(f,0x3f,sizeof f);f[0]=0;\n        fo(i,1,n+1) fo(j,0,i-1) chmin(f[i],f[j]+max(T,2*(a[i]-a[j+1])));\n        write(f[n+1]+E);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn =  1e5 + 5;\n\nint n, E, T, pos;\nint a[maxn];\nll f[maxn], mn = 1e18;\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &E, &T);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n    {\n        while(T < 2 * (a[i] - a[pos + 1]))\n        {\n            mn = min(mn, f[pos] - 2 * a[pos + 1]);\n            pos++;\n        }\n        f[i] = min(f[i - 1] + T, mn + 2 * a[i]);\n        if(pos < i - 1)\n            f[i] = min(f[pos + 1] + T, f[i]);\n    }\n    printf(\"%lld\\n\", f[n] + E);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+5;\nconst long long inf=1LL<<61;\ntypedef long long LL;\nstruct sgt{\n\tLL mn[maxn*2];\n\tint id(int l,int r){return l+r|l!=r;}\n\n\tvoid build(int l,int r){\n\t\tmn[id(l,r)]=inf;\n\t\tif(l==r)return ;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid);\n\t\tbuild(mid+1,r);\n\t}\n\tLL Q(int l,int r,int l0,int r0){\n\t\tif(l0<=l&&r0>=r)\n\t\t\treturn mn[id(l,r)];\n\t\tint mid=(l+r)>>1;\n\t\tLL ans=inf;\n\t\tif(l0<=mid)ans=min(ans,Q(l,mid,l0,r0));\n\t\tif(r0>mid)ans=min(ans,Q(mid+1,r,l0,r0));\n\t\treturn ans;\n\t}\n\tvoid C(int l,int r,int ps,LL val){\n\t\tif(l==r){\n\t\t\tmn[id(l,r)]=val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(ps<=mid)C(l,mid,ps,val);\n\t\telse C(mid+1,r,ps,val);\n\t\tmn[id(l,r)]=min(mn[id(l,mid)],mn[id(mid+1,r)]);\n\t}\n}T1,T2;\nint n;\nLL T,E;\nLL d[maxn];\nLL dp[maxn],d2[maxn];\n\nLL bf(){\n\n\tdp[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=inf;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+d[i]-d[j-1]+max(T,2*(d[i]-d[j])));\n\t\t}\n\t\tprintf(\"dp[%d]=%lld\\n\",i,dp[i]);\n\t}\n\n\n\tLL ans=dp[n]+E-d[n];\n\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tn++;\n\td[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\td2[i]=d[i]*2;\n\t}\n\n\n\t//TODO\n//\tcout<< bf() <<endl;\n//\treturn 0;\n\tT1.build(1,n);\n\tT2.build(1,n);\n\n\n\tdp[1]=0;\n\tT1.C(1,n,1,0);\n\tT2.C(1,n,1,0);\n\n\tfor(int i=2;i<=n;i++){\n\t\tint ps=0;\n\n\t\tdp[i]=dp[i-1]+d[i]-d[i-1]+T;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(2*(d[i]-d[j])>=T){\n\t\t\t\tps=j;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n//\t\tcerr<<\"it is \"<<i<<\" \"<<ps<<endl;\n\t\tLL res1=inf,res2=inf;\n\n\t\tif(ps>=1)\n\t\t\tres1=T1.Q(1,n,1,ps)+3*d[i];\n\n\t\tif(ps+1<=i-1)\n\t\t\tres2=T2.Q(1,n,ps+1,i-1)+d[i]+T;\n//\t\tcerr<<res1<<\" \"<<res2<<endl;\n\n\t\tdp[i]=min(dp[i],res1);\n\t\tdp[i]=min(dp[i],res2);\n//\t\tcerr<<\"dp = \"<<dp[i]<<endl;\n\t\tT1.C(1,n,i,dp[i-1]-d[i-1]-2*d[i]);\n\t\tT2.C(1,n,i,dp[i-1]-d[i-1]);\n\t}\n\n\tLL ans=dp[n]+E-d[n];\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<numeric>\n#include<iomanip>\n#include<utility>\n#include<cstdlib>\n#include<typeinfo>\n#include<stack>\n#include<cassert>\n#include<functional>\n#define int long long int\n#define double long double\nusing namespace std;\n#define INT_MAX 1000000005\n#define INF 1000000005\nconst int MAX_N = 1 << 17;\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nsigned main()\n{\nint n,t,e;\nstd::cin >> n >> e >> t;\nstd::vector<int> x;\nfor(int i = 0; i < n; i++){\n    int temp;\n    std::cin >> temp;\n    x.push_back(temp);\n}\nint sum = 0;\nsum += n * t + e;\nfor(int i = 0; i < n - 1; i++){\n    int flag = 0;\n    for(int k = 1; i + k < n; k++){\n        if((x[i + k] - x[i]) * 2 < 2 * t){\n            flag = k;\n        }\n    }\n    if(flag >= 1){\n        sum -= 2 * t - (x[i + flag] - x[i]) * 2; \n    }\n}\nstd::cout << sum << std::endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\n\nvoid solve() {\n        long long n, e, t;\n        cin >> n >> e >> t;\n        assert(n <= 2000);\n        vector<long long> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        vector<long long> dp(n, INFL);\n        dp[0] = t;\n        for (int i = 1; i < n; i ++) {\n                for (int j = 0; j < i; j ++) dp[i] = min(dp[i], dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n                dp[i] = min(dp[i], max(t, 2 * (x[i] - x[0])));\n        }\n        cout << dp[n - 1] + e << endl;\n        return;\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],ok[3000][3000],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tfor(int A=1;A<=N+100;A++)\n\t\tdp[A]=-1;\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]),ok[A][B]=1;\n\t\t\t//cout<<A<<\" \"<<B<<\" \"<<pre[A][B]<<\"\\n\";\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,t,w;\nlong long dp[2500];\nint x[2500];\nint main(){\n\tcin>>n>>w>>t;\n\tdp[0]=0,x[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i+1];\n\t\tdp[i+1]=1145141919810;\n\t}\n\tfor(int len=1;len<n;len++){\n\t\tfor(int org=0;org<=n-len;org++){\n\t\t\tdp[len+org]=dp[org]+min(2*(x[org+len]-x[org]),t)+x[org+len];\n\n\t\t}\n\t}\n\tcout<<dp[n]+w-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\nconst LL INF = 1e18;\nconst int MAXN = 111111 * 2;\nint n, E;\nLL f[MAXN], minf[MAXN], x[MAXN], T, tr[MAXN << 2];\n\ninline int get_node(int l, int r) {\n\treturn l + r | l != r;\n}\n\ninline void build_tree(int l, int r) {\n\tint k = get_node(l, r);\n\ttr[k] = INF;\n\tif (l == r) return;\n\tint mid = l + r >> 1;\n\tbuild_tree(l, mid);\n\tbuild_tree(mid + 1, r);\n}\n\ninline void add(int l, int r, int x, LL val) {\n\tint k = get_node(l, r);\n\tif (l == r) {\n\t\ttr[k] = val;\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tif (x > mid) {\n\t\tadd(mid + 1, r, x, val);\n\t} else {\n\t\tadd(l, mid, x, val);\n\t}\n\ttr[k] = min(tr[get_node(l, mid)], tr[get_node(mid + 1, r)]);\n}\n\ninline LL query(int l, int r, int a, int b) {\n\tint k = get_node(l, r);\n\tif (l == a && r == b) {\n\t\treturn tr[k];\n\t}\n\tint mid = l + r >> 1;\n\tif (a > mid) return query(mid + 1, r, a, b);\n\tif (b <= mid) return query(l, mid, a, b);\n\treturn min(query(l, mid, a, mid), query(mid + 1, r, mid + 1, b));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> x[i];\n\t}\n\t\n\tx[0] = 0;\n\tx[n + 1] = E;\n\tf[0] = 0;\n\tminf[0] = f[0] - x[0] - x[1] * 2;\n\tbuild_tree(0 + 1, n + 1);\n\tadd(0 + 1, n + 1, 0 + 1, f[0] - x[0]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = f[i - 1] + x[i] - x[i - 1] + T;\n\t\t/*for (int j = 0; j < i; ++j) {\n\t\t\tLL temp;\n\t\t\tif (T > (x[i] - x[j + 1]) * 2) {\n\t\t\t\ttemp = f[j] + x[i] - x[j] + T;\n\t\t\t} else {\n\t\t\t\ttemp = f[j] + x[i] - x[j] + (x[i] - x[j + 1]) * 2;\n\t\t\t}\n\t\t\tf[i] = min(f[i], temp);\n\t\t}*/\n\t\tint left = 0, right = i - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = left + right >> 1;\n\t\t\tif (T > (x[i] - x[mid + 1]) * 2) {\n\t\t\t\tright = mid;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\tf[i] = min(f[i], query(0 + 1, n + 1, left + 1, i - 1 + 1) + x[i] + T);\n\t\tif (left > 0) {\n\t\t\tf[i] = min(f[i], minf[left - 1] + x[i] * 3);\n\t\t}\n\t\tminf[i] = min(minf[i - 1], f[i] - x[i] - x[i + 1] * 2);\n\t\tadd(0 + 1, n + 1, i + 1, f[i] - x[i]);\n\t}\n\tcout << f[n] + x[n + 1] - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAX 100100\n#define ll long long\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,E,T,x[MAX];\nll ans,f[MAX],mn=1e18;\nint main()\n{\n\tn=read();E=read();T=read();\n\tfor(int i=1;i<=n;++i)x[i]=read();\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tfor(int i=1,j=0;i<=n;++i)\n\t{\n\t\tfor(;T<=(x[i]-x[j+1])<<1;++j)mn=min(mn,f[j]-2*x[j+1]);\n\t\tif(j<i)f[i]=min(f[i],f[j]+T);\n\t\tf[i]=min(f[i],mn+2*x[i]);\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,pp,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 1;\n\tlong long mi = (1 << 31) - 1;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\twhile (pp <= n && 2 * (d[i] - d[pp]) > t){\n\t\t\tmi = min(mi,f[pp - 1] - d[pp] * 2);\n\t\t\tpp++;\n\t\t}\n\t\tf[i] = min(f[pp - 1] + t,mi + d[i] * 2);\n\t}\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst long long inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int N = 1e5 + 10; \nint a[N], nxt[N], n, e, t;\nlong long val;\nlong long seg[N << 2], lazy[N << 2], dp[N];\nvector<int> fnd[N];\n//\nvoid relax(int id) {\n\tint lc = id * 2, rc = lc + 1;\n\tseg[lc] += lazy[id], lazy[lc] += lazy[id];\n\tseg[rc] += lazy[id], lazy[rc] += lazy[id];\n\tlazy[id] = 0;\n\treturn;\n}\nvoid add(int l, int r, int id = 1, int s = 0, int e = n) {\n\tif (e <= l || r <= s)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tadd(l, r, lc, s, mid);\n\tadd(l, r, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n//\tcout << \"s = \" << s << \" e = \" << e << \" : \" << seg[id] << endl;\n}\nvoid upd(int p, int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tseg[id] = val;\n\t\tlazy[id] = 0;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tif (p < mid)\n\t\tupd(p, lc, s, mid);\n\telse\n\t\tupd(p, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n\treturn;\n}\nvoid open(int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tcout << \"s = \" << s << \" : \" << seg[id] << endl;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\topen(lc, s, mid);\n\topen(rc, mid, e);\n}\n//\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint st = -1;\n\tn++;\n\tfor (int i = 0; i < n; i++) {\n\t\tval = inf;\n\t\tupd(i);\n\t\twhile ((a[i] - a[st + 1]) * 2 >= t)\n\t\t\tst++;\n\t\tif (st != -1)\n\t\t\tfnd[st].push_back(i);\n\t}\n\tst = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile ((a[st - 1] - a[i]) * 2 >= t)\n\t\t\tst--;\n\t\tnxt[i] = st;\n\t}\n//\tcout << \"HO\" << endl;\n\tval = t;\n\tupd(n - 1);\n\tfor (int i = n - 2; i >= 0; i--) {\n//\t\tcout << \"i = \" << i << endl;\n\t\tlong long toall = a[i + 1] - a[i], tosome = a[i + 2] - a[i + 1];\n\t\tval = toall, add(i + 1, n);\n\t\tif (tosome > 0)\n\t\t\tval = 2 * tosome, add(nxt[i + 1], n);\n\t\tfor (auto plc : fnd[i + 1]) {\n\t\t\tlong long dis = 1ll * (a[plc] - a[i + 1]) * 3 + 1ll * toall;\n\t\t\tval = dis + dp[plc], upd(plc);\n//\t\t\tcout << \"plc = \" << plc << \" : \" << dis << \" val = \" << val << endl;\n\t\t}\n//\t\tcout << \" open : \" << endl;\n//\t\topen();\n//\t\tcout << endl;\n\t\tdp[i] = seg[1], val = dp[i] + t;\n//\t\tcout << \"i = \" << i << \" a[i] =  \" << a[i] << \" dp = \" << dp[i] << \" toall = \" << toall << \" tosome = \" << tosome << \" nxt = \" << nxt[i + 1] << endl;\n\t\tupd(i);\n\t}\n\tcout << dp[0] + e - a[n - 1];\n//\tcout << endl;\n//\topen();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nll N,E,T;\nll dp1 [100001];\nll dp2 [100001];\nconst ll INF = 1e17;\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&E,&T);\n\tvector<ll> X(N + 1);\n\tfor(int i = 1;i <= N;i++){\n\t\tscanf(\"%lld\",&X [i]);\n\t}\n\n\tfill_n(dp1,N + 1,INF);\n\tfill_n(dp2,N + 1,INF);\n\tdp1 [0] = 0;\n\n\tint j = 1;\n\tfor(int i = 1;i <= N;i++){\n\t\twhile(j < i && (X [i] - X [j]) * 2 > T) j++;\n\t\tchmin(dp1 [i],dp1 [j - 1] + T);\n\t\tchmin(dp1 [i],dp2 [j - 1] + X [i] * 2);\n\t\tchmin(dp2 [i],min(dp2 [i - 1],dp1 [i - 1] - X [i] * 2));\n\t}\n\n\tprintf(\"%lld\\n\",dp1 [N] + E);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nll dp[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tmemset(dp,127/3,sizeof(dp)); dp[0]=x[1]; x[0]=x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int pos=0;pos<i;pos++)\n\t\t{\n\t\t\tint l2=x[i]-x[pos];\n\t\t\tif(2*l2>=t) dp[i]=min(dp[i],dp[pos]+l2*3LL);\n\t\t\tdp[i]=min(dp[i],dp[pos]+(i-pos)*ll(t)+l2);\n\t\t}\n\t}\n\tll ans=dp[n]+e-x[n];\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define MAXN 55\n# define MAXM 100005\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nint a[100005];\nLL dp[100005][2];\n\nint main()\n{\n    int n, E, T;\n    LL ans=0;\n    scanf(\"%d%d%d\",&n,&E,&T);\n    FO(i,0,n) scanf(\"%d\",a+i);\n    int i=1;\n    dp[0][0]=a[0]; dp[0][1]=a[0]+T;\n    while(i<n) {\n        dp[i][0]=dp[i-1][1]+a[i]-a[i-1];\n        dp[i][1]=dp[i-1][1]+a[i]-a[i-1]+T;\n        if (T>=(LL)2*(a[i]-a[i-1])) dp[i][1]=min(dp[i][1], dp[i-1][0]+T+a[i]-a[i-1]);\n        else if (T>=a[i]-a[i-1]) dp[i][1]=min(dp[i][1], dp[i-1][0]+(LL)3*(a[i]-a[i-1]));\n        ++i;\n    }\n    printf(\"%lld\\n\",dp[n-1][1]+E-a[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\n\nvoid smain() {\n\n    int n,e,t;\n    cin>>n>>e>>t;\n    vi x(n);\n    for(int i=0;i<n;i++){\n        cin>>x[i];\n    }\n\n    int ans=x[0]+e-x[n-1];\n    for(int i=1;i<n;i++){\n        int j=i,cur=0;\n        while(j<n&&x[j]-x[j-1]<=t){\n            cur+=(x[j]-x[j-1]);\n            j++;\n        }\n        ans+=cur+max(2*cur,t);\n        if(j<n)\n            ans+=x[j]-x[j-1];\n        if(j==1||j==n-1)\n            ans+=t;\n        i=j;\n    }\n\n    cout<<ans;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint st[800005][2]; \nvoid update(ll root, ll l, ll r, ll i, ll val, ll id){\n\tif (i < l || r < i) return;\n\tif (l == r){\n\t\tst[root][id] = val; return;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(root * 2 + 1, l, mid, i, val, id);\n\tupdate(root * 2 + 2, mid + 1, r, i, val, id);\n\tst[root][id] = min(st[root * 2 + 1][id], st[root * 2 + 2][id]);\n}\nll query(ll root, ll l, ll r, ll u, ll v, ll id){\n\tif (v < l || r < u) return 1e12;\n\tif (u <= l && r <= v) return st[root][id];\n\tll mid = (l + r) / 2;\n\treturn min(query(root * 2 + 1, l, mid, u, v, id), query(root * 2 + 2, mid + 1, r, u, v, id));\n}\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\t// dp[i]: shortest time to clear first i candies.\n\tdp[0] = 0;\n\t// 2 segtrees: one record dp[j] - 2 * a[j + 1] - a[j], one record dp[j] - a[j].\n\tupdate(0, 0, n - 1, 0, dp[0] - 2 * a[1], 0);\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tll lw; // lw: (a[i] - a[lw]) * 2 <= t, (a[i] - a[lw - 1]) * 2 > t. (lw - 1 -> 0)\n\t\t// manual binsearch? lw >= l, <= r\n\t\tll l = 0, r = i;\n\t\twhile (l < r){\n\t\t\tll mid = (l + r) / 2;\n\t\t\tif ((a[i] - a[mid]) * 2 <= t) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tlw = l;\n\t\t// so (dp[j] - 2 * a[j + 1] - a[j]) + 3 * a[i] with a from 0 to lw - 1, (dp[j] - a[j]) + a[i] + t to lw to i - 1\n\t\tdp[i] = min(query(0, 0, n - 1, 0, lw - 1, 0) + 3 * a[i], query(0, 0, n - 1, lw, i - 1, 1) + a[i] + t);\n\t\tupdate(0, 0, n - 1, i, dp[i] - 2 * a[i + 1] - a[i], 0); update(0, 0, n - 1, i, dp[i] - a[i], 1);\n\t\t// for (ll j = 0; j < i; j++) dp[i] = min(dp[i], dp[j] + max(2 * (a[i] - a[j + 1]), t) + a[i] - a[j]);\n\t}\n\t// hj, optimize nao\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n\tif (j == 0) {\n\t\treturn a[i] + t * (i - j);\n\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 3ll * (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) - t << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 3ll * (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) - t) + dp[j];\n}\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre;\nint64 T,E;\nint64 x[100005];\nint N,p;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 1e18;\n    que.push_back(0);\n    for(int i = 1 ; i <= N ; ++i) {\n\twhile(p < i - 1 && 2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tdp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front() + 1]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_map>\n# include <unordered_set>\n# include <thread>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing ui32 = unsigned int;\nconstexpr ll INFLL = 1e18;\n\n#define CHECK_IMPL1(cond)              \\\nif (!(cond)) {                         \\\n    DEBUG(\"expected cond: \" << #cond); \\\n    assert(cond);                      \\\n}\n\n#define CHECK_IMPL2(cond, message)                                            \\\nif (!(cond)) {                                                                \\\n    DEBUG(\"expected cond: \" << #cond << \" failed with message: \" << message); \\\n    assert(cond);                                                             \\\n}\n#define CHECK_IMPL(_1, _2, NAME, ...) NAME\n#define CHECK(...) CHECK_IMPL(__VA_ARGS__, CHECK_IMPL2, CHECK_IMPL1, CHECK_IMPL0)(__VA_ARGS__)\n\n#ifdef __APPLE__\n#define DEBUG(message) std::cerr << message << std::endl;\n#else\n#define DEBUG(message)\n#endif\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : n_(n), tree_(5 * n + 1, INFLL) {\n  }\n\n  void update(int pos, ll value) {\n    update_impl(pos, value, 1, 0, n_);\n  }\n\n  ll get(int l, int r) {\n    return get_impl(l, r, 1, 0, n_);\n  }\n\n private:\n  void update_impl(int pos, ll value, int v, int l, int r) {\n    if (l == r) {\n      tree_[v] = value;\n    } else {\n      int m = (l + r) / 2;\n      if (pos <= m) {\n        update_impl(pos, value, v * 2, l, m);\n      } else {\n        update_impl(pos, value, v * 2 + 1, m + 1, r);\n      }\n      tree_[v] = min(tree_[v * 2], tree_[v * 2 + 1]);\n    }\n  }\n\n  ll get_impl(int l, int r, int tv, int tl, int tr) {\n    if (r < tl || l > tr) {\n      return INFLL;\n    }\n    if (l == tl && r == tr) {\n      return tree_[tv];\n    }\n    int tm = (tl + tr) / 2;\n    return min(get_impl(l, min(tm, r), tv * 2, tl, tm), get_impl(max(tm + 1, l), r, tv * 2 + 1, tm + 1, tr));\n  }\n\n private:\n  int n_;\n  vector<ll> tree_;\n};\n\nvoid solve() {\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n\n  vector<ll> x(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    cin >> x[i];\n  }\n\n  vector<ll> dp(n + 1, INFLL);\n  dp[0] = 0;\n\n  SegmentTree first_case(n);\n  SegmentTree second_case(n);\n\n  first_case.update(0, 0 - 2 * x[1] - x[0]);\n  second_case.update(0, 0 - x[0]);\n\n  for (int i = 1; i <= n; i++) {\n    int k = lower_bound(x.begin(), x.end(), (2 * x[i] - t) / 2) - x.begin();\n    if (k > i - 1) {\n      k = i - 1;\n    }\n\n    // 1) dp[i] = min(dp[i], dp[j] + 3 * x[i] - 2 * x[j + 1] - x[j]);\n    // 2) dp[i] = min(dp[i], dp[j] + x[i] + t - x[j]);\n\n//    cout << k << \" first: \" << first_case.get(0, k) << \" second: \" << second_case.get(k + 1, i - 1) << endl;\n//\n//    cout << \"1) \" << first_case.get(0, k - 1) + 3 * x[i] << endl;\n//    cout << \"2) \" << second_case.get(k, i - 1) + x[i] + t << endl;\n\n    dp[i] = min(dp[i], first_case.get(0, k - 1) + 3 * x[i]);\n    dp[i] = min(dp[i], second_case.get(k, i - 1) + x[i] + t);\n\n    if (i < n) {\n      first_case.update(i, dp[i] - 2 * x[i + 1] - x[i]);\n      second_case.update(i, dp[i] - x[i]);\n    }\n\n//    for (int j = 0; j < i; j++) {\n//      dp[i] = min(dp[i], dp[j] + (x[i] - x[j + 1]) * 3 + max(0ll, t - 2 * (x[i] - x[j + 1])) + x[j + 1] - x[j]);\n//    }\n\n//    cout << i << \" \" << dp[i] << endl;\n  }\n\n  cout << dp[n] + e - x[n] << \"\\n\";\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n#ifdef __APPLE__\n  freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", stdout);\n#endif\n  int t = 1;\n//  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[125252];\n\nll dp[125252];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\nstruct RMQ{\n  int n;\n  vl dat;\n  RMQ(int _n){\n    n=1;\n    while(n<_n)n<<=1;\n    dat.assign(2*n,INF);\n  }\n  void set(int x,int v){\n    x += n-1;\n    dat[x] = v;\n    while(x!=0){\n      x = (x-1)/2;\n      dat[x] = min(dat[2*x+1],dat[2*x+2]);\n    }\n  }\n  ll qmin(int l,int r,int a,int b,int k){\n    if(r<=a || b<=l)return INF;\n    if(l<=a && b<=r){\n      return dat[k];\n    }else{\n      int m = (a+b)/2;\n      return min(qmin(l,r,a,m,2*k+1),qmin(l,r,m,b,2*k+2));\n    }\n  }\n  ll qmin(int l,int r){\n    return qmin(l,r,0,n,0);\n  }\n};\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = x[0];\n  REP(i,n)ans += x[i+1]-x[i];\n  RMQ aa(n),bb(n);\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    aa.set(i,2ll*x[i]+dp[i+1]);\n    bb.set(i,t       +dp[i+1]);\n    // find m s.t. 2dij<t\n    int l=i,r=n+1;\n    while(l+1<r){\n      int m = (l+r)/2;\n      int val = 2*(x[m]-x[i]);\n      if(val < t){\n        l = m;\n      }else{\n        r = m;\n      }\n    }\n    ll xx = aa.qmin(max(l+1+5,0),n) - 2ll*x[i];\n    ll yy = bb.qmin(0,min(l+1-5,n));\n    dp[i] = min(xx,yy);\n    FOR(j,min(l+1-5,n),max(l+1+5,0)){\n      if(0<=j && j<n)CHMIN(dp[i],calc(i,j));\n    }\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(13) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 1 << 18, B = 400, oo = 1e18 + 100, M = 2520;\n\n\nvoid smain() {\n    int n;\n    cin >> n;\n\n    int t, e;\n    cin >> e >> t;\n\n    vi kek(n + 1);\n\n    for (int i = 1; i <= n; ++i)\n        cin >> kek[i];\n\n\n    vi dp(n + 1, oo);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = i + 1; j <= n; ++j)\n        {\n            int v = kek[i + 1] - kek[i] + max(2 * (kek[j] - kek[i + 1]), t) + kek[j] - kek[i + 1];\n            dp[j] = min(dp[j], dp[i] + v);\n        }\n    }\n\n    cout << dp.back() + e - kek.back();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long maxn=(1ll<<63-1);\nlong long a[10001],dp[10001]={0};\nlong long n,e,t,k=0;\nint main()\n{\n\tmemset(dp,0x3f3f3f3f,sizeof(dp));\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n    {\n        while(t<=2*(a[i]-a[k+1]))\n        {\n            maxn=min(maxn,dp[k]-2*a[k+1]);\n            k++;\n        }\n        dp[i]=dp[k]+t;\n        dp[i]=min(dp[i],maxn+2*a[i]);\n    }\n    dp[n]+=e;\n    cout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=100010;\n\tconst ll INF=214748364700000ll;\n\tstruct Increasing_queue\n\t{\n\t\tll dl[N];\n\t\tint pos[N];\n\t\tint head,tail;\n\t\tvoid init(){head=0,tail=1;}\n\t\tvoid insert(ll x,int p)\n\t\t{\n\t\t\twhile(head>=tail && dl[head]>=x)head--;\n\t\t\tdl[++head]=x;\n\t\t\tpos[head]=p;\n\t\t}\n\t\tvoid del(int p)\n\t\t{\n\t\t\twhile(head>=tail && pos[tail]<=p)tail++;\n\t\t}\n\t\tll query(){return head>=tail?dl[tail]:INF;}\n\t}d;\n\tint a[N],b[N];\n\tll f[N],tmp;\n\tint n,m;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n//\tinline ll calc(int i,int j)\n//\t{\n//\t\tll dis=get_dis(i,j),ret=dis*3+b[j];\n//\t\tret+=std::max(0ll,m-dis*2);\n//\t\treturn ret;\n//\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\td.init(),tmp=INF;\n\t\tf[0]=a[0],d.insert(f[0]-a[0],0);\n\t\tint ind=0;\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(;ind<i && get_dis(ind,i)*2>m;ind++)\n\t\t\t\td.del(ind),check_min(f[ind]-3ll*a[ind],tmp);\n\n\t\t\tf[i]=d.query()+a[i]+m;\n\t\t\tcheck_min(tmp+3ll*a[i]-2ll*b[i],f[i]);\n\n\t\t\td.insert(f[i]-a[i],i);\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]);\n\t}\n}\nint main()\n{\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=1e5+10;\nint n;\nLL e,t,x[N],dp[N],tt=1e18;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline I mi(const I&a,const I&b){return a<b ? a : b;}\nint main()\n{\n//\tfreopen(\"Shik and Game.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,e,t);\n\tfor(int i=1;i<=n;i++) read(x[i]), dp[i]=2e9;\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[j+1])>=t) \n\t\t{\n\t\t\ttt=mi(tt,dp[j]-2*x[j+1]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=mi(dp[j]+t,tt+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<algorithm>\n#define min(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\nint n,m,t,x[100010];\nlong long f[100010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tlong long k;\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=1,j=0,k=1e18;i<=n;i++)\n\t  {\n\t   for(;2*(x[i]-x[j+1])>t;j++)\n\t     k=min(k,f[j]-2*x[j+1]);\n\t   f[i]=min(k+2*x[i],f[j]+t);\n      }\n    cout<<f[n]+m<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\ntypedef long long ll;\n#define INF 1LL<<60\nint N, E, T;\nint x[101010];\n//-----------------------------------------------------------------\nll dp[101010];\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &x[i + 1]);\n\n\tdp[0] = 0;\n\trep(i, 1, N + 1) {\n\t\tdp[i] = INF;\n\t\trep(j, 0, i) dp[i] = min(dp[i], dp[j] + max(2 * (x[i] - x[j + 1]), T));\n\t}\n\tcout << dp[N] + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint p[100001],s[100001],a[100001];\nlong long f[100001];\nbool cj(int x,int y,int z){\n\treturn 1ll*(x-z)*(p[y]-p[z])>=1ll*(y-z)*(p[x]-p[z]);\n}\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=0;i<=n;a[i]=s[s[0]],s[++s[0]]=i++)\n\t\tfor(;s[0]>1&&cj(i,s[s[0]],s[s[0]-1]);s[0]--);\n\ta[1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=f[i-1]+t;\n\t\tfor(int j=1;j<=i;j++)\n\t\tf[i]=min(f[i],max(t,2*(p[i]-p[j]))+f[j-1]);\n\t}\n\t//\tfor(int i=1;i<=n;i++)cout<<f[i]<<\" \";\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node; \npublic:\n    SegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, inf);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint N;\nll T,E;\n\nll res(vector<ll>& X){\n    vector<ll> dp(N+1,inf);\n    dp[0] = 0;\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i]-X[i-1]+T;\n        for(int j=1;j<=i-1;j++){\n            dp[i] = min(dp[i],dp[j-1]+X[j]-X[j-1]+3*(X[i]-X[j])+max(T-2*(X[i]-X[j]),0LL));\n        }\n    }\n    return dp[N]+(E-X[N]);\n}\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    SegmentTree seg1(vector<ll>(N+2,inf)),seg2(vector<ll>(N+2,inf));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.update(0,dp[0]-X[1]);\n    seg2.update(0,dp[0]-3*X[1]);\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i+1]-X[i]+T;\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        //cerr << i << \" \" << id << \" \" << seg1.getmin(id,i) << \" \" << seg2.getmin(0,id) << endl;\n        dp[i] = min(dp[i],seg1.getmin(max(id-1,0),i)+T+X[i+1]);\n        if(id>0) dp[i] = min(dp[i],seg2.getmin(0,id-1)+2*X[i]+X[i+1]);\n        seg1.update(i,dp[i]-X[i+1]);\n        seg2.update(i,dp[i]-3*X[i+1]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n    //cerr << res(X) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[2001];\nLL dp[2001];\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tif(n > 2000) { return 1; }\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tinc1(i, n) {\n\t\tLL mi = 1000000000000000LL;\n\t\tinc(j, i) {\n\t\t\tLL v = dp[j] + (x[i] - x[j]) + max(2 * (x[i] - x[j + 1]), t);\n\t\t\tsetmin(mi, v);\n\t\t}\n\t\tdp[i] = mi;\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + (e - x[n]));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nll e, t;\nll x[100010];\n\nll memo[100010];\n\nll calc(int k) {\n    if (memo[k] < 0) {\n        if (k == n) memo[k] = 0;\n        else {\n            // wait\n            ll res = t + x[k+1] - x[k] + calc(k+1);\n            int x0 = k+1, x3 = n-1, x1, x2;\n            ll v1, v2;\n            ll d;\n            while (x3 - x0 > 2) {                \n                x1 = x0 + (x3-x0)/3;\n                x2 = x0 + 2*(x3-x0)/3;\n                d = x[x1] - x[x1];\n                v1 = 3*d + max(0LL, t-2*d) + calc(x1+1)+x[x1+1]-x[x1];\n                d = x[x2] - x[x2];\n                v2 = 3*d + max(0LL, t-2*d) + calc(x2+1)+x[x2+1]-x[x2];\n                if (v1 < v2) {\n                    x3 = x2;\n                } else {\n                    x0 = x1;\n                }\n            }\n            for (int i = k+1; i < n; i++) {\n                ll d = x[i] - x[k];\n                res = min(res, 3*d + max(0LL, t-2*d) + calc(i+1)+x[i+1]-x[i]);\n            }\n\n            d = x[x0] - x[x0];\n            res = min(res, 3*d + max(0LL, t-2*d) + calc(x0+1)+x[x0+1]-x[x0]);\n            d = x[x1] - x[x1];\n            res = min(res, 3*d + max(0LL, t-2*d) + calc(x1+1)+x[x1+1]-x[x1]);\n            d = x[x2] - x[x2];\n            res = min(res, 3*d + max(0LL, t-2*d) + calc(x2+1)+x[x2+1]-x[x2]);\n            d = x[x3] - x[x3];\n            res = min(res, 3*d + max(0LL, t-2*d) + calc(x3+1)+x[x3+1]-x[x3]);\n            memo[k] = res;\n        }\n    }\n    return memo[k];\n}\n\nll solve() {\n    memset(memo, -1, sizeof(memo));\n    x[n] = e;\n    return calc(0) + x[0];\n}\n\nvoid input() {\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> x[i];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \nconst ll INF = 1ll<<50;\n \n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b){\n            return seg[k];\n        }\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n \nconst int MAXN = 100100;\nll N, E, T;\nll X[MAXN];\nll dp[MAXN];\n \nint main() {\n    cin >> N >> E >> T;\n    for (int i = 0; i < N; i++)\n        cin >> X[i];\n    const ll INF = 1ll<<60;\n    ST<ll> seg(N+10);\n    for (int i = 0; i <= N; i++) {\n        dp[i] = INF;\n    }\n    X[N] = E;\n    dp[N] = 0;\n    seg.update(N, dp[N] + X[N] + 2*X[N-1]);\n    for (int i = N-1; i >= 0; i--) {\n        // まず T が支配的な部分を探索\n        int low = i, high = N;\n        while (high - low > 1) {\n            const int med = (low + high) / 2;\n            if (2*(X[med]-X[i]) <= T) {\n                low = med;\n            } else {\n                high = med;\n            }\n        }\n        // cout << low+1 << \"a\" << N << endl;\n        dp[i] = dp[low+1] + X[low+1] - X[i] + T;\n        dp[i] = min(dp[i], seg.query(low+1, N) - 3*X[i]);\n        if (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << X[0] + dp[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=100005;\ntypedef long long ll;\nconst ll INF=1e15;\nll d[N];\nint n,m,T;\nll a[N];\nint q[N];\nint s,t;\nint main()\n{\n    //freopen(\"computer.in\",\"r\",stdin);\n    //freopen(\"computer.out\",\"w\",stdout);\n    scanf(\"%d%d%d\",&n,&m,&T);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        d[i]=INF;\n    }\n    if(n<=1000){\n        for(int i=1;i<=n;i++)\n            for(int j=0;j<i;j++){\n                ll f=max(a[i]-a[j+1],T-(a[i]-a[j+1]));\n                d[i]=min(d[i],d[j]+a[i]-a[j]+f+max(a[i]-a[j+1],T-f));\n            }\n        ll ans=d[n]+m-a[n];\n        printf(\"%lld\\n\",ans);\n    }\n    else{\n        s=1,t=1;\n        ll z=INF;\n        for(int i=1;i<=n;i++){\n            while(s<=t&&2*(a[i]-a[q[s]+1])>T){\n                z=min(z,d[q[s]]-a[q[s]]-2*a[q[s]+1]);\n                s++;\n            }\n            d[i]=min(d[i],a[i]+z+2*a[i]);\n            //d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+2*(a[i]-a[q[s]+1]));\n            d[i]=min(d[i],d[q[s]]+a[i]-a[q[s]]+T);\n            while(s<=t&&d[q[s]]-a[q[s]]>=d[i]-a[i])\n                t--;\n            q[++t]=i;\n        }\n        ll ans=d[n]+m-a[n];\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  int l = 0, r = 0;\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n\n    for(int d=max(r, idx)-1;d<idx2&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n    l = max(l, idx);\n    r = max(r, idx);\n  }\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,n_;\nll t,e;\nll x[100005];\n\nstruct data{\n\tll val,lazy;\n\tdata(){}\n\tdata(ll vv,ll la){\n\t\tval=vv;\n\t\tlazy=la;\n\t}\n};\n\ndata dp[1<<21];\n\nvoid lazy_evaluate(int k){\n\tdp[k].val+=dp[k].lazy;\n\tif(k+1<n_){\n\t\tdp[k*2+1].lazy+=dp[k].lazy;\n\t\tdp[k*2+2].lazy+=dp[k].lazy;\n\t}\n\tdp[k].lazy=0;\n}\n\nvoid lazy_update(int k){\n\tdp[k].val=min(dp[k*2+1].val,dp[k*2+2].val);\n}\n\nll query(int a,int b,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return INF*INF;\n\tif(a<=l && r<=b)return dp[k].val;\n\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n\treturn min(vl,vr);\n}\n\nvoid add(int a,int b,ll v,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return;\n\tif(a<=l && r<=b){\n\t\tdp[k].lazy+=v;\n\t\tlazy_evaluate(k);\n\t\treturn;\n\t}\n\tadd(a,b,v,k*2+1,l,(l+r)/2);\n\tadd(a,b,v,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n}\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tif(n>=2001)return 0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tn_=1;\n\twhile(n_<=n)n_*=2;\n\tadd(1,n+1,x[n]+n*t);\n\tint now=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i>0){\n\t\t\twhile(now<i){\n\t\t\t\tll ela=x[i]-x[now+1];\n\t\t\t\tif(ela+x[i]-x[now+1]>=t){\n\t\t\t\t\t//dp[i]=min(dp[i],dp[now]+(x[i]-x[now+1])*2LL);\n\t\t\t\t\tnow++;\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[now+1]);\n\t\t\t\t\tll vi=query(i,i+1);\n\t\t\t\t\tll vi2=query(now,now+1);\n\t\t\t\t\tif(vi>vi2+rest){\n\t\t\t\t\t\tadd(i,i+1,vi2+rest-vi);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll vi=query(i,i+1);\n\t\tll vi2=query(0,now);\n\t\tif(vi>vi2){\n\t\t\tadd(i,i+1,vi2-vi); \n\t\t}\n\t\tif(i>0 && i<n)add(0,i,(x[i+1]-x[i])*2LL);\n\t\t/*\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tprintf(\"%lld \",query(j,j+1));\n\t\t}\n\t\tprintf(\"\\n\");\n\t\t*/\n\t}\n\t/*\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t\tif(i<n)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t\tif(i>=1 && j<i){\n\t\t\t\tll ela=dp[i][j]-dp[j+1][j];\n\t\t\t\t//printf(\"%lld\\n\",ela);\n\t\t\t\tif(ela+x[i]-x[j+1]>=t){\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL);\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[j+1]);\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL+rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tprintf(\"%lld\\n\",query(n,n+1)+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst LL INF = 1LL << 62;\n\nint N;\nLL E, T;\nLL x[114514];\nLL d[114514];\nLL dp[114514];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N >> E >> T;\n  reps(i, 1, N+1) {\n    cin >> x[i];\n  }\n\n  rep(i, N) {\n    d[i] = x[i+1] - x[i];\n  }\n\n  fill(dp, dp+N+1, INF);\n  dp[0] = 0;\n  multiset<LL> ones, threes;\n  ones.insert(T);\n\n  priority_queue<pll, vector<pll>, greater<pll>> evs;\n  evs.push(pll(2*(x[0]+d[0])+T, 0));\n  reps(i, 1, N+1) {\n    while (!evs.empty() && evs.top().X <= x[i]*2) {\n      auto p = evs.top(); evs.pop();\n      int idx = p.Y;\n      auto itr = ones.find(dp[idx]+T-x[idx]);\n      assert(itr != ones.end());\n      ones.erase(itr);\n      threes.insert(dp[idx]-(3*x[idx]+2*d[idx]));\n    }\n\n    if (!ones.empty()) {\n      MN(dp[i], x[i]+*ones.begin());\n    }\n\n    if (!threes.empty()) {\n      MN(dp[i], 3*x[i]+*threes.begin());\n    }\n\n    ones.insert(dp[i]+T-x[i]);\n    evs.push(pll(2*(x[i]+d[i])+T, i));\n  }\n  printf(\"%lld\\n\", dp[N] + E - x[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  int l = 0, r = 0;\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    int idx2 =\n      (idx==n?n: lower_bound(all(x), x[idx]+(t/2)+(t%2)) - x.begin());\n      \n    for(int d=max(l, idx)-1;d<max(idx2, r)&&d<n;d++){\n      ll ad = max(t, 2*(x[d] - x[now])); //追加される分\n      ll nxt = d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n    l = max(l, idx);\n    r = max(r, idx);\n  }\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V> v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return LLONG_MAX;\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nll dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,E,T;\n    cin >> n >> E >> T;\n    vl vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    segtree<ll> st(vl(n,0));\n    dp[0] = 0;\n    st.range(0,1,-2*vec[0]);\n    rep(i,n){\n        int id = lower_bound(all(vec),vec[i]-(T+1)/2)-vec.begin();\n        if(id == 0){\n            dp[i+1] = dp[id]+T;\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n            // cout << \"OO \" << i+1 << \" \" << dp[i+1]-2*vec[i+1] << \"\\n\";\n            continue;\n        }else if(id <= i){\n            dp[i+1] = dp[id]+T;\n        }\n        cmn(dp[i+1],st.query(0,i)+2*vec[i]);\n        // show(st.query(0,i+1));\n        if(i < n-1){\n            st.range(i+1,i+2,dp[i+1]-2*vec[i+1]);\n        }\n    }\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << \"\\n\";\n    // }\n    cout << dp[n]+E << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,E,T;\nll X[202020];\ntemplate<class V,int NV> class SegTree_1 {\npublic:\n\tvector<V> val;\n\tstatic V const def=1LL<<60;\n\tV comp(V l,V r){ return min(l,r);};\n\t\n\tSegTree_1(){val=vector<V>(NV*2,def);};\n\tV getval(int x,int y,int l=0,int r=NV,int k=1) {\n\t\tif(r<=x || y<=l) return def;\n\t\tif(x<=l && r<=y) return val[k];\n\t\treturn comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));\n\t}\n\tvoid update(int entry, V v) {\n\t\tentry += NV;\n\t\tval[entry]=v;\n\t\twhile(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);\n\t}\n};\n\nSegTree_1<ll,1<<20> st1,st3;\n\nll R[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>E>>T;\n\t\n\t\n\tx=0;\n\tX[N+1]=E;\n\tfor(i=1;i<=N;i++) cin>>X[i];\n\t\n\tst1.update(0,0);\n\tst3.update(0,-2*X[1]);\n\tfor(i=1;i<=N;i++) {\n\t\twhile(2*(X[i]-X[x+1])>T) x++;\n\t\t\n\t\tR[i]=min(3*X[i]+st3.getval(0,x), X[i]+T+st1.getval(x,i));\n\t\tst1.update(i,R[i]-X[i]);\n\t\tst3.update(i,R[i]-(X[i]+2*X[i+1]));\n\t\t\n\t}\n\t\n\tcout<<R[N]+E-X[N]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint dp[100020];\n\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=i-cor;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<=vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse vec[i]=vec[2*i+1];\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<=v2.first)return v1;\n\t\telse return v2;\n\t}\n\t\n};\n\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tfor(int i=0;i<=100010;i++)dp[i]=inf*1000000000ll;\n\t\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\t\n\tvector<int> ve(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\t\n\tSegmin ss;\n\tss.shoki1();\n\tss.shoki2();\n\t\n\tdp[0]=t;\n\tss.updchan(0,dp[0]-2*ve[1]);\n\tfor(int i=1;i<n;i++){\n\t\t// r miman\n\t\tint r =ve[i]-t/2;\n\t\tint it=lower_bound(ve.begin(),ve.end(),r)-ve.begin();\n\t\t// [ 0,it)\n\t\t// [it, i]\n\t\t\n\t\tif(1){\n\t\t\tif(it)dp[i]=min(dp[i],t+dp[it-1]);\n\t\t\telse dp[i]=min(dp[i],t);\n\t\t}\n\t\n\t\tif(it){\n\t\t\tdp[i]=min(dp[i],2*(ve[i]-ve[0]));\n\t\t\tif(it>1){\n\t\t\t\tint z=ss.segmin(0,it-1).first +2* ve[i];\n\t\t\t\tdp[i]=min(dp[i],z);\n\t\t\t}\n\t\t}\t\n\t//\tcout<<dp[i]<<endl;\n\t\tss.updchan(i,dp[i]-2*ve[i+1]);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\t\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=100010;\n\tconst ll INF=9223372036854775807ll;\n\tint a[N],b[N];\n\tint n,m;\n\tll ans;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=a[n];\n\n\t\tfor(int i=0,j;i<n;i=j)\n\t\t{\n\t\t\tfor(j=i;j<n && get_dis(i,j+1)*2<=m;j++);\n\n\t\t\tans+=m;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n//\tfreopen(\"out\",\"w\",stdout);\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 3123456\nint n,m,t,x[SZ];\nchar ch,B[1<<20],*S=B,*T=B;\n#define getc() (S==T&&(T=(S=B)+fread(B,1,1<<20,stdin),S==T)?0:*S++)\n#define isd(c) (c>='0'&&c<='9')\nint aa,bb;int F(){\n\tint x; scanf(\"%d\",&x); return x;\n    while(ch=getc(),!isd(ch)&&ch!='-');ch=='-'?aa=bb=0:(aa=ch-'0',bb=1);\n    while(ch=getc(),isd(ch))aa=aa*10+ch-'0';return bb?aa:-aa;\n}\n#define gi F()\n#define BUFSIZE 5000000\nnamespace fob {char b[BUFSIZE]={},*f=b,*g=b+BUFSIZE-2;}\n#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)\n#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)\nstruct foce {~foce() {pob; fflush(stdout);}} _foce;\nnamespace ib {char b[100];}\ninline void pll(ll x)\n{\n    if(x==0) {pc(48); return;}\n    //if(x<0) {pc('-'); x=-x;} //如果有负数就加上 \n    char *s=ib::b;\n    while(x) *(++s)=x%10, x/=10;\n    while(s!=ib::b) pc((*(s--))+48);\n}\nll qf[SZ],f[SZ];\nint main()\n{\n\tn=gi,m=gi,t=gi;\n\tfor(int i=1;i<=n;i++) x[i]=gi;\n\tint p=0; f[0]=0; qf[0]=-2LL*x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(t<=2*(x[i]-x[p+1])&&p<i) ++p;\n\t\tll c=1e18;\n\t\tif(p<i)\n\t\t\tc=min(c,f[p]+max(t,2*(x[i]-x[p+1])));\n\t\tif(p) c=min(c,qf[p-1]+2*x[i]);\n\t\tf[i]=c;\n\t\tqf[i]=min(qf[i-1],f[i]-2LL*x[i+1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt dp[108000];\nInt x[108000];\nInt l, n, e, t;\nint main(){\n  cin >> n >> e >> t;\n  fill(dp, dp + 108000, LINF);\n  dp[0] = 0;\n  for(int i = 1;i <= n;i++)cin >> x[i];\n  for(int i = 1;i <= n;i++){\n    while((x[i] - x[l+1])*2>=t)l++;\n    dp[i] = dp[l] + x[l]*2 - x[i]*2 + t;\n    if(l)dp[i] = min(dp[i], dp[l-1]);\n    dp[i] = min(dp[i], dp[i-1]);\n  }\n  cout << e + dp[n] + x[n]*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long f[101010];\nlong long x[101010];\nlong long E,T;\nlong long calc(int i,int j)\n{\n\treturn max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]);\n}\nint main()\n{\n\tint n;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]+T;\n\t\tint l=1,r=n-1;\n\t\twhile(r-l>2)\n\t\t{\n\t\t\tint m1=(2*l+r)/3,m2=(l+2*r+2)/3;\n\t\t\tif(calc(i,m1)<calc(i,m2))\n\t\t\t\tr=m2;\n\t\t\telse\n\t\t\t\tl=m1;\n\t\t}\n\t\tfor(int j=l;j<=r;j++)\n\t\t\tf[i]=min(f[i],max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]));\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n#include <bits/stdc++.h>\n//#include \"testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n\nbool debug=true;\n\n/*    *************************************\n\t  * Written in New Computer           *\n\t  * The following code belongs to     *\n\t  * XiaoGeNintendo of HellHoleStudios *\n\t  *************************************\n*/\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,pair<T1,T2> ptt){\n\tos<<ptt.first<<\",\"<<ptt.second;\n\treturn os;\n}\ntemplate<typename T>ostream& operator<<(ostream& os,vector<T> vt){\n\tos<<\"{\";\n\tfor(int i=0;i<vt.size();i++){\n\t\tos<<vt[i]<<\" \";\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll n,t,e;\nll dp[100005];\nll x[100005];\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n>>e>>t;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i];\n\t}\n\t\n\t//dp[i]=min{dp[j]+max{t,2*(x[i]-x[j])}}\n\t//dp[i]=min{dp[j]+2*(x[i]-x[j])} or dp[i]=min{dp[j]+t} <-easy\n\t//dp[i]=2*x[i]+min{dp[j]-2*x[j])} \n\tll last=0,mn=-2*x[0];\n\tfor(int i=0;i<n;i++){\n\t\tif(2*(x[i]-x[0])<=t){\n\t\t\tdp[i]=t;\n\t\t\tcontinue;\n\t\t}\n\t\n\t\twhile(2*(x[i]-x[last+1])>t){\n\t\t\tmn=min(mn,dp[last]-2*x[last+1]);\n\t\t\tlast++;\n\t\t}\n\t\t\n\t\tdp[i]=min(mn+2*x[i],dp[last]+t);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll INF = 1LL << 60;\n\nint N, E;\nll T;\nll x[100010];\nll dp[100010];\n\nusing Data = pair<ll, ll>;\n\npriority_queue<Data, vector<Data>, greater<Data>> que, que2;\nint piv;\n\nint main() {\n\tcin >> N >> E >> T;\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcin >> x[i];\n\t\tdp[i] = INF;\n\t}\n\n\tque.push(mp(T, x[1]));\n\n\tfor (int i = 1; i <= N; ++i) {\n\n\t\twhile (!que.empty()) {\n\t\t\tData p = que.top();\n\n\t\t\tif (p.se * 2 + T < x[i] * 2) {\n\t\t\t\tque.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[i] = min(dp[i], p.fi);\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (piv < i && 2 * x[piv+1] + T <= 2 * x[i]) {\n\t\t\tque2.push(mp(dp[piv] - 2 * x[piv + 1] - x[piv], x[piv+1]));\n\t\t\t++piv;\n\t\t}\n\n\t\tif (que2.size()) {\n\t\t\tdp[i] = min(dp[i], que2.top().fi + x[i] * 2);\n\t\t}\n\n\t\tdp[i] += x[i];\n\t\tque.push(mp(dp[i]-x[i]+T, x[i+1]));\n\t}\n\n\tcout << dp[N] + E - x[N] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)\n#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)\n\nmt19937 Rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\ntemplate <typename T>\ninline void chkmax(T &x, T y) { if (x < y) x = y; }\n\ntemplate <typename T>\ninline void chkmin(T &x, T y) { if (x > y) x = y; }\n\ninline int read() {\n  #define nc getchar()\n  int x = 0;\n  char c = nc;\n  while (c < 48) c = nc;\n  while (c > 47) x = (x << 3) + (x << 1) + (c ^ 48), c = nc;\n  return x;\n  #undef nc\n}\n\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nint n, m, T, a[maxn];\n\nll dp[maxn];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &T);\n  rep(i, 1, n) a[i] = read();\n  int l = 1, r = 1;\n  static int Q[maxn];\n  int tpos = -1; ll tmin = 1e18;\n  rep(i, 1, n) {\n    for (; tpos < i && 2 * a[tpos + 1] <= 2 * a[i] - T; tpos++) {\n      if (~tpos) chkmin(tmin, dp[tpos] - 2 * a[tpos + 1]);\n    }\n    while (l <= r && 2 * a[Q[l] + 1] <= 2 * a[i] - T) l++;\n    dp[i] = tmin + 2 * a[i];\n    if (l <= r) {\n      chkmin(dp[i], dp[Q[l]] + T);\n    }\n    while (l <= r && dp[Q[r]] >= dp[i]) r--;\n    Q[++r] = i;\n  }\n  printf(\"%lld\", dp[n] + m);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = n;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 >= T) low = mid;\n      else high = mid;\n    }\n    int pos = low;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long ll ;\nconst ll mk = 100055;\nconst ll logn  = 29;\nconst ll mod = 1e9 + 7;\n\n#define endl \"\\n\"\n#define IOS  ios::sync_with_stdio(0); cin.tie(0);\n#define fi first\n#define se second\n#define pii pair<ll,ll>\n#define pq priority_queue\n#define UwU              uwu\n#define UwU              Mikuwu\n#define Miku             best_waifu\n#define Miku_dancing     god_waving\n#define Miku_singing     god_shaking\n#define a_Miku           cho_doi_bot_ngu\n\nint n, e , t, a[mk], dp[mk];\nvector<int> g[mk];\n\nvoid init() {\n    cin >> n >> e >> t; \n    for(int i = 1; i<=n ; i++) cin >> a[i];\n}\nvoid solve() {\n\tdp[0] = 0 ;  a[0] = 0; \n\tfor(int i= 1; i <= n ; i++) {\n\t\tdp[i] = INT_MAX;\n\t\tfor(int j = 0; j < i ; j++) {\n\t\t\tif(t > 2* (a[i] - a[j + 1])/* go back or not , Miku is still the best waifu */ ) dp[i] = min(dp[i] , dp[j] + a[i] - a[j] + t);\n\t\t\telse dp[i] = min(dp[i] , dp[j] + 2 * (a[i] - a[j + 1]) + a[i] - a[j]); \n\t\t}\n\t}\n\tcout << dp[n] + e - a[n];\n}\nsigned main() {\n\tinit();\n\tsolve();\n\t\n}\n\n "
  },
  {
    "language": "C++",
    "code": "// <<<<GOD>>>> lET'S gO\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll N = 1e5 + 100, inF = 1e15;\n\nll n, e, t, mini = inF, a[N], dp[N];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile(2 * (a[i] - a[p]) > t) {\n\t\t\tmini = min(mini, dp[p - 1] - 2 * a[p]);\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = dp[p - 1] + t;\n\t\tdp[i] = min(dp[i], 2 * a[i] + mini);\n\t}\n\tcout << e + dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nint p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<int>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tmemset(dp,63,sizeof dp);\n\tdp[0]=0;\n\tint now=0;\n\tll Min;\n\tFor(i,1,n)\n\t{\n\t\t//dp[i]=dp[i-1]+T;\t\n\t\tMin=inf;\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tif(now<i)cmin(dp[i],dp[now]+T);\n\t\tcmin(dp[i],Min+2*p[i]);\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nll A[MAX_N],DP[MAX_N];\n\nll n,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T+len;\n}\n\nll g(int idx){\n  ll& x = DP[idx];\n  if(x >= 0) return x;\n  \n  for(int i=idx+1;i<=n;i++){\n    ll val = g(i) + f(A[i-1]-A[idx]);\n    if(x == -1 || val < x) x = val;\n  }\n  \n  return x;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n >> E >> T;\n  \n  if(n > 2030) return 0;\n  \n  for(int i=0;i<n;i++) cin >> A[i];\n  \n  for(int i=0;i<n;i++) DP[i] = -1;\n  \n  cout << E+g(0) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define int ll\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing vi=vector<int>;\n#define PB push_back\n#define ALL(x) x.begin()\nusing pi=pair<int,int>;\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\nint const inf=LLONG_MAX/3;\nvoid chmin(int&a,int b){a=a<b?a:b;}\nvoid chmax(int&a,int b){a=a>b?a:b;}\n\nsigned main(){\n\tint n=read(),e=read(),t=read();\n\tvi x{0};\n\tREP(i,n)x.PB(read());\n\tn++;\n\tvi dp(n,inf);\n\tpriority_queue<pi,vector<pi>,greater<pi>> pq;\n\tpq.push(pi(0,0));\n\tint j=0;\n\tREP(i,n){\n\t\tint w;\n\t\twhile(1){\n\t\t\tpi r=pq.top();\n\t\t\tif(i<=r.second){\n\t\t\t\tw=min(r.first,dp[i]);\n\t\t\t\tbreak;\n\t\t\t}else\n\t\t\t\tpq.pop();\n\t\t}\n\t\tif(i==n-1){\n\t\t\tcout<<w+e<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tchmin(dp[i+1],dp[i]+(x[i+1]-x[i])*2);\n\t\twhile(j<n&&(x[j]-x[i+1])*2<=t)j++;\n\t\tpq.push(pi(w+t,j-1));\n\t\tif(j<n)chmin(dp[j],w+(x[j]-x[i+1])*2);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nclass starry_sky_tree{\npublic:\n  static const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n  using Int = long long;\n  Int segMin[2 * MAX_SIZE - 1], segAdd[2 * MAX_SIZE - 1];\n\n  starry_sky_tree(){\n    fill(segMin, segMin + 2*MAX_SIZE-1, 0);\n    fill(segAdd, segAdd + 2*MAX_SIZE-1, 0);\n  }\n\n  //区間[a, b)に値xを加算する.\n  void add(int a, int b, Int x, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return; //もし交差しない区間であれば終える.\n    \n    if (a <= l && r <= b){ //もし今みている区間[l, r)が[a, b)に完全に内包されていれば\n      segAdd[k] += x;  //区間[l, r)にkを加算する.\n      return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子の区間に(必要があれば)xを加算する.\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃\n\n    //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である.一様に加算される値は更新しなくて良い.\n    segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n  }\n\n  Int getMin(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return (1ll<<57);\n    \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]); //完全に内包されていれば,その区間の最小値を返す.\n    \n    Int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2); //子の区間の最小値を求める.\n    Int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r); //子の区間の最小値を求める\n    \n    return (min(left, right) + segAdd[k]); //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である (大切なので2回書きました!!)\n    \n  }\n};\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  //cin >> x;\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  starry_sky_tree a, b;\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      j++;\n    }\n    if(j) dp[i+1] = min(dp[i+1], a.getMin(0, j));\n    dp[i+1] = min(dp[i+1], t+ b.getMin(j, i+1));\n\n    a.add(0,i+1, 2*(x[i+1]-x[i]));\n    a.add(i+1, i+2, dp[i+1]);\n    \n    b.add(i+1, i+2, dp[i+1]);\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, T, u, v, x, y, t, a, b, ans;\nll A[MAXN], dp[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tcin>>A[n+1]>>T;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tfor (int i=n; i; i--){\n\t\tdp[i]=INF;\n\t\tfor (int j=i; j<=n; j++){\n\t\t\tll len=2*(A[j]-A[i]);\n\t\t\tll cost=(A[j+1]-A[i])+max(len, T);\n\t\t\tdp[i]=min(dp[i], cost+dp[j+1]);\n\t\t}\n//\t\tdebug2(i, dp[i])\n\t}\n\tcout<<A[1]+dp[1]<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst ll oo = 1e18;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint N, E;\nll a[MAXN], dp[MAXN], T;\n\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"inp.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i=0; i<N; i++) scanf(\"%d\", &a[i]);\n\t\n\tfor (int i=0; i<N; i++) dp[i] = oo;\n\tdp[0] = T + a[0];\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<=i; j++) {\n\t\t\tll dis = (a[i] - a[j]) * 2;\n\t\t\tll wait = max(0ll, T - dis);\n\t\t\tll cur = dis / 2 * 3 + wait + a[j] - (j != 0 ? a[j-1] : 0);\n\t\t\tif (j) cur += dp[j-1];\n\t\t\tdp[i] = min(cur, dp[i]);\n\t\t}\n\t}\n\t\n\tcout << (E - a[N - 1]) + dp[N - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <deque>\n#include <stack>\nusing namespace std;\n\nlong long dp[200005];\nlong long x[200005];\ndeque<int> dq;\n\nbool stack_better(int j1, int j2) {\n    return dp[j1] - x[j1] + 2LL * x[j1 + 1] < dp[j2] - x[j2] + 2LL * x[j2 + 1];\n}\n\nbool deque_better(int i, int j) {\n    return dp[i] - x[i] < dp[j] - x[j];\n}\n\nint main() {\n    //ifstream cin(\"f.in\");\n    int n, j = -1, bst = -1; long long t, e;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++ i) {\n        cin >> x[i];\n    }\n    dp[0] = 0;\n    dq.push_back(0);\n    for (int i = 1; i <= n; ++ i) {\n        while (j + 1 < i && 2LL * (x[i] - x[j + 2]) >= t) {\n            j += 1;\n            if (bst == -1 || stack_better(j, bst)) {\n                bst = j;\n            }\n        }\n        while (!dq.empty() && 2LL * (x[i] - x[dq.front() + 1]) >= t) {\n            dq.pop_front();\n        }\n        dp[i] = 1LL << 60;\n        if (!dq.empty()) {\n            dp[i] = min(dp[i], dp[dq.front()] - x[dq.front()] + x[i] + t);\n        }\n        if (j >= 0) {\n            dp[i] = min(dp[i], dp[bst] - (x[bst] + 2LL * x[bst + 1]) + 3LL * x[i]);\n        }\n        while (!dq.empty() && deque_better(i, dq.back())) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n    }\n    cout << dp[n] + (e - x[n]) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 1e5 + 10;\nint N; ll E, T;\nll A[MAXN];\n\nnamespace Subtask1 {\n\tll f[MAXN];\n\tinline int main() {\n\t\tregister int i, j;\n\t\tfor(i = 1; i <= N; ++i)\n\t\t\tfor(f[i] = 1e18, j = 0; j < i; ++j)\n\t\t\t\tf[i] = min(f[i], f[j] + A[i] - A[j] + max(T, 2 * (A[i] - A[j + 1])));\n\t\tprintf(\"%lld\\n\", f[N] + abs(A[N] - E));\n\t\treturn 0;\n\t}\n}\n\nnamespace Subtask2 {\n\tll q[MAXN], ql = 1, qr = 1;\n\tll f[MAXN], res = 1e18;\n\tinline int main() {\n\t\tregister int i, j = 0;\n\t\tfor(i = 1; i <= N; ++i) {\n\t\t\twhile(ql <= qr && 2 * (A[i] - A[(j = q[ql]) + 1]) > T) res = min(res, f[j] - A[j] - 2 * A[j + 1]), ++ql;\n\t\t\tj = q[ql]; f[i] = min(A[i] + 2 * A[i] + res, f[j] + A[i] - A[j] + T);\n\t\t\twhile(j = q[qr], ql <= qr && f[j] - A[j] >= f[i] - A[i]) --qr;\n\t\t\tq[++qr] = i;\n\t\t}\n\t\tprintf(\"%lld\\n\", f[N] + abs(A[N] - E));\n\t\treturn 0;\n\t}\n}\n\nint main() {\n\tregister int i;\n\tscanf(\"%d%lld%lld\", &N, &E, &T);\n\tfor(i = 1; i <= N; ++i)\n\t\tscanf(\"%lld\", A + i);\n\tif(N <= 10000) return Subtask1::main();\n\tSubtask2::main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 10000000000000000;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    ll ans = e;\n    vector<ll> dp(n + 1, INF);\n    dp[0] = 0;\n    vector<ll> dp2(n + 1, INF);\n    for (int i = 1; i <= n; i++) {\n        dp2[i] = min(dp2[i - 1], dp[i - 1] - x[i - 1] * 2);\n        int j = upper_bound(x.begin(), x.begin() + i, x[i - 1] - t / 2) - x.begin();\n        dp[i] = min(dp[j] + t, 2 * x[i - 1] + dp2[j]);\n    }\n    ans += dp[n];                    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    vector<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = (T + 1) + 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (pval <= cval) {\n                time = -LINF;\n                break;\n            }\n            int64_t prevSteady = (T + 1) + 2 * X[p + 1];\n            int64_t xcval = 2 * (dp[j] + X[j + 1] - X[j]) +\n                    3LL * (currSteady - 2 * X[j + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[j + 1]));\n            int64_t xpval = 2 * (dp[p] + X[p + 1] - X[p]) +\n                    3LL * (currSteady - 2 * X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[p + 1]));\n            if (xcval < xpval) {\n                time = LINF;\n                break;\n            }\n            time = currSteady - (xcval - xpval);\n            if (time < prevSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (2 * X[i] >= d.back().second) {\n            d.pop_back();\n        }\n        int p = d.back().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto&\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\nlint x[100020];\n\nlint dp[2020];\n\nlint brute() {\n    rep(i, n + 1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            lint d = x[j] - x[i + 1];\n            if (2 * d >= t) {\n                chmin(dp[j], dp[i] + (x[i + 1] - x[i]) + 3 * d);\n            } else {\n                chmin(dp[j], dp[i] + (x[i + 1] - x[i]) + t + d);\n            }\n        }\n    }\n    return dp[n] + (e - x[n]);\n}\n\nint main() {\n    cin >> n >> e >> t;\n    rep(i, n) cin >> x[i + 1];\n\n    if (n > 2020) exit(1);\n\n    cout << brute() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,0,n)cin>>x[i];\n    int v=0;\n    while(v<n&&x[v]-x[0]+1<(t+1)/2)v++;\n    if(v==n)\n    {\n    \tcout<<t+e;\n    \texit(0);\n    }\n    int g=0;\n    if(v!=0)up(1,0,n,0,-2*x[0]);\n    rep(i,v,n)\n    {\n        while(x[i]-x[g]>=(t+1)/2)g++;\n        g--;\n    \tdp[i]=2*x[i]+query(1,0,n,0,g+1);\n    \tup(1,0,n,i,dp[i-1]-2*x[i]);\n    \tif(g>=v)dp[i]=min(dp[i],dp[g]+t);\n    \telse if(g==-1)\n        {\n            dp[i]=min(dp[i],t);g=0;\n        }\n        else dp[i]=min(dp[i],2*t);\n    }\n    cout<<dp[n-1]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j > 0){\n            tmp1 = sgt2.query(0, min(j, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nclass segtree{\npublic:\n\tint n;vector<T> dat;T ZERO;\n\n\tsegtree(int n_,T zero):ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, int a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = function(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tT function(T a,T b){\n\t\treturn min(a, b);\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = function(L,dat[A++]);\n            if((B & 1) == 0)R = function(R,dat[--B]);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn function(L,R);\n\t}\n};\n\n\nint main(){\n\n\tll n,e,t;cin >> n >> e >> t;\n\n\tvector<ll> v(n+10);\n\tvector<ll> x(n+10);\n\tvector<ll> sum_x(n+10);\n\tREP(i,n){\n\t\tcin >> v[i+1];\n\t\tx[i+1] = v[i+1] - v[i];\n\t\tsum_x[i+1] = x[i+1];\n\t}\n\tREP(i,n)sum_x[i+1] += sum_x[i];\n\n\tsegtree<ll> sg1(n+10, LLINF);\n\tsg1.update(1, x[1]-3*sum_x[1]);\n\tsegtree<ll> sg2(n+10, LLINF);\n\tsg2.update(1, x[1]-sum_x[1]);\n\tll seica = 1;\n\tll ans;\n\n\tfor(int i = 2;i <= n+1;i++){\n\t\t//REP(j,n+3)cout << sg1.get(j) << \" \";cout << endl;\n\t\t//REP(j,n+3)cout << sg2.get(j) << \" \";cout << endl;\n\t\twhile(seica < i-1 && t - 2 * (sum_x[i-1] - sum_x[seica]) <= 0)seica++;\n\t\tll A = 3 * sum_x[i-1] + sg1.que(1,seica);\n\t\tll B = t + sum_x[i-1] + sg2.que(seica,i);\n\n\t\tll now = min(A , B);\n\t\tif(i != n+1){\n\t\t\tsg1.update(i, now+x[i]-3*sum_x[i]);\n\t\t\tsg2.update(i, now+x[i]-sum_x[i]);\n\t\t}\n\t\telse {\n\t\t\tans = now;\n\t\t}\n\t\t//cout << \"          \" << i << \" \" << seica << \" \" << A << \" \" << B << endl;\n\t}\n\n\tcout << ans + e - v[n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 1e5+1;\n\nll N, E, T, A, B = 1e18, x[MN], DP[MN];\n\nint main() {\n\tif (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> N >> E >> T;\n\tfor (int i = 0; i < N; ++i) cin >> x[i];\n\n\tmultiset<ll> S;\n\tS.insert(0);\n\tfor (int i = 0, j = 0; i < N; ++i) {\n\t\twhile (2*(x[i]-x[j]) >= T) {\n\t\t\tB = min(DP[j]-2*x[j], B);\n\t\t\tS.erase(S.find(DP[j]));\n\t\t\t++j;\n\t\t}\n\t\tDP[i+1] = min(A+(i+1)*T, B+2*x[i]);\n\t\tif (S.size()) DP[i+1] = min(*begin(S)+T, DP[i+1]);\n\t\tA = min(DP[i+1]-(i+1)*T, A);\n\t\tS.insert(DP[i+1]);\n\t}\n\tcout << DP[N]+E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\n#define LL long long\nint st1[MAXN],st2[MAXN],r,l,r2;\nLL dp[MAXN],a[MAXN],T;\nint n,m;\nint main()\n{\n//\tfreopen(\"computer.in\",\"r\",stdin);\n//\tfreopen(\"computer.out\",\"w\",stdout);\n\tscanf(\"%d%d%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tdp[1]=T;\n\tint j=1;\n\tst2[r2++]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile((a[i]-a[j])*2>=T)\n\t\t{\n\t\t\twhile(r)\n\t\t\t{\n\t\t\t\tint k=st1[r-1];\n\t\t\t\tif(dp[k-1]-a[k]*2>=dp[j-1]-a[j]*2)\n\t\t\t\t\tr--;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tst1[r++]=j;\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=dp[st1[0]-1]+2*(a[i]-a[st1[0]]);\n\t\twhile(l<r2&&dp[i-1]<=dp[st2[r2-1]-1])\n\t\t\tr2--;\n\t\tst2[r2++]=i;\n\t\twhile(st2[l]<j) l++;\n\t\tdp[i]=min(dp[i],dp[st2[l]-1]+T);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tfor(int A=1;A<=N+100;A++)\n\t\tdp[A]=-1;\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]);\n\t\t\t//cout<<A<<\" \"<<B<<\" \"<<pre[A][B]<<\"\\n\";\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std; \nlong long x[100008],dp[100008];long long t,e;\nvoid update(long long i,long long j)\n{\n\tdp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n}\nint main()\n{\n\tlong long n;cin>>n;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i];for(long long i=0;i<100005;i++) dp[i]=2e9;x[n+1]=2e9;\n\tdp[0]=0;long long j=0;long long mst=2e9,msi=0;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tupdate(i,i-1);\n\t\twhile((x[i]-x[j+1])*2>t and j<i-1)\n\t\t{\n\t\t\tj++;long long tt=dp[j]+2*(x[n+1]-x[j+1]);\n\t\t\tif(tt<mst) mst=tt,msi=j;\n\t\t}\n\t\tupdate(i,j);update(i,max(j-1,(long long)0));update(i,j+1);\n\t\tupdate(i,msi);\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \ntypedef pair<int,int> pii; \n\nconst int maxN = 1000 * 100 + 10; \nll a[maxN]; \nconst ll inf = 1e18; \nll dp[maxN]; \nset<pair<ll,int>> curr1, curr2; \n\nint main() { \n\tios::sync_with_stdio(false); cin.tie(0); \n\ta[0] = 0; \n\tint n,e,T; cin >> n >> e >> T;\n\tfor( int i = 0 ; i < n ; i++ ) cin >> a[i+1]; \n\n\tcurr1.insert( { inf , -1 } ) ; \n\tcurr2.insert( { inf , -1 } ) ; \n\tfill( dp , dp + n + 1 , inf ) ; \n\tdp[0] = 0; \n\tint last = 0; \n\tcurr1.insert( { 0ll - a[1] , 0 } ); \n\tfor( int i = 1 ; i <= n ; i++ ) { \n\t\twhile( last < i && 2ll * (a[i] - a[last+1]) >= T ) { \n\t\t\tcurr1.erase( { 0ll + dp[last] - a[last+1] , last } ) ; \n\t\t\tcurr2.insert( { 0ll + dp[last] - 2ll * a[last+1] , last } ); \n\t\t\tlast++; \n\t\t}\n\t\tdp[i] = min( 0ll + curr1.begin()->first + 1ll * a[i] + T , \n\t\t\t\t0ll + curr2.begin()->first + 2ll * a[i] ); \n\t\tcurr1.insert( { dp[i] - a[i+1] , i } ); \n\t}\n\tcout << dp[n] + e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll x[111111];\nll dp[111111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll lmin=ll(1e18); \n\tdeque<pair<ll,ll> > rmin;\n\tint n; cin>>n; ll e,t; cin>>e>>t;\n\tx[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t}\n\tint ptr=1;\n\trmin.pb(mp(dp[0]-x[0]+t,1));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ptr<=i&&x[i]>=t/2+x[ptr]+1) //this means that we need to remove ptr from the \"T - 2(x_i - x_{j+1})\" is large part\n\t\t{\n\t\t\tif(!rmin.empty()&&rmin.front().se==ptr) rmin.pop_front();\n\t\t\tlmin = min(lmin, dp[ptr-1]-2*x[ptr]-x[ptr-1]);\n\t\t\tptr++;\n\t\t}\n\t\tll best=lmin;\n\t\tif(!rmin.empty()) best=min(best,-2*x[i]+rmin.front().fi);\n\t\tdp[i]=best+3LL*x[i];\n\t\tll cost = dp[i]-x[i]+t;\n\t\twhile(!rmin.empty()&&rmin.back().fi>=cost) rmin.pop_back();\n\t\trmin.pb(mp(cost,i+1));\n\t}\n\tcout<<dp[n]+e-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nclass seg{\n\tvl S,D;\npublic:\n\tseg(int n):S(1<<MSB(n-1)+2,e18),D(1<<MSB(n-1)+2,0ll){}\n\tvoid eval(int k,int l,int r){\n\t\tS[k]+=D[k];\n\t\tif(r-l>1){\n\t\t\tD[k<<1  ]+=D[k];\n\t\t\tD[k<<1|1]+=D[k];\n\t\t}\n\t\tD[k]=0;\n\t}\n\tvoid add(int a,int b,ll x,int k=1,int l=0,int r=-1){\n\t\tif(r<0)r=S.size()>>1;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\tif(a<=l&&r<=b){\n\t\t\tD[k]+=x;\n\t\t\teval(k,l,r);\n\t\t}else{\n\t\t\tadd(a,b,x,k<<1  ,l,l+r>>1);\n\t\t\tadd(a,b,x,k<<1|1,l+r>>1,r);\n\t\t\tS[k]=std::min(S[k<<1],S[k<<1|1]);\n\t\t}\n\t}\n\tll min(int a,int b,int k=1,int l=0,int r=-1){\n\t\tif(r<0)r=S.size()>>1;\n\t\tif(b<=l||r<=a)return e18;\n\t\teval(k,l,r);\n\t\tif(a<=l&&r<=b)return S[k];\n\t\tll L=min(a,b,k<<1  ,l,l+r>>1);\n\t\tll R=min(a,b,k<<1|1,l+r>>1,r);\n\t\treturn std::min(L,R);\n\t}\n};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tll d=0;\n\tseg s(N+1);\n\ts.add(0,N+1,-e18);\n\ts.add(0,1,T);\n\tint k=0;\n\tfoor(i,1,N){\n\t\ts.add(0,k,2*(x[i]-x[i-1]));\n\t\tfor(;2*(x[i]-x[k+1])>T;++k){\n\t\t\ts.add(k,k+1,2*(x[i]-x[k+1])-T);\n\t\t}\n\t\td=s.min(0,i);\n\t\ts.add(i,i+1,d+T);\n\t}\n\tprint(d+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\nconst int N=1e5+50 ; \nconst ll oo=1e18; \n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nint n;\nll T,E,x[N],f[N]; \n\nint main(int argc,char *argv[]){\n#ifdef GCURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tread(n),read(E),read(T); \n\trep(i,1,n)read(x[i]);\n\trep(i,1,n){\n\t\tf[i]=oo;\n\t\tlop(j,0,i)cmin(f[i],f[j]+max(T,2*(x[i]-x[j+1])));\n\t}\n\tprintf(\"%lld\\n\",f[n]+E); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n *\n */\n#include <cstdio>\n#include <iostream>\n\n#define INF 100000000000000000LL\n\nusing namespace std;\ntypedef long long ll;\n\nll x[100005];\nll dp[100005];  // dp[i]: minimum time until the exit\n                 // after you get coin at i-th place and you haven't feed to the rest yet.\n\nint main(){\n    //freopen(\"d3.in\", \"r\", stdin);\n    int N, E, T;\n    scanf(\"%d %d %d\", &N, &E, &T);\n    x[0] = 0;\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%lli\", &x[i]);\n    }\n    dp[N] = E - x[N];\n    cout << \"N = \" << N << \", dp[N]= \" << dp[N] << endl;\n    for (int i = N - 1; i >= 0; --i) {\n        dp[i] = INF;\n        for (int j = i + 1; j <= N; ++j) {\n            if ((2 * (x[j] - x[i+1])) > T) {\n                dp[i] = min(dp[i], dp[j] + 3 * (x[j] - x[i+1]) + (x[i+1] - x[i]));\n            } else {\n                dp[i] = min(dp[i], dp[j] + (x[j] - x[i+1]) + T + (x[i+1] - x[i]));\n            }\n        }\n        cout << \"i = \" << i << \", dp[i]= \" << dp[i] << endl;\n    }\n\n    printf(\"%lli\\n\", dp[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,E,T;\nint X[202020];\nll memo[2200][2200];\n\nll dpdp(int yet,int cur) {\n\t\n\tif(memo[yet][cur]>=0) return memo[yet][cur];\n\tll ret=0;\n\t\n\tif(cur==N-1) {\n\t\tret = max(T-(X[cur]-X[yet]),(X[cur]-X[yet])) + (X[cur]-X[yet]);\n\t}\n\telse {\n\t\tret = max(T-(X[cur]-X[yet]),(X[cur]-X[yet])) + X[cur+1]-X[yet]+dpdp(cur+1,cur+1);\n\t\tret = min(ret, X[cur+1]-X[cur]+dpdp(yet,cur+1));\n\t}\n\t\n\treturn memo[yet][cur]=ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>E>>T;\n\tFOR(i,N) cin>>X[i];\n\t\n\tll ret= X[0] + (E-X[N-1]);\n\tx = X[0];\n\tFOR(i,N) X[i]-=x;\n\t\n\tif(N>2000) return;\n\t\n\tMINUS(memo);\n\tcout<<ret + dpdp(0,0)<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Nmaxim 100000\nusing namespace std;\n\nint minim[Nmaxim], maxim[Nmaxim];\nlong long c[Nmaxim], dp[Nmaxim];\nint n;\nlong long e, t;\n\nlong long mxm(long long a, long long b);\n\nint main()\n{\n\tcin >> n >> e >> t;\n\tint prec = -1e9, m = 0, cit;\n\n\twhile (n--) {\n\t\tcin >> cit;\n\t\tif (cit - prec > t) {\n\t\t\tm++;\n\t\t\tminim[m] = cit;\n\t\t}\n\t\tmaxim[m] = cit;\n\t\tprec = cit;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t\tc[i] = mxm(2ll * (maxim[i] - minim[i]), t) + maxim[i] - minim[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[i] = dp[i - 1] + c[i] + 1ll * (minim[i] - maxim[i - 1]);\n\n\tcout << (long long) dp[m] + e - maxim[m];\n\n\treturn 0;\n}\n\nlong long mxm(long long a, long long b)\n{\n\tif (a > b)\n\t\treturn a;\n\treturn b;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst long long maxn = 100010; const ll inf = 1LL<<60;\nlong long N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline long long gi()\n{\n\tchar ch; long long ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(long long now,long long l,long long r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tlong long mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,long long now,long long l,long long r,long long pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tlong long mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,long long now,long long l,long long r,long long ql,long long qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tlong long mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (long long i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (long long i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tlong long l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (long long j = r+1;j <= r+15&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nconst int N = 1e5 + 5;\nconst ll INF = 1e14;\n\nint n, E, T, x[N];\nll dp[N];\n\nll val[4 * N], lazy[4 * N];\nvoid refresh(int pos, int low, int high)\n{\n    if(!lazy[pos])\n        return;\n\n    val[pos] += lazy[pos];\n    if(low < high)\n    {\n        lazy[pos * 2] += lazy[pos];\n        lazy[pos * 2 + 1] += lazy[pos];\n    }\n    lazy[pos] = 0;\n}\n\nvoid add_interval(int pos, int low, int high, int l, int r, ll d)\n{\n    refresh(pos, low, high);\n    if(l > high || r < low)\n        return;\n    if(l <= low && r >= high)\n    {\n        lazy[pos] += d;\n        refresh(pos, low, high);\n        return;\n    }\n\n    int mid = (low + high) / 2;\n    add_interval(pos * 2, low, mid, l, r, d);\n    add_interval(pos * 2 + 1, mid + 1, high, l, r, d);\n\n    val[pos] = min(val[pos * 2], val[pos * 2 + 1]);\n}\n\nvoid upd_at(int pos, int low, int high, int id, ll x)\n{\n    refresh(pos, low, high);\n    if(low == high)\n    {\n        val[pos] = x;\n        return;\n    }\n\n    int mid = (low + high) / 2;\n    if(id <= mid)\n        upd_at(pos * 2, low, mid, id, x);\n    else\n        upd_at(pos * 2 + 1, mid + 1, high, id, x);\n\n    val[pos] = min(val[pos * 2], val[pos * 2 + 1]);\n}\n\nll query(int pos, int low, int high, int l, int r)\n{\n    refresh(pos, low, high);\n    if(l > high || r < low)\n        return INF;\n    if(l <= low && r >= high)\n        return val[pos];\n\n    int mid = (low + high) / 2;\n    return min(query(pos * 2, low, mid, l, r), query(pos * 2 + 1, mid + 1, high, l, r));\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n\n    cin >> n >> E >> T;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    upd_at(1, 0, n, 0, T);\n    for(int i = 1; i <= n; i++)\n        upd_at(1, 0, n, i, INF);\n\n\n    int leftmost_waiting = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        if(leftmost_waiting < i)\n            add_interval(1, 0, n, leftmost_waiting, i - 1, 2LL * (x[i - 1] - x[i]));\n\n        while(leftmost_waiting < i)\n        {\n            if((ll)T + 2LL * x[leftmost_waiting + 1] - 2LL * x[i] <= 0)\n            {\n                ll current_val = query(1, 0, n, leftmost_waiting, leftmost_waiting);\n                current_val -= (ll)T + 2LL * x[leftmost_waiting + 1] - 2LL * x[i];\n                upd_at(1, 0, n, leftmost_waiting, current_val);\n\n                leftmost_waiting++;\n            }\n            else\n                break;\n        }\n\n\n        dp[i] = query(1, 0, n, 0, i - 1) + 3LL * x[i];\n        ll optimizing = dp[i] - (2LL * x[i + 1] + x[i]) + T + 2LL * (x[i + 1] - x[i]);\n        upd_at(1, 0, n, i, optimizing);\n    }\n\n\n    cout << dp[n] + E - x[n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nint main(){\n\tll n,e,t;\n\tcin>>n>>e>>t;\n\tvi in(n+1);\n\trep(i,n)cin>>in[i+1];\n\tvi dp(n+1,inf);\n\tdp[0]=0;\n\trep(i,n)rep(j,i+1){\n\t\tll sum=dp[j]+in[j+1]-in[j];\n\t\tsum+=max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];\n\t\tdp[i+1]=min<ll>(dp[i+1],sum);\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=100009;\nconst ll Inf=1e18;\n\nint n,t,e;\nint x[N];\nll f[N],smn,ff[N];\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\ninline void chkmin(ll &a,ll b){if(a>b)a=b;}\n\nint main()\n{\n\tn=read();\n\te=read();\n\tt=read();\n\tfor(int i=1;i<=n;i++)\n\t\tx[i]=read();\n\n\tf[0]=0;\n\tff[0]=-2*x[1];\n\tint ptr=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(2ll*(x[i]-x[ptr+1])>t)ptr++;\n\t\tf[i]=f[ptr]+t;\n\t\tif(ptr)chkmin(f[i],2*x[i]+ff[ptr-1]);\n\t\tff[i]=min(f[i]-2*x[i+1],ff[i-1]);\n\t}\n\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int MAXN = 100010;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\nint at[MAXN], T, n, E;\nLL f[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> E >> T;\n\tint cur = 0; LL pre = INF;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> at[i];\n\t\twhile (2 * (at[i] - at[cur + 1]) >= T)\n\t\t\tpre = std::min(pre, f[cur] - 2 * at[cur + 1]), ++cur;\n\t\tf[i] = std::min(pre + 2 * at[i], f[cur] + T);\n\t}\n\tstd::cout << f[n] + E << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nLL n , e , t , x[ N ];\nvoid init(){\n  n = getint();\n  e = getint();\n  t = getint();\n  for( int i = 1 ; i <= n ; i ++ )\n    x[ i ] = getint();\n  x[ n + 1 ] = e;\n}\nLL dp[ N ];\nmultiset< LL > S;\nvoid solve(){\n  LL bst = INF16;\n  queue< int > Q;\n  dp[ 0 ] = 0;\n  Q.push( 0 );\n  S.insert( t );\n  for( int i = 1 ; i <= n ; i ++ ){\n    while( Q.size() ){\n      int j = Q.front();\n      if( x[ i ] + x[ i ] - x[ j ] - x[ j + 1 ] >= x[ j + 1 ] - x[ j ] + t ){\n        S.erase( S.find( dp[ j ] - x[ j ] + t ) );\n        bst = min( bst , dp[ j ] - x[ j ] - x[ j + 1 ] - x[ j + 1 ] );\n        Q.pop();\n      }else break;\n    }\n    dp[ i ] = bst + x[ i ] + x[ i ] + x[ i ];\n    if( S.size() )\n      dp[ i ] = min( dp[ i ] , (*S.begin()) + x[ i ] );\n    Q.push( i );\n    S.insert( dp[ i ] - x[ i ] + t );\n  }\n  printf( \"%lld\\n\" , dp[ n ] + e - x[ n ] );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nconst ll INFLL = 0x3f3f3f3f3f3f3f3fLL;\nconst int MAXN = 2010;\nusing namespace std;\n\nint N, T, E, X[MAXN];\nll dp[MAXN];\n\nint main() {\n\tint i, j;\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(i = 1; i <= N; i++) scanf(\"%d\", &X[i]);\n\tfor(i = 1; i <= N; i++) {\n\t\tdp[i] = INFLL;\n\t\tfor(j = 0; j < i; j++) {\n\t\t\tll nxt = dp[j] + (X[j + 1] - X[j]) + max(T, 2 * (X[i] - X[j + 1])) + (X[i] - X[j + 1]);\n\t\t\tif(nxt < dp[i]) dp[i] = nxt;\n\t\t}\n\t}\n\n\tprintf(\"%lld\", dp[N] + (E - X[N]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint x[MAXN];\nlong long int f(int p1, int p2, int t)\n{\n\tlong long int t1 = x[p2] - x[p1];\n\tif(2*t1 > t)\n\t\treturn 3*t1;\n\treturn 3*t1 + (t - 2*t1);\n}\nint main()\n{\n\tint n,e,t;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tlong long int ans = x[1];\n\tint lp = 1;\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\tif(x[i] - x[i-1] > t)\n\t\t{\n\t\t\tans+=f(lp,i-1,t);\n\t\t\tans+=(x[i] - x[i-1]);\n\t\t\tlp = i;\n\t\t}\n\t}\n\tans+=f(lp,n,t);\n\tans+=(e - x[n]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100005\n#define cmax(_i,_j) ((_i)<(_j)?(_i)=(_j):0)\n#define cmin(_i,_j) ((_i)>(_j)?(_i)=(_j):0)\nusing namespace std;\nnamespace runzhe2000\n{\n\ttypedef long long ll;\n\tint q[N], head, tail; ll f[N], x[N];\n\tvoid main()\n\t{\n\t\tint n, E, T; scanf(\"%d%d%d\",&n,&E,&T);\n\t\tfor(int i = 1; i <= n; i++) scanf(\"%lld\",&x[i]); sort(x+1,x+1+n);\n\t\t\n\t\tll pre = 1ll<<60; int cur = 1; head = 1;\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(; 3*(x[i]-x[cur]) >= T; cur++)\n\t\t\t{\n\t\t\t\tcmin(pre,f[cur-1]-2*x[cur]);\n\t\t\t\tif(head <= tail && q[head] == cur) head++;\n\t\t\t}\n\t\t\tfor(; head <= tail && f[q[tail]-1]-x[q[tail]] >= f[i-1]-x[i]; --tail);\n\t\t\tq[++tail] = i;\n\t\t\t\n\t\t\tf[i] = pre + 2 * x[i];\n\t\t\tif(head <= tail) cmin(f[i], f[q[head]-1]-x[q[head]]+x[i]+T);\n\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]+E);\n\t}\n}\nint main()\n{\n\trunzhe2000::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\nlong long dp[2005];\nlong long x[2005];\n\nint main() {\n    //ifstream cin(\"f.in\");\n    int n; long long t, e;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++ i) {\n        cin >> x[i];\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= n; ++ i) {\n        dp[i] = 1LL << 60;\n        for (int j = 1; j <= i; ++ j) {\n            /// j = last batch\n            long long extra = x[i] - x[i - j];\n            extra += (x[i] - x[i - j + 1]);\n            extra += max(0LL, (t - (extra - (x[i - j + 1] - x[i - j]))));\n            extra += (x[i] - x[i - j + 1]);\n            dp[i] = min(dp[i], dp[i - j] + extra);\n        }\n    }\n    cout << dp[n] + (e - x[n]) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\n#define INF 100000000000000LL\nll dp[2005];\n\nint main(){\n  ios::sync_with_stdio(false);\n  ll N, E, T;\n  cin >> N >> E >> T;\n  vector<ll> x;\n  rep(i,N){\n    ll a;\n    cin >> a;\n    x.push_back(a);\n  }\n  x.push_back(E);\n  rep(i,2005) dp[i] = INF;\n\n  if(N>2000){\n    cout << 0 << endl;\n    return 0;\n  }\n  \n  dp[0] = 0;\n  rep(i,N){\n    rep(j,N){\n      if(i+j<N){\n        ll dx = x[i+j+1]-x[i];\n        ll dy = x[i+j]-x[i];\n        ll y = max(2*dy, T);\n        dp[i+j+1] = min(dp[i+j+1], dp[i] + y + dx);\n      }\n    }\n  }\n\n  cout << x[0] + dp[N] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e15;\nll n, T, E, x[MAXN], dp[MAXN], seg[4 * MAXN], lazy[4 * MAXN];\nvoid upd(int node, int x)\n{\n\tseg[node] += x;\n\tlazy[node] += x;\n\treturn;\n}\nvoid shift(int node)\n{\n\tupd(node << 1, lazy[node]);\n\tupd(node << 1 | 1, lazy[node]);\n\tlazy[node] = 0;\n}\nvoid add(int node, int st, int en, int l, int r, int x)\n{\n\tif(l >= en || st >= r)\n\t\treturn;\n\tif(l <= st && en <= r)\n\t{\n\t\tupd(node, x);\n\t\treturn;\n\t}\n\tint mid = (st + en) >> 1;\n\tshift(node);\n\tadd(node << 1, st, mid, l, r, x);\n\tadd(node << 1 | 1, mid, en, l, r, x);\n\tseg[node] = min(seg[node << 1], seg[node << 1 | 1]);\n}\nll get(int node, int st, int en, int l, int r)\n{\n\tif(l >= en || st >= r)\n\t\treturn inf;\n\tif(l <= st && en <= r)\n\t\treturn seg[node];\n\tint mid = (st + en) >> 1;\n\tshift(node);\n\treturn min(get(node << 1, st, mid, l, r), get(node << 1 | 1, mid, en, l, r));\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tadd(1, 0, n + 1, i, i + 1, x[i + 1] + T);\n\t\n\tadd(1, 0, n + 1, 0, 1, -x[1]);\n\t\n\tint ptr = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tadd(1, 0, n + 1, 0, ptr, 2 * x[i] - 2 * x[i - 1]);\n\t\twhile(ptr < i && 2 * x[i] - x[ptr + 1] >= x[ptr + 1] + T)\n\t\t\tadd(1, 0, n + 1, ptr, ptr + 1, -x[ptr + 1] - T + 2 * x[i] - x[ptr + 1]), ptr++;\n\t\tdp[i] = get(1, 0, n + 1, 0, i) + x[i];\n\t\tadd(1, 0, n + 1, i, i + 1, dp[i] - x[i] - x[i + 1]);\n\t}\n\tcout << dp[n] + E - x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DINGER_GISBAR\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = static_cast<int>(1e9) + 7;\n//{{{TEMPLATE_BEGIN\n#include <unistd.h>\nusing namespace std::rel_ops;\n#ifdef ZEROKUGI\n#include <dumper.hpp>\n#define dump(x) dumper::dumper(cerr, __LINE__, (#x), (x), 50, 1, 1)\n#define tick(...) dumper::tick(__VA_ARGS__)\n#pragma message \"Compiling \" __FILE__\n#else\n#define dump(x)\n#define tick(...)\n#endif\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef long double ldouble;\ntypedef vector<int> vint;\n#define rep(i, n) \\\n    for (int i = 0, i##_len = static_cast<int>(n); i < i##_len; i++)\n#define all(c) begin(c), end(c)\n#define perm(c)   \\\n    sort(all(c)); \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(all(c)))\n#define uniquenize(v) (v).erase(unique(all(v)), end(v))\n#define cauto const auto&\n#define memset(x, y) memset(x, y, sizeof(x))\n#define popcount __builtin_popcount\n#define gcd __gcd\ninline lint bit(int x) { return 1LL << x; }\ntemplate <class T>\ninline int size(const T& a) {\n    return (int)a.size();\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline int clamp(T v, T lo, T hi) {\n    return (v > hi) - (v < lo);\n}\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline pair<vector<T>, char> operator*(const vector<T>& v, const char& c) {\n    return make_pair(v, c);\n}\ntemplate <class T>\ninline istream& operator>>(istream& is, vector<T>& v) {\n#ifdef ZEROKUGI\n    if (v.empty()) {\n        cerr << \"Error L\" << __LINE__ << \": vector size is zero.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n#endif\n    for (auto& x : v) is >> x;\n    return is;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, const pair<vector<T>, char>& v) {\n    bool t = 0;\n    for (const T& x : v.first) {\n        if (t) os << v.second;\n        os << x;\n        t = 1;\n    }\n    return os;\n}\ntemplate <class T>\ninline ostream& operator<<(ostream& os, vector<T>& v) {\n    return os << v * ' ';\n}\nstruct before_main {\n    before_main() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        tick(0, 0);\n    };\n} __before_main;\n//}}}TEMPLATE_END\n\nint n;\nlint e, t;\n\nlint dp[100010];\n\nlint brute() {}\n\nint main() {\n    cin >> n >> e >> t;\n\n    vector<lint> x(n + 1);\n    rep(i, n) cin >> x[i + 1];\n\n    // if (n > 2020) return 0;\n\n    rep(i, n + 1) dp[i] = 1145141919810893LL;\n\n    dp[0] = 0;\n\n    //(val, range)\n    typedef pair<lint, lint> pll;\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n\n    lint hogehoge = 0, fugafuga = dp[1];\n\n    for (int i = 0; i <= n; i++) {\n        while (!pq.empty()) {\n            auto p = pq.top();\n            pq.pop();\n            if (p.second <= i) continue;\n            chmin(dp[i], p.first + x[i]);\n            break;\n        }\n\n        chmin(dp[i], fugafuga + x[i] - x[hogehoge]);\n        int pos = (upper_bound(all(x), x[i + 1] + t / 2) - begin(x));\n        pq.push({dp[i] - x[i] + t, pos});\n\n        if(pos == n+1) continue;\n\n        if(chmin(dp[pos], dp[i] + (x[i + 1] - x[i]) + 3 * (x[pos] - x[i]))) {\n            hogehoge = i;\n            fugafuga = dp[i] + (x[i+1] - x[i]);\n        }\n    }\n    cout << dp[n] + (e - x[n]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll INF = 1e18;\n\ntemplate<typename T>\nstruct SegmentTree{\n    const T INF = 1e18;\n    int n, width;\n    vector<T> dat;\n\n    void init(int x){\n        n = x;\n        width = 1;\n        while (width < n) width *= 2;\n        dat.assign(2*width-1, INF);\n    }\n\n    void update(int i, T x){\n        i += width - 1;\n        dat[i] = x;\n        while (i > 0){\n            i = (i - 1) / 2;\n            dat[i] = min(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n\n    T query(int a, int b, int k, int l, int r){\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n\n    // [l, r)\n    T query(int l, int r){\n        return query(l, r, 0, 0, width);\n    }\n};\n\nint main() {\n    ll n, e, t;\n    cin >> n >> e >> t;\n    VL x(n + 1);\n    REP(i,n) x[i] = in();\n    VL dp(n + 1, INF);\n    dp[0] = 0;\n    SegmentTree<ll> seg1, seg2;\n    seg1.init(n + 1);\n    seg2.init(n + 1);\n    seg1.update(0, 0);\n    seg2.update(0, -2 * x[0]);\n    int i = 0;\n    REP(j,n){\n        while (2 * (x[j] - x[i]) > t) i++;\n        chmin(dp[j + 1], seg1.query(i, j + 1) + t);\n        chmin(dp[j + 1], seg2.query(0, i) + 2 * x[j]);\n        seg1.update(j + 1, dp[j + 1]);\n        seg2.update(j + 1, dp[j + 1] - 2 * x[j + 1]);\n    }\n    // REP(i,n+1) cout << dp[i] << endl;\n    ll ans = e + dp[n];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 111111\n#define M 444444\n#define LL long long\nusing namespace std;\nint n,E,T,i,k,j,a[N];LL f[N],V1[M],V2[M];\nvoid ins(int k,int l,int r,int x,LL z1,LL z2){\n\tif(l==r){V1[k]=z1;V2[k]=z2;return;}\n\tint md=l+r>>1;\n\tif(x<=md)ins(k<<1,l,md,x,z1,z2);else ins(k<<1|1,md+1,r,x,z1,z2);\n\tV1[k]=min(V1[k<<1],V1[k<<1|1]);\n\tV2[k]=min(V2[k<<1],V2[k<<1|1]);\n}\nLL qu1(int k,int l,int r,int x,int y){\n\tif(x>y)return 1e18;\n\tif(x<=l&&r<=y)return V1[k];\n\tint md=l+r>>1;\n\tif(y<=md)return qu1(k<<1,l,md,x,y);\n\tif(x>md)return qu1(k<<1|1,md+1,r,x,y);\n\treturn min(qu1(k<<1,l,md,x,y),qu1(k<<1|1,md+1,r,x,y));\n}\nLL qu2(int k,int l,int r,int x,int y){\n\tif(x>y)return 1e18;\n\tif(x<=l&&r<=y)return V2[k];\n\tint md=l+r>>1;\n\tif(y<=md)return qu2(k<<1,l,md,x,y);\n\tif(x>md)return qu2(k<<1|1,md+1,r,x,y);\n\treturn min(qu2(k<<1,l,md,x,y),qu2(k<<1|1,md+1,r,x,y));\n}\nint main(){\n\tfor(i=0;i<M;i++)V1[i]=V2[i]=1e18;\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(i=0,k=0;i<=n;i++){\n\t\tf[i]=1e18;\n\t\tfor(;(a[i]-a[k+1])*2>T&&k<i;k++);\n\t\t//f[i]=f[k]+max(a[i]-a[k+1]+a[i]-a[k+1],T)+a[i]-a[k];\n\t\t//j<=k a[i]-a[j+1*2>T\n\t\t//f[i]=qu2(1,0,0,k)\n\t//\tprintf(\"%d %d\\n\",(a[i]-a[k+1])*2,T);\n\t\tif(i==0)f[i]=0;else \n\t\tf[i]=min(qu1(1,0,n,k,i-1)+T+a[i],qu2(1,0,n,0,k-1)+a[i]*3);\n\t\t//printf(\"%d %d %d\\n\",i,k,f[i]);\n\t\t//printf(\"%lld %lld %d\\n\",qu1(1,0,n,k,i-1),qu2(1,0,n,0,k-1),T+a[i]);\n\t\t//puts(\"-----------------------\");\n\t\t\t//f[i]=min(f[i],f[j]+a[i]-a[j]+max((a[i]-a[j+1])*2,T));\n\t\t\n\t\tins(1,0,n,i,f[i]-a[i],f[i]-a[i]-a[i+1]*2);\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tll mini=inf;\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[i]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long maxn=(1ll<<63-1);\nlong long a[10001],dp[10001]={0};\nlong long n,e,t,k=0;\nint main()\n{\n\tmemset(dp,0x3f3f3f3f,sizeof(dp));\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n    {\n        while(t<=2*(a[i]-a[k+1]))\n        {\n            maxn=min(maxn,dp[k]-2*a[k+1]);\n            k++;\n        }\n        dp[i]=dp[k]+t;\n        dp[i]=min(dp[i],maxn+2*a[i]);\n    }\n    dp[n]+=e;\n    cout<<dp[n]<<endl;\n}#include<bits/stdc++.h>\nusing namespace std;\nlong long inf=(1ll<<63-1);\nlong long a[10005],dp[1005];    \nlong long n,e,t,maxn=inf;\nint main()\n{    \n\tmemset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    dp[0]=0;\n    int t=0;\n    for(int i=1;i<=n;i++)\n\t{\n        while(t<=2*(a[i]-a[t+1]))\n        {\n            maxn=min(maxn,dp[t]-2*a[t+1]);\n            t++;\n        }\n        dp[i]=dp[t]+t;\n        dp[i]=min(dp[i],maxn+2*a[i]);\n    }\n    dp[n]+=e;\n    cout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2015\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint N, E;\nll a[MAXN], dp[MAXN], T;\nset<pair<ll, ll> > s[2];\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tscanf(\"%d%d%lld\", &N, &E, &T);\n\tfor (int i=0; i<N; i++) scanf(\"%d\", &a[i]);\n\t\n\tfor (int i=0; i<N; i++) dp[i] = oo;\n\tint cur = 0;\n\tfor (int i=0; i<N; i++) {\n\t\twhile (cur <= i && (a[i] - a[cur]) * 2 >= T) {\n\t\t\tll now = T - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\t\n\t\t\tll nxt = -2 * a[cur] - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\tif (s[0].find(mp(now, cur)) != s[0].end()) {\n\t\t\t\ts[0].erase(mp(now, cur));\n\t\t\t\ts[1].insert(mp(nxt, cur));\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tdp[i] = a[i] - (i != 0 ? a[i-1] : 0) + (i != 0 ? dp[i-1] : 0) + T;\n\t\tif (!s[0].empty()) {\n\t\t\tll now = s[0].begin()->FI;\n\t\t\tdp[i] = min(dp[i], a[i] + now);\n\t\t}\n\t\tif (!s[1].empty()) {\n\t\t\tll now = s[1].begin()->FI;\n\t\t\tdp[i] = min(dp[i], 3 * a[i] + now);\t\t\t\n\t\t}\n\t\tll nxt = T - (i != 0 ? a[i - 1] : 0) + (i != 0 ? dp[i - 1] : 0);\n\t\ts[0].insert(mp(nxt, i));\n\t}\n\tcout << E - a[N - 1] + dp[N - 1];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int MAXN = 100010;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\nint at[MAXN], T, n, E, q[MAXN], b, e;\nLL f[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> E >> T;\n\tint cur = 0; LL pre = INF;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> at[i];\n\t\twhile (2 * (at[i] - at[cur + 1]) >= T) {\n\t\t\tpre = std::min(pre, f[cur] - 2 * at[cur + 1]);\n\t\t\t++cur;\n\t\t}\n\t\twhile (b <= e && at[q[b]] < cur) ++b;\n\t\tf[i] = std::min(pre + 2 * at[i], b <= e ? f[q[b]] + T : INF);\n\t\twhile (b <= e && f[i] <= f[q[e]]) --e;\n\t\tq[++e] = i;\n\t}\n\tstd::cout << f[n] + E << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n; ll e, t;\n  cin>>n>>e>>t;\n  ll dp[100002], dp2[100002], mn[100002], x[100002];\n  dp[0]=0; x[0]=0;\n  for(int i=1; i<=n; i++){\n    cin>>x[i];\n  }\n  mn[0]=dp[0]-2*x[1]-x[0];\n  dp2[0]=0;\n  deque<int> deq;\n  deq.push_back(0);\n  int i0=0;\n  for(int i=1; i<=n; i++){\n    while(t-2*(x[i]-x[i0+1])<0) i0++;\n    while(deq.front()<i0) deq.pop_front();\n    dp[i]=dp2[deq.front()]+t+x[i];\n    if(i0>0) dp[i]=min(dp[i], mn[i0-1]+3*x[i]);\n    if(i==n) break;\n    mn[i]=min(mn[i-1], dp[i]-2*x[i+1]-x[i]);\n    dp2[i]=dp[i]-x[i];\n    while(!deq.empty() && dp2[deq.back()]>=dp2[i]) deq.pop_back();\n    deq.push_back(i);\n  }\n  cout<<dp[n]+e-x[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n//const int mod = int(1e9) + 7;\n\nconst int MX = 200500;\nlong long dist[MX];\nconst long long inf = 1e18;\nint x[MX];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> x[n + 1] >> t;\n    x[0] = 0;\n    dist[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        dist[i] = inf;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j <= n; j++){\n            long long d = x[j] - x[i + 1];\n            d *= 2;\n            if(d < t) d = t;\n            d += x[j] - x[i];\n            d += dist[i];\n            if(dist[j] > d) dist[j] = d;\n        }\n    }\n    cout << x[n + 1] - x[n] + dist[n] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(-inputs[1], 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i], now_cost + 2 * inputs[i]);\n\n\t\twhile (next.empty() == false && 2 * (inputs[i] - inputs[next.top().second]) > t) {\n\t\t\tnext.pop();\n\t\t}\n\n\t\tif (next.empty() == false) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\tfor (int q = now_back; q < i; ++q) {\n\t\t\tlong long cost = inputs[i] - inputs[q + 1] + t - (inputs[i] - inputs[q + 1]);\n\t\t\tdp[i] = min(dp[i], dp[q] + cost);\n\t\t}\n\t\tassert(n <= 2000);\n\t\tif (i != n - 1) {\n\t\t\tnext.push(make_pair(dp[i] - inputs[i + 1], i + 1));\n\t\t}\n\t}\n\tcout << dp[n - 1] + e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint dp[N], a[N], b[N], seg[4][N << 2], lazy[4][N << 2], sum[N];\n\nvoid shift(int id, int c) {\n\tseg[id][c << 1] += lazy[id][c];\n\tseg[id][c << 1 | 1] += lazy[id][c];\n\tlazy[id][c << 1] += lazy[id][c];\n\tlazy[id][c << 1 | 1] += lazy[id][c];\n\tlazy[id][c] = 0;\n}\n\nvoid upd(int id, int c, int b, int e, int l, int r, int x) {\n\tif(r <= b || e <= l)\n\t\treturn;\n\tif(l <= b && e <= r) {\n\t\tseg[id][c] += x;\n\t\tlazy[id][c] += x;\n\t\treturn;\n\t}\n\tint mid = (b + e) >> 1;\n\tshift(id, c);\n\tupd(id, c << 1, b, mid, l, r, x), upd(id, c << 1 | 1, mid, e, l, r, x);\n\tseg[id][c] = min(seg[id][c << 1], seg[id][c << 1 | 1]);\n}\n\nint get(int id, int c, int b, int e, int l, int r) {\n\tif(r <= b || e <= l)\n\t\treturn OO;\n\tif(l <= b && e <= r)\n\t\treturn seg[id][c];\n\tint mid = (b + e) >> 1;\n\tshift(id, c);\n\treturn min(get(id, c << 1, b, mid, l, r), get(id, c << 1 | 1, mid, e, l, r));\n}\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t, h = 0;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tupd(1, 1, 0, n + 1, 0, 1, -2 * a[1]);\n\tfor(int i = 1; i <= n; i++) {\n\t\tupd(1, 1, 0, n + 1, 0, i, 3 * (a[i] - a[i - 1]));\n\t\tupd(2, 1, 0, n + 1, 0, i, a[i] - a[i - 1]);\n\t\tif(i == 1) {\n\t\t\tdp[1] = t + a[1];\n\t\t\tupd(1, 1, 0, n + 1, i, i + 1, dp[i] - 2 * (a[i + 1] - a[i]));\n\t\t\tupd(2, 1, 0, n + 1, i, i + 1, dp[i]);\n\t\t\tcontinue;\n\t\t}\n\t\twhile(2 * (a[i] - a[h]) >= t)\n\t\t\th++;\n//\t\tcout << get(2, 1, 0, n + 1, h - 1, i) << endl;\n\t\tdp[i] = min(t + get(2, 1, 0, n + 1, h - 1, i), get(1, 1, 0, n + 1, 0, h - 1));\n\t\tupd(1, 1, 0, n + 1, i, i + 1, dp[i] - 2 * (a[i + 1] - a[i]));\n\t\tupd(2, 1, 0, n + 1, i, i + 1, dp[i]);\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename t>void chkmin(t&a,t b){if(a>b)a=b;}\n\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,t,e,x[maxn],endd=0;\nll dp[maxn],val=1e18;\n\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;++i){\n\t\tdp[i]=1e18;\n\t\tcin>>x[i];\n\t\twhile(endd<i&&2*(x[i]-x[endd+1])>=t)\n\t\t\tchkmin(val,dp[endd]-2*x[endd+1]),++endd;\n\t\tchkmin(dp[i],val+2*x[i]);\n\t\tif(endd<i)\n\t\t\tchkmin(dp[i],dp[endd]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\nint dp[100006];\n\nstruct RMQ {\n\tint n; vector<int>node;\n\tvoid init(int N) {\n\t\tn = 1;\n\t\twhile (n < N)n *= 2;\n\t\tnode.resize(2 * n, inf);\n\t}\n\n\tvoid update(int x, int a) {\n\t\tx += n - 1;\n\t\tnode[x] = a;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[x * 2 + 1], node[x * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tint get(int a, int b) {\n\t\tif (a > b)return inf;\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\nRMQ dp1, dp2;\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\trep(i, n + 1)dp[i] = inf;\n\tdp1.init(n + 1);\n\tdp2.init(n + 1);\n\n\tx[n] = x[n - 1];\n\tdp1.update(0, 0);\n\tdp2.update(0, -2*x[0]);\n\trep(i,n){//dp[i+1]\n\t\tint lb = -1, ub = i;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mi = (ub + lb) / 2;\n\t\t\tif (2 * (x[i] - x[mi]) > t)lb = mi;\n\t\t\telse ub = mi;\n\t\t}\n\n\t\t//0~lb ub~i\n\t\tint X1, X2;\n\t\tX1 = dp1.get(ub, i+1) + t;\n\t\tX2 = dp2.get(0, ub) + 2 * x[i];\n\t\tdp1.update(i+1, min(X1, X2));\n\t\tdp2.update(i+1, dp1.get(i+1, i + 2) - 2 * x[i]);\n\t}\n\tcout << dp1.get(n, n+1)+e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int MaxN = 1e5 + 10;\n\nint N, E, T, x[MaxN];\n\nlong long f[MaxN];\n\nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && 2 * (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n\nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\t/*int j = find(i);\n\t\tif (j != i)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}\n\t\tif (j)\n\t\t{\n\t\t\t--j;\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t\t}*/\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + max(2 * (x[i] - x[j + 1]), T));\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nconst int N = 2005;\nconst ll INF = 1e14;\n\nint n, E, T, x[N];\nll dp[N];\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n\n    cin >> n >> E >> T;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    for(int i = 1; i <= n; i++)\n    {\n        dp[i] = INF;\n        for(int j = i - 1; j >= 0; j--)\n        {\n            ll W = max(0LL, 0LL + T + 2LL * x[j + 1] - 2LL * x[i]);\n            dp[i] = min(dp[i], dp[j] + 3LL * x[i] - x[j] - 2LL * x[j + 1] + W);\n        }\n    }\n\n    cout << dp[n] + E - x[n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e15;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    set<ll> As;\n    set<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>t){\n            As.insert(A[iter]);\n            Bs.erase(B[iter]);\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nint main(){\n  int n;\n  long long e,t;\n  //cin >> n,e,t;\n  scanf(\"%d%lld%lld\", &n,&e,&t);\n\n  vector<long long> x(n);\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<int> t_min;\n  t_min.push_back(0);\n  long long w = 1ll<<57;\n  long long add = 0;\n\n  for(int i=0, j=0; i<n; ++i){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      w = min(w, dp[j] + 2*(x[i] - x[j]));\n      j++;\n    }\n    while(t_min.size() && t_min.front() < j){\n      t_min.pop_front();\n    }\n\n    dp[i+1] = min(dp[i+1], w+add);\n    if(t_min.size()) dp[i+1] = min(dp[i+1], dp[t_min.front()] + t);\n\n    w += 2*(x[i+1] - x[i]);\n    while(t_min.size() && dp[t_min.back()] >= dp[i+1]){\n      t_min.pop_back();\n    }\n    t_min.push_back( i+1 );\n  }\n  printf(\"%lld\\n\", dp[n] + e);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,n_;\nll t,e;\nll x[100005];\n\nstruct data{\n\tll val,lazy;\n\tdata(){}\n\tdata(ll vv,ll la){\n\t\tval=vv;\n\t\tlazy=la;\n\t}\n};\n\ndata dp[1<<21];\n\nvoid lazy_evaluate(int k){\n\tdp[k].val+=dp[k].lazy;\n\tif(k+1<n_){\n\t\tdp[k*2+1].lazy+=dp[k].lazy;\n\t\tdp[k*2+2].lazy+=dp[k].lazy;\n\t}\n\tdp[k].lazy=0;\n}\n\nvoid lazy_update(int k){\n\tdp[k].val=min(dp[k*2+1].val,dp[k*2+2].val);\n}\n\nll query(int a,int b,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return INF*INF;\n\tif(a<=l && r<=b)return dp[k].val;\n\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n\treturn min(vl,vr);\n}\n\nvoid add(int a,int b,ll v,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return;\n\tif(a<=l && r<=b){\n\t\tdp[k].lazy+=v;\n\t\tlazy_evaluate(k);\n\t\treturn;\n\t}\n\tadd(a,b,v,k*2+1,l,(l+r)/2);\n\tadd(a,b,v,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n}\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tn_=1;\n\twhile(n_<=n)n_*=2;\n\tadd(1,n+1,x[n]+n*t);\n\tint now=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i>0){\n\t\t\twhile(now<i){\n\t\t\t\tll ela=x[i]-x[now+1];\n\t\t\t\tif(ela+x[i]-x[now+1]>=t){\n\t\t\t\t\t//dp[i]=min(dp[i],dp[now]+(x[i]-x[now+1])*2LL);\n\t\t\t\t\tnow++;\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[now+1]);\n\t\t\t\t\tll vi=query(i,i+1);\n\t\t\t\t\tll vi2=query(now,now+1);\n\t\t\t\t\tif(vi>vi2+rest){\n\t\t\t\t\t\tadd(i,i+1,vi2+rest-vi);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll vi=query(i,i+1);\n\t\tll vi2=query(0,now);\n\t\tif(vi>vi2){\n\t\t\tadd(i,i+1,vi2-vi); \n\t\t}\n\t\tif(i>0 && i<n)add(0,i,(x[i+1]-x[i])*2LL);\n\t\t/*\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tprintf(\"%lld \",query(j,j+1));\n\t\t}\n\t\tprintf(\"\\n\");\n\t\t*/\n\t}\n\t/*\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t\tif(i<n)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t\tif(i>=1 && j<i){\n\t\t\t\tll ela=dp[i][j]-dp[j+1][j];\n\t\t\t\t//printf(\"%lld\\n\",ela);\n\t\t\t\tif(ela+x[i]-x[j+1]>=t){\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL);\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[j+1]);\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL+rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tprintf(\"%lld\\n\",query(n,n+1)+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mkp make_pair\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int MAXN = 100010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN];\nll dp[MAXN], pre;\nqueue<pli> q;\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tq.push(mkp(0, d[1]));\n\tpre = INF;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tpli u = q.front();\n\t\twhile(2*(d[i]-u.snd) > T) {\n\t\t\tpre = min(pre, u.fst-2*u.snd);\n\t\t\tq.pop();\n\t\t\tif(!q.empty()) u = q.front();\n\t\t}\n\t\tif(!q.empty()) dp[i] = u.fst+T;\n\t\tdp[i] = min(dp[i], pre+(d[i]<<1));\n\t\tq.push(mkp(dp[i], d[i+1]));\n\t}\n\tprintf(\"%I64d\\n\", dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define ll long long int\n\nconst int mx = 1e5+1 , inf = 1e9;\n\nll n,e,t;\nll x[mx];\nll dp[mx];\nll mn=inf;\n\nll ptr=-1;\n\nint main()\n{\n    cin >> n >> e >> t;\n    e*=2;\n    t*=2;\n    for(int i=0;i<n;i++)\n    {\n        cin >> x[i];\n        x[i]*=2;\n    }\n\n    for(int i=0;i<n;i++)\n    {\n        while(x[ptr+1]<x[i]-t/2)\n        {\n            ptr++;\n            if(ptr>0)\n                mn=min(mn, dp[ptr-1]-2*x[ptr]);\n            else\n                mn=min(mn, 0-2*x[ptr]);\n        }\n        if(mn==inf)\n        {\n            dp[i]=t;\n            continue;\n        }\n        dp[i]=mn+2*x[i];\n\n        if(ptr>=0)\n            dp[i]=min(dp[i],dp[ptr]+t);\n    }\n\n    cout << (dp[n-1] + e)/2;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    vector<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = T + 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (pval <= cval) {\n                time = -LINF;\n                break;\n            }\n            int64_t prevSteady = T + 2 * X[p + 1];\n            int64_t xcval = 2 * (dp[j] + X[j + 1] - X[j]) +\n                    3LL * (currSteady - 2 * X[j + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[j + 1]));\n            int64_t xpval = 2 * (dp[p] + X[p + 1] - X[p]) +\n                    3LL * (currSteady - 2 * X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[p + 1]));\n            if (xcval < xpval) {\n                time = LINF;\n                break;\n            }\n            time = currSteady - (xcval - xpval);\n            if (time < prevSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (2 * X[i] >= d.back().second) {\n            d.pop_back();\n        }\n        int p = d.back().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint x[N],l[N];\nint main(){\n\tint n,e,t,cl=-1;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tdp[0]=0;\n\tl[n+1]=n;\n\tfor(int i=n;i>=1;i--){\n\t\tl[i]=min(l[i+1],i);\n\t\twhile(l[i]&&2*(x[i]-x[l[i]])<=t) l[i]--;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[l[i]]+t;\n\t\tfor(int j=l[i-1];j<l[i];j++){\n\t\t\tif(cl<0||dp[j]+2*(x[i]-x[j+1])<dp[cl]+2*(x[i]-x[cl+1])){\n\t\t\t\tcl=j;\n\t\t\t}\n\t\t}\n\t\tif(cl>=0) dp[i]=min(dp[i],dp[cl]+2*(x[i]-x[cl+1]));\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\n#define int long long\n\nint n,e;\nll t;\nint x[252521];\n\nll dp[252521];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\nstruct RMQ{\n  int n;\n  vl dat;\n  RMQ(int _n){\n    n=1;\n    while(n<_n)n<<=1;\n    dat.assign(2*n,INF);\n  }\n  void set(int x,int v){\n    x += n-1;\n    dat[x] = v;\n    while(x!=0){\n      x = (x-1)/2;\n      dat[x] = min(dat[2*x+1],dat[2*x+2]);\n    }\n  }\n  ll qmin(int l,int r,int a,int b,int k){\n    if(r<=a || b<=l)return INF;\n    if(l<=a && b<=r){\n      return dat[k];\n    }else{\n      int m = (a+b)/2;\n      return min(qmin(l,r,a,m,2*k+1),qmin(l,r,m,b,2*k+2));\n    }\n  }\n  ll qmin(int l,int r){\n    return qmin(l,r,0,n,0);\n  }\n};\n\nsigned main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%lld\",x+i);\n  x[n] = e;\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = e;\n  RMQ aa(n),bb(n);\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    aa.set(i,2ll*x[i]+dp[i+1]);\n    bb.set(i,t       +dp[i+1]);\n    // find m s.t. 2dij<t\n    int m = upper_bound(x+i,x+n+1,(ll)(t+2ll*x[i])/2ll) - x;\n    m--;\n    ll xx = aa.qmin(m+1,n) - 2ll*x[i];\n    ll yy = bb.qmin(0,m+1);\n    dp[i] = min(xx,yy);\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = x[0];\n  for(int i=0; i<n; i++){\n\n    auto get_cost = [&](int i, int k){\n      long long cost = (x[i+k-1] - x[i]) * 2;\n      for(int j=i; j<i+k; j++){\n        if(cost < (x[j]-x[i])+t){\n          cost = (x[j]-x[i])+t;\n        }\n        cost += x[j+1] - x[j];\n      }\n      return cost;\n    };\n\n    for(int k=1; k+i<=n; k++){\n      dp[i+k] = min(dp[i+k], dp[i] + get_cost(i,k));\n    }\n  }\n\n  println(dp[n]);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (R int i = 1; i <= n; ++i) a[i] = F();\n\tfor (R int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = 1ll * i * T;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tlong long S = a[i] - a[j], temp = dmax(T - 2ll * S, 0);\n\t\t\tcmin(f[i], f[j - 1] + temp * (i - j + 1) + S * 2);\n\t\t\tcmin(f[i], f[j - 1] + 1ll * (i - j + 1) * T);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + E );\n\treturn 0;\n}\n/*\n4 8 2\n1 2 6 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1 << 17;\ntypedef long long ll;\n\nint n;\nint t, e;\nint x[N];\nll dp[N];\n\nstruct SegT {\n\tll Min[N << 1], Lazy[N << 1];\n\n\tvoid pushdown(int i) {\n\t\tif (!Lazy[i]) return ;\n\t\tMin[i] += Lazy[i];\n\t\tif (i < N) {\n\t\t\tLazy[i << 1] += Lazy[i];\n\t\t\tLazy[i << 1 | 1] += Lazy[i];\n\t\t}\n\t\tLazy[i] = 0;\n\t}\n\n\tvoid upd(int l, int r, ll v, int i = 1, int a = 0, int b = N) {\n\t\tif (l <= a && b <= r) {Lazy[i] += v; pushdown(i); return ;}\n\t\tpushdown(i); if (r <= a || b <= l) return ;\n\t\tint m = (a + b) >> 1;\n\t\tif (l < m) upd(l, r, v, i << 1, a, m);\n\t\tif (m < r) upd(l, r, v, i << 1 | 1, m, b);\n\t\tMin[i] = min(Min[i << 1], Min[i << 1 | 1]);\n\t}\n\n\tll qry(int l, int r, int i = 1, int a = 0, int b = N) {\n\t\tpushdown(i); if (l <= a && b <= r) return Min[i];\n\t\tif (r <= a || b <= l) return 1e18;\n\t\tint m = (a + b) >> 1; ll ans = 1e18;\n\t\tif (l < m) ans = min(ans, qry(l, r, i << 1, a, m));\n\t\tif (m < r) ans = min(ans, qry(l, r, i << 1 | 1, m, b));\n\t\treturn ans;\n\t}\n} segt;\n\nint main() {\n\tcin >> n >> e >> t;\n\t++ n;\n\tfor (int i = 1; i < n; ++ i) cin >> x[i];\n\tdp[0] = 0;\n\tsegt.upd(0, 1, dp[0] + t);\n\tfor (int i = 1, j = 0; i < n; ++ i) {\n\t\tsegt.upd(0, j, (x[i] - x[i - 1]) * 2LL);\n\t\twhile (j < i && (x[i] - x[j + 1]) * 2LL >= t) {\n\t\t\tsegt.upd(j, j + 1, (x[i] - x[j + 1]) * 2LL - t);\n\t\t\t++ j;\n\t\t}\n\t\tdp[i] = segt.qry(0, i);\n\t\tsegt.upd(i, i + 1, dp[i] + t);\n\t}\n\tcout << dp[n - 1] + e << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<4*maxn;i++){\n\t\tseg[i]={(long long)1e18,(int)1e9};\n\t\tseg2[i]={(long long)1e18,(int)1e9};\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);\n\nll edge1 = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nll edge2 = 3*(X[n-1]-X[i]) + max(0ll , T-2*(X[n-1]-X[i])) + F[n-1] + dp(n);\n\nll ans = min(t1,t2);\nans = min(ans , edge1);\nans = min(ans , edge2);\n//cout << i << \" \" << ans  << \"\\n\";\n\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \ntypedef pair<int,int> pii; \n\nconst int maxN = 1000 * 100 + 10; \nint a[maxN]; \nconst ll inf = 1e17; \nll dp[maxN]; \nset<pair<ll,int>> curr1, curr2; \n\nint main() { \n\tios::sync_with_stdio(false); cin.tie(0); \n\ta[0] = 0; \n\tint n,e,T; cin >> n >> e >> T;\n\tfor( int i = 0 ; i < n ; i++ ) cin >> a[i+1]; \n\n\tcurr1.insert( { inf , -1 } ) ; \n\tcurr2.insert( { inf , -1 } ) ; \n\tfill( dp , dp + n + 1 , inf ) ; \n\tdp[0] = 0; \n\tint last = 0; \n\tcurr1.insert( { 0ll - a[1] , 0 } ); \n\tfor( int i = 1 ; i <= n ; i++ ) { \n\t\twhile( last < i && 2ll * (a[i] - a[last+1]) >= T ) { \n\t\t\tcurr1.erase( { 0ll + dp[last] - a[last] - a[last+1] , last } ) ; \n\t\t\tcurr2.insert( { 0ll + dp[last] - a[last] - 2ll * a[last+1] , last } ); \n\t\t\tlast++; \n\t\t}\n\t\tdp[i] = min( 0ll + curr1.begin()->first + 2ll * a[i] + T , \n\t\t\t\t0ll + curr2.begin()->first + 3ll * a[i] ); \n\t\tcurr1.insert( { dp[i] - a[i] - a[i+1] , i } ); \n\t}\n\tcout << dp[n] + e - a[n] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\nusing ulong = unsigned long;\nusing ll = long long;\nconst int M = 1e9 + 7;\n#pragma unused(M)\n\nint main(){\n\tint n, e, t;\n\tcin >> n >> e >> t;\n    vector<ll> xs(n);\n    for(int i=0;i<n;i++){\n        cin >> xs[i];\n    }\n\n    ll ans = xs[0] + t, wait = t;\n    for(int i=1;i<n;i++){\n        ll dx = xs[i] - xs[i - 1];\n        if(dx + t < 3 * dx - min(wait, 2 * dx)){\n            ans += dx + t;\n            wait = t;\n        }else{\n            ans += 3 * dx - min(wait, 2 * dx);\n            wait = 0;\n        }\n    }\n    ans += e - xs.back();\n    cout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 40, T = 18, MAXN = (1 << T) + 100;\nint a[N];\nint dp[3][MAXN], n, m;\nvector<int> fr, sd;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i < (1 << min(n, T)); i++) {\n\t\tint plcf = __builtin_ctz(i), add = a[plcf] % m;\n\t\tdp[0][i] = (dp[0][i ^ (1 << plcf)] + add) % m;\n\t\tfr.push_back(dp[0][i]);\n\t}\n\tfor (int i = 1; i < (1 << max(0, n - T)); i++) {\n\t\tint plcf = __builtin_ctz(i), add = a[plcf + T] % m;\n\t\tdp[1][i] = (dp[1][i ^ (1 << plcf)] + add) % m;\n\t\tsd.push_back(dp[1][i]);\n\t}\n\tsd.push_back(0);\n\tsort(sd.begin(), sd.end());\n\tint mx = 0;\n\tfr.push_back(0);\n\tfor (auto x : fr) {\n\t\tint nd = m - 1 - x;\n\t\tint plc = upper_bound(sd.begin(), sd.end(), nd) - sd.begin() - 1;\n\t\tif (plc == sd.size() || plc == 0)\n\t\t\tmx = max(mx, x);\n\t\telse\n\t\t\tmx = max(mx, sd[plc] + x);\n\t}\n\tcout << mx;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e5 + 10;\nint a[MAXN];\nint n, e, t;\nint32_t main () {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i =0; i < n; ++i)\n        cin >> a[i];\n    a[n] = 2e9;\n    int res = a[0];\n    int point = 0;\n    for (int i = 0; i < n; ++i) {\n        if (a[i + 1] - a[point] > t) {\n            res += max(a[i] - a[point], t - a[i] + a[point]) + a[i] - a[point];\n            point = i + 1;\n        }\n        if (i < n - 1)\n            res += a[i + 1] - a[i];\n    }\n    res += e - a[n - 1];\n    cout << res;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\ntemplate <typename T>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  int n;\n  F f;\n  T ti;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}\n  void init(int n_){\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n  void update(int k,T x){\n    dat[k+=n]=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n  void add(int k,T x){\n    dat[k+=n]+=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n  T query(int a,int b){\n    T vl=ti,vr=ti;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);\n      if(r&1) vr=f(dat[--r],vr);\n    }\n    return f(vl,vr);\n  }\n};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,e,t;\n  cin >> n >> e >> t;\n\n  vector<int> a(n,0);\n  REP(i,n) cin >> a[i];\n\n  auto f = [](int a, int b){return min(a,b);};\n  SegmentTree<int> seg1(f,INF),seg2(f,INF);\n\n  vec tmp(n+1,INF);\n  tmp[0] = 0;\n  seg1.build(tmp);\n  tmp[0] = -2*a[0];\n  seg2.build(tmp);\n\n  vec dp(n+1,INF);\n  dp[0] = 0;\n  FOR(i,1,n+1){\n    int id = upper_bound(a.begin(),a.end(),a[i-1]-(t+1)/2) - a.begin() - 1;\n    id = min(id,i-1);\n    //debug(id);\n    dp[i] = min(dp[i],seg1.query(id+1,i)+a[i-1]+t);\n    dp[i] = min(dp[i],seg2.query(0,id+1)+a[i-1]*3);\n    seg1.update(i,dp[i]-a[i-1]);\n    seg2.update(i,dp[i]-a[i-1]-2*a[i]);\n    //debug(dp[i]);\n  }\n\n  cout << dp[n]+e-a.back() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n+1,0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvl dp(n+1,INF);\n\tdp[0] = e;\n\tvi p(n + 1);\n\tint l = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 < t)l++;\n\t\tp[i] = l;\n\t}\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tif(p[i]<i)mi = dp[p[i]] + t;\n\t\tfor (int j =0; j<l; j++) {\n\t\t\tmi = min(mi, dp[j]+ 2 * (x[i]-x[j+1]));\n\t\t}\n\t\tdp[i] = mi;\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 101010;\nint N , E , T;\nint x[MAXN];\nll f[MAXN];\nint head = 1 , tail = 0;\nll maxn = 1000000000000ll;\nint q[MAXN];\nll t[MAXN];\nvoid push(int p , ll now){\n\twhile(head <= tail && now <= t[tail])\n\t\ttail --;\n\tq[++ tail] = p;\n\tt[tail] = now;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin >> N >> E >> T;\n\tfor(int i = 1 ; i <= N ; ++ i)\n\t\tcin >> x[i];\n\tf[N] = E + T - x[N];\n\tx[N + 1] = E;\n\tpush(N , f[N + 1] + x[N]);\n\tfor(int i = N - 1 ; i >= 1 ; -- i){\n\t\twhile(head <= tail && 2 * (x[q[head]] - x[i]) >= T){\n\t\t\tmaxn = min(maxn , f[q[head] + 1] + 2ll * x[q[head]] + x[q[head] + 1]);\n\t\t\thead ++;\n\t\t}\n\t\tf[i] = maxn - 3ll * x[i];\n\t\tf[i] = min(f[i] , f[i + 1] + T + x[i + 1] - x[i]);\n\t\tif(head <= tail) f[i] = min(f[i] , t[head] + T - x[i]);\n\t\tpush(i , f[i + 1] + x[i]);\n\t}\t\n\tcout << f[1] + x[1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    ll N,E,T; cin >> N >> E >> T;\n    //if (N > 2000) return 0;\n    vector<ll> X(N); rv(X);\n\n    vector<ll> H(N, 0);\n    for (int i = 0; i < N; i++) {\n        H[i] = max(T, 2*X[i] - 2*X[0]);\n    }\n\n    int y = -1;\n    ll df = 1e15;\n    priority_queue<pair<ll,int>,vector<pair<ll,int>>, greater<pair<ll,int>>> Q;\n    for (int i = 0; i < N; i++) {\n        if (i!=0) df = df + 2*X[i] - 2*X[i-1];\n        while (y < N-1 && 2*X[i] - 2*X[y+1] > T) {\n            //cout << \"ADD\" << y << endl;\n            df = min(df, (y >= 0 ? (H[y] - X[y]) : 0) + 2*X[i] - 2*X[y+1]);\n            y++;\n        }\n\n        //cout << i << ' ' << y << ' ' << H[i] << ' ' << df << 'D' << endl;\n        H[i] = min(H[i], df);\n        while (!Q.empty() && 2*X[i] - 2*X[Q.top().y+1] > T) {\n            //cout << \"KILL\" << Q.top().y << endl;\n            Q.pop();\n        }\n        if (!Q.empty()) {\n            //cout << i << ' ' << y << ' ' << H[i] << ' ' << Q.top().x+T << 'T' << endl;\n            H[i] = min(H[i], Q.top().x + T);\n        }\n\n        Q.push({H[i], i});\n        /*for (int j = 0; j < i; j++) {\n            H[i] = min(H[i], H[j] - X[j] + max(T, 2*X[i] - 2*X[j+1]));\n        }*/\n        H[i] += X[i];\n        //cout << i << ' ' << y << ' ' << df << ' ' << H[i] << endl;\n    }\n    cout << H[N-1] + E - X[N-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    const ll INFL = LLONG_MAX / 3;\n    int N, E, T;\n    cin >> N >> E >> T;\n    vi x(N + 1);\n    vll f(N + 1, 0);\n    for(int i = 1; i <= N; ++i)cin >> x[i];\n\n    int p = 0;\n    // min(dp[i]+T) // 近い\n    // min(dp[i]-2x[i+1]) // 遠い\n    multiset<ll> aa, bb;\n    for(int i = 1; i <= N; ++i) {\n        aa.insert(f[i - 1] + T);\n        while(T < 2 * (x[i] - x[p + 1])) {\n            bb.insert(f[p] - 2 * x[p + 1]);\n            aa.erase(aa.find(f[p++]+T));\n        }\n        f[i] = *aa.begin();\n        if(sz(bb))smin(f[i], 2 * x[i] + (*bb.begin()));\n    }\n    cout << E + f[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nstruct seg {\n\tint min[N << 2];\n\tvoid modify(int u, int k, int v, int l = 0, int r = n) {\n\t\t// printf(\"modify %d %d %d %d %d\\n\", u, k, v, l, r);\n\t\tif (l == r) { min[u] = v; return; }\n\t\tint mid = (l + r) >> 1;\n\t\tif (k <= mid) modify(u << 1, k, v, l, mid);\n\t\telse modify(u << 1 | 1, k, v, mid + 1, r);\n\t\tmin[u] = std::min(min[u << 1], min[u << 1 | 1]);\n\t}\n\tint query(int u, int ql, int qr, int l = 0, int r = n) {\n\t\t// printf(\"query %d %d %d %d %d : %d\\n\", u, ql, qr, l, r, min[u]);\n\t\tif (ql > qr) return f[N - 1];\n\t\tif (ql == l && qr == r) return min[u];\n\t\tint mid = (l + r) >> 1;\n\t\tif (qr <= mid) return query(u << 1, ql, qr, l, mid);\n\t\tif (ql > mid) return query(u << 1 | 1, ql, qr, mid + 1, r);\n\t\treturn std::min(query(u << 1, ql, mid, l, mid), query(u << 1 | 1, mid + 1, qr, mid + 1, r));\n\t}\n} s[2];\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tmemset(s[0].min, 0x3f, sizeof(s[0].min));\n\tmemset(s[1].min, 0x3f, sizeof(s[1].min));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\ts[0].modify(1, 0, -2 * a[1]);\n\ts[1].modify(1, 0, 0);\n\tfor (int i = 1, from; i <= n; i++) {\n\t\tint j = std::lower_bound(a, a + i, (a[i] * 2 - k + 1) >> 1) - a - 1;\n\t\tf[i] = std::min(f[i], 3 * a[i] + s[0].query(1, std::max((int)0, (int)0), std::min(n, j - 1)));\n\t\tf[i] = std::min(f[i], a[i] + k + s[1].query(1, std::max((int)0, (int)j), std::min(n, i - 1)));\n\t\ts[0].modify(1, i, f[i] - a[i] - 2 * a[i + 1]);\n\t\ts[1].modify(1, i, f[i] - a[i]);\n\t\t// printf(\"[%d %d] %d %d | [%d %d] %d %d\\n\",\n\t\t// \t0, j - 1, 3 * a[i], s[0].query(1, 0, j - 1),\n\t\t// \tj, i - 1, a[i] + k, s[1].query(1, j, i - 1));\n\t}\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\nconst int inf = 1e18;\nint x[111111], dp[111111], st[333333] = {inf};\nint upd(int l, int r, int cur, int ind, int val)\n{\n    if(ind < l or r < ind)\n        return inf;\n    if(l == r)\n        return st[cur] = val;\n    int mid = (l+r)/2;\n    upd(mid+1, r, cur*2+2, ind, val);\n    upd(l, mid, cur*2+1, ind, val);\n    return st[cur] = min(st[cur*2+1], st[cur*2+2]);\n}\nint mn(int l, int r, int sl, int sr, int cur)\n{\n    if(sr < l or r < sl)\n        return inf;\n    if(l == r)\n        return st[cur];\n    int mid = (l+r)/2;\n    return min(mn(l, mid, sl, sr, cur*2+1), mn(mid+1, r, sl, sr, cur*2+2));\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n, t, e;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n\n    upd(0, n, 0, 0, -2*x[1]);\n\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x+1, x+n+1, x[i]-t/2.0)-x;\n        if((x[i]-x[j])*2 < t)\n            j--;\n        dp[i] = min(dp[j]+t, mn(0,n,0,j-1,0)+2*x[i]);\n        //cout << i << ' ' << j << ' ' << dp[i] << endl;\n\n        upd(0, n, 0, i, dp[i]-2*x[i+1]);\n    }\n    cout << dp[n]+e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n \nint p[100001],s[100001],l,r;\nlong long f[100001];\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tlong long z=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\ts[++r]=i;\n\t\tfor(;2*(p[i]-p[s[l]])>=t;l++)\n\t\t\tz=min(z,f[s[l]-1]-2*p[s[l]]);\n\t\tf[i]=f[s[l]-1]+t;\n\t\tf[i]=min(f[i],2*p[i]+z);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n,e,t,curpos;\nlong long arr[100010];\nlong long ans;\nlong long dp[100010];\ndeque<long long> dp2;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin>>n>>e>>t;\n    for (int i=1;i<=n;i++) cin>>arr[i];\n    dp2.push_back(1e16);\n    for (int k=1;k<=n;k++){\n        dp[k]=1e16;\n        int prevpos=curpos;\n        while (curpos<k-1 && t<=(arr[k]-arr[curpos])*2) curpos++;\n        dp[k]=dp[curpos]+t;\n        dp[k]=min(dp[k],arr[k]*2+dp2.front());\n        for (int i=prevpos;i<=curpos;i++){\n            while (!dp2.empty() && dp2.back()>dp[i]-arr[i+1]*2) dp2.pop_back();\n            dp2.push_back(dp[i]-arr[i+1]*2);\n        }\n    }\n    cout<<e+dp[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n/////////////////////\n\nint const N = (1 << 18);\nll const INF = 1e18;\n\nint n;\nll t, x[N], e;\nll t1[N], t2[N];\n\nvoid remin(ll &a, ll b){ a = min(a, b); }\n\nvoid push(int v, ll *t){\n\tremin(t[v*2+1], t[v]);\n\tremin(t[v*2+2], t[v]);\n}\n\nvoid upd(int v, int tl, int tr, int l, int r, ll val, ll *t){\n\tif(tl > r || tr < l) return;\n\tif(l <= tl && tr <= r){\n\t\tremin(t[v], val);\n\t\treturn;\n\t}\n\tpush(v, t);\n\tint tm = (tl+tr)/2;\n\tupd(v*2+1, tl, tm, l, r, val, t);\n\tupd(v*2+2, tm+1, tr, l, r, val, t);\n}\n\nll get(int v, int tl, int tr, int p, ll *t){\n\tif(tl == tr){\n\t\treturn t[v];\n\t}else{\n\t\tpush(v, t);\n\t\tint tm = (tl+tr)/2;\n\t\tif(p <= tm) return get(v*2+1, tl, tm, p, t);\n\t\telse return get(v*2+2, tm+1, tr, p, t);\n\t}\n}\n\nvoid build(int v, int tl, int tr, ll *t, bool flag){\n\tt[v] = INF;\n\tif(tl == tr){\n\t\tt[v] = INF;\n\t\tif(flag && tl == 0){\n\t\t\tt[v] = 0;\n\t\t}\n\t}else{\n\t\tint tm = (tl+tr)/2;\n\t\tbuild(v*2+1, tl, tm, t, flag);\n\t\tbuild(v*2+2, tm+1, tr, t, flag);\n\t}\n}\n\nll getVal(int id){\n\tll ret = get(0, 0, n-1, id, t1) + x[id];\n\tif(id > 0){\n\t\tremin(ret, get(0, 0, n-1, id, t2) + x[id] + 2LL * x[id-1]);\n\t}\n\treturn ret;\n}\n\nint getPos(int l, ll xi){\n\tint r = n;\n\twhile(r-l>1){\n\t\tint m = (l+r)/2;\n\t\tll val = (x[m] - xi) * 2;\n\t\tif(val <= t) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n\nvoid solve(){\n\tcin >> n >> e >> t;\n\trep(i, 0, n) cin >> x[i];\n\tx[n] = e;\t\n\tn += 1;\n\tbuild(0, 0, n-1, t1, true);\n\tbuild(0, 0, n-1, t2, false);\n\n\trep(i, 0, n){\n\t\tll cur = getVal(i);\n\t\tint pos = getPos(i-1, x[i]);\n\t\t//cout << i << \" \" << cur << endl;\n\t\tupd(0, 0, n-1, i+1, min(n-1, pos+1), cur + t - x[i], t1);\n\t\tupd(0, 0, n-1, pos+2, n-1, cur - 3 * x[i], t2);\n\t}\n\n\tll ans = getVal(n - 1);\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 <= t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);\n\nll edge1 = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nll edge2 = 3*(X[n-1]-X[i]) + max(0ll , T-2*(X[n-1]-X[i])) + F[n-1] + dp(n);\n\nll ans = min(t1,t2);\nans = min(ans , edge1);\nans = min(ans , edge2);\n//cout << i << \" \" << ans  << \"\\n\";\n\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n\treturn dp[j] + max(t, 2 * (a[i] - a[j + 1]));\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\tdp[i] = dp[i - 1] + a[i] - a[i - 1] + t;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}\n\t//\tcout << \"73 \" << i << \" \" << dp[i] << endl;\n\t//\tcout << \"72 \" << get(2, 0) << endl;\n\t}\n\tcout << dp[n] + e;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()]>=dp[xx]-2*x[xx]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t\t}\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;ll E,T;cin >> N >> E >> T;\n\t\tvector<ll> xs(N+1);\n\t\tfor(int i:range(N)) cin >> xs[i+1];\n\n\t\tvector<ll> dp(N+1,INF<ll>());\n\t\tdp[0] = 0;\n\t\tfor(int i:range(1,N+1)){\n\t\t\tfor(int pre:range(i)){\n\t\t\t\tll d = xs[i] - xs[pre+1];\n\t\t\t\tdp[i] = min(dp[i],dp[pre] + xs[pre+1]-xs[pre] + d + max(2*d,T));\n\t\t\t}\n\t\t}\n\t\tcout << dp[N] + E - xs[N] << endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n\n*/\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define gc() getchar()\n#define MAXIN 300000\n//#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)\ntypedef long long LL;\nconst int N=1e5+5;\n\nint p[N];\nLL f[N];\nchar IN[MAXIN],*SS=IN,*TT=IN;\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-'0',c=gc());\n\treturn now;\n}\n\nint main()\n{\n\tint n=read(),E=read(),T=read();\n\tfor(int i=1; i<=n; ++i) p[i]=read();\n\tLL mn=1e16;\n\tfor(int i=1,j=0; i<=n; ++i)\n\t{\n\t\twhile(T<=2*(p[i]-p[j+1])) mn=std::min(mn,f[j]-2*p[j+1]), ++j;\n\t\tif(j!=i) f[i]=std::min(f[j]+T,2*p[i]+mn);\n\t\telse f[i]=2*p[i]+mn;\n\t}\n\tprintf(\"%lld\\n\",f[n]+E);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n + 1, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint l = 0;\n\tvi p(n + 1);\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\tvl dp(n + 1, INF);\n\tdp[0] = e;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tif (p[i] < i)mi = dp[p[i]] + t;\n\t\tfor (int j = 0; j<p[i]; j++) {\n\t\t\tmi = min(mi, dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n\t\t}\n\t\tdp[i] = mi;\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[2010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+2010, 1e15);\n\n  dp[0] = 0;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tint j;\n\tfor(j=i;j<N;++j){\n\t  LL d = xs[j] - xs[i];\n\t  LL tmp = dp[i] + t + d*3 + max(0ll, T-2*d);\n\t  dp[j+1] = min(dp[j+1], tmp);\n\t  if(T - 2*d <= 0) break;\n\t}\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nint n,T,E;\nint a[100010];\nlong long ans;\nlong long f[100010],g[100010];\npair<int,long long> q[100010];\n\nint main()\n{int i,j,t,w;\n \n scanf(\"%d%d%d\",&n,&E,&T);\n for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n f[0]=0;\n j=1;\n a[n+1]=E;\n t=1;\n w=1;\n q[1]=make_pair(0,0);\n for(i=1;i<=n;i++)\n {\twhile(j+1<=i && (a[i]-a[j+1])*2>=T) j++;\n\tif((a[i]-a[j])*2>=T) f[i]=max(f[i],(a[i+1]-a[i])*2+g[j-1]);\n\twhile(t<=w && (a[i]-a[q[t].first])*2>=T) t++;\n\twhile(t<=w && q[t].second<=f[i-1]-a[i]*2) w--;\n\tq[++w]=make_pair(i,f[i-1]-a[i]*2);\n\tif(t<=w) f[i]=max(f[i],q[t].second+2*a[i]+2*(a[i+1]-a[i])-T);\n\tg[i]=max(g[i-1],f[i]);\n }\n ans=(ll)3*E-f[n]-2*a[1];\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n#define INF 1LL<<60\ntypedef long long ll;\ntemplate<class V, int NV> class SegTree {\npublic:\n\tstatic V const def = -(1LL << 60);\n\tV comp(V l, V r) { return max(l, r); };\n\n\tvector<V> val;\n\tSegTree() { val = vector<V>(NV * 2, def); }\n\n\tV getval(int l, int r) { //[l,r]\n\t\tl += NV; r += NV + 1;\n\t\tV ret = def;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) ret = comp(ret, val[l++]);\n\t\t\tif (r & 1) ret = comp(ret, val[--r]);\n\t\t\tl /= 2; r /= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV;\n\t\tval[i] = v;\n\t\twhile (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n};\n//-----------------------------------------------------------------\nint N;\nll E, T;\nll X[101010];\nll Y[101010];\nll YY[101010];\nll dp[101010][2];\nSegTree<ll, 1 << 20> st;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> E >> T;\n\trep(i, 0, N) scanf(\"%d\", &X[i]);\n\tX[N] = E;\n\n\tY[0] = X[0];\n\trep(i, 0, N) Y[i + 1] = X[i + 1] - X[i];\n\n\tYY[0] = Y[0];\n\trep(i, 1, N + 1) YY[i] = Y[i] + YY[i - 1];\n\n\trep(i, 0, N + 1) dp[i][0] = dp[i][1] = INF;\n\n\tdp[0][0] = Y[0];\n\tdp[0][1] = Y[0] + T;\n\tst.update(0, dp[0][0] - YY[0] * 3);\n\trep(i, 1, N + 1) {\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][0] + Y[i] + T);\n\t\tdp[i][0] = min(dp[i][0], dp[i - 1][1] + Y[i]);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][0] + Y[i] + T * 2);\n\t\tdp[i][1] = min(dp[i][1], dp[i - 1][1] + Y[i] + T);\n\t\tdp[i][1] = min(dp[i][1], YY[i] * 3 + st.getval(0, i - 1));\n\t\tst.update(i, dp[i][0] - YY[i] * 3);\n\t}\n\n\trep(i, 0, N + 1) printf(\"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n\n\tcout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int  maxn=200008;\nint n,e; \nlong long T;\nint a[maxn]; \nlong long f[maxn];\n\nvoid check(int i,int j)\n{\n  long long h=a[i];\n        f[i]=min(f[i],f[j]+a[i]-a[j]+max(T-2*(a[i]-a[j+1]),h-a[j+1])+a[i]-a[j+1]);\n}\nint main(){\n  cin>>n>>e>>T;\n  for (int i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n  f[0]=0; a[0]=0;\n\n  if (n<=1000) \n  {\n  for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=0;j--)\n      {   \n        check(i,j);\n        \n      }\n    }  \n  }\n  else\n  {\n     for (int i=1;i<=n;i++)\n    {\n    f[i]=f[i-1]+a[i]-a[i-1]+T;\n    \n    for (int j=i-2;j>=max(0,i-50);j--)\n      {   \n        \n        check(i,j);\n        \n      }\n    check(i,0);\n    check(i,i / 2);\n    \n    }  \n  }\n  //for (int i=1;i<=n;i++)\n  //  cout<<f[i]<<endl;\n   cout<<f[n]+e-a[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,n_;\nll t,e;\nll x[100005];\n\nstruct data{\n\tll val,lazy;\n\tdata(){}\n\tdata(ll vv,ll la){\n\t\tval=vv;\n\t\tlazy=la;\n\t}\n};\n\ndata dp[100005];\n\nvoid lazy_evaluate(int k){\n\tdp[k].val+=dp[k].lazy;\n\tif(k+1<n_){\n\t\tdp[k*2+1].lazy+=dp[k].lazy;\n\t\tdp[k*2+2].lazy+=dp[k].lazy;\n\t}\n\tdp[k].lazy=0;\n}\n\nvoid lazy_update(int k){\n\tdp[k].val=min(dp[k*2+1].val,dp[k*2+2].val);\n}\n\nll query(int a,int b,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return INF*INF;\n\tif(a<=l && r<=b)return dp[k].val;\n\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n\treturn min(vl,vr);\n}\n\nvoid add(int a,int b,ll v,int k=0,int l=0,int r=n_){\n\tlazy_evaluate(k);\n\tif(r<=a || b<=l)return;\n\tif(a<=l && r<=b){\n\t\tdp[k].lazy+=v;\n\t\tlazy_evaluate(k);\n\t\treturn;\n\t}\n\tadd(a,b,v,k*2+1,l,(l+r)/2);\n\tadd(a,b,v,k*2+2,(l+r)/2,r);\n\tlazy_update(k);\n}\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tif(n>=2001)return 0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tn_=1;\n\twhile(n_<=n)n_*=2;\n\tadd(1,n+1,x[n]+n*t);\n\tint now=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i>0){\n\t\t\twhile(now<i){\n\t\t\t\tll ela=x[i]-x[now+1];\n\t\t\t\tif(ela+x[i]-x[now+1]>=t){\n\t\t\t\t\t//dp[i]=min(dp[i],dp[now]+(x[i]-x[now+1])*2LL);\n\t\t\t\t\tnow++;\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[now+1]);\n\t\t\t\t\tll vi=query(i,i+1);\n\t\t\t\t\tll vi2=query(now,now+1);\n\t\t\t\t\tif(vi>vi2+rest){\n\t\t\t\t\t\tadd(i,i+1,vi2+rest-vi);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll vi=query(i,i+1);\n\t\tll vi2=query(0,now);\n\t\tif(vi>vi2){\n\t\t\tadd(i,i+1,vi2-vi); \n\t\t}\n\t\tif(i>0 && i<n)add(0,i,(x[i+1]-x[i])*2LL);\n\t\t/*\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tprintf(\"%lld \",query(j,j+1));\n\t\t}\n\t\tprintf(\"\\n\");\n\t\t*/\n\t}\n\t/*\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t\tif(i<n)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x[i+1]-x[i]);\n\t\t\tif(i>=1 && j<i){\n\t\t\t\tll ela=dp[i][j]-dp[j+1][j];\n\t\t\t\t//printf(\"%lld\\n\",ela);\n\t\t\t\tif(ela+x[i]-x[j+1]>=t){\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL);\n\t\t\t\t}else{\n\t\t\t\t\tll rest=t-(ela+x[i]-x[j+1]);\n\t\t\t\t\tdp[i][i]=min(dp[i][i],dp[i][j]+(x[i]-x[j+1])*2LL+rest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tprintf(\"%lld\\n\",query(n,n+1)+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> VL;\n\ntemplate <class I, class BiOp> class SegmentTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\n\npublic:\n  typedef int size_type;\n  typedef I value_type;\n  SegmentTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_)\n      n *= 2; // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  /* http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/\n   * [a, b)\n   */\n  I query(int a, int b) const {\n    I left = e;\n    I right = e;\n    a += n - 1;\n    b += n - 1;\n    while (a < b) {\n      if ((a & 1) == 0) {\n        left = op(left, dat[a]);\n      }\n      if ((b & 1) == 0) {\n        right = op(dat[b - 1], right);\n      }\n      a = a / 2;\n      b = (b - 1) / 2;\n    }\n    return op(left, right);\n  }\n  I operator[](int idx) const {\n    return dat[idx + n - 1];\n  }\n};\n\n\nconst ll inf = 1e16;\n\nstruct min_fun {\n  ll operator()(ll x, ll y) const {\n    return min(x, y);\n  }\n};\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  VL x(n);\n  SegmentTree<ll, min_fun> raw(n + 1, min_fun(), inf); // dp[i]\n  SegmentTree<ll, min_fun> boiled(n + 1, min_fun(), inf); // dp[i] - 2 * x[i]\n  REP(i, 0, n) {\n    cin >> x[i];\n  }\n  raw.update(0, 0);\n  boiled.update(0, -2 * x[0]);\n  REP(i, 0, n) {\n    // Compute the range of j s.t. t <= 2 * (x[i] - x[j]) (0 <= j <= i)\n    int j_boundary =\n      upper_bound(x.begin(), x.begin() + i + 1, x[i] - (t+1)/2) - x.begin();\n    ll ret = inf;\n    ret = min(ret, boiled.query(0, j_boundary) + 2 * x[i]);\n    ret = min(ret, raw.query(j_boundary, i + 1) + t);\n    raw.update(i + 1, ret);\n    if (i < n - 1) {\n      boiled.update(i + 1, ret - 2 * x[i + 1]);\n    }\n  }\n  cout << raw[n] + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j != 0){\n            tmp1 = sgt2.query(0, min(j, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint arr[100005], que[100005], he = 0, ta = 0;\nlong long dp[100005], mn = 1e18;\nint main()\n{\n\t// freopen(\"AGC007-D.in\", \"r\", stdin);\n\tint n, e, t;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1, cur = 0; i <= n; i++)\n\t{\n\t\twhile (cur < i && (arr[i] - arr[cur + 1] << 1) >= t)\n\t\t{\n\t\t\tif (he <= ta && que[he] == cur)\n\t\t\t\the++;\n\t\t\tmn = std::min(mn, dp[cur] - (arr[cur + 1] << 1));\n\t\t\tcur++;\n\t\t}\n\t\tdp[i] = mn + (arr[i] << 1);\n\t\tif (he <= ta)\n\t\t\tdp[i] = std::min(dp[i], dp[que[he]] + t);\n\t\twhile (he <= ta && dp[que[ta]] >= dp[i])\n\t\t\tta--;\n\t\tque[++ta] = i;\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100010\n#define INF 1e15+7\nstruct SegmentTree {\nprivate:\n    int nn; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        nn = 1; while(nn < sz) nn *= 2;\n        node.resize(2*nn-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (nn - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = nn;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+2),seg2(n+2);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-x[i]*2+x[mid+1]*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nll t[1 << 20];\nstatic ll dp[1 << 20];\nstatic int pos[1 << 20];\nstatic int s[1 << 20];\nint n,S,T;\nvoid U(int p,int u,int poz,ll val,int node)\n{\n    if (p == u)\n        t[node] = val;\n    else\n    {\n        int m = (p + u) / 2;\n        if (poz <= m)\n            U(p,m,poz,val,node << 1);\n        else\n            U(m + 1,u,poz,val,node << 1 | 1);\n        t[node] = min(t[node << 1],t[node << 1 | 1]);\n    }\n}\nvoid update(int poz,ll val)\n{\n    U(1,n + 1,poz + 1,val,1);\n}\nll query(int p,int u,int l,int r,int node)\n{\n    if (l > r) return (ll)(1e18);\n    if (l <= p && u <= r)\n        return t[node];\n    int m = (p + u) / 2;\n    ll ans = 1e18;\n    if (l <= m)\n        ans = min(ans,query(p,m,l,r,node << 1));\n    if (m+1<=r)\n        ans = min(ans,query(m+1,u,l,r,node << 1 | 1));\n    return ans;\n}\nll query(int l,int r)\n{\n    return query(1,n + 1,l + 1,r + 1,1);\n}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    fi>>n>>S>>T;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    pos[0] = 0;\n    for (int i = 0;i <= n;++i)\n        update(i,(ll)(1e18));\n    for (int i = 1;i <= n;++i)\n    {\n        pos[i] = pos[i - 1];\n        while (T < 2ll * (s[i] - s[pos[i]])) ++pos[i];\n    }\n    dp[0] = 0;\n    update(0,dp[0] - s[0] + T);\n    for (int i = 1;i <= n;++i)\n        --pos[i];\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = pos[i - 1];j < pos[i];++j)\n                update(j,dp[j] - s[j] - 2ll * s[j + 1]);\n            dp[i] = min(query(0,pos[i] - 1) + 3ll * s[i],1ll * s[i] + query(pos[i],i - 1));\n            update(i,dp[i] - s[i] + T);\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 2e9;\nconst ld EPS = 1e-8;\n\nint main(){\n  int N, E, T;\n  cin >> N >> E >> T;\n  vector<int> x(N);\n  REP(i,N) cin >> x[i];\n\n  if(N > 2000) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  vector<ll> dp(N + 1, INF);\n  dp[0] = 0;\n  REP(i,N) {\n    REP(j,i + 1) {\n      dp[i + 1] = min(dp[i + 1], dp[j] + max(T, 2 * (x[i] - x[j])));\n    }\n  }\n\n  cout << dp[N] + E << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, E, st[n], Q[n];\n\nI64\t\tT, X[n], F[n];\n\nI64\t\tCost(int j, int i){\n\t\treturn\tX[j+1] - X[j] + max(T, (X[i] - X[j+1])*2) + (X[i] - X[j+1]);\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tE= IN();\n\t\tT= IN();\n\t\tFor(i, 1, N)\tX[i]= IN();\n\t\t\n\t\tint h= 1, t= 1;\n\t\tst[1]= 1;\tQ[1]= 0;\n\t\t\n\t\tFor(i, 1, N)\t{\n\t\t\tfor\t(; h < t && st[h+1] == i; h++);\n\t\t\tF[i]= F[Q[h]] + Cost(Q[h], i);\n\t\t\t\n\t\t\tfor\t(; st[t] > i && F[i] + Cost(i, st[t]) < F[Q[t]] + Cost(Q[t], st[t]); )\tt--;\n\t\t\t\n\t\t\tint l= max(st[t], i), r= N+1;\n\t\t\tfor\t(; l+1 < r;)\t{\n\t\t\t\tint Mid= (l+r) >> 1;\n\t\t\t\tif\t(F[i] + Cost(i, Mid) < F[Q[t]] + Cost(Q[t], Mid))\tr= Mid;\n\t\t\t\t\telse\tl= Mid;\n\t\t\t}\n\t\t\t\n\t\t\tif\t(r != N+1)\tt++, Q[t]= i, st[t]= r;\n\t\t}\n\t\t\n\t\tcout << F[N] + E - X[N] << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nusing namespace std;\n\nint n;\nlong long a[N];\nlong long d[N];\nlong long E, T;\nlong long pref[N];\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> E >> T;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        long long inf = 1e18;\n        pref[0] = inf;\n        for(int i = 1, h = 0; i <= n; i++){\n                d[i] = inf;\n                pref[i] = pref[i - 1];\n                while(2 * (a[i] - a[h + 1]) >= T){\n                        h += 1;\n                }\n                if(h > 0){\n                        d[i] = 3 * a[i] + pref[h];\n                }\n\n                for(int dx = -1; dx <= 1; dx++){\n                        int j = h + dx;\n                        if(j < 1 || j > i){\n                                continue;\n                        }\n                        long long D = a[i] - a[j];\n                        d[i] = min(d[i], d[j - 1] + D + max(D * 2, T) + a[j] - a[j - 1]);\n                }\n                pref[i] = min(pref[i], - 2 * a[i] - a[i - 1] + d[i - 1]);\n        }\n        cout << d[n] + E - a[n] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int maxn = 1e5 + 5;\n\nint n, e, t;\nint x[maxn];\nll dp[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tdp[0] = 0;\n\tREP(i, 1, n)\n\t\tscanf(\"%d\", x + i);\n\tfor(int i = 1, j = 1; i <= n; ++i){\n\t\tif(2 * (x[i] - x[1]) <= t)\n\t\t\tdp[i] = t;\n\t\telse{\n\t\t\tdp[i] = -2 * x[1];\n\t\t\tfor(; 2 * (x[i] - x[j + 1]) > t; ++j){\n\t\t\t\tdp[i] = min(dp[i], dp[j] - 2 * x[j + 1]);\n\t\t\t}\n\t\t\tdp[i] += 2 * x[i];\n\t\t\tdp[i] = min(dp[i], dp[j] + t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define xx first\n#define yy second\n#define i64 long long int\n#define MEM(a,x) memset(a,x,sizeof(x))\n#define INF 1000000000\n#define mod 998244353\n\nusing namespace std ;\n\n#define maxn 1000005\n\ni64 x[maxn] , mn[maxn] , dp[maxn] ;\ndeque< pair<i64,i64> > dq ;\n\nint main()\n{\n    i64 i , j , k , l , n , m , e , t ;\n\n    scanf(\"%lld %lld %lld\",&n,&e,&t) ;\n    for(i=1; i<=n ; i++) scanf(\"%lld\",&x[i]) ;\n\n    x[0] = 0 ; x[n+1] = e ;\n\n    dp[0] = 0 ;\n    mn[0] = -x[0]-2*x[1] + dp[0] ;\n    dq.push_front( mp(0,0) ) ;\n\n    i64 last = 0 ;\n\n    for(i=1 ; i<=n ; i++)\n    {\n        while( last < i && 2*(x[i]-x[last+1]) > t )\n        {\n            if( !dq.empty() && dq.back().yy==last ) dq.pop_back() ;\n            last++ ;\n        }\n        dp[i] = dp[i-1] + x[i]-x[i-1] + t ;\n        if(last>0) dp[i] = min( dp[i] , 3*x[i] + mn[last-1] ) ;\n        if( !dq.empty() ) dp[i] = min( dp[i] , x[i]+dq.back().xx+t ) ;\n\n        mn[i] = min( mn[i-1] , dp[1]-x[1]-2*x[i+1] ) ;\n\n        while( !dq.empty() && dq.front().xx >= dp[i]-x[i] ) dq.pop_front() ;\n        dq.push_front( mp( dp[i]-x[i],i ) ) ;\n    }\n\n    for(i=1 ; i<=n ; i++) printf(\"%lld\\n\",dp[i]) ;\n\n    printf(\"%lld\\n\",dp[n]+x[n+1]-x[n]) ;\n\n    return 0 ;\n}\n/*\n4 20 3\n3 5 14 19\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234567;\nlong long dp[N], dp1[N];\nlong long x[N];\nlong long const INF = 1LL << 60;\nint const T = 1 << 20;\n\nlong long f[T + T + 5];\n\nvoid setit(int x, long long y) {\n  x += T;\n  f[x] = y;\n  while (x > 1) {\n    x >>= 1;\n    f[x] = std::min(f[x + x], f[x + x + 1]);\n  }\n}\n\nlong long getmin(int l, int r) {\n  l += T;\n  r += T;\n  long long ret = INF;\n  while (l <= r) {\n    if (l & 1) ret = std::min(ret, f[l++]);\n    if (~r & 1) ret = std::min(ret, f[r--]);\n    l >>= 1;\n    r >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n  int n, ex, T;\n  scanf(\"%d%d%d\", &n, &ex, &T);\n  for (int i = 1; i <= n; i++) {\n    int y;\n    scanf(\"%d\", &y);\n    x[i] = y;\n  }\n  for (int i = 0; i <= n; i++) {\n    dp[i] = INF;\n  }\n  dp[0] = 0;\n  x[0] = 0;\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = i + 1; j <= n; j++) {\n  //     long long first = dp[i] + x[i + 1] - x[i] + T;\n  //     long long last = dp[i] + x[j] - x[i];\n  //     long long back = last + x[j] - x[i + 1];\n  //     back = std::max(back, first);\n  //     last = back + x[j] - x[i + 1];\n  //     dp[j] = std::min(dp[j], last);\n  //   }\n  // }\n  dp1[0] = 0 - x[0] - 2 * x[1];\n  for (int i = 0; i <= n; i++) setit(i, INF);\n  setit(0, 0);\n  for (int i = 1, w = 0; i <= n; i++) {\n    while (w < i && 2 * (x[i] - x[w + 1]) > T) ++w;\n    if (w > 0) {\n      // printf(\"%d %lld\\n\", i, 3LL * x[i] + dp1[w - 1]);\n      dp[i] = std::min(dp[i], 3LL * x[i] + dp1[w - 1]);\n    }\n    dp[i] = std::min(dp[i], x[i] + T + getmin(w, i - 1));\n    dp1[i] = std::min(dp[i] - x[i] - 2 * x[i + 1], dp1[i - 1]);\n    setit(i, dp[i] - x[i]);\n    // printf(\"%lld\\n\", dp[i]);\n  }\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = i + 1; j <= n; j++) {\n  //     dp[j] = std::min(dp[j], std::max<long long>(2 * (x[j] - x[i + 1]), T) + x[j] - x[i] + dp[i]);\n  //   }\n  //   printf(\"%lld\\n\", dp[i + 1]);\n  // }\n  // for (int i = 0; i < n; i++) {\n  //   long long end = (long long) i * T + x[n - 1];\n  //   long long next = std::max(end + x[n - 1] - x[i], x[i] + (long long) (i + 1) * T);\n  //   ans = std::min(ans, next + ex - x[i]);\n  // }\n  printf(\"%lld\\n\", ex - x[n] + dp[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[2222];\nLL ans;\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tif(n > 2222) { return 1; }\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tinc1(i, n) {\n\t\tans += x[i] - x[i - 1];\n\t\t\n\t\tint jj = i;\n\t\tincII(j, i, n) {\n\t\t\tLL l = x[j] - x[i];\n\t\t\tLL w = l + t * (j - i + 1);\n\t\t\tLL b = l + max(2 * l, t);\n\t\t\tif(w < b) { break; }\n\t\t\tjj = j;\n\t\t}\n\t\tLL l = x[jj] - x[i];\n\t\tLL w = l + t * (jj - i + 1);\n\t\tLL b = l + max(2 * l, t);\n\t\tans += min(w, b);\n\t\t\n\t\ti = jj;\n\t}\n\tans += e - x[n];\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[2010];\nint x[2010];\nint n,e;\nlong long t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=4e18;\n\t\tfor(int j=0;j+1<i;j++)\n\t\t{\n\t\t\tdp[i]=min(dp[i],dp[j]+x[i]-x[j]+max(2LL*(x[i]-x[j+1]),t));\n\t\t}\n\t\tdp[i]=min(dp[i],dp[i-1]+x[i]-x[i-1]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20;\nll n, t, e, x[maxn], dp[maxn];\nint main() {\n\tdp[0] = x[0] = 0;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tint j = 0;\n\tmultiset<ll> p, s;\n\tfor(int j = 1, i = 1; i <= n; i++) {\n\t\twhile(2*(x[i]-x[j]) > t) {\n\t\t\ts.erase(s.find(dp[j-1] - x[j] + (x[j] - x[j-1])));\n\t\t\tp.insert(dp[j-1] - 3ll*x[j] + (x[j] - x[j-1]));\n\t\t\t//cout << j << \" p \" << (dp[j-1] - 3ll*x[j] + (x[j] - x[j-1])) << '\\n';\n\t\t\tj++;\n\t\t}\n\t\tdp[i] = dp[i - 1] + (x[i] - x[i-1]) + t;\n\t\tif(!s.empty()) dp[i] = min(dp[i], *s.begin() + x[i] + t);\n\t\tif(!p.empty()) dp[i] = min(dp[i], *p.begin() + 3ll*x[i]);\n\t\ts.insert(dp[i-1] - x[i] + (x[i] - x[i-1]));\n\t\t//cout << i << \" s \" << (dp[i-1] - x[i] + (x[i] - x[i-1])) << '\\n';\n\t\t//cout << i << \" \" << dp[i] << \" \" << x[i] << \" \" << t << \"\\n\";\n\t}\n\tcout << dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nconst int N=1e5+5;\ntypedef long long LL;\nint n,E,T,p[N];\nLL dp[N];\nint q[N],h,t;\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",p+i),dp[i]=0x7fffffffffffffff;\n\tint pre=0,mpos=0;\n\tfor(int i=1;i<=n;++i){\n\t\tconst int TL=T-2*p[i];\n\t\twhile(h<t&&TL<=-2*p[q[h]+1])++h;\n\t\tint j=q[h];\n\t\tdp[i]=dp[j]-p[j]+std::max(TL,-2*p[j+1])+3LL*p[i];\n\t\twhile(pre<i&&TL<=-2*p[pre+1]){\n\t\t\tif(dp[mpos]-p[mpos]-2LL*p[mpos+1]>dp[pre]-p[pre]-2LL*p[pre+1])\n\t\t\tmpos=pre;\n\t\t\t++pre;\n\t\t}\n\t\tj=mpos;\n\t\tdp[i]=std::min(dp[i],dp[j]-p[j]+std::max(TL,-2*p[j+1])+3LL*p[i]);\n\t\twhile(h<=t&&dp[q[t]]-p[q[t]]>=dp[i]-p[i])--t;\n\t\tq[++t]=i;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+E-p[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define X first\n#define Y second\nusing namespace std;\nconst int max_n = 1e6 + 20, inf = 1e12;\nint a[max_n], DP[max_n];\npair<int, int> seg[max_n * 4], seg2[max_n * 4];\nint n, e, t, INF = 1e12, L;\npair<int, int> Merge(pii x, pii y) {\n    return min(x , y);\n}\nvoid update(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg[id].X = val;\n        seg[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update(x, val, mid, e, id << 1 | 1);\n    else\n        update(x, val, b, mid, id << 1);\n    seg[id] = Merge(seg[id << 1 | 1], seg[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, 0};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get(l, r, b, mid, id << 1), get(l, r, mid, e, id << 1 | 1));\n}\nvoid update2(int x, int val, int b = 0, int e = n, int id = 1) {\n    if (e - b == 1) {\n        seg2[id].X = val;\n        seg2[id].Y = x;\n     //   cout << id << \">>>>>>>>>\" << val << \"   \";\n        return;\n    }\n    int mid = e + b >> 1;\n    if (x >= mid)\n        update2(x, val, mid, e, id << 1 | 1);\n    else\n        update2(x, val, b, mid, id << 1);\n    seg2[id] = Merge(seg2[id << 1 | 1], seg2[id << 1]);\n   // cout << endl;\n   // cout << (id << 1)<< \" BBBBBBB \" << seg[id << 1].X << endl;\n}\npii get2(int l, int r, int b = 0, int e = n, int id = 1) {\n //   cout << \"A\";\n    if (e <= l || r <= b)\n        return {INF, 0};\n    if (l <= b && e <= r) {\n      //  cout << \"              \" << seg[id].Y << endl;\n        return seg2[id];\n    }\n    int mid = b + e >> 1;\n    return Merge(get2(l, r, b, mid, id << 1), get2(l, r, mid, e, id << 1 | 1));\n}\nvoid out() {\n    for (int i = 1; i < n * 4; i++)\n        cout << seg[i].Y << \">>>>>\" << seg[i].X << \"   \";\n    cout << endl;\n}\nvoid solve() {\n    for (int i = 1; i < n; i++) {\n        int tmp = (lower_bound(a, a + n, a[i] - L) - a);\n        pii x = get(tmp, i), y = get2(0, tmp);\n        //cout << tmp << endl;\n        DP[i] = min(x.X + t, y.X + 2 * a[i]) + a[i];\n        DP[i] = min(DP[i] , DP[i - 1] + a[i] - a[i - 1] + t);\n    //    cout << DP[i] << endl;\n        update(i, DP[i - 1] - a[i - 1]);\n        update2(i, DP[i - 1] - a[i - 1] - (2 * a[i]));\n      //  cout << endl;\n        //out();\n    }\n}\nint32_t main() {\n    cin >> n >> e >> t;\n    L = (t) / 2;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    for (int i = 0; i < n * 4; i++)\n        seg[i].X = inf, seg2[i].X = inf;\n    DP[0] = a[0] + t;\n    update(0, 0);\n    update2(0, 0);\n    solve();\n    cout << DP[n - 1] + (e - a[n - 1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef  long long int ll;\nconst int maxn=200005;\nconst ll inf = (1LL<<60) - 1;\n\nint n,e,t,p[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n  //  freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i] + t;\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+1000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100002;\n\ntemplate<class T, int SZ> struct LazySegTree {\n    T sum[2*SZ], mn[2*SZ], lazy[2*SZ]; // set SZ to a power of 2\n    \n    LazySegTree() {\n        memset (sum,0,sizeof sum);\n        memset (mn,0,sizeof mn);\n        memset (lazy,0,sizeof lazy);\n    }\n    \n    void push(int ind, int L, int R) {\n        sum[ind] += (R-L+1)*lazy[ind];\n        mn[ind] += lazy[ind];\n        if (L != R) lazy[2*ind] += lazy[ind], lazy[2*ind+1] += lazy[ind];\n        lazy[ind] = 0;\n    }\n    \n    void pull(int ind) {\n        sum[ind] = sum[2*ind]+sum[2*ind+1];\n        mn[ind] = min(mn[2*ind],mn[2*ind+1]);\n    }\n    \n    void build() {\n        F0Rd(i,SZ) pull(i);\n    }\n    \n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {\n        push(ind,L,R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        \n        int M = (L+R)/2;\n        return qsum(lo,hi,2*ind,L,M) + qsum(lo,hi,2*ind+1,M+1,R);\n    }\n\n    T qmin(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {\n        push(ind,L,R);\n        if (lo > R || L > hi) return INF;\n        if (lo <= L && R <= hi) return mn[ind];\n        \n        int M = (L+R)/2;\n        return min(qmin(lo,hi,2*ind,L,M), qmin(lo,hi,2*ind+1,M+1,R));\n    }\n    \n    void upd(int lo, int hi, ll inc, int ind = 1, int L = 0, int R = SZ-1) {\n        push(ind,L,R);\n        if (hi < L || R < lo) return;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind,L,R);\n            return;\n        }\n        \n        int M = (L+R)/2;\n        upd(lo,hi,inc,2*ind,L,M); upd(lo,hi,inc,2*ind+1,M+1,R);\n        pull(ind);\n    }\n};\n\nLazySegTree<ll,1<<17> L[2]; // ctime\nint N,E,T,X[MX],y;\n\nvoid solve(int x) {\n    L[0].upd(0,x,X[x]-X[x-1]); \n    L[1].upd(0,x,X[x]-X[x-1]); \n    \n    // y to x-1: ctime+T\n    // 0 to y-1: ctime+2*(X[x]-X[i])\n    while (2*(X[x]-X[y]) > T) y ++;\n    ll a = L[0].qmin(y,x)+T, b = L[1].qmin(0,y-1)+2*X[x];\n    ll val = min(a,b);\n    // cout << \"HI \" << x << \" \" << y << \" \" << a << \" \" << b << \" \" << val << \"\\n\";\n    L[0].upd(x+1,x+1,val); L[1].upd(x+1,x+1,val);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    cin >> X[N+1] >> T;\n    FOR(i,1,N+1) cin >> X[i];\n    F0R(i,N+2) L[1].upd(i,i,-2*X[i]);\n    FOR(i,1,N+2) solve(i);\n    cout << L[0].qmin(N+1,N+1) << \"\\n\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200200;\nlong long f[maxn], x[maxn];\nint main(){\n\tint n, E, T;\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tmultiset<long long> small, bigger;\n\tint j = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\twhile(j < i && 2*(x[i] - x[j]) > T){\n\t\t\tsmall.erase(small.find(f[j - 1]));\n\t\t\tbigger.insert(f[j - 1] - 2 * x[j]);\n\t\t\tj++;\n\t\t}\n\t\tf[i] = T + f[i - 1];\n\t\tif(!small.empty()) f[i] = min(f[i], *small.begin() + T);\n\t\tif(!bigger.empty()) f[i] = min(f[i], *bigger.begin() + 2 * x[i]);\n\t\tsmall.insert(f[i - 1]);\n\t}\n\tcout << f[n] + E << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nint main() {\n  int n, e, t;\n  cin >> n >> e >> t;\n  vl x(n + 1);\n  rep1 (i, n) cin >> x[i];\n\n  vl dp(n + 1, INF);\n\n  set<pll> near, far;\n  dp[0] = 0;\n  near.insert(pll(0, 0));\n  rep1 (i, n) {\n    while (near.size() > 0) {\n      auto itr = near.begin();\n      ll val = itr->first, j = itr->second;\n      if (2*(x[i] - x[j + 1]) >= t) {\n        near.erase(near.begin());\n        far.insert(pll(dp[j] - x[j] - 2*x[j + 1], j));\n      }\n      else {\n        dp[i] = dp[j] - x[j] + x[i] + t;\n        break;\n      }\n    }\n    if (far.size() > 0) {\n      auto itr = far.begin();\n      ll val = itr->first, j = itr->second;\n      chmin(dp[i], val + 3 * x[i]);\n    }\n    /*\n    DEBUG(\"near\");\n    for (auto itr = near.begin(); itr != near.end(); itr++) DEBUG(*itr);\n    DEBUG(\"far\");\n    for (auto itr = far.begin(); itr != far.end(); itr++) DEBUG(*itr);\n    //*/\n    near.insert(pll(dp[i] - x[i], i));\n  }\n  //DEBUG_VEC(dp);\n  cout << dp[n] + e - x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 2020;\nconst ll inf = 1e18;\nint n, e, t, x[maxn];\nll dp[maxn];\n\nint main(){\n    scanf(\"%d%d%d\", &n, &e, &t);\n\n    if(n > maxn){\n        return 0;\n    }\n\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d\", x + i);\n\n        dp[i] = inf;\n\n        for(int j = 0; j < i; j++){\n            ll d = x[i] - x[j + 1];\n            dp[i] = min(dp[i], dp[j] + (x[i] - x[j]) + 2 * d + max(0ll, t - 2 * d));\n        }\n    }\n\n    printf(\"%lld\\n\", dp[n] + e - x[n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:60777216\")  \n\n#include <cassert>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<complex>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<cstdlib>\n#include<memory.h>\n#include<ctime>\n#include<bitset>\n#include<fstream>\n#include<queue>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef long double ld;\n\ntypedef long long ll;\ntypedef pair<int,int>\tpii;\ntypedef pair<ld,ld>\tpdd;\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef pair<ll,ll> pl;\n\n#define FOR(i,a,b)\t\tfor(int i=(a);i<(b);i++)\n#define REP(i,n)\t\tFOR(i,0,n)\n#define SORT(v)\t\t\tsort((v).begin(),(v).end())\n#define UN(v)\t\t\tSORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)\t\t\t\tmemset(a,b,sizeof a)\n#define pb\t\t\t\tpush_back\n\nint n,e,t;\nint x[222222];\n\n\nll  r[222222];\nint p[222222];\n\nll solve(int from,int to){\n\treturn max(0ll+x[to] - x[from]+x[to]-x[from+1],0ll+x[from+1]-x[from]+t)+x[to]-x[from+1];\n}\n\nint main(){\t\n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>e>>t;\n\tREP(i,n)scanf(\"%d\",x+i+1);\n\tFOR(i,1,n+1){\n\t\tr[i]=1e18;\n\t\tREP(prev,i)r[i]=min(r[i],r[prev]+solve(prev,i));\n\t/*\tint prev = p[i-1];\n\t\tr[i] = r[prev] + solve(prev,i);\n\t\twhile(prev+1<i && r[i] > r[prev+1]+solve(prev+1,i)){\n\t\t\tprev++;\n\t\t\tr[i] = r[prev] + solve(prev,i);\n\t\t}\n\t\tp[i] = prev;*/\n\t}\n\n\tcout<<r[n]+e-x[n]<<endl;\n\n\n\n#ifdef LocalHost\n\tprintf(\"TIME: %.3lf\\n\",ld(clock())/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:60777216\")  \n\n#include <cassert>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<complex>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<cstdlib>\n#include<memory.h>\n#include<ctime>\n#include<bitset>\n#include<fstream>\n#include<queue>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef long double ld;\n\ntypedef long long ll;\ntypedef pair<int,int>\tpii;\ntypedef pair<ld,ld>\tpdd;\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef pair<ll,ll> pl;\n\n#define FOR(i,a,b)\t\tfor(int i=(a);i<(b);i++)\n#define REP(i,n)\t\tFOR(i,0,n)\n#define SORT(v)\t\t\tsort((v).begin(),(v).end())\n#define UN(v)\t\t\tSORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)\t\t\t\tmemset(a,b,sizeof a)\n#define pb\t\t\t\tpush_back\n\nint n,e,t;\nint x[222222];\n\n\nll  r[222222];\nint p[222222];\n\nll solve(int from,int to){\n\treturn max(0ll+x[to] - x[from]+x[to]-x[from+1],0ll+x[from+1]-x[from]+t)+x[to]-x[from+1];\n}\n\nint main(){\t\n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>e>>t;\n\tREP(i,n)scanf(\"%d\",x+i+1);\n\tFOR(i,1,n+1){\n\t\tint prev = p[i-1];\n\t\tr[i] = r[prev] + solve(prev,i);\n\t\twhile(prev+1<i && r[i] > r[prev+1]+solve(prev+1,i)){\n\t\t\tprev++;\n\t\t\tr[i] = r[prev] + solve(prev,i);\n\t\t}\n\t\tp[i] = prev;\n\t}\n\n\tcout<<r[n]+e-x[n]<<endl;\n\n\n\n#ifdef LocalHost\n\tprintf(\"TIME: %.3lf\\n\",ld(clock())/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=100005;\nlong long dp[M];\nint P[M];\nint n,e,t;\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",P+i);\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(t<=2*(P[j]-P[i+1]))\n\t\t\t\tdp[j]=min(dp[j],dp[i]+P[j]-P[i]+2*(P[j]-P[i+1]));\n\t\t\telse\n\t\t\t\tdp[j]=min(dp[j],dp[i]+P[j]-P[i]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e-P[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nconst int INF = 2e18;\n\nint N, E, T;\nint x[100010];\n\nint dp[2010]; // dp[i] = i番目まで(inclusiv)を全て回収するのにかかるコスト\n\nsigned main(){\n    while(cin >> N >> E >> T){\n        if(N > 2000) return 1;\n        rep(i,2010) dp[i] = INF;\n        rep(i,N) cin >> x[i];\n        x[N] = E;\n\n        dp[0] = 0;\n        rep(i,N){\n            int premove = x[i] - (i == 0 ? 0 : x[i-1]);\n            // dump(premove);\n            for(int j = i; j < N; ++j){\n                int dist = x[j] - x[i];\n                int cost = max(T, dist*2) + dist;\n                dp[j+1] = min(dp[j+1], dp[i] + premove + cost);\n            }\n        }\n        cout << dp[N] + E - x[N-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, E;\n\nI64\t\tT, X[n], F[n];\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tE= IN();\n\t\tT= IN();\n\t\tFor(i, 1, N)\tX[i]= IN();\n\t\t\n\t\tFor(i, 1, N)\t{\n\t\t\tF[i]= 1ll << 60;\t\n\t\t\tFor(j, 1, i)\tF[i]= min(F[i], F[j-1] + X[j] - X[j-1] + max(T, (X[i] - X[j])*2) + (X[i] - X[j]));\n\t\t}\n\t\t\n\t\tcout << F[N] + E - X[N] << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = 0;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\t//cout << idxmin << endl;\n\t\tfor( size_t i = idxmin; i < N + 1; i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t\t//DP[now + 1] = min( DP[now + 1], DP[now] + X[now + 1] - X[now] + T );\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n\t/*\n\tfor( size_t i = 0; i < N + 2; i++ ) {\n\t\tcout << DP[i] << \" \";\n\t}\n\tcout << endl;\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  const int N = 100000 + 10;\n  int n;\n  lli e, t;\n  while (cin >> n >> e >> t) {\n    lli x[N];\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i + 1];\n    }\n    x[0] = 0;\n    x[n+1] = e;\n    lli dp[N];\n    for (int i = 0; i <= n; ++i) {\n      dp[i] = i * t;\n    }\n\n    // dp[i] := i番目を拾い終えたときの最適値\n    \n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j < i; ++j) {\n        // jまで拾い終えていてiまで全部拾う。\n        dp[i] = min(dp[i], dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n      }\n    }\n\n    cout << dp[n] + e << endl;\n  }\n  \n  return 0;\n}\n\n\n// #include <bits/stdc++.h>\n\n// #define each(i, c) for (auto& i : c)\n// #define unless(cond) if (!(cond))\n\n// using namespace std;\n\n// typedef long long int lli;\n// typedef unsigned long long ull;\n// typedef complex<double> point;\n\n// template<typename P, typename Q>\n// ostream& operator << (ostream& os, pair<P, Q> p)\n// {\n//   os << \"(\" << p.first << \",\" << p.second << \")\";\n//   return os;\n// }\n\n// int main(int argc, char *argv[])\n// {\n//   const int N = 100000 + 10;\n//   int n;\n//   lli e, t;\n//   while (cin >> n >> e >> t) {\n//     lli x[N];\n//     for (int i = 0; i < n; ++i) {\n//       cin >> x[i];\n//     }\n//     x[n] = e;\n\n//     lli dp[N];\n//     fill(dp, dp + N, 1LL << 60);\n//     dp[0] = 0;\n\n//     lli mn = 1LL << 60;\n//     for (int i = 0, j = -1; i < n; ++i) {\n//       while (t < 2 * (x[i] - x[j + 1])) {\n//         mn = min(mn, dp[j] - 2 * x[j + 1]);\n//         ++j;\n//       }\n//       dp[i] = min(dp[j] + t, 2 * x[i] + mn);\n//     }\n//     cout << dp[n - 1] + e << endl;\n//   }\n//   return 0;\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n} \nconst int N = 2e5+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, t, e, px[N];\nint64 f[N], w = INF;\nint main()\n{\n    n = read(), e = read(), t = read();\n    for(int i = 1; i <= n; ++i) px[i] = read();\n    for(int i = 1, j = 0; i <= n; ++i)\n    {\n        while(2*(px[i]-px[j+1]) >= t) w = min(f[j]-2*px[j+1], w), ++j;\n        f[i] = min(w+2*px[i], f[j]+t);\n    }\n    printf(\"%lld\\n\", f[n]+e);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    if (N>2000)\n        return 0;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n        for (int j=1; j<i; j++)\n            A[i] = min(A[i], A[j-1]+(x[i]-x[j-1])+(x[i]-x[j])*2+max(0, T-(x[i]-x[j])*2));\n    }\n\n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n#define MP make_pair \n#define PB push_back \n#define INF (1000000007) \n#define eps 1e-8\n#define MOD (1000003)\n#define IOS ios::sync_with_stdio(false)\n\ntypedef pair<int,int> pii ;\ntypedef pair<double,double> pdd ;\ntypedef long long ll ;\n\nll n,e,t;\nll dp[100005],p[100005];\nll mx=-1;\nmultiset<ll>s;\n\nint main()\n{\n\tIOS;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tdp[0]=0;\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif((p[i]-p[pos])*2>t) \n\t\t\t{\n\t\t\t\tif(mx==-1) mx=dp[pos-1]-p[pos]*2;\n\t\t\t\telse mx=min(dp[pos-1]-p[pos]*2,mx);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mx+2*p[i]);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nLL t;\nstruct UnionFind{\n    vector<int> par;\n    vector<LL> w;\n    UnionFind(int n){\n        par = vector<int>(n,-1);\n        w=vector<LL>(n,0);\n    }\n    int root(int x){\n        if(par[x]<0){\n            return x;\n        }else{\n            return par[x]=root(par[x]);\n        }\n    }\n    void unite(int x,int y, LL a){\n        x=root(x);\n        y=root(y);\n        if(x!=y){\n            if(par[x]<par[y]) swap(x,y);\n            par[y] += par[x];\n            par[x] = y;\n        }\n        w[y]=w[y]+w[x]+a;\n        return;\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    int size(int x){\n        return -par[root(x)];\n    }\n    LL rest(int x){\n        return max(0ll,t-w[root(x)]);\n    }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    LL e;\n    cin >> n >> e >> t;\n    LL ans=e;\n    vector<int> x(n),dx(n-1);\n    REP(i,n) cin >> x[i];\n    REP(i,n-1) dx[i]=(x[i+1]-x[i])*2;\n    UnionFind P(n);\n    typedef tuple<LL,LL,LL> TP;//cost,l,r\n    priority_queue<TP> Q;\n    REP(i,n-1){\n        Q.push(make_tuple(min(t,2*t-dx[i]),i,i+1));\n    }\n    while(!Q.empty() && get<0>(Q.top())>0){\n        LL c,l,r;\n        tie(c,l,r)=Q.top();\n        //cerr<< c << ' ' << l << ' ' << r << endl;\n        Q.pop();\n        if((l==0 && !P.same(r,r+1)) || (r==n-1 && !P.same(l-1,l)) || (!P.same(l-1,l) && !P.same(r,r+1))){\n            P.unite(l,r,dx[l+P.size(l)-1]);\n            if(r!=n-1){\n                int newr=r+P.size(r+1);\n                LL r1=P.rest(l),r2=P.rest(newr);\n                Q.push(make_tuple(min(t,r1+r2-dx[r]),l,newr));\n            }\n            if(l!=0){\n                int newl=l-P.size(l-1);\n                LL r1=P.rest(r),r2=P.rest(newl);\n                Q.push(make_tuple(min(t,r1+r2-dx[l-1]),newl,r));\n            }\n        }\n    }\n\n\n    REP(i,n){\n        if(P.par[i]<0)ans+=max(t,P.w[i]);\n    }\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    LazySegmentTree seg1(vector<ll>(N+1,0)),seg2(vector<ll>(N+1,0));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.add(0,1,dp[0]-X[1]);\n    seg2.add(0,1,dp[0]-3*X[1]);\n    for(int i=1;i<=N+1;i++){\n        dp[i] = dp[i-1]+X[i+1]-X[i]+T;\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        cerr << i << \" \" << id << endl;\n        if(id<i) dp[i] = min(dp[i],seg1.getmin(id,i)+T+X[i+1]);\n        if(id>=i-1) id = i-1;\n        dp[i] = min(dp[i],seg2.getmin(0,id)+2*X[i]+X[i+1]);\n        seg1.add(i,i+1,dp[i]-X[i+1]);\n        seg2.add(i,i+1,dp[i]-3*X[i+1]);\n    }\n//    for(int i=0;i<=N+1;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n\n#define llint long long int\n#define N 2100\n#define MAX(x,y) ((x)<(y)?(y):(x))\n\nint main(void){\n  int n,e,t;\n  //std::priority_queue<int, std::vector<int>, std::greater<int> > x;\n  int x[N];\n  llint total = 0;\n  int now = 0;\n  \n  std::cin >> n >> e >> t;\n\n  //int temp;\n  for(int i=1; i<=n; i++){\n    std::cin >> x[i];\n    //  std::cin >> temp;\n    //    x.push(temp);\n  }\n\n  for(int i=1; i<=n; i++){\n    int nnext = i;\n    while(1){\n      if(x[nnext+1] - x[i] <= t and nnext != n){\n\tnnext++;\n      }else break;\n    }\n\n    \n    total += (x[i]-now) + MAX(0, t-2*(x[nnext]-x[i])) + 3*(x[nnext]-x[i]);\n    i = nnext;\n    now = x[nnext];\n  }\n  std::cout << (total+e-x[n]) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <queue>\n#include <ctime>\n#include <string>\n#include <cstring>\n#define mp make_pair\n#define pb push_back\n#define NAME \"\"\n#define y1 y1_423\n#define list lista\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const vector<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"()\");\n\t}\n\tcout << \"(\" << a[0];\n\tfor (int i = 1; i < (int)a.size(); i++) {\n\t\tcout << \"; \" << a[i];\n\t}\n\treturn (cout << \")\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const set<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream& cout, const multiset<T> &a) {\n\tif ((int)a.size() == 0) {\n\t\treturn (cout << \"{}\");\n\t}\n\tauto it = a.begin();\n\tcout << \"{\" << *it;\n\t++it;\n\tfor (; it != a.end(); ++it) {\n\t\tcout << \"; \" << *it;\n\t}\n\treturn (cout << \"}\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& cout, const pair<T1, T2> &a) {\n\treturn cout << \"(\" << a.first << \"; \" << a.second << \")\";\n}\n\nconst int nmax = 2000 * 1000;\nconst int inf = 2000 * 1000 * 1000;\nconst ll infl = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nconst int mod = 1000 * 1000 * 1000 + 7;\nconst ld pi = acos(-1.0);\n\nint n;\nll e, t, x[nmax], dp[nmax];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(NAME\".in\", \"r\", stdin);freopen(NAME\".out\", \"w\", stdout);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &x[i]);\n\t}\n\tx[0] = 0;\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = infl;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 1; j <= n - i; j++) {\n\t\t\tdp[i + j] = min(dp[i + j], dp[i] + max(t, (x[i + j] - x[i + 1]) * 2) - x[i] + x[i + j]);\n\t\t}\n\t}\n\tcout << dp[n] + e - x[n];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <memory>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nstruct segment_tree_min {\n\tint n; vector<ll> v;\n\tsegment_tree_min(int _n) {\n\t\tfor (n = 1; n < _n; n *= 2);\n\t\tv = vector<ll>(n * 2 - 1, LLONG_MAX / 10);\n\t}\n\tvoid set(int i, ll x) {\n\t\tint k = i + n - 1;\n\t\tv[k] = x;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tv[k] = min(v[k * 2 + 1], v[k * 2 + 2]);\n\t\t}\n\t}\n\tll _get(int i, int j, int k, int l, int r) {\n\t\tif (r <= i || j <= l) return LLONG_MAX / 10;\n\t\tif (i <= l && r <= j) return v[k];\n\t\tll vl = _get(i, j, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = _get(i, j, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tll get(int i, int j) { return _get(i, j, 0, 0, n); }\n};\n\nint main() {\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<ll> dp(N + 1);\n\tdp[0] = 0;\n\tsegment_tree_min st1(N + 1), st2(N + 1);\n\tst1.set(0, 0); st2.set(0, - x[0] * 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll ans = LLONG_MAX / 10;\n\t\tint lb = -1, ub = i - 1;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif ((x[i - 1] - x[mid]) * 2 <= T) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tint l = ub;\n\t\tans = min(ans, st1.get(l, i) + T);\n\t\tans = min(ans, st2.get(0, l) + x[i - 1] * 2);\n\t\tdp[i] = ans;\n\t\tst1.set(i, ans);\n\t\tif (i < N) st2.set(i, ans - x[i] * 2);\n\t}\n\tcout << dp[N] + E << endl;\n\treturn 0;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tdp[j] = min(dp[j], dp[i] + max(T, (x[j - 1] - x[i]) * 2));\n\tcout << dp[N] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n;\nlli gl,t;\n\nlli dat[100005]={};\nlli dp[100005]={};\n\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&gl,&t);\n\treg(i,1,n)scanf(\"%lld\",&dat[i]);\n\tdat[0]=0;\n\tdp[0]=0;\n\tif(n>2005)return 0;\n\treg(i,1,n){\n\t\tdp[i]=dp[i-1]+t;\n\t\trep(j,i){\n\t\t\tdp[i]=min(dp[i],dp[j]+max(2*(dat[i]-dat[j+1]),t));\n\t\t}\n\t\t//printf(\"dp[%d] .. %lld\\n\",i,dp[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\",gl+dp[n]);\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t;\nll dp[maxn];\nint x[maxn],y[maxn];\nclass segtree{\npublic:\n\tll tree[maxn*4];\n\tint leaf[maxn];\n\tvoid build(int l,int r,int node){\n\t\tif(l==r){\n\t\t\tleaf[l]=node;\n\t\t\ttree[node]=Inf;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,node*2);\n\t\tbuild(mid+1,r,node*2+1); \n\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t}\n\tvoid upd(int node,ll val){\n\t\tnode=leaf[node];\n\t\ttree[node]=val;\n\t\tnode>>=1;\n\t\twhile(node){\n\t\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t\t\tnode>>=1;\n\t\t}\n\t}\n\tll query(int l,int r,int vl,int vr,int node){\n\t\tif(r<l||vr<vl)return Inf;\n\t\tif(l>vr||r<vl)return Inf;\n\t\tif(l>=vl&&r<=vr)return tree[node];\n\t\tint mid=(l+r)>>1;\n\t\treturn min(query(l,mid,vl,vr,node*2),query(mid+1,r,vl,vr,node*2+1));\n\t}\n}t1,t2;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]),y[i]=2*x[i];\n\tt1.build(0,n-1,1);\n\tt2.build(0,n-1,1);\n\trep(i,n){\n\t\tdp[i]=max((x[i]-x[0])*2LL,1LL*t);\n\t\tint pos=lower_bound(y,y+n,2*x[i]-t)-y;\n\t\tdp[i]=min(dp[i],min(t1.query(0,n-1,0,pos-2,1)+2LL*x[i],t2.query(0,n-1,max(pos-1,0),n-1,1)+t));\n\t\tt1.upd(i,dp[i]-2LL*x[i+1]);\n\t\tt2.upd(i,dp[i]);\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 1e5 + 10;\nint n , T , E;\nint a[maxn];\nll dp[maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> E >> T;\n    for(int i = 1 ; i <= n ; ++i)cin >> a[i];\n    int j = 0;ll pref = 1e18;\n    for(int i = 1 ; i <= n ; ++i){\n        dp[i] = 1e18;\n        while(j < i && 2 * (a[i] - a[j + 1]) > T){\n            pref = min(pref,dp[j]-2*a[j + 1]);\n            ++j;\n        }\n        dp[i] = min(pref+2*a[i],dp[j]+T);\n//        cout << dp[i] << \" \";\n    }\n    cout << dp[n] + E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre;\nint64 T,E;\nint64 x[100005];\nint N,p;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 1e18;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(p < i - 1 && 2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tif(p != -1) dp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front() + 1]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mini=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[j]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstatic const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\n\nvoid solve() {\n        long long n, e, t;\n        cin >> n >> e >> t;\n        assert(n <= 2000);\n        vector<long long> x(n);\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        vector<long long> dp(n, INFL);\n        dp[0] = t;\n        for (int i = 1; i < n; i ++) {\n                for (int j = 0; j < i; j ++) dp[i] = min(dp[i], dp[j] + max(t, 2 * (x[i] - x[j + 1])));\n                dp[i] = min(dp[i], max(t, 2 * (x[i] - x[0])));\n        }\n        cout << dp[n - 1] + e << endl;\n        return;\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tfor (int x=now+1; x<=n; ++x){\n\t\t\tlong long tmp=0;\n\t\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t\t}\n\t\t\telse f[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst LL Infll = 0x3f3f3f3f3f3f3f3f;\nconst int MN = 200005;\n\nint N, E, T, A[MN];\nLL f[MN], g[MN];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tg[0] = Infll;\n\tfor (int i = 1, j = 1; i <= N; ++i) {\n\t\twhile (2 * (A[i] - A[j]) > T) ++j;\n\t\tf[i] = std::min(f[j - 1] + T, 2 * A[i] + g[j - 1]);\n\t\tg[i] = std::min(g[i - 1], f[i - 1] - 2 * A[i]);\n\t}\n\tprintf(\"%lld\\n\", E + f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n\nusing namespace std;\n\nlong long int N;\nlong long int E;\nlong long int T;\nlong long int dp[200001];\nlong long int place[200001];\n\nlong long int min(long long int a, long long int b) {\n\tif (a > b)return b;\n\treturn a;\n}\n\nlong long int max(long long int a, long long int b) {\n\tif (a > b)return a;\n\treturn b;\n}\n\nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 1; i <= N; i++)cin >> place[i];\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = ULONG_MAX;\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = min(max(place[i] + (place[i] - place[1]) * 2, T + place[i]), T*i + place[i]);\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = max(i,1); j <= N; j++) {\n\t\t\tif (dp[j] == dp[i] + place[j] - place[i])break;\n\t\t\tdp[j] = min(dp[j], dp[i] + max((place[j] - place[i]) * 3, T + place[j] - place[i]));\n\t\t\tdp[j] = min(dp[j], dp[j - 1] + T + place[j] - place[j - 1]);\n\t\t}\n\t}\n\tcout << dp[N] + E - place[N]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N, E, T; cin >> N >> E >> T;\n    vec x(N); cin >> x;\n    assert(N <= 2000);\n\n    mat dp(N, vec(N, INF));\n    dp[0][0] = 0;\n    REP(i, N) dp[0][i] = max(x[0] + T, 2 * x[i] - x[0]);\n    FOR(i, 1, N){\n        int t = dp[i - 1][i - 1] + x[i] - x[i - 1];\n        FOR(j, i, N){\n            dp[i][j] = min(dp[i - 1][j] + x[i] - x[i - 1], max(t + T, t + 2 * (x[j] - x[i])));\n        }\n    }\n    int ans = dp[N - 1][N - 1] + E - x[N - 1];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int SN = 1 << 18;\nconst long long inf = 1e16;\nint n , e , t;\nint x[N];\nlong long cost(int l , int r){\n    long long res = 0;\n    res += x[r] - x[l];\n    res += x[r] - x[l];\n    res = max(res , 1LL * t);\n    res += x[r] - x[l];\n    return res;\n}\nlong long dp[N];\nlong long suf[N];\nlong long dp2[N];\nlong long segtree[SN];\nvoid build(int l , int r , int node){\n    segtree[node] = inf;\n    if(l < r){\n        int mid = l + r >> 1;\n        build(l , mid , node + node);\n        build(mid + 1 , r , node + node + 1);\n    }\n}\nvoid update(int l , int r , int node , int idx , long long value){\n    if(l == r){\n        segtree[node] = value;\n    }\n    else{\n        int mid = l + r >> 1;\n        if(idx <= mid){\n            update(l , mid , node + node , idx , value);\n        }\n        else{\n            update(mid + 1 , r , node + node + 1 , idx , value);\n        }\n        segtree[node] = min(segtree[node + node] , segtree[node + node + 1]);\n    }\n}\nbool check(int i , int j){\n    return 2LL * (x[j] - x[i]) >= t;\n}\nlong long query(int l , int r , int node , int ql , int qr){\n    if(l > qr || r < ql){\n        return inf;\n    }\n    if(l >= ql && r <= qr){\n        return segtree[node];\n    }\n    int mid = l + r >> 1;\n    return min(query(l , mid , node + node , ql , qr) , query(mid + 1 , r , node + node + 1 , ql , qr));\n}\nlong long getmin(int l , int r){\n    return query(1 , n , 1 , l , r);\n}\nint main(){\n    scanf(\"%d %d %d\" , &n , &e , &t);\n    for(int i = 1 ; i <= n ; ++i){\n        scanf(\"%d\" , x + i);\n    }\n    build(1 , n , 1);\n    x[0] = 0;\n    x[n + 1] = e;\n    dp[n + 1] = x[n + 1] - x[n];\n    suf[n + 1] = inf;\n    for(int pos = n ; pos >= 1 ; --pos){\n        dp[pos] = inf;\n        int j;\n        if(!check(pos , n)){\n            j = n + 1;\n        }\n        else{\n            int l = pos;\n            int r = n;\n            while(l < r){\n                int mid = l + r >> 1;\n                if(check(pos , mid)){\n                    r = mid;\n                }\n                else{\n                    l = mid + 1;\n                }\n            }\n            j = l;\n        }\n        dp2[pos] = t + dp[pos + 1] + x[pos];\n        update(1 , n , 1 , pos , dp2[pos]);\n        dp[pos] = min(dp[pos] , getmin(pos , j - 1) - x[pos]);\n        dp[pos] = min(dp[pos] , suf[j] - 3LL * x[pos]);\n        dp[pos] += x[pos] - x[pos - 1];\n        suf[pos] = min(suf[pos + 1] , 3LL * x[pos] + dp[pos + 1]);\n    }\n    printf(\"%lld\\n\" , dp[1]);\n}\n\n    //i  j 2*(x[j] - x[i]) >= t , j min index\n    //k < i t + x[j] - x[i]\n    //k > j 3x[j] - x[i]"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nvector<ll> B;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return e-X[n-1];\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i]))  + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i]))  + dp(mid+2);\n    if(t2 <= t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i]))  + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + dp(r+1);\n\nll edge1 = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i]))  + dp(i+1);\nll edge2 = 3*(X[n-1]-X[i]) + max(0ll , T-2*(X[n-1]-X[i]))  + dp(n);\n\nll ans = min(t1,t2);\nans = min(ans , edge1);\nans = min(ans , edge2);\n//cout << i << \" \" << ans  << \"\\n\";\nans += B[i];\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n    \n    B.push_back(X[0]);\n    \n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n        B.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0) << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e18;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    int n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    \n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=upper_bound(x,x+n+1,(x[i]-T))-x;\n        j--;\n        if(j>=0){\n            dp[i]=dp2[j]+x[i]*2;\n        }\n        \n        dp[i]=min(dp[j]+2*T,dp[i]);\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n       // cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n        \n    }\n    \n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <utility>\n#include <map>\n#include <stack>\n#include <set>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <sstream>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define LB long double\n#define Pair pair<int,int>\n#define LOWBIT(x) x & (-x)\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=100;\n\ninline int getint()\n{\n\tchar ch;\n\twhile ((ch=getchar())<'0' || ch>'9') {}\n\tint res=ch-'0';\n\twhile ((ch=getchar())>='0' && ch<='9') res=res*10+ch-'0';\n\treturn res;\n}\n\nint n,e,T;\nLL a[100048];\npriority_queue<pair<LL,int> > q1,q2;\nLL dp[100048];\n\nint main ()\n{\n\tint i;\n\tn=getint();e=getint();T=getint();\n\tfor (i=1;i<=n;i++) a[i]=(LL)getint();\n\tdp[0]=0;\n\ta[0]=0;\n\tq2.push(mp(a[0]-dp[0],0));\n\t//dp[1]=a[1]+T;\n\t//q2.push(mp(a[1]-dp[1],1));\n\tint num1,num2;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\t\n\t\tbool f=true;\n\t\twhile (!q2.empty() && f)\n\t\t{\n\t\t\tint num=q2.top().y;f=false;\n\t\t\tif (T-2*a[i]+2*a[num+1]<0)\n\t\t\t{\n\t\t\t\tq2.pop();f=true;\n\t\t\t\tq1.push(mp(a[num]+2*a[num+1]-dp[num],num));\n\t\t\t}\n\t\t}\n\t\tLL ans1=LINF,ans2=LINF;\n\t\tif (!q1.empty())\n\t\t{\n\t\t\tnum1=q1.top().y;\n\t\t\tans1=dp[num1]+3*a[i]-a[num1]-2*a[num1+1];\n\t\t}\n\t\tif (!q2.empty())\n\t\t{\n\t\t\tnum2=q2.top().y;\n\t\t\tans2=dp[num2]+a[i]-a[num2]+T;\n\t\t}\n\t\tdp[i]=min(ans1,ans2);\n\t\tq2.push(mp(a[i]-dp[i],i));\n\t}\n\t//for (i=1;i<=n;i++) cout<<dp[i]<<' ';\n\t//cout<<endl;\n\tcout<<dp[n]+(e-a[n])<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+2];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+2];\n\tint x[100000+2];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n//\t\tcout<<dp[i]<<endl;\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n//\t\tcout<<dp[i]<<\" \"<<las<<endl;\n//\t\twhile(!b1.empty()&&b1.)\n//\t\trb(k,0,i-1){\n//\t\t\tint j=k+1;\n//\t\t\tdp[i]=min(dp[i],dp[k]+x[j]-x[k]+max(T,(x[i]-x[j])*2)+x[i]-x[j]);\n//\t\t}\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3)/3,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3);\n//\t\tb1.push(i+1,dp[i]+x[i+1]-x[i]-all);\n//\t\tb2.push(i+1,dp[i]+x[i+1]-x[i]-all/3);\n//\t\tcout<<dp[i]<<endl<<endl;\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\n\nll inf=1e18;\nstruct segtree{\n\tstatic const int N=1<<17;\n\tll seg[N*2];\n\tsegtree(){\n\t\trep(i,N*2) seg[i]=inf;\n\t}\n\n\tvoid update(int x,ll v){\n\t\tx+=N;\n\t\tseg[x]=v;\n\t\tx/=2;\n\t\twhile(x){\n\t\t\tseg[x]=min(seg[x*2],seg[x*2+1]);\n\t\t\tx/=2;\n\t\t}\n\t}\n\tll getmin(int a,int b,int l=0,int r=N,int k=1){\n\t\tif(b<=l||r<=a) return inf;\n\t\tif(a<=l&&r<=b) return seg[k];\n\t\treturn min(getmin(a,b,l,(l+r)/2,k*2),getmin(a,b,(l+r)/2,r,k*2+1));\n\t}\n}seg1,seg2;\n\nint N;\nconst int MN=100010;\nll E,T;\nll x[MN];\nint get2(int id){\n\tint lb=-1,ub=id;\n\twhile(ub-lb>1){\n\t\tint m=(ub+lb)/2;\n\t\tif((x[id]-x[m])*2>=T) lb=m;\n\t\telse ub=m;\n\t}\n\treturn ub;\n}\n\nint main(){\n\tcin>>N>>E>>T;\n\trep(i,N) cin>>x[i];\n\tx[N]=E;\n\tseg1.update(0,-2*x[0]);\n\tseg2.update(0,0);\n\tfor(int i=1;i<=N;i++){\n\t\tint t=get2(i-1);\n\t\tll val = min(seg1.getmin(0,t)+3*x[i-1],seg2.getmin(t,i)+x[i-1]+T)+(x[i]-x[i-1]);\n\t\t// show(t);\n\t\t// show(val);\n\t\tif(i==N){\n\t\t\tcout<<val<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tseg1.update(i,val-3*x[i]);\n\t\tseg2.update(i,val-x[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Nmaxim 100000\nusing namespace std;\n\nlong long minim[Nmaxim], maxim[Nmaxim];\nlong long c[Nmaxim], dp[Nmaxim];\nlong long n;\nlong long e, t;\n\nlong long mxm(long long a, long long b);\n\nint main()\n{\n\tcin >> n >> e >> t;\n\tint prec = -1e9, m = 0, cit;\n\n\twhile (n--) {\n\t\tcin >> cit;\n\t\tif (cit - prec > t) {\n\t\t\tm++;\n\t\t\tminim[m] = cit;\n\t\t}\n\t\tmaxim[m] = cit;\n\t\tprec = cit;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t\tc[i] = mxm(2ll * (maxim[i] - minim[i]), t) + maxim[i] - minim[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[i] = dp[i - 1] + c[i] + 1ll * (minim[i] - maxim[i - 1]);\n\n\tcout << (long long) dp[m] + e - maxim[m];\n\n\treturn 0;\n}\n\nlong long mxm(long long a, long long b)\n{\n\tif (a > b)\n\t\treturn a;\n\treturn b;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\n\ntemplate<typename T>\nstruct SegmentTree {\n\tint n;\n\tT unit;\n\tvector<T>dat;\n\tfunction<T(T, T)> func;\n\tSegmentTree(const int N, T _unit, function<T(T, T)> _func)\n\t\t:unit(_unit), func(_func) {\n\t\tn = 1;\n\t\t//簡単のため、要素数を2のべき乗に\n\t\twhile (n < N)n *= 2;\n\t\tdat.assign(2 * n, unit);\n\t}\n\n\tvoid update(int k, T a) {\n\t\tk += n - 1;//葉の節点\n\t\tdat[k] = a;\n\t\t//上りながら更新\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\tT _query(int a, int b, int k, int l, int r) {\n\t\t//[a,b)と[l,r)が交差していなければ、funcに影響を与えない値を返す\n\t\tif (r <= a || b <= l)return unit;\n\t\t//[a,b)が[l,r)を完全に含んでいれば、この節点の値\n\t\tif (a <= l && r <= b)return dat[k];\n\t\telse {\n\t\t\tT vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tT vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\t//[a,b)\n\tT query(int a, int b) {\n\t\treturn _query(a, b, 0, 0, n);\n\t}\n};\n\n\n\nll dp[100010];\nvoid solve() {\n\tint N, E, T; cin >> N >> E >> T;\n\tvector<int>x(N + 1);\n\tREP(i, N) {\n\t\tcin >> x[i];\n\t}\n\tx[N] = E;\n\tdp[N] = 0;\n\tREP(i, N)dp[i] = LINF;\n\tauto f = [](int a, int b) {return min(a,b); };\n\tSegmentTree<int>seg(N+1,LINF,f);\n\n\tREPR(i, N) {\n\t\tseg.update(i, x[i + 1] + 2*x[i] + dp[i + 1]);\n\t\tint ok = i, ng = N;\n\t\twhile (abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (T >= 2 * (x[mid] - x[i]))ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tint res = T + x[ok + 1] - x[i] + dp[ok + 1];\n\t\tif (ok < N - 1) {\n\t\t\tint tmp = seg.query(ok + 1, N);\n\t\t\tres = min(res, tmp - 3 * x[i]);\n\t\t}\n\t\tdp[i] = res;\n\n\t}\n\tprint(x[0] + dp[0]);\n}\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\t\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 2);\n    rep1 (i, n) cin >> x[i];\n    x.back() = e;\n    x.push_back(INF);\n\n    vl dp(n + 3, INF);\n    dp[0] = 0;\n    rep (i, n + 1) {\n        if (dp[i] == INF) continue;\n        ll nx;\n        if (t % 2 == 0) nx = x[i + 1] + t / 2;\n        else nx = x[i + 1] + (t + 1) / 2;\n\n        auto itr = lower_bound(all(x), nx);\n        int ni = itr - x.begin();\n        chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + (x[ni] - x[i + 1]) * 3);\n\n        ni--;\n        if (ni > i) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + t + (x[ni] - x[i + 1]));\n        }\n    }\n    cout << min({dp[n] + x[n + 1] - x[n], dp[n + 1], dp[n + 2]}) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\nlong long f[100008], g[100008];\nint x[100008];\nint main(){\n\tregister int n, e, t, i, j;\n\tregister long long fmin = 3000000000ll;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tf[0] = 0;\n\tg[0] = -2 * x[1];\n\tfor (j = 0, i = 1; i <= n; ++i) {\n\t\twhile (2 * (x[i] - x[j + 1]) > t) {\n\t\t\tcmin(fmin, f[j] - x[j + 1] * 2);\n\t\t\t++j;\n\t\t}\n\t\tf[i] = dmin(fmin + 2 * x[i], g[i - 1] + t);\n\t\tg[i] = dmin(f[i] - 2 * x[i + 1], g[i - 1]);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repp(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dp[2010];\nconst int INF = 1e12;\n\nsigned main(){\n    int n, t, e;\n    cin >> n >> e >> t;\n    if(n > 2000) return 0;\n    vector<int> a(n);\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, 2010){\n        dp[i] = INF;\n    }\n    dp[0] = a[0];\n    rep(i, 1, n + 1){\n        rep(j, i, n + 1){\n            int tmp = 2 * (a[j - 1] - a[i - 1]);\n            if(tmp < t) tmp += t - tmp * (j - i + 1);\n            dp[j] = min(dp[j], dp[i - 1] + tmp);\n        }\n    }\n    // rep(i, 0, n + 1){\n    //     cout << dp[i] << \" \";\n    // }\n    cout << dp[n] + e - a[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define bg begin()\n#define ed end()\n#define all(x) (x).bg,(x).ed\n#define si(x) int((x).size())\n#define mp make_pair\n#define a first\n#define b second\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntypedef long long ll;\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\n\nconst ll inf=1e17;\n\nconst int nmax=3.1e6;\nint n;\nll m,t;\nll x[nmax];\n\nll dp[nmax];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin>>n>>m>>t;\n\tx[0]=0;\n\trng(i,1,n+1)\n\t\tcin>>x[i];\n\n\tdp[0]=0;\n\tint j=0;\n\tll w=inf;\n\trng(i,1,n+1){\n\t\twhile((x[i]-x[j+1])*2>t){\n\t\t\tchmin(w,dp[j]-2*x[j+1]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=min(w+2*x[i],dp[j]+t);\n\t}\n\tcout<<dp[n]+m<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n\nstruct seg{\n\tlint tree[270000];\n\tint lim;\n\tvoid init(int n){\n\t\tmemset(tree, 0x3f, sizeof(tree));\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid update(int x, lint v){\n\t\tx += lim;\n\t\ttree[x] = min(tree[x], v);\n\t\twhile(x > 1){\n\t\t\tx >>= 1;\n\t\t\ttree[x] = min(tree[2*x], tree[2*x+1]);\n\t\t}\n\t}\n\tlint query(int s, int e){\n\t\ts += lim;\n\t\te += lim;\n\t\tlint ret = 1e18;\n\t\twhile(s < e){\n\t\t\tif(s%2 == 1) ret = min(ret, tree[s++]);\n\t\t\tif(e%2 == 0) ret = min(ret, tree[e--]);\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tif(s == e) ret = min(ret, tree[s]);\n\t\treturn ret;\n\t}\n}seg;\n\nint n, e, t, a[100005];\nlint dp[100005];\n\n\nint main(){\n\tcin >> n >> e >> t;\n\tlint curmin = 1e18;\n\tint p = 0;\n\tseg.init(n);\n\tseg.update(0, 0);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\twhile(p < i && 2 * a[i] - 2 * a[p+1] >= t){\n\t\t\tcurmin = min(curmin, dp[p] - 2 * a[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = curmin + 2 * a[i];\n\t\tdp[i] = min(dp[i], seg.query(p, i-1) + t);\n\t\tseg.update(i, dp[i]);\n\t}\n\tcout << dp[n] + e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t &x, int64_t y) {\n    if (x > y) x = y;\n}\n\nint64_t dp[2020][2020];\n\nint main() {\n    int n;\n    int64_t T, E;\n    cin >> n >> E >> T;\n    vector<int64_t> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<int64_t> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    if (n > 2000) return 0;\n\n    fill_n(*dp, 2020 * 2020, 1e17);\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            // wait\n            if (j == 0) {\n                chmin(dp[i + 1][0], dp[i][j] + T + d[i]);\n            }\n\n            // return\n            if (j > 0) {\n                int64_t dist = ds[i] - ds[i - j];\n                chmin(dp[i + 1][0], dp[i][j] + d[i] + max(0LL, T - 2 * dist) + dist * 2);\n            }\n\n            // ignore\n            if (i < n - 1) {\n                chmin(dp[i + 1][j + 1], dp[i][j] + d[i]);\n            }\n        }\n    }\n\n    int64_t ans = dp[n][0] + x[0] + (E - x[n - 1]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt dp[108000];\nInt dp2[108000];\nInt x[108000];\nInt l, n, e, t;\nint main(){\n  cin >> n >> e >> t;\n  fill(dp, dp + 108000, LINF);\n  x[n] = e;\n  for(int i = 0;i < n;i++)cin >> x[i];\n  dp[0] = -x[0] * 2;\n  dp2[0] = dp[0];\n  for(int i = 1;i <= n;i++){\n    while((x[i-1] - x[l+1])*2>=t)l++;\n    \n    if((x[i-1] - x[l]) * 2 >= t){\n      dp[i] = dp2[l] + 2 * (x[i-1] - x[i]);\n      dp[i] = min(dp[i], dp[l+1] + 2*x[l+1] + t - 2*x[i]);\n    }\n    else{\n      dp[i] = dp[l] + 2*x[l] + t - 2 * x[i];\n    }\n    //    cout << i << \" \" << dp[i] + x[i] * 2 << \" \" << dp2[i] << endl;\n    dp2[i] = min(dp[i], dp2[i-1]);\n  }\n  cout << e + dp[n] + x[n]*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint N, E, T;\nVI x;\n\nint main(void) {\n    scanf(\"%d%d%d\", &N, &E, &T);\n    x.resize(N);\n    assert(N <= 2000);\n    for_each(ALL(x), [](int &e){scanf(\"%d\", &e);});\n    VL dp(N + 1, LLINF);\n    //dp[i] = i - 1番目までを収穫する最小時間からEを引いたやつ\n    dp[0] = 0;\n    REP(i, N) {\n        FOR(j, i, N) {\n            int dis = x[j] - x[i];\n            dp[j + 1] = min(dp[j + 1], dp[i] + max(T, dis * 2));\n        }\n    }\n    cout << dp[N] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        for(int j=i;j<=N;j++){\n            if((A[j]-A[i])*2>T) break;\n            chmin(dp[j],dp[i-1]+T);\n        }\n        /*auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));*/\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 > T) L = mid;\n      else R = mid;\n    }\n    int pos = L;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e16;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 1;\n    ll now = 1e17;\n    for(int i = 1; i <= N; i++) {\n        now += 2 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before]) >= T) {\n            now = min(now, dp[before - 1] + (x[i] - x[before - 1]) + 2 * (x[i] - x[before]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i] << endl;\n        //if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        dp[i] = min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + 2 * T + x[i] - x[before]);\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \nconst ll INF = 1ll<<50;\n \n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return seg[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n \nconst int MAXN = 100100;\nint N, E, T;\nint X[MAXN];\nll dp[MAXN];\n \nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i];\n\tconst ll INF = 1ll<<60;\n\tST<ll> seg(N+10);\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i] = INF;\n\t}\n\tX[N] = E;\n\tdp[N] = 0;\n\tseg.update(N, dp[N] + X[N] + 2*X[N-1]);\n\tfor (int i = N-1; i >= 0; i--) {\n\t\t// まず T が支配的な部分を探索\n\t\tint low = i, high = N;\n\t\twhile (high - low > 1) {\n\t\t\tconst int med = (low + high) / 2;\n\t\t\tif (2*(X[med]-X[i]) <= T) {\n\t\t\t\tlow = med;\n\t\t\t} else {\n\t\t\t\thigh = med;\n\t\t\t}\n\t\t}\n\t\t//cout << i << \" \" << low << endl;\n\t\tdp[i] = dp[low+1] + X[low+1] - X[i] + T;\n\t\tdp[i] = min(dp[i], seg.query(low+1, N+5) - 3*X[i]);\n\t\tif (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n\t\t//cout << i << \" \" << dp[i] << endl;\n\t}\n\tcout << X[0] + dp[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconstexpr LL INF = 1e18;\nLL dp[100001], dp2[100001];\nLL N, T, E;\nLL x[100001];\n\nint main() {\n    scanf(\"%lld %lld %lld\", &N, &E, &T);\n    for(int i = 1; i<=N; ++i) scanf(\"%lld\", x+i);\n    int now = 1;\n    LL mn = -2*x[1];\n    for(int i = 1; i<=N; ++i) {\n        if( 2*(x[i] - x[1]) <= T ) {\n            dp[i] = T;\n            continue;\n        }\n        while( 2*(x[i]-x[now+1]) > T ) {\n            mn = min(mn, dp[now]-2*x[now+1]);\n            ++now;\n        }\n        dp[i] = min(dp[now]+T, mn+2*x[i]);\n    }\n    printf(\"%lld\\n\", dp[N]+E);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll n,t,e;\nll ans;\nll xx[maxn];\ninline ll max(ll aa,ll bb){\n\tif (aa>bb)return aa;\n\telse return bb;\n}\nint main(){\n\tll b1,b2,b3,b4,b5;\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\txx[n+1]=e;\n\tans=xx[1];\n\tb1=1;\n\twhile (b1<=n){\n\t\tb2=b1;\n\t\tif ((b2+1<=n)&&((xx[b2+1]-xx[b2])<=t)){\n\t\t\tb2++;\n\t\t}\n\t\twhile ((b2+1<=n)&&((xx[b2+1]-xx[b2])*2<=t)){\n\t\t\tb2++;\n\t\t}\n\t\tans+=max((xx[b2]-xx[b1])*2,t)+(xx[b2+1]-xx[b1]);\n\t\tb1=b2+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  ll bestF = Inf; \n  auto relaxF = [&] (int i) {\n    bestF = min(bestF, dp[i] - x[i] - (ll)t * i);\n  };\n  auto get0 = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1]; \n  };\n  auto gett = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1] + 2 * x[i + 1];\n  };\n  relaxF(0);\n  //multiset <ll> h0, ht;\n  //ht.insert(gett(0));\n  //int uk = 0;\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = bestF + x[i] + (ll)t * i;\n    for (int j = 0; j < i; ++j) {\n      if (t - 2 * x[i] + 2 * x[j + 1] >= 0) {\n        dp[i] = min(dp[i], gett(j) + 3 * x[i] + t - 2 * x[i]);\n      } else {\n        dp[i] = min(dp[i], get0(j) + 3 * x[i]);\n      }\n    }\n    //if (!h0.empty()) dp[i] = min(dp[i], *h0.begin() + 3 * x[i]); \n    //if (!ht.empty()) dp[i] = min(dp[i], *ht.begin() + 3 * x[i] + t);\n    /*for (int j = i + 1; j <= n; ++j) {\n      ll extra = max(0LL, t - 2 * x[j] + 2 * x[i + 1]);\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }*/\n    relaxF(i);\n    //if (i < n) ht.insert(gett(i));\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define SZ(a) (int)((a).size())\n\nconst int MAXN = 100007;\nconst int INF = 1000000007;\nconst LL LINF = INF * (LL)INF;\n\nLL A[MAXN], DP[MAXN];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 1, n + 1)\n\t{\n\t\tcin >> A[i];\n\t\tDP[i] = LINF;\n\t}\n\tFOR(i, 1, n + 1)\n\t{\n\t\tint l = 0, r = i - 1, m;\n\t\twhile (r - l)\n\t\t{\n\t\t\tm = (l + r) / 2;\n\t\t\tif (DP[m] - A[m] + max(t - 2 * A[i], -2 * A[m + 1]) < \n\t\t\t\tDP[m + 1] - A[m + 1] + max(t - 2 * A[i], -2 * A[m + 2]))\n\t\t\t\tr = m;\n\t\t\telse l = m + 1;\n\t\t}\n\t\tDP[i] = 3 * A[i] + DP[l] - A[l] + max(t - 2 * A[i], -2 * A[l + 1]);\n\t}\n\tcout << DP[n] + e - A[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN], v[MAXN];\ndeque<int> p, q;\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nvoid pushp(int x) {\n    while (!p.empty() && f[x] + v[x + 1] - d[x + 1] < f[p.back()] + v[p.back() + 1] - d[p.back() + 1])\n        p.pop_back();\n    p.push_back(x);\n}\n\nvoid pushq(int x) {\n    while (!q.empty() && f[x] + v[x + 1] - d[x + 1] * 3 < f[q.back()] + v[q.back() + 1] - d[q.back() + 1] * 3)\n        q.pop_back();\n    q.push_back(x);\n}\n\nint main() {\n    n = read();\n    if (n > 2000)\n        return 0;\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i) {\n        d[i] = read();\n        v[i] = d[i] - d[i - 1];\n    }\n    p.push_back(0);\n    for (int i = 1, j; i <= n; ++i) {\n        while (!p.empty() && (d[i] - d[p.front() + 1]) * 2 > t) {\n            pushq(p.front());\n            p.pop_front();\n        }\n        f[i] = INF;\n        if (!p.empty()) {\n            j = p.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] + d[i] + t);\n        }\n        if (!q.empty()) {\n            j = q.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] * 3 + d[i] * 3);\n        }\n        pushp(i);\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    i64 g, t; cin >> g >> t;\n    vector<i64> a(n + 1, 0LL);\n    for(int i : in(n)) cin >> a[i + 1];\n    vector<i64> dp(n + 1, 1e18);\n    dp[0] = 0LL;\n    int j = 0;\n    i64 mi = 1e18;\n    for(int i : in(1, n + 1)) {\n        dp[i] = dp[i - 1] + t;\n        while(j < i && t <= 2LL * (a[i] - a[j + 1])) {\n            mi = min(mi, dp[j] - 2 * a[j + 1]);\n            ++j;\n        }\n        dp[i] = min(dp[i], dp[j] + t);\n        dp[i] = min(dp[i], mi + 2 * a[i]);\n    }\n    cout << dp[n] + g << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    rep (i, n) {\n        if (dp[i] == INF) continue;\n        ll nx;\n        if (t % 2 == 0) nx = x[i + 1] + t / 2;\n        else nx = x[i + 1] + (t + 1) / 2;\n\n        auto itr = lower_bound(all(x), nx);\n        int ni = itr - x.begin();\n        if (ni <= n) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + (x[ni] - x[i + 1]) * 3);\n        }\n\n        ni--;\n        assert((x[ni] - x[i + 1]) * 2 <= t);\n        if (ni + 1 < x.size()) {\n            assert((x[n + 1] - x[i + 1]) * 2 >= t);\n        }\n        if (ni > i) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + t + (x[ni] - x[i + 1]));\n        }\n    }\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_map>\n# include <unordered_set>\n# include <thread>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing ui32 = unsigned int;\nconstexpr ll INFLL = 1e18;\n\n#define CHECK_IMPL1(cond)              \\\nif (!(cond)) {                         \\\n    DEBUG(\"expected cond: \" << #cond); \\\n    assert(cond);                      \\\n}\n\n#define CHECK_IMPL2(cond, message)                                            \\\nif (!(cond)) {                                                                \\\n    DEBUG(\"expected cond: \" << #cond << \" failed with message: \" << message); \\\n    assert(cond);                                                             \\\n}\n#define CHECK_IMPL(_1, _2, NAME, ...) NAME\n#define CHECK(...) CHECK_IMPL(__VA_ARGS__, CHECK_IMPL2, CHECK_IMPL1, CHECK_IMPL0)(__VA_ARGS__)\n\n#ifdef __APPLE__\n#define DEBUG(message) std::cerr << message << std::endl;\n#else\n#define DEBUG(message)\n#endif\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : n_(n), tree_(5 * n + 1, INFLL) {\n  }\n\n  void update(int pos, ll value) {\n    update_impl(pos, value, 1, 0, n_);\n  }\n\n  ll get(int l, int r) {\n    return get_impl(l, r, 1, 0, n_);\n  }\n\n private:\n  void update_impl(int pos, ll value, int v, int l, int r) {\n    if (l == r) {\n      tree_[v] = value;\n    } else {\n      int m = (l + r) / 2;\n      if (pos <= m) {\n        update_impl(pos, value, v * 2, l, m);\n      } else {\n        update_impl(pos, value, v * 2 + 1, m + 1, r);\n      }\n      tree_[v] = min(tree_[v * 2], tree_[v * 2 + 1]);\n    }\n  }\n\n  ll get_impl(int l, int r, int tv, int tl, int tr) {\n    if (r < tl || l > tr) {\n      return INFLL;\n    }\n    if (l == tl && r == tr) {\n      return tree_[tv];\n    }\n    int tm = (tl + tr) / 2;\n    return min(get_impl(l, min(tm, r), tv * 2, tl, tm), get_impl(max(tm + 1, l), r, tv * 2 + 1, tm + 1, tr));\n  }\n\n private:\n  int n_;\n  vector<ll> tree_;\n};\n\nvoid solve() {\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n\n  vector<ll> x(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    cin >> x[i];\n  }\n\n  vector<ll> dp(n + 1, INFLL);\n  dp[0] = 0;\n\n  SegmentTree first_case(n);\n  SegmentTree second_case(n);\n\n  first_case.update(0, 0 - 2 * x[1] - x[0]);\n  second_case.update(0, 0 - x[0]);\n\n  for (int i = 1; i <= n; i++) {\n//    cout << endl << endl << \"iter: \" << i << endl;\n    int k = lower_bound(x.begin(), x.end(), (2 * x[i] - t) / 2) - x.begin();\n    k = max(0, k - 1);\n    if (k > i - 1) {\n      k = i - 1;\n    }\n    while (k < i - 1 && t - 2 * (x[i] - x[k + 1]) < 0) {\n      ++k;\n    }\n//    cout << (2 * x[i] - t) / 2 << endl;\n\n    // 1) dp[i] = min(dp[i], dp[j] + 3 * x[i] - 2 * x[j + 1] - x[j]);\n    // 2) dp[i] = min(dp[i], dp[j] + x[i] + t - x[j]);\n\n//    cout << k << \" first: \" << first_case.get(0, k) << \" second: \" << second_case.get(k + 1, i - 1) << endl;\n//\n//    cout << \"1) \" << first_case.get(0, k - 1) << endl;\n//    cout << \"2) \" << second_case.get(k, i - 1) << endl;\n\n    CHECK(t - 2 * (x[i] - x[k + 1]) >= 0);\n\n    dp[i] = min(dp[i], first_case.get(0, k - 1) + 3 * x[i]);\n    dp[i] = min(dp[i], second_case.get(k, i - 1) + x[i] + t);\n\n    if (i < n) {\n      first_case.update(i, dp[i] - 2 * x[i + 1] - x[i]);\n      second_case.update(i, dp[i] - x[i]);\n    }\n\n//    for (int j = 0; j < i; j++) {\n//      dp[i] = min(dp[i], dp[j] + (x[i] - x[j + 1]) * 3 + max(0ll, t - 2 * (x[i] - x[j + 1])) + x[j + 1] - x[j]);\n//    }\n\n//    cout << i << \" \" << dp[i] << endl;\n  }\n\n  cout << dp[n] + e - x[n] << \"\\n\";\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n#ifdef __APPLE__\n  freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", stdout);\n#endif\n  int t = 1;\n//  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e15;\n\n\nint main(){\n\tll N, E, T;\n\tll x[100005]={};\n\n\tcin >> N >> E >> T;\n\trep(i,N) cin >> x[i];\n\tx[N] = E;\n\n\tN = min(N, 2000);\n\n\tll dp[2][100005]={};\n\trep(i,N){\n\t\tFill( dp[(i+1)%2], INF );\n\t\tll dist = x[i+1] - x[i];\n\t\trep(j,i+1){\n\t\t\tchmin( dp[(i+1)%2][j], dp[i%2][j] + dist );\n\n\t\t\tll back = (x[i] - x[j]) * 2;\n\t\t\tll t = max( back, T );\n\t\t\tchmin( dp[(i+1)%2][i+1], dp[i%2][j] + t + dist );\n\t\t}\n\t\t//rep(j,N+1) cout << dp[(i+1)%2][j] << \" \"; cout << endl;\n\t}\n\n\tll ans = dp[N%2][N] + x[0];// + E-x[N-1];\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=4e5+10;\ntypedef long long LL;\nconst LL INF=1e15+10;\n\nint n;\nLL x[maxn],e,t;\nint ll[maxn],rr[maxn];\nLL mini1[maxn],mini2[maxn];\nLL dp[maxn];\n\nvoid build(int p,int l,int r)\n{\n\tll[p]=l;rr[p]=r;\n\tmini1[p]=mini2[p]=INF;\n\tif (l==r) return;\n\tbuild(p<<1,l,(l+r)>>1);\n\tbuild((p<<1)|1,((l+r)>>1)+1,r);\n\treturn;\n}\n\nvoid update(int p,int pos,LL val,int tp)\n{\n\tif (!tp) mini1[p]=min(mini1[p],val);\n\telse mini2[p]=min(mini2[p],val);\n\tif (ll[p]==rr[p]) return;\n\tif (pos<=rr[p<<1]) update(p<<1,pos,val,tp);\n\telse update((p<<1)|1,pos,val,tp);\n\treturn;\n}\n\nLL getmini(int p,int l,int r,int tp)\n{\n\tif (l>r) return INF;\n\tif (r<ll[p] || rr[p]<l) return INF;\n\tif (l<=ll[p] && rr[p]<=r) \n\t{\n\t\tif (!tp) return mini1[p];\n\t\telse return mini2[p];\n\t}\n\treturn min(getmini(p<<1,l,r,tp),getmini((p<<1)|1,l,r,tp));\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tx[n+1]=e;\n\t\n\tdp[0]=x[1];\n\tbuild(1,0,n);\n\tupdate(1,0,dp[0]-x[1],0);\n\tupdate(1,0,dp[0]-x[1]*3ll,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint tmp=lower_bound(x+1,x+n+1,x[i]-(t>>1))-x;\n\t\tdp[i]=min(getmini(1,0,tmp-2,1)+3ll*x[i],getmini(1,tmp-1,i-1,0)+t+x[i]);\n\t\tdp[i]+=x[i+1]-x[i];\n\t\tupdate(1,i,dp[i]-x[i+1],0);\n\t\tupdate(1,i,dp[i]-x[i+1]*3ll,1);\n\t\t//printf(\"%d %d\\n\",tmp,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 101010;\nint n,e,t;\nlong long s[N],dp[N];\nstruct g{\n\tlong long v;\n\tint pos;\n}q[N];\nint l,r;\nlong long tmp;\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld%d\",&s[n+1],&t);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&s[i]);\n\t\n\tl=1;r=0;tmp=(1LL<<50);\n\tq[++r].pos=1;\n\tq[r].v=t;\n\tfor (int i=1;i<=n;i++){\n\t\twhile ((s[i]-s[q[l].pos])*2>t) \n\t\t{\t\n\t\t\ttmp=min(tmp,q[l].v-t-2*s[q[l].pos]);\n\t\t\tl++;\n\t\t}\n\t\tdp[i]=(1LL<<50);\n\t\tdp[i]=min(dp[i],q[l].v+s[i]);\n\t\tdp[i]=min(dp[i],tmp+3*s[i]);\n\t\twhile ((l<=r)&&(dp[i]-s[i]+t<=q[r].v)) r--;\n\t\tq[++r].pos=i+1;\n\t\tq[r].v=dp[i]-s[i]+t;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+s[n+1]-s[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 0;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));*/\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define N 100010\ntypedef long long ll;\n\nconst ll INF=1e18;\n\nint n,E,T;\nint dis[N];\nll Dp[N];\n\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint main()\n{\n    n=read();E=read();T=read();\n    for(int i=1;i<=n;i++)\n        dis[i]=read();\n    Dp[0]=0;\n    int pos=0;ll Min=INF;\n    for(int i=1;i<=n;i++)\n    {\n        Dp[i]=Dp[i-1]+T;\n        while(pos+1<=i&&2*(dis[i]-dis[pos+1])>T)\n        {\n            Min=min(Min,Dp[pos]-2*dis[pos+1]);\n            pos++;\n        }\n        Dp[i]=min(min(Dp[i],Dp[pos]+T),Min+2*dis[i]);\n    }\n    cout<<Dp[n]+E<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\t//cout << opt << endl;\n\tll dp1 = T;\n\tif(opt - 1 >= 0)\n\t\tdp1 += dp[opt - 1];\n\tll dp2 = a[idx] * 2;\n\tif(opt - 1 >= 0)\n\t\tdp2 += dpRMQ[opt - 1];\n\t//cout << dp1 << \" \" << dp2 << endl;\n\t//if(opt < idx)\n\t\treturn(min(dp1 , dp2));\n\t//else\n\t\t//return dp2;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = - a[0] * 2;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\t/*while(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}*/\n\t\tdp[i] = findDp(i);\n\t\t//cout << \"DP: \"<< dp[i] << endl;\n\t\tdpRMQ[i] = min(dpRMQ[i - 1] , dp[i - 1] - a[i] * 2);\n\t\t//for(int j = 0; j <= i; j++)\n\t\t\t//dp[i] = min(dp[i] , cost(i , j));\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <ll> vi;\ntypedef pair <ll, ll> pi;\ntypedef vector <pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(),x.end()\n#define SZ(x) (ll) x.size()\n#define f first\n#define s second\n#define MAXN 100100\nll INF = 1e18;\ndeque<pi> dq;\nll max_constant;\nll N,E,T;\nll off;\nll D[MAXN];\nll dp[MAXN];\nqueue<pi> Q;\nmultiset<ll> S2;\n\nint main(){\n\tcin>>N>>E>>T;\n\tfor (int i=1;i<=N;++i)cin>>D[i];\n\tdp[0] = 0;\n\tmax_constant = -INF;\n\tQ.push(mp(T+2*D[1], 2*D[1]));\n\tS2.insert(T+4*D[1]);\n\n\tfor (int i=1;i<=N;++i){\n\t\twhile (SZ(Q) && Q.front().f <= 2*D[i]){\n\t\t\tpi cur = Q.front();Q.pop();\n\t\t\tmax_constant = max(max_constant, cur.s);\n\t\t\tS2.erase(S2.find(cur.f+cur.s));\n\t\t}\n\t\t// cout<<max_constant<<'\\n';\n\t\tdp[i] = INF;\n\t\t// Case 1 is using the constant\n\t\tdp[i] = min(dp[i], 3*D[i]-max_constant);\n\t\t// cout<<\"Case 1 \"<<i<<' '<<dp[i]<<' '<<3*D[i]-max_constant<<'\\n';\n\t\t// Case 2: is waiting\n\t\tdp[i] = min(dp[i], T + D[i] - D[i-1] + dp[i-1]);\n\t\t// cout<<\"Case 2 \"<<i<<' '<<dp[i]<<'\\n';\n\t\t// Case 3: Need to wait\n\t\tif (SZ(S2))dp[i] = min(dp[i], *S2.begin() + D[i]);\n\t\tQ.push(mp(T+2*D[i+1], -2*D[i+1] - D[i]+ dp[i]));\n\t\tS2.insert(T-D[i]+dp[i]);\n\t\t// cout<<i<<' '<<dp[i]<<'\\n';\n\t}\n\tcout<<dp[N] + E-D[N];\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(2 * -inputs[1], 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i], now_cost + 2 * inputs[i]);\n\n\t\twhile (next.empty() == false && 2 * (inputs[i] - inputs[next.top().second]) > t) {\n\t\t\tnext.pop();\n\t\t}\n\n\t\tif (next.empty() == false) {\n\t\t\tdp[i] = min(dp[i], next.top().first + 2 * inputs[i] + t);\n\t\t}\n\n\t\tif (i != n - 1)\n\t\t\tnext.push(make_pair(dp[i] - 2 * inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvll v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tv.PB(INFL);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tmins(dp[min(it,n-1)],dp[i]+T);\n\t\tint p = it+1;\n\t\tint it2 = upper_bound(ALL(v), v[i]+T)-v.begin();\n\t\treep(j,p,it2+1){\n\t\t\tmins(dp[min(j,n-1)], dp[i]+2*(v[j-1]-v[i]));\n\t\t\tif(p+100<j){\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans  << \"\\n\";\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    deque<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = T + 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (cval <= pval) {\n                d.pop_back();\n                continue;\n            }\n            int64_t prevSteady = T + 2 * X[p + 1];\n            time = prevSteady + pval - cval;\n            if (time > currSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (SZ(d) > 1 && 2 * X[i] >= d[1].second) {\n            d.pop_front();\n        }\n        d.front().second = LINF;\n        int p = d.front().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//fold\n#ifndef KHALIL\n#include <bits/stdc++.h>\n#else\n#include \"header.h\"\n#endif\n#define endl '\\n'\n#define mp make_pair\n#define tostr(x) static_cast<ostringstream&>((ostringstream()<<dec<<x)).str()\n#define rep(i,begin,end) for(auto i = begin;i < end;i++)\n#define repr(i,begin,end) for(auto i = begin-1;i >= end;i--)\n#define pb push_back\n#define sz(a) ((int)(a).size())\n#define fi first\n#define se second\n#define abs(a) ((a) < (0) ? (-1)*(a) : (a))\n#define SQ(a) ((a)*(a))\n#define eqd(a,b) (abs(a-b)<1e-9)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate <typename t> t in(t q){cin >> q;return q;}\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v){os << \"[\";for (int i = 0; i < sz(v); ++i) { os << v[i]; if (i != sz(v) - 1) os << \",\";}os << \"]\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const map<T, S>& v){for (auto it : v)os << \"(\" << it.first << \":\" << it.second << \")\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const pair<T, S>& v){os << \"(\" << v.first << \",\" << v.second << \")\";return os;}\nconst long double PI = acosl(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\ninline int rand(int l,int r){return uniform_int_distribution<int>(l, r)(rng);}\ninline ll rand(ll l,ll r){return uniform_int_distribution<ll>(l, r)(rng64);}\n//endfold\n#define  N  (100'005)\n#define MOD (1'000'000'007ll)\n#define OO (1'050'000'000)\n#define OOL (1'100'000'000'000'000'000ll)\n\n//global\nll x[N];\nll dp[N];\n\nint main(){\n\t//fold\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcout << setprecision(10);\n\t//endfold\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,0,n){\n\t\tcin >> x[i];\n\t}\n\tdp[n] = 0;\n\tx[n] = e;\n\tfor (int i = n-1; i >= 0; --i){\n\t\tll k = lower_bound(x+i+1,x+n,x[i]+(t+1)/2)-x;\n\t\tll ans = OOL;\n\t\tfor(int j = k; j < n; j++){\n\t\t\tans = min(ans,2*x[j]+x[j+1]+dp[j+1]-3*x[i]);\n\t\t}\n\t\tk--;\n\t\tans = min(ans,t+x[k+1]-x[k]+dp[k+1]);\n\t\tdp[i] = ans;\n\t}\n\tcout << dp[0]+x[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre,p;\nint64 T,E;\nint64 x[100005];\nint N;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tdp[i] = min(dp[i],dp[i - 1] + T);\n\tif(p != -1) dp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front()]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\n\nstruct RMQ {\n\tint n; vector<int>node;\n\tvoid init(int N) {\n\t\tn = 1;\n\t\twhile (n < N)n *= 2;\n\t\tnode.resize(2 * n, inf);\n\t}\n\n\tvoid update(int x, int a) {\n\t\tx += n - 1;\n\t\tnode[x] = a;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[x * 2 + 1], node[x * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tint get(int a, int b) {\n\t\tif (a > b)return inf;\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\nRMQ dp1, dp2;\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\tdp1.init(n + 2);\n\tdp2.init(n + 2);\n\n\tx[n] = x[n - 1];\n\tdp1.update(0, 0);\n\tdp2.update(0, -2*x[0]);\n\trep(i,n){//dp[i+1]\n\t\tint lb = -1, ub = i+1;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mi = (ub + lb) / 2;\n\t\t\tif (2 * (x[i] - x[mi]) > t)lb = mi;\n\t\t\telse ub = mi;\n\t\t}\n\n\t\t//0~lb ub~i\n\t\tint X1, X2;\n\t\tX1 = dp1.get(ub, i+1) + t;\n\t\tX2 = dp2.get(0, ub) + 2 * x[i];\n//\t\tcout << ub << ' ' << X1 << ' ' << X2 << endl;\n\t\tdp1.update(i+1, min(X1, X2));\n\t\tdp2.update(i+1, dp1.get(i+1, i + 2) - 2 * x[i]);\n\t}\n\tcout << dp1.get(n, n+1)+e << endl;\n\n\t/*\n\tdp[0] = 0;\n\trep(i, n) {\n\t\tfor (int j = i; j<n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + max(2 * (x[j] - x[i]), t));\n\t\t}\n\t}\n\tcout << dp[n] + e<< endl;\n\t*/\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nint move(int i, int j) {\n\tif (j < 0 || j >= i) return f[N - 1];\n\treturn f[j] + a[i] - a[j] + std::max((a[i] - a[j + 1]) << 1, k);\n}\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint j = std::lower_bound(a, a + i, (a[i] * 2 - k + 1) >> 1) - a;\n\t\t// printf(\"i=%d j=%d\\n\", i, j);\n\t\tf[i] = std::min(f[i], move(i, j - 2));\n\t\tf[i] = std::min(f[i], move(i, j - 1));\n\t\tf[i] = std::min(f[i], move(i, j));\n\t\tf[i] = std::min(f[i], move(i, j + 1));\n\t\tf[i] = std::min(f[i], move(i, j + 2));\n\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\nconst int mod=1000000007;\nconst int mod1=998244353;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,T,e;cin >> n >> e >> T;\n\tvector<ll> x(n);\n\trep(i,n) cin >> x.at(i);\n\tll ans=x.at(0);\n\tvector<bool> b(n);\n\trep(i,n){\n\t\tif(i==n-1){\n\t\t\tif(!b.at(i)) ans+=T;\n\t\t\tans+=e-x.at(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(b.at(i)){\n\t\t\tans+=x.at(i+1)-x.at(i);\n\t\t}\n\t\telse{\n\t\t\tif((x.at(i+1)-x.at(i))*2-T>=T) ans+=T;\n\t\t\telse{\n\t\t\t\tint k=i;\n\t\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\t\tif((x.at(j)-x.at(i))*2-T<T){\n\t\t\t\t\t\tk=j;\n\t\t\t\t\t\tb.at(j)=true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((x.at(j)-x.at(j-1))*2-T-(T-(x.at(j-1)-x.at(i))*2)<(x.at(j)-x.at(j-1))*2-T){\n\t\t\t\t\t\t\tk=j;\n\t\t\t\t\t\t\tb.at(j)=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=(x.at(k)-x.at(i))*2;\n\t\t\t}\n\t\t\tans+=x.at(i+1)-x.at(i);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=100010;\nint n,e;\nll T;\nint x[maxn];\nll f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&e);\n\tcin>>T;\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tf[0]=0;\n\tf[1]=T;\n\tint la=0;\n\tll minx=1LL<<60;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\twhile (2LL*(x[i]-x[la+1])>T)\n\t\t{\n\t\t\tll tmp=f[la]-2LL*x[la+1];\n\t\t\tif (minx>tmp)\tminx=tmp;\n\t\t\tla++;\n\t\t}\n\t\tf[i]=f[i-1]+T;\n\t\tif (la>0)\n\t\t\tf[i]=min(f[i],minx+2LL*x[i]);\n\t\tf[i]=min(f[i],f[la]+T);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int64_t LINF = 1LL << 62;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    vector<pair<int, int64_t>> d;\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = LINF;\n        int j = i - 1;\n        int64_t time = LINF;\n        int64_t cval = dp[j] + X[j + 1] - X[j] + \n                3LL * (X[i] - X[j + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1])));\n        int64_t currSteady = 2 * X[j + 1];\n        while (!d.empty()) {\n            int p = d.back().first;\n            int64_t pval = dp[p] + X[p + 1] - X[p] + \n                    3LL * (X[i] - X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n            if (pval <= cval) {\n                time = -LINF;\n                break;\n            }\n            int64_t prevSteady =  2 * X[p + 1];\n            int64_t xcval = 2 * (dp[j] + X[j + 1] - X[j]) +\n                    3LL * (currSteady - 2 * X[j + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[j + 1]));\n            int64_t xpval = 2 * (dp[p] + X[p + 1] - X[p]) +\n                    3LL * (currSteady - 2 * X[p + 1]) +\n                    max((int64_t) 0, (int64_t) (2 * T - currSteady + 2LL * X[p + 1]));\n            if (xcval < xpval) {\n                time = LINF;\n                break;\n            }\n            time = currSteady - (xcval - xpval);\n            if (time < prevSteady) {\n                time = LINF;\n            }\n            if (time <= d.back().second) {\n                d.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (d.empty()) {\n            time = LINF;\n        }\n        d.push_back(make_pair(j, time));\n        while (2 * X[i] >= d.back().second) {\n            d.pop_back();\n        }\n        int p = d.back().first;\n        int64_t pval = dp[p] + X[p + 1] - X[p] + \n                3LL * (X[i] - X[p + 1]) +\n                max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[p + 1])));\n        dp[i] = pval;\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b)-1; i >= (a); i--)\n#define ITER(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 100100;\n\nint A[MAX];\nLL A2[MAX];\n\nLL D[MAX];\n\nVI ADD[MAX];\nVI REM[MAX];\n\nLL ST[MAX];\n\nmultiset<LL> S;\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, e, t;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tFOR (i, 0, n)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t\tA2[i] = A[i] * 2;\n\t}\n\n\tFOR (i, 0, n + 7)\n\t{\n\t\tST[i] = LINF;\n\t}\n\n\n\tLL res = e;\n\n\tD[0] = 0;\n\tLL mn = LINF;\n\n\tFOR (i, 0, n + 1)\n\t{\n\t\tFOR (j, 0, SZ(ADD[i]))\n\t\t{\n\t\t\tS.insert(ADD[i][j]);\n\t\t}\n\n\t\tFOR (j, 0, SZ(REM[i]))\n\t\t{\n\t\t\tS.erase(S.find(REM[i][j]));\n\t\t}\n\n\t\tmn = min(mn, ST[i]);\n\n\t\tif (i == 0) D[i] = 0;\n\t\telse\n\t\t{\n\t\t\tD[i] = LINF;\n\t\t\tif (SZ(S))D[i] = *S.begin();\n\n\t\t\tD[i] = min(D[i], 2 * A[i - 1] + mn);\n\n\t//\t\tcout<<i<<' '<<mn<<endl;\n\t//\t\tif (SZ(S)) cout<<\"** \"<<*S.begin()<<endl;\n\n\t\t\tif (i == n) break;\n\t\t}\n\n\t\tint pos = upper_bound(A2, A2 + n, A2[i] + t) - A2;\n\n\t//\tcout<<i<<\": \"<<pos<<endl;\n\n\t\tADD[i+1].PB(D[i] + t);\n\t\tREM[pos + 1].PB(D[i] + t);\n\n\t\tST[pos + 1] = min(ST[pos + 1], D[i] - 2 * A[i]);\n\t\t//mn = min(mn, D[i] - 2 * A[i]);\n\t}\n\n\n/*\tFOR (i, 0, n + 1)\n\t{\n\t\tcout<<D[i]<<' ';\n\t}\n\tcout<<endl;*/\n\n\tres += D[n];\n\n\tcout<<res<<endl;\n\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long n;\nlong long t,e;\nlong long a[100100];\nint use[100100];\n\nmain()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\t\n\t}\n\tlong long ans=0;\n\tlong long rt=0;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint d=0;\n\t\trt=0;\n\t\tif(use[i]==0)\n\t\t\tfor(int j=0;i-j-1>=0;j++)\n\t\t\t{\n\t\t\t\td=0;\n\t\t\t\t//printf(\"%lld %lld\\n\",a[i-j],a[i-j-1]);\n\t\t\t\tif(a[i-j]-a[i-j-1]<t)\n\t\t\t\t{\n\t\t\t\t\td=1;\n\t\t\t\t\t//printf(\"op1\\n\");\n\t\t\t\t\tuse[i-j-1]=1;\n\t\t\t\t\trt+=a[i-j]-a[i-j-1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op2 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\t//printf(\"%lld %lld \",rt,t);\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op2.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d==1&&i-j-1==0)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op3 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\t//printf(\"%lld %lld \",rt,t);\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op3.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t}\n\t\t\t}\n\t\tuse[i]=1;\n\t}\n\tif(use[0]==0)\n\t{\n\t\tans+=t;\n\t}\n\tans+=e;\n\tprintf(\"%lld\",ans);\n}\n\n/*\n5 12 3\n1 3 8 9 10\n\n9 20 4\n1 3 7 11 12 16 17 18 19\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n//#define debug\n//#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 100010;\nconst llint INF = 1e18;\n\nint n, t, e, x[MAXN];\nllint f[MAXN], val[MAXN];\n\nstruct cmpf {\n  bool operator()(const int& i, const int& j) {\n    if (val[i] != val[j]) return val[i] < val[j];\n    return i < j;\n  }\n};\n\nset<int, cmpf> s1, s2;\n\nint main(void) {\n  scanf(\"%d %d %d\",&n,&e,&t);\n  REP(i, n) scanf(\"%d\",&x[i]);\n\n  int j = n - 1;\n  \n  for (int i = n - 1; i >= 0; --i) {\n    val[i] = f[i+1] + t;\n    s1.insert(i);\n    \n    for (; 2*(x[j] - x[i]) > t; --j) {\n      s1.erase(j);\n      val[j] = f[j+1] + 2*x[j];\n      s2.insert(j);\n    }\n\n    f[i] = INF;\n    if (!s1.empty()) f[i] = min(f[i], val[*s1.begin()]);\n    if (!s2.empty()) f[i] = min(f[i], val[*s2.begin()] - 2*x[i]);\n  }\n\n  printf(\"%lld\\n\",f[0] + e);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAX = 2000 + 10;\n\nlong long cal[MAX][MAX];\nlong long dp[MAX];\nlong long rec[MAX];\n\nint main(){\n  int n;\n  long long e, t;\n  scanf(\"%d %lld %lld\", &n, &e, &t);\n  for(int i = 0 ; i < n ; i++){\n    scanf(\"%lld\", &rec[i]);\n  }\n  for(int i = 0 ; i < n ; i++)\n    cal[i][i] = t;\n  for(int i = 0 ; i < n ; i++){\n    for(int j = i+1 ; j < n ; j++){\n      cal[i][j] = min(t * (j-i+1), max(2 * (rec[j] - rec[i]), t));\n    }\n  }\n  for(int i = 0 ; i < n ; i++){\n    dp[i] = cal[0][i];\n    for(int j = 0 ; j < i ; j++) {\n      dp[i] = min(dp[i], dp[j] + cal[j+1][i]);\n    }\n  }\n  printf(\"%lld\\n\", e + dp[n-1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\nconst int maxn = 1e5 + 100;\nconst ll inf = 1e18;\n\nll x[maxn];\nll dp[maxn], seg[maxn * 4];\n\n\nvoid add(int v, int l, int r, int i, ll val)\n{\n    if(r - l == 1)\n    {\n        seg[v] = val;\n        return ;\n    }\n    int mid = (l + r) / 2;\n    if(i < mid)\n        add(v * 2, l, mid, i, val);\n    else\n        add(v * 2 + 1, mid, r, i, val);\n    seg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\n\nll query(int v, int l, int r, int b, int e)\n{\n    if(e <= l || r <= b)\n        return inf;\n    if(b <= l && r <= e)\n        return seg[v];\n    int mid = (l + r) / 2;\n    return min(query(v * 2, l, mid, b, e), query(v * 2 + 1, mid, r, b, e));\n}\n\nint main()\n{\n    ll n, E, T;\n    cin >> n >> E >> T;\n\n\n\n    for(int i = 1; i <= n; i++)\n        cin >> x[i], x[i] *= 2;\n\n    add(1,0,n+1,0,-x[1]*2);\n    for(int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x + 1, x + n + 1, x[i] - T) - x;\n\n        if(x[j]>x[i]-T and j)\n            j--;\n\n        dp[i] = min(query(1, 0, n + 1, 0, j) + x[i] * 2,dp[j] + T*2 );\n\n\n\n        add(1, 0, n + 1, i, dp[i] - 2 * x[i+1]);\n    }\n\n    cout << (dp[n] + E * 2) / 2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000000000000000\n\ntemplate <typename T,typename F>\nstruct SWAG{\n\tF func;\n\tT init_value;\n\tvector<pair<T,T>> X,Y;\n\tSWAG(F f,T iv):func(f){\n\t\tinit_value = iv;\n\t}\n\t\n\tvoid push_front(T x){\n\t\tif(X.empty())X.push_back({x,x});\n\t\telse X.push_back({x,func(x,X.back().second)});\n\t}\n\t\n\tvoid push_back(T x){\n\t\tif(Y.empty())Y.push_back({x,x});\n\t\telse Y.push_back({x,func(Y.back().second,x)});\n\t}\n\t\n\tvoid pop_front(){\n\t\tif(X.empty()){\n\t\t\tint n = Y.size();\n\t\t\tvector<T> t;\n\t\t\tfor(int i=0;i<n/2;i++){\n\t\t\t\tt.push_back(Y.back().first);\n\t\t\t\tY.pop_back();\n\t\t\t}\n\t\t\twhile(!Y.empty()){\n\t\t\t\tpush_front(Y.back().first);\n\t\t\t\tY.pop_back();\n\t\t\t}\n\t\t\twhile(!t.empty()){\n\t\t\t\tpush_back(t.back());\n\t\t\t\tt.pop_back();\n\t\t\t}\n\t\t\tif(!X.empty())X.pop_back();\n\t\t}\n\t\telse{\n\t\t\tX.pop_back();\n\t\t}\n\t}\n\t\n\tvoid pop_back(){\n\t\tif(Y.empty()){\n\t\t\tint n = X.size();\n\t\t\tstack<T> t;\n\t\t\tfor(int i=0;i<n/2;i++){\n\t\t\t\tt.push_back(X.back().first);\n\t\t\t\tX.pop_back();\n\t\t\t}\n\t\t\twhile(!X.empty()){\n\t\t\t\tpush_back(X.back().first);\n\t\t\t\tX.pop_back();\n\t\t\t}\n\t\t\twhile(!t.empty()){\n\t\t\t\tpush_front(t.back());\n\t\t\t\tt.pop_back();\n\t\t\t}\n\t\t\tif(!Y.empty())Y.pop_back();\n\t\t}\n\t\telse{\n\t\t\tY.pop_back();\n\t\t}\n\t}\n\t\n\tT get(){\n\t\tT ret = init_value;\n\t\tif(!X.empty())ret = func(ret,X.back().second);\n\t\tif(!Y.empty())ret = func(ret,Y.back().second);\n\t\treturn ret;\n\t}\n\t\n\tT front(){\n\t\tif(!X.empty())return X.back().first;\n\t\tif(!Y.empty())return Y[0].first;\n\t\treturn init_value;\n\t}\n\t\n\tT back(){\n\t\tif(!Y.empty())return Y.back().first;\n\t\tif(!X.empty())return X[0].first;\n\t\treturn init_value;\n\t}\n\t\n};\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tlong long E,T;\n\tcin>>E>>T;\n\t\n\tvector<long long> x(N);\n\tfor(int i=0;i<N;i++)cin>>x[i];\n\tx.push_back(E);\n\t\n\tvector<long long> dp(x.size(),Inf);\n\tdp[0] = x[0];\n\t\n\tauto f = [](long long a,long long b){\n\t\treturn min(a,b);\n\t};\n\t\t\n\tSWAG<long long,decltype(f)> minT(f,Inf),minX(f,Inf);\n\tminT.push_back(dp[0]-x[0]);\n\tint now = 0;\n\t\n\tfor(int i=1;i<dp.size();i++){\n\t\twhile(now!=i&&(x[i-1]-x[now])*2>T){\n\t\t\tminT.pop_front();\n\t\t\tminX.push_back(dp[now]-3*x[now]);\n\t\t\tnow++;\n\t\t}\n\t\tdp[i] = min(minT.get()+T+x[i],minX.get()+x[i]+x[i-1]*2);\n\t\tminT.push_back(dp[i]-x[i]);\n\t}\n\t\n\tcout<<dp.back()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <utility>\n#include <map>\n#include <stack>\n#include <set>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <sstream>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define LB long double\n#define Pair pair<int,int>\n#define LOWBIT(x) x & (-x)\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=100;\n\ninline int getint()\n{\n\tchar ch;\n\twhile ((ch=getchar())<'0' || ch>'9') {}\n\tint res=ch-'0';\n\twhile ((ch=getchar())>='0' && ch<='9') res=res*10+ch-'0';\n\treturn res;\n}\n\nint n,e,T;\nLL a[100048];\npriority_queue<pair<LL,int> > q1,q2;\nLL dp[100048];\n\nint main ()\n{\n\tint i;\n\tn=getint();e=getint();T=getint();\n\tfor (i=1;i<=n;i++) a[i]=(LL)getint();\n\tdp[0]=0;\n\ta[0]=0;\n\tq2.push(mp(a[0]-dp[0],0));\n\t//dp[1]=a[1]+T;\n\t//q2.push(mp(a[1]-dp[1],1));\n\tint num1,num2;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\t\n\t\tbool f=true;\n\t\twhile (!q2.empty() && f)\n\t\t{\n\t\t\tint num=q2.top().y;f=false;\n\t\t\tif (T-2*a[i]+2*a[num+1]<0)\n\t\t\t{\n\t\t\t\tq2.pop();f=true;\n\t\t\t\tq1.push(mp(a[num]+2*a[num+1]-dp[num],num));\n\t\t\t}\n\t\t}\n\t\tLL ans1=LINF,ans2=LINF;\n\t\tif (!q1.empty())\n\t\t{\n\t\t\tnum1=q1.top().y;\n\t\t\tans1=dp[num1]+3*a[i]-a[num1]-2*a[num1+1];\n\t\t}\n\t\tif (!q2.empty())\n\t\t{\n\t\t\tnum2=q2.top().y;\n\t\t\tans2=dp[num2]+a[i]-a[num2]+T;\n\t\t}\n\t\tdp[i]=min(ans1,ans2);\n\t\tq2.push(mp(a[i]-dp[i],i));\n\t}\n\t//for (i=1;i<=n;i++) cout<<dp[i]<<' ';\n\t//cout<<endl;\n\tcout<<dp[n]+(e-a[n])<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[100010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+100010, 1e15);\n\n  dp[0] = 0;\n  int e = 0;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tfor(;e<N;++e){\n\t  LL d = xs[e] - xs[i];\n\t  LL tmp = dp[i] + t + d*3 + max(0ll, T-2*d);\n\t  dp[e+1] = min(dp[e+1], tmp);\n\t  if(T - 2*d < 0) break;\n\t}\n\tif(e > 0)\n\t  dp[e] = min(dp[e], dp[i] + t + xs[e-1] - xs[i] + T);\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nnamespace Segment_tree {\n\ttemplate<typename T>\n\tclass segment_tree {\n\t\tvector<T> dat;\n\t\tint n;\n\t\tT e;\n\t\tstd::function<T(T, T)> f;\n\t\tT query_implement(int a, int b, int k, int l, int r) {\n\t\t\tif (r <= a || b <= l) return e;\n\t\t\tif (a <= l && r <= b) return dat[k];\n\n\t\t\tT v1 = query_implement(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT v2 = query_implement(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn f(v1, v2);\n\t\t}\n\tpublic:\n\t\tsegment_tree(int n_, T _e, T(*calc)(T lhs, T rhs)) {\n\t\t\te = _e;\n\t\t\tf = calc;\n\t\t\tn = 1;\n\t\t\twhile (n < n_) n *= 2;\n\t\t\tdat.resize(2 * n - 1);\n\t\t\tfor (int i = 0; i < 2 * n - 1; i++)\n\t\t\t\tdat[i] = e;\n\t\t}\n\n\t\tvoid update(int k, int a) {\n\t\t\tk += n - 1;\n\t\t\tdat[k] = a;\n\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tdat[k] = f(dat[k * 2 + 2], dat[k * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT query(int a, int b) { return query_implement(a, b, 0, 0, n); }\n\t};\n}\nlong long int f(long long int i, long long int j) { return min(i, j); }\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\t\n\tSegment_tree::segment_tree<long long int> seg(n,1e10,f);\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tint index=lower_bound(ALL(x), int(x[i]-double(t)/2+0.001)) - x.begin();\n\t\tif (index >= i)\n\t\t\tindex = i-1;\n\t\tindex--;\n\t\tindex--;\n\t\tif (index > 0)\n\t\t\tres = min(res, dp[index] - 2 * x[index] - x[index + 1]);\n\t\tindex = lower_bound(ALL(x), int(x[i] - double(t) / 2+0.001)) - x.begin();\n\t\tindex--;\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t\tif (index < i -1) {\n\t\t\tlong long int a = seg.query(index, i-1 );\n\t\t\tres = min(res, a + x[i]);\n\t\t}\n\t\tdp[i] = res;\n\t\tif(i<n-1)\n\t\tseg.update(i,dp[i] - 2 * x[i] - x[i + 1] + t - 2 * x[i + 1]);\n\t}\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  X.push_back(e);\n  vector<ll> dp;\n  rep(i,n+2){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n  dp[1] = 0;\n\n  int memo = 0;\n  vector<ll> mins;\n  mins.push_back(0);\n\n  reps(i,n+1){\n    if(i != 1){\n\n      int j;\n      j = lower_bound(all(X), X[i-1] - t/2.0) - X.begin();\n      chmin(dp[i], dp[j] + t);\n\n      if(j-1 >= 0){\n        j = mins[j-1];\n        chmin(dp[i], dp[j] + (X[i-1] - X[j]) * 2);      \n      }\n    }\n\n    if((e-X[memo])*2+dp[memo] > (e-X[i])*2 + dp[i]){\n      memo = i;\n    }\n    mins.push_back(memo);\n  }\n\n  rep(i,n+2){\n    //cout<<dp[i]<<\" \"<<mins[i]<<endl;\n  }\n\n  cout<<dp[n+1] + e<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#define LL long long\n#define N 110000\nusing namespace std;\nLL x[N],f[N],s[N],inf=1ll<<50,ans,ed,t;\nint p[N],head,tail,n;\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&ed,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\ts[0]=t;\n\tint j=0;\n\thead=tail=1;p[1]=0;\n\ts[0]=-2*x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=inf;\n\t\twhile(2*(x[i]-x[j+1])>t) j++;\n\t\tif(j>0) f[i]=3*x[i]+s[j-1];\n\t\twhile(head<=tail && p[head]<j) head++;\n\t\tif(head<=tail) f[i]=min(f[i],f[p[head]]+x[i]-x[p[head]]+t);\n\t\twhile(head<=tail && f[p[tail]]-x[p[tail]]>=f[i]-x[i]) tail--;\n\t\tp[++tail]=i;\n\t\ts[i]=min(s[i-1],f[i]-x[i]-2*x[i+1]);\n\t}\n\tans=f[n]+ed-x[n];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<ll, int> ii;\n\nconst int len = 1e5+5;\nconst ll inf = 1e15;\nint a[len], n, en, t, nex[len];\nll dp[len], suf[len];\n//deque<ii> deq;\n\nint main(){\n    scanf(\"%d %d %d\", &n, &en, &t);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n\n    for (int i = 1, j = 1; i <= n; i++){\n        while (j <= n && 2*(a[j]-a[i]) <= t)\n            j++;\n        nex[i] = j;\n    }\n\n    //deq.push_back(mp(0, n+1));\n    suf[n+1] = inf;\n    for (int i = n; i >= 1; i--){\n        int j = nex[i];\n\n        dp[i] = min(dp[j]+t, suf[j]-2*a[i]);\n        //dp[i] = min(deq.front().fi+t, suf[j]-2*a[i]);\n\n        suf[i] = min(suf[i+1], dp[i+1]+2*a[i]);\n        /*while (!deq.empty() && dp[i] <= deq.back().fi)\n            deq.pop_back();\n        deq.push_back(mp(dp[i], i));\n        while(!deq.empty() && deq.front().se > nex[i-1])\n            deq.pop_front();*/\n    }\n\n    printf(\"%lld\\n\", dp[1]+en);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\ntypedef long long ll;\n\n//const int dx[4] = {1, 0, -1, 0};\n//const int dy[4] = {0, 1, 0, -1};\n\n// const int C ;\n// const int M = 1000000007;\n\nint N;\nll E;\nll T;\nll x[100010];\nll memo[100010];\n\nint main () {\n  cin >> N >> E >> T;\n  for (auto i = 0; i < N; i++) {\n    cin >> x[i];\n  }\n  fill(memo, memo+100010, -1);\n  memo[0] = x[0] + T;\n  int now = 1;\n  int ret = -1;\n  while (now < N) {\n    //cerr << \"ret = \" << ret << \", now = \" << now << endl;\n    ll back;\n    if (ret == -1) {\n      back = x[now];\n    } else {\n      back = memo[ret] + (x[now] - x[ret]);\n    }\n    ll time = x[now] - x[ret+1];\n    if (2 * time < T) back += (T - 2 * time);\n    back += 2 * time;\n    if (memo[now] == -1) {\n      memo[now] = back;\n      ret++;\n    } else {\n      if (memo[now] > back) {\n        memo[now] = back;\n        ret++;\n        if (ret > now) now++;\n      } else {\n        now++;\n      }\n    }\n  }\n  cout << memo[N-1] + (E - x[N-1]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nvi dp,in;\nll n,e,t;\nll f(ll i,ll j){return dp[j]+in[j+1]-in[j]+max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];}\nint main(){\n\tcin>>n>>e>>t;\n\tif(n>3000)return -1;\n\tin=vi(n+1);\n\trep(i,n)cin>>in[i+1];\n\tdp=vi(n+1,inf);\n\tdp[0]=0;\n\trep(i,n){\n//rep(j,i+1){\n\t\tll l=0,r=i+1;\n\t\twhile(r-l>3){\n\t\t\tll h1=(r-l)/3+l;\n\t\t\tll h2=(r-l)/3*2+l;\n\t\t\tll s1=f(i,h1);\n\t\t\tll s2=f(i,h2);\n\t\t\tif(s1>s2)l=h1;\n\t\t\telse r=h2;\n\t\t}\n\t\tll mi=inf;\n\t\tloop(j,max<ll>(l-3,0),min<ll>(i+1,r+3))mi=min(mi,f(i,j));\n\t\tdp[i+1]=mi;\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define gcd            __gcd\n#define setbits(x)     __builtin_popcountll(x)\n#define zrobits(x)     __builtin_ctzll(x)\n#define mod            1000000007\n#define mod2           998244353\n#define maxe           *max_element\n#define mine           *min_element\n#define inf            1e18\n#define deci(x, y)      fixed<<setprecision(y)<<x\n#define w(t)           int t; cin>>t; while(t--)\n#define nitin          ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define PI             3.141592653589793238\nusing namespace std;\nint pre[2001][2001];\nint find_ans(int l,int n,vector<int>&v)\n{\n    int ans=pre[l][n];\n    for(int j=l;j<n;j++)\n    {\n        ans=min(ans,pre[l][j]+find_ans(j+1,n,v)+v[j+1]-v[j]);\n    }\n    return ans;\n}\nint32_t main() {\n    nitin;\n    int n,e,t;\n    cin>>n>>e>>t;\n    vector<int>v(n+1,0);\n    for(int i=0;i<n;i++){\n        cin>>v[i+1];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            pre[i][j]=3*(v[j]-v[i])+(j-i+1)*max(t-2*(v[j]-v[i]),(int)0);\n        }\n    }\n    int ans=v[1];\n    ans+=find_ans(1,n,v);\n    ans+=e-v[n];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst llong inf = 1e16;\nint n, e, t;\nint x[100002];\nllong seg1[1 << 18];\nllong seg2[1 << 18];\n\nvoid update(llong seg[], int i, int s, int e, int x, llong v) {\n    if (s == e) {\n        seg[i] = v;\n        return;\n    }\n    int m = (s + e) / 2;\n    if (x <= m) update(seg, i << 1, s, m, x, v);\n    else update(seg, i << 1 | 1, m + 1, e, x, v);\n    seg[i] = min(seg[i << 1], seg[i << 1 | 1]);\n}\n\nllong query(llong seg[], int i, int s, int e, int x, int y) {\n    if (e < x || y < s) return inf;\n    if (x <= s && e <= y) return seg[i];\n    int m = (s + e) / 2;\n    return min(query(seg, i << 1, s, m, x, y)\n               , query(seg, i << 1 | 1, m + 1, e, x, y));\n}\n\nint main() {\n    for (int i = 0; i < (1 << 18); ++i) seg1[i] = seg2[i] = inf;\n    scanf(\"%d%d%d\", &n, &e, &t);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", x + i);\n    }\n    update(seg1, 1, 0, n, 0, -x[1]);\n    update(seg2, 1, 0, n, 0, -2 * x[1]);\n    llong dp;\n    for (int i = 1; i <= n; ++i) {\n        int j = lower_bound(x, x + (n + 1), x[i] - (t - 1) / 2) - x;\n        llong dp1 = query(seg1, 1, 0, n, j - 1, i - 1) + x[i] + t;\n        llong dp2 = query(seg2, 1, 0, n, 0, j - 2) + 2 * x[i];\n        dp = min(dp1, dp2);\n        update(seg1, 1, 0, n, i, dp - x[i + 1]);\n        update(seg2, 1, 0, n, i, dp - 2 * x[i + 1]);\n    }\n    \n    printf(\"%lld\\n\", dp + e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i, pos = i;\n    while (low <= high) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 <= T) {\n        high = mid - 1, pos = mid;\n      }\n      else {\n        low = mid + 1;\n      }\n    }\n    if (pos) --pos;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:60777216\")  \n\n#include <cassert>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<complex>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<cstdlib>\n#include<memory.h>\n#include<ctime>\n#include<bitset>\n#include<fstream>\n#include<queue>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef long double ld;\n\ntypedef long long ll;\ntypedef pair<int,int>\tpii;\ntypedef pair<ld,ld>\tpdd;\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef pair<ll,ll> pl;\n\n#define FOR(i,a,b)\t\tfor(int i=(a);i<(b);i++)\n#define REP(i,n)\t\tFOR(i,0,n)\n#define SORT(v)\t\t\tsort((v).begin(),(v).end())\n#define UN(v)\t\t\tSORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)\t\t\t\tmemset(a,b,sizeof a)\n#define pb\t\t\t\tpush_back\n\nint n,e,t;\nint x[222222];\n\n\nll  r[222222];\nint p[222222];\n\nint main(){\t\n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>e>>t;\n\tif(n>10000)return 0;\n\tREP(i,n)scanf(\"%d\",x+i+1);\n\tFOR(i,1,n+1){\n\t\tr[i]=1e18;\n\t\tFOR(prev,p[i-1],i){\n\t\t\tint diff = x[i] - x[prev+1];diff*=2;\n\t\t\tif(r[i]>r[prev]+max(diff,t)){\n\t\t\t\tr[i]=r[prev]+max(diff,t);\n\t\t\t\tp[i]=prev;\n\t\t\t}\n\t\t\tif(diff<t)break;\n\t\t}\n\t/*\tint prev = p[i-1];\n\t\tr[i] = r[prev] + solve(prev,i);\n\t\twhile(prev+1<i && r[i] > r[prev+1]+solve(prev+1,i)){\n\t\t\tprev++;\n\t\t\tr[i] = r[prev] + solve(prev,i);\n\t\t}\n\t\tp[i] = prev;*/\n\t}\n\n\tcout<<r[n]+e<<endl;\n\n\n\n#ifdef LocalHost\n\tprintf(\"TIME: %.3lf\\n\",ld(clock())/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\nconst long long INF = 1LL<<60;\n\ntemplate<class Monoid> struct RMQ {\n    const Monoid INF;\n    int SIZE_R;\n    vector<pair<Monoid,int> > dat;\n    \n    RMQ(int n, const Monoid &inf): INF(inf) { init(n); }\n    void init(int n) {\n        SIZE_R = 1;\n        while (SIZE_R < n) SIZE_R *= 2;\n        dat.assign(SIZE_R * 2, pair<Monoid,int>(INF, -1));\n    }\n    \n    /* set, a is 0-indexed */\n    void set(int a, const Monoid &v) { dat[a + SIZE_R] = make_pair(v, a); }\n    void build() {\n        for (int k = SIZE_R - 1; k > 0; --k) {\n            dat[k] = min(dat[k*2], dat[k*2+1]);\n        }\n    }\n    \n    /* update, a is 0-indexed */\n    void update(int a, const Monoid &v) {\n        int k = a + SIZE_R;\n        dat[k] = make_pair(v, a);\n        while (k >>= 1) dat[k] = min(dat[k*2], dat[k*2+1]);\n    }\n    \n    /* get {min-value, min-index}, a and b are 0-indexed */\n    pair<Monoid,int> get(int a, int b) {\n        pair<Monoid,int> vleft = make_pair(INF, -1), vright = make_pair(INF, -1);\n        for (int left = a + SIZE_R, right = b + SIZE_R; left < right; left >>= 1, right >>= 1) {\n            if (left & 1) vleft = min(vleft, dat[left++]);\n            if (right & 1) vright = min(dat[--right], vright);\n        }\n        return min(vleft, vright);\n    }\n    inline Monoid operator [] (int a) { return dat[a + SIZE_R].first; }\n    \n    /* debug */\n    void print() {\n        for (int i = 0; i < SIZE_R; ++i) {\n            Monoid val = (*this)[i];\n            if (val < INF) cout << val;\n            else cout << \"INF\";\n            if (i != SIZE_R-1) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n\n\n\nint N;\nlong long T, E;\nvector<long long> x;\n\nlong long solve() {\n    vector<long long> dp(N+1, INF);\n    RMQ<long long> r1(N+1, INF), r2(N+1, INF);\n    dp[0] = 0;\n    r1.update(0, -x[0] * 2);\n    r2.update(0, 0);\n    for (int i = 1; i <= N; ++i) {\n        int ut = upper_bound(x.begin(), x.end(), x[i-1] - (T+1)/2) - x.begin() - 1;\n        int lt = lower_bound(x.begin(), x.end(), x[i-1] - (T-1)/2) - x.begin();\n        chmin(ut, i-1);\n        chmin(dp[i], r1.get(0, ut+1).first + x[i-1] * 3);\n        chmin(dp[i], r2.get(lt, i).first + x[i-1] + T);\n        r1.update(i, dp[i] - x[i] * 2 - x[i-1]);\n        r2.update(i, dp[i] - x[i-1]);\n\n        //cout << i << \": \" << dp[i] << endl; r1.print(); r2.print();\n    }\n    return dp[N] + (E - x[N-1]);\n}\n\nint main() {\n    while (cin >> N >> E >> T) {\n        x.resize(N);\n        for (int i = 0; i < N; ++i) cin >> x[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>  \n#include<iostream>  \n#include<algorithm>  \n#include<cstdlib>  \n#include<cstring>\n#include<string>\n#include<climits>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<ctime>\n#define LL long long\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n  \ninline char nc(){\n    /* \n  static char buf[100000],*p1=buf,*p2=buf;\n  if (p1==p2) { p2=(p1=buf)+fread(buf,1,100000,stdin); if (p1==p2) return EOF; }\n  return *p1++;\n    */return getchar();\n}\n  \ninline void read(int &x){\n  char c=nc();int b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\n  \ninline void read(LL &x){\n  char c=nc();LL b=1;\n  for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;\n  for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\n \ninline int read(char *s)\n{\n    char c=nc();int len=1;\n    for(;!(c=='.'||c=='#');c=nc()) if (c==EOF) return 0;\n    for(;(c=='.'||c=='#');s[len++]=c,c=nc());\n    s[len++]='\\0';\n    return len-2;\n}\n \ninline void read(char &x){\n  for (x=nc();!(x>='0' && x<='1');x=nc());\n}\n \nint wt,ss[19];\ninline void print(int x){\n    if (x<0) x=-x,putchar('-'); \n    if (!x) putchar(48); else {\n    for (wt=0;x;ss[++wt]=x%10,x/=10);\n    for (;wt;putchar(ss[wt]+48),wt--);}\n}\ninline void print(LL x){\n    if (x<0) x=-x,putchar('-');\n    if (!x) putchar(48); else {for (wt=0;x;ss[++wt]=x%10,x/=10);for (;wt;putchar(ss[wt]+48),wt--);}\n}\n\nint n,q[100010];\nLL m,T,a[100010],f[100010],Minout;\n\n\nint main()\n{\n    read(n);read(m);read(T);\n    for (int i=1;i<=n;i++)\n        read(a[i]),f[i]=m*10+T*10;\n    int l=1,r=1;\n    LL z=m*10+T*10;\n    for(int i=1;i<=n;i++)\n    {\n        while(l<=r&&2*(a[i]-a[q[l]+1])>T)\n            z=min(z,f[q[l]]-a[q[l]]-2*a[q[l]+1]),l++;\n        f[i]=min(f[i],a[i]+z+2*a[i]);\n        f[i]=min(f[i],f[q[l]]+a[i]-a[q[l]]+T);\n        while(l<=r&&f[q[l]]-a[q[l]]>=f[i]-a[i]) r--;\n        q[++r]=i;\n    }\n    LL ans=f[n]+m-a[n];\n    print(ans),puts(\"\");\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    ll N,E,T; cin >> N >> E >> T;\n    if (N > 2000) return 0;\n    vector<ll> X(N); rv(X);\n\n    vector<ll> H(N, 0);\n    for (int i = 0; i < N; i++) {\n        H[i] = X[i] + max(T, 2*X[i] - 2*X[0]);\n        for (int j = 0; j < i; j++) {\n            H[i] = min(H[i], H[j] + X[i] - X[j] + max(T, 2*X[i] - 2*X[j+1]));\n        }\n    }\n    cout << H[N-1] + E - X[N-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\n#define LL long long\nLL dp[MAXN],a[MAXN],T,tmp=1000000000000000LL;\nint n,m,t;\nint main()\n{\n\tfreopen(\"computer.in\",\"r\",stdin);\n\tfreopen(\"computer.out\",\"w\",stdout);\n\tscanf(\"%d%d%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(T<=2*(a[i]-a[t+1]))\n\t\t\ttmp=min(tmp,dp[t]-2*a[t+1]),t++;\n\t\tdp[i]=min(tmp+2*a[i],dp[t]+T);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node; \npublic:\n    SegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, inf);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint N;\nll T,E;\n\nll res(vector<ll>& X){\n    vector<ll> dp(N+1,inf);\n    dp[0] = 0;\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i]-X[i-1]+T;\n        for(int j=1;j<=i-1;j++){\n            dp[i] = min(dp[i],dp[j-1]+X[j]-X[j-1]+3*(X[i]-X[j])+max(T-2*(X[i]-X[j]),0LL));\n        }\n    }\n    return dp[N]+(E-X[N]);\n}\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    SegmentTree seg1(vector<ll>(N+1,inf)),seg2(vector<ll>(N+1,inf));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.update(0,dp[0]-X[1]);\n    seg2.update(0,dp[0]-3*X[1]);\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i+1]-X[i]+T;\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        //cerr << i << \" \" << id << \" \" << seg1.getmin(id,i) << \" \" << seg2.getmin(0,id) << endl;\n        if(id>0) dp[i] = min(dp[i],seg1.getmin(id-1,i)+T+X[i+1]);\n        if(id>0) dp[i] = min(dp[i],seg2.getmin(0,id-1)+2*X[i]+X[i+1]);\n        seg1.update(i,dp[i]-X[i+1]);\n        seg2.update(i,dp[i]-3*X[i+1]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n    //cerr << res(X) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  ll bestF = Inf; \n  auto relaxF = [&] (int i) {\n    bestF = min(bestF, dp[i] - x[i] - (ll)t * i);\n  };\n  auto get0 = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1]; \n  };\n  auto gett = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1] + 2 * x[i + 1];\n  };\n  relaxF(0);\n  multiset <ll> h0, ht;\n  ht.insert(gett(0));\n  int uk = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (uk < i && t - 2 * x[i] + 2 * x[uk + 1] < 0) {\n      ht.erase(ht.find(gett(uk)));\n      h0.insert(get0(uk));\n      ++uk;\n    }\n    dp[i] = bestF + x[i] + (ll)t * i;\n    if (!h0.empty()) dp[i] = min(dp[i], *h0.begin() + 3 * x[i]); \n    if (!ht.empty()) dp[i] = min(dp[i], *ht.begin() + 3 * x[i] + t - 2 * x[i]);\n    /*for (int j = i + 1; j <= n; ++j) {\n      ll extra = max(0LL, t - 2 * x[j] + 2 * x[i + 1]);\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }*/\n    relaxF(i);\n    ht.insert(gett(i));\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n; ll T,E;\nll x[N];\nll f[N];\ntypedef long long ll;\nstruct data{\n\tll x,y;int id;\n\tdata(ll x=0,ll y=0,int id=0):x(x),y(y),id(id){}\n}t[N];int u,v;\n\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tx[n+1]=E;\n\tf[0]=x[1];\n\t/*\n\tf[i]=min(f[j]+(x[i]-x[j+1])*2+T (x[i]-x[j+1])<=T)\n\t*/\n\tu=v=1;t[1]=data(x[1],f[0]-x[1]+T,0);\n\t\n\tll Lmin=1000000000000000000;\n\tint j=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(u<=v&& 2ll*x[i]-2ll*t[u].x > T ) ++u;\n\t\twhile(j<i&&2ll*x[i]-2ll*x[j+1] > T){\n\t\t\tLmin=min(Lmin,f[j]-3ll*x[j+1]);\n\t\t\t++j;\n\t\t}\n\t\tf[i]=Lmin+3*x[i];\n\t\t\n\t\tif(u<=v){\n\t\t\t\n\t\t\tf[i]=min(f[i],1ll*x[i]+t[u].y);\n\t\t}\n\t\tf[i]+=x[i+1]-x[i];\n\t\tdata newnode=data(x[i+1],f[i]-x[i+1]+T,0);\n\t\t//cout<<i<<\"::>>>\"<<newnode.y<<\" \"<<f[i]<<\" \"<<2*x[i+1]<<' '<<T<<endl;\n\t\twhile(u<=v&&newnode.y <= t[v].y)--v;\n\t\tt[++v]=newnode;\n//\t\tfor(int j=u;j<=v;j++)cout<<t[j].y<<\" \";puts(\"\");\n//\t\tcout<<i<<\" , \"<<f[i]<<endl;\n\t}\n//\tputs(\"\");\n\tprintf(\"%lld\\n\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint last=0,lastt=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\t//if(lastt!=0)\n\t\t//dp[i]=min(dp[i],(x[i]-x[last+1])*2+dp[last]);\n\t\tfor(int j=lastt;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif((x[i]-x[j+1])*2<t)\n\t\t\t{\t\n\t\t\t\tlastt=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//if(dp[i]==(x[i]-x[j+1])*2+dp[j])\n\t\t\t//last=j;\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nclass starry_sky_tree{\npublic:\n  static const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n  using Int = long long;\n  Int segMin[2 * MAX_SIZE - 1], segAdd[2 * MAX_SIZE - 1];\n\n  starry_sky_tree(){\n    fill(segMin, segMin + 2*MAX_SIZE-1, 0);\n    fill(segAdd, segAdd + 2*MAX_SIZE-1, 0);\n  }\n\n  //区間[a, b)に値xを加算する.\n  void add(int a, int b, Int x, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return; //もし交差しない区間であれば終える.\n    \n    if (a <= l && r <= b){ //もし今みている区間[l, r)が[a, b)に完全に内包されていれば\n      segAdd[k] += x;  //区間[l, r)にkを加算する.\n      return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子の区間に(必要があれば)xを加算する.\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃\n\n    //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である.一様に加算される値は更新しなくて良い.\n    segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n  }\n\n  Int getMin(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return (1ll<<57);\n    \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]); //完全に内包されていれば,その区間の最小値を返す.\n    \n    Int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2); //子の区間の最小値を求める.\n    Int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r); //子の区間の最小値を求める\n    \n    return (min(left, right) + segAdd[k]); //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である (大切なので2回書きました!!)\n    \n  }\n};\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  starry_sky_tree a, b;\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      j++;\n    }\n    if(j) dp[i+1] = min(dp[i+1], a.getMin(0, j));\n    dp[i+1] = min(dp[i+1], t+ b.getMin(j, i+1));\n\n    a.add(0,i+1, 2*(x[i+1]-x[i]));\n    b.add(i+1, i+2, dp[i+1]);\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nconst int mn = 1 << 17;\nll dp[mn],x[mn];\nint n, nn; ll dat[2][2*mn-1];\nvoid init() {\n\tnn = 1;\n\twhile (nn < n)nn *= 2;\n\trep(i, 2 * nn - 1)dat[0][i] = dat[1][i] = INF;\n}\nvoid update(int id, int k, ll a) {\n\tk += nn - 1;\n\tdat[id][k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[id][k] = min(dat[id][k * 2 + 1], dat[id][k * 2 + 2]);\n\t}\n}\nll query(int id,int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[id][k];\n\telse {\n\t\tll vl = query(id, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(id, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tcin >> n; n++;\n\tinit();\n\tll e, t; cin >> t >> e;\n\trep(i, n-1) {\n\t\tcin >> x[i];\n\t}\n\tx[n-1] = t;\n\tfill(dp, dp + n + 2, INF);\n\tdp[0] = x[0];\n\tupdate(0, 0, 0);\n\tupdate(1, 0, -2*x[0]);\n\trep1(i, n-1) {\n\t\tint loc = lower_bound(x, x + n, x[i-1] - e / 2) - x;\n\t\tll mi1 = query(1, 0, loc, 0, 0, nn) + x[i] + 2*x[i - 1];\n\t\tll mi2 = query(0, loc, i, 0, 0, nn) + e + x[i];\n\t\tdp[i] = min(mi1, mi2);\n\t\tupdate(0, i, dp[i] - x[i]);\n\t\tupdate(1, i, dp[i] - 3 * x[i]);\n\t}\n\tcout << dp[n-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\ntypedef long long ll;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n;\nll t,e,x[N],f[N];\nll calc(int l,int r) {\n    return x[r]-x[l]+max(x[r]-x[l+1],t-(x[r]-x[l+1]))+x[r]-x[l+1];\n}\nint main() {\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    memset(f,0x3f,sizeof(f));f[0]=0;\n    for(int i=1;i<=n;i++) {\n        f[i]=calc(0,i);\n        for(int j=1;j<i;j++) f[i]=min(f[i],f[j]+calc(j,i));\n    }\n    printf(\"%lld\\n\",f[n]+abs(x[n]-e));\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[2001];\t//1-indexed, x[0] = 0\nint dp[2001];\t//dp[i] = 左からi個を回収するのにかかる時間の最小値\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tdp[0] = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i; j <= n; j++) {\n\t\t\tint cst;\n\t\t\tif (i == 0) {\n\t\t\t\tif (2 * (x[j] - 1) > t) { cst = 3 * (x[j] - 1) + 1; }\n\t\t\t\telse { cst = t + x[j]; }\n\t\t\t}\n\t\t\t\n\t\t\telse if (2 * (x[j] - x[i]) > t) { cst = 3 * (x[j] - x[i]); }\n\t\t\telse { cst = t + (x[j] - x[i]); }\n\t\t\tdp[j] = min(dp[i] + cst, dp[j]);\n\t\t}\n\t}\n\t\n//\tfor (i = 0; i <= n; i++) { cout << dp[i] << endl; }\n\t\n\tcout << dp[n] + e - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, t, e;\nvi x;\nll dp[2222][2222];\n\nll solve(int p, int col)\n{\n\tif (dp[p][col] >= 0) return dp[p][col];\n\tll res = 0;\n\tif (p == n - 1 && col == n)\n\t{\n\t\tres = e - x[n - 1];\n\t}\n\telse if (p == n - 1)\n\t{\n\t\tll d = x[p] - x[col];\n\t\tll tmp;\n\t\tif (d * 2 <= t) tmp = t;\n\t\telse tmp = d * 2;\n\t\tres = tmp + solve(n - 1, n);\n\t}\n\telse\n\t{\n\t\tll dist = x[p + 1] - x[p];\n\t\tll tmp;\n\t\tll d = x[p] - x[col];\n\t\tif (d * 2 <= t) tmp = t;\n\t\telse tmp = d * 2;\n\t\tres = dist + min(solve(p + 1, col), solve(p + 1, p + 1) + tmp);\n\t}\n\treturn dp[p][col] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\tcin >> n >> e >> t;\n\tif (n > 2000) return 1;\n\tx.resize(n);\n\tREP(i, n) cin >> x[i];\n\tcout << x[0] + solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,e,t,x[200000];\nlong long dp[200000];\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tfor(int i=1,k=0;i<=n;i++)\n\t{\n\t\tdp[i]=1ll<<40;\n\t\twhile(k<n&&(x[i]-x[k+1])*2>t)k++;\n\t\tdp[i]=min(dp[0]+x[i]+max(t,(x[i]-x[1])<<1),dp[k]+x[i]-x[k]+max(t,(x[i]-x[k+1])<<1));\n\t}\n\t//for(int i=1;i<=n;i++)printf(\"DP %d = %lld\\n\",i,dp[i]-x[i]);\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <iostream>\n#include <sstream>\n#include <complex>\n#include <cassert>\n#include <bitset>\n\n#define enp     puts(\"**chkchkchkchkchk**\")\n#define A       first\n#define B       second\n#define MP      make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\n\nconst int INF = 0x60000000;\nconst int MINF = -1000000000;\nconst int mod = 1000000007;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\nconst int sqrtMax = 317;\nconst int blocks = cons / 3;\n\nll dp[2001];\nll pos[2001];\nint n;\nll e, t;\n\nint main() \n{\n\tscanf(\"%d%lld%lld\", &n, &e, &t);\n\n\tfor (int i = 1; i <= n; i++)scanf(\"%lld\", &pos[i]);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tdp[i] = 1e18;\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tdp[i] = min(dp[i], dp[j] - pos[j] + pos[i] \n\t\t\t\t+ max(t, 2 * pos[i] - 2 * pos[j + 1]));\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", e - pos[n] + dp[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 1000 * 1000 + 47;\n\nint n, e, t;\nint X[MAX];\nLL dp[MAX];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> X[i];\n\t}\n\n\tFOR(i, 0, n + 1) dp[i] = INF;\n\tdp[0] = 0;\n\tint p = 0;\n\tLL minn = LINF;\n\n\tFOR(i, 1, n + 1)\n\t{\n\t\twhile (2 * (X[i - 1] - X[p]) > t)\n\t\t{\n\t\t\tminn = min(dp[p] - 2 * X[p], minn);\n\t\t\tp++;\n\t\t}\n\n\t\tdp[i] = minn + 2 * X[i - 1];\n\t\tdp[i] = min(dp[i], dp[p] + t);\n\t}\n\n\tcout << dp[n] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvll v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tv.PB(INFL);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tmins(dp[min(it,n-1)],dp[i]+T);\n\t\tint p = it+1;\n\t\tint it2 = upper_bound(ALL(v), v[i]+T)-v.begin();\n\t\treep(j,p,it2+1){\n\t\t\tmins(dp[min(j,n-1)], dp[i]+2*(v[j-1]-v[i]));\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=1000001;\nint n,m,ans,ban[maxn],x,vis[maxn],E,T,lim[maxn];\nstruct heapy\n{\n    priority_queue<int>q1,q2;\n    int sz;\n    void add(int x){q1.push(-x);++sz;}\n    void del(int x){q2.push(-x);--sz;}\n    int top()\n    {\n        if(q1.empty())return 1e9;\n        while(!q2.empty()&&q1.top()==q2.top())q1.pop(),q2.pop();\n        return -q1.top();\n    }\n}l,r;\nint f[maxn],a[maxn];\nsigned main()\n{\n    cin>>n>>E>>T;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    n++;a[n]=E;\n    for(int i=1,j=1;i<=n;i++)\n    {\n        while(a[j]-a[i]<=T/2&&j<=n)lim[j]=i,j++;\n    }\n  //  for(int i=1;i<=n;i++)cout<<lim[i]<<\" \";cout<<endl;\n    f[1]=a[1];r.add(f[1]-a[1]+T);\n  //  cout<<1<<\" \"<<f[1]<<endl;\n    for(int i=1,j=1;i<=n;i++)\n    {\n        while(j<lim[i]&&j<=n)\n            r.del(f[j]-a[j]+T),l.add(f[j]-3*a[j]),j++;\n      //  cout<<i<<\" \"<<l.top()<<\" \"<<r.top()<<endl;\n        f[i+1]=min(l.top()+3*a[i],r.top()+a[i])+a[i+1]-a[i];\n      //  cout<<f[i+1]-a[i+1]+a[i]<<\" \"<<f[i+1]<<endl;\n        r.add(f[i+1]-a[i+1]+T);\n    }\n    cout<<f[n];\n}\n/*\n8 20 6\n1 2 3 5 7 9 11 18\n简单地贪了一发之后感觉没有指望，又简单地dp了一发之后发现不对劲，所以在外面套一个二分。\n一次dfs一定是走进一个子树，回来，走进另一个子树，再回来。\nfij表示i子树内，起点到i距离不超过j的最近终点距离，每次匹配一次，这转移就并不困难了。\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\nint dp[100006];\nsigned main(){\n\tint n,e,t;cin>>n>>e>>t;\n\trep(i,n)cin>>x[i];\n\trep(i,n+1)dp[i]=inf;\n\t\n\tif(n>2000)return 0;\n\t\n\tdp[0]=0;\n\tx[n]=x[n-1];\n\trep(i,n){\n\t\tfor(int j=i;j<n;j++){\n\t\t\tdp[j+1]=min(dp[j+1],dp[i]+x[j]-x[i]+max(2*(x[j]-x[i]),t)+x[j+1]-x[j]);\n\t\t\t}\n\t\t}\n\t\t\n\tcout<<dp[n]+x[0]+e-x[n-1]<<endl;\t\n\t}\n"
  },
  {
    "language": "C++",
    "code": "//https://discuss.codechef.com/t/robagain-editorial/20734\n#pragma GCC optimize(\"O3\")\n#include<queue>\n#include <cmath>\n#include <complex>\n#include<map>\n#include <string>\n#include<iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <stdio.h>\n#include<bits/stdc++.h>\n\n\n/*\n#define x real()\n#define y imag()\n#define angle(a)                (atan2((a).imag(), (a).real()))\n#define vec(a,b)                ((b)-(a))\n#define same(p1,p2)             (dp(vec(p1,p2),vec(p1,p2)) < EPS)\n#define dp(a,b)                 ( (conj(a)*(b)).real() )\t// a*b cos(T), if zero -> prep\n#define cp(a,b)                 ( (conj(a)*(b)).imag() )\t// a*b sin(T), if zero -> parllel\n#define length(a)               (hypot((a).imag(), (a).real()))\n#define normalize(a)            (a)/length(a)\n//#define polar(r,ang)            ((r)*exp(point(0,ang)))  ==> Already added in c++11\n#define rotateO(p,ang)          ((p)*exp(point(0,ang)))\n#define rotateA(p,ang,about)  (rotateO(vec(about,p),ang)+about)\n#define reflectO(v,m)  (conj((v)/(m))*(m))\n*/\n\n//#define pi 3.141592654\n#define forr(i,a,b) for(int i=a;i<=b;i++)\n#define F first\n#define S second\n#define input ios_base::sync_with_stdio(0);cin.tie(0);\n#define NOT(x) (1^x)\n\nconst double PI  = acos(-1.0);\nusing namespace std;\ntypedef pair<double,double>pdd;\ntypedef long long  ll;\ntypedef pair<ll, ll>pii;\ntypedef complex<double> point;\n\n//int x[8]={1,0,0,-1,-1,-1,1,1};\n//int y[8]={0,1,-1,0,-1,1,-1,1};\n//const int N=500009,M=1000000;\nconst double EPS= 1e-9,eps=-1e9;\nconst int N =100005;\n\nll n,e,t,mem[N][2],x;\nvector<ll>a,b;\nmap<ll,ll>id;\nll dp(int i=0,int ck=0)\n{\n    if(i>=n)return 0;\n    ll&ret=mem[i][ck];\n    if(~ret)return ret;\n    ret=1e15;\n    auto it=upper_bound(a.begin(),a.end(),a[i]+t/2);\n    int j=it-a.begin();\n    if(ck==0){\n        ret=min(ret,dp(b[j],0)+t);\n        if(i+1!=n)ret=min(ret,dp(b[j],1)+(a[j]-a[i])*(ll)2);\n    }\n    if(ck){\n        ret=min(ret,dp(i+1,0));\n        if(i+1!=n)ret=min(ret,dp(i+1,1)+(a[i+1]-a[i])*(ll)2);\n    }\n    return ret;\n}\n int main()\n{\n//freopen(\"travel.in\",\"r\",stdin);\n//freopen(\"travel.out\",\"w\",stdout);\n//__builtin_popcount()\ninput;\n\n\n      cin>>n>>e>>t;\n      for(int i=0;i<n;i++)\n      {\n          cin>>x;\n          a.push_back(x);\n          b.push_back(i);\n      }\n      a.push_back(e);\n      b.push_back(n);\n      memset(mem,-1,sizeof mem);\n      cout<<e+dp()<<endl;\n\n\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nconst int N=2e5+3,M=1e9+7;\nint n,x,y,a,b,ans,sum,t[N],invf[N],c[N],d,f[N];\nstd::vector<int>h[N];\nbool Cmp(const int&i,const int&j){\n\tif(!h[i].size())return 0;\n\tif(!h[j].size())return 1;\n\treturn h[i][0]<h[j][0];\n}\ninline int Pow(int a,int m){int s=1;for(;m;m>>=1)m&1?s=1ll*s*a%M:0,a=1ll*a*a%M;return s;}\nvoid InC(){\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++)f[i]=1ll*f[i-1]*i%M;\n\tinvf[n]=Pow(f[n],M-2);\n\tfor(int i=n;i;i--)invf[i-1]=1ll*invf[i]*i%M;\n}\ninline int C(int n,int m){return 1ll*f[n]*invf[m]%M*invf[n-m]%M;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tInC();\n\tfor(int i=1;i<=n;i++)\n\t  scanf(\"%d%d\",&a,&b),h[a].push_back(b),\n\t  t[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t  std::sort(h[i].begin(),h[i].end());\n\t  for(int j=1;j<h[i].size();j++)\n\t\tif(h[i][0]+h[i][j]<=x)c[i]=j;\n\t}\n\tstd::sort(t+1,t+1+n,Cmp);\n\tif(!h[t[2]].size())return 0*puts(\"1\");\n\tfor(int i=1,k;h[t[i]].size();i++){\n\t  k=i==1?2:1;\n\t  for(int j=0;j<h[t[i]].size();j++)\n\t\tif(h[t[k]][0]+h[t[i]][j]<=y&&j>c[t[i]])c[t[i]]=j;\n\t  if(h[t[i]][0]+h[t[k]][0]<=y)d=i;\n\t}\n\tans=1;sum=0;\n\tfor(int i=1;i<=d;i++)sum+=c[t[i]]+1;\n\tfor(int i=1;i<=d;i++)\n\t  ans=1ll*ans*C(sum,c[t[i]]+1)%M,\n\t  sum-=c[t[i]]+1;\n\tprintf(\"%d\",ans);\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[112345];\nint n,ppp,pp\t,s,t,d[112345];\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&d[i]);\n\tpp = 0;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = (1 << 31) - 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tf[i] = min(f[i],f[j] + max(2 * (d[i] - d[j + 1]),t));\n//\t\tprintf(\"%d %lld\\n\",i,f[i]);\n\t//\tprintf(\"%d %lld\\n\",i,f[i]);\n//\tfor (int i = 1; i <= n; i++)\n\t//\tprintf(\"%lld \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",s + f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nconst ll inf = (1LL<<60) - 1;\n\nint n,e,t,p[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i];\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]+t-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll INF = 1e18;\n\ntemplate<typename T>\nstruct SegmentTree{\n    const T INF = 1e18;\n    int n, width;\n    vector<T> dat;\n\n    void init(int x){\n        n = x;\n        width = 1;\n        while (width < n) width *= 2;\n        dat.assign(2*width-1, INF);\n    }\n\n    void update(int i, T x){\n        i += width - 1;\n        dat[i] = x;\n        while (i > 0){\n            i = (i - 1) / 2;\n            dat[i] = min(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n\n    T query(int a, int b, int k, int l, int r){\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n\n    // [l, r)\n    T query(int l, int r){\n        return query(l, r, 0, 0, width);\n    }\n};\n\nint main() {\n    ll n, e, t;\n    cin >> n >> e >> t;\n    VL x(n);\n    REP(i,n) x[i] = in();\n    VL dp(n + 1, INF);\n    dp[0] = 0;\n    SegmentTree<ll> seg1, seg2;\n    seg1.init(n);\n    seg2.init(n);\n    seg1.update(0, 0);\n    seg2.update(0, -2 * x[0]);\n    int i = 0;\n    REP(j,n){\n        while (2 * (x[j] - x[i]) > t) i++;\n        chmin(dp[j + 1], seg1.query(i, j + 1) + t);\n        chmin(dp[j + 1], seg2.query(0, i) + 2 * x[j]);\n        seg1.update(j + 1, dp[j + 1]);\n        seg2.update(j + 1, dp[j + 1] - 2 * x[j + 1]);\n    }\n    // REP(i,n+1) cout << dp[i] << endl;\n    ll ans = e + dp[n];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\n#define mid ((s + e) / 2)\n#define int long long\n\nint n, ed, tad;\nint x[N];\nint dp[N];\nint seg[N * 4];\nint laz[N * 4];\nint get(int l, int r, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn 2e18;\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\treturn min(get(l, r, v * 2, s, mid), get(l, r, v * 2 + 1, mid, e));\n}\nvoid add(int l, int r, int val, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[v] += val;\n\t\tlaz[v] += val;\n\t\treturn;\n\t}\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v * 2] += laz[v];\n\tlaz[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\tadd(l, r, val, v * 2, s, mid);\n\tadd(l, r, val, v * 2 + 1, mid, e);\n\tseg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\nint tmp[N];\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> ed >> tad;\n\tint pnt = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tadd(0, 1, 0 + x[1] - 0 + tad);\n\t\t}\n\t\tadd(0, pnt, (x[i] - x[i - 1]) * 2);\n\t\twhile ((x[i] - x[pnt + 1]) * 2 >= tad) {\n\t\t\tadd(pnt, pnt + 1, (x[i] - x[pnt + 1]) * 2 - tad);\n//\t\t\tcout << \"pnt << \" << pnt << endl;\n\t\t\tpnt++;\n\t\t}\n\t\tadd(0, i - 1, x[i] - x[i - 1]);\n/*\t\tcout << \"all done : \" << endl;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tcout << j << \" > \" << get(j, j + 1) << \"    \"; \n\t\tcout << endl;*/\n\t\tdp[i] = get(0, i);\n//\t\tcout << \"dp[i] : \" << i << \" \" << dp[i] << \" \" << tmp[i] << endl << endl << endl;\n\t\tadd(i, i + 1, dp[i] + x[i + 1] - x[i] + tad);\n\t}\n\tcout << ed - x[n] + dp[n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(s...)  fprintf(stderr, s)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n\ntemplate<class T> struct RMQ {\n    int n;\n    vector<T> A; vector<int> I;\n    RMQ(int n_=0): n(n_), A(n), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = I[2*i];\n    }\n    RMQ(const vector<T> &a): n(a.size()), A(a), I(2*n) {\n\tfor (int i=0; i<n; i++) I[i+n] = i;\n\tfor (int i=n; --i;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    void modify(int i, const T &v) {\n\tA[i] = v;\n\tfor (i+=n; i>>=1;) I[i] = (A[I[i*2+1]] < A[I[i*2]]? I[i*2+1]: I[i*2]);\n    }\n    int min_i(int x, int y) {\n\tx += n; y += n;\n\tint p = -1;\n\tfor (; x<y; x>>=1, y>>=1) {\n\t    if (y & 1) { --y; if (p < 0 || A[I[y]] < A[p]) p = I[y]; }\n\t    if (x & 1) { if (p < 0 || A[I[x]] < A[p]) p = I[x]; x++; }\n\t}\n\treturn p;\n    }\n    T min_v(int x, int y) { return A[min_i(x, y)]; }\n};\n\nint N, T, E;\nint A[100111];\nLL dp[100111];\n\nint main() {\n\n    scanf(\"%d%d%d\", &N, &E, &T);\n    REP (i, N) scanf(\"%d\", A+i+1);\n    A[N+1] = E;\n\n    RMQ<LL> X1(N + 10), X2(N + 10);\n    X1.modify(0, -2LL * A[1]);\n\n\n    int mid = 0;\n    LL cst = 0;\n    for (int i=1; i<=N; i++) {\n\n\twhile (2LL * (A[i] - A[mid]) > T) mid++;\n\tcst = 1LL << 60;\n\n\tif (0 < mid-1) amin(cst, X1.min_v(0, mid-1) + 3LL * A[i]);\n\tif (mid-1 < i) amin(cst, X2.min_v(max(0, mid-1), i) + T + A[i]);\n\tamin(cst, X2.min_v(i-1, i) + T + A[i]);\n\n\tX1.modify(i, cst - 2LL * A[i+1] - A[i]);\n\tX2.modify(i, cst - A[i]);\n\n//\teprintf(\"%d %lld %d\\n\", i, cst, mid);\n    }\n\n    LL ans = cst + E - A[N];\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nvector<int>x, memo;\nint N, E, T;\n\nint solve(int posindex) {\n\t//x[posindex]の位置についた直後で、自分より手前の熊は処理済みで、自分より奥の熊は手付かず\n\n\tif (posindex == N)return 0;\n\tif (memo[posindex] != -1)return memo[posindex];\n\n\tint ans = intmax;\n\n\t//その場で待つ\n\tans = min(ans, solve(posindex + 1) + T + x[posindex + 1] - x[posindex]);\n\n\t//先まで行く\n\tREP(i, posindex+1, N) {\n\t\tint sol = solve(i + 1);\n\t\tint dist = x[i] - x[posindex];\n\t\tint gets = max(T + dist, dist * 3);\n\t\tint res = sol + gets + x[i + 1] - x[i];\n\t\tif (ans < res)break;\n\t\tans = res;\n\t}\n\tmemo[posindex] = ans;\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tx = vector<int>(N+1);\n\tmemo = vector<int>(N,-1);\n\trep(i, N)cin >> x[i];\n\tx[N] = E;\n\tsort(ALL(x));\n\n\n\t\n\tcout << x[0] + solve(0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long i64;\n\nint n;\ni64 t;\ni64 e;\nvector<i64> x;\n\ni64 dp[100010];\n\ni64 rec(int end_x)\n{\n\tif(dp[end_x] != -1) return dp[end_x];\n\t//cout << \"end\" << end_x << endl;\n\tif(end_x == n)\n\t{\n\t\t//cout << \"n\" << endl;\n\t\treturn (dp[end_x] = e - x[n]);\n\t}\n\t\n\tauto ite = lower_bound(x.begin(),x.end(), x[end_x + 1] + t / 2 + t % 2);\n\tint i = ite - x.begin();\n\t//cout << \"ite : \" << i << endl;\n\ti64 v1 = (1LL << 62);\n\ti64 v2 = v1;\n\tif(i < n + 1)\n\t{\n\t\tv1 = rec(i) + (x[i] - x[end_x + 1]) * 3;\n\t}\n\ti--;\n\tif(i < n + 1)\n\t{\n\t\tv2 = rec(i) + (x[i] - x[end_x + 1]) + t;\n\t}\n\t\n\treturn (dp[end_x] = min(v1,v2) + x[end_x + 1] - x[end_x]);\n}\n\n\n\n\n\n\n\nint main()\n{\n\tfill(dp,dp + 100010,-1LL);\n\tcin >> n >> e >> t;\n\tx.assign(n +1,0);\n\tx[0] = 0;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\n\tcout << rec(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nint N, E, T;\nvector<int> X;\nvector<ll> dp;\n\nll f(int i, int j){\n    return dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    cin >> N >> E >> T;\n    X.assign(N + 1, 0);\n    rep(i, 1, N + 1) cin >> X[i];\n    \n    // i\n    dp.assign(N + 1, 1LL << 60);\n    dp[0] = 0;\n    rep(i, 1, N + 1){\n        \n        int l = 0; int r = i - 1;\n        int cnt = 0;\n        while(r - l > 5 && cnt < 50){\n            int ml = (2 * l + r) / 3;\n            int mr = (l + 2 * r) / 3;\n            if(f(i, ml) < f(i, mr)){\n                r = mr;\n            }\n            else{\n                l = ml;\n            }\n            cnt++;\n        }\n        rep(j, l, r + 1){\n            dp[i] = min(dp[i], f(i, j));\n        }\n        \n        \n//        rep(j, i){\n//            dp[i] = min(dp[i], dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1]);\n//        }\n    }\n    \n    ll ret = dp[N] + (E - X[N]);\n    \n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MAXN = 1e6 + 100 ;\n \n \nlong long dp[MAXN] , tmp[MAXN] , nx[MAXN] , a[MAXN] ; \n \nint32_t main(){\n\t//ios_base::sync_with_stdio(0) ;\n\t//cin . tie(0) ; cout . tie(0) ; \n \n\tint n ; cin >> n ; \nif(n > 10000) return 0;\n\tint e , t ; cin >> e >> t ; \n\tfor(int i = 0 ; i < n ; i ++)\n\t\tcin >> a[i] ; \n\tint l = n - 1 ; \n\t//cout << \"Hir\" << endl ; \n\tfor(int i = n - 1 ; i >= 0 ; i --){\n\t\twhile(l > 0 && 2 * (a[i] - a[l - 1]) <= t)\n\t\t\tl -- ; \n\t\tnx[i] = l ; \n\t}\n\t//cout << \"Hir\" << endl ; \n\tmemset(dp , 63 , sizeof dp) ; \n\tmemset(tmp , 63 , sizeof tmp) ; \n\tdp[0] = 0 ; \n\ttmp[0] = -2 * a[0] ;\n\t//cout << 0 << ' ' << dp[0]<< ' '  << tmp[0]<< ' ' << '\\n' ; \n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tdp[i] = t + dp[nx[i - 1]] ;\n\t\tif(nx[i - 1]) dp[i] = min(dp[i] , 2 * a[i - 1] + tmp[nx[i - 1] - 1]) ;\n\t\ttmp[i] = min(tmp[i - 1] , dp[i] - 2 * a[i]) ; \n\t\t//cout << i << ' ' << dp[i] << ' ' << tmp[i] << '\\n' ; \n\t}\n\tcout << dp[n] + e ; \n \n}"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T;\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\t/*while(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}*/\n\t\tdp[i] = LINF;\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tdp[i] = min(dp[i] , cost(i , j));\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,t,e,x,ab,a[200005],dp[200005];\nint main(){\n\tn=read(),e=read(),t=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\ta[n+1]=e;\n\tfor(int i=1;i<=n;i++){\n\t\twhile((s[i]-s[ab+1])*2>t)\n\t\t\tx=min(x,dp[ab]-2*s[ab+1]),ab++;\n\t\tdp[i]=min((ll)(1e18),dp[ab]+t);\n\t\tif(ab)dp[i]=min(dp[i],2*s[i]+x);\n\t}\n\tprintf(\"%lld\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint N, E, T;\nint x[100001];\n\nint main(int argc, char **argv) {\n\tcin >> N >> E >> T;\n\tREP(i, N) cin >> x[i];\n\tx[N] = E;\n\tll c = 0, t = x[0];\n\twhile (c < N) {\n\t\tcerr << t << endl;\n\t\tint r = c;\n\t\twhile (r < N - 1 && x[r + 1] - x[c] < T) ++r;\n\t\tt += max(T, (x[r] - x[c]) * 2);\n\t\tt += x[r + 1] - x[c];\n\t\tc = r + 1;\n\t}\n\tcout << t << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <vector>\n#include <array>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <valarray>\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;Scan(__VA_ARGS__);\ntemplate<typename T> void Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void Scan(First& first, Rest&...rest) { std::cin >> first; Scan(rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\t\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& i : v){std::cerr << i << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr << j << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& i : v){for(const auto& j : i){std::cerr<<'('<<j.first<<\", \"<<j.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& i:v){std::cerr<<'('<<i.first<<\", \"<<i.second<<\") \";}std::cout<<\"\\n\";}\n#define CHECKTIME(state) {auto start=std::chrono::system_clock::now();state();auto end=std::chrono::system_clock::now();auto res=std::chrono::duration_cast<std::chrono::nanoseconds>(end-start).count();std::cerr<<\"[Time:\"<<res<<\"ns  (\"<<res/(1.0e9)<<\"s)]\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\n#define CHMAX(a, b) a = (((a)<(b)) ? (b) : (a))\n#define CHMIN(a, b) a = (((a)>(b)) ? (b) : (a))\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^19\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238;\n\nint dp[2003][2003];\nint tt[2003];\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\tassert(n <= 2000);\n\n\tauto calc = [&](int i, int j) {\n\t\treturn 3 * (x[j] - x[i]) + std::max(t - 2 * (x[j] - x[i]), 0LL);\n\t};\n\n\tREP(i, n) FOR(j, i, n) {\n\t\tdp[i][j] = calc(i, j);\n\t}\n\n\tstd::fill(tt, tt + n+1, INFLL);\n\ttt[0] = x[0];\n\n\tauto xx = [&](ll i) {\n\t\treturn (i == n) ? e : x[i];\n\t};\n\n\tREP(i, n+1) {\n\t\tif (i != 0) {\n\t\t\tCHMIN(tt[i], tt[i - 1] + t + xx(i) - x[i - 1]);\n\t\t}\n\t\tREP(j, i) {\n\t\t\tCHMIN(tt[i], tt[j] + dp[j][i-1] + xx(i) - x[i - 1]);\n\t\t}\n\t}\n\n\t/*REP(i, n) {\n\t\tREP(j, n) {\n\t\t\tOUT(dp[i][j])SP;\n\t\t}BR;\n\t}\n\tREP(i, n+1) {\n\t\tOUT(tt[i])SP;\n\t}BR*/;\n\n\tOUT(tt[n])BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/* Karen {{{\n  ___  ____\n |_  ||_  _|\n   | |_/ /    ,--.   _ .--.  .---.  _ .--.\n   |  __'.   `'_\\ : [ `/'`\\]/ /__\\\\[ `.-. |\n  _| |  \\ \\_ // | |, | |    | \\__., | | | |\n |____||____|\\'-;__/[___]    '.__.'[___||__]\n}}} */\n/* cpp template {{{*/\nusing namespace std;\n\n#define endl '\\n'\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define REPS(i, a, n) for (int i = (a); i < (n); i++)\n#define RREP(i, n) for (int i = 1; i <= (n); i++)\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ALL(v) v.begin(), v.end()\n\ntypedef double D;\ntypedef int ll;\ntypedef long double lb;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\ntypedef pair<int, int> pii;\ntypedef pair<int, string> pis;\ntypedef pair<string, int> psi;\n\ninline bool inside(int y,int x,int H,int W){return(y>=0&&x>=0&&y<H&&x<W);}\ninline int in() {int x; std::cin >> x; return x;}\n\ntemplate <typename T>\nvoid print(std::vector<T>& v, char c = ' ') {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << c;\n    std::cout << v[i];\n  }\n  std::cout << endl;\n}\ntemplate <typename T>\nvoid print(T x) {\n  std::cout << x << '\\n';\n}\n/* }}} */\n/* 定数 {{{*/\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9 + 9;\nconst D EPS  = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n/* }}} */\n\n#define int long long\n\nint x[101010];\nint n, e, T;\n\nint cost;\n\nint dp[101010];\n\nint dfs(int i=1, int now=0, int t=T)\n{\n  int d = x[i] - x[now];\n  int dt = max(0ll, t - 2ll * d);\n  int dT = max(0ll, T - 2ll * d);\n  if (i == n) return t;\n  int &ret = dp[i];\n  //if (ret != -1) return ret;\n  ret = min(t + d + dfs(i + 1, now + 1, T), dt + 3 * d + dfs(i + 1, now + 1, dT));\n\n  cout << i << \":\" << now << \"=\" << ret << endl;\n  return ret;\n}\n\nsigned main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> n >> e >> T;\n  REP(i, n) cin >> x[i];\n\n  cost += x[0] + e - x[n - 1];\n\n  cout << dfs() + cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\ntemplate<typename T,typename E>\nstruct LazySegmentTree{\n    using F=function<T(T,T)>;\n    using G=function<T(T,E)>;\n    using H=function<E(E,E)>;\n    \n    int n;\n    vector<T> dat;\n    vector<E> lazy;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    \n    LazySegmentTree(int n_,F f,G g,H h,T ti,E ei) :f(f),g(g),h(h),ti(ti),ei(ei){\n        n=1;\n        while(n<n_) n*=2;\n        dat.assign(2*n-1,ti);\n        for(int i=n-2;i>=0;i--) dat[i]=f(dat[i*2+1],dat[i*2+2]);\n        \n        lazy.assign(2*n-1,ei);\n    }\n    \n    LazySegmentTree(int n_,vector<T> &v,F f,G g,H h,T ti,E ei) :f(f),g(g),h(h),ti(ti),ei(ei){\n        n=1;\n        while(n<n_) n*=2;\n        dat.assign(2*n-1,ti);\n        \n        for(int i=n-1;i-(n-1)<v.size();i++) dat[i]=v[i-(n-1)];\n        \n        for(int i=n-2;i>=0;i--) dat[i]=f(dat[i*2+1],dat[i*2+2]);\n        \n        lazy.assign(2*n-1,ei);\n    }\n    \n    inline void eval(int k,int l,int r){\n        \n        if(lazy[k]==ei) return;\n        \n        dat[k]=g(dat[k],lazy[k]);\n        \n        if(r-l>1){\n            lazy[k*2+1]=h(lazy[k*2+1],lazy[k]);\n            lazy[k*2+2]=h(lazy[k*2+2],lazy[k]);\n        }\n        \n        lazy[k]=ei;\n    }\n    \n    void update_(int a,int b,E x,int k,int l,int r){\n        \n        eval(k,l,r);\n        \n        if(r<=a||b<=l) return;\n        \n        if(a<=l&&r<=b){\n            lazy[k]=h(lazy[k],x);\n            eval(k,l,r);\n        }\n        \n        else{\n            update_(a,b,x,2*k+1,l,(l+r)/2);\n            update_(a,b,x,2*k+2,(l+r)/2,r);\n            dat[k]=f(dat[2*k+1],dat[2*k+2]);\n        }\n        \n    }\n    \n    void update(int a,int b,E x){\n        return update_(a,b,x,0,0,n);\n    }\n    \n    T query_(int a,int b,int k,int l,int r){\n        \n        eval(k,l,r);\n        \n        if(r<=a||b<=l) return ti;\n        if(a<=l&&r<=b) return dat[k];\n        \n        T vl=query_(a,b,2*k+1,l,(l+r)/2);\n        T vr=query_(a,b,2*k+2,(l+r)/2,r);\n        return f(vl,vr);\n    }\n    \n    T query(int a,int b){\n        return query_(a,b,0,0,n);\n    }\n    \n};\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N),def(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(INF);\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    LazySegmentTree<ll,ll> seg(N,\n                               def,\n                               [](ll a,ll b){return min(a,b);},\n                               [](ll a,ll b){return a+b;},\n                               [](ll a,ll b){return a+b;},\n                               INF,\n                               0);\n    \n    int last=0;\n    \n    for(int i=1;i<=N;i++){\n        int left=-1,right=i;\n        while(right-left>1){\n            int mid=(left+right)/2;\n            if(seg.query(mid,mid+1)<=T) right=mid;\n            else left=mid;\n        }\n        chmin(dp[i],T+dp[right]);\n        chmin(dp[i],seg.query(0,right));\n        \n        if(i!=N) seg.update(0,i,2*(A[i]-A[i-1]));\n        \n        while(last<N){\n            if(seg.query(last,last+1)>T){\n                seg.update(last,last+1,dp[last]);\n                last++;\n            }else break;\n        }\n    }\n    \n    cout<<dp[N]+E<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define N (100000+1000)\n#define LL long long\nusing namespace std;\n\nLL n,e,t,f[N],a[N],Segt[N<<2],p;\n\nvoid Update(LL now,LL l,LL r,LL x,LL v)\n{\n\tif (l==r) {Segt[now]+=v; return;}\n\tLL mid=(l+r)>>1;\n\tif (x<=mid) Update(now<<1,l,mid,x,v);\n\telse Update(now<<1|1,mid+1,r,x,v);\n\tSegt[now]=min(Segt[now<<1],Segt[now<<1|1]);\n}\n\nLL Query(LL now,LL l,LL r,LL l1,LL r1)\n{\n\tif (l>r1 || r<l1) return 1e17;\n\tif (l1<=l && r<=r1) return Segt[now];\n\tLL mid=(l+r)>>1;\n\treturn min(Query(now<<1,l,mid,l1,r1),Query(now<<1|1,mid+1,r,l1,r1));\n}\n\nint main()\n{\n//\tfreopen(\"data.in\",\"r\",stdin);\n//\tfreopen(\"datam.out\",\"w\",stdout);\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\twhile (p<=i-1 && 2*(a[i]-a[p])>=t)\n\t\t\tUpdate(1,1,n,p,-2*a[p]),p++;\n\t\tLL temp=1e17;\n\t\ttemp=min(temp,Query(1,1,n,1,p-1));\n\t\tif (p<=i-1) temp=min(temp,Query(1,1,n,p,i-1)+t-2*a[i]);\n\t\tf[i]=min(temp+3*a[i],f[i-1]+a[i]-a[i-1]+t);\n\t\tUpdate(1,1,n,i,-a[i-1]+f[i-1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std;\nset<pair<long long,long long> > s; \nlong long x[100008],dp[100008];\nint main()\n{\n\tlong long n;cin>>n;long long t,e;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i],s.insert(make_pair(x[i],i));for(long long i=0;i<100005;i++) dp[i]=2e9;\n\tdp[0]=0;s.insert(make_pair(0,0));\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tint j;set<pair<long long,long long> >::iterator it=s.lower_bound(make_pair(x[i]-(t+1)/2,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\tit=s.lower_bound(make_pair(x[i]-t,0));\n\t\tif(it!=s.end())j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t\t--it;if(it!=s.end() and (++it)!=s.begin())--it,j=(*it).second;dp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll inf=999999999999999999;\nint n,id;\nll a[101010],f[101010],T,E;\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i) f[i]=inf;\n\tll minn=inf;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\twhile (T<=2*(a[i]-a[id+1]))\n\t\t\tminn=min(minn,f[id]-2*a[id+1]),++id;\n\t\tf[i]=min(f[id]+T,2*a[i]+minn);\n\t}\n\tprintf(\"%lld\\n\",E+f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T;\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tdp[i] = LINF;\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tdp[i] = min(dp[i] , cost(i , j));\n\t}\n\tfor(int i = 0; i < N - 1; i++)\n\t{\n\t\tif(dp[i + 1] < dp[i])\n\t\t{\n\t\t\tcout << 1 / 0;\n\t\t}\n\t}\n\tcout << dp[N - 1] + E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\ntypedef long long ll;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n;\nll t,e,x[N],f[N];\nll calc(int l,int r) {\n    return x[r]-x[l]+max(x[r]-x[l+1],t-(x[r]-x[l+1]))+x[r]-x[l+1];\n}\nstruct data { int x,l,r; } q[N];\nint main() {\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    memset(f,0x3f,sizeof(f));f[0]=0;\n    int h=1,t=0;q[++t]=(data){0,1,n};\n    for(int i=1;i<=n;i++) {\n        while(q[h].r<i) h++;\n        f[i]=f[q[h].x]+calc(q[h].x,i);\n        while(h<=t&&f[q[t].x]+calc(q[t].x,q[t].l)>=f[i]+calc(i,q[t].l)) t--;\n        if(h>t) q[++t]=(data){i,i+1,n};\n        else {\n            int l=q[t].l,r=q[t].r,ret=q[t].r+1;\n            while(l<=r) {\n                int mid=(l+r)>>1;\n                if(f[q[t].x]+calc(q[t].x,mid)>=f[i]+calc(i,mid)) ret=mid,r=mid-1;\n                else l=mid+1;\n            }\n            q[t].r=ret-1;if(ret<=n) q[++t]=(data){i,ret,n};\n        }\n    }\n    /*for(int i=1;i<=n;i++) {\n        f[i]=calc(0,i);int p=0;\n        for(int j=1;j<i;j++) if(f[j]+calc(j,i)<f[i]) f[i]=f[j]+calc(j,i),p=j;\n        }*/\n    printf(\"%lld\\n\",f[n]+abs(x[n]-e));\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: d.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;} template<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>ll dcmp(T a,T b){return a>b;}\ntemplate<ll *a>ll cmp_a(ll x,ll y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst ll SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; ll f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// prll the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed lleger\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// prll a signed lleger\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nll f[100005],s[100005],mx[100005];\nll q[100005],*l,*r;\nvoid add(ll w){\n\twhile(l<=r&&w<*r)--r;\n\t*(++r)=w;\n}\nvoid del(ll w){\n\tif(*l==w)++l;\n}\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"d.in\",\"r\",stdin);\n\tfreopen(\"d.out\",\"w\",stdout);\n#endif\n\tll n,t,e;\n\tread(n);\n\tread(e,t);\n\tfor(ll i=1;i<=n;++i)read(s[i]);\n\tmx[0]=-2*s[1];\n\t*(l=r=q)=0;\n\tfor(ll i=1,j=0;i<=n;++i){\n\t\twhile((s[i]-s[j+1])*2>t){del(f[j]);++j;}\n\t\tf[i]=*l+t;\n\t\tif(j)chkmin(f[i],mx[j-1]+s[i]*2);\n\t\tadd(f[i]);\n\t\tmx[i]=min(mx[i-1],f[i]-2*s[i+1]);\n\t}\n\twrite(f[n]+e,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint l[N],x[N];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[l[i]]+max(2*(x[i]-x[l[i]+1]),t);\n\t\twhile(l[i]+1<i&&dp[l[i]+1]+max(2*(x[i]-x[l[i]+2]),t)<dp[i]){\n\t\t\tdp[i]=dp[l[i]+1]+max(2*(x[i]-x[l[i]+2]),t);\n\t\t\tl[i]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//By Don4ick \n//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define y1 qewr1234\n\nconst double PI = acos(-1.0);\nconst int DIR = 4;\nconst int X[] = {1, 0, -1, 0};\nconst int Y[] = {0, 1, 0, -1};\n\nconst ll INF = (ll)1e18 + 228;\nconst int N = (int)1e5 + 228;\n\nusing namespace std;\n\nint n, e, T, x[N];\nll dp[N], t[2][N + N];\n\nvoid upd(int v, ll val, int type)\n{\n\tv += n - 1;\n\tt[type][v] = min(t[type][v], val);\n\twhile(v != 1)\n\t{\n\t\tv >>= 1;\n\t\tt[type][v] = min(t[type][v << 1], t[type][v << 1 | 1]);\n\t}\n}\n\nll get(int l, int r, int type)\n{\n\tl += n - 1;\n\tr += n - 1;\n\tll res = INF;\n\twhile(l <= r)\n\t{\n\t\tif (l & 1)\n\t\t\tres = min(res, t[type][l++]);\n\t\tif (!(r & 1))\n\t\t\tres = min(res, t[type][r--]);\n\t\tl >>= 1, r >>= 1;\t\t\t\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie();\n\t//cout.tie();\t\t\n\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\n\t//~read\n\tscanf(\"%d%d%d\", &n, &e, &T);\n\tforn(i, n)\t\n\t\tscanf(\"%d\", &x[i]);\n\t//~solve\n\tfor (int i = 1; i < n + n; i++)\n\t\tt[0][i] = t[1][i] = INF;\n\tforn(i, n)\n\t{\n\t\tupd(i, dp[i - 1] - x[i - 1], 0);\n\t\tupd(i, dp[i - 1] - x[i - 1] - 2ll * x[i], 1);\n\t\tint l = 0, r = i + 1;\n\t\twhile(l < r - 1)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (2ll * (x[i] - x[mid]) <= T)\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\tdp[i] = min(get(r, i, 0) + x[i] + T, get(1, r - 1, 1) + 3ll * x[i]);\n\t}\n\tcout << dp[n] + e - x[n] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e5 + 10, INF = 2e18;\nint x[MAXN], dp[MAXN];\nint n, e, t;\nint32_t main () {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i =0; i < n; ++i) {\n        cin >> x[i];\n        dp[i] = INF;\n    }\n    x[n] = e;\n    int mn = INF;\n    int point = n;\n    for (int i = n - 1; i >= 0; --i) {\n        while (x[point - 1] - x[i] > t / 2) {\n            mn = min(mn,dp[point] + x[point] + 2 * x[point - 1]);\n            --point;\n        }\n        dp[i] = min(mn - 3 * x[i], dp[point] + x[point] - x[i] + t);\n    }\n    cout << dp[0] + x[0];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\tvl e(N+1,e18);\n\td[0]=0;\n\te[0]=T;\n\tfoor(i,1,N){\n\t\tfr(j,i){\n\t\t\tif(2*(x[i]-x[j+1])>T){\n\t\t\t\tif(2*(x[i-1]-x[j+1])<=T){\n\t\t\t\t\te[j]=d[j]+2*(x[i]-x[j+1]);\n\t\t\t\t}else{\n\t\t\t\t\te[j]+=2*(x[i]-x[i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfr(j,i){\n\t\t\tchmin(d[i],e[j]);\n\t\t}\n\t\te[i]=d[i]+T;\n\t}\n\tprint(d[N]+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define re register\n#define il inline\n#define inf 0x3f3f3f\n\nconst ll maxn = 2e5 + 5;\nll n, E, T, x[maxn], f[maxn], ans, ok = 1e18;\nll l = 1, r = 1, q[maxn];\nll read() {\n  ll x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-')\n      f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return f * x;\n}\nint main() {\n  memset(f, 0x3f, sizeof f);\n  n = read(), E = read(), T = read();\n  for (int i = 1; i <= n; ++i)\n    x[i] = read();\n  f[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (l <= r && 2 * (x[i] - x[q[l] + 1]) > T) {\n      ok = min(ok, f[q[l]] - 2 * x[q[l] + 1]);\n      l++;\n    }\n    f[i] = min(f[i], f[q[l]] + T);\n    f[i] = min(f[i], ok + 2 * x[i]);\n    q[++r] = i;\n  }\n  ans = f[n] + E;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nmultiset<long long>Set1, Set2;\nint n, E, T, w[101000];\nlong long D[101000];\nint main(){\n    int i, pv = 1;\n    scanf(\"%d%d%d\",&n,&E,&T);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    w[n+1] = E;\n    D[1] = w[1];\n    for(i=1;i<=n;i++){\n        long long r = 1e15, tp;\n        Set2.insert(D[i] - w[i]);\n        while(pv<=i && (w[i] - w[pv]) * 2 > T){\n            Set2.erase(Set2.find(D[pv] - w[pv]));\n            Set1.insert(D[pv] - 1ll*3*w[pv]);\n            pv++;\n        }\n        if(!Set1.empty()){\n            tp = *Set1.begin();\n            if(r > tp + w[i]*3ll) r = tp + w[i]*3ll;\n        }\n        tp = *Set2.begin();\n        if(r > tp + w[i] + T) r = tp + w[i] + T;\n        D[i+1] = w[i+1] - w[i] + r;\n    }\n    printf(\"%lld\\n\",D[n+1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint N, E, T;\n\twhile(cin >> N >> E >> T){\n\t\tlong long res = E;\n\t\tvector<int> x(N);\n\t\tfor(int i=0;i<N;i++) cin >> x[i];\n\t\tvector<long long> dp(N+1);\n\t\tvector<long long> dp2(N);\n\t\tdp[N-1] = E+T; dp[N] = E;\n\t\tdp2[N-1] = dp[N] + 2*x[N-1];\n\t\tint thr = N-1;\n\t\tfor(int i=N-2;i>=0;i--){\n\t\t\tdp[i] = dp[i+1] + T;\n\t\t\twhile(2*(x[thr] - x[i]) > T) --thr;\n\t\t\tdp[i] = min(T + dp[thr+1], dp2[i+1] - 2*x[i]);\n\t\t\tdp2[i] = min(dp2[i+1], dp[i+1] + 2*x[i]);\n\t\t}\n\t\tcout << dp[0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nint main(){\n    ll n,e,t;\n    cin>>n>>e>>t;\n    vector<ll> a(n);\n    for(auto &I:a){cin>>I;}\n    ll r=0;\n    vector<pll> dp(n,{E,E});\n    dp[0]={t,0};\n    for(int i=0;i+1<n;i++){\n        while(r<n && (a[r]-a[i])*2<=t){\n            dp[r].F=min(dp[r].F,dp[i].S+t);\n            r++;\n        }\n        if(r<n){dp[r].F=min(dp[r].F,dp[i].S+2*(a[r]-a[i]));}\n        dp[i+1].F=min(dp[i+1].F,dp[i].F+2*(a[i+1]-a[i]));\n        dp[i+1].S=min(dp[i+1].S,dp[i].S+t);\n        dp[i+1].S=min(dp[i+1].S,dp[i].F);\n    }\n    cout<<e+min(dp.back().F,dp.back().S+t)<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = (1e5)+1;\n\nint n;\nlong long E, T, x[MAX], dp[MAX], f[MAX];\nmultiset<long long> l, m;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> E >> T;\n\tl.insert(f[0] = T);\n\tfor(int i = 1, j = 0; i <= n; i++) {\n\t\tcin >> x[i];\n\t\twhile(j < i && 2*(x[i]-x[j+1]) >= T) {\n\t\t\tl.erase(l.find(f[j]));\n\t\t\tf[j] = f[j]-T-2*(x[j+1]);\n\t\t\tm.insert(f[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i] = LLONG_MAX;\n\t\tif(!l.empty()) dp[i] = min(x[i]+*l.begin(), dp[i]);\n\t\tif(!m.empty()) dp[i] = min(3*x[i]+*m.begin(), dp[i]);\n\t\tl.insert(f[i] = dp[i]-x[i]+T);\n\t}\n\tcout << dp[n]+E-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n  int N, E, T, pos[100000]; ll t[100000];\n  scanf(\"%d %d %d\", &N, &E, &T);\n  for(int i=0; i<N; i++) scanf(\"%d\", &pos[i]);\n  t[0] = pos[0];\n  for(int i=0; i<N; i++){\n    if(i==N-1){ t[i]+=T; break; }\n    int maxIdx = i;\n    while(maxIdx<N-1 && pos[maxIdx+1]-pos[i]<T){\n      maxIdx++; t[maxIdx] = t[i]+pos[maxIdx]-pos[i];\n    }\n    t[i] = max(t[i]+T, t[maxIdx]+pos[maxIdx]-pos[i]);\n    for(int j=i+1; j<=maxIdx; j++) t[j] = max(t[j]+T, t[j-1]+pos[j]-pos[j-1]);\n    if(maxIdx<N-1) t[maxIdx+1] = t[maxIdx]+pos[maxIdx+1]-pos[maxIdx];\n    i = maxIdx;\n  }\n  printf(\"%lld\\n\", t[N-1]+E-pos[N-1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e5 + 10;\nconst int INF = 2e9;\n\nint dp[MAXN], seg[4 * MAXN], x[MAXN];\n\nvoid _set(int v, int l, int r, int p, int x) {\n    if (r - l == 1) {\n\tseg[v] = x;\n\treturn;\n    }\n    int mid = (r + l) / 2;\n    if (p < mid) \n\t_set(2 * v, l, mid, p, x);\n    else\n\t_set(2 * v + 1, mid, r, p, x);\n    seg[v] = min(seg[2 * v], seg[2 * v + 1]);\n}\n\nint query(int v, int l, int r, int s, int t) {\n    if (s <= l && r <= t)\n\treturn seg[v];\n    int mid = (l + r) / 2, res = INF;\n    if (s < mid)\n\tres = min(res, query(2 * v, l, mid, s, t));\n    if (t > mid)\n\tres = min(res, query(2 * v + 1, mid, r, s, t));\n    return res;\n}\n\nint lower(int val, int s, int t) {\n    if (t - s == 1)\n\treturn s;\n    int mid = (s + t) / 2;\n    if (x[mid-1] >= val)\n\treturn lower(val, s, mid);\n    else\n\treturn lower(val, mid, t);\n}\n\nmain() {\n    int N, T, E;\n    cin >> N >> E >> T;\n    T *= 2;\n    for (int i = 0; i < N; i ++) cin >> x[i], x[i] *= 2;\n    for (int i = 0; i < N; i ++) {\n\tint last = lower(x[i] - T/2, 0, N);\n\t//if(i)cerr << dp[i-1] << endl;\n\tif (last <= 1) {\n\t    dp[i] = (last?2 * x[i] - 2 * x[0] : T);\n\t    if(i)dp[i] = min(dp[i], dp[last - 1] + T);\n\t    _set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n\t    continue;\n\t}\n\tdp[i] = query(1, 0, N, 0, last-1) + 2 * x[i]; dp[i] = min(dp[i], dp[last- 1] + T);\n\t_set(1, 0, N, i, dp[i] - 2 * x[i+1]);\n    }\n    cout << dp[N -1]/2 + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (int i = 1; i <= n; ++i) a[i] = F();\n\tif (n > 2000) return 0;\n\tR long long ans = E;\n\tR int last = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = i * T;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tlong long S = a[i] - a[j], temp = dmax(T - 2 * S, 0);\n\t\t\tcmin(f[i], f[j - 1] + temp * (i - j + 1) + S * 2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define MAXN 55\n# define MAXM 100005\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nint a[100005];\n\nint main()\n{\n    int n, E, T;\n    LL ans=0;\n    scanf(\"%d%d%d\",&n,&E,&T);\n    FO(i,0,n) scanf(\"%d\",a+i);\n    ans+=a[0];\n    int i=0, flag=1;\n    while(i<n-1) {\n        if (flag) {\n            if (a[i+1]-a[i]<T) ans+=(LL)3*(a[i+1]-a[i]), flag=0;\n            else ans+=(LL)(a[i+1]-a[i])+T, flag=1;\n        }\n        else {\n            ans+=(LL)a[i+1]-a[i], flag=1;\n        }\n        ++i;\n    }\n    if (flag==1) ans+=T;\n    ans+=(LL)E-a[n-1];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nlong double solve(int n,long double a,long double d){\n    if(!n) return 0;\n    long double res=a+d*(2*n-1)/2;\n    long double a1=(a*(n-1)*2+(a+2*d)+(3*a+3*d))/(2*n);\n    long double a2=((a+d)*(2*(n-1)-1)+(a+3*d)*2+(3*a+6*d))/(2*n);\n    return res+solve(n-1,a1,a2-a1);\n}\n\nint main(){\n    int n;\n    double a,d;\n    scanf(\"%d%lf%lf\",&n,&a,&d);\n    printf(\"%.20lf\\n\",(double)solve(n,a,d));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 100054;\n\nint n, t;\nint x[N];\nll f[N];\n\ninline void down(ll &x, const ll y) {x > y ? x = y : 0;}\n\nint main() {\n\tint i, j = 0; ll ans, r = 0x3f3f3f3f3f3f3f3fll;\n\tscanf(\"%d%lld%d\", &n, &ans, &t);\n\tfor (i = 1; i <= n; ++i) {\n\t\tfor (scanf(\"%d\", x + i); x[j + 1] < x[i] - t / 2; ++j)\n\t\t\tdown(r, f[j] - 2 * x[j + 1]);\n\t\tdown(f[i] = r + 2 * x[i], f[j] + t);\n\t}\n\tprintf(\"%lld\\n\", ans + f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(-inputs[1], 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i],now_cost + 2 * inputs[i]);\n\t\twhile (next.empty() == false&&2 * (inputs[i] - inputs[next.top().second])> t) {\n\t\t\tnext.pop();\n\t\t}\n\t\t\n\t\tif (next.size() != 0) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\t\n\t\tif(i != n-1)\n\t\tnext.push(make_pair(dp[i] - inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#define MAXN 200000\n\nusing namespace std;\n\nint N;\nlong long E, T;\nlong long x[MAXN];\nlong long dp[MAXN];\n\nint main() {\n    scanf(\"%d%lld%lld\", &N, &E, &T);\n    for (int i = 0; i < N; i++)\n        scanf(\"%lld\", &x[i]);\n\n    dp[N - 1] = T;\n    for (int i = N - 2; i >= 0; i--) {\n        dp[i] = x[N - 1] - x[i] + max(2 * (x[N - 1] - x[i]), T);\n        for (int j = i; j + 1 < N; j++) {\n            long long cost = (x[j] - x[i]) + max(2 * (x[j] - x[i]), T);\n            cost += x[j + 1] - x[j];\n            dp[i] = min(dp[i], dp[j + 1] + cost);\n        }\n    }\n\n    long long res = dp[0] + x[0] + E - x[N - 1];\n    printf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long n;\nlong long t,e;\nlong long a[100100];\nint use[100100];\n\nmain()\n{\n\tscanf(\"%lld %lld %lld\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\t\n\t}\n\tlong long ans=0;\n\tlong long rt=0;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint d=0;\n\t\trt=0;\n\t\tif(use[i]==0)\n\t\t\tfor(int j=0;i-j-1>=0;j++)\n\t\t\t{\n\t\t\t\td=0;\n\t\t\t\t//printf(\"%lld %lld\\n\",a[i-j],a[i-j-1]);\n\t\t\t\tif(a[i-j]-a[i-j-1]<=t)\n\t\t\t\t{\n\t\t\t\t\td=1;\n\t\t\t\t\t//printf(\"op1\\n\");\n\t\t\t\t\tuse[i-j-1]=1;\n\t\t\t\t\trt+=a[i-j]-a[i-j-1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op2 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\t//printf(\"%lld %lld \",rt,t);\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op2.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d==1&&i-j-1==0)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"op3 \");\n\t\t\t\t\t//printf(\"%lld \",rt);\n\t\t\t\t\trt*=2;\n\t\t\t\t\tans+=rt;\n\t\t\t\t\t//printf(\"%lld %lld \",rt,t);\n\t\t\t\t\tif(t>rt)\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"op3.2 \");\n\t\t\t\t\t\tans+=(j+1)*(t-rt);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%lld\\n\",ans);\n\t\t\t\t\trt=0;\n\t\t\t\t}\n\t\t\t}\n\t\tuse[i]=1;\n\t}\n\tif(use[0]==0)\n\t{\n\t\tans+=t;\n\t}\n\tans+=e;\n\tprintf(\"%lld\",ans);\n}\n\n/*\n5 12 3\n1 3 8 9 10\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nifstream fin (\"contest.in\");\nofstream fout (\"contest.out\");\n\n#define MAX 100000\nlong long n, e, t, x[MAX + 1], d, sum;\n\nlong long maxim (long long A, long long B)\n{\n    if (A > B)return A;\n    else return B;\n}\nint main()\n{\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; i++)cin >> x[i];\n\n    sum = e;\n    for (int i = 1; i < n; i++)\n    {\n        int ind = i + 1;\n        d = x[ind] - x[i];\n        while (d < t && ind <= n)\n        {\n            ind ++;\n            d = x[ind] - x[i];\n        }\n        ind--;\n\n        if (i == ind && i == n- 1)sum +=t;\n        if (i == ind)sum += t;\n        else\n        {\n            d = x[ind] - x[i];\n            sum += maxim(t - 2 * d, 0) + 2 * d;\n            i = ind;\n        }\n    }\n    cout << sum;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll INF = 10000000000000;\n\ntemplate<typename Monoid>\nstruct SegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n\n    int sz;\n    vector<Monoid> seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n        sz = 1;\n        while(sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid &x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for(int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid &x) {\n        k += sz;\n        seg[k] = x;\n        while(k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if(a & 1) L = f(L, seg[a++]);\n            if(b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int &k) const {\n        return seg[k + sz];\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll e, t;\n    cin >> e >> t;\n    e *= 2;\n    t *= 2;\n    ll x[100005];\n    x[0] = 0;\n    for(int i = 1; i <= n; i++){\n        cin >> x[i];\n        x[i] *= 2;\n    }\n    x[n + 1] = e;\n    SegmentTree<P> seg(n + 2, [](P a, P b){return min(a, b);}, P(INF, INF));\n    ll dp[100005];\n    for(int i = 0; i <= n; i++) dp[i] = INF;\n    for(int i = 0; i <= n; i++){\n        if(i == 0) dp[0] = 0;\n        int l = upper_bound(x, x + n + 2, x[i] - t / 2) - x;\n        if(l - 1 > 0){\n            int j = seg.query(0, l - 1).second;\n            dp[i] = min(dp[i], dp[j] + (x[i] - x[j]) * 3 - (x[j + 1] - x[j]) * 2);\n        }\n        seg.update(i, P(dp[i] + (e - x[i]) * 3 - (x[i + 1] - x[i]) * 2, i));\n        int r = upper_bound(x, x + n + 1, x[i + 1] + t / 2) - x - 1;\n        dp[r] = min(dp[r], dp[i] + t + (x[r] - x[i]));\n    }\n    cout << (dp[n] + (e - x[n])) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  for(int i=0, j=1; i<n; i++){\n    while(j+1<=n && 2*(x[j-1] - x[i]) <= t ){\n      dp[j] = min(dp[j], dp[i] + max(t, 2*(x[j-1]-x[i])));\n      j++;\n    }\n    dp[j] = min(dp[j], dp[i] + max(t, 2*(x[j-1]-x[i])));\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register ll i=(a);i<=(b);i++)\n#define For(i,a,b) for (register ll i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+5;\nll n,E,T,x[N],f[N],Ans,k=1e18;\nll l=1,r=1,q[N];\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\nint main()\n{\n\tmem(f,0x3f);\n\tn=read(),E=read(),T=read();\n\tFOR(i,1,n) x[i]=read();\n\tf[0]=0;\n\tFOR(i,1,n)\n\t{\n\t\twhile (l<=r&&2*(x[i]-x[q[l]+1])>T)\n\t\t{\n\t\t\tk=min(k,f[q[l]]-2*x[q[l]+1]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[i],f[q[l]]+T);\n\t\tf[i]=min(f[i],k+2*x[i]);\n\t//\twhile (l<=r&&f[q[l]]-x[q[l]]>=f[i]-x[i]) r--;\n\t\tq[++r]=i;\n\t}\n\tAns=f[n]+E;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<climits>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 2005\n#define M 10005\n#define INF 1000000000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint is_mul_overflow(ll a, ll b) {\n        return LLONG_MAX / a < b;\n}\n\nint x[N];\nll dp[N][N];\nint n,e,t;\nll get(int a,int b)\n{\n    int d = x[b]-x[a];\n    return t>2*d?t-d:d+d;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n>>e>>t)\n    {\n        FOR(i,1,n)cin>>x[i];\n        FOR(i,0,n)FOR(j,0,n)dp[i][j] = INF;\n        x[0] = 0;\n        dp[0][0] = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,0,i-1)\n            {\n                dp[i][j] = min(dp[i][j],dp[i-1][j]+x[i]-x[i-1]);\n                dp[i][i] = min(dp[i][i],dp[i][j]+get(j+1,i));\n            }\n            //cout<<i<<\" \"<<dp[i][i]<<endl;\n        }\n        //cout<<dp[n][n]<<endl;\n        //cout<<dp[n][n]+e-x[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int maxn = 500010, inf = 1e9 + 233;\n\nint n, T, e;\nll p[maxn], f[maxn], mn[maxn];\nmultiset<ll>s;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &T);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &p[i]);\n\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0; s.insert(0); mn[0] = - 2 * p[1];\n\tint now = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\t/*while (now < i && 2 * (p[i] - p[now + 1]) >= T) s.erase(f[now] - p[now]), now++;\n\t\t\n\t\tif (s.size()) f[i] = min(f[i], *s.begin() + p[i] + T);\n\t\tif (now) f[i] = min(f[i], mn[now - 1] + p[i] + 2 * p[i]);\n\t\ts.insert(f[i] - p[i]);\n\t\tmn[i] = min(mn[i - 1], f[i] - p[i] - 2 * p[i + 1]);*/\n\t\t\n\t\t\n\t\t\t\t\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tf[i] = min(f[i], f[j] + p[i] - p[j] + max((ll)T, 2 * (p[i] - p[j + 1])));\n\t\t\t//printf(\"i:%d j:%d f[i]:%d %d %d\\n\", i, j, f[i], T, 2 * (p[i] - p[j + 1]));\n\t\t}\n\t\t\n\t\t//printf(\"i:%d f[i]:%lld\\n\", i, f[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[n] + e - p[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct segtree{\n    int n;\n    T UNIT;\n    vector<T> dat;\n    segtree(int n_, T unit){\n        UNIT = unit;\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n);\n        for(int i = 0; i < 2*n; i++) dat[i] = UNIT;\n    }\n\n    T calc(T a, T b){\n        T ans;\n        ans = min(a, b);\n        return ans;\n    }\n    void insert(int k, T a){\n        dat[k+n-1] = a;\n    }\n    void update_all(){\n        for(int i = n-2; i >= 0; i--){\n            dat[i] = calc(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n    //k番目の値(0-indexed)をaに変更\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = calc(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //[a, b)\n    //区間[a, b]へのクエリに対してはquery(a, b+1)と呼ぶ\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return UNIT;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = query(a, b, k*2+1, l, (l+r)/2);\n            T vr = query(a, b, k*2+2, (l+r)/2, r);\n            return calc(vl, vr);\n        }\n    }\n};\n\nll N, E, T;\nll x[100001];\nll x_[100001];\nll dp[100001];\nconst ll INF = 1e+18;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> E >> T;\n    x[0] = 0;\n    for(int i = 0; i < N; i++){\n        cin >> x[i+1];\n        x_[i+1] = x[i+1]*2;\n    }\n    dp[0] = 0;\n    segtree<ll> sgt1(N+1, INF), sgt2(N+1, INF);\n    sgt1.update(0, dp[0]-x[0]);\n    sgt2.update(0, dp[0]-x[0]-2*x[1]);\n    // cout << dp[0]-x[0] << ' ' << dp[0]-x[0]-2*x[1] << endl;\n    for(int i = 1; i <= N; i++){\n        auto p = lower_bound(x_, x_+N+1, x_[i]-T);\n        int j = p-x_;\n        // 0~j-1はT/2より大きい幅\n        ll tmp1 = INF, tmp2 = INF;\n        if(j-1 > 0){\n            tmp1 = sgt2.query(0, min(j, i-1))+x[i]*3;\n        }\n        //\n        if(j != i) tmp2 = sgt1.query(j, i)+x[i]+T;\n        else tmp2 = dp[i-1]+x[i]-x[i-1]+T;\n        dp[i] = min(tmp1, tmp2);\n        if(i != N){\n            sgt1.update(i, dp[i]-x[i]);\n            sgt2.update(i, dp[i]-x[i]-2*x[i+1]);\n        }\n        // cout << dp[i]-x[i] << ' ' << dp[i]-x[i]-2*x[i+1] << endl;\n        // cout << i << ' ' <<  j << ' ' << tmp1 << ' ' << tmp2 << endl;\n        // cout << dp[i] << ' ' << endl;\n    }\n    cout << dp[N]+E-x[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\ntypedef long long LL;\nconst int N=100005;\nint n;LL f[N],d[N],mi,E,T;\nint main()\n{\n\tn=read(),E=read(),T=read();\n\tfor(RI i=1;i<=n;++i) d[i]=read();\n\tmi=1e15;\n\tfor(RI i=1,j=0;i<=n;++i) {\n\t\twhile(j<i&&(d[i]-d[j+1])*2>T) mi=min(mi,f[j]-2*d[j+1]),++j;\n\t\tf[i]=mi+2*d[i];\n\t\tif(j<i&&f[j]+T<f[i]) f[i]=f[j]+T;\n\t}\n\tprintf(\"%lld\\n\",f[n]+E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, E, T;\nvector<int> X;\nvector<int> Y;\nmap<int, long long> memo;\nlong long f(int p) {\n\tif (p == N) return 0;\n\tif (memo.count(p)) return memo[p];\n\tlong long r = 1LL<<60;\n\tlong long d = 0;\n\tfor (int i = p; i < N; ++ i) {\n\t\tlong long e = max<long long>(T, d * 2);\n\t\td += Y[i];\n\t\tauto x = f(i+1) + d + e;\n\t\t//cerr << p << \" \" << i << \" \" << x << endl;\n\t\tr = min(r, x);\n\t}\n\t//cerr << p << \" \" << r << endl;\n\treturn memo[p] = r;\n}\nint main() {\n\tcin >> N >> E >> T;\n\tif (N > 2000) throw 1;\n\tX.resize(N);\n\tfor (auto& x : X) cin >> x;\n\tfor (int i = 1; i < N; ++ i) {\n\t\tY.push_back(X[i] - X[i-1]);\n\t}\n\tY.push_back(E-X[N-1]);\n\tcout << f(0) + X[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e15;\n\n\nint main(){\n\tll N, E, T;\n\tll x[100005]={};\n\n\tcin >> N >> E >> T;\n\trep(i,N) cin >> x[i];\n\tx[N] = E;\n\n\tll dp[2][100005]={};\n\trep(i,N){\n\t\tFill( dp[(i+1)%2], INF );\n\t\tll dist = x[i+1] - x[i];\n\t\trep(j,i+1){\n\t\t\tchmin( dp[(i+1)%2][j], dp[i%2][j] + dist );\n\n\t\t\tll back = (x[i] - x[j]) * 2;\n\t\t\tll t = max( back, T );\n\t\t\tchmin( dp[(i+1)%2][i+1], dp[i%2][j] + t + dist );\n\t\t}\n\t\t//rep(j,N+1) cout << dp[(i+1)%2][j] << \" \"; cout << endl;\n\t}\n\n\tll ans = dp[N%2][N] + x[0];// + E-x[N-1];\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n;\nll E, T;\n\nll a[300000];\nint S;\n\nll it[300000];\nll d[300000];\nll e[300000];\n\nvoid update(int x)\n{\n\tfor(x/=2;x>0;x/=2) it[x]=min(it[x*2], it[x*2+1]);\n}\n\nll getmin(int x, int y)\n{\n\tll mi=MAX2;\n\twhile(x <= y)\n\t{\n\t\tif(x%2 == 1) mi=min(mi, it[x++]);\n\t\tif(y%2 == 0) mi=min(mi, it[y--]);\n\t\tx/=2, y/=2;\n\t}\n\treturn mi;\n}\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>E>>T;\n\tfor(i=0;i<n;i++) scanf(\"%lld\", &a[i]);\n\tfor(S=1;S<n;S*=2);\n\td[0]=a[0]+T;\n\te[0]=0-2*a[0]-0;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tll u=a[i]-T/2;\n\t\tint x=lower_bound(a, a+n, u)-a;\n\t\td[i]=MAX2;\n\t\tif(x > 0) d[i]=min(d[i], e[x-1]+3*a[i]);\n\t\td[i]=min(d[i], getmin(S+x, S+i-1)+a[i]+T);\n\t\td[i]=min(d[i], d[i-1]+a[i]-a[i-1]+T);\n\t\te[i]=min(e[i-1], d[i-1]-2*a[i]-a[i-1]);\n\t\tit[S+i]=d[i-1]-a[i-1];\n\t\tupdate(S+i);\n\t}\n\tcout<<d[n-1]+E-a[n-1]<<endl;\n\treturn 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 100000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nint n, E, T, a[N], b[N], dp[N], seg[N << 2], sm[N];\n\nvoid add(int id, int lq, int rq, int x, int l, int r){\n\tif (rq <= l || r <= lq) return;\n\tif (lq <= l && r <= rq){\n\t\tseg[id] = x;\n\t\treturn;\n\t}\n\tint md = (l + r) >> 1;\n\tadd(id << 1, lq, rq, x, l, md);\n\tadd(id << 1 | 1, lq, rq, x, md, r);\n\tseg[id] = min(seg[id << 1], seg[id << 1 | 1]);\n}\n\nint get(int id, int lq, int rq, int l, int r){\n\tif (rq <= l || r <= lq) return INF;\n\tif (lq <= l && r <= rq) return seg[id];\n\tint md = (l + r) >> 1;\n\treturn min(get(id << 1, lq, rq, l, md), get(id << 1 | 1, lq, rq, md, r));\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; i++) {cin >> a[i]; b[i] = 2 * a[i];}\n\tmemset(dp, 63, sizeof dp);\n\tmemset(seg, 63, sizeof seg);\n\tmemset(sm , 63, sizeof sm);\n\tdp[n + 1] = 0;\n\ta[n + 1] = E;\n\tfor (int i = n; i >= 1; i--){\n\t\tadd(1, i, i + 1, dp[i + 1] + 3 * a[i] + a[i + 1] - a[i] + T - 2 * a[i], 1, n + 1);\n\t\tint koj = lower_bound(b + 1, b + n + 1, T + 2 * a[i]) - b;\n\t\t//cout << koj << '\\n';\n\t\tdp[i] = sm[koj] - 3 * a[i];\n\t\tdp[i] = min(dp[i], get(1, i, koj, 1, n + 1) - a[i]);\n\t\tsm[i] = min(sm[i + 1], dp[i + 1] + 3 * a[i] + a[i + 1] - a[i]);\n//\t\tint mx = 0;\n//\t\tfor (int j = i; j <= n; j++){\n//\t\t\tdp[i] = min(dp[i], dp[j + 1] + 3 * (a[j] - a[i]) + a[j + 1] - a[j] + max(0ll, T - 2 * a[j] + 2 * a[i]));\n//\t\t}\n\t\t//cout << dp[i] << '\\n';\n\t}\n\tcout << dp[1] + a[1];\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nlong long e, t, dp[MAXN], mn = 1e17;\nint n, x[MAXN];\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tdp[1] = t;\n\tint j = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile ((x[i] - x[j]) * 2 > t) {\n\t\t\tmn = min(mn, dp[j - 1] - 2 * x[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i] = min(mn + 2 * x[i], dp[j - 1] + t);\n\t}\n\tcout << dp[n] + e;\n}"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[100003];\nLL dp[100003];\nLL mn1[100003], mn2[100003];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tmn1[0]=mn2[0]=0;\n\t/*for(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}\n\tprintf(\"%d\\n\",e+dp[n]);*/\n\tj=0;\n\tfor(i=1;i<=n;i++){\n\t\t//printf(\"%d %d %d\\n\",i,mn1[i-1],mn2[i-1]);\n\t\twhile(j<n && 2*(x[i]-x[j])>t) j++;\n\t\tj--;\n\t\tdp[i]=dp[mn1[i-1]]+max(2*(x[i]-x[mn1[i-1]+1]),(LL)t);\n\t\tdp[i]=min(dp[i],dp[mn2[j]]+max(2*(x[i]-x[mn2[j]+1]),(LL)t));\n\t\tmn1[i]=dp[mn1[i-1]]<dp[i] ? mn1[i-1]:i;\n\t\tmn2[i]=(dp[mn2[i-1]]-2*x[mn2[i-1]+1])<(dp[i]-2*x[i+1]) ? mn2[i-1]:i;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,t,e,x,ab,a[200005],dp[200005];\nint main(){\n\tn=read(),e=read(),t=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\ta[n+1]=e;\n\tfor(int i=1;i<=n;i++){\n\t\twhile((a[i]-a[ab+1])*2>t)\n\t\t\tx=min(x,dp[ab]-2*a[ab+1]),ab++;\n\t\tdp[i]=min((ll)(1e18),dp[ab]+t);\n\t\tif(ab)dp[i]=min(dp[i],2*a[i]+x);\n\t}\n\tprintf(\"%lld\",dp[n]+e);\n\treturn 0;\n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  ll bestF = Inf; \n  auto relaxF = [&] (int i) {\n    bestF = min(bestF, dp[i] - x[i] - (ll)t * i);\n  };\n  auto get0 = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1]; \n  };\n  auto gett = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1] + 2 * x[i + 1];\n  };\n  relaxF(0);\n  multiset <ll> h0, ht;\n  ht.insert(gett(0));\n  int uk = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (uk < i && t - 2 * x[i] + 2 * x[uk + 1] < 0) {\n      ht.erase(gett(uk));\n      h0.insert(get0(uk));\n      ++uk;\n    }\n    dp[i] = bestF + x[i] + (ll)t * i;\n    if (!h0.empty()) dp[i] = min(dp[i], *h0.begin() + 3 * x[i]); \n    if (!ht.empty()) dp[i] = min(dp[i], *ht.begin() + 3 * x[i] + t - 2 * x[i]);\n    /*for (int j = i + 1; j <= n; ++j) {\n      ll extra = max(0LL, t - 2 * x[j] + 2 * x[i + 1]);\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }*/\n    relaxF(i);\n    ht.insert(gett(i));\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a) (a).begin(), (a).end()\n#define FOR(x,n) for(int x = 0; x < n; x++)\n#define FORR(x,n) for(int x = n-1; x >= 0; x--)\n#define FIN ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define SZ(a) ((int)(a).size())\nusing namespace std;\ntypedef long long ll;\n\nconst int MXN = 2001;\nint N, T, E;\nll xs[MXN];\nll m[MXN][MXN] = {};\n\nll solve(int i, int lastp) {\n  if(m[i][lastp] != -1) return m[i][lastp];\n  ll tmp;\n  if(i == N) {\n    if(lastp == 0)\n      tmp = T;\n    else\n      tmp = max(T-2*(xs[i]-xs[lastp]), 0LL) + 2*(xs[i]-xs[lastp]);\n    return m[i][lastp] = tmp;\n  }\n  if(lastp == 0)\n    tmp = T + (xs[i+1]-xs[i]) + solve(i+1,0);\n  else\n    tmp = max(T-2*(xs[i]-xs[lastp]) , 0LL) + 2*(xs[i]-xs[lastp]) + solve(i+1, 0) + (xs[i+1]-xs[i]);\n    \n  tmp = min(tmp, solve(i+1, lastp == 0 ? i : lastp)+(xs[i+1]-xs[i]));\n  \n  return m[i][lastp] = tmp;\n}\n\nint main(){\n  memset(m, -1, sizeof m);\n  cin >> N >> E >> T;\n  FOR(x,N) cin >> xs[x+1];  \n  cout << solve(1,0) + xs[1] + (E-xs[N]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint last=0,lastt=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tif(lastt!=0)\n\t\tdp[i]=min(dp[i],(x[i]-x[last+1])*2+dp[last]);\n\t\tfor(int j=lastt;j<i;j++){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t\tif((x[i]-x[j+1])*2<t)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t\tlastt=j;\n\t\t\t}\n\t\t\tif(dp[i]==(x[i]-x[j+1])*2+dp[j])\n\t\t\tlast=j;\n\t\t}\n\t\t//printf(\"%d %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<long long> dq;\n  dq.push_back(0);\n  for(int i=0; i<n; i++){\n    while(dq.size() > 1 && (x[i] - x[dq.front()]) * 2 > t){\n      dp[i+1] = min( dp[i+1], dp[dq.front()] + 2*(x[i]-x[dq.front()]) );\n      dq.pop_front();\n    }\n    dp[i+1] = min(dp[i+1], dp[dq.front()] + max(t, x[i] - x[dq.front()]));\n    dq.push_back(i+1);\n  }\n\n  println(dp[n] + e);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> VL;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid M. Note that constructing this tree requires the identity\n * element of M and the operation of M.\n * Header requirement: vector, algorithm\n * Verified by AtCoder ABC017-D (http://abc017.contest.atcoder.jp/submissions/660402)\n */\ntemplate<class I, class BiOp = I (*) (I, I)>\nclass SegTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\npublic:\n  SegTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_) { n *= 2; } // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  void update_array(int k, int len, const I *vals) {\n    for (int i = 0; i < len; ++i) {\n      update(k + i, vals[i]);\n    }\n  }\n  /*\n    Updates all elements. O(n)\n   */\n  void update_all(const I *vals, int len) {\n    for (int k = 0; k < std::min(n, len); ++k) {\n      dat[k + n - 1] = vals[k];\n    }\n    for (int k = std::min(n, len); k < n; ++k) {\n      dat[k + n - 1] = e;\n    }\n    for (int b = n / 2; b >= 1; b /= 2) {\n      for (int k = 0; k < b; ++k) {\n\tdat[k + b - 1] = op(dat[k * 2 + b * 2 - 1], dat[k * 2 + b * 2]);\n      }\n    }\n  }\n  /* l,r are for simplicity */\n  I querySub(int a, int b, int k, int l, int r) const {\n    // [a,b) and  [l,r) intersects?\n    if (r <= a || b <= l) return e;\n    if (a <= l && r <= b) return dat[k];\n    I vl = querySub(a, b, 2 * k + 1, l, (l + r) / 2);\n    I vr = querySub(a, b, 2 * k + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n  /* [a, b] (note: inclusive) */\n  I query(int a, int b) const {\n    return querySub(a, b + 1, 0, 0, n);\n  }\n};\n\n\nconst int N = 200100;\nconst ll inf = 1e16;\n\nstruct min_fun {\n  ll operator()(ll x, ll y) const {\n    return min(x, y);\n  }\n};\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  VL x(n);\n  SegTree<ll, min_fun> raw(n + 1, min_fun(), inf); // dp[i]\n  SegTree<ll, min_fun> boiled(n + 1, min_fun(), inf); // dp[i] - 2 * x[i]\n  REP(i, 0, n) {\n    cin >> x[i];\n  }\n  raw.update(0, 0);\n  boiled.update(0, -2 * x[0]);\n  REP(i, 0, n) {\n    // Compute the range of j s.t. t <= 2 * (x[i] - x[j]) (0 <= j <= i)\n    int j_boundary =\n      upper_bound(x.begin(), x.begin() + i + 1, x[i] - (t+1)/2) - x.begin();\n    ll ret = inf;\n    ret = min(ret, boiled.query(0, j_boundary - 1) + 2 * x[i]);\n    ret = min(ret, raw.query(j_boundary, i) + t);\n    raw.update(i + 1, ret);\n    if (i < n - 1) {\n      boiled.update(i + 1, ret - 2 * x[i + 1]);\n    }\n  }\n  cout << raw.query(n, n) + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 200007;\nconst int K = 5000;\nint dp[N], x[N], f[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; i++){\n        cin >> x[i];\n    }\n    dp[n] = e - x[n] + t;\n    x[n + 1] = e;\n    f[n] = x[n + 1] + 2 * x[n] + dp[n + 1];\n    int z = 1e15;\n    int p = n;\n    for (int i = n - 1; i >= 1; i--){\n        while((x[p] - x[i]) * 2 >= t){\n            z = min(z, f[p]);\n            p--;\n        }\n        dp[i] = x[p + 1] + 2 * x[p] + dp[p + 1] + max(t - 2 * x[p] + 2 * x[i], 0LL);\n        dp[i] = min(dp[i], z);\n        dp[i] = dp[i] - 3 * x[i];\n        f[i] = x[i + 1] + 2 * x[i] + dp[i + 1];\n    }\n    cout << x[1] + dp[1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FORE(i, a) for (auto i = a.begin(); i != a.end(); ++i)\n#define REPU(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a); i > (b); --i)\n#define MEM(a, x) memset(a, x, sizeof(a))\n#define ALL(a) a.begin(), a.end()\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\n\nvector<string> split(const string &s, char c) {\n\tvector<string> v;\n\tstringstream ss(s);\n\tstring x;\n\twhile (getline(ss, x, c)) v.push_back(x);\n\treturn v;\n}\n\n#define DEBUG(args...) { vector<string> _v = split(#args, ','); err(_v.begin(), args); }\n\nvoid err(vector<string>::iterator it) {}\n\ntemplate<typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << \"[DEBUG] \" << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << '\\n';\n\terr(++it, args...);\n}\n\ntypedef long long ll;\nconst int MOD = 1000000007;\n\ntemplate<class T, class U> inline T tmin(T a, U b) { return (a < b) ? a : b; }\ntemplate<class T, class U> inline T tmax(T a, U b) { return (a > b) ? a : b; }\ntemplate<class T, class U> inline void amax(T &a, U b) { if (b > a) a = b; }\ntemplate<class T, class U> inline void amin(T &a, U b) { if (b < a) a = b; }\ntemplate<class T> inline T tabs(T a) { return (a > 0) ? a : -a; }\ntemplate<class T> T gcd(T a, T b) { while (b != 0) { T c = a; a = b; b = c % b; } return a; }\n\nconst int M = 100005, N = 2005;\nint x[M];\nll dp[N][N];\n\nint main(int argc, char *argv[]) {\n\tios_base::sync_with_stdio(false);\n\n\tint n, e, t;\n\n\tcin >> n >> e >> t;\n\tREPU(i, 1, n + 1) cin >> x[i];\n\tif (n < N) {\n\t\tint ans = 0;\n\t\tdp[0][0] = 0;\n\t\tREPU(j, 1, n + 1) {\n\t\t\tdp[1][j] = x[j] * 2 - x[1] + max(0, t - 2 * (x[j] - x[1]));\n\t\t\tREPU(i, 2, j + 1) {\n\t\t\t\tll tmp = dp[i - 1][i - 1] + 2 * x[j] - x[i] - x[i - 1] + max(0, t - 2 * (x[j] - x[i]));\n\t\t\t\tdp[i][j] = min(tmp, dp[i - 1][j] + x[i] - x[i - 1]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[n][n] + e - x[n]);\n\t}\n\telse puts(\"0\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint x[100001];\nlong long dp[100001];\n\nint main() {\n    int n, e, t, i, j;\n    \n    scanf(\"%d %d %d\", &n, &e, &t);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    \n    if (n > 2000) return 0;\n    \n    x[n] = e;\n    \n    for (i = 0; i <= n; i++) dp[i] = 1e18;\n    \n    dp[0] = x[0];\n    \n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j <= n; j++) {\n            int c = max(t - (x[j - 1] - x[i]) * 2, 0);\n            \n            dp[j] = min(dp[j], dp[i] + (long long)(x[j - 1] - x[i]) * 3 + x[j] - x[j - 1] + c);\n        }\n    }\n    \n    printf(\"%lld\\n\", dp[n]);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5e5+5;const ll inf=1e18;\nint n,t,e,a[N];ll f[N];\ninline ll min(R ll x,R ll y){return x<y?x:y;}\ninline ll max(R ll x,R ll y){return x>y?x:y;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tassert(n<=2000);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tfp(i,1,n){\n\t\tf[i]=inf;\n\t\tfp(j,1,i)cmin(f[i],f[j-1]+max((a[i]-a[j])<<1,t));\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n#define double long double\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\n//typedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-15;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint n,e,t,x[100010] = {},ind = 0,tmp = INF,dp[100010];\n\tcin >> n >> e >> t;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> x[i];\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\twhile((x[i] - x[ind + 1]) * 2 >= t){\n\t\t\tchmin(tmp,dp[ind] + (x[i] - x[ind + 1]) * 2);\n\t\t\tind++;\n\t\t}\n\t\tdp[i] = min(tmp,dp[ind] + t);\n\t\ttmp += (x[i] - x[i - 1]) * 2;\n\t}\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n \nint p[100001],s[100001],l,r;\nlong long f[100001];\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tlong long z=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\ts[++r]=i;\n\t\tfor(;2*(p[i]-p[s[l]])>=t;l++)\n\t\t\tz=min(z,f[s[l]-1]-2*p[s[l]]);\n\t\tf[i]=f[s[l]-1]+t;\n\t\tf[i]=min(f[i],2*p[i]+z);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e16, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint a[N], b[N], dp[N], sum[N];\n\nint32_t main() {\n\tuse_fast;\n\tint n, e, t, h = 0;\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tif(i == 1) {\n\t\t\tdp[1] = t + a[1];\n\t\t\tsum[1] = a[1];\n\t\t\tcontinue;\n\t\t}\n\t\tsum[i] = sum[i - 1] + a[i] - a[i - 1];\n\t\tdp[i] = dp[h] + sum[h + 1] - sum[h] + max(t, 2 * (sum[i] - sum[h + 1])) + sum[i] - sum[h + 1];\n\t\twhile(h < i - 1) {\n\t\t\th++;\n\t\t\tint cnt = dp[h] + sum[h + 1] - sum[h] + max(t, 2 * (sum[i] - sum[h + 1])) + sum[i] - sum[h + 1];\n\t\t\tif(cnt > dp[i]) {\n\t\t\t\th--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdp[i] = cnt;\n\t\t}\n\t}\n\tcout << e - a[n] + dp[n] << endl;\n    return 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nll dpRMQ[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\n\tprev = dp[opt - 1];\n\n\tll cur = max((a[i] - a[opt]) * 2 , T);\n\n\treturn prev + cur;\n}\nint findOpt(int idx)\n{\n\treturn lower_bound(a , a + N , a[idx] - T / 2) - a;\n}\nll findDp(int idx)\n{\n\tint opt = findOpt(idx);\n\t//cout << opt << endl;\n\tll dp1 = T;\n\tif(opt - 1 >= 0)\n\t\tdp1 += dp[opt - 1];\n\tll dp2 = a[idx] * 2;\n\tif(opt - 1 >= 0)\n\t\tdp2 += dpRMQ[opt - 1];\n\t//cout << dp1 << \" \" << dp2 << endl;\n\t//if(opt < idx)\n\t\treturn(min(dp1 , dp2));\n\t//else\n\t\t//return dp2;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tdpRMQ[0] = - a[0] * 2;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\t/*while(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}*/\n\t\tdp[i] = findDp(i);\n\t\t//cout << \"DP: \"<< dp[i] << endl;\n\t\tdpRMQ[i] = min(dpRMQ[i - 1] , dp[i] - a[i] * 2);\n\t\t//for(int j = 0; j <= i; j++)\n\t\t\t//dp[i] = min(dp[i] , cost(i , j));\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+20];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+20];\n\tint x[100000+20];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3ll*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>=T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3ll+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n\t\tif(i==N) break;\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3ll)/3ll,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3ll);\n\t}\n\tif(dp[N]+E-x[N]<0){\n\t\twhile(1);\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n \ntypedef pair<int,int>  pii;\n \nconst int MAX=1e6;\nconst int INF=1e18;\n \nint N,E,T,arr[MAX],dp[MAX],tot[MAX],pre[MAX],nxt[MAX];\n \n/*int cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}*/\n \nvoid solve()\n{\n\tdp[N]=T+E-arr[N];\n\t//tot[N]=3*arr[N]+T-arr[N];\n\t//cout<<dp[N]<<\" ha ha \\n\";\n\tfor(int A=N-1;A>=1;A--)\n\t{\n\t\tdp[A]=pre[A]+arr[nxt[A]+1]-arr[nxt[A]]+dp[nxt[A]+1];\n\t//\tif(nxt[A]<N)\n\t//\t\tdp[A]=min(dp[A],-3*arr[A]+tot[nxt[A]+1]);\n\t//\ttot[A]=min(tot[A+1],3*arr[A]+arr[A+1]-arr[A]+dp[A+1]);\n\t\tfor(int B=nxt[A]+1;B<=N;B++)\n\t\t{\n\t\t//\tcout<<dp[A]<<\"lol \\n\";\n\t\t\tdp[A]=min(dp[A],3*(arr[B]-arr[A])+arr[B+1]-arr[B]+dp[B+1]);\n\t\t\t//cout<<dp[A]<<\" \"<<3*(arr[B]-arr[A])<<\" \"<<arr[B+1]-arr[B]<<\" \"<<dp[B+1]<<\"lol \\n\";\n\t\t}\n\t\t//cout<<A<<\" \"<<dp[A]<<\" \"<<pre[A]<<\" \"<<dp[nxt[A]+1]<<\"\\n\";\n\t}\n\treturn ;\n}\n \nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n \n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t{\n\t\tint low=A,high=N,mid,res=A;\n\t\twhile(low<=high)\n\t\t{\n\t\t\tmid=(low+high)/2;\n\t\t\tif(T-2*(arr[mid]-arr[A])>0)\n\t\t\t{\n\t\t\t\tres=mid;\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh=mid-1;\n\t\t}\n\t//\tcout<<A<<\" \"<<res<<\"\\n\";\n\t\tnxt[A]=res;\n\t\tpre[A]=T-2*(arr[res]-arr[A])+3*(arr[res]-arr[A]);\n\t}\n\tsolve();\n\tcout<<arr[1]+dp[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define INF 2147483647\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ninline void Fail(){\n\tprintf(\"0\");\n\texit(0);\n}\n\nconst int maxn=100005;\nint n,e,t;\nll dp[maxn];\nint x[maxn],y[maxn];\nclass segtree{\npublic:\n\tll tree[maxn*4];\n\tint leaf[maxn];\n\tvoid build(int l,int r,int node){\n\t\tif(l==r){\n\t\t\tleaf[l]=node;\n\t\t\ttree[node]=Inf;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,node*2);\n\t\tbuild(mid+1,r,node*2+1); \n\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t}\n\tvoid upd(int node,ll val){\n\t\tnode=leaf[node];\n\t\ttree[node]=val;\n\t\tnode>>=1;\n\t\twhile(node){\n\t\t\ttree[node]=min(tree[node*2],tree[node*2+1]);\n\t\t\tnode>>=1;\n\t\t}\n\t}\n\tll query(int l,int r,int vl,int vr,int node){\n\t\tif(r<l||vr<vl)return Inf;\n\t\tif(l>vr||r<vl)return Inf;\n\t\tif(l>=vl&&r<=vr)return tree[node];\n\t\tint mid=(l+r)>>1;\n\t\treturn min(query(l,mid,vl,vr,node*2),query(mid+1,r,vl,vr,node*2+1));\n\t}\n}t1,t2;\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,n)scanf(\"%d\",&x[i]),y[i]=2*x[i];\n\tt1.build(0,n-1,1);\n\tt2.build(0,n-1,1);\n\trep(i,n){\n\t\tdp[i]=max((x[i]-x[0])*2LL,1LL*t);\n\t\tint pos=lower_bound(y,y+n,2*x[i]-t)-y;\n\t\tdp[i]=min(dp[i],min(t1.query(0,n-1,0,pos-2,1)+2LL*x[i],t2.query(0,n-1,max(pos-1,0),n-1,1)+t));\n\t\tt1.upd(i,dp[i]-2LL*x[i+1]);\n\t\tt2.upd(i,dp[i]);\n\t}\n\tprintf(\"%lld\",e+dp[n-1]);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stdout,f,##__VA_ARGS__),fflush(stdout)\n\ntypedef long long ll;\n\nconst int N=1e5+50 ; \nconst ll oo=1e18; \n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nint n;\nll T,E,x[N],f[N]; \n\nll cal(int j,int i){ return f[j]+max(2*(x[i]-x[j+1]),T); }\nvoid sol(){\n\tstatic int q[N],l[N],h,t; \n\th=1,t=0;\n\tq[++t]=0,l[t]=1;\n\trep(i,1,n){\n\t\tif(h+1<=t&&i>=l[h+1])++h;\n\t\tf[i]=cal(q[h],i); \n\t\tint L,R=n+1,mid;\n\t\twhile(true){\n\t\t\tif(i<l[t]&&cal(i,l[t])<=cal(q[t],l[t])){\n\t\t\t\tR=l[t--];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tL=max(i,l[t]);\n\t\t\twhile(R-L>1){\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(cal(i,mid)>cal(q[t],mid))L=mid;\n\t\t\t\telse R=mid;\n\t\t\t}\n\t\t\tif(L<n)q[++t]=i,l[t]=L+1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"dat.in\",\"r\",stdin);\n\tfreopen(\"my.out\",\"w\",stdout); \n#endif\n\tread(n),read(E),read(T); \n\trep(i,1,n)read(x[i]);\n\tsol(); \n\tprintf(\"%lld\\n\",f[n]+E); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    if(N>2000) return 1;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            ll need=A[i+1]-A[i];\n            ll dis=(A[j]-A[i+1])*2;\n            chmin(dp[j],dp[i]+need+max(T,dis)+dis/2);\n        }\n    }\n    \n    cout<<dp[N]+E-A[N]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, m;\nbool isVal[N];\nvector<int> graph[N];\nvector<int> adj[N];\nbool mark[N];\nint h[N];\nint jump[N];\n\nvoid dfs(int v, int par = -1) \n{\n    jump[v] = h[v];\n    mark[v] = true;\n    for (auto u: graph[v])\n    {\n        if (u == par)\n        {\n            continue;\n        }\n        if (!mark[u])\n        {\n            h[u] = h[v] + 1;\n            dfs(u, v);\n            jump[v] = min(jump[v], jump[u]);\n        }\n        else\n        {\n            jump[v] = min(jump[v], h[u] - 1);\n        }\n    }\n}\n\nvoid dfs2(int v)\n{\n    mark[v] = true;\n    for (auto u: graph[v])\n    {\n        if (!mark[u] && isVal[u])\n        {\n            if (isVal[u] && isVal[v])\n            {\n                adj[u + 1].push_back(v + 1);\n                adj[v + 1].push_back(u + 1);\n            }\n            dfs2(u);\n        }\n    }\n}\n\n\nint main() \n{\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) \n    {\n        int u, v;\n        cin >> u >> v;\n        graph[u - 1].push_back(v - 1);\n        graph[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (!mark[i])\n        {\n            dfs(i);\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        //cout << i << \" \" << jump[i] << \" \" << h[i] << endl;;\n        if (jump[i] >= h[i])\n        {\n            isVal[i] = true;\n        }\n    }\n    memset(mark, 0, sizeof mark);\n    for (int i = 0; i < n; i++)\n    {\n        if (!mark[i] && isVal[i])\n        {\n            dfs2(i);\n            adj[0].push_back(i + 1);\n        }\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nvector<int>x, memo;\nint N, E, T;\n\nint solve(int posindex) {\n\t//x[posindex]の位置についた直後で、自分より手前の熊は処理済みで、自分より奥の熊は手付かず\n\n\tif (posindex == N)return 0;\n\tif (memo[posindex] != -1)return memo[posindex];\n\n\tint ans = intmax;\n\n\t//その場で待つ\n\tans = min(ans, solve(posindex + 1) + T + x[posindex + 1] - x[posindex]);\n\n\t//先まで行く\n\tREP(i, posindex+1, N) {\n\t\tint sol = solve(i + 1);\n\t\tint dist = x[i] - x[posindex];\n\t\tint gets = max(T + dist, dist * 3);\n\t\tint res = sol + gets + x[i + 1] - x[i];\n\t\tans = res;\n\t}\n\tmemo[posindex] = ans;\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\tx = vector<int>(N+1);\n\tmemo = vector<int>(N,-1);\n\trep(i, N)cin >> x[i];\n\tx[N] = E;\n\tsort(ALL(x));\n\n\n\t\n\tcout << x[0] + solve(0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (1 << 20);\n\nint64_t n, t, e;\nint64_t x[MAXN];\n\nvoid read()\n{\n\tcin >> n >> e >> t;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n}\n\nint64_t dp[MAXN];\n\nvoid solve()\n{\n\tx[0] = 0;\n\tdp[0] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tdp[i] = (int64_t)1e18;\n\t\tfor(int j = i; j >= 1; j--)\n\t\t{\n\t\t\tint64_t wait_t = max((int64_t)0, t - 2 * (x[i] - x[j]));\n\t\t\tchkmin(dp[i], x[i] - x[j - 1] + wait_t + (x[i] - x[j]) * (int64_t)2 + dp[j - 1]);\n\t\t}\n\t}\n\n\tcout << dp[n] + e - x[n] << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconst int inf = 1e17;\nconst int mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint x[100006];\n\nstruct RMQ {\n\tint n; vector<int>node;\n\tvoid init(int N) {\n\t\tn = 1;\n\t\twhile (n < N)n *= 2;\n\t\tnode.resize(2 * n, inf);\n\t}\n\n\tvoid update(int x, int a) {\n\t\tx += n - 1;\n\t\tnode[x] = a;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[x * 2 + 1], node[x * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tint get(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\nRMQ dp1, dp2;\nsigned main() {\n\tint n, e, t; cin >> n >> e >> t;\n\trep(i, n)cin >> x[i];\n\tdp1.init(n + 2);\n\tdp2.init(n + 2);\n\n\tx[n] = x[n - 1];\n\tdp1.update(0, 0);\n\tdp2.update(0, -2*x[0]);\n\trep(i,n){//dp[i+1]\n\t\tint lb = -1, ub = i+1;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mi = (ub + lb) / 2;\n\t\t\tif (2 * (x[i] - x[mi]) > t)lb = mi;\n\t\t\telse ub = mi;\n\t\t}\n\n\t\t//[0,i]を分ける\n\t\t//[0,lb]は2(x[i]-x[j]), [ub,i]はt\n\t\tint X1, X2;\n\t\tX1 = dp1.get(ub, i+1) + t;\n\t\tX2 = dp2.get(0, ub) + 2 * x[i];\n//\t\tcout << ub << ' ' << X1 << ' ' << X2 << endl;\n\t\tdp1.update(i+1, min(X1, X2));\n\t\tdp2.update(i+1, min(X1,X2)-2 * x[i+1]);\n\t}\n\tcout << dp1.get(n, n+1)+e << endl;\n\n\t/*\n\tdp[0] = 0;\n\trep(i, n) {\n\t\tfor (int j = i; j<n; j++) {\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] + max(2 * (x[j] - x[i]), t));\n\t\t}\n\t}\n\tcout << dp[n] + e<< endl;\n\t*/\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 210110;\nconst int MOD = 998244353;\nconst double eps = 1e-8;\n\nll n, e, t;\nll a[N];\n\nll dp[N];\nll kek, j = -1;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    kek = 1e18;\n    set<pair<int, int> > ss;\n    ss.insert({0, -1});\n    for (int i = 0; i < n; i++)\n    {\n        dp[i] = (i > 0 ? dp[i - 1] : 0) + t;\n        while (2 * (a[i] - a[j + 1]) >= t)\n        {\n            ss.erase({(j >= 0 ? dp[j] : 0), j});\n            kek = min(kek, (j >= 0 ? dp[j] : 0) - 2 * a[j + 1]);\n            j++;\n        }\n        if (ss.size())\n        {\n            pair<int, int> it = *(ss.begin());\n            dp[i] = min(dp[i], min(it.first + t, kek + 2 * a[i]));\n        }\n        else\n        {\n            dp[i] = min(dp[i], kek + 2 * a[i]);\n        }\n        ss.insert({dp[i], i});\n        //cout << j << \" \" << kek << \" \" << dp[i] << endl;\n    }\n    cout << dp[n - 1] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[2010];\nint x[2010];\nint n,e;\nlong long t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tdp[i]=4e18;\n\t\tfor(int j=0;j+1<i;j++)\n\t\t{\n\t\t\tlong long tt=2*(x[i]-x[j+1]);\n\t\t\tdp[i]=min(dp[i],dp[j]+x[i]-x[j]+min((t+tt-1)/tt*tt,t*(i-j)));\n\t\t}\n\t\tdp[i]=min(dp[i],dp[i-1]+x[i]-x[i-1]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nint main(){\n  int n;\n  long long e,t;\n  scanf(\"%d%lld%lld\", &n,&e,&t);\n\n  vector<long long> x(n);\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  long long w = 1ll<<57;\n\n  for(int i=0, j=0; i<n; ++i){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      w = min(w, dp[j] + 2*(x[i] - x[j]));\n      j++;\n    }\n\n    dp[i+1] = min(dp[i+1], w);\n    if(2*(x[i]-x[j]) < t) dp[i+1] = min(dp[i+1], dp[j] + t);\n\n    w += 2*(x[i+1] - x[i]);\n  }\n  printf(\"%lld\\n\", dp[n] + e);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"factories.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e5 + 10, INF = 1e9 * 1e9;\nll dp[SZ], push[SZ * 8][4], tree[SZ * 8][4];\n\nvoid p(int v, int ind) {\n\ttree[v * 2 + 1][ind] += push[v][ind];\n\ttree[v * 2 + 2][ind] += push[v][ind];\n\tpush[v * 2 + 1][ind] += push[v][ind];\n\tpush[v * 2 + 2][ind] += push[v][ind];\n\tpush[v][ind] = 0;\n}\n\nll get(int v, int l, int r, int askl, int askr, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) {\n\t\treturn INF;\n\t}\n\n\tif (l >= askl && r <= askr) {\n\t\treturn tree[v][ind];\n\t}\n\tint mid = (l + r) / 2;\n\tll q = get(v * 2 + 1, l, mid, askl, askr, ind), q2 = get(v * 2 + 2, mid, r, askl, askr, ind);\n\treturn min(q, q2);\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int add, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\ttree[v][ind] += add;\n\t\tpush[v][ind] += add;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, add, ind);\n\tupd(v * 2 + 2, mid, r, askl, askr, add, ind);\n\ttree[v][ind] = min(tree[v * 2 + 1][ind], tree[v * 2 + 2][ind]);\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vec(n);\n\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\n\tvec.push_back(e);\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tdp[i] = dp[i + 1] + (vec[i + 1] - vec[i]) + t;\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 1, 0);\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 3, 1);\n\t\tint l = i, r = n + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif ((vec[mid] - vec[i]) * 2 >= t) {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\n\t\tll q = INF;\n\t\tif (i + 1 < r - 1) q = get(0, 0, n + 1, i + 1, r - 1, 0) + t;\n\t\tif (r != n + 1) q = min(q, get(0, 0, n + 1, r, n + 1, 1));\n\t\tdp[i] = min(dp[i], q);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 0);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 1);\n\t}\n\n\tcout << dp[0] + vec.front();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=100005;\nstruct SegTree{\n\tll mn[N<<2];\n\t#define mid ((l+r)>>1)\n\tvoid init(){memset (mn,0x3f,sizeof(mn));}\n\tvoid insert(int root,int l,int r,int x,int v){\n\t\tif (l==r){mn[root]=v;return;}\n\t\tif (x<=mid) insert(root<<1,l,mid,x,v);\n\t\telse insert((root<<1)|1,mid+1,r,x,v);\n\t\tmn[root]=min(mn[root<<1],mn[(root<<1)|1]);\n\t}\n\tll query(int root,int l,int r,int L,int R){\n\t\tif (r<L||l>R) return 1ll<<60;\n\t\tif (L<=l&&r<=R) return mn[root];\n\t\treturn min(query(root<<1,l,mid,L,R),query((root<<1)|1,mid+1,r,L,R));\n\t}\n\t#undef mid\n}Seg1,Seg2;\nint a[N];\nll dp[N];\nint main (){\n\tint n,e,t;scanf (\"%d%d%d\",&n,&e,&t);\n\tfor (int i=1;i<=n;i++) scanf (\"%d\",&a[i]);\n\tdp[0]=0;Seg1.init(),Seg2.init();\n\tSeg1.insert(1,0,n,0,-2ll*a[1]);\n\tSeg2.insert(1,0,n,0,0);\n\tfor (int i=1;i<=n;i++){\n\t\tdp[i]=1ll<<60ll;\n\t\tint l=1,r=i-1,pos=-1;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (2ll*(a[i]-a[mid])>=t) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tif (pos!=-1) dp[i]=Seg1.query(1,0,n,0,pos-1)+2ll*a[i];\n\t\tdp[i]=min(dp[i],Seg2.query(1,0,n,pos,n)+t);\n\t\tSeg1.insert(1,0,n,i,dp[i]-2ll*a[i+1]);\n\t\tSeg2.insert(1,0,n,i,dp[i]);\n\t}\n\tprintf (\"%lld\",dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre;\nint64 T,E;\nint64 x[100005];\nint N,p;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 1e18;\n    for(int i = 1 ; i <= N ; ++i) {\n\twhile(p < i - 1 && 2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tif(p != -1) dp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front() + 1]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=1e5+10;\nint n;\nLL e,t,x[N],dp[N],tt=1e18;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline I mi(const I&a,const I&b){return a<b ? a : b;}\nint main()\n{\n//\tfreopen(\"Shik and Game.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,e,t);\n\tfor(int i=1;i<=n;i++) read(x[i]), dp[i]=2e9;\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[j+1])>=t) \n\t\t{\n\t\t\ttt=mi(tt,dp[j]-2*x[j+1]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=mi(dp[j]+t,tt+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100010\n#define INF 1e15+7\nstruct SegmentTree {\nprivate:\n    int nn; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        nn = 1; while(nn < sz) nn *= 2;\n        node.resize(2*nn-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (nn - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = nn;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+2),seg2(n+2);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=-1,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-x[i]*2+x[mid+1]*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e5 + 5;\nconst ll INF = 1e18;\n\nll x [MAX_N];\nll dp [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, E, T;\n  cin >> n >> E >> T;\n\n  for (int i = 1; i <= n; i++) {\n    cin >> x[i];\n  }\n  \n  ll ans = 0;\n  ans += E - x[n];\n  ans += x[1];\n\n  if (2 * (x[n] - x[1]) < T) {\n    ans += T;\n    ans += x[n] - x[1];\n    cout << ans << endl;\n    return 0;\n  }\n\n  ans += 3 * (x[n] - x[1]);\n  \n  set<pair<ll, int>, greater<pair<ll, int>>> zrange;\n  set<pair<ll, int>, greater<pair<ll, int>>> lrange;\n\n  x[n + 1] = x[n];\n  lrange.insert(make_pair(dp[0] - 2 * x[1], 0));\n  int lastl = 0;\n  for (int i = 1; i <= n; i++) {\n    while (lastl < i) {\n      if (T - 2 * (x[i] - x[lastl + 1]) <= 0) {\n        lrange.erase(make_pair(dp[lastl] - 2 * x[lastl + 1], lastl));\n        zrange.insert(make_pair(dp[lastl], lastl));\n        lastl++;\n      } else {\n        break;\n      }\n    }\n\n    dp[i] = -INF;\n    if (!lrange.empty()) {\n      dp[i] = 2 * (x[i + 1] - x[i]) - T + 2 * x[i] + lrange.begin()->first;\n    }\n    if (!zrange.empty()) {\n      dp[i] = max(dp[i], 2 * (x[i + 1] - x[i]) + zrange.begin()->first);\n    }\n    lrange.insert(make_pair(dp[i] - 2 * x[i + 1], i));\n  }\n\n  cout << ans - dp[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) f=n; else f=ng[f];\n\t\tfor(int j=max(i+1,beg-5);j<=min(f,beg+10000);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME \"\"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nconst int MAXN = 1000001;\nstring s;\nstring t;\nll x[MAXN];\nll f1[MAXN];\nll f2[MAXN];\nll f[MAXN];\nconst ll INF = 1ll << 40;\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tll t, e;\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\tfor (int i = 0; i <= n; i++) f[i] = f2[i]  = INF;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tll d = f[i - 1] + x[i] - x[i  - 1];\n\t\tint g = upper_bound(x + i, x + n + 1, x[i] + t / 2) - x;\t\n\t\tf[g - 1] = min(f[g - 1], d + t + x[g - 1] - x[i]);\n\t\tf2[g] = min(f2[g], d - 3 * x[i]);\n\t\tf2[i] = min(f2[i], f2[i - 1]);\n\t\tf[i] = min(f[i], f2[i] + 3 * x[i]);\n\t}\n\tcout << f[n] + e - x[n] << endl;\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN], v[MAXN];\ndeque<int> p, q;\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nvoid pushp(int x) {\n    while (!p.empty() && f[x] + v[x + 1] - d[x + 1] < f[p.back()] + v[p.back() + 1] - d[p.back() + 1])\n        p.pop_back();\n    p.push_back(x);\n}\n\nvoid pushq(int x) {\n    while (!q.empty() && f[x] + v[x + 1] - d[x + 1] * 3 < f[q.back()] + v[q.back() + 1] - d[q.back() + 1] * 3)\n        q.pop_back();\n    q.push_back(x);\n}\n\nint main() {\n    n = read();\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i) {\n        d[i] = read();\n        v[i] = d[i] - d[i - 1];\n    }\n    p.push_back(0);\n    for (int i = 1, j; i <= n; ++i) {\n        while (!p.empty() && (d[i] - d[p.front() + 1]) * 2 > t) {\n            pushq(p.front());\n            p.pop_front();\n        }\n        f[i] = INF;\n        if (!p.empty()) {\n            j = p.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] + d[i] + t);\n        }\n        if (!q.empty()) {\n            j = q.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] * 3 + d[i] * 3);\n        }\n        pushp(i);\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=4000+5,inf=1e18+1;\nll mod=924844033;\n\nll n,e,t;\nll dp[M];\nll x[M];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> e >> t;\n\tif (n>2000) return 0;\n\tFor(i,0,n)\n\t{\n\t    cin >> x[i];\n\t}\n\tFor(i,1,n+1)\n\t{\n\t    dp[i]=(x[i-1]-x[0])*3+max(0LL,t-2*(x[i-1]-x[0]))+x[0];\n\t    For(j,1,i)\n\t    {\n\t        smin(dp[i],(x[i-1]-x[j])*3+\n\t            max(0LL,t-2*(x[i-1]-x[j]))+\n\t            dp[j]+x[j]-x[j-1]);\n\t    }\n\t    //ER(i);ER(dp[i]);\n\t}\n\tcout << dp[n]+e-x[n-1];\n}    "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 4;\n\nint main()\n{\n    int n, e, t;\n    cin >> n >> e >> t;\n\n    vector<int> x(n+1);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n    x[n] = e;\n\n    vector<long long> dp(n+1, INF);\n    dp[0] = x[0];\n    int j = 0;\n    long long tmp = INF;\n    for(int i=0; i<n; ++i){\n        while(j <= i && (x[i] - x[j]) * 2LL > t){\n            tmp = min(tmp, dp[j] - x[j] * 3LL);\n            ++ j;\n        }\n        dp[i+1] = min(tmp + x[i] * 3LL, dp[j] + (x[i] - x[j]) + t) + (x[i+1] - x[i]);\n    }\n    cout << dp[n] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nLL f[100005];\nint x[100005], n, t, e;\nint main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\trep(i, 1, n) scanf(\"%d\", &x[i]);\n\trop(i, 0, n) {\n\t\trep(j, i + 1, n) {\n\t\t\tf[j] = min(f[j], f[i] + x[i + 1] - x[i] + max((x[j] - x[i + 1]) * 2, t) + x[j] - x[i + 1]);\n\t\t}\n\t}\n\tcout << f[n] + e - x[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tlong long a[N];\n\tlong long dp[N];\n\tqueue<pair<long long, long long> >q;\n\tf(i, N){\n\t\ta[i] = 0;\n\t\tdp[i] = 0;\n\t}\n\tint n, k;\n\tlong long x, y, z;\n\tlong long s, ans, t;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d %lld %lld\", &n, &s, &t);\n\tans = s;\n\tf(i, n){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tif (n == 1){\n\t\tprintf(\"%lld\\n\", s + t);\n\t\treturn 0;\n\t}\n\tdp[0] = t;\n\tq.push(make_pair(dp[0]-a[1], a[1]));\n\ts = -(2 * a[0]);\n\tfor (int i = 1; i<n; i++){\n\t\twhile (true){\n\t\t\tx = q.front().first;\n\t\t\ty = q.front().second;\n\t\t\tif ((a[i] - y)>t){\n\t\t\t\ts = min(s, x - y);\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tx = q.front().first;\n\t\tdp[i] = min(t + x + a[i], s + (2 * a[i]));\n\t\tif (i < n - 1)\tq.push(make_pair(dp[i] - a[i + 1], a[i + 1]));\n\t}\n\tans += dp[n - 1];\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n#define BT 1024*128*2\n#define INF 100000000000005LL\n\nusing namespace std;\ntypedef long long int ll;\n\nstruct segtree\n{\n\tll seg[BT];\n\tint mum;\n\t\n\tvoid init(int n)\n\t{\n\t\tmum=1;\n\t\twhile(mum<n) mum<<=1;\n\t\tfor(int i=0;i<mum*2;i++) seg[i]=INF;\n\t}\n\tvoid add(int k,ll v)\n\t{\n\t\tk+=mum-1;\n\t\tseg[k]=min(seg[k],v);\n\t\twhile(k>0)\n\t\t{\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tll get(int a,int b,int k,int l,int r)\n\t{\n\t\tif(b<=l||r<=a) return INF;\n\t\tif(a<=l&&r<=b) return seg[k];\n\t\telse\n\t\t{\n\t\t\tll vl=get(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=get(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tll get(int a,int b)\n\t{\n\t\treturn get(a,b,0,0,mum);\n\t}\n};\nsegtree s1,s2;\nint X[SIZE];\nll dp[SIZE];\n\nint main()\n{\n\tint n,E,T;\n\tscanf(\"%d %d %d\",&n,&E,&T);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&X[i]);\n\ts1.init(n+2);\n\ts2.init(n+2);\n\tll bef=E;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\ts1.add(i,bef);\n\t\ts2.add(i,X[i]*2LL+bef);\n\t\tint pos=lower_bound(X,X+n,X[i]+T/2+1)-X-1;\n\t\tdp[i]=s1.get(i,pos+1)-X[i]+(ll) T;\n\t\tif(pos+1<n) dp[i]=min(dp[i],s2.get(pos+1,n)-(ll) X[i]*3LL);\n\t\tbef=X[i]+dp[i];\n\t}\n\tprintf(\"%lld\\n\",bef);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nlong long dp[100005], mn = 1e18;\nint arr[100005], que[100005];\nint main()\n{\n\t// freopen(\"AGC007-D.in\", \"r\", stdin);\n\tint n, e, t, he = 0, ta = 0;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1, pos = 0; i <= n; i++)\n\t{\n\t\twhile (pos < i && (arr[i] - arr[pos + 1] << 1) >= t)\n\t\t{\n\t\t\tif (he <= ta && que[he] <= pos)\n\t\t\t\the++;\n\t\t\tmn = std::min(mn, dp[pos] - (arr[pos + 1] << 1));\n\t\t\tpos++;\n\t\t}\n\t\tdp[i] = mn + (arr[i] << 1);\n\t\tif (he <= ta)\n\t\t\tdp[i] = std::min(dp[i], dp[que[he]] + t);\n\t\twhile (he <= ta && dp[que[ta]] >= dp[i])\n\t\t\tta--;\n\t\tque[++ta] = i;\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\ntypedef long long ll;\n\n//const int dx[4] = {1, 0, -1, 0};\n//const int dy[4] = {0, 1, 0, -1};\n\n// const int C ;\n// const int M = 1000000007;\n\nint N;\nll E;\nll T;\nll x[100010];\nll memo[100010];\nint ret[100010];\n\nint main () {\n  cin >> N >> E >> T;\n  for (auto i = 0; i < N; i++) {\n    cin >> x[i];\n  }\n  memo[0] = x[0] + T;\n  ret[0] = -1;\n  for (auto i = 1; i < N; i++) {\n    ll wait = memo[i-1] + (x[i] - x[i-1]) + T;\n    ll back;\n    if (ret[i-1] == -1) {\n      back = x[i];\n    } else {\n      back = memo[ret[i-1]] + (x[i] - x[ret[i-1]]);\n    }\n    ll time = x[i] - x[ret[i-1]+1];\n    if (2 * time < T) back += (T - 2 * time);\n    back += 2 * time;\n    if (wait > back) {\n      memo[i] = back;\n      ret[i] = ret[i-1];\n    } else {\n      memo[i] = wait;\n      ret[i] = i;\n    }\n  }\n  cout << memo[N-1] + (E - x[N-1]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int maxn = 1e5 + 20;\n\nint N, E, T;\nint x[maxn];\nlong long f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tfor(int i = 1; i <= N; i++) f[i] = 1e18;\n\t\n\tfor(int i = 1, j = 1; i <= N; i++)\n\t{\n\t\twhile(j <= N && 2 * (x[j] - x[i]) <= T) j++;\n\t\n\t\tf[j] = std::min(f[j], f[i - 1] + 2 * (x[j] - x[i]));\n\t\tf[j - 1] = std::min(f[j - 1], f[i - 1] + T);\n\t\tf[i] = std::min(f[i], f[i - 1] + T);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[N] + E);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\nvoid debug_impl() { std::cerr << '\\n'; }\ntemplate <class Head, class... Tail>\nvoid debug_impl(Head&& head, Tail&&... tail) {\n    std::cerr << ' ' << head;\n    debug_impl(std::forward<Tail>(tail)...);\n}\n\n#define ENABLE_DEBUG\n#ifdef ENABLE_DEBUG\n#define debug(...)\\\n    do { std::cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n         debug_impl(__VA_ARGS__); std::cerr << noboolalpha; } while (false)\n#else\n#define debug(...)\n#endif\n\ntypedef long long lint;\nconstexpr lint inf = 1ll << 60;\n\nint N;\nlint T;\nlint X[100001];\nlint dp[100002];\n\ntemplate <class Mn, class Op>\nstruct segment_tree {\nprivate:\n\n    int size;\n    std::vector<Mn> node;\n    const Mn unit;\n    const Op oper;\n\npublic:\n\n    segment_tree(const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { }\n    segment_tree(const int& size_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { init(size_); }\n    segment_tree(const std::vector<Mn>& node_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { build(node_); }\n\n    void init(const int& size_) {\n        for(size = 1; size < size_; size <<= 1);\n        node.assign(size << 1, unit);\n    }\n\n    void build(const std::vector<Mn>& node_) {\n        init(node_.size());\n        for (int i = 0; i < node_.size(); ++i) {\n            node[i + size] = node_[i];\n        }\n        for (int i = size - 1; i > 0; --i) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void set_value(const int& idx, const Mn& value) {\n        int i = idx + size;\n        for (node[i] = value; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void add_value(const int& idx, const Mn& plus) {\n        int i = idx + size;\n        for (node[i] += plus; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    Mn fold(const int& l, const int& r) const {\n        Mn result_l = unit, result_r = unit;\n        for(int tl = l + size, tr = r + size; tl < tr; tl >>= 1, tr >>= 1) {\n            if (tl & 1) { result_l = oper(result_l, node[tl]); ++tl; }\n            if (tr & 1) { --tr; result_r = oper(node[tr], result_r); }\n        }\n        return oper(result_l, result_r);\n    }\n\n    Mn operator [] (const int& idx) const {\n        return node[idx + size];\n    }\n\n};\n\nint main() {\n    \n    cin >> N;\n    cin >> X[N + 1] >> T;\n    rep(i, 1, N) cin >> X[i];\n\n    const auto getmin = [](const lint& x, const lint& y) { return x < y ? x : y; };\n    segment_tree<lint, decltype(getmin)> memo1(N + 1, inf, getmin), memo2(N + 1, inf, getmin);\n    memo1.set_value(0, 0);\n    memo2.set_value(0, - 2 * X[1]);\n\n    rep(i, 1, N) {\n        dp[i] = inf;\n        int l = 0, r = (X[i] - X[1]) * 2 < T ? 0 : i;\n        while(r - l > 1) {\n            int md = (l + r) / 2;\n            ((X[i] - X[md + 1]) * 2 >= T ? l : r) = md;\n        }\n        chmin(dp[i], memo1.fold(r, i) + T + X[i]);\n        chmin(dp[i], memo2.fold(0, r) + 3 * X[i]);\n        memo1.set_value(i, dp[i] - X[i]);\n        memo2.set_value(i, dp[i] - 2 * X[i + 1] - X[i]);\n    }\n    \n    cout << dp[N] + X[N + 1] - X[N] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll f[maxn],xx[maxn];\nll n,e,t;\nll store;//fj-2xj+1\nint main(){\n\tll b1,b2,b3,b4;\n\tll p;//定位\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\t\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\tfor (b1=1;b1<=n;b1++){\n\t\tf[maxn]=b1*t;\n\t}\n\tp=0;store=((ll)1<<60);\n\tfor (b1=1;b1<=n;b1++){\n\t\twhile (2*xx[p+1]<=2*xx[b1]-t){\n\t\t\tstore=min(store,f[p]-2*xx[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tf[b1]=min(2*xx[b1]+store,f[p]+t);\n\t\tf[b1]=min(f[b1-1]+t,f[b1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  ll bestF = Inf; \n  auto relaxF = [&] (int i) {\n    bestF = min(bestF, dp[i] - x[i] - (ll)t * i);\n  };\n  auto get0 = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1]; \n  };\n  auto gett = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1] + 2 * x[i + 1];\n  };\n  relaxF(0);\n  multiset <ll> h0, ht;\n  ht.insert(gett(0));\n  int uk = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (uk < i && t - 2 * x[i] + 2 * x[uk + 1] < 0) {\n      ht.erase(gett(uk));\n      h0.insert(get0(uk));\n      ++uk;\n    }\n    dp[i] = bestF + x[i] + (ll)t * i;\n    if (!h0.empty()) dp[i] = min(dp[i], *h0.begin() + 3 * x[i]); \n    if (!ht.empty()) dp[i] = min(dp[i], *ht.begin() + 3 * x[i] + t);\n    /*for (int j = i + 1; j <= n; ++j) {\n      ll extra = max(0LL, t - 2 * x[j] + 2 * x[i + 1]);\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }*/\n    relaxF(i);\n    ht.insert(gett(i));\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint N,E,T,X[100100];\nlong long D[100100];\n\nint main()\n{\n\tscanf (\"%d %d %d\",&N,&E,&T);\n\tfor (int i=1;i<=N;i++) scanf (\"%d\",&X[i]);\n\tfor (int i=1;i<=N;i++){\n\t\tD[i] = 1e18;\n\t\tfor (int j=0;j<i;j++){\n\t\t\tlong long d = D[j] + X[i] - X[j] + max(T,2*(X[i]-X[j+1]));\n\t\t\tif (D[i] > d)\n\t\t\t\tD[i] = d;\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\",D[N]+E-X[N]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <vector>\n#define MAXN 100005\n#define LL long long\nusing namespace std;\nint n, e, t;\nvector<int> num;\nint main()\n{\n    scanf(\"%d%d%d\", &n, &e, &t);\n    num.clear();\n    for(int x, i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x);\n        num.push_back(x);\n    }\n    LL sum = 0;\n    sum += num[0] + e - num[n - 1];\n    //cout << sum << endl;\n    for(int j, i = 0; i < n; i = j)\n    {\n        j = i;\n        while(j < n && num[j] - num[i] <  t) j++;\n        sum += 3LL * (num[j - 1] - num[i]);\n        for(int k = i; k < j; k++)\n        {\n            if((num[j - 1] - num[i]) * 2 < t) sum += (t - num[j - 1] + num[i]);\n        }\n        if(j < n) sum += num[j] - num[j - 1];\n        //cout << i << \" \" << j << endl;\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[i]+(x[i]-x[0])*2+max(0, T-(x[i]-x[0])*2));\n        for (int j=1; j<i; j++)\n            A[i] = min(A[i], A[j-1]+(x[i]-x[j-1])+(x[i]-x[j])*2+max(0, T-(x[i]-x[j])*2));\n    }\n\n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[1234567];\nint x[1234567];\nlong long const INF = 1LL << 60;\nint main() {\n  int n, ex, T;\n  scanf(\"%d%d%d\", &n, &ex, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n  for (int i = 0; i <= n; i++) {\n    dp[i] = INF;\n  }\n  dp[0] = 0;\n  x[0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      long long first = dp[i] + x[i + 1] - x[i] + T;\n      long long last = dp[i] + x[j] - x[i];\n      long long back = last + x[j] - x[i + 1];\n      back = std::max(back, first);\n      last = back + x[j] - x[i + 1];\n      dp[j] = std::min(dp[j], last);\n    }\n  }\n  // for (int i = 0; i < n; i++) {\n  //   long long end = (long long) i * T + x[n - 1];\n  //   long long next = std::max(end + x[n - 1] - x[i], x[i] + (long long) (i + 1) * T);\n  //   ans = std::min(ans, next + ex - x[i]);\n  // }\n  printf(\"%lld\\n\", ex - x[n] + dp[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define N 100010\ntypedef long long ll;\n\nconst ll INF=1e18;\n\nint n,E,T;\nint dis[N];\nll Dp[N];\n\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint main()\n{\n    n=read();E=read();T=read();\n    for(int i=1;i<=n;i++)\n        dis[i]=read();\n    Dp[0]=0;\n    int pos=0;\n    for(int i=1;i<=n;i++)\n    {\n        Dp[i]=Dp[i-1]+T;\n        ll Min=INF;\n        while(pos+1<=i&&2*(dis[i]-dis[pos+1])>T)\n        {\n            Min=min(Min,Dp[pos]-2*dis[pos+1]+2*dis[i]);\n            pos++;\n        }\n        Dp[i]=min(min(Dp[i],Dp[pos]+T),Min);\n    }\n    cout<<Dp[n]+E<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint x[100010];\nll f[100010];\nint que[100010],hd,tl;\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),E=gi(),T=gi();\n\tfor(int i=1;i<=n;++i)x[i]=gi();x[++n]=E;\n\tll MN=9e18;\n\tfor(int i=n-1;i;--i){\n\t\tf[i]=9e18;\n\t\twhile((hd^tl)&&f[que[tl-1]]+x[que[tl-1]]>f[i+1]+x[i+1])--tl;\n\t\tque[tl++]=i+1;\n\t\twhile((hd^tl)&&2*(x[que[hd]-1]-x[i])>T)MN=std::min(MN,f[que[hd]]+x[que[hd]]+2*x[que[hd]-1]),++hd;\n\t\tif(hd^tl)f[i]=f[que[hd]]+x[que[hd]]-x[i]+T;\n\t\tf[i]=std::min(f[i],MN-3ll*x[i]);\n\t}\n\tprintf(\"%lld\\n\",f[1]+x[1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<39;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nll n, e, t;\nll x[N], dp[N];\n\nint main(){\n\tcin>>n>>e>>t;\n\trep(i, n) cin>>x[i];\n\tfill(dp, dp+N, INF);\n\tdp[0] = 0;\n\trep(i, n){\n\t\tll r = upper_bound(x, x+n, x[i]+t/2)-x;\n\t\tif(r<n){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t\tr--;\n\t\tif(r>=i){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t\tif(i>=1) chmin(dp[i+1], dp[i]+2*(x[i]-x[i-1]));\n\t}\n\tcout<<dp[n]+e<<endl;\n\trep(i, n+1) cerr<<dp[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0;\n\tdp[1] = A[1] + T;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\t//for(int j = 0; j < i; ++ j)\n\t\twhile(cur + 1 < i && calc(cur, i) >= calc(cur + 1, i)) ++ cur;\n\t\tdp[i] = min(calc(cur, i), dp[i]);\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nlong long f[101010];\nlong long x[101010];\nlong long E,T;\nlong long calc(int i,int j)\n{\n\treturn max(f[j-1]+T,f[j-1]+2*x[i]-2*x[j]);\n}\npriority_queue<long long> Q;\nint main()\n{\n\tint n;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>x[i];\n\tf[1]=T;\n\tint now=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]+T;\n\t\tint l=1,r=i-1;\n\t\twhile(r>l)\n\t\t{\n\t\t\tint m=(l+r)/2;\n\t\t\tif(T-2*x[i]+2*x[m]>=0)\n\t\t\t\tr=m;\n\t\t\telse\n\t\t\t\tl=m+1;\n\t\t}\n\t\tf[i]=min(f[i],max(f[l-1]+T,f[l-1]+2*x[i]-2*x[l]));\n\t\tif(l>1)\n\t\t{\n\t\t\twhile(now<l-1)\n\t\t\t{\n\t\t\t\tnow++;\n\t\t\t\tQ.push(2*x[now]-f[now-1]);\n\t\t\t}\n\t\t\tf[i]=min(f[i],2*x[i]-Q.top());\n\t\t}\n\t}\n\tcout<<f[n]+E<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\n\nLL getdist(vector<LL> &x, LL T, int i, int j, bool& param) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\tif(T < (x[j] - x[i]) * 2) param = true;\n\telse param = false;\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tLL p2 = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos = p2;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tbool a;\n\t\t\tLL data = getdist(x, T, pos , i, a);\n\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tif(ans[i] >= ans[pos] + data) p2 = pos;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n//\t\t\tif(a) break;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\tbool tmp;\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[j] = min(ans[j], ans[i] + getdist(x, T,i, j, tmp));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int MAXN = 100000;\nint x[MAXN + 1];\nll dp[MAXN + 1];\n\nint main() {\n    //ios_base::sync_with_stdio(false);\n   // freopen(\"input.txt\", \"r\", stdin);\n   // freopen(\"output.txt\", \"w\", stdout);\n\n    int n, e, t;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    for(int i = 0; i <= MAXN; i++)\n        dp[i] = 1e18;\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        dp[i] = min(dp[i], dp[i - 1] + (x[i] - x[i - 1]) + t);\n        /*for(int j = 0; j < i; j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }*/\n        for(int j = 0; j <= 0; j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }\n        int l = 0, r = i, m1, m2;\n        while(r > l + 2) {\n            m1 = l + (r - l) / 3;\n            m2 = r - (r - l) / 3;\n            ll res1 = 0, res2 = 0;\n\n            ll need = 2 * (x[i] - x[m1]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            res1 = dp[m1 - 1] + need + (x[i] - x[m1]) + (m1 > 0 ? (x[m1] - x[m1 - 1]) : 0);\n\n            need = 2 * (x[i] - x[m2]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            res2 = dp[m2 - 1] + need + (x[i] - x[m2]) + (m2 > 0 ? (x[m2] - x[m2 - 1]) : 0);\n            if(res1 <= res2)\n                r = m2;\n            else\n                l = m1;\n        }\n        for(int j = max(1, m1 - 10); j < min(i, m2 + 10); j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (j > 0 ? (x[j] - x[j - 1]) : 0));\n        }\n    }\n    dp[n] += e - x[n];\n    cout << dp[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\t// dp[i]: shortest time to clear first i candies.\n\tdp[0] = 0;\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tfor (ll j = 0; j < i; j++) dp[i] = min(dp[i], dp[j] + max(2 * (a[i] - a[j + 1]), t) + a[i] - a[j]);\n\t}\n\t// hj, optimize nao\n\t// 2 segtrees: one record dp[j] - 2 * a[j + 1] - a[j], one record dp[j] - a[j].\n\t\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = B) + fread(B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar B[1 << 15], *_S = B, *_T = B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 100010\nint a[maxn];\nlong long f[maxn];\nint main()\n{\n//\tsetfile();\n\tR int n = F(), E = F(), T = F();\n\tfor (int i = 1; i <= n; ++i) a[i] = F();\n\tR long long ans = E;\n\tR int last = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i] = i * T;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tint S = a[i] - a[j], temp = dmax(T - 2 * S, 0);\n//\t\t\tprintf(\"%d %d\\n\", S, temp );\n//\t\t\tprintf(\"i = %d j = %d %lld\\n\", i, j, f[j - 1] + temp * (i - j + 1) + S * 2 );\n\t\t\tcmin(f[i], f[j - 1] + temp * (i - j + 1) + S * 2);\n\t\t}\n//\t\tprintf(\"f[%d] = %lld\\n\", i, f[i] );\n\t}\n\tprintf(\"%lld\\n\", f[n] + ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nll n,e,t;\nvl a;\n\nint main(){\n\tcin>>n>>e>>t;\n\ta=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tll ans=a[0],now=a[0];\n\tfor(int i=0;i<n;i++){\n\t\twhile(i<n-1&&a[i+1]<=now+t) i++;\n\t\tll tmp=a[i]-now;\n\t\tans+=(2*tmp-t>=0)?3*tmp:t+tmp;\n\t\tnow=a[i];\n\t\tif(i!=n-1){\n\t\t\tans+=a[i+1]-now;\n\t\t\tnow=a[i+1];\n\t\t}\n\t}\n\tcout<<ans+e-a[n-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nconst int inf =1e18;\nint n,e,t,dp[maxn],x[maxn],pm[4*maxn];\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,1,n+1)cin>>x[i];\n    int g=0;\n    pm[0]=-2*x[1];\n    rep(i,1,n+1)\n    {\n        while(x[g+1]<=x[i]-t/2.0)g++;\n        dp[i]=min(t+dp[g],g>=1?2*x[i]+pm[g-1]:inf);\n        pm[i]= min(pm[i-1],dp[i]-2*x[i+1]);\n    }\n    cout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint32_t main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<4*maxn;i++){\n\t\tseg[i]={(long long)1e18,(int)1e9};\n\t\tseg2[i]={(long long)1e18,(int)1e9};\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\tif(2*(a[i]-a[0])<d){\n\t\t\tr=0;\n\t\t}\n\t\tif(2*(a[i]-a[i-1])>=d){\n\t\t\tl=i-1;\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18+10;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define NMAX 100000\nusing namespace std;\n\nint min[NMAX], max[NMAX];\nlong long c[NMAX], dp[NMAX];\nint n;\nlong long e, t;\n\nlong long mxm(long long a, long long b);\n\nint main()\n{\n\tcin >> n >> e >> t;\n\tint prec = -1e9, m = 0, cit;\n\n\twhile (n--) {\n\t\tcin >> cit;\n\t\tif (cit - prec > t) {\n\t\t\tm++;\n\t\t\tmin[m] = cit;\n\t\t}\n\t\tmax[m] = cit;\n\t\tprec = cit;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t\tc[i] = mxm(2ll * (max[i] - min[i]), t) + max[i] - min[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[i] = dp[i - 1] + c[i] + 1ll * (min[i] - max[i - 1]);\n\n\tcout << (long long) dp[m] + e - max[m];\n\n\treturn 0;\n}\n\nlong long mxm(long long a, long long b)\n{\n\tif (a > b)\n\t\treturn a;\n\treturn b;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    ll ans = e - x[n - 1] + x[0];\n    for (int i = 0; i < n;) {\n        if (i != 0) ans += x[i] - x[i - 1];\n        ll tmp = t;\n        for (int j = n - 1; j >= i + 1; j--) {\n            ll tmp1 = max((x[j] - x[i]) * 3, (x[j] - x[i]) + t);\n            ll tmp2 = x[j] - x[i] + t * (j - i + 1);\n            if (tmp1 < tmp2) {\n                tmp = tmp1;\n                i = j + 1;\n                break;\n            }\n        }\n        if (tmp == t) i++;\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k        2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                   .  YO.               vq                            :G       Z:\n *          SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *          B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *              iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *         vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *         N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *              r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *              7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *         ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *         E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *              7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *              LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *          .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *          MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                            .ll                                           rB.                     :\n                 .::                                                       ,,         .:                    :,         :.\n          :LuqL  5B@   :v             77L21F5F5F5F1F5S15Uv7,              :@B         0@U                  .B@        L@P\n B@B@@@B@B@B@@B  L@B   B@B@,          @BB2XSPSPkPXPkPXPF2B@B     .@B@B@B@B@@@B@B@B@B@@@B@B@B@B@B@ :@@@@BBMOB@BGM@B@BME@@@EMB@B@B@r\n ,Yi:  @B2       iB@     2@@@7        B@,                8Bq      vriii:.:0@@:ii::,:::B@B::iiii77 ,E1uJuJJ7GB@7LUk2ULvB@B7LjJjjSq:\n       B@7        @B       i7         @B@B@B@B@B@B@B@B@B@B@k          @B  .BZ    u@.   :                   ,@N        7B2\n0EqEqX2@B@1N0Z0ZSqB@qX0ZNPUYLSZ8      B@                 NBP          :@B       1@BMX0uj2EEZN15,    8@B@B@@@GGB@7 5@B@BOM@B@B@B.\n@B@B@B@@@B@B@B@B@B@B@B@B@B@B@B@B      @B@B@B@B@B@B@B@B@B@B@q      @B@B@B@B@@@u S@B2qOOMOMM@BMB@L              @@7            B@.\n       @Bv        @@v       .         B@:                k@v      :i;.,...q5::B@k            @Bi     8@@B@B@B@B@v  BB@B@B@B@@@B.\n       B@L   .,7  0B@     SB@S   :5jj7vi::iiiii:..,:iii::;77LY25   B@     @B u@20B@B@B@B@N   @@:     B@       .:   B@        ::\n .:v28P@B@@@B@B@, ,@@   u@B@.    YB@B@ME0OB@B@@@B@BMB@B@BBOBB@B@.  L@@   OBS    B@:    JB@   @B.    v@BLuXP0qXvL: 1@B7ukXE00SYvL\n@@@B@B@B@Z.        B@kLB@B:            7Ei      @@;                 @B:  B@     @B     .@O   B@      LO1i   , @B0  ;BX7.  ,..P@B\n       @Bu         1B@B5     ::       :@B       B@@@B@B@@@B@B@      7@@ U@u     B@i,::.PB@   @B      .7OBGu   Z@v   rNBOFi   7B8\n       B@5      7B@B@B@      B@B     i@B@7      @BN.::i:i:i:ii       17 @B      @B@B@B@MMY   B@          u@OBUMBi      :@BNBYv@F\n       @B0  u@B@B@L  kB@;    @@;    0@B.J@@O:   B@i               ,:ii7@B@B@@@u SZ          i@B    LB@@@B@5Y, B@, 5@@@B@GFY: ZBu\n :5rr:5B@J  MBM:      iB@@k:@@@  ,NB@E    k@@B@B@B@qEZMMBM@MBB@Br @B@B@OY77:,      :MSUjuukB@Br    iBvUr.   .8@B  i5::r     YB@\n .B@B@BZ:                0B@B8   @BO         .:i:77uU5uFSkFkFXXq                    B@B@@@GU.         ,@B@B@BM:       B@B@B@B7\n          .:7kq  ;@B,   ,                   @B.    i@M                .B@,      N@@       .BO       :,.            .:..\n LB@@@B@B@B@B@@  :B@,  EB@O,                B@i    U@@                 ,q@BX    1@B    ,q@B0:      ,B@B@B@B@B@B@1  @B@B@B@B@B@B@\n  kri. M@@        @B:    u@B@J    @B@B@B@B@@@Bi    J@@@B@B@B@B@B   irrvi:u@BjLJ7@B@7YYLB@Bj::rir              @Bj            i@B\n       EBO        @@:      :1     iiii:i::,:B@:    uB@.::i:i:iii   @B@qquvrLu1127rrUU5Uvrrv5q@B@.    .,iiiii::B@L   .,:iiiii:E@@\nYLLvv7iB@Bi7YLYL7r@@ErLLL7r::iYU            @@i    Y@@             B@k      . .     ...       @B,    B@B@B@B@B@BF   @B@B@B@B@@@B\n@@B@B@B@B@@@B@B@B@B@B@B@B@B@B@B@.           B@i    uB@             r7. ,B@MMMBMBMBMBMBMMG@B@  7v    r@M            LB8\n       E@O        PBM       .     vB@B@B@@@B@Bi    J@B@B@B@B@@@7       .@B               P@8        @BX.::i:i:     B@2,:::i:i.  .\n       Z@M     ;  ;@B     i@@@    ,ULYLJLL77@@i    uB@ivLYLJLJu:       ,B@B@B@B@B@B@B@B@B@B@        BOEOB@B@B@B@q  BZNO@B@B@B@B@@\n  ,:i7JB@B@B@B@@u  B@:  :B@Bv               @Bi    J@B                  2J      uB@      :u:         @@r      @BL  7@X:       8BZ\nB@B@B@B@B@,i.      kBBi@B@L                 B@i    j@@               uYjvJ2kSk1jM@@u2kFS1uLuJUi      iu@B@O   B@i  .iNB@Bj    B@u\n .     Z@M         :@B@Mi     :  rEXqXXXPS5U@Bi    Y@Bj1XXqkXXN07    B@Bq088OOGk@B@SE8OZZNq5@B@          i7:, @@,       ::i2r @B7\n       MB@      ,8B@B@B      kB@ Y@@B@B@BBOGB@i    uB@EMB@B@B@B@j    @Bi        7@B         G@8    ukBB@@@B@P B@  .75BB@@@B@: B@:\n       O@B  7u@B@BO, v@@v    B@G            @Bi    J@B               B@Y        uB@    7:,.i@BS   ,B@B1:     .@B  N@@BL       @B.\n  5ri:r@B@  k@BL.     ,@B@q:5@B             B@r    1@@               @B7        F@B    @B@B@Or        .i.,,:1@B8       r,:::u@B@\n  @B@B@B1               .q@B@B:             @Br    L@B                          5B@                   kB@B@@@5.       r@@@@B@Z;\n           ,ijN   B@L   .             B@5                          .:...,:,:,.     ,,:.......                  ... .\n :@B@B@@@B@B@@@i  @B1  j@B@.         .@B      .B@B@B@@@B@B@B@B@B   G@B@B@B@B@B@B  .B@B@B@@@B@B@v    7;L7ri. @@@B@B@@ B@B@B@@@B@B@@\n  NLrr:0B@        B@2    YB@@N       UBB       ... .      .@B@Bi              B@             @Br    B@BBB@8 B@   JBE         :B@\n       :@B        BBk      .O:   E@B@B@B@B@B@P          .M@BS        ..,:,:,.7@@    ,.:,:::.,B@i    @B  :BS BB   B@           @B\n:L77rr:E@@ir7vvvr:B@B:rv7ri:::rJ :7ij@Biir:@BM        :@B@i         v@B@@@B@B@@@   UB@B@B@B@B@BL    B@  i@5 M@  S@v  UB@B@@M  B@\n8B@B@B@B@B@B@B@B@B@@@B@B@@@B@B@@L   JBM    @@i        5B@           @B.            @@               @B  ;@F BB  @B   O@L .@B  @B\n       7B@        i@B               @@,    @B         L@B          ,B@..,:,,..    :@B..,,:,:.  .    B@  i@5 M@ .B@   NB.  B@  @@\n       ;@B     ,,  B@      @@B.    U@B    0BE @B@B@B@B@B@B@B@B@B@  LBEOB@@@B@B@B  UO0G@B@B@B@B@Bi   @B  rBS MB. :@@  X@,  @B  @B\n    ,;7B@@B@B@B@B  @B5   MB@q      @B7    B@          Y@B           :@5.      B@   OOv        @@    B@  i@5 M@.  jB5 kB.  B@  B@\n7B@B@B@B@@1r:      ;@B.Z@@O        iB@@r B@j          vB@           ,1@B@B;  :@B   i0B@B@     @B    @B  ,BF MB.   @B 2@5i7@B  @B\n ::    7B@          B@B@u             7@B@B           Y@@                j , r@@        i :0 ,B@    B@LLG@F M@    @@ 0@@B@MZ  B@\n       L@B       v@B@@@:     :@B:      B@B@B1.        jB@         :LLkBB@B@B 7@B  :7L0@B@@@B :@@    @@MO@BO BB2B@B@7 Y@       @@\n       7B@  .7B@B@B7 :B@u    qB@    .@B@  .@B@:       7@B         O@@B7,     BBO  B@BMi      SB@    B@   :  B@.:i:            B@\n  u::.,B@B  LB@Gi     .B@B2.:B@i  uB@B7         rL::,:@B@             :.   ,P@@:      :,  .:uB@r            @B.         .:.  U@@\n  B@B@BBS                5B@BM:   MB            v@@@@@Mv              @@B@B@Bv        B@@@B@Bu              M@          .@B@B@X\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n#define IN inline\n#define RE register\n#define F first\n#define S second\n#define N 100005\n#define mod 998244353\n#define INF 0x3f3f3f3f\nint n,t,e;\nll a[N],dp[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tll curmin=100000000000ll;\n\tint p=0;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",a+i);\n\t\twhile((a[i]-a[p+1]<<1)>t){\n\t\t\tcurmin=min(curmin,dp[p]-(a[p+1]<<1));\n\t\t\t++p;\n\t\t}\n\t\tdp[i]=min(dp[p]+t,(a[i]<<1)+curmin);\n\t\t//printf(\"%d %lld\\n\",p,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\n//pair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>=val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint n,E,T,q[N],head,tail,x[N];ll dp[N];\nll cost(int i,int j){return dp[j]+x[i]-x[j]+T;}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tint p=0;ll v=1e16;\n\tq[head=tail=1]=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (;p<i&&2*(x[i]-x[p+1])>=T;p++) v=min(v,dp[p]-x[p]-2*x[p+1]);\n\t\tfor (;head<=tail&&2*(x[i]-x[q[head]+1])>T;head++);\n\t\tdp[i]=v+3ll*x[i];\n\t\tif (head<=tail) dp[i]=min(dp[i],cost(i,q[head]));\n\t\tfor (;head<=tail&&cost(i,q[tail])>=cost(i,i);tail--);\n\t\tq[++tail]=i;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+E-x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define en end()\n#define bg begin()\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n#define y1 y1234567890\n#define um unordered_map                         \n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define sqrd(x) ((x) * 1.0 * (x))\n\nconst ll INF = (ll)1e18;\nconst int inf = (int)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst double pi = acos(-1.0);\nconst double eps = (double)1e-9;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nconst int N = 300500;\n\nint n;\nll x[N], dp[N], t, e, dp2[N];\n\nint main() {\n\tsrand(time(NULL));\n\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\n\tcout << setprecision(10) << fixed;\n\n\tcin >> n >> e >> t;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> x[i];\n\n\tdp[0] = 0;\n\t\n\tint cur = 1;\n\n\tdp2[0] = INF;\n\n\tfor(int i = 1; i <= n; ++i){\n\t\twhile(t - 2LL * (x[i] - x[cur]) < 0)\n\t\t\tcur++;\n\t   \tdp[i] = min(dp2[cur - 1] + 2LL * x[i], dp[cur - 1] + t);\n\t   \tdp2[i] = min(dp2[i], dp[i - 1] - 2LL * x[i]);\n\t}\n\n\tcout << dp[n] + e;\n\n\t//cerr << (clock() + 0.0) / 1000.0;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\n#define mid ((s + e) / 2)\n#define int long long\n\nint n, ed, tad;\nint x[N];\nint dp[N];\nint seg[N * 4];\nint laz[N * 4];\nint get(int l, int r, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn 1e17;\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\treturn min(get(l, r, v * 2, s, mid), get(l, r, v * 2 + 1, mid, e));\n}\nvoid add(int l, int r, int val, int v = 1, int s = 0, int e = N) {\n/*\tif (v == 1)\n\t\tcout << \"\t\t\tadd : \" << l << ' ' << r << ' ' << val << endl;*/\n\tif (r <= s || e <= l)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[v] += val;\n\t\tlaz[v] += val;\n\t\treturn;\n\t}\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v * 2] += laz[v];\n\tlaz[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\tadd(l, r, val, v * 2, s, mid);\n\tadd(l, r, val, v * 2 + 1, mid, e);\n\tseg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> ed >> tad;\n\tint pnt = -1;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tadd(0, 1, 0 + x[1] - 0 + tad);\n\t\t}\n\t\tadd(0, pnt + 1, (x[i] - x[i - 1]) * 2);\n\t\twhile ((x[i] - x[pnt + 1]) * 2 >= tad) {\n\t\t\tadd(pnt, pnt + 1, (x[i] - x[pnt + 1]) * 2 - tad);\n\t\t\tpnt++;\n\t\t}\n\t\tadd(0, i - 1, x[i] - x[i - 1]);\n/*\t\tcout << \"all done : \" << endl;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tcout << j << \" > \" << get(j, j + 1) << \"    \"; \n\t\tcout << endl;\n*/\t\tdp[i] = get(0, i);\n//\t\tcout << \"dp[i] : \" << i << \" \" << dp[i] << \" \" << dp[i] + x[i + 1] - x[i] + tad << endl;\n\t\tadd(i, i + 1, dp[i] + x[i + 1] - x[i] + tad);\n\t}\n\tcout << ed - x[n] + dp[n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T>\nostream& operator<<(ostream& o, vector<T>& v) {\n    for (auto& x : v) o << x << ' ';\n    return o;\n}\nconst int MAXN = 100010;\nll n, T, E;\nll memo[MAXN];\nll arr[MAXN];\nll dp(int id){\n    if (id == n) return E - arr[n-1];\n    ll &res = memo[id];\n    if (res != -1) return res;\n    ll pre = arr[id];\n    if (id) pre = arr[id] - arr[id-1];\n\n    res = LLONG_MAX/2;\n    for (int i = id; i < n; i++){\n        ll d = arr[i] - arr[id];\n        ll cur = pre + max(2LL * d, T) + d + dp(i + 1);\n        if (cur < res) res = cur;\n    }\n    return res;\n}\n\nint main(){\n    std::ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> E >> T;\n    if (n > 2000) assert(false);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    memset(memo, -1, sizeof memo);\n    ll res = dp(0);\n    cout << res << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\n#define int long long\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nsigned main() {\n  scanf(\"%lld%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = n;\n    while (high - low > 1) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 >= T) low = mid;\n      else high = mid;\n    }\n    int pos = low;\n    dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,e,t;\n  cin >> n >> e >> t;\n  \n  assert(n <= 2000);\n\n  vector<int> a(n+1,0);\n  REP(i,n) cin >> a[i+1];\n\n  vec dp(n+1,INF);\n  dp[0] = 0;\n  REP(i,n){\n    FOR(j,i+1,n+1){\n      int dist1 = a[j]-a[i], dist2 = a[j]-a[i+1];\n      dp[j] = min(dp[j],dp[i]+dist1+dist2*2+max(0LL,t-dist2*2));\n    }\n  }\n\n  cout << dp[n]+e-a.back() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]));\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tfor (int x=now+1; x<=n&&x-now<=1500; ++x){\n\t\t\tf[x]=min(f[x],f[now]+max(2*(pos[x]-pos[now+1]),wait));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,x,y) for(ll i=x; i<=y; i++)\n#define BIT(t) ((long long 1) << t)\n#define PER(i,y,x) for(ll i=y; i>=x; i--)\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\nusing namespace std;\ntypedef long long ll;\n\nstruct segtree {\n       vector<ll> tree;\n\n       ll op(ll x, ll y) {\n               return min(x,y);\n       }\n       ll const INIT_VALUE = 1e18;\n       ll n_ = 1;\n\n       segtree(ll n) {\n               while (n_ <= n) {\n                       n_ *= 2;\n               }\n               tree = vector<ll>(n_ * 2 + 1, INIT_VALUE);\n       }\n\n       //k番目をxでupdate\n       void update(ll k, ll x) {\n               k += n_;\n               tree[k] = x;\n               while (k >= 1) {\n                       k /= 2;\n                       tree[k] = op(tree[k * 2], tree[k * 2 + 1]);\n               }\n       }\n\n       ll val_o(ll a, ll b, ll k, ll l, ll r) {\n               if (a <= l && r <= b) {\n                       return tree[k];\n               }\n               else if (r <= a || b <= l) {\n                       return INIT_VALUE;\n               }\n               else {\n                       ll x1 = val_o(a, b, k * 2, l, (l + r) / 2);\n                       ll x2 = val_o(a, b, k * 2 + 1, (l + r) / 2, r);\n                       return op(x1, x2);\n               }\n\n       }\n\n       //[a,b)のvalueを求める\n        ll val(ll a, ll b) {\n            if(a >= b){\n                return INIT_VALUE;\n            }\n            return val_o(a, b, 1, 0, n_);\n        }\n};\n\nll const MAX = 1e5 + 5;\nsegtree tree1(MAX), tree2(MAX);\nvll a(MAX);\nvll dp(MAX);\nint main(){\n    ll n,e,t;\n    cin >> n >> e >> t;\n    a[0] = 0;\n    REP(i,1,n){\n        cin >> a[i];\n    }\n    tree1.update(0,0);\n    tree2.update(0,-2 * a[1]);\n    a.push_back(1e18);\n    REP(i,1,n){\n        ll tmp = lower_bound(a.begin(), a.begin() + n + 1, a[i] - double(t) / 2) - 1 - a.begin();\n        ll k1,k2;\n        k1 = tree1.val(tmp, i) + a[i] + t;\n        k2 = tree2.val(0, tmp) + 3 * a[i];\n        dp[i] = min(k1,k2);\n        tree1.update(i, dp[i] - a[i]);\n        tree2.update(i, dp[i] - a[i] - 2*a[i+1]);\n    }\n    cout << dp[n] + e - a[n]<< endl;    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MN = 100010;\n\nint N, E, T;\nint X[MN];\n\nstruct BIT {\n    vector<ll> tree;\n    void init() {\n        tree = vector<ll>(4 * MN, 1e18);\n    }\n    void upd(int idx, ll val, int l, int r, int n) {\n        if(idx < l || r < idx) return;\n        if(l == r) {\n            tree[n] = min(tree[n], val);\n            return;\n        }\n        int m = (l + r)>>1;\n        upd(idx, val, l, m, 2*n);\n        upd(idx, val, m + 1, r, 2*n + 1);\n        tree[n] = min(tree[2*n], tree[2*n + 1]);\n    }\n    ll quer(int a, int b, int l, int r, int n) {\n        if(b < l || r < a) return 1e18;\n        if(a <= l && r <= b) return tree[n];\n        int m = (l + r)>>1;\n        ll L = quer(a, b, l, m, 2*n);\n        ll R = quer(a, b, m + 1, r, 2*n + 1);\n        return min(L, R);\n    }\n} bit1, bit2;\n\nll dp[MN];\n\nint main() {\n    scanf(\"%d %d %d\", &N, &E, &T);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    X[N] = E;\n\n    bit1.init();\n    bit2.init();\n\n    dp[N] = 0;\n    bit1.upd(N, dp[N] + 2 * X[N - 1] + X[N], 0, MN - 1, 1);\n    bit2.upd(N, dp[N] + X[N], 0, MN - 1, 1);\n\n    for(int i = N - 1; i >= 0; i--) {\n\n        int s = i + 1, e = N, p = -1;\n        while(s <= e) {\n            int m = (s + e)>>1;\n\n            if(T > 2 * (X[m - 1] - X[i])) {\n                p = m;\n                s = m + 1;\n            }\n            else e = m - 1;\n        }\n\n        dp[i] = bit1.quer(p + 1, N, 0, MN - 1, 1) - 3 * X[i];\n        dp[i] = min(dp[i], bit2.quer(i + 1, p, 0, MN - 1, 1) - X[i] + T);\n\n        bit1.upd(i, dp[i] + 2 * (i? X[i - 1] : 0) + X[i], 0, MN - 1, 1);\n        bit2.upd(i, dp[i] + X[i], 0, MN - 1, 1);\n    }\n\n    printf(\"%lld\", dp[0] + X[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int N, E, T;\n    cin >> N >> E >> T;\n    vector<int> X(N + 1, 0);\n    rep(i, 1, N + 1) cin >> X[i];\n    \n    \n    // i\n    vector<ll> dp(N + 1, 1LL << 60);\n    dp[0] = 0;\n    rep(i, 1, N + 1){\n        rep(j, i){\n            dp[i] = min(dp[i], dp[j] + (X[j + 1] - X[j]) + max(2 * (X[i] - X[j + 1]), T) + X[i] - X[j + 1]);\n        }\n    }\n    \n    ll ret = dp[N] + (E - X[N]);\n    \n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nlong long n,m,t,i,j,px[100005],dp[100005],qx[100005],ql,qr,s=0x1212121212121212ll;\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&m,&t);\n\tfz1(i,n)scanf(\"%lld\",&px[i]);\n\tdp[0]=m;qx[ql=qr=1]=0;\n\tfz1(i,n){\n\t\twhile(ql<=qr&&2*(px[i]-px[qx[ql]+1])>=t){\n\t\t\ts=min(s,dp[qx[ql]]-px[qx[ql]+1]*2);\n\t\t\tql++;\n\t\t}\n\t\tdp[i]=s+2*px[i];\n\t\tif(ql<=qr) dp[i]=min(dp[i],dp[qx[ql]]+t);\n\t\tqx[++qr]=i;\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 1e5 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long t, n, a[N], mn, dp[N], e, en, ps[N];\n\nvoid upd (int x) {\n    if (!mn)\n        mn = x;\n    long long ghabli = 2 * a[mn] + a[mn + 1] + dp[mn + 1];\n    long long jadid = 2 * a[x] + a[x + 1] + dp[x + 1];\n    if (jadid < ghabli)\n        mn = x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    en = n;\n    a[n + 1] = e;\n    for (int i = n; i; i--) {\n        while (2 * (a[en] - a[i]) > t) {\n            upd (en);\n            en--;\n        }\n        // ta en berim va bargardim\n        dp[i] = t + a[en + 1] - a[i] + dp[en + 1];\n        // ta min berim va bargardim\n        if (mn)\n            dp[i] = min (dp[i], 2 * a[mn] + a[mn + 1] + dp[mn + 1] - 3 * a[i]);\n    }\n    cout << dp[1] + a[1] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\nconst int N = 100005;\n\nint n, e, t, x[N];\nLL dp[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> e >> t;\n\tfor (int i = 1; i <= n; ++i) std::cin >> x[i];\n\tint k = 0; LL left_min = inf;\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (2 * (x[i] - x[k + 1]) > t) left_min = std::min(left_min, dp[k] - 2 * x[k + 1]), ++k;\n\t\tdp[i] = std::min(left_min + 2 * x[i], dp[k] + t);\n\t}\n\tstd::cout << dp[n] + e << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]))*(x-now);\n\t\t\t//cerr<<\"X\"<<x<<endl;\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t\t//cerr<<f[x]<<endl;\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\t//cerr<<\"X\"<<x<<endl;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t\t//cerr<<f[x]<<endl;\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t\t//cerr<<\"now\"<<now<<\" \"<<f[now]<<endl;\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[200010];\nint main() {\n    ll N, E, T; scanf(\"%lld%lld%lld\", &N, &E, &T);\n\n    vector<ll> S(N+1);\n    for(int i=0; i<N; i++) {\n        scanf(\"%lld\", &S[i+1]);\n    }\n\n    fill(dp, dp + N + 1, LONGINF);\n    dp[0] = 0;\n    vector<ll> f1(N+1, -LONGINF), f2(N+1, -LONGINF);\n    \n    ll ans = (S[1] - 0) + (E - S[N]), j = 0, d = 0;\n    for(int i=0; i<=N; i++) {\n        if(i == N) continue;\n        ll e = (i+1 < N ? S[i+2] - S[i+1] : 0);\n        while(j <= i and 2*(S[i+1] - S[j+1]) >= T) {\n            ll v = dp[j] - 3*S[j+1];\n            f1[j] = v - 3*d;\n            if(j > 0) chmin(f1[j], f1[j-1]);\n            j++;\n        }\n        {\n            ll v = dp[i] + T;\n            f2[i] = v;\n        }\n        /*\n        for(int j=0; j<=i; j++) {\n            ll d = S[i+1] - S[j+1];\n            ll c1 = dp[j] + 3*d, c2 = dp[j] + T + d;\n            chmin(dp[i+1], max(c1, c2) + e);\n        }\n        */\n        \n        // fprintf(stderr, \"min_v_1 = %lld, min_v_2 = %lld\\n\", min_v_1, min_v_2);\n        chmin(dp[i+1], min((j ? f1[j-1] + 3*(S[i+1]+d) : LONGINF), f2[j]) + e);\n        // fprintf(stderr, \"dp[%d] = %lld\\n\", i+1, dp[i+1]);\n        \n        d += S[i+2] - S[i+1];\n        // fprintf(stderr, \"d = %lld\\n\", d);\n        /*\n        c1 += 3*d;\n        c2 += d;\n        */\n        // fprintf(stderr, \"after: c1 = %lld, c2 = %lld\\n\", c1, c2);\n    }\n    ans += dp[N];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tlong long int loss=0;\n\t\t\tif ((x[i] - x[j + 1]) * 2 < t)\n\t\t\t\tloss = t - (x[i] - x[j+1]) * 2;\n\t\t\t//cout << dp[j] + x[i] - x[j] + x[i] - x[j + 1] + loss + x[i] - x[j + 1] << endl;\n\t\t\tres = min(res, dp[j] + x[i] - x[j] + x[i] - x[j + 1] + loss + x[i] - x[j + 1]);\n\t\t}\n\t\tdp[i] = res;\n\t}\n\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint l[N],x[N];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tl[n+1]=n;\n\tfor(int i=n;i>=1;i--){\n\t\tl[i]=min(i,l[i+1]);\n\t\twhile(l[i]>0&&2*(x[i]-x[l[i]])<=t) l[i]--;\n\t}\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(l[i]) dp[i]=min(dp[l[i]]+t,dp[l[i]-1]+2*(x[i]-x[l[i]]));\n\t\telse dp[i]=t;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2015\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint N, E;\nll a[MAXN], dp[MAXN], T;\nset<pii> s[2];\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i=0; i<N; i++) scanf(\"%d\", &a[i]);\n\t\n\tfor (int i=0; i<N; i++) dp[i] = oo;\n\tint cur = 0;\n//\ts[0].insert(mp(T, 0));\n\tfor (int i=0; i<N; i++) {\n\t\twhile (cur <= i && (a[i] - a[cur]) * 2 >= T) {\n\t\t\tint now = T - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\t\n\t\t\tint nxt = -2 * a[cur] - (cur != 0 ? a[cur - 1] : 0) + (cur != 0 ? dp[cur - 1] : 0);\n\t\t\tif (s[0].find(mp(now, cur)) != s[0].end()) {\n\t\t\t\ts[0].erase(mp(now, cur));\n\t\t\t\ts[1].insert(mp(nxt, cur));\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tdp[i] = a[i] - (i != 0 ? a[i-1] : 0) + (i != 0 ? dp[i-1] : 0) + T;\n//\t\tif (i == 1) cout << dp[1] << endl;\n\t\tif (!s[0].empty()) {\n\t\t\tint now = s[0].begin()->FI;\n\t\t\tdp[i] = min(dp[i], a[i] + now);\n\t\t}\n//\t\tif (i == 2) cout << dp[i] << endl;\n\t\tif (!s[1].empty()) {\n\t\t\tint now = s[1].begin()->FI;\n\t\t\tdp[i] = min(dp[i], 3 * a[i] + now);\t\t\t\n\t\t}\n\t\tint nxt = T - (i != 0 ? a[i - 1] : 0) + (i != 0 ? dp[i - 1] : 0);\n\t\ts[0].insert(mp(nxt, i));\n\t}\n//\tcout << dp[1] << endl;\n\tcout << E - a[N - 1] + dp[N - 1];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\n\ntypedef long long i64;\n\nconst int N = 100000 + 10;\nconst i64 INF = 1LL << 60;\n\nint n, t, e, x[N];\ni64 f[N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &e, &t);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n  std::multiset<i64> a, b;\n  for (int i = 1, j = 1; i <= n; ++i) {\n    b.insert(f[i - 1]);\n    for (; 2 * (x[i] - x[j]) > t; ++j) {\n      b.erase(b.find(f[j - 1]));\n      a.insert(f[j - 1] - 2 * x[j]);\n    }\n    f[i] = INF;\n    if (!a.empty()) f[i] = 2 * x[i] + *a.begin();\n    if (!b.empty()) f[i] = std::min(f[i], *b.begin() + t);\n  }\n  printf(\"%lld\\n\", f[n] + e);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n     \nusing namespace std;\n     \ntypedef long long ll;\ntypedef pair<int, int> pii;\n     \n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n     \nmt19937 rnd(chrono::steady_clock().now().time_since_epoch().count());\n\nconst int N = 2002;\nconst ll inf = (ll)1e18;\n\nll dp[N];\nll x[N];\n\nll ab(ll x){\n    return max(x,-x);\n}\n\nint main(){\n    fastIO;\n    int n;\n    ll w, e;\n    cin >> n >> e >> w;\n    for(int i = 1; i <= n; i ++ ){\n        cin >> x[i];\n        dp[i] = inf;\n        for(int j = 1; j <= i ; j ++ ){\n            dp[i] = min(dp[i], dp[j - 1] + (x[i] - x[j-1]) + max(w,2*(x[i]-x[j])));\n            /*\n            if(i == n){\n                if(dp[j - 1] + (x[i] - x[j-1]) + max(w,2*(x[i]-x[j])) == 15)\n                    cout << j << \" \";\n            }\n            */\n        }\n    }\n    cout << dp[n]+(e-x[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n\n\n/*\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 < t1){\n        l = mid;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans  << \"\\n\";\n*/\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> PII;\n\nint n, E, T, a[1<<17];\nlong long dp[1<<17], dp2[1<<17], mdp2 = (1<<30);\n\nint main() {\n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    dp2[0] = -2*a[1];\n    for (int i = 1, it = 1; i <= n; i++) {\n        while (2 * (a[i] - a[it]) > T) it++;\n        dp[i] = min(dp[it-1] + T, mdp2 + 2*a[i]);\n        dp2[i] = dp[i] - 2 * a[i+1];\n        mdp2 = min(mdp2, dp2[i-1]);\n    }\n    cout << dp[n] + E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\nconst int N = 1e5 + 10;\nint64 dp[N];\nint x[N];\nint64 c[N];\n\nvoid add(int x, int64 y, int n) {\n  for (; x <= n; x += x & -x) {\n    c[x] = min(c[x], y);\n  }\n}\n\nint64 query(int x) {\n  int64 ret = 1LL << 60;\n  for (; x; x -= x & -x) {\n    ret = min(ret, c[x]);\n  }\n  return ret;\n}\n\nint main() {\n  int n, E, t;\n  scanf(\"%d%d%d\", &n, &E, &t);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  x[n] = E;\n  fill(c, c + N, 1LL << 60);\n  dp[n] = 0;\n  int64 y = dp[n] + x[n] + 2 * x[n - 1];\n  add(1, y, n);\n  for (int i = n - 1; i >= 0; --i) {\n    int j = upper_bound(x + i, x + n, t / 2 + x[i]) - x;\n    int k = j - 1;\n    // trace(i, j, k);\n    dp[i] = x[k + 1] + dp[k + 1] + t - x[i];\n    if (j + 1 <= n) {\n      int64 cur = query(n - j);\n      dp[i] = min(dp[i], cur - 3LL * x[i]);\n    }\n    if (i > 0) {\n      y = dp[i] + x[i] + 2 * x[i - 1];\n      add(n + 1 - i, y, n);\n    }\n  }\n  // for (int i = 0; i < n; ++i) {\n  //   cout << i << \" \" << dp[i] << endl;\n  // }\n  printf(\"%lld\\n\", x[0] + dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,t,e,x,ab,a[200005],dp[200005];\nint main(){\n\tn=read(),e=read(),t=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\ta[n+1]=e;\n\tfor(int i=1;i<=n;i++){\n\t\twhile((a[i]-a[ab+1])*2>t)\n\t\t\tx=min(x,dp[ab]-2*a[ab+1]),ab++;\n\t\tdp[i]=min((ll)(1e18),dp[ab]+t);\n\t\tif(ab)dp[i]=min(dp[i],2*a[i]+x);\n\t}\n\tprintf(\"%lld\",dp[n]+e);\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[200010];\nint main() {\n    ll N, E, T; scanf(\"%lld%lld%lld\", &N, &E, &T);\n\n    vector<ll> S(N+1);\n    for(int i=0; i<N; i++) {\n        scanf(\"%lld\", &S[i+1]);\n    }\n\n    fill(dp, dp + N + 1, LONGINF);\n    dp[0] = 0;\n    vector<ll> c(N+1, -LONGINF);\n    multiset<ll> ms1, ms2;\n    \n    ll ans = (S[1] - 0) + (E - S[N]), j = 0, d = 0;\n    for(int i=0; i<=N; i++) {\n        if(i == N) continue;\n        ll e = (i+1 < N ? S[i+2] - S[i+1] : 0);\n        while(j <= i and 2*(S[i+1] - S[j+1]) >= T) {\n            ms2.erase(ms2.find(c[j]));\n            ll v = dp[j] + 3*(S[i+1] - S[j+1]);\n            ms1.emplace(v - 3*d);\n            c[j] = v - 3*d;\n            j++;\n        }\n        {\n            ll v = dp[i] + T;\n            // fprintf(stderr, \"#2: i = %d, v = %lld\\n\", i, v);\n            ms2.emplace(v - d);\n            c[i] = v - d;\n        }\n        /*\n        for(int j=0; j<=i; j++) {\n            ll d = S[i+1] - S[j+1];\n            ll c1 = dp[j] + 3*d, c2 = dp[j] + T + d;\n            chmin(dp[i+1], max(c1, c2) + e);\n        }\n        */\n\n        ll min_v_1 = (ms1.size() ? *ms1.begin() + 3*d : LONGINF);\n        ll min_v_2 = (ms2.size() ? *ms2.begin() + 1*d : LONGINF);\n        // fprintf(stderr, \"min_v_1 = %lld, min_v_2 = %lld\\n\", min_v_1, min_v_2);\n        chmin(dp[i+1], min(min_v_1, min_v_2) + e);\n        // fprintf(stderr, \"dp[%d] = %lld\\n\", i+1, dp[i+1]);\n        \n        d += S[i+2] - S[i+1];\n        // fprintf(stderr, \"d = %lld\\n\", d);\n        /*\n        c1 += 3*d;\n        c2 += d;\n        */\n        // fprintf(stderr, \"after: c1 = %lld, c2 = %lld\\n\", c1, c2);\n    }\n    ans += dp[N];\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll f[maxn],xx[maxn];\nll n,e,t;\nll store;//fj-2xj+1\nint main(){\n\tll b1,b2,b3,b4;\n\tll p;//定位\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\t\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\tfor (b1=1;b1<=n;b1++){\n\t\tf[maxn]=b1*t;\n\t}\n\tp=0;store=((ll)1<<60);\n\tfor (b1=1;b1<=n;b1++){\n\t\twhile (2*xx[p+1]<=2*xx[b1]-t){\n\t\t\tstore=min(store,f[p]-2*xx[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tf[b1]=min(2*xx[b1]+store,f[p]+t);\n\t\tf[b1]=min(f[b1-1]+t,f[b1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n \n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n \ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n \ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return;\n\tint mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n \ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; }\n\tint mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n \ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now];\n\tint mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n \nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]+(ll)X[i]-3LL*(ll)X[i]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) <= 0) l = mid+1;\n\t\t\telse r = mid-1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tfor (int j = r+1;j <= r+5&&j < i;++j)\n\t\t\tf[i] = min(f[j]+(ll)X[j+1]-3LL*(ll)X[j+1]-(ll)X[j]+3LL*(ll)X[i]+(ll)((ll)T-2LL*(X[i]-X[j+1])),f[i]);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nlong long solve2(int n, int E, int T, int *x) {\n    long long dp[n];\n    memset(dp, 0, sizeof dp);\n    for (int i = 0; i < n; i++) dp[i] = max(T, 2 * (x[i] - x[0]));\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] = min(dp[i], dp[j] + max(T, 2 * (x[i] - x[j+1])));\n        }\n    }\n    return E + dp[n-1];\n}\n\nlong long solve(int n, int E, int T, int *x) {\n    long long dp[n], b[n+1];\n    fill(dp, dp+n, 1LL<<60);\n    fill(b, b+n+1, 1LL<<60);\n    for (int i = 0, j = 0; i < n; i++) {\n        while (2 * (x[i] - x[j]) > T) j++;\n        // cerr << i << \" \" << j << endl;\n        dp[i] = min(dp[i], (j > 0 ? dp[j-1] : 0) + T);\n        dp[i] = min(dp[i], max(2LL * (x[i] - x[0]), (long long)T));\n        for (int k = j-1; k > 0; k -= k&-k)\n            dp[i] = min(dp[i], b[k] + 2 * x[i]);\n        for (int k = i+1; k <= n; k += k&-k)\n            b[k] = min(b[k], dp[i] - 2 * (i < n-1 ? x[i+1] : 0));\n    }\n    // for (int i = 0; i < n; i++) cerr << i << ' ' << dp[i] << endl;\n    return E + dp[n-1];\n}\n\nint main() {\n    int N, E, T; cin >> N >> E >> T;\n    int x[N]; for (int i = 0; i < N; i++) cin >> x[i];\n    long long ans = solve(N, E, T, x);\n    cout << ans << endl;\n\n    // long long expect = solve2(N, E, T, x);\n    // if (ans != expect) {\n    //     cerr << \"expect: \" << expect << \", got \" << ans << endl;\n    //     exit(1);\n    // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e5 + 7, INF = 1e18 + 7;\nint n, T, E, a[N], dp[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = INF;\n        for (int j = 1; j <= i; ++j) {\n            dp[i] = min(dp[i], dp[j - 1] + max(T, 2 * (a[i] - a[j])));\n        }   \n    }   \n    cout << dp[n] + E << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  if(n>2000) throw runtime_error(\"error\");\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n\n  vll dp(n+1, 1000000000000000000);\n\n\n  dp[0] = e;\n  for(int now=0;now<n;now++){\n    for(int d=0;d+now<n;d++){\n      ll ad = max(t, 2*(x[now+d] - x[now])); //追加される分\n      ll nxt = now + d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  //std::cout << dp[1] << '\\n';\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n} \nconst int N = 2e5+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, t, e, px[N];\nint64 f[N];\nint main()\n{\n    n = read(), e = read(), t = read();\n    if(n >= 2000) return 0; \n    for(int i = 1; i <= n; ++i) px[i] = read(); px[n+1] = e;\n    for(int i = 1; i <= n+1; ++i)\n    {\n        f[i] = f[i-1]+px[i]-px[i-1]+t*(i <= n);\n        for(int j = 1; j <= i; ++j)\n            if(2*(px[i]-px[j]) >= t) \n                f[i] = min(f[i], f[j-1]+px[j]-px[j-1]+3ll*(px[i]-px[j]));\n    }\n    printf(\"%lld\\n\", f[n+1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nint n,t,e;\nll ans;\nint xx[maxn];\ninline ll max(ll aa,ll bb){\n\tif (aa>bb)return aa;\n\telse return bb;\n}\nint main(){\n\tint b1,b2,b3,b4,b5;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%d\",&xx[b1]);\n\t}\n\txx[n+1]=e;\n\tans=xx[1];\n\tb1=1;\n\twhile (b1<=n){\n\t\tb2=b1;\n\t\twhile ((b2+1<=n)&&((ll)(xx[b2+1]-xx[b1])*2<(ll)t*(b2-b1+2))){\n\t\t\tb2++;\n\t\t}\n\t\tans+=max((ll)(xx[b2]-xx[b1])*2,(ll)t)+(ll)(xx[b2+1]-xx[b1]);\n\t\tb1=b2+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nsigned main() {\n    fio();\n    ll n, e, t;\n    cin >> n >> e >> t;\n\n    vl x(n + 1);\n    rep1 (i, n) cin >> x[i];\n\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    rep (i, n) {\n        if (dp[i] == INF) continue;\n        ll nx;\n        if (t % 2 == 0) nx = x[i + 1] + t / 2;\n        else nx = x[i + 1] + (t + 1) / 2;\n\n        auto itr = lower_bound(all(x), nx);\n        int ni = itr - x.begin();\n        if (ni <= n) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + (x[ni] - x[i + 1]) * 3);\n        }\n\n        ni--;\n        if (ni > i) {\n            chmin(dp[ni], dp[i] + (x[i + 1] - x[i]) + t + (x[ni] - x[i + 1]));\n        }\n    }\n    cout << dp[n] + e - x[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll x[111111];\nll dp[111111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll lmin=ll(1e18); \n\tdeque<pair<ll,ll> > rmin;\n\tint n; cin>>n; ll e,t; cin>>e>>t;\n\tx[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t}\n\tint ptr=1;\n\trmin.pb(mp(dp[0]-x[0]+t,1));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ptr<=i&&x[i]>=t/2+x[ptr]+1)\n\t\t{\n\t\t\tif(!rmin.empty()&&rmin.front().se==ptr) rmin.pop_front();\n\t\t\tlmin = min(lmin, dp[ptr-1]-2*x[ptr]-x[ptr-1]);\n\t\t\tptr++;\n\t\t}\n\t\tll best=lmin;\n\t\tif(!rmin.empty()) best=min(best,-2*x[i]+rmin.front().fi);\n\t\tdp[i]=best+3LL*x[i];\n\t\tll cost = dp[i]-x[i]+t;\n\t\twhile(!rmin.empty()&&rmin.back().fi>=cost) rmin.pop_back();\n\t\trmin.pb(mp(cost,i+1));\n\t}\n\tcout<<dp[n]+e-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(0, 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i],now_cost + 2 * inputs[i]);\n\t\twhile (next.empty() == false&&2 * (inputs[i] - inputs[next.top().second])> t) {\n\t\t\tnext.pop();\n\t\t}\n\t\tif (next.size() != 0) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\t/*\n\t\tfor (int q = now_back; q < i; ++q) {\n\t\t\tlong long cost = inputs[i] - inputs[q + 1] + t - (inputs[i] - inputs[q + 1]);\n\t\t\tdp[i] = min(dp[i], dp[q] + cost);\n\t\t}\n\t\t*/\n\t\tif(i != n-1)\n\t\tnext.push(make_pair(dp[i] - inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nconst int N = (int)1e5 + 9;\nconst ll inf = (ll)1e18;\n \nll dp[N];\nll x[N];\n \nint main(){\n    fastIO;\n    int n;\n    ll w, e;\n    cin >> n >> e >> w;\n    int p=1;\n    ll v1 = inf;\n    priority_queue<pii, vector<pii>, greater<pii>> kk;\n    for(int i = 1; i <= n; i ++ ){\n        cin >> x[i];\n        kk.push(mp(dp[i-1] - x[i - 1] + w, i));\n        dp[i] = inf;\n        while(2ll * (x[i] - x[p]) >= w){\n            v1 = min(v1, dp[p-1] - 2ll * x[p] - x[p - 1]);\n            p ++ ;\n        }\n        while(!kk.empty() && kk.top().se < p){\n            kk.pop();\n        }\n        dp[i] = min(dp[i], 3ll * x[i] + v1);\n        dp[i] = min(dp[i], x[i] + kk.top().fi);\n    }\n    cout << dp[n]+(e-x[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<long long> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        chmin(dp[i + 1], dp[i] + T);\n        for (int j = i; j < min(i + 30000, n); j++) {\n            chmin(dp[j + 1], dp[i] + 2 * (ds[j] - ds[i]) + max(0LL, T - 2 * (ds[j] - ds[i])));\n        }\n    }\n\n    cout << min(dp[n] + E, E + ds.back() * 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nconst int N=1e5+5;\nconst long long inf=2e12+7;\nlong long dp[N],dp1[4*N],lazy[4*N],pos[N];\nvoid upd(int idx,int l,int r,int lef,int rig,int val){\n\tif(l>rig||r<lef){\n\t\treturn;\n\t}\n\tif(l>=lef&&r<=rig){\n\t\tif(dp1[idx]<=val){\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif(dp1[idx]>val){\n\t\t\t\tlazy[idx]=val;\n\t\t\t\tdp1[idx]=val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif(lazy[idx]){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tif(lazy[2*idx]!=0){\n\t\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\t}\n\t\telse{\n\t\t\tlazy[2*idx]=lazy[idx];\n\t\t}\n\t\tif(lazy[2*idx+1]!=0){\n\t\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\t}\n\t\telse{\n\t\t\tlazy[2*idx+1]=lazy[idx];\n\t\t}\n\t\tlazy[idx]=0;\n\t}\n\tupd(2*idx,l,(l+r)/2,lef,rig,val);\n\tupd(2*idx+1,(l+r)/2+1,r,lef,rig,val);\n\tdp1[idx]=max(dp[2*idx],dp[2*idx+1]);\n}\nlong long getans(int idx,int l,int r,int pos1){\n\tif(l>pos1||r<pos1){\n\t\treturn inf;\n\t}\n\tif(l==r){\n\t\treturn dp1[idx];\n\t}\n\tif(lazy[idx]){\n\t\tdp1[2*idx]=min(lazy[idx],dp1[2*idx]);\n\t\tdp1[2*idx+1]=min(dp1[2*idx+1],lazy[idx]);\n\t\tif(lazy[2*idx]!=0){\n\t\t\tlazy[2*idx]=min(lazy[2*idx],lazy[idx]);\n\t\t}\n\t\telse{\n\t\t\tlazy[2*idx]=lazy[idx];\n\t\t}\n\t\tif(lazy[2*idx+1]!=0){\n\t\t\tlazy[2*idx+1]=min(lazy[2*idx+1],lazy[idx]);\n\t\t}\n\t\telse{\n\t\t\tlazy[2*idx+1]=lazy[idx];\n\t\t}\n\t\tlazy[idx]=0;\n\t}\n\treturn min(getans(2*idx,l,(l+r)/2,pos1),getans(2*idx+1,(l+r)/2+1,r,pos1));\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,end,time,i,j,k;\n\tcin>>n>>end>>time;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>pos[i];\n\t}\n\tmemset(dp,inf,sizeof(dp));\n\tmemset(dp1,inf,sizeof(dp1));\n//\tcout<<dp[1]<<endl;\n\tdp[0]=0;\n\tfor(i=0;i<n;i++){\n\t\tif(i!=0){\n\t\t\tdp[i]=min(dp[i],getans(1,1,n,i)+3*pos[i]);\n\t\t\t//cout<<dp[i]<<endl;\n\t\t}\n\t\tk=upper_bound(pos+1,pos+1+n,(time+2*pos[i+1])/2)-pos-1;\n\t\tdp[k]=min(dp[k],dp[i]+time+pos[k]-pos[i]);\n\t\tif(k!=n){\n\t\t\tupd(1,1,n,k+1,n,dp[i]-2*pos[i+1]-pos[i]);\n\t\t}\n\t}\n\tdp[n]=min(dp[n],getans(1,1,n,n)+3*pos[n]);\n\tcout<<dp[n]+end-pos[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n \n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n \n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mkp make_pair\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int MAXN = 100010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN], l, r;\nll dp[MAXN], pre;\npli q[MAXN*20];\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tl = r = 0;\n\tq[++r] = mkp(0, d[1]);\n\tpre = INF;\n\tint j = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tpli u = q[l+1];\n\t\twhile(2*(d[i]-u.snd) > T) {\n\t\t\tl++;\n\t\t\tif(l != r) u = q[l+1];\n\t\t\telse break;\n\t\t}\n\t\twhile(2*(d[i]-d[j+1]) >= T) {\n\t\t\tpre = min(pre, dp[j]-(d[j+1]<<1));\n\t\t\tj++;\n\t\t}\n\t\tif(l != r) dp[i] = min(dp[i], u.fst+T);\n\t\tdp[i] = min(dp[i], pre+(d[i]<<1));\n\t\twhile(l != r && dp[i] > q[r].fst) r--;\n\t\tq[++r] = mkp(dp[i], d[i+1]);\n\t\t//printf(\"%lld %lld\\n\", dp[i], pre);\n\t}\n\tprintf(\"%lld\\n\", dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define gcd            __gcd\n#define setbits(x)     __builtin_popcountll(x)\n#define zrobits(x)     __builtin_ctzll(x)\n#define mod            1000000007\n#define mod2           998244353\n#define maxe           *max_element\n#define mine           *min_element\n#define inf            1e18\n#define deci(x, y)      fixed<<setprecision(y)<<x\n#define w(t)           int t; cin>>t; while(t--)\n#define nitin          ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define PI             3.141592653589793238\nusing namespace std;\nint pre[2001][2001];\nint dp[2001][2001];\nint find_ans(int l,int n,vector<int>&v)\n{\n    if(dp[l][n]!=-1)\n        return dp[l][n];\n    int ans=pre[l][n];\n    for(int j=l;j<n;j++)\n    {\n        ans=min(ans,pre[l][j]+find_ans(j+1,n,v));\n    }\n    return dp[l][n]=ans;\n}\nint32_t main() {\n    nitin;\n    int n,e,t;\n    cin>>n>>e>>t;\n    vector<int>v(n+1,0);\n    for(int i=0;i<n;i++){\n        cin>>v[i+1];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            pre[i][j]=2*(v[j]-v[i])+(j-i+1)*max(t-2*(v[j]-v[i]),(int)0);\n            dp[i][j]=-1;\n        }\n    }\n    int ans=e;\n    ans+=find_ans(1,n,v);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 100050;\nint x[MAXN];\nll dp[MAXN];\n\nint N, E, T;\nll f(int i,int k) {\n\treturn x[i] + dp[k]-x[k] + max( T, 2*(x[i]-x[k+1]) );\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &x[i]);\n\tdp[0] = 0;\n\tdeque<int> deq;\n\tdeq.PB(0);\n\tfor(int i=1;i<=N;i++) {\n\t\tdp[i]=1ll*(E+T)*MAXN*10;\n\t\tdebug(\"[%d]%lld(%d) %lld(%d)--\\n\",SZ(deq), f(i, deq[0]),deq[0], f(i, deq[1]),deq[1]);\n\t\twhile(SZ(deq)>1 && f(i, deq[0])>=f(i, deq[1])) deq.pop_front();\n\t\tdebug(\"deq[0]=%d\\n\", deq[0]);\n\t\tdp[i]=f(i, deq[0]);\n\t\tdebug(\"[%d]%lld(%d) %lld(%d)-\\n\",SZ(deq), f(i,deq.back()),deq.back(), f(i, i),i);\n\t\twhile(SZ(deq)>=1 && f(i, deq.back())>=f(i, i)) deq.pop_back();\n\t\tdeq.PB(i);\n\t\t/*for(int k=0;k<i;k++)\n\t\t\tdp[i]=min(dp[i], x[i] + dp[k]-x[k] + max( T, 2*(x[i]-x[k+1]) ));*/\n\t\tdebug(\"i %d %lld\\n\", i, dp[i]);\n\t}\n\tcout << dp[N] + E-x[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nint main() {\n\tint n, E, T;\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tvector<int> X(n + 1);\n\tvector<ll> dp(n + 1);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &X[i]);\n\tint j = 0;\n\tll minv = 1LL << 60;\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (2 * X[j + 1] < 2 * X[i] - T) {\n\t\t\tminv = min(minv, dp[j] - 2 * X[j + 1]);\n\t\t\t++j;\n\t\t}\n\t\tassert(j < i);\n\t\tassert(X[i] - X[j + 1] <= T);\n\t\tdp[i] = min(minv + 2 * X[i], dp[j] + T);\n\t}\n\tll ans = dp[n] + E;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n#define LOCAL\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<typename Monoid>\nstruct SegmentTree{\n    typedef function<Monoid(Monoid,Monoid)> F;\n    int n;\n    F f;\n    Monoid id;\n    vector<Monoid> dat;\n    SegmentTree(int n_,F f,Monoid id):f(f),id(id){init(n_);}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,id);\n    }\n    void build(const vector<Monoid> &v){\n        for (int i=0;i<v.size();++i) dat[i+n]=v[i];\n        for (int i=n-1;i;--i) dat[i]=f(dat[i<<1|0],dat[i<<1|1]);\n    }\n    void update(int k,Monoid x){\n        dat[k+=n]=x;\n        while(k>>=1) dat[k]=f(dat[k<<1|0],dat[k<<1|1]);\n    }\n    Monoid query(int a,int b){\n        if (a>=b) return id;\n        Monoid vl=id,vr=id;\n        for (int l=a+n,r=b+n;l<r;l>>=1,r>>=1){\n            if (l&1) vl=f(vl,dat[l++]);\n            if (r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    Monoid operator[](int i){\n        return dat[i+n];\n    }\n    // most left position that meets condition \"check\"\n    template<typename C>\n    int find(int a,int b,const C &check,int k,int l,int r){\n        if (!check(dat[k])||r<=a||b<=l) return -1;\n        if (l+1==r) return k-n;\n        int vl=find(a,b,check,k<<1|0,l,(l+r)>>1);\n        if (~vl) return vl;\n        return find(a,b,check,k<<1|1,(l+r)>>1,r);\n    }\n    template<typename C>\n    int find(int a,int b,const C &check){\n        return find(a,b,check,1,0,n);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; ll E,T; cin >> N >> E >> T;\n    vector<ll> x(N+1); x[0]=0;\n    for (int i=1;i<=N;++i) cin >> x[i];\n    vector<ll> x_2(N+1);\n    for (int i=0;i<=N;++i) x_2[i]=x[i]*2;\n    vector<ll> dp(N+1,IINF),dp0(N+1);\n    SegmentTree<ll> seg(N+1,[](ll a,ll b){return min(a,b);},IINF);\n    dp[0]=0; dp0[0]=-2*x[1];\n    seg.update(0,0);\n    for (int i=1;i<=N;++i){\n        int pos=lower_bound(x_2.begin(),x_2.end(),x_2[i]-T)-x_2.begin()-2;\n        // debug(i,pos);\n        if (~pos) dp[i]=min(dp[i],dp0[pos]+3*x[i]);\n        dp[i]=min(dp[i],seg.query(max(0,pos+1),i)+T+x[i]);\n        if (i==N) continue;\n        dp0[i]=min(dp0[i-1],dp[i]-x_2[i+1]-x[i]);\n        seg.update(i,dp[i]-x[i]);\n    }\n    // cerr << dp << '\\n';\n    // cerr << dp0 << '\\n';\n    // for (int i=0;i<N+1;++i) cerr << seg[i] << (i+1==N+1?'\\n':' ');\n    cout << dp[N]+(E-x[N]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tstatic ll N,E,T;\n\tstatic ll x[100010];\n\tscanf(\"%lld%lld%lld\",&N,&E,&T);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\t\n\tstatic ll dp1[100010];\n\tstatic ll dp2[100010];\n\tfor(int i = 0 ; i < 100010 ; i ++){\n\t\tdp1[i] = dp2[i] = 1000000000000000000;\n\t}\n\tdp1[0] = 0;\n\tint r = 1;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tdp1[i-1] = min( dp1[i-1] , dp2[i-1] );\n\t\tdp2[i] = min( dp2[i] , dp2[i-1]+2*(x[i]-x[i-1]) );\n\t\twhile(r+1 <= N && 2*(x[r+1]-x[i]) <= T)r ++;\n\t\tdp1[r] = min( dp1[r] , dp1[i-1]+T );\n\t\tif(r+1 <= N)dp2[r+1] = min( dp2[r+1] , dp1[i-1]+2*(x[r+1]-x[i]) );\n\t}\n\tcout << min(dp1[N],dp2[N])+E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 100050;\nint x[MAXN];\nll dp[MAXN];\n\nint N, E, T;\nll f(int i,int k) {\n\treturn x[i] + dp[k]-x[k] + max( T, 2*(x[i]-x[k+1]) );\n}\nll cf(int i,int k) {\n\treturn x[i] + dp[k]-x[k] + 2*(x[i]-x[k+1]);\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &x[i]);\n\tdp[0] = 0;\n\tdeque<int> deq;\n\tdeq.PB(0);\n\tfor(int i=1;i<=N;i++) {\n\t\twhile(SZ(deq)>1 && f(i, deq[0])>=f(i, deq[1])) deq.pop_front();\n\t\tdebug(\" -- %d\\n\", deq[0]);\n\t\tdp[i]=f(i, deq[0]);\n\t\t//while(SZ(deq)>=1 && f(i, deq.back())>=f(i, i)) deq.pop_back();\n\t\tdebug(\"PB[%d] %lld %lld\\n\",deq.back(), cf(i, deq.back()), cf(i, i));\n\t\tif(cf(i, deq.back()) > cf(i, i)) {\n\t\t\tdeq.PB(i);\n\t\t}\n\t\tdebug(\"i %d %lld\\n\", i, dp[i]);\n\t}\n\tcout << dp[N] + E-x[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n \ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n \n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n \nconst int MaxN = 1e5 + 10;\n \nint N, E, T, x[MaxN];\n \nlong long f[MaxN];\n \nint find(int i)\n{\n\tint j = i;\n\tfor (int k = 18; ~k; --k)\n\t\tif ((j - (1 << k)) >= 0 && 2 * (x[i] - x[j - (1 << k) + 1]) <= T)\n\t\t\tj -= 1 << k;\n\treturn j;\n}\n\nstruct zkw\n{\n\tlong long s[MaxN << 2];\n\n\tint cnt;\n\n\tvoid build()\n\t{\n\t\tcnt = 1;\n\t\tfor (; cnt < N + 3; cnt <<= 1); --cnt;\n\t\tfor (int i = 1; i <= N + 1; ++i) s[cnt + i] = 1e18;\n\t\tfor (int i = cnt; i; --i) s[i] = 1e18;\n\t}\n\n\tvoid modify(int pos, long long x)\n\t{\n\t\t++pos;\n\t\tpos += cnt;\n\t\ts[pos] = min(s[pos], x);\n\t\tfor (pos >>= 1; pos; pos >>= 1) s[pos] = min(s[pos << 1], s[pos << 1 | 1]);\n\t}\n\n\tlong long query(int l, int r)\n\t{\n\t\tlong long ans = 1e18;\n\t\t++l, ++r;\n\t\tfor (l += cnt - 1, r += cnt + 1; l ^ r ^ 1; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (~l & 1) ans = min(ans, s[l ^ 1]);\n\t\t\tif (r & 1) ans = min(ans, s[r ^ 1]);\n\t\t}\n\t\treturn ans;\n\t}\n} s1, s2;\n\n\n \nint main()\n{\n\tgiii(N, E, T);\n\tfor (int i = 1; i <= N; ++i) gi(x[i]), f[i] = 1e18;\n\ts1.build(), s2.build();\n\ts1.modify(0, -2 * x[1]);\n\ts2.modify(0, 0);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint k = find(i);\n\t\tf[i] = min(f[i], s1.query(0, k - 1) + 3LL * x[i]);\n\t\t/*for (int j = 0; j < k; ++j)\n\t\t\tf[i] = min(f[i], 3LL * x[i] + f[j] - x[j] - 2 * x[j + 1]));*/\n\t\tf[i] = min(f[i], s2.query(k, i - 1) + x[i] + T);\n\t\ts1.modify(i, f[i] - x[i] - 2 * x[i + 1]);\n\t\ts2.modify(i, f[i] - x[i]);\n\t\t/*for (int j = k; j < i; ++j)\n\t\t\tf[i] = min(f[i], f[j] + x[i] - x[j] + T);*/\n\t}\n\t//cerr << f[2] << endl;\n\tf[N] += E - x[N];\n\tprintf(\"%lld\\n\", f[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 1E5 + 100;\nconst LL INF = 1E18;\nint x[N];\nLL f[N];\n\nint main() {\n    int n, e, t;\n    deque<pair<LL, int>> q;\n    LL past_min = INF;\n    cin >> n >> e >> t;\n    FOR (i, 1, n + 1) cin >> x[i];\n    FOR (i, 1, n + 1) {\n        while (!q.empty() && (x[i] - x[q.front().second]) * 2 > t) {\n            int j = q.front().second;\n            past_min = min(past_min, f[j - 1] - 2LL * x[j] - x[j - 1]);\n            q.pop_front();\n        }\n\n        LL val = f[i - 1] + t - x[i - 1];\n        while (!q.empty() && q.back().first >= val) q.pop_back();\n        q.emplace_back(val, i);\n\n        f[i] = min(q.front().first + x[i], past_min + 3LL * x[i]);\n\n        // dbg(i, f[i]);\n    }\n    cout << f[n] + (e - x[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n */\n#include <cstdio>\n#include <iostream>\n\n#define INF 1000000000000000LL\n\nusing namespace std;\ntypedef long long ll;\n\nll x[100005];\nll dp[100005];  // dp[i]: minimum time until the exit\n                 // after you get coin at i-th place and you haven't feed to the rest yet.\n\nint main(){\n    //freopen(\"d2.in\", \"r\", stdin);\n    int N, E, T;\n    scanf(\"%d %d %d\", &N, &E, &T);\n    x[0] = 0;\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%lli\", &x[i]);\n    }\n    dp[N] = E - x[N];\n    //cout << \"N = \" << N << \", dp[N]= \" << dp[N] << endl;\n    for (int i = N - 1; i >= 0; --i) {\n        dp[i] = INF;\n        for (int j = i + 1; j <= N; ++j) {\n            if ((2 * (x[j] - x[i+1])) > T) {\n                dp[i] = min(dp[i], dp[j] + 3 * (x[j] - x[i+1]) + (x[i+1] - x[i]));\n            } else {\n                dp[i] = min(dp[i], dp[j] + (x[j] - x[i+1]) + T + (x[i+1] - x[i]));\n            }\n        }\n        //cout << \"i = \" << i << \", dp[i]= \" << dp[i] << endl;\n    }\n\n    printf(\"%lli\\n\", dp[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int64 i = 0; i < (int64)(n); i++)\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nint main()\n{\n  int N, E, T, X[100001] = {};\n\n  cin >> N >> E >> T;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n  X[N] = E;\n\n  vector< int64 > dp1(N + 1, INF);\n  dp1[0] = X[0]; // dp1[0]まで訪問済み\n  for(int i = 1; i <= N; i++) { // dp1[i]まで訪問済み\n    for(int j = i - 1; j >= 0; j--) {\n      int64 need = dp1[j] + (X[i - 1] + X[i - 1] - X[j] - X[j]);\n      need = max(need, dp1[j] + T);\n      dp1[i] = min(dp1[i], need + X[i] - X[j]);\n    }\n  }\n\n  cout << dp1.back() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 1e5 + 7;\nint n, E, T;\nLL f[N], x[N];\nint q[N], hd = 1, tl;\nint main() {\n#ifdef fwat\n#endif\n\tn = gi(), E = gi(), T = gi();\n\tif(n > 2000) return puts(\"gg\"), 0;\n\tmemset(f, 0x3f, sizeof f); f[0] = 0;\n\trep(i, 1, n) x[i] = gi();\n\tLL mi = 1e18;\n\tq[++tl] = 0;\n\tfor(int i = 1, j = 0; i <= n; ++i) {\n\t\tfor(; j < i && 2 * (x[i] - x[j + 1]) >= T; ++j) Min(mi, f[j] - 2 * x[j + 1]);\n\t\tMin(f[i], mi + 2 * x[i]);\n\t\twhile(hd <= tl && 2 * (x[i] - x[q[hd] + 1]) >= T) ++hd;\n\t\tif(hd <= tl)\n\t\t\tMin(f[i], f[q[hd]] + T);\n\t\tfor(; hd <= tl && f[i] <= f[q[tl]]; --tl);\n\t\tq[++tl] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, E, T;\n\tcin >> N >> E >> T;\n\n\tint X[100000];\n\trep(i, N) cin >> X[i];\n\tint D[100000];\n\trep1(i, N - 1) D[i] = X[i] - X[i - 1];\n\n\tmap<ll, ll> dp[100001];\n\tdp[0][0] = E;\n\n\n\trep1(i, N - 1) {\n\t\tdp[i][0] = 1e18;\n\t\tll besuto = 1e18;\n\t\tfor (auto itr = dp[i - 1].begin(); itr != dp[i - 1].end(); itr++) {\n\t\t\tll saizu = (*itr).first;\n\t\t\tll jikan = (*itr).second;\n\t\t\tif (besuto > jikan) {\n\t\t\t\tbesuto = jikan;\n\t\t\t\t\tdp[i][0] = min(dp[i][0], jikan + max(T, saizu));\n\t\t\t\t\tif (saizu < T) dp[i][saizu + D[i] * 2] = jikan;\n\t\t\t}\n\t\t}\n\t}\n\n\tll kotae = 1e18;\n\tfor (auto itr = dp[N - 1].begin(); itr != dp[N - 1].end(); itr++) {\n\t\tll saizu = (*itr).first;\n\t\tll jikan = (*itr).second;\n\t\tkotae = min(kotae, jikan + max(T, saizu));\n\t}\n\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e5+50;\nint n,E,T;\nint xc[N];\nLL f[N];\nint main() {\n\tn=rd(), E=rd(), T=rd();\n\tfor(int i=1;i<=n;i++) xc[i]=rd();\n\txc[n+1]=E;\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0; f[1]=xc[1];\n\tfor(int i=2,j=1;i<=n;i++) {\n\t\twhile(2*(xc[i]-xc[j])>=T) ++j;\n\t\tj--;\n\t\tf[i]=min(f[i],f[i-1]+T+xc[i]-xc[i-1]);\n\t\tf[i+1]=f[j]+2*(xc[i]-xc[j])+xc[i+1]-xc[j];\n\t\t++j;\n\t} cout<<min(f[n+1],f[n]+T+xc[n+1]-xc[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0;\n\tdp[1] = A[1] + T;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\t//for(int j = 0; j < i; ++ j)\n\t\twhile(cur + 1 < i && calc(cur, i) >= calc(cur + 1, i)) ++ cur;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 1000; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t}\n\t\tdp[i] = min(calc(cur, i), dp[i]);\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\n\nint n,E,T;\nll x[MAXN];\nll dp[MAXN+1]; // dp[i]=minimum time to have collected all coins for i bears and be at the last of them (x[i-1]) (and not haven given any candy to other bears)\n// dp[i]=min(x[j]-x[j-1]+min(dp[j]+max(2*(x[i-1]-x[j]),T)+x[i-1]-x[j],j=0..i-1)\n// dp[i]=min(3*x[i-1]+min(dp[j]-2*x[j]-x[j-1],j=0..jwait-1),x[i-1]+min(dp[j]+T-x[j-1],j=jwait..i-1))\n// dp[i+1]=min(3*x[i]+min(dp[j]-2*x[j]-x[j-1],j=0..jwait-1),x[i]+min(dp[j]+T-x[j-1],j=jwait..i))\nll mna[MAXN+1]; // mna[i]=min(dp[j]-2*x[j]-x[j-1],j=0..i-1)\n// mna[i+1]=min(mna[i],dp[i]-2*x[i]-x[i-1])\n\n\n\nvoid run() {\n\tscanf(\"%d%d%d\",&n,&E,&T); REP(i,n) scanf(\"%lld\",&x[i]);\n\tdp[0]=0; mna[0]=LLONG_MAX; int jwait=0;\n\tREP(i,n) {\n\t\twhile(2*(x[i]-x[jwait])>T) ++jwait;\n\t\tll a=mna[jwait]==LLONG_MAX?LLONG_MAX:3*x[i]+mna[jwait];\n\t\tll b=x[i]+dp[jwait]+T-(jwait==0?0:x[jwait-1]);\n\t\tdp[i+1]=min(a,b);\n\t\tmna[i+1]=min(mna[i],dp[i]-2*x[i]-(i==0?0:x[i-1]));\n\t\t//printf(\"dp[%d]=%lld, mna[%d]=%lld [%lld vs %lld]\\n\",i+1,dp[i+1],i+1,mna[i+1],a,b);\n\t}\n\tll ret=dp[n]+E-x[n-1]; printf(\"%lld\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nclass starry_sky_tree{\npublic:\n  static const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n  using Int = long long;\n  Int segMin[2 * MAX_SIZE - 1], segAdd[2 * MAX_SIZE - 1];\n\n  starry_sky_tree(){\n    fill(segMin, segMin + 2*MAX_SIZE-1, 0);\n    fill(segAdd, segAdd + 2*MAX_SIZE-1, 0);\n  }\n\n  //区間[a, b)に値xを加算する.\n  void add(int a, int b, Int x, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return; //もし交差しない区間であれば終える.\n    \n    if (a <= l && r <= b){ //もし今みている区間[l, r)が[a, b)に完全に内包されていれば\n      segAdd[k] += x;  //区間[l, r)にkを加算する.\n      return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子の区間に(必要があれば)xを加算する.\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃\n\n    //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である.一様に加算される値は更新しなくて良い.\n    segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n  }\n\n  Int getMin(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return (1ll<<57);\n    \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]); //完全に内包されていれば,その区間の最小値を返す.\n    \n    Int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2); //子の区間の最小値を求める.\n    Int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r); //子の区間の最小値を求める\n    \n    return (min(left, right) + segAdd[k]); //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である (大切なので2回書きました!!)\n    \n  }\n};\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  starry_sky_tree a, b;\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      j++;\n    }\n    if(j) dp[i+1] = min(dp[i+1], a.getMin(0, j));\n    dp[i+1] = min(dp[i+1], t+ b.getMin(j, i+1));\n\n    a.add(0,i+1, 2*(x[i+1]-x[i]));\n    a.add(i+1, i+2, dp[i+1]);\n    \n    b.add(i+1, i+2, dp[i+1]);\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define int ll\nll t[1 << 20];\nstatic ll dp[1 << 20];\nstatic int pos[1 << 20];\nstatic int s[1 << 20];\nint n,S,T;\nvoid U(int p,int u,int poz,ll val,int node)\n{\n    if (p == u)\n        t[node] = val;\n    else\n    {\n        int m = (p + u) / 2;\n        if (poz <= m)\n            U(p,m,poz,val,node << 1);\n        else\n            U(m + 1,u,poz,val,node << 1 | 1);\n        t[node] = min(t[node << 1],t[node << 1 | 1]);\n    }\n}\nvoid update(int poz,ll val)\n{\n    U(1,n + 1,poz + 1,val,1);\n}\nll query(int p,int u,int l,int r,int node)\n{\n    if (l > r) return (ll)(1e18);\n    if (l <= p && u <= r)\n        return t[node];\n    int m = (p + u) / 2;\n    ll ans = 1e18;\n    if (l <= m)\n        ans = min(ans,query(p,m,l,r,node << 1));\n    if (m+1<=r)\n        ans = min(ans,query(m+1,u,l,r,node << 1 | 1));\n    return ans;\n}\nll query(int l,int r)\n{\n    return query(1,n + 1,l + 1,r + 1,1);\n}\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    fi>>n>>S>>T;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    pos[0] = 0;\n    for (int i = 0;i <= n;++i)\n        update(i,(ll)(1e18));\n    for (int i = 1;i <= n;++i)\n    {\n        pos[i] = pos[i - 1];\n        while (T < 2ll * (s[i] - s[pos[i]])) ++pos[i];\n    }\n    dp[0] = 0;\n    update(0,dp[0] - s[0] + T);\n    for (int i = 1;i <= n;++i)\n        --pos[i];\n    for (int i = 1;i <= n;++i)\n        {\n            dp[i] = 1e18;\n            for (int j = pos[i - 1];j < pos[i];++j)\n                update(j,dp[j] - s[j] - 2ll * s[j + 1]);\n            dp[i] = min(query(0,pos[i] - 1) + 3ll * s[i],1ll * s[i] + query(pos[i],i - 1));\n            update(i,dp[i] - s[i] + T);\n        }\n    fo << dp[n] + S - s[n] << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\n\ntemplate<typename F>struct NoOp{void setup(ui, F){}void op(F&p,F n,ui,ui){p=n;}void down(F&,F&,F&,ui,ui) {}};\n\ntemplate<typename F,typename SetOp,typename PowerOp>struct Lazy{\n    void setup(ui s,F def){this->def=def;this->s=s;L=new F[s]();fill(L,L+s,def);}\n    void down(F&u,F&l,F&r,ui i,ui s){op(l,L[i],i<<1,s>>1);op(r,L[i],i<<1|1,s>>1);L[i]=def;}\n    void op(F&p,F n,ui i,ui s){p=sop(p,pop(n,s));if(i<this->s)this->L[i]=sop(this->L[i],n);}\n    SetOp sop;PowerOp pop;F*L;ui s;F def;\n};\n\ntemplate <typename F, typename CombineOp, typename ModifyOp = NoOp<F>> struct SegTree {\n\tvoid setup(ui s, F def) {\n\t\tn = 1<<logceil(s);\n\t\tT = vector<F>(2*n, def);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tvoid setup(vector<F> & data, F def = F()) {\n\t\tn = 1<<logceil(data.size());\n\t\tT = vector<F>(2*n, def);\n\t\tcopy(data.begin(), data.end(), T.begin() + n);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tinline void put(ui x, F n) { put(x, x, n); }\n\tinline void put(ui from, ui to, F v) { put2(from, to+1, v, 1, n); }\n\tinline F get(ui x) { return get(x, x); }\n\tinline F get(ui from, ui to) { return get2(from, to+1, 1, n); }\n\n\tvoid put2(ui from, ui to, F v, ui i, ui s) {\n\t\tif (from == 0 && to == s) { mop.op(T[i], v, i, s); return; }\n\t\tmop.down(T[i], T[i<<1], T[i<<1|1], i, s);\n        s>>=1;i<<=1;\n        if (to <= s) { put2(from, to, v, i, s); }\n        else if (from >= s) { put2(from-s, to-s, v, i|1, s); }\n        else {\n            put2(from, s, v, i, s);\n            put2(0, to-s, v, i|1, s);\n        }\n\t\tT[i>>1] = cop(T[i], T[i|1]);\n\t}\n\n\tF get2(ui from, ui to, ui i, ui s) {\n        while (true) {\n            if (from == 0 && to == s) return T[i];\n            mop.down(T[i], T[i << 1], T[i << 1 | 1], i, s);\n            s >>= 1;i <<= 1;\n            if (to > s) {\n                to -= s;\n                if (from >= s) { from -= s; i|=1; }\n                else return cop(get2(from, s, i, s), get2(0, to, i|1, s));\n            }\n        }\n    }\n\n\tui n;\n\tvector<F> T;\n\tCombineOp cop;\n    ModifyOp mop;\n};\n\n\ntemplate <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};\ntemplate <typename F> struct MinOp { F operator()(F a, F b) { return std::min(a,b); }};\ntemplate <typename F> struct MaxOp { F operator()(F a, F b) { return std::max(a,b); }};\ntemplate <typename F> struct MultiplyOp { F operator()(F a, F b) { return a*b; }};\ntemplate <typename F> struct MultOp { F operator()(F a, ui b) { return a*b; }};\ntemplate <typename F> struct IdempOp { F operator()(F a, ui b) { return a; }};\ntemplate <typename F> struct InverseOp { F operator()(F a, F b) { return b?b-a:a; }};\n\ntemplate<typename T> using AddSumTree = SegTree<T, AddOp<T>, Lazy<T, AddOp<T>, MultOp<T>>>;\ntemplate<typename T> using AddMaxTree = SegTree<T, MaxOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AddMinTree = SegTree<T, MinOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMinTree = SegTree<T, MinOp<T>, Lazy<T, MinOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMaxTree = SegTree<T, MaxOp<T>, Lazy<T, MaxOp<T>, IdempOp<T>>>;\ntemplate<typename T> using XorTree = SegTree<T, AddOp<T>, Lazy<T, InverseOp<T>, MultOp<T>>>;\n\ntemplate<typename T> using SetMinTree = SegTree<T, MinOp<T>>;\ntemplate<typename T> using SetMaxTree = SegTree<T, MaxOp<T>>;\ntemplate<typename T> using SetMulTree = SegTree<T, MultiplyOp<T>>;\n\n\nclass DShikAndGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, E, T; cin >> N >> E >> T;\n        vector<ll> X(N+1, 0);\n        for (int i = 0; i < N; ++i) cin >> X[i+1];\n        vector<ll> D(N+1, 0), W(N+1, 1e18);\n        SetMinTree<ll> F, G;\n        F.setup(W, 0); G.setup(W, 0);\n        for (int i = 1; i <= N; ++i) {\n            F.put(i-1, D[i-1] - X[i-1] - 2 * X[i]);\n            G.put(i-1, D[i-1] - X[i-1]);\n            D[i] = 1e18;\n            int z = bsl(0, i-1, [&](int t) { return 2*(X[i] - X[t+1]) < T; });\n            if (z != i) D[i] = X[i] + T + G.get(z, i-1);\n            if (z != 0) D[i] = min(D[i], F.get(0, z-1) + 3 * X[i]);\n        }\n\n        cout << D[N] + E - X[N] << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDShikAndGame solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long inf = 1e17 + 5;\nint a[N];\nlong long dp[N];\n\n \nint main () \n{\n    int n, E, T; \n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; i++) \n    {\n        cin >> a[i];\n    }\n    memset(dp, 127, sizeof dp);\n    dp[0] = 0;\n    int pos = 0;\n    long long minj = inf;\n    for (int i = 1; i <= n; i++) \n    {\n        while (2 * (a[i] - a[pos + 1]) >= T) \n        {\n            minj = min(minj, dp[pos] - 2 * a[pos + 1]);\n            pos++;\n        }\n        dp[i] = minj + 2 * a[i];\n        if (pos != i)\n        { \n            dp[i] = min(dp[i], dp[pos] + T);\n        }\n    }\n    cout << dp[n] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mkp make_pair\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int MAXN = 100010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN], l, r;\nll dp[MAXN], pre;\npli q[MAXN*20];\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tl = r = 0;\n\tq[++r] = mkp(0, d[1]);\n\tpre = INF;\n\tint j = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tpli u = q[l+1];\n\t\twhile(2*(d[i]-u.snd) > T) {\n\t\t\tl++;\n\t\t\tif(l != r) u = q[l+1];\n\t\t\telse break;\n\t\t}\n\t\twhile(2*(d[i]-d[j+1]) > T) {\n\t\t\tpre = min(pre, dp[j]-(d[j+1]<<1));\n\t\t\tj++;\n\t\t}\n\t\tif(l != r) dp[i] = u.fst+T;\n\t\tdp[i] = min(dp[i], pre+(d[i]<<1));\n\t\twhile(l != r && dp[i] > q[r].fst) r--;\n\t\tq[++r] = mkp(dp[i], d[i+1]);\n\t\t//printf(\"%lld %lld\\n\", dp[i], pre);\n\t}\n\tprintf(\"%lld\\n\", dp[n]+e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector< vector<int> > vvi;\ntypedef vector<ll> vl;\ntypedef vector< vector<ll> > vvl;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n#define forv(i, v) forn(i, v.size())\n#define all(v) v.begin(), v.end()\n#define mp make_pair\n#define pb push_back\n\nconst ll INF = 1e18;\n\nint main() {\n#ifdef NEREVAR_PROJECT\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    ll t, e;\n    cin >> n >> e >> t;\n    vl x(n);\n    forn(i, n) {\n        scanf(\"%lld\", &x[i]);\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    vl minCF(n + 1, INF);\n    ll minC = INF;\n    forn(i, n) {\n        ll pos = i == 0 ? 0 : x[i - 1];\n        \n        minC = min(minC, minCF[i + 1]);\n        dp[i + 1] = min(dp[i + 1], x[i] * 3 + minC);\n        \n        int lf = i, rg = n - 1;\n        while (rg - lf > 1) {\n            int mid = (lf + rg) / 2;\n            if ((x[mid] - x[i]) * 2 <= t) {\n                lf = mid;\n            } else {\n                rg = mid - 1;\n            }\n        }\n        \n        int L = max(i, lf - 20);\n        int R = min(n, rg + 20);\n        \n        minCF[R] = min(minCF[R], x[i] - pos - x[i] * 3);\n        \n        for (int j = L; j < R; j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n    }\n    cout << dp[n] + e - x[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,arr[MAX],dp[MAX],tot[MAX],pre[MAX],nxt[MAX];\n\n/*int cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t{\n\t\tif(ok[ind][A] and ok[ind][A+1])\n\t\t\tcontinue;\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\t}\n\treturn dp[ind];\n}*/\n\nvoid solve()\n{\n\tdp[N]=T+E-arr[N];\n\t//tot[N]=3*arr[N]+T-arr[N];\n\tfor(int A=N-1;A>=1;A--)\n\t{\n\t\tdp[A]=pre[A]+arr[nxt[A]+1]-arr[nxt[A]]+dp[nxt[A]+1];\n\t//\tif(nxt[A]<N)\n\t//\t\tdp[A]=min(dp[A],-3*arr[A]+tot[nxt[A]+1]);\n\t//\ttot[A]=min(tot[A+1],3*arr[A]+arr[A+1]-arr[A]+dp[A+1]);\n\t\tfor(int B=nxt[A]+1;B<=N;B++)\n\t\t\tdp[A]=min(dp[A],3*(arr[B]-arr[A])+arr[B+1]-arr[B]+dp[B+1]);\n\t}\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tfor(int A=1;A<=N;A++)\n\t{\n\t\tint low=A,high=N,mid,res=A;\n\t\twhile(low<=high)\n\t\t{\n\t\t\tmid=(low+high)/2;\n\t\t\tif(T-2*(arr[mid]-arr[A])>0)\n\t\t\t{\n\t\t\t\tres=mid;\n\t\t\t\tlow=mid+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh=mid-1;\n\t\t}\n\t\tnxt[A]=res;\n\t\tpre[A]=T-2*(arr[res]-arr[A])+3*(arr[res]-arr[A]);\n\t}\n\tsolve();\n\tcout<<arr[1]+dp[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\ntypedef long long ll;\n\nint n, e, t, x[100005];\nll dp[100005];\n\nnamespace SegTree {\n\tll mn[100005 << 2];\n\t\n\tvoid init() { memset(mn, 0x3f, sizeof mn); }\n\t\n\tvoid modify(int k, int l, int r, int pos, ll val) {\n\t\tif (l == r) {\n\t\t\tmn[k] = val; return;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (pos <= mid) modify(k << 1, l, mid, pos, val);\n\t\telse modify(k << 1 | 1, mid + 1, r, pos, val);\n\t\tmn[k] = std::min(mn[k << 1], mn[k << 1 | 1]);\n\t}\n\t\n\tll query(int k, int l, int r, int L, int R) {\n\t\tif (L > R) return 0x3f3f3f3f3f3f3f3fll;\n\t\tif (L <= l && r <= R) return mn[k];\n\t\tint mid = (l + r) >> 1;\n\t\tll res = 0x3f3f3f3f3f3f3f3fll;\n\t\tif (L <= mid) res = std::min(res, query(k << 1, l, mid, L, R));\n\t\tif (mid < R) res = std::min(res, query(k << 1 | 1, mid + 1, r, L, R));\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", x + i);\n\t\n\tSegTree::init();\n\t\n\tint l = 0;\n\tSegTree::modify(1, 0, n, 0, 0);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile ((x[i] - x[l + 1]) * 2 >= t) {\n\t\t\tSegTree::modify(1, 0, n, l, dp[l] - x[l + 1] * 2);\n\t\t\t++l;\n\t\t}\n\t\tdp[i] = std::min(t + SegTree::query(1, 0, n, l, i - 1), \n\t\t\t\t\t\t x[i] * 2 + SegTree::query(1, 0, n, 0, l - 1));\n\t\tSegTree::modify(1, 0, n, i, dp[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define fs first\n#define sc second\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)x.size()\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst ll INFTY=1e18;\n\nint main() {\n    ll i, n, e, t, l, r, m;\n    scanf(\"%lld%lld%lld\", &n, &e, &t);\n    vll x(n+2);\n    for(i=1; i<=n; i++) scanf(\"%lld\", &x[i]);\n    x[n+1]=e;\n    vll opt(n+2), dp(n+2);\n    dp[n+1]=INFTY;\n    for(i=n; i>=1; i--) {\n        l=i+1; r=n+1;\n        while(l<r) {\n            m=(l+r)/2;\n            if(2*(x[m]-x[i])<=t) l=m+1;\n            else r=m;\n        }\n        opt[i]=min(t+x[l]-x[i]+opt[l], -3*x[i]+dp[l]);\n        dp[i]=min(2*x[i]+x[i+1]+opt[i+1], dp[i+1]);\n    }\n    printf(\"%lld\\n\", x[1]+opt[1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes, macros {{{\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <functional>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n#define rep(i, s, e)    for (int i = (s); i < (int)(e); i++)\n//#define PB(e) push_back(e)\n//#define MP(a, b) make_pair(a, b)\n\n// for debug\n#define kita            cout << \"kita\\n\"\n#define print2(i, n)    cout << (i) << \": \" << (n) << endl\n#define print3(i, j, n)     cout << \"(\" << (i) << \", \" << (j) << \") : \" << (n) << endl\n#define print4(i, j, n, m)  cout << \"(\" << (i) << \", \" << (j) << \") : \" << (n) << \", \" << (m) << endl\n#define print_mat(mat, h, w) for(int i=0;i<(h);i++){for(int j=0;j<(w);j++){cout << mat[i][j] << \" \";}cout << endl;}\n \ntypedef long long ll;\ntypedef unsigned long long ull; // }}}\n\nll N, E, T, ans;\nll x[100005];\n\nint main(){\n    cin >> N >> E >> T;\n    ans = E;\n    for(ll i=0;i<N;i++){\n        cin >> x[i];\n    }\n    for(ll i=0;i<N;i++){\n        for(ll j=i+1;j<N;j++){\n            if(x[j]-x[i] > T){\n                i=j;\n                break;\n            }\n            if(j == N-1){\n                i=j;\n            }\n        }\n        ans += T*2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define lowbit(x) (x&-x)\nusing namespace std;\nconst int MAXN = 100005;\ntypedef long long ll;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nll t,e,n,d[MAXN];\nll c[MAXN],f[MAXN];\ninline void update(int x,ll v)\n{\n\tfor(;x<=n;x+=lowbit(x))\n\t\tc[x]=min(c[x],v);\n}\ninline ll query(int x)\n{\n\tll ret=INF;\n\tfor(;x;x-=lowbit(x))\n\t\tret=min(ret,c[x]);\n\treturn min(ret,(ll)-2*d[1]);\n}\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",d+i);\n\tint p=0;\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(2*(d[i]-d[p+1])>=t)++p;\n\t\tif(p>0)f[i]=min(f[i],query(p-1)+2*d[i]);\n\t\tf[i]=min(f[i],f[p]+t);\n\t\tupdate(i,f[i]-2*d[i+1]);\n\t}\n\tcout<<f[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 1e5 + 5;\n\nint E, n, T, i, j, x[Nmax];\nll dp[Nmax], A[Nmax], B[Nmax];\ndeque<int> dq;\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> E >> T;\n    for(i=1; i<=n; ++i) cin >> x[i];\n\n    for(i=1; i<=n; ++i)\n    {\n        A[i] = min(A[i-1], dp[i-1] - x[i-1] - 2 * x[i]);\n        B[i] = dp[i-1] - x[i-1];\n\n        while(j < i && 2 * (x[i] - x[j+1]) > T) ++j;\n        while(dq.size() && B[dq.back()] >= B[i]) dq.pop_back();\n        dq.push_back(i);\n        while(dq.size() && dq.front() <= j) dq.pop_front();\n\n        dp[i] = x[i] + min(dq.size() ? T + B[dq.front()] : (1LL<<60), j ? A[j] + 2 * x[i] : (1LL<<60));\n    }\n\n    cout << dp[n] + E - x[n] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main() {\n  int N, E, T;\n  scanf(\"%d%d%d\", &N, &E, &T);\n  LL bears[N+1];\n  bears[0] = 0;\n  for (int i = 0; i < N; i++)\n    scanf(\"%lld\", &bears[i + 1]);\n\n  N++;\n  LL DP[N+1][N+1];\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      DP[i][j] = 0xffffffffffffLL;\n    }\n  }\n\n  DP[0][0] = 0;\n\n  for (int j = 0; j < N; j++) {\n    for (int i = 1; i < N; i++) {\n      DP[j][i] = min(DP[j][i], DP[j][i-1] + bears[i] - bears[i-1]);\n    }\n\n    for (int i = j; i < N; i++) {\n      LL ct = DP[j][i];\n      LL nt = ct + bears[i] - bears[j+1];\n      if (T > (bears[i] - bears[j+1]) * 2) {\n        nt += T;\n      } else {\n        nt += bears[i] - bears[j+1];\n      }\n      DP[i][i] = min(DP[i][i], nt);\n    }\n\n//     puts(\"===\");\n//     for (int k = 0; k < N; k++) {\n//       for (int l = 0; l < N; l++) {\n//         if (DP[k][l] == 0xffffffffffffLL) {\n//           printf(\"XX \");\n//         } else {\n//           printf(\"%lld \", DP[k][l]);\n//         }\n//       }\n//       puts(\"\");\n//     }\n\n  }\n\n\n  printf(\"%lld\\n\", DP[N-1][N-1] + E - bears[N-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  vll x(n);re(i, n) scanf(\"%lld\", &x[i]);\n  vll dp(n+1, 1000000000000000000);\n  dp[0] = e;\n\n  for(int now=0;now<n;now++){\n    // t/2(切り上げ) 以上のもの\n    int idx = lower_bound(all(x), x[now] + (t/2)+(t%2)) - x.begin();\n    idx -= now;\n    // そこかその一個前\n    for(int d=idx-1;d+now<n;d++){\n      ll ad = max(t, 2*(x[now+d] - x[now])); //追加される分\n      ll nxt = now + d + 1;\n      dp[nxt] = min(dp[nxt], dp[now] + ad);\n    }\n  }\n  std::cout << dp[n] << '\\n';\n\n  //全ての辺について2通りの可能性\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nll tim;\n\ntemplate<typename T,const T id>\nstruct ConvexHullTrick{\n    struct Line{\n        T a,b;\n        Line(T a=0,T b=0):a(a),b(b){}\n        T get(T x){return max(tim+x-b+a,3*(x-b)+a);}\n    };\n\n    struct Node{\n        Line l;\n        Node *lhs,*rhs;\n        Node(Line l):l(l),lhs(nullptr),rhs(nullptr){}\n    };\n\n    const int n;\n    const vector<T> pos;\n    Node* root;\n\n    ConvexHullTrick(const vector<T> &pos):n(pos.size()),pos(pos),root(nullptr){}\n    Node* insert(Node* p,int lb,int ub,Line& l){\n        if(!p)return new Node(l);\n        if(p->l.get(pos[lb])<=l.get(pos[lb])&&p->l.get(pos[ub])<=l.get(pos[ub]))return p;\n        if(p->l.get(pos[lb])>=l.get(pos[lb])&&p->l.get(pos[ub])>=l.get(pos[ub])){\n            p->l = l;\n            return p;\n        }\n        int mid=(lb+ub)/2;\n        if(p->l.get(pos[mid])>l.get(pos[mid]))swap(p->l , l);\n        if(p->l.get(pos[lb])>=l.get(pos[lb])){\n            p->lhs=insert(p->lhs,lb,mid,l);\n        }\n        else {\n            p->rhs=insert(p->rhs,mid+1,ub,l);\n        }\n        return p;\n\n    }\n    void insert(T a,T b){\n        Line l(a,b);\n        root=insert(root,0,n-1,l);\n    }\n    T get(Node* p,int lb,int ub,int t){\n        if(!p)return id;\n        if(lb==ub)return p->l.get(pos[t]);\n        int mid=(lb+ub)/2;\n        if(t<=mid)return min(p->l.get(pos[t]),get(p->lhs,lb,mid,t));\n        else return min(p->l.get(pos[t]),get(p->rhs,mid+1,ub,t));\n    }\n\n    T get(T x){\n        int t=lower_bound(pos.begin(),pos.end(),x)-pos.begin();\n        return get(root,0,n-1,t);\n    }\n};\nint main(){\n   int n;cin>>n;ll e;\n    cin>>e>>tim;\n    vector<ll> a(n+2);\n    rep(i,n)cin>>a[i+1];\n    a[n+1]=e;\n    ConvexHullTrick<ll,longinf> cht(a);\n    cht.insert(a[1],a[1]);\n    rep(i,n){\n        ll x=cht.get(a[i+1]);\n        cht.insert(x+a[i+2]-a[i+1] ,a[i+2]);\n    }\n    cout<<cht.get(a[n])+a[n+1]-a[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n数据不清空，爆零两行泪。\n多测不读完，爆零两行泪。\n边界不特判，爆零两行泪。\n贪心不证明，爆零两行泪。\nD P 顺序错，爆零两行泪。\n大小少等号，爆零两行泪。\n变量不统一，爆零两行泪。\n越界不判断，爆零两行泪。\n调试不注释，爆零两行泪。\n溢出不 l l，爆零两行泪。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long//防爆int \nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int N=100000;\nint n/*小熊个数*/,m/*终点*/,s/*小熊被Shik碰到至生产金币之间的秒数*/;\nint a[N+1];//小熊的位置 \nint dp[N+1];//dp[i]表示Shik收完了前i个小熊的金币并回到了位置a[i]所花的最小秒数 \nint q[N],head,tail;//对于第1个min维护的单调队列 \nsigned main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tq[tail++]=0;//i=1,j=0满足2a[j+1]>=2a[i]-t，归第1个min，于是压入单调队列 \n\tint now=-1/*第2个min取的j构成的区间（前缀）的右端点*/,mn=inf/*当前的前缀最小值*/;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(now+1<i&&2*a[now+2]<2*a[i]-s)now++,mn=min(mn,dp[now]-a[now]-2*a[now+1]);//将now往后移 \n\t\twhile(head<tail&&q[head]<=now)head++;//维护单调队列，弹出过时元素 \n\t\twhile(head<tail&&dp[q[tail-1]]-a[q[tail-1]]>=dp[i-1]-a[i-1])tail--;//维护单调队列队尾严格单调递增性 \n\t\tq[tail++]=i-1;//将j=i-1入队 \n\t\tdp[i]=min(dp[q[head]]-a[q[head]]+a[i]+s,mn+3*a[i]);//状态转移方程 \n\t}\n\tcout<<dp[n]+m-a[n]<<\"\\n\";//目标 \n\treturn 0;\n}\n/*1\n3 9 1\n1 3 8\n*/\n/*2\n3 9 3\n1 3 8\n*/\n/*3\n2 1000000000 1000000000\n1 999999999\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=n;j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e15;\n\n\nint main(){\n\tll N, E, T;\n\tll x[100005]={};\n\n\tcin >> N >> E >> T;\n\trep(i,N) cin >> x[i];\n\tx[N] = E;\n\n\tN = min<ll>(N, 2000);\n\n\tll dp[2][100005]={};\n\trep(i,N){\n\t\tFill( dp[(i+1)%2], INF );\n\t\tll dist = x[i+1] - x[i];\n\t\trep(j,i+1){\n\t\t\tchmin( dp[(i+1)%2][j], dp[i%2][j] + dist );\n\n\t\t\tll back = (x[i] - x[j]) * 2;\n\t\t\tll t = max( back, T );\n\t\t\tchmin( dp[(i+1)%2][i+1], dp[i%2][j] + t + dist );\n\t\t}\n\t\t//rep(j,N+1) cout << dp[(i+1)%2][j] << \" \"; cout << endl;\n\t}\n\n\tll ans = dp[N%2][N] + x[0];// + E-x[N-1];\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef  long long int ll;\nconst int maxn=200005;\nconst ll inf = (1LL<<60) - 1;\n\nint n,e,t,p[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*4];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i];\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]+t-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long LL;\nconst int maxn = 1e5 + 20;\n\nint N, E, T;\nint x[maxn];\nLL f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tLL pmin = 1ll << 60;\n\t\n\tfor(int i = 1, p = 1; i <= N; i++)\n\t{\n\t\twhile(p <= N && (x[i] - x[p]) * 2 > T)\n\t\t{\n\t\t\tpmin = std::min(pmin, f[p - 1] - 2 * x[p]);\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tf[i] = f[i - 1] + T;\n\t\tf[i] = std::min(f[i], f[p] + T);\n\t\tf[i] = std::min(f[i], pmin + 2 * x[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[N] + E);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[4*maxn],tree2[4*maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return; int mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; } int mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now]; int mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]-2LL*(ll)X[i]-(ll)X[i-1]);\n\t\tmodify(tree2,1,1,N,i,f[i-1]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) > 0) r = mid-1;\n\t\t\telse l = mid+1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tif (r+2 <= i) f[i] = min(f[i],query(tree2,1,1,N,r+2,i)+(ll)X[i]+(ll)T);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nconst int MAXN=100005 ;\nint n , E, T , dis[MAXN] ;\nlong long dp[MAXN] ;\n\nmultiset<long long> st;\nmultiset<long long>::iterator it ;\n\nlong long calc_1(int j){\n\treturn dp[j]-2*dis[j+1]-dis[j] ;\n}\n\nlong long calc_2(int j){\n\treturn dp[j]-dis[j] ;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T) ;\n\tmemset(dp,0x3f,sizeof(dp)) ;\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&dis[i]) ;\n\tdp[0]=0 ;\n\tint last=0 ; //第一个满足边界的\n\tst.insert(calc_2(0)) ;\n\tlong long minn=(1ll<<60)-1 ;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(last<i && 2*(dis[i]-dis[last+1])>=T){\n\t\t\tlong long tmp=calc_2(last) ;\n\t\t\tit=st.find(tmp) , st.erase(it) ;\n\t\t\tminn=min(minn,calc_1(last)) , ++last ;\n\t\t}\n\t\tdp[i]=minn+(long long)3*dis[i] ;\n\t\tif(!st.empty()) dp[i]=min(dp[i],(*st.begin())+T+dis[i]) ;\n\t\tst.insert(calc_2(i)) ;\n\t}\n\tcout << dp[n]+E-dis[n] << '\\n' ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 20-yr-old beautiful girl.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(...) return printf(__VA_ARGS__),0;\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nunsigned Rand(){return rand()*32768+rand();}\nint rand(int a,int b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\nconst int jt=998244353;\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len];\n\tDSU(){loop(i,len)fa[i]=i;}\n\tvoid init(){loop(i,len)fa[i]=i;}\n\tint root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){\n\t\treturn mat[x];\n\t}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D>\n\tmatrix<R,D> operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tvoid debug(){\n\t\tloop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;\n\t}\n};\n\nint n,e,t;\nll a[100005];\nll dp[100005];\n\nint main(){\n\tfio>>n>>e>>t;\n\tcont(i,n){\n\t\tfio>>a[i];\n\t}\n\tint now=1;\n\tll mn=INF;\n\tcont(i,n){\n\t\tif(2*(a[i]-a[1])<t){\n\t\t\tdp[i]=t;\n\t\t\tcontinue;\n\t\t}\n\t\tmn=min(mn,-2*a[1]);\n\t\twhile(2*(a[i]-a[now+1])>t){\n\t\t\tmn=min(mn,dp[now]-2*a[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tdp[i]=mn+2*a[i];\n\t\tdp[i]=min(dp[i],dp[now]+t);\n\t}\n\tfio<<dp[n]+e<<ln;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long ,int>seg[4*maxn];\npair<long long ,int>seg2[4*maxn];\nint a[maxn];\nlong long  dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long ,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long )1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long  val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long ,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long )1e18+10,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint32_t main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<4*maxn;i++){\n\t\tseg[i]={(long long)1e18,(int)1e9};\n\t\tseg2[i]={(long long)1e18,(int)1e9};\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\tif(2*(a[i]-a[0])<d){\n\t\t\tr=0;\n\t\t}\n\t\tif(2*(a[i]-a[i-1])>=d){\n\t\t\tl=i-1;\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long)1e18+10;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF 2100000006\n#define MAXN 100006\nusing namespace std;\nlong long m,T,minone,a[MAXN],d[MAXN];\nint n,l[MAXN],last;\nint find(int x)\n{\n\tint l=1,r=x;\n\twhile(l<r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(T-2*(a[x]-a[mid])>0) r=mid;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main()\n{\n\t//freopen(\"computer.in\",\"r\",stdin);\n\t//freopen(\"computer.out\",\"w\",stdout);\n\tscanf(\"%d%lld%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tl[i]=find(i);\n\tminone=INF;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(last<l[i]-1)\n\t\t{\n\t\t\tlast++;\n\t\t\tminone=min(minone,d[last-1]-a[last-1]-2*a[last]);\n\t\t}\n\t\tlong long len=a[i]-a[l[i]];\n\t\td[i]=d[l[i]-1]+a[l[i]]-a[l[i]-1]+len+T;\n\t\td[i]=min(d[i],minone+3*a[i]);\n\t}\n\tprintf(\"%lld\",d[n]+m-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nLL t;\nstruct UnionFind{\n    vector<int> par;\n    vector<LL> w;\n    UnionFind(int n){\n        par = vector<int>(n,-1);\n        w=vector<LL>(n,0);\n    }\n    int root(int x){\n        if(par[x]<0){\n            return x;\n        }else{\n            return par[x]=root(par[x]);\n        }\n    }\n    void unite(int x,int y, LL a){\n        x=root(x);\n        y=root(y);\n        if(x!=y){\n            if(par[x]<par[y]) swap(x,y);\n            par[y] += par[x];\n            par[x] = y;\n        }\n        w[y]=w[y]+w[x]+a;\n        return;\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    int size(int x){\n        return -par[root(x)];\n    }\n    LL rest(int x){\n        return max(0ll,t-w[root(x)]);\n    }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    LL e;\n    cin >> n >> e >> t;\n    LL ans=e;\n    vector<int> x(n),dx(n-1);\n    REP(i,n) cin >> x[i];\n    REP(i,n-1) dx[i]=(x[i+1]-x[i])*2;\n    UnionFind P(n);\n    typedef tuple<LL,LL,LL> TP;//cost,l,r\n    priority_queue<TP> Q;\n    REP(i,n-1){\n        Q.push(make_tuple(min(t,2*t-dx[i]),i,i+1));\n    }\n    while(!Q.empty() && get<0>(Q.top())>0){\n        LL c,l,r;\n        tie(c,l,r)=Q.top();\n        Q.pop();\n        if(l==0 || r==n-1 || (!P.same(l-1,l) && !P.same(r,r+1))){\n            P.unite(l,r,dx[l+P.size(l)-1]);\n            if(r!=n-1){\n                int newr=r+P.size(r+1);\n                LL r1=P.rest(l),r2=P.rest(newr);\n                Q.push(make_tuple(l,newr,min(t,r1+r2-dx[r])));\n            }\n            if(l!=0){\n                int newl=l-P.size(l-1);\n                LL r1=P.rest(r),r2=P.rest(newl);\n                Q.push(make_tuple(newl,r,min(t,r1+r2-dx[l-1])));\n            }\n        }\n    }\n\n\n    REP(i,n){\n        if(P.par[i]<0)ans+=max(t,P.w[i]);\n    }\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#define INT long long\n#define oo 9876543210000000LL\nusing namespace std;\n\nINT n, e, t, a[100010], dt[100010];\n\nINT dp(int x)\n{\n    if( x == n ) return e-a[n];\n    if( dt[x] ) return dt[x];\n    INT &ret = dt[x] = oo;\n    for(int i = x+1 ; i <= n ; i++ )\n        ret = min( ret, dp(i) + a[i]-a[x]+min( max(t, 2*(a[i]-a[x+1])), t*(i-x) ) );\n    return ret;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>e>>t;\n    for(int i = 1 ; i <= n ; i++ )\n        cin>>a[i];\n    a[0] = 0, a[n+1] = e;\n    cout<<dp(0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n;\nll T,E,pos[100111];\nll dp[100111];\npair<ll,int> q[100111];\nint qb,qe;\nvoid add(int id)\n{\n\twhile(qe>qb&&q[qe-1].FF>=dp[id])qe--;\n\tq[qe++]=MP(dp[id],id);\n}\nvoid del(int id)\n{\n\tif(qb<qe&&q[qb].SS==id)qb++;\n}\nint main()\n{\n\tint tmp;\n\tgetiii(n,tmp,T);\n\tfor(int i=1;i<=n;i++)geti(pos[i]),pos[i]*=2;\n\tll mn=1ll*mod*mod;\n\tint it=-1;\n\tadd(0);\n\tfor(int i=1;i<=n;i++)\n\t{\n//\t\tcerr<<\"i=\"<<i<<endl;\n\t\twhile(pos[i]-pos[it+2]>T)\n\t\t{\n\t\t\tit++;del(it);\n\t\t\tmn=min(mn,dp[it]-pos[it+1]);\n\t\t}\n//\t\tcerr<<\"it=\"<<it<<\" mn=\"<<mn<<endl;\n\t\tdp[i]=mn+pos[i];\n\t\tif(qb<qe)dp[i]=min(dp[i],q[qb].FF+T);\n//\t\tcerr<<\"dp=\"<<dp[i]<<endl;\t\t\n\t\tadd(i);\n\t}\n\tcout<<dp[n]+tmp<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[2002];\nLL ans;\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tif(n > 2000) { return 1; }\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\tx[0] = 0;\n\tx[n + 1] = e;\n\t\n\tinc1(i, n) {\n\t\tans += x[i] - x[i - 1];\n\t\t\n\t\tint jj = i;\n\t\tincII(j, i, n) {\n\t\t\tLL l = x[j] - x[i];\n\t\t\tLL w = l + t * (j - i + 1);\n\t\t\tLL b = l + max(2 * l, t);\n\t\t\tif(w < b) { break; }\n\t\t\tjj = j;\n\t\t}\n\t\tLL l = x[jj] - x[i];\n\t\tLL w = l + t * (jj - i + 1);\n\t\tLL b = l + max(2 * l, t);\n\t\tans += min(w, b);\n\t\t\n\t\ti = jj;\n\t}\n\tans += e - x[n];\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n#define double long double\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\n//typedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-15;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint n,e,t,x[100010] = {},ind = 0,tmp = INF,dp[100010];\n\tcin >> n >> e >> t;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> x[i];\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\twhile((x[i] - x[ind + 1]) * 2 >= t){\n\t\t\tchmin(tmp,dp[ind] + (x[i] - x[ind + 1]) * 2);\n\t\t\tind++;\n\t\t}\n\t\tdp[i] = min(tmp,dp[ind] + t);\n\t\ttmp += (x[i + 1] - x[i]) * 2;\n\t}\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+5;\nconst long long inf=1LL<<61;\ntypedef long long LL;\nstruct sgt{\n\tLL mn[maxn*2];\n\tint id(int l,int r){return l+r|l!=r;}\n\n\tvoid build(int l,int r){\n\t\tmn[id(l,r)]=inf;\n\t\tif(l==r)return ;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid);\n\t\tbuild(mid+1,r);\n\t}\n\tLL Q(int l,int r,int l0,int r0){\n\t\tif(l0<=l&&r0>=r)\n\t\t\treturn mn[id(l,r)];\n\t\tint mid=(l+r)>>1;\n\t\tLL ans=inf;\n\t\tif(l0<=mid)ans=min(ans,Q(l,mid,l0,r0));\n\t\tif(r0>mid)ans=min(ans,Q(mid+1,r,l0,r0));\n\t\treturn ans;\n\t}\n\tvoid C(int l,int r,int ps,LL val){\n\t\tif(l==r){\n\t\t\tmn[id(l,r)]=val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(ps<=mid)C(l,mid,ps,val);\n\t\telse C(mid+1,r,ps,val);\n\t\tmn[id(l,r)]=min(mn[id(l,mid)],mn[id(mid+1,r)]);\n\t}\n}T1,T2;\nint n;\nLL T,E;\nLL d[maxn];\nLL dp[maxn],d2[maxn];\n\nLL bf(){\n\n\tdp[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=inf;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+d[i]-d[j-1]+max(T,2*(d[i]-d[j])));\n\t\t}\n\t\tprintf(\"dp[%d]=%lld\\n\",i,dp[i]);\n\t}\n\n\n\tLL ans=dp[n]+E-d[n];\n\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tn++;\n\td[1]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\td2[i]=d[i]*2;\n\t}\n\n\n\t//TODO\n//\tcout<< bf() <<endl;\n//\treturn 0;\n\tT1.build(1,n);\n\tT2.build(1,n);\n\n\n\tdp[1]=0;\n\tT1.C(1,n,1,0);\n\tT2.C(1,n,1,0);\n\n\tfor(int i=2;i<=n;i++){\n\n\t\tdp[i]=dp[i-1]+d[i]-d[i-1]+T;\n\n\n\t\tauto bin=[&](int lef,int rig){\n\t\t\tint l=1,r=rig-1;\n\n\t\t\twhile(l<r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(2*(d[rig]-d[mid])>=T)\n\t\t\t\t\tl=mid+1;\n\t\t\t\telse\n\t\t\t\t\tr=mid;\n\t\t\t}\n\n\t\t\tint ans=0;\n\t\t\tfor(int delta=-10;delta<=10;delta++){\n\t\t\t\tint ps=delta+l;\n\t\t\t\tif(1<=ps&&ps<rig){\n\t\t\t\t\tif(2*(d[rig]-d[ps])>=T){\n\t\t\t\t\t\tans=ps;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ans;\n\t\t};\n\t\tint ps=bin(1,i);\n\t\t/*\n\t\tint ps=0;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(2*(d[i]-d[j])>=T){\n\t\t\t\tps=j;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n*/\n//\t\tcerr<<ps<<\" \"<<bin(1,i)<<endl; \n//\t\tassert(bin(1,i)==ps);\n\n\t\t//assert(ps==bin(1,i));\n\n//\t\tcerr<<\"it is \"<<i<<\" \"<<ps<<endl;\n\t\tLL res1=inf,res2=inf;\n\n\t\tif(ps>=1)\n\t\t\tres1=T1.Q(1,n,1,ps)+3*d[i];\n\n\t\tif(ps+1<=i-1)\n\t\t\tres2=T2.Q(1,n,ps+1,i-1)+d[i]+T;\n//\t\tcerr<<res1<<\" \"<<res2<<endl;\n\n\t\tdp[i]=min(dp[i],res1);\n\t\tdp[i]=min(dp[i],res2);\n//\t\tcerr<<\"dp = \"<<dp[i]<<endl;\n\t\tT1.C(1,n,i,dp[i-1]-d[i-1]-2*d[i]);\n\t\tT2.C(1,n,i,dp[i-1]-d[i-1]);\n\t}\n\n\tLL ans=dp[n]+E-d[n];\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nlong long int dp2[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint p=0,mini=1e9;\n\tdp[0]=t;\n\tfor(int i=1;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i-1;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tif((x[i]-x[p+1])*2>t)\n\t\tp++;\n\t\tdp[i]=min(x[i]*2-dp2[p-1],t+dp[p]);\n\t\tif(i!=0)\n\t\tdp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n\t\telse\n\t\tdp2[i]=dp[i]-x[i+1]*2;\n\t//\tprintf(\"%d\\n\",dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tfor (int x=now+1; x<=n; ++x){\n\t\t\tlong long tmp=0;\n\t\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]));\n\t\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t\t}\n\t\t\telse f[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "// Template\n#include <bits/stdc++.h>\n#define rep_override(x, y, z, name, ...) name\n#define rep2(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rep3(i, l, r) for (int i = (int)(l); i < (int)(r); ++i)\n#define rep(...) rep_override(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define per(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\nconstexpr int inf = 1001001001;\nconstexpr ll INF = 3003003003003003003LL;\ntemplate <typename T> inline bool chmin(T& x, const T& y) {if (x > y) {x = y; return 1;} return 0;}\ntemplate <typename T> inline bool chmax(T& x, const T& y) {if (x < y) {x = y; return 1;} return 0;}\nstruct IOSET {IOSET() {cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10);}} ioset;\n\n// Main\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    vector<int> x(n);\n    rep(i, n) cin >> x[i];\n    \n    x.push_back(e);\n    \n    vector<ll> dp(n + 1, INF);\n    dp[n] = 0;\n    per(i, n) {\n        int sum = 0;\n        rep(j, i, n) {\n            if (j > i) sum += (x[j] - x[j - 1]) * 2;\n            chmin(dp[i], dp[j + 1] + max(sum, t) + x[j + 1] - x[i]);\n        }\n    }\n    \n    // rep(i, n) cout << dp[i] << \" \\n\"[i == n - 1];\n    \n    cout << dp[0] + x[0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP(x) cerr << #x << \" = \" << (x) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent=false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n\ntemplate<typename T = int> inline T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> inline vector<T> in(int n) { vector<T> xs(n); rep(i, n) cin >> xs[i]; return xs; }\ntemplate<typename T = int> inline vector<vector<T>> in(int n, int m) { vector<vector<T>> xs(n, vector<T>(m)); rep(i, n) rep(j, m) cin >> xs[i][j]; return xs; }\n\nint main(void) {\n    LL N, E, T;\n    cin >> N >> E >> T;\n    VLL xs = in<LL>(N);\n\n    VLL dp(N, INFL);\n    rrep(i, N) {\n        {\n            LL t = T;\n            if (i + 1 == N) t += E - xs[i];\n            else t += dp[i + 1] + (xs[i + 1] - xs[i]);\n            MINUD(dp[i], t);\n        }\n\n        for (int j = i + 1; j < N; j++) {\n            LL m = (xs[j] - xs[i]) * 3;\n            LL t = m;\n            MAXUD(t, T);\n\n            if (j + 1 == N) t += E - xs[j];\n            else t += dp[j + 1] + (xs[j + 1] - xs[j]);\n            MINUD(dp[i], t);\n        }\n    }\n\n    LL ans = dp[0] + xs[0];\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define LL long long\nusing namespace std;\nmultiset<LL> s1, s2;\nLL dp[110000], dp2[110000];\nint x[110000], n, E, T;\nint main(){\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tdp2[0] = T;s1.insert(T);\n\tfor(int i = 1, j = 0; i <= n; i++){\n\t\tscanf(\"%d\", &x[i]);\n\t\twhile(j < i && 2 * (x[i] - x[j + 1]) >= T){\n\t\t\ts1.erase(s1.find(dp2[j]));\n\t\t\tdp2[j] = dp2[j] - T - 2 * (x[j + 1]);\n\t\t\ts2.insert(dp2[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp2[i] = (((LL)1)<<50);\n\t\tif(!s2.empty()) dp[i] = min(dp[i], *s2.begin() + (LL)3 * x[i]);\n\t\tdp2[i] = dp[i] - x[i] + T; \n\t\ts1.insert(dp2[i]);\n\t}\n\tcout<<dp[n] - x[n] + E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tassert(N<=2000);\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tvl d(N+1,e18);\n\tvl e(N+1,e18);\n\td[0]=0;\n\te[0]=T;\n\tint k=0;\n\tfoor(i,1,N){\n\t\tfor(int j=0;j<k;++j){\n\t\t\te[j]+=2*(x[i]-x[i-1]);\n\t\t}\n\t\tfor(;2*(x[i]-x[k+1])>T;++k){\n\t\t\te[k]=d[k]+2*(x[i]-x[k+1]);\n\t\t}\n\t\tfr(j,i){\n\t\t\tchmin(d[i],e[j]);\n\t\t}\n\t\te[i]=d[i]+T;\n\t}\n\tprint(d[N]+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()+1]>=dp[xx]-2*x[xx+1]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std; \nlong long x[100008],dp[100008];long long t,e;\nvoid update(long long i,long long j)\n{\n\tdp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n}\nint main()\n{\n\tlong long n;cin>>n;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i];for(long long i=0;i<100005;i++) dp[i]=2e9;x[n+1]=2e9;\n\tdp[0]=0;long long j=0;long long mst=2e9,msi=0;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tupdate(i,i-1);\n\t\twhile((x[i]-x[j+1])*2>t and j<i-1)\n\t\t{\n\t\t\tj++;long long tt=dp[j]+2*(x[n+1]-x[j+1]);\n\t\t\tif(tt<mst) mst=tt,msi=j;\n\t\t}\n\t\tupdate(i,j);update(i,max(j-1,0));update(i,j+1);\n\t\tupdate(i,msi);\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nÊý¾Ý²»Çå¿Õ£¬±¬ÁãÁ½ÐÐÀá¡£\n¶à²â²»¶ÁÍê£¬±¬ÁãÁ½ÐÐÀá¡£\n±ß½ç²»ÌØÅÐ£¬±¬ÁãÁ½ÐÐÀá¡£\nÌ°ÐÄ²»Ö¤Ã÷£¬±¬ÁãÁ½ÐÐÀá¡£\nD P Ë³Ðò´í£¬±¬ÁãÁ½ÐÐÀá¡£\n´óÐ¡ÉÙµÈºÅ£¬±¬ÁãÁ½ÐÐÀá¡£\n±äÁ¿²»Í³Ò»£¬±¬ÁãÁ½ÐÐÀá¡£\nÔ½½ç²»ÅÐ¶Ï£¬±¬ÁãÁ½ÐÐÀá¡£\nµ÷ÊÔ²»×¢ÊÍ£¬±¬ÁãÁ½ÐÐÀá¡£\nÒç³ö²» l l£¬±¬ÁãÁ½ÐÐÀá¡£\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint n=read(),E=read(),T=read(),a[100005];\nint dp[100005];//dp[i]=min(dp[j]+a[i]-a[j]+max(T,2*(a[i]-a[j+1]))=;\nsigned main(){\n\tfz(i,1,n)\ta[i]=read();\n\tmemset(dp,63,sizeof(dp));\n\tdeque<int> q;\n\tq.push_back(0);\n\tdp[0]=0;\n\tfz(i,1,n){\n\t\tint mn=0x3f3f3f3f3f3f3f3fll;\n\t\twhile(!q.empty()&&2*(a[i]-a[q.front()+1])>T){\n\t\t\tint j=q.front();\n//\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\tmn=min(mn,dp[j]+a[i]-a[j]+2*(a[i]-a[j+1]));\n\t\t\tq.pop_front();\n\t\t}\n//\t\tcout<<\"mn=\"<<mn<<endl;\n\t\tdp[i]=min(dp[i],dp[q.front()]+a[i]-a[q.front()]+T);\n\t\tdp[i]=min(dp[i],mn);\n//\t\tcout<<dp[i]<<endl;\n//\t\twhile(!q.empty()&&dp[q.back()]-a[q.back()]>dp[i]-a[i])\tq.pop_back();\n\t\tq.push_back(i);\n\t}\n\tcout<<dp[n]+abs(a[n]-E)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,e,t;\nll dp[N],x[N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep(i,1,n+1) scanf(\"%lld\",x+i);\n\trep(i,1,n+1) {\n\t\tdp[i]=1ll<<60;\n\t\trep(j,0,i) dp[i]=min(dp[i],dp[j]+x[j+1]-x[j]+max(2*(x[i]-x[j+1]),(ll)t)+x[i]-x[j+1]);\n//\t\tprintf(\"%lld\\n\",dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100000;\nconst ll INF = (1ll<<60);\nll dp[MAXN + 5], a[MAXN + 5], T;\nint que[MAXN + 5], s, t;\nll f1(int x) {\n\treturn dp[x] - a[x] - 2*a[x+1];\n}\nll f2(int x) {\n\treturn T + 2*a[x+1];\n}\nint main() {\n\tint N, M;\n\tscanf(\"%d%d%lld\", &N, &M, &T);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%lld\", &a[i]);\n\ta[N+1] = M; ll p = INF;\n\ts = 1, t = 0;\n\tfor(int i=1;i<=N+1;i++) {\n\t\tdp[i] = INF;\n\t\twhile( s <= t && f1(que[t]) + f2(que[t]) >= f1(i-1) + f2(i-1) )\n\t\t\tt--;\n\t\tque[++t] = i-1;\n\t\twhile( s <= t && f2(que[s])-2*a[i] <= 0 ) {\n\t\t\tp = min(p, f1(que[s]));\n\t\t\ts++;\n\t\t}\n\t\tdp[i] = min(p, f1(que[s]) + f2(que[s]) - 2*a[i]) + 3*a[i];\n\t}\n\tprintf(\"%lld\\n\", min(dp[N+1], dp[N]+M-a[N]));\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define REP(i, k) for (decltype(k) i = 0; i < k; i++)\n#define LOOP(k) REP (ngtkana_is_a_genius, k)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\nauto cmn = [](auto& x, auto y){ if (x>y) { x=y; return true; } return false; };\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    u64 n, E, T; std::cin >> n >> E >> T;\n    assert(n<=u64{2000});\n    vec<u64> a(n + 1);\n    for (usize i=1; i<=n; i++) std::cin >> a.at(i);\n    n++;\n\n    u64 inf = numr<u64>::max();\n    vec<u64> dp(n, inf);\n    dp.at(0) = 0;\n    for (u64 i=0; i<n; i++) {\n        for (u64 j=i+1; j<n; j++) {\n            cmn(dp.at(j),\n                dp.at(i)\n                + a.at(j) - a.at(i)\n                + std::max(T, 2 * (a.at(j) - a.at(i+1))));\n        }\n    }\n\n    u64 ans = dp.at(n-1) + E - a.at(n-1);\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5e5+5;\nint n,t,e,a[N];ll res;\ninline ll min(R ll x,R ll y){return x<y?x:y;}\ninline ll max(R ll x,R ll y){return x>y?x:y;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t),res=e;\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tfor(R int l=1,r=1;l<=n;l=r){\n\t\twhile(r<=n&&((a[r]-a[l])<<1)<=1ll*t*(r-l+1))++r;\n\t\tres+=max(t,(a[r-1]-a[l])<<1);\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define INF (1LL << 50)\nusing namespace std;\n \ntemplate<class T> inline\nvoid read(T& x) {\n\tint f = 1; x = 0;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n \n/*============ Header Template ============*/\n\nconst int N = 100000 + 5;\n\nLL n, l, r, ll, rr, E, T;\nint q[N], qq[N];\nLL s[N], f[N];\n\nLL calc(int x) {\n\treturn f[x] - 2LL * s[x + 1] - s[x];\n}\n\nLL calc2(int x) {\n\treturn calc(x) + T + 2LL * s[x + 1];\n}\n\nvoid add(int x) {\n\twhile (l <= r && calc(q[r]) > calc(x)) r--; \n\tq[++r] = x;\n}\n\nvoid add2(int x) {\n\twhile (ll <= rr && calc2(qq[rr]) > calc2(x)) rr--;\n\tqq[++rr] = x;\n}\n\nint main() {\n\tread(n), read(E), read(T);\n\tfor (int i = 1; i <= n; i++) read(s[i]);\n\tfor (int i = 1; i <= n; i++) f[i] = INF; f[0] = 0;\n\tl = 1, r = 0;\n\tll = 1, rr = 0;\n\tadd2(0);\n\tfor (int i = 1, j = 0; i <= n; i++) {\n\t\twhile (2LL * (s[i] - s[j + 1]) >= T) add(j++);\t\n\t\tif (l <= r) {\n\t\t\tint k = q[l];\n\t\t\tf[i] = 3LL * s[i] + calc(k);\n\t\t}\n\t\twhile (ll <= rr && T - 2LL * (s[i] - s[qq[ll] + 1]) < 0) ll++;\n\t\tif (ll <= rr) {\n\t\t\tint k = qq[ll];\n\t\t\tf[i] = min(f[i], 3LL * s[i] + calc(k) + T - 2LL * (s[i] - s[k + 1]));\n\t\t}\n\t\tadd2(i);\n\t\t//printf(\"%lld\\n\", f[i]);\n\t}\n\tcout << f[n] + E - s[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100020\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\nll f[N][2], x[N];\nint main(int argc, char const *argv[]) {\n  int n = read();\n  ll E = read(), T = read();\n\n  for (int i = 1; i <= n; ++ i) {\n    x[i] = read();\n  }\n  x[n + 1] = E;\n\n  f[0][1] = 2 * x[1];\n\n  for (int i = 1; i <= n; ++ i) {\n    ll llen = x[i] - x[i - 1];\n    ll rlen = x[i + 1] - x[i];\n    f[i][0] = min(f[i-1][1] + max(2 * llen, T) - llen, f[i-1][0] + llen + T);\n    f[i][1] = min(f[i-1][0] + llen + max(2 * rlen, T), f[i-1][1] + max(2 * llen + 2 * rlen, T) - llen);\n    // printf(\"%lld %lld\\n\", f[i][0], f[i][1]);\n  }\n\n  printf(\"%lld\\n\", f[n][0] + x[n+1]-x[n]);\n\n  return 0;\n}\n/*\n\n只有两种情况。\n\n          | wait T\n----------+------------>\n0         A            B            E\n\n\n-----------------------.\n          .------------`\n          `--------------->\n0         A            B            E\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint dp[2010];\n\nint n;\nint T,E;\nint x[2010];\n\nsigned main(){\n\tfor(int i = 0 ; i < 2010 ; i++) dp[i] = 1e18;\n\tcin >> n >> E >> T;\n\tassert(n <= 2000 );\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> x[i];\n\t}\n\tdp[0] = x[0];\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdp[i+1] = min(dp[i+1],dp[i] + T + (i+1 < n ? x[i+1] - x[i] : E-x[i]) );\n\t\tfor(int j = i ; j < n ; j++){\n\t\t\tdp[j+1] = min(dp[j+1], dp[i] + max(x[j]-x[i]+T,max(x[i]+T,2*(x[j] - x[i])) + x[j] - x[i]) + (j+1 < n ? x[j+1] - x[j] : E - x[j]) );\n\t\t}\n\t\t//cout << dp[i] << endl;\n\t}\n\tcout << dp[n]  << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nmultiset<long long> s;\n\nconst int N = 1e5 + 7;\nconst long long INF = 1LL << 60;\n\nint n, t, e;\nlong long pos[N], f[N];\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tpos[i] = x;\n\t}\n\tpos[0] = 0;\n\tf[0] = 0;\n\tlong long min_v = INF;\n\ts.insert(f[0] - pos[0]);\n\tfor (int i = 1, j = 0; i <= n; i++) {\n\t\twhile (2 * pos[j + 1] + t < 2 * pos[i]) {\n\t\t\tmin_v = min(min_v, f[j] - 2 * pos[j + 1] - pos[j]);\n\t\t\tif (s.size()) {\n\t\t\t\ts.erase(s.find(f[j] - pos[j]));\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tf[i] = min_v + 3 * pos[i];\n\t\tif (s.size()) {\n\t\t\tf[i] = min(f[i], *(s.begin()) + pos[i] + t);\n\t\t}\n\t\ts.insert(f[i] - pos[i]);\n\t}\n\tcout << f[n] + e - pos[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nint main(){\n    int N;\n    ll E, T;\n    cin >> N >> E >> T;\n    ll x[N];\n    rep(i, N) cin >> x[i];\n    ll dp[N+1];\n    fill(dp, dp+N+1, INF);\n    dp[0] = 0;\n    int pos1 = 0, pos2 = 0;\n    ll m = INF;\n    rep(i, N){\n        if(dp[i] == INF) continue;\n        while(pos1 < N && (x[pos1]-x[i])*2 < T) pos1++;\n        chmin(dp[pos1], dp[i]+T);\n        while(pos2 < N && (x[i]-x[pos2])*2 >= T){\n            if(pos2 > 0) m += (x[pos2]-x[pos2-1])*2;\n            chmin(m, dp[pos2++]);\n        }\n        if(pos2 > 0) chmin(dp[i+1], m+(x[i]-x[pos2-1])*2);\n    }\n    cout << dp[N]+E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long i64;\n\nint n;\ni64 t;\ni64 e;\nvector<i64> x;\n\ni64 dp[100010];\n\ni64 rec(int end_x)\n{\n\tif(dp[end_x] != -1) return dp[end_x];\n\t//cout << \"end\" << end_x << endl;\n\tif(end_x == n)\n\t{\n\t\t//cout << \"n\" << endl;\n\t\treturn (dp[end_x] = e - x[n]);\n\t}\n\t\n\tauto ite = lower_bound(x.begin(),x.end(), x[end_x + 1] + t / 2 + t % 2);\n\tint i = ite - x.begin();\n\t//cout << \"ite : \" << i << endl;\n\ti64 v1 = (1LL << 62);\n\ti64 v2 = v1;\n\tif(i < n + 1)\n\t{\n\t\tv1 = rec(i) + (x[i] - x[end_x + 1]) * 3;\n\t}\n\ti--;\n\tif(i < n + 1)\n\t{\n\t\tv2 = rec(i) + (x[i] - x[end_x + 1]) * 2 + t;\n\t}\n\t\n\treturn (dp[end_x] = min(v1,v2) + x[end_x + 1] - x[end_x]);\n}\n\n\n\n\n\n\n\nint main()\n{\n\tfill(dp,dp + 100010,-1LL);\n\tcin >> n >> e >> t;\n\tx.assign(n +1,0);\n\tx[0] = 0;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\n\tcout << rec(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  X.push_back(e);\n  vector<ll> dp;\n  rep(i,n+1){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n\n  rep(i,n){\n    int j;\n    j = n;\n    chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j = lower_bound(all(X), X[i+1] + t/2.0) - X.begin();\n    if(X[j] == X[i+1] + t/2.0) j++;\n\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j--;\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n  }\n\n  cout<<dp[n] + e - X[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, e, t;\n    cin >> n >> e >> t;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    ll ans = e - x[n - 1] + x[0];\n    for (int i = 0; i < n;) {\n        if (i != 0) ans += x[i] - x[i - 1];\n        ll tmp = t;\n        for (int j = n - 1; j >= i + 1; j--) {\n            ll tmp1 = max((x[j] - x[i]) * 3, (x[j] - x[i]) + t);\n            ll tmp2 = x[j] - x[i] + t * (j - i + 1);\n            if (tmp1 < tmp2) {\n                tmp = tmp1;\n                i = j + 1;\n                break;\n            }\n        }\n        if (tmp == t) i++;\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 100005\n#define oo 2000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n;\nll E, T, dp[maxN], minF[maxN], x[maxN];\n\nint main () {\n    cin >> n >> E >> T;\n    fto(i, 1, n) cin >> x[i];\n    x[n+1] = E;\n\n    dp[0] = x[1];\n    int j = 1;\n    fto(i, 1, n) {\n        while (2*(x[i]-x[j]) >= T) ++j;\n        dp[i] = dp[j-1] + x[i+1] - x[j] + T;\n        if (j > 1) dp[i] = min(dp[i], minF[j-1] + x[i+1] + 2*x[i]);\n        minF[i] = min(minF[i-1], dp[i-1]-3*x[i]);\n    }\n\n    printf(\"%lld\", dp[n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint dp[100005];\n\n// ------------>8---------- LazySegmentTree ---------->8------------\n\n// ## write [ LST lst(n, SUM/MAX/MIN, ADD/UPD) ] when using this snippet.\nenum QUERY_SEG_LazySegmentTree { SUM, MAX, MIN };\nenum QUERY_LAZ_LazySegmentTree { ADD, UPD };\ntemplate<class SEG, class LAZ>\nclass LazySegmentTree {\nprivate:\n\tstd::vector<SEG> seg;\n\tstd::vector<LAZ> laz;\n\tstd::vector<bool> isUpdated;\n\tint ARY_SIZE;\n\tSEG eSeg;\n\tLAZ eLaz;\n\tstd::function<SEG(SEG&, SEG&)> mergeSeg;\n\tstd::function<LAZ(LAZ&, LAZ&)> mergeLaz;\n\tstd::function<SEG(SEG&, LAZ&, int)> applyLaz;\n\n\tvoid push(int k, int l, int r) {\n\t\tif (!isUpdated[k]) {\n\t\t\tapplyLaz(seg[k], laz[k], r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tmergeLaz(laz[k * 2 + 1], laz[k]); isUpdated[k * 2 + 1] = false;\n\t\t\t\tmergeLaz(laz[k * 2 + 2], laz[k]); isUpdated[k * 2 + 2] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = eLaz;\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n, QUERY_SEG_LazySegmentTree qSeg, QUERY_LAZ_LazySegmentTree qLaz) : ARY_SIZE(1) {\n\t\tARY_SIZE = 1;\n\t\twhile (ARY_SIZE < n) ARY_SIZE *= 2;\n\t\tseg.resize(ARY_SIZE * 2 - 1);\n\t\tlaz.resize(ARY_SIZE * 2 - 1);\n\t\tisUpdated.resize(ARY_SIZE * 2 - 1, true);\n\n\t\tswitch (qSeg) {\n\t\tcase SUM:\n\t\t\teSeg = 0;\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return l + r; };\n\t\t\tbreak;\n\t\tcase MAX:\n\t\t\teSeg = std::numeric_limits<SEG>::lowest();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::max(l, r); };\n\t\t\tbreak;\n\t\tcase MIN:\n\t\t\teSeg = std::numeric_limits<SEG>::max();\n\t\t\tmergeSeg = [](SEG& l, SEG& r) { return std::min(l, r); };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (qLaz)\n\t\t{\n\t\tcase ADD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l += r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s += l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s += l; };\n\t\t\tbreak;\n\t\tcase UPD:\n\t\t\teLaz = 0;\n\t\t\tmergeLaz = [](LAZ& l, LAZ& r) { return l = r; };\n\t\t\tif (qSeg == SUM) applyLaz = [](SEG& s, LAZ& l, int w) { return s = l * w; };\n\t\t\telse applyLaz = [](SEG& s, LAZ& l, int w) { return s = l; };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstruct INVALID_QUERY_TYPE_ERROR {};\n\t\t\tthrow INVALID_QUERY_TYPE_ERROR();\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid update(int a, int b, SEG v, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tLAZ la(v);\n\t\t\tmergeLaz(laz[k], la);\n\t\t\tisUpdated[k] = false;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, v, k * 2 + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, v, k * 2 + 2, (l + r) / 2, r);\n\t\t\tseg[k] = mergeSeg(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\t// ## update [l, r) with v\n\tvoid update(int l, int r, SEG v) {\n\t\tupdate(l, r, v, 0, 0, ARY_SIZE);\n\t}\n\tSEG query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return eSeg;\n\t\tif (a <= l && r <= b) return seg[k];\n\t\tSEG vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tSEG vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn mergeSeg(vl, vr);\n\t}\n\t// ## return SUM/MAX/MIN in [l, r)\n\tSEG query(int l, int r) {\n\t\treturn query(l, r, 0, 0, ARY_SIZE);\n\t}\n};\n\nusing LST = LazySegmentTree<ll, ll>;\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nint solve(std::vector<int> x, int T) {\n\tint n = x.size();\n\n\tauto cost = [&](int l, int r) { // [l, r]\n\t\tif (r >= n | l > r) return 0LL;\n\t\tif (T >= (x[r] - x[l]) * 2) return T;\n\t\telse return (x[r] - x[l]) * 2;\n\t};\n\n\tLST lst(n, MIN, ADD);\n\tdp[0] = T;\n\n\tFOR(i, 1, n) {\n\t\tint pre = std::lower_bound(ALL(x), x[i - 1] - T / 2) - x.begin();\n\t\tint t = std::lower_bound(ALL(x), x[i] - T / 2) - x.begin();\n\t\tFOR(j, pre, t) {\n\t\t\tlst.update(j, j + 1, dp[j] + cost(j + 1, i) - lst.query(j, j + 1));\n\t\t}\n\t\tlst.update(0, pre, (x[i] - x[i - 1]) * 2);\n\t\tlst.update(i - 1, i, dp[i - 1] + T - lst.query(i - 1, i));\n\n\t\tdp[i] = std::min(lst.query(0, i), cost(0, i));\n\t}\n\treturn dp[n - 1];\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, e, t);\n\tVEC(int, x, n);\n\n\tint ans = e;\n\tRREP(i, n) x[i] -= x[0];\n\tans += solve(x, t);\n\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long f[100010],c[100010],d[100010];\nint x[100010];\nint n,e,t,T;\n\ninline void add1(int x,long long o)\n{\n\twhile(x<=n)\n\t{\n\t\tc[x]=min(c[x],o);\n\t\tx+=x&-x;\n\t}\n}\n\ninline long long ask1(int x)\n{\n\tlong long nowans=0x3f3f3f3f3f3f3f3fll;\n\twhile(x)\n\t{\n\t\tnowans=min(nowans,c[x]);\n\t\tx-=x&-x;\n\t}\n\treturn nowans;\n}\n\ninline void add2(int x,long long o)\n{\n\twhile(x)\n\t{\n\t\td[x]=min(d[x],o);\n\t\tx-=x&-x;\n\t}\n}\n\ninline long long ask2(int x)\n{\n\tlong long nowans=0x3f3f3f3f3f3f3f3fll;\n\twhile(x<=n)\n\t{\n\t\tnowans=min(nowans,d[x]);\n\t\tx+=x&-x;\n\t}\n\treturn nowans;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tT=t;\n\tif(t%2)T++;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(c,0x3f,sizeof(c));\n\tmemset(d,0x3f,sizeof(d));\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=min(f[i],f[i-1]+x[i]-x[i-1]+t);\n\t\tint now=upper_bound(x+1,x+1+i,x[i]-T/2)-x;\n\t\tif(x[i]-T/2>=x[1])\n\t\t{\n\t\t\tnow--;\n\t\t\tlong long nowans=ask1(now);\n\t\t\tf[i]=min(f[i],3ll*x[i]+nowans);\n\t\t}\n\t\tif(x[i]-T/2<x[1])now=0;\n\t\tnow++;\n\t\tlong long nowans=ask2(now);\n\t\tf[i]=min(f[i],x[i]+nowans);\n\t\t/*for(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif((x[j]-x[i])*2>=t)f[j]=min(f[j],f[i-1]+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t\telse f[j]=min(f[j],f[i-1]+t-2*(x[j]-x[i])+3ll*(x[j]-x[i])+x[i]-x[i-1]);\n\t\t}*/\n\t\tadd1(i,-3ll*x[i]+f[i-1]+x[i]-x[i-1]);\n\t\tadd2(i,0ll+t-x[i]+x[i]+f[i-1]-x[i-1]);\n\t}\n\tcout<<f[n]+e-x[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long f[101010];\nlong long a[101010];\nint main()\n{\n\tint n,e,t,now=1;\n\tlong long mi;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tf[0]=0;\n\tf[1]=t;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile((a[i]-a[now])*2>t)\n\t\t{\n\t\t\tmi=min(mi,f[now-1]-2*a[now]);\n\t\t\tnow++;\n\t\t}\n\t\tf[i]=f[now-1]+t;\n\t\tf[i]=min(f[i],mi+2*a[i]);\n\t}\n\tprintf(\"%lld\",(long long)e+f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e15;\nvi dp,in;\nll n,e,t;\nll f(ll i,ll j){return dp[j]+in[j+1]-in[j]+max<ll>(t,2*(in[i+1]-in[j+1]))+in[i+1]-in[j+1];}\nint main(){\n\tcin>>n>>e>>t;\n\tin=vi(n+1);\n\trep(i,n)cin>>in[i+1];\n\tdp=vi(n+1,inf);\n\tdp[0]=0;\n\trep(i,n){\n//rep(j,i+1){\n\t\tll l=0,r=i+1;\n\t\twhile(r-l>5){\n\t\t\tll h1=(r-l)/3+l;\n\t\t\tll h2=(r-l)/3*2+l;\n\t\t\tll s1=f(i,h1);\n\t\t\tll s2=f(i,h2);\n\t\t\tif(s1>s2)l=h1;\n\t\t\telse r=h2;\n\t\t}\n\t\tll mi=inf;\n\t\tloop(j,max<ll>(l-5,0),min<ll>(i,r+5))mi=min(mi,f(i,j));\n\t\tdp[i+1]=mi;\n\t}\n\tcout<<dp[n]+e-in[n]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, e, t;\nll f[maxn], x[maxn];\nll s0[20][maxn];\nll s1[20][maxn];\ninline ll min0(int l,int r) { const int lg = std::__lg(r - l + 1); return l <= r ? std::min(s0[lg][r], s0[lg][l + (1 << lg) - 1]) : 1e18; }\ninline ll min1(int l,int r) { const int lg = std::__lg(r - l + 1); return l <= r ? std::min(s1[lg][r], s1[lg][l + (1 << lg) - 1]) : 1e18; }\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\trep(i, 1, n) cin >> x[i];\n\tint j = 0;\n\ts0[0][0] = 0;\n\ts1[0][0] = - x[1] * 2;\n\trep(i, 1, n) {\n\t\tfor(;x[i] - x[j + 1] << 1 > t;) ++ j;\n\t\tf[i] = std::min(min0(j, i - 1) + t, x[i] * 2 + min1(0, j - 1));\n\t\ts0[0][i] = f[i];\n\t\ts1[0][i] = f[i] - x[i + 1] * 2;\n\t\tfor(int j = 1;1 << j <= i + 1;++j) {\n\t\t\ts0[j][i] = std::min(s0[j - 1][i], s0[j - 1][i - (1 << j - 1)]);\n\t\t\ts1[j][i] = std::min(s1[j - 1][i], s1[j - 1][i - (1 << j - 1)]);\n\t\t}\n\t}\n\tstd::cout << f[n] + e << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int n,e,t;\n  cin>>n>>e>>t;\n  int x[n+1];\n  for(int i=0;i<n;i++) cin>>x[i];\n  if(n>2000) assert(0);\n  x[n]=e;\n  int dp[n+1];\n  int INF=1LL<<55LL;\n  fill_n(dp,n+1,INF);\n  dp[0]=x[0];\n  for(int j=0;j<n;j++){\n    int res=dp[j+1];\n    for(int i=0;i<=j;i++){\n      int tmp=max(2*(x[j]-x[i]),t);\n      tmp+=x[j+1]-x[i];\n      res=min(res,dp[i]+tmp);\n    }\n    dp[j+1]=res;\n  }\n  cout<<dp[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nclass segtree{\npublic:\n\tint n;vector<T> dat;T ZERO;\n\n\tsegtree(int n_,T zero):ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, int a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = function(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tT function(T a,T b){\n\t\treturn min(a, b);\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = function(L,dat[A++]);\n            if((B & 1) == 0)R = function(R,dat[--B]);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn function(L,R);\n\t}\n};\n\n\nint main(){\n\n\tll n,e,t;cin >> n >> e >> t;\n\n\tvector<ll> v(n+10);\n\tvector<ll> x(n+10);\n\tvector<ll> sum_x(n+10);\n\tREP(i,n){\n\t\tcin >> v[i+1];\n\t\tx[i+1] = v[i+1] - v[i];\n\t\tsum_x[i+1] = x[i+1];\n\t}\n\tREP(i,n)sum_x[i+1] += sum_x[i];\n\n\tsegtree<ll> sg1(n+10, LLINF);\n\tsg1.update(1, x[1]-3*sum_x[1]);\n\tsegtree<ll> sg2(n+10, LLINF);\n\tsg2.update(1, x[1]-sum_x[1]);\n\tll seica = 1;\n\tll ans;\n\n\tfor(int i = 2;i <= n+1;i++){\n\t\t//REP(j,n+3)cout << sg1.get(j) << \" \";cout << endl;\n\t\t//REP(j,n+3)cout << sg2.get(j) << \" \";cout << endl;\n\t\twhile(seica < i-1 && t - 2 * (sum_x[i-1] - sum_x[seica-1]) <= 0)seica++;\n\t\tll A = 3 * sum_x[i-1] + sg1.que(1,seica);\n\t\tll B = t + sum_x[i-1] + sg2.que(seica,i);\n\n\t\tll now = min(A , B);\n\t\tif(i != n+1){\n\t\t\tsg1.update(i, now+x[i]-3*sum_x[i]);\n\t\t\tsg2.update(i, now+x[i]-sum_x[i]);\n\t\t}\n\t\telse {\n\t\t\tans = now;\n\t\t}\n\t\t//cout << \"          \" << i << \" \" << seica << \" \" << A << \" \" << B << endl;\n\t}\n\n\tcout << ans + e - v[n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nlong long n,E,T,t,a[100005],f[100005],M=1LL<<60;int main(){scanf(\"%d%d%d\",&n,&E,&T);for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);for(int i=1;i<=n;i++){for (;T<=2*(a[i]-a[t+1]);t++)M=__min(M,f[t]-2*a[t+1]);f[i]=__min(f[t]+T,M+2*a[i]);}printf(\"%lld\",E+f[n]);}"
  },
  {
    "language": "C++",
    "code": "//fold\n#ifndef KHALIL\n#include <bits/stdc++.h>\n#else\n#include \"header.h\"\n#endif\n#define endl '\\n'\n#define mp make_pair\n#define tostr(x) static_cast<ostringstream&>((ostringstream()<<dec<<x)).str()\n#define rep(i,begin,end) for(auto i = begin;i < end;i++)\n#define repr(i,begin,end) for(auto i = begin-1;i >= end;i--)\n#define pb push_back\n#define sz(a) ((int)(a).size())\n#define fi first\n#define se second\n#define abs(a) ((a) < (0) ? (-1)*(a) : (a))\n#define SQ(a) ((a)*(a))\n#define eqd(a,b) (abs(a-b)<1e-9)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate <typename t> t in(t q){cin >> q;return q;}\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v){os << \"[\";for (int i = 0; i < sz(v); ++i) { os << v[i]; if (i != sz(v) - 1) os << \",\";}os << \"]\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const map<T, S>& v){for (auto it : v)os << \"(\" << it.first << \":\" << it.second << \")\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const pair<T, S>& v){os << \"(\" << v.first << \",\" << v.second << \")\";return os;}\nconst long double PI = acosl(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\ninline int rand(int l,int r){return uniform_int_distribution<int>(l, r)(rng);}\ninline ll rand(ll l,ll r){return uniform_int_distribution<ll>(l, r)(rng64);}\n//endfold\n#define  N  (100'005)\n#define MOD (1'000'000'007ll)\n#define OO (1'050'000'000)\n#define OOL (1'100'000'000'000'000'000ll)\n\n//global\nll x[N];\nll dp[N];\n\nint main(){\n\t//fold\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcout << setprecision(10);\n\t//endfold\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,0,n){\n\t\tcin >> x[i];\n\t}\n\tdp[n] = 0;\n\tx[n] = e;\n\tqueue<pair<ll,ll>> q;\n\tll mi = OOL;\n\tfor (int i = n-1; i >= 0; --i){\n\t\tll k = lower_bound(x+i+1,x+n,x[i]+(t+1)/2)-x;\n\t\tif(sz(q)) while(q.front().first <= k){\n\t\t\tmi = min(mi,q.front().second);\n\t\t\tq.pop();\n\t\t\tif(q.empty()) break;\n\t\t}\n\t\tll ans = mi-3*x[i];\n\t\tk--;\n\t\tans = min(ans,t+x[k+1]-x[i]+dp[k+1]);\n\t\tdp[i] = ans;\n\t\tq.push({i,2*x[i]+x[i+1]+dp[i+1]});\n\t}\n\tcout << dp[0]+x[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nll A[MAX_N],DP[MAX_N];\n\nll n,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T;\n}\n\nint last;\n\nll g(int idx){\n  ll& x = DP[idx];\n  if(x >= 0) return x;\n  \n  ll idx2 = lower_bound(A,A+n,A[idx]+T/2)-A;\n  idx2--;\n  if(idx2 <= idx) idx2 = idx+1;\n  \n  for(int i=idx2;i<=min(n,idx2+4);i++){\n    ll val = g(i) + f(A[i-1]-A[idx]);\n    if(x == -1 || val < x){\n      x = val;\n    }// else {\n     // break;\n    //}\n  }\n  \n  return x;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n >> E >> T;\n  \n  last = n;\n  \n  for(int i=0;i<n;i++) cin >> A[i];\n  \n  for(int i=0;i<n;i++) DP[i] = -1;\n  \n  for(int i=n-1;i>=0;i--) g(i);\n  \n  cout << E+g(0) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(-inputs[1], 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i], now_cost + 2 * inputs[i]);\n\n\t\twhile (next.empty() == false && 2 * (inputs[i] - inputs[next.top().second]) > t) {\n\t\t\tnext.pop();\n\t\t}\n\n\t\tif (next.empty() == false) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\n\t\tif (i != n - 1)\n\t\t\tnext.push(make_pair(dp[i] -inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF=0x3f3f3f3f3f3f3f3fLL;\nconst int M=100005;\nlong long dp[M];\nint P[M],Q[M];\nlong long mi=INF;\nint n,e,t,l,r;\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",P+i);\n\tQ[r++]=0;\n\tfor(int i=0,j=1;j<=n;++j){\n\t\twhile(t<=2*(P[j]-P[i+1])){\n\t\t\tmi=min(mi,dp[i]-P[i]-2*P[i+1]);\n\t\t\tif(l<r && Q[l]<=i)\n\t\t\t\t++l;\n\t\t\t++i;\n\t\t}\n\t\tdp[j]=3LL*P[j]+mi;\n\t\tif(l<r)\n\t\t\tdp[j]=min(dp[j],dp[Q[l]]+P[j]-P[Q[l]]+t);\n\t\twhile(l<r && dp[j]-P[j]<=dp[Q[r-1]]-P[Q[r-1]])\n\t\t\t--r;\n\t\tQ[r++]=j;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e-P[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:60777216\")  \n\n#include <cassert>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<complex>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<cstdlib>\n#include<memory.h>\n#include<ctime>\n#include<bitset>\n#include<fstream>\n#include<queue>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef long double ld;\n\ntypedef long long ll;\ntypedef pair<int,int>\tpii;\ntypedef pair<ld,ld>\tpdd;\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef pair<ll,ll> pl;\n\n#define FOR(i,a,b)\t\tfor(int i=(a);i<(b);i++)\n#define REP(i,n)\t\tFOR(i,0,n)\n#define SORT(v)\t\t\tsort((v).begin(),(v).end())\n#define UN(v)\t\t\tSORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)\t\t\t\tmemset(a,b,sizeof a)\n#define pb\t\t\t\tpush_back\n\nint n,e,t;\nint x[222222];\n\n\nll  r[222222];\nint p[222222];\n\nint main(){\t\n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>e>>t;\n\t//if(n>10000)return 0;\n\tREP(i,n)scanf(\"%d\",x+i+1);\n\tFOR(i,1,n+1){\n\t\tr[i]=1e18;\n\t\tFOR(prev,p[i-1],i){\n\t\t\tint diff = x[i] - x[prev+1];diff*=2;\n\t\t\tif(r[i]>r[prev]+max(diff,t)){\n\t\t\t\tr[i]=r[prev]+max(diff,t);\n\t\t\t\tp[i]=prev;\n\t\t\t}\n\t\t\tif(diff<t)break;\n\t\t}\n\t/*\tint prev = p[i-1];\n\t\tr[i] = r[prev] + solve(prev,i);\n\t\twhile(prev+1<i && r[i] > r[prev+1]+solve(prev+1,i)){\n\t\t\tprev++;\n\t\t\tr[i] = r[prev] + solve(prev,i);\n\t\t}\n\t\tp[i] = prev;*/\n\t}\n\n\tcout<<r[n]+e<<endl;\n\n\n\n#ifdef LocalHost\n\tprintf(\"TIME: %.3lf\\n\",ld(clock())/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 123456;\nconst long long llinf = 1e18;\n\nint n, e, t, p[N], q[N], l, r;\nlong long dp[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> e >> t;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n  }\n  q[l = r = 0] = 0;\n  long long pre_min = llinf;\n  for (int i = 1, j = 0; i <= n; ++i) {\n    dp[i] = llinf;\n    while (l <= r && 2 * (p[i] - p[q[l] + 1]) > t) {\n      ++l;\n    }\n    if (l <= r) {\n      dp[i] = min(dp[i], dp[q[l]] - p[q[l]] + p[i] + t);\n    }\n    while (2 * (p[i] - p[j + 1]) > t) {\n      pre_min = min(pre_min, dp[j] - p[j] - 2 * p[j + 1]);\n      ++j;\n    }\n    dp[i] = min(dp[i], pre_min + 3ll * p[i]);\n    while (l <= r && dp[i] - p[i] <= dp[q[r]] - p[q[r]]) {\n      --r;\n    }\n    q[++r] = i;\n  }\n  cout << dp[n] + e - p[n] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n;\nlong long T, E;\nlong long a[Maxn];\nlong long dp[Maxn];\n// dp[i] = min { dp[j] + a[i] - a[j] + max(T, 2 * (a[i] - a[j + 1]) }\n// dpt[i] = min { dpt[j] + max(T, 2 * (a[i] - a[j + 1])) }\n// dp[i] = dpt[i] + a[i]\n// Ans = dp[n] + (E - a[n]) = dpt[n] + E\n\nnamespace sgt1 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\nnamespace sgt2 {\n  #define ls (p * 2 + 1)\n  #define rs (p * 2 + 2)\n  #define mid (l + r >> 1)\n  long long tr[Maxn << 2];\n  inline void init() {\n    memset(tr, 0x3f, sizeof(tr));\n  }\n  inline void pushup(int p) {\n    tr[p] = min(tr[ls], tr[rs]);\n  }\n  void modify(int p, int l, int r, int pos, long long val) {\n    if (l == r) {\n      tr[p] = min(tr[p], val);\n      return ;\n    }\n    if (pos <= mid) {\n      modify(ls, l, mid, pos, val);\n    }\n    else {\n      modify(rs, mid + 1, r, pos, val);\n    }\n  }\n  long long query(int p, int l, int r, int L, int R) {\n    if (L > r || l > R) return 1e18;\n    if (L <= l && r <= R) {\n      return tr[p];\n    }\n    long long left = query(ls, l, mid, L, R);\n    long long right = query(rs, mid + 1, r, L, R);\n    return min(left, right);\n  }\n  #undef ls\n  #undef rs\n  #undef mid\n}\n\nint main() {\n  scanf(\"%d%lld%lld\", &n, &E, &T);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n  }\n  \n  memset(dp, 63, sizeof(dp));\n  dp[0] = 0;\n  sgt1::init();\n  sgt2::init();\n  sgt1::modify(0, 0, n, 0, dp[0]);\n  sgt2::modify(0, 0, n, 0, dp[0] - 2 * a[1]);\n  for (int i = 1; i <= n; ++i) {\n    int low = 0, high = i, pos = i;\n    while (low <= high) {\n      int mid = low + high >> 1;\n      if ((a[i] - a[mid]) * 2 <= T) {\n        high = mid - 1, pos = mid;\n      }\n      else {\n        low = mid + 1;\n      }\n    }\n    if (pos) --pos;\n    if (pos < i) {\n      dp[i] = min(dp[i], sgt1::query(0, 0, n, pos, i - 1) + T);\n    }\n    if (pos > 0) {\n      dp[i] = min(dp[i], sgt2::query(0, 0, n, 0, pos - 1) + 2 * a[i]);\n    }\n    sgt1::modify(0, 0, n, i, dp[i]);\n    sgt2::modify(0, 0, n, i, dp[i] - 2 * a[i + 1]);\n  }\n  printf(\"%lld\\n\", dp[n] + E);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e5 + 10, INF = 1e9 * 1e9;\nll dp[SZ], push[SZ * 8][4], tree[SZ * 8][4];\n\nvoid p(int v, int ind) {\n\ttree[v * 2 + 1][ind] += push[v][ind];\n\ttree[v * 2 + 2][ind] += push[v][ind];\n\tpush[v * 2 + 1][ind] += push[v][ind];\n\tpush[v * 2 + 2][ind] += push[v][ind];\n\tpush[v][ind] = 0;\n}\n\nll get(int v, int l, int r, int askl, int askr, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) {\n\t\treturn INF;\n\t}\n\n\tif (l >= askl && r <= askr) {\n\t\treturn tree[v][ind];\n\t}\n\tint mid = (l + r) / 2;\n\tll q = get(v * 2 + 1, l, mid, askl, askr, ind), q2 = get(v * 2 + 2, mid, r, askl, askr, ind);\n\treturn min(q, q2);\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int add, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\ttree[v][ind] += add;\n\t\tpush[v][ind] += add;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, add, ind);\n\tupd(v * 2 + 2, mid, r, askl, askr, add, ind);\n\ttree[v][ind] = min(tree[v * 2 + 1][ind], tree[v * 2 + 2][ind]);\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vec(n);\n\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\n\tvec.push_back(e);\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 1, 0);\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 3, 1);\n\n\t\tdp[i] = dp[i + 1] + (vec[i + 1] - vec[i]) + t;\n\t\t\n\t\tint l = i, r = n + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif ((vec[mid] - vec[i]) * 2 >= t) {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\n\t\tll q = INF;\n\t\tif (i + 1 < r - 1) q = get(0, 0, n + 1, i + 1, r - 1, 0) + t;\n\t\tif (r < n + 1) q = min(q, get(0, 0, n + 1, r, n + 1, 1));\n\n\t\tdp[i] = min(dp[i], q);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 0);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 1);\n\t}\n\n\tcout << dp[0] + vec.front();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 1e5 + 10, INF = 1e9 * 1e9;\nll dp[SZ], push[SZ * 8][4], tree[SZ * 8][4];\n\nvoid p(int v, int ind) {\n\ttree[v * 2 + 1][ind] += push[v][ind];\n\ttree[v * 2 + 2][ind] += push[v][ind];\n\tpush[v * 2 + 1][ind] += push[v][ind];\n\tpush[v * 2 + 2][ind] += push[v][ind];\n\tpush[v][ind] = 0;\n}\n\nll get(int v, int l, int r, int askl, int askr, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) {\n\t\treturn INF;\n\t}\n\n\tif (l >= askl && r <= askr) {\n\t\treturn tree[v][ind];\n\t}\n\tint mid = (l + r) / 2;\n\tll q = get(v * 2 + 1, l, mid, askl, askr, ind), q2 = get(v * 2 + 2, mid, r, askl, askr, ind);\n\treturn min(q, q2);\n}\n\nvoid upd(int v, int l, int r, int askl, int askr, int add, int ind) {\n\tp(v, ind);\n\tif (l >= askr || r <= askl) return;\n\n\tif (l >= askl && r <= askr) {\n\t\ttree[v][ind] += add;\n\t\tpush[v][ind] += add;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(v * 2 + 1, l, mid, askl, askr, add, ind);\n\tupd(v * 2 + 2, mid, r, askl, askr, add, ind);\n\ttree[v][ind] = min(tree[v * 2 + 1][ind], tree[v * 2 + 2][ind]);\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> vec(n);\n\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\n\tvec.push_back(e);\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 1, 0);\n\t\tupd(0, 0, n + 1, i + 1, n + 1, (vec[i + 1] - vec[i]) * 3, 1);\n\n\t\tdp[i] = dp[i + 1] + (vec[i + 1] - vec[i]) + t;\n\t\t\n\t\tint l = i, r = n + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif ((vec[mid] - vec[i]) * 2 >= t) {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\n\t\tll q = INF;\n\t\tif (i + 1 < r) q = get(0, 0, n + 1, i + 1, r, 0) + t;\n\t\tif (r < n + 1) q = min(q, get(0, 0, n + 1, r, n + 1, 1));\n\n\t\tdp[i] = min(dp[i], q);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 0);\n\t\tupd(0, 0, n + 1, i, i + 1, dp[i + 1] + (vec[i + 1] - vec[i]), 1);\n\t}\n\n\tcout << dp[0] + vec.front();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mxn=1e6+6;\nint n,E,T,w[mxn];\nll d[mxn];\nmultiset<ll>s1,s2;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint pv=1;\n\tcin>>n>>E>>T;\n\tfor(int i=1;i<=n;++i)cin>>w[i];\n\tw[n+1]=E,d[1]=w[1];\n\tfor(int i=1;i<=n;++i){\n\t\tll r=1e15,tp;\n\t\ts2.insert(d[i]-w[i]);\n\t\tfor(;pv<=i and (w[i]-w[pv])*2>T;){\n\t\t\ts2.erase(s2.find(d[pv]-w[pv]));\n\t\t\ts1.insert(d[pv]-1ll*3*w[pv]);\n\t\t\t++pv;\n\t\t}\n\t\tif(!s1.empty()){\n\t\t\ttp=*s1.begin();\n\t\t\tif(r>tp+w[i]*3ll)r=tp+w[i]*3ll;\n\t\t}\n\t\ttp=*s2.begin();\n\t\tif(r>tp+w[i]+T)r=tp+w[i]+T;\n\t\td[i+1]=w[i+1]-w[i]+r;\n\t}\n\tcout<<d[n+1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector< vector<int> > vvi;\ntypedef vector<ll> vl;\ntypedef vector< vector<ll> > vvl;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n#define forv(i, v) forn(i, v.size())\n#define all(v) v.begin(), v.end()\n#define mp make_pair\n#define pb push_back\n\nconst ll INF = 1e18;\n\nint main() {\n#ifdef NEREVAR_PROJECT\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    ll t, e;\n    cin >> n >> e >> t;\n    vl x(n);\n    forn(i, n) {\n        scanf(\"%lld\", &x[i]);\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    vl minCF(n + 1, INF);\n    ll minC = INF;\n    forn(i, n) {\n        ll pos = i == 0 ? 0 : x[i - 1];\n        \n        minC = min(minC, minCF[i + 1]);\n        dp[i + 1] = min(dp[i + 1], x[i] * 3 + minC);\n        \n        int lf = i, rg = n - 1;\n        while (rg - lf > 1) {\n            int mid = (lf + rg) / 2;\n            if ((x[mid] - x[i]) * 2 <= t) {\n                lf = mid;\n            } else {\n                rg = mid - 1;\n            }\n        }\n        \n        int L = max(i, lf - 300);\n        int R = min(n, rg + 300);\n        \n        minCF[R] = min(minCF[R], dp[i] + x[i] - pos - x[i] * 3);\n        \n        for (int j = L; j < R; j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n        \n        for (int j = i; j < min(n, i + 500); j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n    }\n    cout << dp[n] + e - x[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600123456789\n\nvector<vector<long> > dp;\nvector<long> vec;\nlong n,e,t;\n\nint main(){\n  cin>>n>>e>>t;\n  dp = vector<vector<long> >(n+1, vector<long>(n+1, INF));\n  vec.resize(n+1);\n  vec[0]=0;\n  rep(i,n) scanf(\"%d\", &vec[i+1]);\n\n  if(n>2000){ cout<<-1<<endl; return 0; }\n\n  dp[0][0]=0;\n  rep(j,n+1) repl(i,j,n+1) if(dp[i][j]!=INF){\n    // すすむ\n    if(i<n && dp[i][j] + vec[i+1] - vec[i] < dp[i+1][j]){\n      dp[i+1][j] = dp[i][j] + vec[i+1] - vec[i];\n    }\n    // もどる\n    if(i>0 && i!=j){\n      long tim = max(t-2*(vec[i]-vec[j+1]), 0L) + 2*(vec[i]-vec[j+1]) + dp[i][j];\n      if(tim < dp[i][i]){\n        dp[i][i] = tim;\n      }\n    }\n  }\n//  rep(i,n+1) {rep(j,n+1) cout<<dp[i][j]<<\" \"; cout<<endl;}\n\n  cout<< dp[n][n] + e-vec[n] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \ntypedef pair<int,int> pii; \n\nconst int maxN = 1000 * 100 + 10; \nll a[maxN]; \nconst ll inf = 1e18; \nll dp[maxN]; \nset<pair<ll,int>> curr1, curr2; \n\nint main() { \n\tios::sync_with_stdio(false); cin.tie(0); \n\ta[0] = 0; \n\tint n,e,T; cin >> n >> e >> T;\n\tfor( int i = 0 ; i < n ; i++ ) cin >> a[i+1]; \n\n\tcurr1.insert( { inf , -1 } ) ; \n\tcurr2.insert( { inf , -1 } ) ; \n\tfill( dp , dp + n + 1 , inf ) ; \n\tdp[0] = 0; \n\tint last = 0; \n\tcurr1.insert( { 0ll , 0 } ); \n\tfor( int i = 1 ; i <= n ; i++ ) { \n\t\twhile( last < i && 2ll * (a[i] - a[last+1]) >= T ) { \n\t\t\tcurr1.erase( { 0ll + dp[last] ,  last } ) ; \n\t\t\tcurr2.insert( { 0ll + dp[last] - 2ll * a[last+1] , last } ); \n\t\t\tlast++; \n\t\t}\n\t\tdp[i] = min( 0ll + curr1.begin()->first + T , \n\t\t\t\t0ll + curr2.begin()->first + 2ll * a[i] ); \n\t\tcurr1.insert( { dp[i]  , i } ); \n\t}\n\tcout << dp[n] + e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\n#define N (1<<17)\n//Range Add Query+Range Minimum Query\ntemplate<class T>\nclass RAQ_RMQ {\npublic:\n\tT dat[2*N], lazy[2*N], ZERO, DEFAULT;\n\tfunction<T(T,T)>merge;\n\tvoid init(\n\t\tfunction<T(T,T)>Merge=[](T a,T b){return min(a,b);}, T d = LLONG_MAX) {\n\t\tmerge=Merge;\n\t\tDEFAULT = d;\n\t\tZERO = T();\n\t\trep(i,2*N-1){\n\t\t\tdat[i]=lazy[i]=ZERO;\n\t\t}\n\t}\n\tinline void push(int k) {\n\t\tdat[k] = dat[k] + lazy[k];\n\t\tif (k < N - 1) {\n\t\t\tlazy[k * 2 + 1] = lazy[k * 2 + 1] + lazy[k];\n\t\t\tlazy[k * 2 + 2] = lazy[k * 2 + 2] + lazy[k];\n\t\t}\n\t\tlazy[k] = ZERO;\n\t}\n\tinline void update_node(int k) {\n\t\tdat[k]=merge(dat[k*2+1],dat[k*2+2]);\n\t}\n\tinline void update(int a, int b, T x, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = lazy[k] + x; push(k); return;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t}\n\tinline T query(int a, int b, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return DEFAULT;\n\t\tif (a <= l&&r <= b)return dat[k];\n\t\tT lb = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT rb = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t\treturn merge(lb,rb);\n\t}\n\tinline void update(int a, int b, T x) {\n\t\tupdate(a, b, x, 0, 0, N);\n\t}\n\tinline void update(int a, T x) {\n\t\tupdate(a, a + 1, x);\n\t}\n\tinline T query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tinline T query(int a) {\n\t\treturn query(a, a + 1);\n\t}\n};\nint x[200000];\nRAQ_RMQ<ll>seg;\n\nint main(){\n\tseg.init();\n\tint n,E,T;cin>>n>>E>>T;\n\trep(i,n)scanf(\"%d\",&x[i+1]);\n\tx[n+1]=E;\n\tseg.update(0,x[1]);\n\tint s=0;\n\tfor(int i=2;i<=n+1;i++){\n\t\tseg.update(0,i-1,x[i]-x[i-1]);\n\t\twhile((x[i-1]-x[s+1])*2>=T){\n\t\t\tseg.update(s,-T+(x[i-2]-x[s+1])*2);\n\t\t\ts++;\n\t\t}\n\t\tseg.update(0,s,(x[i-1]-x[i-2])*2);\n\t\tseg.update(i-1,seg.query(0,i-1)+T);\n\t}\n\tcout<<seg.query(n)<<endl;\n\t/*\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[1][0]=x[1];\n\tfor(int i=2;i<=n+1;i++)rep(j,i-1){\n\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+(x[i]-x[i-1]));\n\t\tdp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+max(T,(x[i-1]-x[j+1])*2)+(x[i]-x[i-1]));\n\t}\n\tcout<<dp[n+1][n]<<endl;\n\t*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 2010;\nconst ll INF = 1LL<<50;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint n, e, T, d[MAXN];\nll dp[MAXN];\n\nint main() {\n\tn = read();\n\te = read(), T = read();\n\tfor(int i = 1; i <= n; i++) d[i] = read();\n\tdp[0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tdp[i] = INF;\n\t\tint f = 0;\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tll res = dp[j]+d[i]-d[j]+max(T, 2*(d[i]-d[j+1]));\n\t\t\tif(res < dp[i]) {\n\t\t\t\tdp[i] = res;\n\t\t\t\tf = j;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\", f);\n\t}\n\t//printf(\"%lld\\n\", dp[2]);\n\tprintf(\"%lld\\n\", dp[n]+e-d[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=4000+5,inf=1e18+1;\nll mod=924844033;\n\nll n,e,t;\nll dp[M];\nll x[M];\n\nll seg[2*M];\n\nvoid upd(ll p,ll v)\n{\n    //ER(p);ER(v);\n    for (p+=2*n;p>0;p/=2) smin(seg[p],v);\n}\n\nll get(ll l,ll r)\n{\n    //ER(l);ER(r);\n    ll res=inf;\n    for (l+=2*n,r+=2*n;l<r;l/=2,r/=2)\n    {\n        if (l&1) smin(res,seg[l++]);      \n        if (r&1) smin(res,seg[--r]);\n    }\n    //ER(res);\n    return res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> e >> t;\n\t//if (n>2000) return 0;\n\tFor(i,0,n)\n\t{\n\t    cin >> x[i];\n\t}\n\t/*For(i,1,n+1)\n\t{\n\t    dp[i]=(-x[0])*3+max(0LL,t-2*(x[i-1]-x[0]))+x[0];\n\t    For(j,1,i)\n\t    {\n\t        smin(dp[i],(-x[j])*3+\n\t            max(0LL,t-2*(x[i-1]-x[j]))+\n\t            dp[j]+x[j]-x[j-1]);\n\t    }\n\t    dp[i]+=x[i-1]*3;\n\t    //ER(i);ER(dp[i]);\n\t}//*/\n\tmemset(seg,127,sizeof seg);\n\tFor(i,1,n+1)\n\t{\n\t    dp[i]=(-x[0])*2+max(0LL,t-2*(x[i-1]-x[0]));\n\t    ll lo=0,hi=i-1;\n\t    while (hi-lo>1)\n\t    {\n\t        ll mid=(hi+lo)>>1;\n\t        if (t>2*(x[i-1]-x[mid])) hi=mid; else lo=mid;\n\t    }\n\t    if (hi>0)\n\t        smin(dp[i],-x[hi]*2+t-2*(x[i-1]-x[hi])+dp[hi]-x[hi-1]);\n        smin(dp[i],get(0,hi));\n\t    dp[i]+=x[i-1]*3;\n\t    upd(i,-x[i]*2+dp[i]-x[i-1]);\n\t    //ER(i);ER(dp[i]);\n\t}\n\tcout << dp[n]+e-x[n-1];\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\n\nconst int maxn = 100000 + 10;\nint n, e, t;\nint x[maxn];\nint nxt[maxn];\nlong long f[maxn];\nlong long rmq[2][maxn << 1];\n\nvoid upd(int k, int p, long long val) {\n\tfor (rmq[k][p += maxn] = val; p > 1; ) p >>= 1, rmq[k][p] = min(rmq[k][p << 1], rmq[k][p << 1 | 1]);\n}\nlong long query(int k, int l, int r) {\n\tlong long res = LINF;\n\tfor (l += maxn, r += maxn + 1; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = min(res, rmq[k][l++]);\n\t\tif (r & 1) res = min(res, rmq[k][--r]);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n >> e >> t;\n\tFOR(i, 0, n) cin >> x[i];\n\tx[n] = e;\n\tfor (int i = 0; i < (maxn << 1); i++) {\n\t\trmq[0][i] = rmq[1][i] = LINF;\n\t}\n\tint ptr = 0;\n\tFOR(i, 0, n) {\n\t\twhile (ptr < n - 1 && 2 * (x[ptr + 1] - x[i]) <= t) ptr++;\n\t\tnxt[i] = ptr;\n\t}\n\tupd(0, n, f[n] + x[n] + t);\n\tupd(1, n, f[n] + 2 * x[n - 1] + x[n]);\n\tFORd(i, n, 0) {\n\t\tint ix = nxt[i];\n\t\tf[i] = query(0, i + 1, ix + 1) - x[i];\n\t\tchkmin(f[i], query(1, ix + 2, n) - 3 * x[i]);\n\t\tif (i) {\n\t\t\tupd(0, i, f[i] + x[i] + t);\n\t\t\tupd(1, i, f[i] + 2 * x[i - 1] + x[i]);\n\t\t}\n\t}\n\tcout << f[0] + x[0] << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nconst long long inf = 1ll * N * N;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n\treturn dp[j] + a[i] - a[j] + max(t, 2 * (a[i] - a[j + 1]));\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tlong long c = inf;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\twhile (2 * (a[i] - a[p + 1]) > t) {\n\t\t\tc = min(c, dp[p] - a[p] - 2 * a[p + 1]);\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = inf;\n\t\tif (p < i) {\n\t\t\tdp[i] = dp[p] + a[i] - a[p] + t;\n\t\t}\n\t\tdp[i] = min(dp[i], 3 * a[i] + c);\n\t\t\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;\n\t//\tcout << \"72 \" << get(2, 0) << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//dp[i]=min(dp[j]+max(T,(s[i]-s[j+1])*2)+(s[i]-s[j]));\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nconst long long inf=1LL<<60;\nint s[maxn];\nint n,E,T;\nint head,tail,que[maxn];\nlong long dp[maxn];\nlong long tmp=inf;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&E,&T);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&s[i]);\n    head=1,tail=0;\n    que[++tail]=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(head<=tail&&2*(s[i]-s[que[head]+1])>T)tmp=min(tmp,dp[que[head]]-2*s[que[head]+1]),head++;\n        dp[i]=min(dp[que[head]]+T,tmp+2*s[i]);\n        que[++tail]=i;\n    }\n    printf(\"%lld\\n\",dp[n]+E);\n}"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\t// printf(\"[%d] -> [%d] : %d %d %d\\n\", j, i, f[j], a[i] - a[j], std::max((a[i] - a[j]) << 1, k));\n\t\t\tf[i] = std::min(f[i], f[j] + a[i] - a[j] + std::max((a[i] - a[j + 1]) << 1, k));\n\t\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll dp[MX], dp2[MX];\nint s, t, deq[MX];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, T; cin >> n;\n\tvi v(n + 2);\n\tcin >> v[n + 1] >> T;\n\trep(i, n) cin >> v[i + 1];\n\t\n\t// dp[i] := best - 2 * next - cur\n\t// dp2[i] := best - cur\n\tdp[0] = -2ll * v[1];\n\tt = 1;\n\tll min1 = 1e18;\n\t\n\tfor(int i = 0, j = 0; i < n; i++){\n\t\twhile(2ll * (v[i + 1] - v[j + 1]) > T){\n\t\t\tmin1 = min(min1, dp[j]);\n\t\t\tif(s < t && deq[s] == j) s++;\n\t\t\tj++;\n\t\t}\n\t\tll tmp = 3ll * v[i + 1] + min1;\n\t\ttmp = min(tmp, v[i + 1] + dp2[deq[s]] + T);\n\t\tif(i == n - 1){\n\t\t\tcout << tmp + v[n + 1] - v[n] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tdp[i + 1] = tmp - 2ll * v[i + 2] - v[i + 1];\n\t\tdp2[i + 1] = tmp - v[i + 1];\n\t\t\n\t\twhile(s < t && dp2[deq[t - 1]] >= dp2[i + 1]) t--;\n\t\tdeq[t++] = i + 1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst long long inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int N = 1e5 + 10; \nint a[N], nxt[N], n, e, t;\nlong long val;\nlong long seg[N << 2], lazy[N << 2], dp[N];\nvector<int> fnd[N];\n//\nvoid relax(int id) {\n\tint lc = id * 2, rc = lc + 1;\n\tseg[lc] += lazy[id], lazy[lc] += lazy[id];\n\tseg[rc] += lazy[id], lazy[rc] += lazy[id];\n\tlazy[id] = 0;\n\treturn;\n}\nvoid add(int l, int r, int id = 1, int s = 0, int e = n) {\n\tif (e <= l || r <= s)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tadd(l, r, lc, s, mid);\n\tadd(l, r, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n//\tcout << \"s = \" << s << \" e = \" << e << \" : \" << seg[id] << endl;\n}\nvoid upd(int p, int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tseg[id] = val;\n\t\tlazy[id] = 0;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tif (p < mid)\n\t\tupd(p, lc, s, mid);\n\telse\n\t\tupd(p, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n\treturn;\n}\nvoid open(int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tcout << \"s = \" << s << \" : \" << seg[id] << endl;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\topen(lc, s, mid);\n\topen(rc, mid, e);\n}\n//\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint st = -1;\n\tn++;\n\tfor (int i = 0; i < n; i++) {\n\t\tval = inf;\n\t\tupd(i);\n\t\twhile ((a[i] - a[st + 1]) * 2 >= t)\n\t\t\tst++;\n\t\tif (st != -1)\n\t\t\tfnd[st].push_back(i);\n\t}\n\tst = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile ((a[st - 1] - a[i]) * 2 >= t)\n\t\t\tst--;\n\t\tnxt[i] = st;\n\t}\n//\tcout << \"HO\" << endl;\n\tval = t;\n\tupd(n - 1);\n\tfor (int i = n - 2; i >= 0; i--) {\n//\t\tcout << \"i = \" << i << endl;\n\t\tlong long toall = a[i + 1] - a[i], tosome = a[i + 2] - a[i + 1];\n\t\tval = toall, add(i + 1, n);\n\t\tif (tosome > 0)\n\t\t\tval = tosome, add(nxt[i + 1], n);\n\t\tfor (auto plc : fnd[i + 1]) {\n\t\t\tlong long dis = 1ll * (a[plc] - a[i + 1]) * 3 + 1ll * toall;\n\t\t\tval = dis + dp[plc], upd(plc);\n//\t\t\tcout << \"plc = \" << plc << \" : \" << dis << \" val = \" << val << endl;\n\t\t}\n//\t\tcout << \" open : \" << endl;\n//\t\topen();\n//\t\tcout << endl;\n\t\tdp[i] = seg[1], val = dp[i] + t;\n//\t\tcout << \"i = \" << i << \" a[i] =  \" << a[i] << \" dp = \" << dp[i] << \" toall = \" << toall << \" tosome = \" << tosome << \" nxt = \" << nxt[i + 1] << endl;\n\t\tupd(i);\n\t}\n\tcout << dp[0] + e - a[n - 1];\n//\tcout << endl;\n//\topen();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst ll oo = 1e18;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint N, E;\nll a[MAXN], dp[MAXN], T;\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor (int i=0; i<N; i++) scanf(\"%d\", &a[i]);\n\t\n\tfor (int i=0; i<N; i++) dp[i] = oo;\n\tdp[0] = T + a[0];\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<=i; j++) {\n\t\t\tll dis = (a[i] - a[j]) * 2;\n\t\t\tll wait = max(0ll, T - dis);\n\t\t\tll cur = dis / 2 * 3 + wait + a[j] - (j != 0 ? a[j-1] : 0);\n\t\t\tif (j) cur += dp[j-1];\n\t\t\tdp[i] = min(cur, dp[i]);\n\t\t}\n\t}\n\t\n\tcout << (E - a[N - 1]) + dp[N - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n;\nll x[2005],e,t;\nll dp[2005];\nint main() {\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&x[i]);\n\t\tdp[i]=dp[i-1]+t;\n//\t\tcerr<<\"--tmp\\n\";\n\t\tfor(int j=0;j<i-1;j++) {\n\t\t\tdp[i]=min(dp[i],dp[j]+2*(x[i]-x[j+1])+max(0ll,t-2*(x[i]-x[j+1])));\n//\t\t\tcerr<<j<<\":\"<<dp[i]<<endl;\n\t\t}\n//\t\tcerr<<\"--\\\\tmp\\n\";\n//\t\tcerr<<dp[i]<<endl;\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\tincID(j, m[i - 1], m[i]) { ms.erase(dp[j]); }\n\tms.insert(dp[i - 1]);\n\treturn *(ms.rbegin());\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst lint INF=1e18;\n\nint n;\nlint L,t;\nlint ar[100005];\nlint dp[100005];\nlint dp2[100005];\nint main(){\n  cin>>n>>L>>t;\n  REP(i,n) scanf(\"%lld\",&ar[i]);\n  ar[n]=L;\n\n  ++n;\n  REP(i,n+1) dp[i]=dp2[i]=INF;\n  dp[0]=ar[0];\n\n  int j=0;\n  REP(i,n){\n    if(i>0) chmin(dp[i],dp2[i]+ar[i]+ar[i-1]*2);\n    chmin(dp2[i+1],dp2[i]);\n    while(j+1<n && (ar[j]-ar[i])*2<=t) ++j;\n    if(j+1<n){\n      chmin(dp2[j+1],dp[i]-ar[i]*3);\n    }\n    chmin(dp[j],dp[i]+t+ar[j]-ar[i]);\n  }\n  lint res=dp[n-1];\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll> X;\n  X.push_back(0);\n  rep(i,n){\n    ll x;cin>>x;\n    X.push_back(x);\n  }\n  X.push_back(e);\n  vector<ll> dp;\n  rep(i,n+1){\n    dp.push_back(LINF);\n  }\n  dp[0] = 0;\n\n  rep(i,n){\n    int j;\n    j = n;\n    chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j = lower_bound(all(X), X[i+1] + t + 0.1) - X.begin();\n    if(X[j] == X[i+1] + t/2.0) j++;\n\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j--;\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n      j = lower_bound(all(X), X[i+1] + t/2.0 + 0.1) - X.begin();\n    if(X[j] == X[i+1] + t/2.0) j++;\n\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n\n    j--;\n    if(j<=n) chmin(dp[j], dp[i] + X[i+1]-X[i] + max(2*(X[j]-X[i+1]), t) + X[j] - X[i+1]);\n  }\n\n  cout<<dp[n] + e - X[n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n#define INF 1e15+7\nstruct SegmentTree {\nprivate:\n    int n; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+1),seg2(n+1);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-x[i]*2+x[mid+1]*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,l+1);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n#define double long double\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\n//typedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-15;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint n,e,t,x[2010] = {},dp[2010][2010];\n\tcin >> n >> e >> t;\n\tif(n > 2000) return 0;\n\tfor(int i = 1;i <= n;i++) cin >> x[i];\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n;j++) dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tint mi = INF;\n\t\tfor(int j = 0;j <= i;j++){\n\t\t\tif(i == j) dp[i][j] = mi;\n\t\t\telse{\n\t\t\t\tdp[i][j] = dp[i - 1][j] + x[i] - x[i - 1];\n\t\t\t\tmi = min(mi,dp[i][j] + max(t,(x[i] - x[j + 1]) * 2));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][n] + e - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef double db;\ntypedef vector<db> vdb;\n#define INF 10000000000\nint main() {\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tvl x(n + 10, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint l = 0;\n\tvi p(n + 1);\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile ((x[i] - x[l]) * 2 > t)l++;\n\t\tp[i] = l;\n\t}\n\tvl dp(n + 10, INF);\n\tdp[0] = e;\n\tvl dp2(n + 10, INF);\n\tdp2[0] = INF; dp2[1] = INF; dp2[2] = e-2*x[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tll mi = INF;\n\t\tdp[i] = dp[max(0,p[i]-1)] + t;\n\t\tfor (int j = 0; j+1<p[i]; j++) {\n\t\t\tmi = min(mi, dp[j] -2 *  x[j + 1]);\n\t\t}\n\t\t//mi = dp2[p[i]];\n\t\tdp[i] = min(dp[i],mi+2*x[i]);\n\t\tdp2[i + 2] = min(dp[i + 1], dp[i] - 2 * x[i + 1]);\n\t\t/*for (int i = 0; i <= n; i++) {\n\t\tcout << dp[i] << \" \";\n\t\t}cout << endl;*/\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    if(n>2000)return 0;\n    ll dp[2001]={};\n    rep2(i,1,n){\n        ll temp=1e15;\n        rep(j,i){\n                ll s=x[i]*3-x[j]-x[j+1]*2+max((ll)0,t-(x[i]-x[j+1])*2);\n                temp=min(temp,s+dp[j]);\n        }\n        dp[i]=temp;\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\n\nint n,e,t,p[maxn],ti[maxn];\nll f[maxn];\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)cin>>p[i];\n    for(int i=1;i<=n;i++)\n    for(int j=0;j<i;j++){\n        ll tt = p[i] - p[j+1] + p[i] - p[j+1];\n        if(tt<t)tt=t;\n        tt+=p[i]-p[j];\n        if(f[i]==0||f[i]>tt+f[j])f[i]=tt+f[j];\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nextidx = now + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = now;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\tfor( size_t i = idxmin; i < max( N + 1, idxmin + 50 ); i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[now] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\n#define INF 1e15+7\nstruct SegmentTree {\nprivate:\n    int n; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+1),seg2(n+1);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-x[i]*2+x[mid+1]*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//fold\n#ifndef KHALIL\n#include <bits/stdc++.h>\n#else\n#include \"header.h\"\n#endif\n#define endl '\\n'\n#define mp make_pair\n#define tostr(x) static_cast<ostringstream&>((ostringstream()<<dec<<x)).str()\n#define rep(i,begin,end) for(auto i = begin;i < end;i++)\n#define repr(i,begin,end) for(auto i = begin-1;i >= end;i--)\n#define pb push_back\n#define sz(a) ((int)(a).size())\n#define fi first\n#define se second\n#define abs(a) ((a) < (0) ? (-1)*(a) : (a))\n#define SQ(a) ((a)*(a))\n#define eqd(a,b) (abs(a-b)<1e-9)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate <typename t> t in(t q){cin >> q;return q;}\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v){os << \"[\";for (int i = 0; i < sz(v); ++i) { os << v[i]; if (i != sz(v) - 1) os << \",\";}os << \"]\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const map<T, S>& v){for (auto it : v)os << \"(\" << it.first << \":\" << it.second << \")\";return os;}\ntemplate <typename T, typename S>ostream& operator<<(ostream& os, const pair<T, S>& v){os << \"(\" << v.first << \",\" << v.second << \")\";return os;}\nconst long double PI = acosl(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\ninline int rand(int l,int r){return uniform_int_distribution<int>(l, r)(rng);}\ninline ll rand(ll l,ll r){return uniform_int_distribution<ll>(l, r)(rng64);}\n//endfold\n#define  N  (100'005)\n#define MOD (1'000'000'007ll)\n#define OO (1'050'000'000)\n#define OOL (1'100'000'000'000'000'000ll)\n\n//global\nll x[N];\nll dp[N];\n\nint main(){\n\t//fold\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcout << setprecision(10);\n\t//endfold\n\tll n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,0,n){\n\t\tcin >> x[i];\n\t}\n\tdp[n] = 0;\n\tx[n] = e;\n\tfor (int i = n-1; i >= 0; --i){\n\t\tll k = lower_bound(x+i+1,x+n,x[i]+(t+1)/2)-x;\n\t\tll ans = OOL;\n\t\tfor(int j = k; j < n; j++){\n\t\t\tans = min(ans,2*x[j]+x[j+1]+dp[j+1]-3*x[i]);\n\t\t}\n\t\tk--;\n\t\tans = min(ans,t+x[k+1]-x[i]+dp[k+1]);\n\t\tdp[i] = ans;\n\t}\n\tcout << dp[0]+x[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline int read()\n{\n\tint res, ok = 1;\n\tchar ch;\n\tfor (ch = getchar(); ch < '0' || ch > '9'; ch = getchar())\n\tif (ch == '-')\n\tok = -1;\n\tres = ch - '0';\n\tfor (ch = getchar(); ch >= '0' && ch <= '9'; ch = getchar())\n\tres = res * 10 + ch - '0';\n\treturn res * ok;\n}\nint n, t, e, a[100005], last;\nlong long ans[100005], minn = 1LL << 60;\nint main()\n{\n\tn = read();\n\te = read();\n\tt = read();\n\tfor (int i = 1; i <= n; i++)\n\ta[i] = read();\n\tans[0] = 0;\n\tans[1] = t;\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\twhile (2LL * (a[i] - a[last + 1]) > t)\n\t\t{\n\t\t\tlong long now = ans[last] - 2LL * a[last + 1];\n\t\t\tminn = min (minn, now);\n\t\t\tlast++;\n\t\t}\n\t\tans[i] = ans[i - 1] + t;\n\t\tif (last > 0)\n\t\tans[i] = min (ans[i], minn + 2LL * a[i]);\n\t\tans[i] = min (ans[i], ans[last] + t);\n\t}\n\tprintf (\"%lld\\n\", ans[n] + e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,i, j));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define Pair pair<int, int>\n#define MP(x, y) make_pair(x, y)\n#define fi first\n#define se second\n//#define int long long \n#define LL long long \n#define Fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define Fout(x) {freopen(#x\".out\",\"w\",stdout);}\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)\nchar buf[(1 << 22)], *p1 = buf, *p2 = buf;\nusing namespace std;\nconst int MAXN = 2e5 + 10, mod = 998244353, INF = 1e9 + 10;\nconst double eps = 1e-9;\ntemplate <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}\ntemplate <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}\ntemplate <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}\ntemplate <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}\ntemplate <typename A> inline void debug(A a){cout << a << '\\n';}\ntemplate <typename A> inline LL sqr(A x){return 1ll * x * x;}\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nLL N, E, T, a[MAXN], f[MAXN];\nint main() {\n\tN = read(); E = read(); T = read();\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i = 1; i <= N; i++) a[i] = read();\n\tf[0] = 0; f[1] = T;\n\tLL mn = 1e18, j = 0;\n\tfor(int i = 2; i <= N; i++) {\n\t\twhile(T <= 2 * (a[i] - a[j + 1]) && j < i) chmin(mn, f[j] - 2 * a[j + 1]), j++;\n\t\tchmin(f[i], mn + 2 * a[i]);\n\t\tchmin(f[i], f[j] + T);\n\t}\n\tcout << f[N] + E;\n    return 0;\n}\n/*\n3 9 23333\n1 3 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\n#define mid ((s + e) / 2)\n#define int long long\n\nint n, ed, tad;\nint x[N];\nint dp[N];\nint seg[N * 4];\nint laz[N * 4];\nint get(int l, int r, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn 2e18;\n\tif (l <= s && e <= r)\n\t\treturn seg[v];\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\treturn min(get(l, r, v * 2, s, mid), get(l, r, v * 2 + 1, mid, e));\n}\nvoid add(int l, int r, int val, int v = 1, int s = 0, int e = N) {\n\tif (r <= s || e <= l)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[v] += val;\n\t\tlaz[v] += val;\n\t\treturn;\n\t}\n\tseg[v * 2] += laz[v];\n\tseg[v * 2 + 1] += laz[v];\n\tlaz[v * 2] += laz[v];\n\tlaz[v * 2 + 1] += laz[v];\n\tlaz[v] = 0;\n\tadd(l, r, val, v * 2, s, mid);\n\tadd(l, r, val, v * 2 + 1, mid, e);\n\tseg[v] = min(seg[v * 2], seg[v * 2 + 1]);\n}\nint tmp[N];\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> ed >> tad;\n\tint pnt = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> x[i];\n\t\ttmp[i] = 2e18;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\ttmp[i] = min(tmp[i], tmp[j - 1] + x[j] - x[j - 1] + max(2 * (x[i] - x[j]), tad) + x[i] - x[j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tadd(0, 1, 0 + x[1] - 0 + tad);\n\t\t}\n\t\tadd(0, pnt, (x[i] - x[i - 1]) * 2);\n\t\twhile ((x[i] - x[pnt + 1]) * 2 >= tad) {\n\t\t\tadd(pnt, pnt + 1, (x[i] - x[pnt + 1]) * 2 - tad);\n//\t\t\tcout << \"pnt << \" << pnt << endl;\n\t\t\tpnt++;\n\t\t}\n\t\tadd(0, i - 1, x[i] - x[i - 1]);\n/*\t\tcout << \"all done : \" << endl;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tcout << j << \" > \" << get(j, j + 1) << \"    \"; \n\t\tcout << endl;*/\n\t\tdp[i] = get(0, i);\n//\t\tcout << \"dp[i] : \" << i << \" \" << dp[i] << \" \" << tmp[i] << endl << endl << endl;\n\t\tadd(i, i + 1, dp[i] + x[i + 1] - x[i] + tad);\n\t}\n\tcout << ed - x[n] + dp[n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n;\nlli gl,t;\n\nlli dat[100005]={};\nlli dp[100005]={};\nlli qdp[100005]={};\n\nlli inf = IINF*100LL;\n\nint main(void){\n\tscanf(\"%d%lld%lld\",&n,&gl,&t);\n\treg(i,1,n){\n\t\tscanf(\"%lld\",&dat[i]);\n\t\tqdp[i]=dp[i]=inf;\n\t}\n\tqdp[0]=inf;\n\tdat[0]=0;\n\tdp[0]=0;\n\tint sen=0;\n\trep(i,n+1){\n\t\t//printf(\"dp[%d] .. %lld qdp[%d] .. %lld\\n\",i,dp[i],i,qdp[i]);\n\t\tdp[i] = min(dp[i],qdp[i]);\n\t\tqdp[i+1] = min(qdp[i+1],qdp[i]+2*(dat[i+1]-dat[i]));\n\t\tif(sen<=i)sen=i+1;\n\t\t//printf(\"%d %d\\n\",i,sen);\n\t\twhile(sen<=n && 2*(dat[sen]-dat[i+1])<t){\n\t\t\tdp[sen]=dp[i]+t;\n\t\t\tsen++;\n\t\t}\n\t\tqdp[sen] = min(qdp[sen],2*(dat[sen]-dat[i+1])+dp[i]);\n\t\tdp[i+1]=min(dp[i+1],dp[i]+t);\n\t\t/*\n\t\tdp[i]=dp[i-1]+t;\n\t\trep(j,i){\n\t\t\tdp[i]=min(dp[i],dp[j]+max(2*(dat[i]-dat[j+1]),t));\n\t\t}\n\t\t//printf(\"dp[%d] .. %lld\\n\",i,dp[i]);\n\t\t*/\n\t}\n\t\n\tprintf(\"%lld\\n\",gl+dp[n]);\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nconst long long INF = 1e18;\n\nint n, a[MAXN], e, t;\n\n#define lc (nd<<1)\n#define rc (nd<<1|1)\n\nstruct node {\n\tlong long x, y;\n\tnode()\n\t{ x = y = INF; }\n\tnode(long long _x, long long _y)\n\t{ x = _x, y = _y; }\n\tfriend node operator + (const node &a, const node &b)\n\t{ return (node) {min(a.x, b.x), min(a.y, b.y)}; }\n};\n\nnode dat[MAXN*4];\nlong long tag[MAXN*4];\n\ninline void update(int nd)\n{ dat[nd] = dat[lc]+dat[rc]; }\ninline void put_tag(int nd, int dt)\n{ dat[nd].x += dt, dat[nd].y += dt, tag[nd] += dt; }\ninline void pdw(int nd)\n{\n\tput_tag(lc, tag[nd]);\n\tput_tag(rc, tag[nd]);\n\ttag[nd] = 0;\n}\ninline void modify(int nd, int L, int R, int opl, int opr, int dt)\n{\n\tpdw(nd);\n\tif (L == opl && R == opr) put_tag(nd, dt);\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (opr <= mid) modify(lc, L, mid, opl, opr, dt);\n\t\telse if (opl > mid) modify(rc, mid+1, R, opl, opr, dt);\n\t\telse modify(lc, L, mid, opl, mid, dt), modify(rc, mid+1, R, mid+1, opr, dt);\n\t\tupdate(nd);\n\t}\n}\ninline void modify(int nd, int L, int R, int pos, const node &pt)\n{\n\tpdw(nd);\n\tif (L == R) dat[nd] = pt;\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (pos <= mid) modify(lc, L, mid, pos, pt);\n\t\telse modify(rc, mid+1, R, pos, pt);\n\t\tupdate(nd);\n\t}\n}\ninline node query(int nd, int L, int R, int opl, int opr)\n{\n\tif (opl > opr) return (node) {INF, INF}; \n\tpdw(nd);\n\tif (L == opl && R == opr) return dat[nd];\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (opr <= mid) return query(lc, L, mid, opl, opr);\n\t\telse if (opl > mid) return query(rc, mid+1, R, opl, opr);\n\t\telse return query(lc, L, mid, opl, mid)+query(rc, mid+1, R, mid+1, opr);\n\t}\n}\nconst int root = 1;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tmodify(root, 0, n, 0, (node) {0, -2*a[1]});\n\tint pos = -1;\n\tlong long dpv;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (pos+1 < i && 2ll*(a[i]-a[pos+2]) > t) pos++;\n\t\tdpv = min(query(root, 0, n, 0, pos).y+3ll*a[i]-a[i-1], query(root, 0, n, pos+1, i-1).x+a[i]-a[i-1]+t);\n\t\tmodify(root, 0, n, i, (node) {dpv, dpv-2*a[i+1]});\n\t\tmodify(root, 0, n, 0, i-1, a[i]-a[i-1]);\n\t\t// for (int j = 0; j < i; j++) dp[i][i] = min(dp[i][i], dp[i-1][j]+a[i]-a[i-1]+max(t, 2*(a[i]-a[j+1])));\n\t}\n\tcout << dpv+e-a[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n/////////////\n\nint const N = 2e3 + 41;\nll const INF = 1e18;\n\nll x[N], d[N], t, e;\nint n;\n\nvoid remin(ll &a, ll b){ a = min(a, b); }\n\nvoid solve(){\n\tcin >> n >> e >> t;\n\tassert(n < N);\n\trep(i, 0, n) cin >> x[i];\n\tx[n] = e;\n\trep(i, 0, N) d[i] = INF;\n\td[0] = x[0];\n\trep(i, 0, n) rep(j, i, n){\n\t\tll lt = d[i] + max(t, 2 * (x[j] - x[i]));\n\t\tll rt = lt + x[j+1] - x[i];\n\t\tremin(d[j+1], rt);\n\t}\n\tcout << d[n] << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\nll g(ll l,ll r){\n    ll dis=d[r]-d[l];\n    ll ans=d[l]-d[l-1]+dis;\n    ans+=max(dis*2,t);\n    return ans;\n}\nll f[N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    lol(i,n)cin>>d[i+1];\n    if(n>N)return 0;\n    lol(i,N)f[i]=1e18; f[0]=0;\n    lol(i,n){\n\t//cout<<f[i]<<\" \";\n\tfor(ll j=i+1;j<=n;j++){\n\t    chmin(f[j],f[i]+g(i+1,j));\n\t}\n    }\n    cout<<f[n]+e-d[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 1LL << 62;\n        for (int j = i - 1; j >= 0; --j) {\n            dp[i] = min(dp[i], dp[j] + X[j + 1] - X[j] + \n                    3LL * (X[i] - X[j + 1]) + max((int64_t) 0, (int64_t) T - 2LL * (X[i] - X[j + 1])));\n        }\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define re register\n#define il inline\n#define inf 0x3f3f3f\n\nconst int maxn = 2e5 + 5;\nll n, e, t;\nll a[maxn], f[maxn];\nll q[maxn];\nll ans;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch > '9' || ch < '0') {\n    if (ch == '-')\n      f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint main(int argc, char const *argv[]) {\n  memset(f, inf, sizeof f);\n  n = read(), e = read(), t = read();\n  ll ok = inf;\n  for (int i = 1; i <= n; ++i)\n    a[i] = read();\n\n  f[0] = 0;\n  ll head = 1, tail = 1;\n  for (int i = 1; i <= n; ++i) {\n    while (head <= tail and 2 * (a[i] - a[q[head] + 1]) > t) {\n      ok = min(ok, f[q[head] - 2 * a[q[head]] + 1]);\n      head++;\n    }\n    f[i] = min(f[i], f[q[head]] + t);\n    f[i] = min(f[i], ok + 2 * a[i]);\n    q[++tail] = i;\n  }\n\n  ans = f[n] + e;\n  std::cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nusing ll = long long;\n\nll dfs[2345][2];\nll n, e, t;\nll x[2345];\nll dist[2345];\n\n\nint main(void)\n{\n\tscanf(\"%lld %lld %lld\", &n, &e, &t);\n\tfor (int i = 0; i < n; ++i)scanf(\"%d\", x + i);\n\tdist[0] = x[0];\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tdist[i] = x[i] - x[i - 1];\n\t}\n\tdist[n] = e - x[n - 1];\n\tdfs[0][0] = 0;\n\tdfs[0][1] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tdfs[i][0] = dfs[i - 1][1] + dist[i - 1];\n\t\tll small = dfs[i][0] + t;\n\t\tll rui = 0;\n\t\tfor (int j = i - 1; j >= 0; --j)\n\t\t{\n\t\t\trui += dist[j];\n\t\t\tsmall = min(small, dfs[j][0] + max(rui * 3, rui + t));\n\t\t}\n\t\tdfs[i][1] = small;\n\t}\n\n\tprintf(\"%lld\\n\", dfs[n][1] + dist[n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()+1]>=dp[xx]-2*x[xx+1]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nstruct RMQ {\n    int N;\n    vector<long long> seg;\n\n    RMQ(int n) {\n        N = 1 << (int)log2(n * 2 - 1);\n        seg.resize(N * 2, 1e18);\n    }\n\n    void update(int k, long long v) {\n        for (seg[k += N] = v; k > 1; k >>= 1) {\n            seg[k >> 1] = min(seg[k], seg[k ^ 1]);\n        }\n    }\n\n    long long minimum(int l, int r) {\n        long long res = 1e18;\n        for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = min(res, seg[l++]);\n            if (r & 1) res = min(res, seg[--r]);\n        }\n        return res;\n    }\n};\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n), d(n), ds(n + 1);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    RMQ L(n + 1), R(n + 1);\n    L.update(0, 0);\n    R.update(0, 0);\n\n    for (int i = 1; i <= n; i++) {\n        int ok = i;\n        int ng = -1;\n        while (ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if (T >= 2 * (ds[i - 1] - ds[mid])) ok = mid;\n            else ng = mid;\n        }\n        chmin(dp[i], L.minimum(ok, i) + T);\n        chmin(dp[i], R.minimum(0, ok) + 2 * ds[i - 1]);\n        L.update(i, dp[i]);\n        R.update(i, dp[i] - 2 * ds[i]);\n    }\n\n    cout << dp[n] + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//f[i]=min(f[j]+)\n#include<bits/stdc++.h>\nusing namespace std;\nlong long n,e,t,f[10001],a[10001];\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tf[i]=f[i-1]+(a[i]-a[i-1])+t;\n\t\tfor (int j=i-1; j>=1; --j)\n\t\t\tf[i]=min(f[i],f[j-1]+(a[i]-a[j])*3+(a[j]-a[j-1])+max(1ll*0,t-2*(a[i]-a[j]))); \n//\t\tcout<<f[i]<<' ';\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<long long> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        chmin(dp[i + 1], dp[i] + T);\n        for (int j = i; j < n; j++) {\n            chmin(dp[j + 1], dp[i] + 2 * (ds[j] - ds[i]) + max(0LL, T - 2 * (ds[j] - ds[i])));\n        }\n    }\n\n    cout << min(dp[n] + E, E + ds.back() * 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctime>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string.h>\nusing namespace std; \nlong long x[100008],dp[100008];long long t,e;\nvoid update(long long i,long long j)\n{\n\tdp[i]=min(dp[i],dp[j]+max(t,2*(x[i]-x[j+1])));\n}\nint main()\n{\n\tlong long n;cin>>n;cin>>e>>t;\n\tfor(long long i=1;i<=n;i++) cin>>x[i];for(long long i=0;i<100005;i++) dp[i]=2e9;\n\tdp[0]=0;long long j=0;long long mst=2e9,msi=0;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tupdate(i,i-1);\n\t\twhile((x[i]-x[j+1])*2>t)\n\t\t{\n\t\t\tlong long tt=dp[j]+2*(x[0]-x[j+1]);\n\t\t\tif(tt<mst) mst=tt,msi=j;j++;\n\t\t}\n\t\tupdate(i,j);update(i,max(j-1,(long long)0));update(i,j+1);\n\t\tupdate(i,msi);\n\t}\n\tcout<<dp[n]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nLL t;\nstruct UnionFind{\n    vector<int> par;\n    vector<LL> w;\n    UnionFind(int n){\n        par = vector<int>(n,-1);\n        w=vector<LL>(n,0);\n    }\n    int root(int x){\n        if(par[x]<0){\n            return x;\n        }else{\n            return par[x]=root(par[x]);\n        }\n    }\n    void unite(int x,int y, LL a){\n        x=root(x);\n        y=root(y);\n        if(x!=y){\n            if(par[x]<par[y]) swap(x,y);\n            par[y] += par[x];\n            par[x] = y;\n        }\n        w[y]=w[y]+w[x]+a;\n        return;\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    int size(int x){\n        return -par[root(x)];\n    }\n    LL rest(int x){\n        return max(0ll,t-w[root(x)]);\n    }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    LL e;\n    cin >> n >> e >> t;\n    LL ans=e;\n    vector<int> x(n),dx(n-1);\n    REP(i,n) cin >> x[i];\n    REP(i,n-1) dx[i]=(x[i+1]-x[i])*2;\n    UnionFind P(n);\n    typedef tuple<LL,int,int> TP;//cost,l,r\n    priority_queue<TP> Q;\n    REP(i,n-1){\n        Q.push(make_tuple(min(t,2*t-dx[i]),i,i+1));\n    }\n    while(!Q.empty() && get<0>(Q.top())>0){\n        LL c,l,r;\n        tie(c,l,r)=Q.top();\n        //cerr<< c << ' ' << l << ' ' << r << endl;\n        Q.pop();\n            //cout << c << ' ' << l << ' ' <<r <<endl;\n\n        if((l==0 && r==n-1) || (l==0 && !P.same(r,r+1)) || (r==n-1 && !P.same(l-1,l)) || (!P.same(l-1,l) && !P.same(r,r+1))){\n            //cout << c << ' ' << l << ' ' <<r <<endl;\n            P.unite(l,r,dx[l+P.size(l)-1]);\n            //cout <<P.w[P.root(l)]<<endl;\n            if(r!=n-1){\n                int newr=r+P.size(r+1);\n                LL r1=P.rest(l),r2=P.rest(newr);\n                Q.push(make_tuple(min(t,r1+r2-dx[r]),l,newr));\n            }\n            if(l!=0){\n                int newl=l-P.size(l-1);\n                LL r1=P.rest(r),r2=P.rest(newl);\n                Q.push(make_tuple(min(t,r1+r2-dx[l-1]),newl,r));\n            }\n        }\n    }\n\n    REP(i,n){\n        if(P.par[i]<0)ans+=max(t,P.w[i]);\n    }\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvint v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tn++;\n\tvll dp(n+1,INFL);\n\tdp[0]=0;\n\trep(i,n){\n\t\treep(j,i+1,n+1){\n\t\t\tif(2*(v[j-1]-v[i])<=T){\n\t\t\t\tmins(dp[j],dp[i]+T);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll dp[1 << 17],x[1<<17];\nint main() {\n\tint n; cin >> n;\n\tll e, t; cin >> t >> e;\n\trep(i, n) {\n\t\tcin >> x[i];\n\t}\n\tx[n] = t;\n\tfill(dp, dp + n + 2, INF);\n\tdp[0] = x[0];\n\trep(i, n+1) {\n\t\tRep(j, i + 1, n + 2) {\n\t\t\tdp[j] = min(dp[j], x[j]-x[i] + max(e, 2 * (x[j - 1] - x[i]))+dp[i]);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 1e6 + 10, md = 1e9 + 7;\nint p = 31;\nstring s[3];\nint n[3];\nint pw[MAXN], h[3][MAXN];\nvector <pair <int, int>> suffix;\nint get(int l, int r, int index) {\n    return h[index][r] - h[index][l] * pw[r - l];\n}\nint length(pair <int, int> a, pair <int, int> b) {\n    int l = 0, r = min(n[a.second] - a.first, n[b.second] - b.first) + 1;\n    while (r - l > 1) {\n        int mid = (l + r) / 2;\n        if (get(a.first, a.first + mid, a.second) == get(b.first, b.first + mid, b.second))\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\nbool cmp(pair <int, int> a, pair <int, int> b) {\n    int l = length(a, b);\n    if (l == n[a.second] - a.first)\n        return true;\n    if (l == n[b.second] - b.second)\n        return false;\n    return s[b.second][b.first + l] > s[a.second][a.first + l];\n}\nint cnt[3][MAXN][3];\nint in[3][MAXN];\nstruct K{\n    pair <int, int> left, right;\n    int l;\n} a1;\nbool cmp1(K a, K b) {\n    return a.l > b.l;\n}\npair <int, int> par[3][MAXN];\npair <int, int> find(pair <int, int> a) {\n    pair <int, int> now = par[a.second][a.first];\n    if (par[now.second][now.first] == now)\n        return now;\n    return par[a.second][a.first] = find(now);\n}\nint32_t main () {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    pw[0] = 1;\n    for (int i = 1; i < MAXN; ++i)\n        pw[i] = pw[i - 1] * p;\n    cin >> s[0] >> s[1] >> s[2];\n    for (int now = 0; now < 3; ++now) {\n        n[now] = s[now].size();\n        for (int i = 1; i <= n[now]; ++i) {\n            h[now][i] = h[now][i - 1] * p + s[now][i - 1];\n            suffix.push_back({i - 1, now});\n            ++cnt[now][i - 1][now];\n            par[now][i - 1] = {i - 1, now};\n        }\n    }\n    sort(suffix.begin(), suffix.end(), cmp);\n    vector <K> vctr;\n    int sz = suffix.size();\n    for (int i = 0; i < sz - 1; ++i) {\n        a1.left = suffix[i];\n        a1.right = suffix[i + 1];\n        a1.l = length(suffix[i], suffix[i + 1]);\n        // cout << a1.l << ' ';\n        vctr.push_back(a1);\n    }\n    sort(vctr.begin(), vctr.end(), cmp1);\n    int point = 0, now = 0;\n    vector <int> res;\n    for (int l = n[0]; l; --l) {\n        while (point < sz - 1 && vctr[point].l >= l) {\n            pair <int, int> v = find(vctr[point].left), u = find(vctr[point].right);\n            if (u == v)\n                continue;\n            int cur = 1;\n            for (int i = 0; i < 3; ++i)\n                cur *= cnt[v.second][v.first][i] + cnt[u.second][u.first][i];\n            cur %= md;\n            int cpy = cur;\n            cur += (in[v.second][v.first] + in[u.second][u.first]) * (md - 1) % md;\n            if (cur >= md)\n                cur %= md;\n            now += cur;\n            if (now >= md)\n                now %= md;\n            par[v.second][v.first] = u;\n            in[u.second][u.first] = cpy;\n            for (int i = 0; i < 3; ++i)\n                cnt[u.second][u.first][i] += cnt[v.second][v.first][i];\n            ++point;\n        }\n        res.push_back(now);\n    }\n    int mn = min(n[0], min(n[1], n[2]));\n    reverse(res.begin(), res.end());\n    for (int i = 0; i < mn; ++i)\n        cout << res[i] << ' ';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(st2.find(dp[last] - x[last] + t));\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,e,T;\n\tcin>>n>>e>>T;\n\tvi in(n+1);\n\trep(i,n)cin>>in[i+1];\n\tin.pb(e);\n\tn++;\n\tvi dp(n+1,inf),dp1(n+1,inf);\n\tdp[0]=0;\n\tdp1[0]=-2*in[1];\n\tint t=1;\n\trep(i,n-1){\n\t\twhile(!(2*(in[i+1]-in[t])<T))t++;\n\t\tcmin(dp[i+1],dp[t-1]+T);\n\t\tif(t-2>=0)cmin(dp[i+1],dp1[t-2]+2*in[i+1]);\n\t\tdp1[i+1]=min(dp[i+1]-2*in[i+2],dp1[i]);\n\t}\n\tcout<<in[n]+dp[n-1]<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 10000000000000000;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    for (int i = 0; i < n; i++) cin >> x[i];\n    ll ans = e;\n    vector<ll> dp(n + 1, INF);\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] = min(dp[i], dp[j] + max(t, (x[i - 1] - x[j]) * 2));\n        }\n    }\n    ans += dp[n];                    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<assert.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 1 << 17;\nconst int MM = 1000000007;\n\nstruct Tree{\n\tll t[MX*2];\n\tvoid update(int x, ll v){\n\t\tx += MX; t[x] = v;\n\t\twhile(x > 1){\n\t\t\tx /= 2;\n\t\t\tt[x] = min(t[x*2], t[x*2+1]);\n\t\t}\n\t}\n\tll read(int s, int e){\n\t\ts += MX, e += MX;\n\t\tll r = 1e18;\n\t\twhile(s <= e){\n\t\t\tif( s&1 ) r = min(t[s++], r);\n\t\t\tif(~e&1 ) r = min(t[e--], r);\n\t\t\ts /= 2, e /= 2;\n\t\t}\n\t\treturn r;\n\t}\n}t1, t2;\n\nll D[MX];\nint X[MX];\nint N, T, E;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", X+i);\n\tint k = 0;\n\tt1.update(0, -X[1]*2);\n\tfor(int i = 1; i <= N; i++){\n\t\twhile(2*(X[i] - X[k]) >= T) k++;\n\t\t// 0~k-1 : 2*(X[i] - X[k]) > T\n\t\tD[i] = min(t1.read(0, k-2) + 3ll*X[i], t2.read(k-1, i-1) + X[i] + T);\n\t\tt1.update(i, D[i] - X[i] - X[i+1]*2);\n\t\tt2.update(i, D[i] - X[i]);\n\t}\n\tprintf(\"%lld\\n\", D[N] + (E-X[N]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nconst int mn = 1 << 17;\nll dp[mn],x[mn];\nint n, nn; ll dat[2][mn];\nvoid init() {\n\tnn = 1;\n\twhile (nn < n)nn *= 2;\n\trep(i, 2 * nn - 1)dat[0][i] = dat[1][i] = INF;\n}\nvoid update(int id, int k, ll a) {\n\tk += nn - 1;\n\tdat[id][k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[id][k] = min(dat[id][k * 2 + 1], dat[id][k * 2 + 2]);\n\t}\n}\nll query(int id,int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[id][k];\n\telse {\n\t\tll vl = query(id, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(id, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tcin >> n;\n\tinit();\n\tll e, t; cin >> t >> e;\n\trep(i, n) {\n\t\tcin >> x[i];\n\t}\n\tx[n] = t;\n\tfill(dp, dp + n + 2, INF);\n\tdp[0] = x[0];\n\tupdate(0, 0, 0);\n\tupdate(1, 0, -2*x[0]);\n\trep1(i, n) {\n\t\tint loc = lower_bound(x, x + n + 1, x[i-1] - e / 2) - x;\n\t\tll mi1 = query(1, 0, loc, 0, 0, nn) + x[i] + 2*x[i - 1];\n\t\tll mi2 = query(0, loc, i, 0, 0, nn) + e + x[i];\n\t\tdp[i] = min(mi1, mi2);\n\t\tupdate(0, i, dp[i] - x[i]);\n\t\tupdate(1, i, dp[i] - 3 * x[i]);\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x; \n}\nconst int N = 131072+5;\nconst int64 INF = 0x3f3f3f3f3f3f3f3f;\nint n, w[N], ch[2][N], c[N];\nint64 d[N], l = INF, r, mid, ans, pre[N];\nvector<pair<int64, int64> > f[N];\ninline bool cmpx(pair<int64, int64> a, pair<int64, int64> b) { return a.first < b.first; }\ninline bool cmpy(pair<int64, int64> a, pair<int64, int64> b) { return a.second < b.second; }\ninline void insert(vector<pair<int64, int64> > &ls, vector<pair<int64, int64> > &rs, int x)\n{\n    int sy = ls.size(), sz = rs.size();\n    sort(ls.begin(), ls.end(), cmpy);\n    sort(rs.begin(), rs.end(), cmpx);\n    pre[0] = rs[0].second;\n    for(int i = 1; i < sz; ++i) pre[i] = min(pre[i-1], rs[i].second);\n    for(int i = 0, j = sz-1; i < sy; ++i)\n    {\n        while(~j&&ls[i].second+rs[j].first-d[x]*2 > mid) --j;\n        if(~j) f[x].push_back(make_pair(ls[i].first, pre[j]));\n    }\n}\nbool valid(int x)\n{\n    f[x].clear();\n    if(!c[x]) return f[x].push_back(make_pair(d[x], d[x])), f[x].size();\n    int y = ch[0][x], z = ch[1][x];\n    if(!valid(y)||!valid(z)) return false;\n    insert(f[y], f[z], x), insert(f[z], f[y], x);\n    return f[x].size();\n}\nvoid dfs(int x)\n{\n    d[x] += w[x];\n    if(!c[x]) return l = min(l, d[x]), void(r = max(r, d[x]<<1));\n    d[ch[0][x]] = d[ch[1][x]] = d[x];\n    dfs(ch[0][x]), dfs(ch[1][x]);\n}\nint main()\n{\n    n = read();\n    for(int i = 2; i <= n; ++i)\n    {\n        int x = read(); w[i] = read();\n        ch[c[x]++][x] = i;\n    }\n    dfs(1);\n    while(l <= r)\n    {\n        mid = (l+r)>>1;\n        if(valid(1)) ans = mid, r = mid-1;\n        else l = mid+1;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i-1;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tfor(int j=Max;j>=0;j--){\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t/*\tif(max(t,(x[i]-x[j+1])*2)+dp[j]>dp[i])\n\t\t\tbreak;*/\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define PB push_back\n#define PF push_front\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn = 1e5 + 100;\nconst ll inf = 1e18;\n\nll x[maxn], dp[maxn];\n\nclass node {\n\tpublic:\n\t\tll mnm;\n\t\tll lzy;\n\t\tll cng;\n\t\tnode () {\n\t\t\tmnm = inf;\n\t\t}\n};\n\nnode seg[4 * maxn];\n\nvoid propagate (int, int, int);\n\nll get (int id, int L, int R, int l, int r) {\n\tif (L == l and R == r)\n\t\treturn seg[id].mnm;\n\tpropagate (id, L, R);\n\tint mid = (L + R) >> 1;\n\tll ret = inf;\n\tif (mid > l)\n\t\tret = min(ret, get(2 * id + 0, L, mid, l, min(mid, r)));\n\tif (mid < r)\n\t\tret = min(ret, get(2 * id + 1, mid, R, max(l, mid), r));\n\treturn ret;\n}\n\nvoid update(int id, int L, int R, int l, int r, ll val) {\n\tif (L == l and R == r) {\n\t\tseg[id].mnm += val;\n\t\tseg[id].lzy += val;\n\t\treturn;\n\t}\n\tpropagate (id, L, R);\n\tint mid = (L + R) >> 1;\n\tif (mid > l)\n\t\tupdate(2 * id + 0, L, mid, l, min (mid, r), val);\n\tif (mid < r)\n\t\tupdate(2 * id + 1, mid, R, max (l, mid), r, val);\n\tseg[id].mnm = min (seg[2 * id + 0].mnm, seg[2 * id + 1].mnm);\n}\n\nvoid change(int id, int L, int R, int l, int r, ll val) {\n\tif (L == l and R == r) {\n\t\tseg[id].mnm = val;\n\t\tseg[id].cng = val;\n\t\tseg[id].lzy = 0;\n\t\treturn;\n\t}\n\tpropagate(id, L, R);\n\tint mid = (L + R) >> 1;\n\tif (mid > l)\n\t\tchange(2 * id + 0, L, mid, l, min (mid, r), val);\n\tif (mid < r)\n\t\tchange(2 * id + 1, mid, R, max (l, mid), r, val);\n\tseg[id].mnm = min(seg[2 * id + 0].mnm, seg[2 * id + 1].mnm);\n}\n\nvoid propagate (int id, int L, int R) {\n\tint mid = (L + R) >> 1;\n\tif (seg[id].cng != 0)\n\t\tchange(2 * id + 0, L, mid, L, mid, seg[id].cng);\n\tif (seg[id].lzy != 0)\n\t\tupdate(2 * id + 0, L, mid, L, mid, seg[id].lzy);\n\tseg[id].lzy = seg[id].cng = 0;\n}\n\nll dis (int fi, int se) { return abs (x[fi] - x[se]); }\n\nint main () {\n\tios_base::sync_with_stdio (false);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tmemset (dp, 63, sizeof dp);\n\tdp[0] = 0;\n\tint ptr = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tchange (1, 1, n + 1, i, i + 1, dp[i - 1] + dis(i - 1, i) + t);\n\t\tif (i != 1)\n\t\t\tupdate (1, 1, n + 1, 1, i, 3*dis (i - 1, i));\n\t\tif (ptr != i)\n\t\t\tupdate (1, 1, n + 1, ptr, i, -2 * dis (i - 1, i)); \n\t\twhile (2 * (x[i] - x[ptr]) > t) {\n\t\t\tupdate (1, 1, n + 1, ptr, ptr + 1, 2 * dis(ptr, i) - t);\n\t\t\tptr ++;\n\t\t}\n\t\tdp[i] = get (1, 1, n + 1, 1, i + 1);\n//\t\tcout << dp[i] << endl;\n//\t\tdp[i] = min (dp[i], dp[j-1] + dis(j-1, j) + 3*dis(j, i) + max(0ll,t-2*dis(j, i)));\n\t}\n\tcout << dp[n] + e - x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define Lsn (x<<1)\n#define Rsn (x<<1|1)\n#define Mid (L+R>>1)\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst ll oo=1ll<<50;\n\nll f[N];\nint d[N],E,T,n,l,r,res;\n\nll Qv;\nint Ql,Qr,Qx;\n\nstruct SegTree{\n\tll mn[N*4];\n\tSegTree(){\n\t\tFor(i,0,N*4) mn[i]=oo;\n\t}\n\tvoid Modify(int x,int L,int R){\n\t\tmn[x]=min(mn[x],Qv);\n\t\tif (L==R) return;\n\t\tif (Qx<=Mid) Modify(Lsn,L,Mid);else Modify(Rsn,Mid+1,R);\n\t}\n\tll Query(int x,int L,int R){\n\t\tif (Ql<=L&&R<=Qr) return mn[x];\n\t\tll res=oo;\n\t\tif (Ql<=Mid) res=min(res,Query(Lsn,L,Mid));\n\t\tif (Qr>Mid) res=min(res,Query(Rsn,Mid+1,R));\n\t\treturn res;\n\t}\n} S1,S2;\n\nint main(){\n\tn=IN(),E=IN(),T=IN();\n\tFor(i,1,n+1) d[i]=IN();\n\tFor(i,0,N) f[i]=oo;\n\tf[0]=0;\n\tFor(i,1,n+1){\n\t\tQx=i,Qv=f[i-1]+d[i]-d[i-1]-3ll*d[i];\n\t\tS1.Modify(1,1,n);\n\t\tQx=i,Qv=f[i-1]+d[i]-d[i-1]-d[i];\n\t\tS2.Modify(1,1,n);\n\t\t\n\t\tl=1,r=i;res=0;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r>>1);\n\t\t\tif (2*(d[i]-d[mid])>T) res=mid,l=mid+1;else r=mid-1;\n\t\t}\n\t\tQl=1,Qr=res;\n\t\tif (Ql<=Qr) f[i]=min(f[i],S1.Query(1,1,n)+3ll*d[i]);\n\t\tQl=res+1,Qr=i;\n\t\tif (Ql<=Qr) f[i]=min(f[i],S2.Query(1,1,n)+T+d[i]);\n\t\t/*\n\t\tFor(j,1,i+1){\n\t\t\tf[i]=min(f[i],f[j-1]+d[j]-d[j-1]+max(2*(d[i]-d[j]),T)+d[i]-d[j]);\n\t\t}\n\t\t*/\n\t}\n\tcout<<f[n]+E-d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int64 i = 0; i < (int64)(n); i++)\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nint main()\n{\n  int N, E, T, X[100001] = {};\n\n  cin >> N >> E >> T;\n  for(int i = 1; i <= N; i++) {\n    cin >> X[i];\n  }\n\n  vector< int64 > dp1(N + 1, INF);\n  dp1[0] = 0;\n  for(int i = 1; i <= N; i++) {\n    for(int j = i - 1; j >= 0; j--) { // この区間を往復する\n\n      int64 need = dp1[j];\n      need += X[i] - X[j];\n      need += X[i] - X[j + 1];\n      need = max(need, dp1[j] + (X[j + 1] - X[j]) + T);\n      need += X[i] - X[j + 1];\n\n      dp1[i] = min(dp1[i], need);\n    }\n  }\n\n  cout << dp1.back() + (E - X[N]) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\t//freopen(\"i.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long n, e, t;\n\tcin >> n >> e >> t;\n\t\n\tlong long arr[n+2];\n\tfor(int i = 1;i <= n;i++) cin >> arr[i];\n\tarr[0] = 0;\n\tlong long far[n+2];\n\tlong long dp[n+2];\n\tmultiset<long long> close;\n\tdp[0] = 0;\n\tfar[0] = -2 * arr[1];\n\tclose.insert(0);\n\t\n\tint c = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\t///from c onwards, add t, before c, add 2 * (arr[i] - arr[j+1]);\n\t\twhile(2 * (arr[i] - arr[c+1]) > t){\n\t\t\tclose.erase(dp[c] - arr[c]);\n\t\t\tc++;\n\t\t}\n\t\t\n\t\tdp[i] = 10234567890123242;\n\t\tif(c != 0){\n\t\t\tdp[i] = min(dp[i], far[c-1] + 3 * arr[i]);\n\t\t}\n\t\tif(!close.empty()){\n\t\t\tlong long v = *(close.begin());\n\t\t\t//cout << i << \" \" << v << \"\\n\";\n\t\t\tdp[i] = min(dp[i], v + t + arr[i]);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfar[i] = dp[i] - 2 * arr[i+1] - arr[i];\n\t\tfar[i] = max(far[i],far[i-1]);\n\t\tclose.insert(dp[i] - arr[i]);\n\t}\n\t\n\t//for(int i = 1;i <= n;i++) cout << dp[i] << \" \";\n\t\n\tcout << dp[n] + (e-arr[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint f[101010];\nint a[101010];\nint main()\n{\n\tint n,e,t,now=0,mi;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tf[0]=0;\n\tf[1]=t;\n\tmi=f[0]-2*a[1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile((a[i]-a[now])*2>t)\n\t\t\tnow++;\n\t\tf[i]=f[now-1]+t;\n\t\tf[i]=min(f[i],mi+2*a[i]);\n\t\tif(i<n)\n\t\t\tmi=min(mi,f[i-1]-2*a[i]);\n\t}\n\tprintf(\"%lld\",(long long)e+f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\n\ninline void chk_min(ll &a,ll b){ if(a>b) a=b;}\n\nstruct Queue\n{\n\tint q[MAXN],hd,tl;\n\tQueue(void){ hd=tl=0;}\n\tinline bool empty(void){ return hd>=tl;}\n\tinline int front(void){ return q[hd+1];}\n\tinline int back(void){ return q[tl];}\n\tinline void push(int x){ q[++tl]=x;}\n\tinline void pop(void){ ++hd;}\n}q;\n\nint a[MAXN];\nll dp[MAXN],preMn[MAXN];\n\nint main(void)\n{\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\n\tmemset(dp,0x3f,sizeof(dp));\n\t\n\tdp[1]=t;\n\tq.push(1);\n\tpreMn[1] = min(dp[1]-2*a[2], 0ll);\n\tfor(int i=2; i<=n; ++i)\n\t{\n\t\twhile(!q.empty() && (a[i]-a[q.front()+1])*2 > t) q.pop();\n\t\t\n\t\tdp[i]=dp[i-1]+t;\n\t\tchk_min(dp[i], max(t, (a[i]-a[1])*2));\n\t\t\n\t\tif(!q.empty())\n\t\t\tchk_min(dp[i], dp[q.front()]+t),\n\t\t\tchk_min(dp[i], preMn[q.front()-1]+2*a[i]);\n\t\telse chk_min(dp[i], preMn[i-1]+2*a[i]);\n\t\t\n\t\tpreMn[i] = min(preMn[i-1], dp[i]-2*a[i+1]);\n\t\tq.push(i);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100000;\nconst ll INF = (1ll<<60);\nll dp[MAXN + 5], a[MAXN + 5], T;\nint que[MAXN + 5], s, t;\nll f1(int x) {\n\treturn dp[x] - a[x] - 2*a[x+1];\n}\nll f2(int x) {\n\treturn T + 2*a[x+1];\n}\nint main() {\n\tint N, M;\n\tscanf(\"%d%d%lld\", &N, &M, &T);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%lld\", &a[i]);\n\ta[N+1] = M; ll p = INF;\n\ts = 1, t = 0;\n\tfor(int i=1;i<=N+1;i++) {\n\t\tdp[i] = INF;\n\t\twhile( s <= t && f1(que[t]) + f2(que[t]) >= f1(i-1) + f2(i-1) )\n\t\t\tt--;\n\t\tque[++t] = i-1;\n\t\twhile( s <= t && f2(que[s])-2*a[i] <= 0 ) {\n\t\t\tp = min(p, f1(que[s]));\n\t\t\ts++;\n\t\t}\n\t\tdp[i] = min(p, f1(que[s]) + f2(que[s]) - 2*a[i]) + 3*a[i];\n\t}\n\tprintf(\"%d\\n\", min(dp[N+1], dp[N]+M-a[N]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define sec second\nusing namespace std;\n\n\nconst int MAXN=1e5+100;\nconst ll INF=1e17;\nll x[MAXN],dp[MAXN],dp2[MAXN];\nint main() {\n   // cout << \"HI\" <<endl;\n    ll n,E,T;\n    cin>>n>>E>>T;\n    x[0]=0;\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n        x[i]*=2;\n        dp[i]=INF;\n    }\n    E*=2;\n    \n    dp2[0]=-x[1]*2;\n    for(int i=1;i<=n;i++){\n        int j=upper_bound(x,x+n,(x[i]-T))-x;\n        j-=2;\n        if(j>=0){\n            dp[i]=dp2[j]+x[i]*2;\n        }\n        \n        dp[i]=min(dp[i-1]+2*T,dp[i]);\n        dp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n       // cout<<i<<' '<<dp[i]<<' '<<dp2[i]<<' '<<j<<endl;\n        \n    }\n    \n    cout<<(dp[n]+E)/2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define LL long long\nusing namespace std;\nmultiset<LL> s1, s2;\nLL dp[110000], dp2[110000];\nint x[110000], n, E, T;\nint main(){\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tdp2[0] = T;s1.insert(T);\n\tfor(int i = 1, j = 0; i <= n; i++){\n\t\tscanf(\"%d\", &x[i]);\n\t\twhile(j < i && 2 * (x[i] - x[j + 1]) >= T){\n\t\t\ts1.erase(s1.find(dp2[j]));\n\t\t\tdp2[j] = dp2[j] - T - 2 * (x[j + 1]);\n\t\t\ts2.insert(dp2[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp2[i] = (((LL)1)<<50);\n\t\tif(!s1.empty()) dp[i] = max(dp[i], *s1.begin() + x[i]);\n\t\tif(!s2.empty()) dp[i] = min(dp[i], *s2.begin() + (LL)3 * x[i]);\n\t\tdp2[i] = dp[i] - x[i] + T; \n\t\ts1.insert(dp2[i]);\n\t}\n\tcout<<dp[n] - x[n] + E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, T, E, A[N];\nlong long dp[N];\nint main()\n{\n    scanf(\"%d%d%d\", &n, &E, &T);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    int r = 1;\n    long long Mn = 1e18;\n    for (int i = 1; i <= n; i++)\n    {\n        while ((A[i] - A[r]) * 2 >= T)\n            Mn = min(Mn, dp[r - 1] - A[r] * 2), r ++;\n        dp[i] = min(dp[r - 1] + T, Mn + A[i] * 2);\n    }\n    return !printf(\"%lld\\n\", dp[n] + E);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <vector>\n#define MAXN 100005\n#define LL long long\nusing namespace std;\nint n, e, t;\nvector<int> num;\nLL work(int i, int j)\n{\n    LL tmp = 0, xx = 0;\n    for(int k = i; k < j; k++)\n    {\n        if((num[j - 1] - num[i]) * 2 + xx < t)\n        {\n            tmp += (t - (num[j - 1] - num[i]) * 2 - xx);\n            xx += (t - (num[j - 1] - num[i]) * 2 - xx);\n        }\n    }\n    return tmp;\n}\nint main()\n{\n    scanf(\"%d%d%d\", &n, &e, &t);\n    num.clear();\n    for(int x, i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x);\n        num.push_back(x);\n    }\n    LL sum = 0;\n    sum += num[0] + e - num[n - 1];\n    for(int j, i = 0; i < n; i = j)\n    {\n        LL tmp = 0;\n        j = i;\n        while(j < n && num[j] - num[i] <  t) j++;\n        tmp += 3LL * (num[j - 1] - num[i]);\n        tmp += work(i, j);\n\n        if(j < n)\n        {\n            LL temp = 3LL * (num[j] - num[i]);\n            temp += work(i, j + 1);\n            if(tmp > temp)\n            {\n                j++;\n                sum += temp;\n            }\n            else\n                sum += tmp;\n        }\n        else\n        {\n            sum += tmp;\n        }\n        if(j < n) sum += num[j] - num[j - 1];\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll INF = 1LL << 60;\n\nint N, E, T;\nint x[100010];\nll dp[100010];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcin >> x[i];\n\t\tdp[i] = INF;\n\t}\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tdp[i] = min(dp[i], dp[j] + max(x[j+1]-x[j]+T, (x[i]-x[j]+x[i]-x[j+1])) + x[i] - x[j+1]);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", dp[N] + E - x[N]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n,m,t;\n  cin >> n >> m >> t;\n  ll a[n+2];\n  rep(i,n) R a[i+1];\n  a[0]=0;\n  a[n+1]=m;\n  n++;\n  ll dp[n+1];\n  fill(dp,dp+n+1,MAXL);\n  dp[0]=0;\n  rep(i,n) {\n    REP(j,i,n) {\n      ll d=a[j]-a[i];\n      d=max(t+d,d*3);\n      if(!j) d=0;\n      dp[j+1]=min(dp[j+1],d+a[j+1]-a[j]+dp[i]);\n    }\n  }\n  pr(dp[n]);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 5;\n\nint A[N], n, T, E, dp[N];\n\nint calc(int x, int y) {\n\tif(y == x + 1) return dp[x] + A[y] - A[x] + T;\n\telse return dp[x] + A[x + 1] - A[x] + (A[y] - A[x + 1]) * 3 + max(0LL, T - (A[y] - A[x + 1]) * 2);\n}\n\nmain() {\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%lld\", &A[i]);\n\tint ans = 1e18, res = 0;\n\tdp[0] = 0;\n\tint cur = 0;\n\tdp[1] = A[1] + T;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tdp[i] = 1e18;\n\t\t//for(int j = 0; j < i; ++ j)\n\t\twhile(cur + 1 < i && calc(cur, i) >= calc(cur + 1, i)) ++ cur;\n\t\twhile(1) {\n\t\t\tint t = cur;\n\t\t\tfor(int j = t; j < i && j < t + 500; ++ j) {\n\t\t\t\tif(calc(j, i) < calc(cur, i)) cur = j;\n\t\t\t}\n\t\t\tif(cur == t) break;\n\t\t}\n\t\tdp[i] = min(calc(cur, i), dp[i]);\n\t}\n\tcout << dp[n] + E - A[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=100000+10;\nll f[maxn],xx[maxn];\nll n,e,t;\nll store;//fj-2xj+1\nint main(){\n\tll b1,b2,b3,b4;\n\tll p;//定位\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\t\n\tfor (b1=1;b1<=n;b1++){\n\t\tscanf(\"%lld\",&xx[b1]);\n\t}\n\tfor (b1=1;b1<=n;b1++){\n\t\tf[maxn]=b1*t;\n\t}\n\tp=0;store=((ll)1<<60);\n\tfor (b1=1;b1<=n;b1++){\n\t\twhile (2*xx[p+1]<=2*xx[b1]-t){\n\t\t\tstore=min(store,f[p]-2*xx[p+1]);\n\t\t\tp++;\n\t\t}\n\t\tf[b1]=min(2*xx[b1]+store,f[p]+t);\n\t\tf[b1]=min(f[b1-1]+t,f[b1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100005;\nconst long long INF = (1LL<<60);\nint n, T, E;\nint X[N];\n\n#define lson(x) (1<<x)\n#define rson(x) ((1<<x)|1)\nstruct Node {\n    int l, r;\n    long long Min[2], lazy;\n    void gao(int f){\n        lazy += f;\n        Min[0] += f;\n        Min[1] += f;\n    }\n} node[N * 4];\n\nvoid pushdown(int x) {\n    if (node[x].lazy) {\n        node[lson(x)].gao(node[x].lazy);\n        node[rson(x)].gao(node[x].lazy);\n        node[x].lazy = 0;\n    }\n}\n\nvoid pushup(int x) {\n    for (int i = 0; i < 2; i++)\n        node[x].Min[i] = min(node[lson(x)].Min[i], node[rson(x)].Min[i]);\n}\n\nvoid build(int l, int r, int x = 1) {\n    node[x].l = l; node[x].r = r;\n    node[x].lazy = 0;\n    if (l == r) {\n        node[x].Min[0] = 0;\n        node[x].Min[1] = X[l];\n        return;\n    }\n    int mid = (l + r)>>1;\n    build(l, mid, lson(x));\n    build(mid + 1, r, rson(x));\n    pushup(x);\n}\n\nvoid add(int l, int r, int w, int x = 1) {\n    if (node[x].l >= l && node[x].r <= r) {\n        node[x].gao(w);\n        return;\n    }\n    int mid = (node[x].l + node[x].r)>>1;\n    pushdown(x);\n    if (l <= mid) add(l, r, w, lson(x));\n    if (r > mid) add(l, r, w, rson(x));\n    pushup(x);\n}\n\nlong long query(int l, int r, int tp, int x = 1){\n    if (l > r) return INF;\n    if (node[x].l >= l && node[x].r <= r) {\n        return node[x].Min[tp];\n    }\n    int mid = (node[x].l + node[x].r)>>1;\n    pushdown(x);\n    long long ans = INF;\n    if (l <= mid) ans = min(ans, query(l, r, tp, lson(x)));\n    if (r > mid) ans = min(ans, query(l, r, tp, rson(x)));\n    pushup(x);\n}\n\nlong long dp[N];\nint main() {\n    while (~scanf(\"%d%d%d\", &n, &E, &T)) {\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &X[i]);\n        build(0, n);\n        int v = 0;\n        for (int i = 1; i <= n; i++) {\n            dp[i] = INF;\n            for (int j = 0; j < i; j++) {\n                dp[i] = min(dp[i], dp[j] + max((X[i] - X[j + 1]) * 2, T) + X[i] - X[j]);\n            }\n          //  printf(\"%d %lld\\n\", i, dp[i]);\n        }\n        printf(\"%lld\\n\", dp[n] + E - X[n]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz(a) int((a).size())\n#define F first\n#define S second\n\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n#define per(i, a, b) for(int i = a; i >= b; --i)\n#define travel(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define INDEX(arr,ind)\t\t\t(lower_bound(all(arr),ind)-arr.begin())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\ntypedef pair<int, pii> piii;\ntypedef pair<ll, pll> plll;\ntypedef vector<pii> vpii;\ntypedef vector<piii> vpiii;\n\ninline ll powmod(ll x, ll n, ll _mod){ \n  ll res = 1; \n  while (n){\n    if (n & 1)res = (res*x) % _mod; \n    x = (x*x) % _mod; \n    n >>= 1;\n    }\n    return res; \n  }\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,-1,1};\n//******************************************************************//\n#define N 100005\nint n,e,t;\nint a[N];\nconst ll inf=1e16;\nll dp[N];\n\nll sol(int x){\n\tif(x>=n)return 0;\n\tif(dp[x]!=inf)return dp[x];\n\tll ret=t+sol(x+1)+a[x+1]-a[x]; //if(x==0)cout<<ret<<endl;;\n\trep(i,x+1,n){\n\t\tll d=a[i]-a[x];\n\t\tif(2LL*d >= 1LL*t){\n\t\t\t\tret=min(ret,3LL*d+sol(i+1)+a[i+1]-a[i]);\n\t\t\t}\n\t\t\t//if(x==0)cout<<i<<\" \"<<ret<<endl;\n\t}\n\t//cout<<x<<\"->\"<<ret<<endl;\n\treturn dp[x]=ret;\n}\n\nint main(){\n ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n // freopen(\"in.txt\",\"r\",stdin);\n // freopen(\"o.txt\",\"w\",stdout);\n\nrep(i,0,N)dp[i]=inf;\ncin>>n>>e>>t;\nrep(i,0,n)cin>>a[i];\n\na[n]=a[n-1];\ncout<<sol(0)+a[0]+e-a[n];\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nll n, t, e;\nll x[100009];\n\nll dp[100009];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> e >> t;\n    rep(i, n) cin >> x[i + 1];\n\n    fill(ALL(dp), inf);\n    dp[0] = 0;\n    int j = 0;\n    ll mn = inf;\n    FOR(i, 1, n + 1) {\n        while(t <= 2 * (x[i] - x[j + 1])) {\n            chmin(mn, dp[j] - 2 * x[j + 1]);\n            j++;\n        }\n        chmin(dp[i], dp[j] + t);\n        chmin(dp[i], 2 * x[i] + mn);\n    }\n\n    cout << dp[n] + e << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[100005],x[100005];\ndeque<int> q1,q2;\nint n;\nlong long e,t;\nvoid ins1(int xx)\n{\n\twhile(!q1.empty()&&dp[q1.front()]-2*x[q1.front()]>=dp[xx]-2*x[xx]) q1.pop_back();\n\tq1.push_back(xx);\n}\nvoid ins2(int xx)\n{\n\twhile(!q2.empty()&&dp[q2.front()]>=dp[xx]) q2.pop_back();\n\tq2.push_back(xx);\n}\nlong long r1(int i)\n{\n\tif(!q1.empty())return dp[q1.front()]+2*(x[i]-x[q1.front()+1]); else return 1e18;\n}\nlong long r2(int i)\n{\n\tif(!q2.empty())return dp[q2.front()]+t; else return 1e18;\n}\nint main()\n{\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t\tdp[i]=1e18;\n\t}\n\tdp[0]=0;\n\tq2.push_back(0);\n\tint l=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t//\tdp[i]=min(dp[i],dp[j]+max(2*(x[i]-x[j+1]),t));\n\t\t\twhile(l<i&&2*(x[i]-x[l+1])>=t)\n\t\t\t{\n\t\t\t\tins1(l);\n\t\t\t\tif(q2.front()==l) q2.pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tdp[i]=min(r1(i),r2(i));\n//\t\t\tcout<<((!q1.empty())? q1.front():100)<<\" \"<<r1(i)<<\" \"<<\" \"<<((!q2.empty())? q2.front():100)<<\" \"<<r2(i)<<\" \"<<dp[i]<<endl;\n\t\t\tins2(i);\n\t\t}\n\t}\n\tcout<<e+dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 13.01.2020 23:37:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long e, t;\n  cin >> n >> e >> t;\n  n += 1;\n  vector<long long> x(n);\n  for (int i = 1; i < n; i++) {\n    cin >> x[i];\n  }\n  vector<long long> dp(n);\n  multiset<long long> far;\n  multiset<long long> near;\n  int j = 0;\n  near.insert(dp[0] + t - x[0]);\n  for (int i = 1; i < n; i++) {\n    while (j < i && 2 * (x[i] - x[j + 1]) >= t) {\n      near.erase(near.find(dp[j] + t - x[j]));\n      far.insert(dp[j] - x[j] - 2 * x[j + 1]);\n      j += 1;\n    }\n    dp[i] = (long long) 1e18;\n    if (!near.empty()) {\n      dp[i] = min(dp[i], *near.begin() + x[i]);\n    }\n    if (!far.empty()) {\n      dp[i] = min(dp[i], *far.begin() + 3 * x[i]);\n    }\n    near.insert(dp[i] + t - x[i]);\n  }\n  cout << dp[n - 1] + e - x[n - 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <unistd.h>\n\n\n#define ll long long\n#define lst(x) x.size()-1\n#define ld long double\n#define pr pair<ll,ll>\n#define loop(i,n) for(ll i=0 ; i<n ; ++i)\n#define rep(i,x,n) for(ll i=x ; i<=n ; ++i)\n#define iteloop(type,data,name,it) for(type<data>::iterator it=name.begin() ;it!=name.end() ; ++it)\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<typename T>\nusing os = tree<T, null_type, less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nconst ll N=1e5+5,M=1e1+5,MOD=1e9+7,INF=1e18;\n\nll pos[N],n,t,e;\nll memo[N];\nll seg1[4*N] ;  // To store segment seg1\nll lazy1[4*N] ;  // To store pending updates\n\nvoid updateRangeUtil(ll si, ll ss, ll se, ll us,\n                     ll ue, ll diff){\n\n    if (lazy1[si] != 0){\n        seg1[si] += lazy1[si];\n        if (ss != se){\n            lazy1[si*2 + 1]   += lazy1[si];\n            lazy1[si*2 + 2]   += lazy1[si];\n        }\n        lazy1[si] = 0;\n    }\n    if (ss>se || ss>ue || se<us)\n        return ;\n    if (ss>=us && se<=ue){\n        seg1[si] += diff;\n        if (ss != se){\n            lazy1[si*2 + 1]   += diff;\n            lazy1[si*2 + 2]   += diff;\n        }\n        return;\n    }\n    ll mid = (ss+se)/2;\n    updateRangeUtil(si*2+1, ss, mid, us, ue, diff);\n    updateRangeUtil(si*2+2, mid+1, se, us, ue, diff);\n    seg1[si] = min(seg1[si*2+1] , seg1[si*2+2]);\n}\n\nvoid updateRange(ll us, ll ue, ll diff){\n    updateRangeUtil(0, 0, n-1, us, ue, diff);\n}\n\nll getMinUtil(ll ss, ll se, ll qs, ll qe, ll si){\n    if (lazy1[si] != 0){\n        seg1[si] += lazy1[si];\n        if (ss != se){\n            lazy1[si*2+1] += lazy1[si];\n            lazy1[si*2+2] += lazy1[si];\n        }\n        lazy1[si] = 0;\n    }\n\n    if (ss>se || ss>qe || se<qs)\n        return INF;\n\n    if (ss>=qs && se<=qe)\n        return seg1[si];\n    ll mid = (ss + se)/2;\n    return min(getMinUtil(ss, mid, qs, qe, 2*si+1),\n           getMinUtil(mid+1, se, qs, qe, 2*si+2));\n}\nll getMin( ll qs, ll qe){\n    if (qs < 0 || qe > n-1 || qs > qe){\n        return INF;\n    }\n\n    return getMinUtil(0, n-1, qs, qe, 0);\n}\nvoid constructST(){\n    memset(seg1,0,sizeof(seg1));\n    memset(lazy1,0,sizeof(lazy1));\n}\n\n\n\n\n\n\n\n\nll seg2[4*N] ;  // To store segment seg1\nll lazy2[4*N] ;  // To store pending updates\n\nvoid updateRangeUtil2(ll si, ll ss, ll se, ll us,\n                     ll ue, ll diff){\n\n    if (lazy2[si] != 0){\n        seg2[si] += lazy2[si];\n        if (ss != se){\n            lazy2[si*2 + 1]   += lazy2[si];\n            lazy2[si*2 + 2]   += lazy2[si];\n        }\n        lazy2[si] = 0;\n    }\n    if (ss>se || ss>ue || se<us)\n        return ;\n    if (ss>=us && se<=ue){\n        seg2[si] += diff;\n        if (ss != se){\n            lazy2[si*2 + 1]   += diff;\n            lazy2[si*2 + 2]   += diff;\n        }\n        return;\n    }\n    ll mid = (ss+se)/2;\n    updateRangeUtil2(si*2+1, ss, mid, us, ue, diff);\n    updateRangeUtil2(si*2+2, mid+1, se, us, ue, diff);\n    seg2[si] = min(seg2[si*2+1] , seg2[si*2+2]);\n}\n\nvoid updateRange2(ll us, ll ue, ll diff){\n    updateRangeUtil2(0, 0, n-1, us, ue, diff);\n}\n\nll getMinUtil2(ll ss, ll se, ll qs, ll qe, ll si){\n    if (lazy2[si] != 0){\n        seg2[si] += lazy2[si];\n        if (ss != se){\n            lazy2[si*2+1] += lazy2[si];\n            lazy2[si*2+2] += lazy2[si];\n        }\n        lazy2[si] = 0;\n    }\n\n    if (ss>se || ss>qe || se<qs)\n        return INF;\n\n    if (ss>=qs && se<=qe)\n        return seg2[si];\n    ll mid = (ss + se)/2;\n    return min(getMinUtil2(ss, mid, qs, qe, 2*si+1) ,\n           getMinUtil2(mid+1, se, qs, qe, 2*si+2));\n}\nll getMin2( ll qs, ll qe){\n    if (qs < 0 || qe > n-1 || qs > qe){\n        return INF;\n    }\n\n    return getMinUtil2(0, n-1, qs, qe, 0);\n}\nvoid constructST2(){\n    memset(seg2,0,sizeof(seg2));\n    memset(lazy2,0,sizeof(lazy2));\n}\nint main(){\n    cin.sync_with_stdio(false), cin.tie(0) , cout.tie(0);\n#ifndef ONLINE_JUDGE\n   // freopen(\"in.txt\", \"rt\" , stdin);\n    // freopen(\"in.txt\", \"wt\" , stdout);\n#endif\n    cin>>n>>e>>t;\n    loop(i,n){\n        cin>>pos[i];\n    }\n    pos[n]=e;\n    memo[0]=t;\n\n    constructST();\n    constructST2();\n\n    // seg1 = dp\n    // seg2 = dp + aj-ai\n\n    updateRange(0,0,t);\n    updateRange2(0,0,t);\n\n    rep(i,1,n-1){\n        ll st=0,en=i-1;\n        while(st<=en){\n            ll mid=(st+en)/2;\n            if(2*(pos[i]-pos[mid+1])>t){\n                st=mid+1;\n            }else{\n                en=mid-1;\n            }\n        }\n        memo[i]=getMin2(0,st-1);\n       //  to decide if it's better to return to the begining\n        memo[i]=min(memo[i],(ll)max(t,2*(pos[i]-pos[0])));\n\n\n        memo[i]=min(memo[i],getMin(st,i-1)+t);\n\n\n        memo[i]=min(memo[i],t+memo[i-1]);\n\n\n        updateRange2(0,i-1,2*(pos[i+1]-pos[i]));\n        updateRange2(i,i,memo[i]);\n        updateRange(i,i,memo[i]);\n    }\n    cout<<memo[n-1]+e<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nclass LazySegmentTree {\n    public:\n    \n    LazySegmentTree(int n) {\n        size = 1;\n        while (size < n) size <<= 1;\n        \n        data = (long long *)malloc(sizeof(long long) * size * 2);\n        lazy = (long long *)malloc(sizeof(long long) * size * 2);\n        \n        for (int i = 0; i < size * 2; i++) data[i] = lazy[i] = 0;\n    }\n    \n    ~LazySegmentTree() {\n        free(data);\n        free(lazy);\n    }\n    \n    //[x,y)\n    void update(int x, int y, long long v) {\n        int len = 0;\n        \n        get(x, y, len);\n        \n        for (int i = len - 1; i >= 0; i--) propagate(index[i]);\n        \n        while (0 < x && x + (x & -x) <= y) {\n            lazy[(size + x) / (x & -x)] += v;\n            propagate((size + x) / (x & -x));\n            x += x & -x;\n        }\n        \n        while (x < y) {\n            lazy[(size + y) / (y & -y) - 1] += v;\n            propagate((size + y) / (y & -y) - 1);\n            y -= y & -y;\n        }\n        \n        for (int i = 0; i < len; i++) merge(index[i]);\n    }\n    \n    //[x,y)\n    long long query(int x, int y) {\n        int len = 0;\n        long long ans = 1e18;\n        \n        get(x, y, len);\n        \n        for (int i = len - 1; i >= 0; i--) propagate(index[i]);\n        \n        while (0 < x && x + (x & -x) <= y) {\n            propagate((size + x) / (x & -x));\n            ans = min(ans, data[(size + x) / (x & -x)]);\n            x += x & -x;\n        }\n        \n        while (x < y) {\n            propagate((size + y) / (y & -y) - 1);\n            ans = min(ans, data[(size + y) / (y & -y) - 1]);\n            y -= y & -y;\n        }\n        \n        for (int i = 0; i < len; i++) merge(index[i]);\n        \n        return ans;\n    }\n    \n    private:\n    \n    int size;\n    long long *data, *lazy;\n    int index[64];\n    \n    void propagate(int x) {\n        if (x < size) {\n            lazy[x * 2] += lazy[x];\n            lazy[x * 2 + 1] += lazy[x];\n        }\n        \n        data[x] += lazy[x];\n        lazy[x] = 0;\n    }\n    \n    void merge(int x) {\n        data[x] = min(data[x * 2] + lazy[x * 2], data[x * 2 + 1] + lazy[x * 2 + 1]);\n    }\n    \n    void get(int x, int y, int &len) {\n        for (int l = x ? ((size + x) / (x & -x)) >> 1 : 0, r = ((size + y) / (y & -y) - 1) >> 1; ; r >>= 1) {\n            if (l == r) {\n                for (; l > 0; l >>= 1) index[len++] = l;\n                return;\n            }\n            \n            if (l > r) swap(l, r);\n            index[len++] = r;\n        }\n    }\n};\n\n\nint x[100001];\n\nint main() {\n    int n, e, t, last = 0, i, j;\n    \n    scanf(\"%d %d %d\", &n, &e, &t);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    \n    x[n] = e;\n    \n    LazySegmentTree s(n + 1);\n    \n    s.update(0, 1, x[0]);\n    \n    for (i = 1; i <= n; i++) {\n        long long ans = 1e18;\n        \n        if (i > 1) s.update(0, i - 1, x[i - 1] - x[i - 2]);\n        \n        if (last > 0) s.update(0, last, (x[i - 1] - x[i - 2]) * 2);\n        \n        for (; last < i - 1; last++) {\n            if ((x[i - 1] - x[last]) * 2 <= t) break;\n            \n            s.update(last, last + 1, (x[i - 1] - x[last]) * 2);\n        }\n        \n        if (last > 0) ans = min(ans, s.query(0, last) + x[i] - x[i - 1]);\n        ans = min(ans, s.query(last, i) + t + x[i] - x[i - 1]);\n        \n        s.update(i, i + 1, ans);\n    }\n    \n    printf(\"%lld\\n\", s.query(n, n + 1));\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\nLL getdist(vector<LL> &x, LL T, int i, int j) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tLL data = getdist(x, T, pos , i);\n//\t\t\tif(ans[i] < ans[pos] + data) break;\n//\t\t\tif(ans[i] >= ans[pos] + data) break;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[j], ans[i] + getdist(x, T,i, j));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+20];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+20];\n\tint x[100000+20];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n//\t\tcout<<dp[i]<<endl;\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n//\t\tcout<<dp[i]<<\" \"<<las<<endl;\n//\t\twhile(!b1.empty()&&b1.)\n//\t\trb(k,0,i-1){\n//\t\t\tint j=k+1;\n//\t\t\tdp[i]=min(dp[i],dp[k]+x[j]-x[k]+max(T,(x[i]-x[j])*2)+x[i]-x[j]);\n//\t\t}\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3)/3,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3);\n//\t\tb1.push(i+1,dp[i]+x[i+1]-x[i]-all);\n//\t\tb2.push(i+1,dp[i]+x[i+1]-x[i]-all/3);\n//\t\tcout<<dp[i]<<endl<<endl;\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\n#define LL long long\nLL dp[MAXN],a[MAXN],T,tmp=1000000000000000LL;\nint n,m,t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&m,&T);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(T<=2*(a[i]-a[t+1]))\n\t\t\ttmp=min(tmp,dp[t]-2*a[t+1]),t++;\n\t\tdp[i]=min(tmp+2*a[i],dp[t]+T);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n\n  ll sz, height;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  Monoid f(Monoid x,Monoid y){\n    return x<y?x:y;\n  };\n  Monoid g(Monoid x,OperatorMonoid y){\n    return x+y;\n  };\n  OperatorMonoid h(OperatorMonoid x,OperatorMonoid y){\n    return x+y;\n  };\n  const Monoid M1 = INF;//単位元を変えるのを忘れない！！！！！！！！！！\n  const OperatorMonoid OM0 = 0;//単位元を変えるのを忘れない！！！！！！！！！！\n  LazySegmentTree(ll n){\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(ll k, const Monoid &x) {\n    data[k + sz] = x;\n  }\n\n  void build() {\n    for(ll k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n\n  inline void propagate(ll k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(ll k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(ll k) {\n    while(k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(ll k) {\n    for(ll i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(ll a, ll b, const OperatorMonoid &x) {\n\tif(a>=b)return;\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(ll l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(ll a, ll b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for(ll l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) L = f(L, reflect(l++));\n      if(r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const ll &k) {\n    return query(k, k + 1);\n  }\n\n  template< typename C >\n  ll find_subtree(ll a, const C &check, Monoid &M, bool type) {\n    while(a < sz) {\n      propagate(a);\n      Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n      if(check(nxt)) a = 2 * a + type;\n      else M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template< typename C >\n  ll find_first(ll a, const C &check) {\n    Monoid L = M1;\n    if(a <= 0) {\n      if(check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    ll b = sz;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if(check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n\n  template< typename C >\n  ll find_last(ll b, const C &check) {\n    Monoid R = M1;\n    if(b >= sz) {\n      if(check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz - 1);\n    ll a = sz;\n    for(b += sz; a < b; a >>= 1, b >>= 1) {\n      if(b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if(check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n  void print(){\n    for(ll i=0;i<sz;i++)cout<<((*this)[i]==M1?\"x\":to_string((*this)[i]))<<\" \";\n    cout<<endl;\n  }\n};\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,e,t;cin>>n>>e>>t;\n  vector<ll>x(n+1);\n  rep(i,0,n)cin>>x[i];\n  x[n]=e;\n  LazySegmentTree<ll,ll>seg1(n+1),seg2(n+1);\n  seg1.update(0,1,-INF+x[0]);\n  seg2.update(0,1,-INF+x[0]);\n  rep(i,0,n){\n    ll idx=partition_point(ALL(x),[&](ll p){\n      return 2*(x[i]-p) > t; \n    })-x.begin();\n    ll mi1=seg1.query(0,idx);\n    ll mi2=seg2.query(idx,i+1)+t;\n    //cout<<mi1 spa mi2<<endl;\n    if(mi1>mi2)swap(mi1,mi2);\n    mi1+=x[i+1]-x[i];\n    seg1.update(i+1,i+2,mi1-INF);\n    seg2.update(i+1,i+2,mi1-INF);\n    if(i==n-1){\n      cout<<mi1<<endl;\n    }\n    seg1.update(0,i+1,3*(x[i+1]-x[i]));\n    seg2.update(0,i+1,x[i+1]-x[i]);\n    //seg1.print();\n    //seg2.print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nconst num inf = 0x3f3f3f3f3f3f3f3f;\nint n, m, t, a[nsz + 5];\nnum dp[nsz + 5], ans;\n\nvoid inline upd(num &a, num b) {\n\ta > b && (a = b);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin >> n >> m >> t;\n\tcont (i, n) {\n\t\tcin >> a[i];\n\t}\n\tmemset(dp, inf, sizeof(dp));\n\tdp[0] = 0;\n\tcont (i, n) {\n\t\tloop (j, i) {\n\t\t\tupd(dp[i], dp[j] + a[i] - a[j] + a[i] - a[j + 1] + max(0, t - (a[i] - a[j] + a[i] - a[j + 1] - a[j + 1] + a[j])) + a[i] - a[j + 1]);\n\t\t}\n\t}\n\tans = dp[n] + m - a[n];\n\tcout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[maxn],tree2[maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return; int mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; } int mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now]; int mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]-2LL*(ll)X[i]-(ll)X[i-1]);\n\t\tmodify(tree2,1,1,N,i,f[i-1]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) > 0) r = mid-1;\n\t\t\telse l = mid+1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tif (r+2 <= i) f[i] = min(f[i],query(tree2,1,1,N,r+2,i)+(ll)X[i]+(ll)T);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, E, T, x[100009];\nlong long dp[100009], INF = 1LL << 50;\nmultiset < long long > S1, S2;\n\nvoid push (int lin, long long val)\n{\n    if (lin == 1) S1.insert (val);\n    else S2.insert (val);\n}\n\nvoid pop (int lin, long long val)\n{\n    if (lin == 1) S1.erase (S1.find (val));\n    else S2.erase (S2.find (val));\n}\n\nlong long getVal (int lin, int k)\n{\n    if (lin == 1) return (long long) dp[k - 1] - x[k] - x[k] - x[k - 1];\n    return (long long) dp[k - 1] - x[k - 1] + T;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &E, &T);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nint k = 1;\nfor (int i=1; i<=N; i++)\n{\n    while (2 * (x[i] - x[k]) >= T)\n    {\n        push (1, getVal (1, 1));\n        pop (2, getVal (2, k));\n        k ++;\n    }\n    push (2, getVal (2, i));\n    ///pe [1, k - 1] am dp[k - 1] - x[k] - x[k] - x[k - 1]     +3x[i]\n    ///pe [k, i] am dp[k - 1] - x[k - 1] + T    +x[i]\n    long long val1 = INF, val2 = INF;\n    if (!S1.empty ()) val1 = (*S1.begin ()) + 3LL * x[i];\n    if (!S2.empty ()) val2 = (*S2.begin ()) + x[i];\n    dp[i] = min (val1, val2);\n}\nprintf (\"%lld\\n\", dp[N] + E - x[N]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,N) for(int i = 0;i < N;i++)\n#define int long long\nsigned main(){\n  int N,E,T;\n  cin >> N >> E >> T;\n  int kuma[100000];\n  int edge[100000];\n  Rep(i,N)cin >> kuma[i];\n  Rep(i,N - 1)edge[i] = kuma[i + 1] - kuma[i];\n  int sum = kuma[0];\n  int ruiseki = 0;\n  Rep(i,N - 1){\n    \n    if(max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki + edge[i] + T > (max(max((int)0,T - (ruiseki * 2 + 2 * edge[i])),ruiseki + 2 * edge[i])) + ruiseki + edge[i]) {\n      ruiseki += edge[i];\n      sum += edge[i];\n    }else {\n      sum += max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki + edge[i];\n      ruiseki = 0;\n    }\n  }\n  if(ruiseki) {\n    cout << sum + E - kuma[N - 1] + max(max((int)0,T - ruiseki * 2),ruiseki) + ruiseki << endl;\n  }else {\n    cout << sum + E - kuma[N - 1] + T << endl;\n  }\n  return 0;\n}\n      \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100 * 1000 + 3, INF = 1000ll * 1000 * 1000 * MAXN + 3, D = 1000 * 1000 * 1000 + 7;\n\n\n\n\n\n\n\n\n\n\n\n\n\nint n, m, s, t, d[2 + 1][MAXN], cnt[2 + 1][MAXN], w[MAXN], e[MAXN], ans;\nvector<int> g[MAXN];\npriority_queue<pii, vector<pii>, greater<pii>> p;\nbitset<MAXN> mark;\n\n\nvoid dij(int x, int y) {\n\tmark.reset();\n\tfill(d[y], d[y] + n, INF);\n\tp.push({0, x});\n\td[y][x] = 0;\n\tcnt[y][x] = 1;\n\twhile (!p.empty()) {\n\t\tint f = p.top().second;\n\t\tp.pop();\n\t\tif (mark[f]) continue;\n\t\tmark[f] = true;\n\t\tfor (auto i : g[f]) {\n\t\t\tint z = f ^ e[i];\n\t\t\tif (d[y][f] + w[i] < d[y][z]) {\n\t\t\t\td[y][z] = d[y][f] + w[i];\n\t\t\t\tp.push((pii){d[y][z], z});\n\t\t\t\tcnt[y][z] = cnt[y][f];\n\t\t\t} else if (d[y][f] + w[i] == d[y][z]) cnt[y][z] += cnt[y][f];\n\t\t}\n\t}\n}\n\n\n\nint32_t main() {\n\tcin >> n >> m >> s >> t;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v >> w[i];\n\t\tg[--u].push_back(i), g[--v].push_back(i);\n\t\te[i] = u ^ v;\n\t}\n\ts--, t--;\n\tdij(s, 0), dij(t, 1);\n\tans = cnt[0][t] * cnt[1][s] % D;\n\tint q = d[0][t];\n\tfor (int i = 0; i < n; i++) {\n\t\tint a = cnt[0][i], x = d[0][i], o = cnt[1][i];\n\t\tfor (auto j : g[i]) {\n\t\t\tint zz = e[j] ^ i;\n\t\t\tint y = d[1][zz], b = cnt[1][zz];\n\t\t\tif (x + w[j] != d[0][zz] || y + w[j] != d[1][i] || x + y + w[j] != q || abs(x - y) >= w[j]) continue;\n\t\t\tans -= a * b % D * a % D * b % D;\n\t\t\tans %= D;\n\t\t}\n\t\tif (q == d[0][i] + d[1][i] && d[0][i] == d[1][i]) ans -= a * o % D * a % D * o % D;\n\t}\n\tcout << (ans + D) % D;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#define ll long long\n#define inf 1e9\n#define eps 1e-10\n#define mod 9901\n#define mkp make_pair\nusing namespace std;\nint i,j,k,m,s,t,n,ans1,ans2,n1,nn,m1,mx;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint kabs(int a)\n{\n   if (a<0) return -a;\n   return a; \n}\nvoid add(int &x,int y)\n{\n   x+=y;\n   if (x>=mod) x-=mod;\n}\nvoid dec(int &x,int y)\n{\n\tx-=y;\n\tif (x<0) x+=mod;\n}\nint a[101000];\nll f[101000];\nint main()\n{\n\tint e;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tj=0;\n\tll s=1e18;\n\tfor (i=1;i<=n;i++)\n\t\tf[i]=1e18;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\twhile (2*(a[i]-a[j+1])>=t)\n\t\t\ts=min(s,f[j]-2ll*a[j+1]),j++;\n\t\tf[i]=min(f[j]+t,2ll*a[i]+s);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint st[800005][2]; \nvoid update(ll root, ll l, ll r, ll i, ll val, ll id){\n\tif (i < l || r < i) return;\n\tif (l == r){\n\t\tst[root][id] = val; return;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(root * 2 + 1, l, mid, i, val, id);\n\tupdate(root * 2 + 2, mid + 1, r, i, val, id);\n\tst[root][id] = min(st[root * 2 + 1][id], st[root * 2 + 2][id]);\n}\nll query(ll root, ll l, ll r, ll u, ll v, ll id){\n\tif (u > v) return 1e18;\n\tif (v < l || r < u) return 1e18;\n\tif (u <= l && r <= v) return st[root][id];\n\tll mid = (l + r) / 2;\n\treturn min(query(root * 2 + 1, l, mid, u, v, id), query(root * 2 + 2, mid + 1, r, u, v, id));\n}\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\t// dp[i]: shortest time to clear first i candies.\n\tdp[0] = 0;\n\t// 2 segtrees: one record dp[j] - 2 * a[j + 1] - a[j], one record dp[j] - a[j].\n\tupdate(0, 0, n - 1, 0, dp[0] - 2 * a[1], 0);\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tll lw; // lw: (a[i] - a[lw]) * 2 <= t, (a[i] - a[lw - 1]) * 2 > t. (lw - 1 -> 0)\n\t\t// manual binsearch? lw >= l, <= r\n\t\tll l = 0, r = i - 1;\n\t\twhile (l < r){\n\t\t\tll mid = (l + r) / 2;\n\t\t\tif ((a[i] - a[mid + 1]) * 2 <= t) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tlw = l;\n\t\t// so (dp[j] - 2 * a[j + 1] - a[j]) + 3 * a[i] with a from 0 to lw - 1, (dp[j] - a[j]) + a[i] + t to lw to i - 1\n\t\tdp[i] = min(query(0, 0, n - 1, 0, lw - 1, 0) + 3 * a[i], query(0, 0, n - 1, lw, i - 1, 1) + a[i] + t);\n\t\tupdate(0, 0, n - 1, i, dp[i] - 2 * a[i + 1] - a[i], 0); update(0, 0, n - 1, i, dp[i] - a[i], 1);\n\t\t// for (ll j = 0; j < i; j++) dp[i] = min(dp[i], dp[j] + max(2 * (a[i] - a[j + 1]), t) + a[i] - a[j]);\n\t}\n\t// hj, optimize nao\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define REP(i, k) for (decltype(k) i = 0; i < k; i++)\n#define LOOP(k) REP (ngtkana_is_a_genius, k)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// segtree{{{\ntemplate <class Monoid>\nstruct segtree {\n    using value_type = typename Monoid::value_type;\n\n    std::vector<value_type> table;\n\n    segtree()=default;\n    segtree(segtree const&)=default;\n    segtree(segtree&&)=default;\n    segtree&operator=(segtree const&)=default;\n    segtree&operator=(segtree&&)=default;\n\n    segtree(std::size_t n, value_type init=Monoid::id())\n        : table(2*n, init) {}\n\n    void resize(std::size_t n, value_type init=Monoid::id()) {\n        assert(table.empty());\n        table.resize(2*n, init);\n    }\n\n    void lazy_set(std::size_t i, value_type x) {\n        table.at(i + size()) = x;\n    }\n\n    void build() {\n        for (std::size_t i=size()-1; i; i--) {\n            table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1));\n        }\n    }\n\n    std::size_t size() const { return table.size() / 2; }\n\n    value_type fold(std::size_t l, std::size_t r) const {\n        value_type fl = Monoid::id();\n        value_type fr = Monoid::id();\n\n        for(l+=size(),r+=size();l<r;l>>=1,r>>=1){\n            if(l&1u) fl=Monoid::op(fl, table.at(l++));\n            if(r&1u) fr=Monoid::op(fr, table.at(--r));\n        }\n\n        return Monoid::op(fl, fr);\n    }\n\n    value_type get(std::size_t i) const { return table.at(size() + i); }\n\n    std::vector<value_type> to_vec() const {\n        std::vector<value_type> ret(size());\n        std::copy(table.begin()+size(), table.end(), ret.begin());\n        return ret;\n    }\n\n    void set(std::size_t i, value_type x) {\n        assert(i < size());\n        i+=size();\n        table.at(i) = x;\n        for (i>>=1; i; i>>=1) {\n            table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1));\n        }\n    }\n\n    void add(std::size_t i, value_type x) { set(i, get(i) + x); }\n    void sub(std::size_t i, value_type x) { set(i, get(i) - x); }\n    void mul(std::size_t i, value_type x) { set(i, get(i) * x); }\n    void div(std::size_t i, value_type x) { set(i, get(i) / x); }\n    void cmn(std::size_t i, value_type x) { set(i, std::min(get(i), x)); }\n    void cmx(std::size_t i, value_type x) { set(i, std::max(get(i), x)); }\n\n    template <class F> void map(std::size_t i, F const& f) { set(i, f(get(i))); }\n};\n/*}}}*/\ntemplate <class Value> struct min_monoid_t {\n    using value_type = Value;\n    static value_type op(value_type l, value_type r) { return std::min(l, r); }\n    static const value_type id() { return std::numeric_limits<Value>::max(); }\n};\nauto cmn = [](auto& x, auto y){ if (x>y) { x=y; return true; } return false; };\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n; i64 E, T; std::cin >> n >> E >> T;\n    vec<i64> a(n+1);\n    for (usize i=1; i<=n; i++) std::cin >> a.at(i);\n\n    auto dp = segtree<min_monoid_t<i64>>(n+1);\n    auto ep = segtree<min_monoid_t<i64>>(n+1);\n    dp.set(0, 0);\n    ep.set(0, -2 * a.at(1));\n    for (usize l=0, j=1; j<=n; j++) {\n        for (; T < 2 * (a.at(j) - a.at(l+1)); l++);\n        if (l) dp.cmn(j, ep.fold(0, l) + 2 * a.at(j));\n        dp.cmn(j, dp.fold(l, j) + T);\n        if (j < n) ep.set(j, dp.get(j) - 2 * a.at(j + 1));\n    }\n\n    i64 ans = dp.get(n) + E;\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <fstream>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n\n#define maxn 200010\n#define inf 1LL<<60\n\nusing namespace std;\nlong long x[maxn];\nlong long dp[maxn];\n\nint main() {\n    // freopen(\"POLYGON.in\", \"r\", stdin);\n    // freopen(\"POLYGON.out\", \"w\", stdout);\n    int n;\n    long long e, t;\n    cin >> n >> e >> t;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> x[i];\n    }\n    x[n+1] = e;\n    \n    dp[1] = x[1];\n    for (int i = 2; i <= n+1; ++i) {\n        dp[i] = inf;\n    }\n    int j = 1;\n    long long bonus = inf;\n    for (int i = 1; i <= n; ++i) {\n        while (j < n && 2*(x[j+1] - x[i]) <= t) {\n            bonus += 3*(x[j+1] - x[j]);\n            ++j;\n            dp[j+1] = min(dp[j+1], bonus + x[j+1] - x[j]);\n        }\n        dp[j+1] = min(dp[j+1], dp[i] + 3*(x[j] - x[i]) + (t - 2*(x[j] - x[i])) + x[j+1] - x[j]);\n        bonus = min(bonus, dp[i] + 3*(x[j]-x[i]));\n        \n        /*\n        for (int j = i; j <= n; ++j) {\n            dp[j+1] = min(dp[j+1], dp[i] + 3*(x[j] - x[i]) + max(0LL, t - 2*(x[j] - x[i])) + x[j+1] - x[j]);\n        }\n        */\n    }\n    cout << dp[n+1];\n}"
  },
  {
    "language": "C++",
    "code": "/*\tAtCoder 2171 Shik and Game\n    1st Edition:2017.11.25 Saturday\n    Algorithm:DP,╣╔╣В╤сап\n*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cstdlib>\n#include <ctime>\n#include <cctype>\nusing namespace std;\n\n#define For(a,b,c) for(int (a)=(b);(a)<=(c);++a)\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define shl(x,y) ((x)<<(y))\n#define shr(x,y) ((x)>>(y))\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef double db;\nconst ll inf=2000000007LL;\nconst double EPS=1e-10;\nconst ll inf_ll=(ll)1e18;\nconst ll maxn=100005LL;\nconst ll mod=1000000007LL;\n\n//input\nint n;\nll T,E;\nll x[maxn];\n\nvoid input(){\n\tscanf(\"%d%lld%lld\",&n,&E,&T);\n\tFor(i,1,n) scanf(\"%lld\",x+i);\n}\n\n//DP\nll f[maxn];\n\nvoid dp_init(){\n\tf[0]=0;\n\tFor(i,1,n) f[i]=inf_ll;\n}\n\nvoid dp_test(){\n\tputs(\"\\ndp tests begin\");\n\tFor(i,1,n) printf(\"%d \",f[i]);\n\tputs(\"\");\n\tputs(\"dp tests end\\n\");\n}\n\nvoid dp_main(){\n\tdp_init();\n\tint divl=0;\n\tll min2=inf_ll;\n\tif(x[1]*2>T) min2=0;\n\tFor(i,1,n){\n\t\tmin2+=2*(x[i]-x[i-1]);\n\t\twhile(divl<i && 2*(x[i]-x[divl+1])>T){\n\t\t\tmin2=min(min2,f[divl]+(x[i]-x[divl+1])*2);\n\t\t\t++divl;\n\t\t}\n//\t\tprintf(\"%d %lld %lld\\n\",divl,f[divl]+T,min2);\n\t\tf[i]=min(min2,f[divl]+T);\n\t}\n\tprintf(\"%lld\\n\",E+f[n]);\n//\tdp_test();\n}\n\n//main\nint main(){\n\tinput();\n\tdp_main();\n\treturn 0;\n}\n\n/*\n3 9 1\n1 3 8\n\n3 9 3\n1 3 8\n\n2 1000000000 1000000000\n1 999999999\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nconst int MAXN=100000;\npriority_queue<pair<LL,int >,vector<pair<LL,int > >,greater<pair<LL,int> > >b1,b2;\n//一个是加上2*(x[i]-x[j]),另一个不加 \nLL add_val[100000+20];\nsigned main(){\n\tfastio;\n\tint N;\n\tcin>>N;\n\tint T,E;\n\tcin>>E>>T;\n\tLL dp[100000+20];\n\tint x[100000+20];\n\trb(i,1,N)\n\t\tcin>>x[i];\n\trb(i,1,N){\n\t\tdp[i]=(LL)(T)*i+x[i];\n\t} \n\tint las=0;\n\tLL all=0;\n\tadd_val[0]=dp[0]+x[1];\n\tadd_val[1]=dp[1]+x[2]-x[1];\n\tb2.push(II(dp[1]+x[2]-x[1],1));\n\tb2.push(II(dp[0]+x[1],0));\n\trb(i,2,N){\n\t\tall+=3*(x[i]-x[i-1]);\n\t\twhile((x[i]-x[las+1])*2>T){\n\t\t\tb1.push(II(add_val[las],las));\n\t\t\tlas++;\n\t\t}\n//\t\tcout<<dp[i]<<endl;\n\t\twhile(!b2.empty()&&b2.top().SEC<las) b2.pop();\n\t\tif(!b2.empty())\n\t\tdp[i]=min(dp[i],b2.top().FIR+all/3+T);\n//\t\tcout<<dp[i]<<endl;\n\t\tif(!b1.empty())\n\t\t\tdp[i]=min(dp[i],b1.top().FIR+all);\n//\t\tcout<<dp[i]<<\" \"<<las<<endl;\n//\t\twhile(!b1.empty()&&b1.)\n//\t\trb(k,0,i-1){\n//\t\t\tint j=k+1;\n//\t\t\tdp[i]=min(dp[i],dp[k]+x[j]-x[k]+max(T,(x[i]-x[j])*2)+x[i]-x[j]);\n//\t\t}\n\t\tif(i==N) break;\n\t\tb2.push(II(dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3)/3,i));\n\t\tadd_val[i]=dp[i]+x[i+1]-x[i]-(all+(x[i+1]-x[i])*3);\n//\t\tb1.push(i+1,dp[i]+x[i+1]-x[i]-all);\n//\t\tb2.push(i+1,dp[i]+x[i+1]-x[i]-all/3);\n//\t\tcout<<dp[i]<<endl<<endl;\n\t}\n\tcout<<dp[N]+E-x[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100001\nstruct SegmentTree {\nprivate:\n    int n; vector<ll> node;\npublic:\n    SegmentTree(int sz) {\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n    }\n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n    ll rmq(int a,int b){\n        return getmin(a,b,0,0,-1);\n    }\n};\nmain(){\n    ll n=lin(),e=lin(),t=lin();\n    ll x[N]={};\n    rep2(i,1,n)x[i]=lin();\n    ll dp[N]={};\n    SegmentTree seg1(n+1),seg2(n+1);\n    seg1.update(0,-x[1]*2);\n    seg2.update(0,0);\n    rep2(i,1,n){\n        int l=0,r=i-1;\n        while(l<r-1){\n            int mid=(l+r)/2;\n            if(t-(x[i]-x[mid+1])*2>0){\n                r=mid;\n            }\n            else l=mid;\n        }\n        ll m1=seg1.rmq(0,r);\n        ll m2=seg2.rmq(r,i)+t-x[i]*2;\n        dp[i]=3*x[i]+min(m1,m2);\n        seg1.update(i,dp[i]-(x[i]+2*x[i+1]));\n        seg2.update(i,dp[i]-x[i]);\n    }\n    rep(i,n)cout<<dp[i]<<endl;\n    cout<<dp[n]+(e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr auto INF = LIM< LL >::max() / 2;\n\nLL dp[ 1 << 17 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tint N, E, T;\n\tscanf( \"%d%d%d\", &N, &E, &T );\n\n\tVI X( N );\n\tfor_each( ALL( X ), []( int &x ){ scanf( \"%d\", &x ); } );\n\n\tif ( 2000 < N )\n\t{\n\t\treturn 1;\n\t}\n\n\tfill( ALL( dp ), INF );\n\tdp[0] = 0;\n\t// dp[i] := 左から i 枚目まで回収するのに，余計にかかる時間の最小値\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i, N )\n\t\t{\n\t\t\tchmin( dp[ j + 1 ], dp[i] + max( T, 2 * ( X[j] - X[i] ) ) );\n\t\t}\n\t}\n\n\tprintf( \"%lld\\n\", E + dp[N] );\n\tfflush( stdout );\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN],pos[MAXN],m,t,pre;\npriority_queue<pair<ll,int> > q;\nint n;\nint main(){\n\tfreopen(\"computer.in\",\"r\",stdin);\n\tfreopen(\"computer.out\",\"w\",stdout);\n\tSF(\"%d%lld%lld\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%lld\",&pos[i]);\n\tq.push(make_pair(0,0));\n\tint las=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]+t+pos[i]-pos[i-1];\n\t\twhile(1){\n\t\t\tpair<ll,int> x=q.top();\n\t\t\tif(2ll*(pos[i]-pos[x.second+1])<=t){\n\t\t\t\tdp[i]=min(dp[i],-x.first+pos[i]+t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\twhile(2ll*(pos[i]-pos[las+2])>t){\n\t\t\tlas++;\n\t\t\tpre=min(pre,dp[las]-pos[las]-2ll*pos[las+1]);\n\t\t}\n\t\tif((pos[i]-pos[las+1])*2ll>t)\n\t\t\tdp[i]=min(dp[i],pre+3ll*pos[i]);\n\t\tq.push(make_pair(-dp[i]+pos[i],i));\n\t}\n\tPF(\"%lld\",dp[n]+m-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define FF first\n#define SS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\n\nint n, T, L;\nint a[MAXN];\nLL dp[MAXN];\nPLI q[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d%d%d\", &n, &L, &T );\n\tlpi ( i, 1, n ) scanf ( \"%d\", &a[i] );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tdp[0] = 0;\n\tint l = 1, r = 0;\n\tint nl = 0;\n\tLL vl = LINF;\n\tq[++r] = MP ( dp[0] - a[1], 0 );\n\tlpi ( i, 1, n ){\n\t\twhile ( ( ( a[i] - a[nl+1] ) << 1 ) > T ){\n\t\t\tvl = min ( vl, dp[nl] - ( a[nl+1] << 1 ) );\n\t\t\t++nl;\n\t\t}\n\t\twhile ( l <= r && ( ( a[i] - a[q[l].SS+1] ) << 1 ) > T ) ++l;\n\t\tdp[i] = min ( vl + ( a[i] << 1 ), ( l <= r ) ? ( q[l].FF + a[i] + T ) : LINF );\n\t\twhile ( l <= r && ( q[r].FF >= dp[i] - a[i+1] ) ) --r;\n\t\tq[++r] = MP ( dp[i] - a[i+1], i );\n\t}\n\t\n//\tlpi ( i, 1, n ) cerr << dp[i] << \" \"; cerr << endl;\n\t\n\tcout << dp[n] + L << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double \n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\nusing namespace :: std;\n\n\nconst ll  maxn=1e5+500;\nconst ll inf=2e18+7;\n\nll dp[maxn];\nll a[maxn];\nll parminn[maxn];\nint main(){\n    fill(dp,dp+maxn,inf);\n    ll n,e,t;\n    cin>>n>>e>>t;\n    t*=2;\n    e*=2;\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n        a[i]*=2;\n    }\n    ll p=0;\n    dp[0]=0;\n    for(ll i=1;i<=n;i++){\n        while(p+1<i && a[i]-a[p]>=t/2){\n            p++;\n        }\n        if(p==0){\n            dp[i]=t;\n        }else{\n            dp[i]=min(dp[p]+t,parminn[p]+a[i]*2);\n        }\n        parminn[i]=min(parminn[i-1],dp[i-1]-a[i]*2);\n    }\n    cout<<(dp[n]+e)/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nconst long long INF = 1e18;\n\nint n, a[MAXN], e, t;\n\n#define lc (nd<<1)\n#define rc (nd<<1|1)\n\nstruct node {\n\tlong long x, y;\n\tnode()\n\t{ x = y = INF; }\n\tnode(long long _x, long long _y)\n\t{ x = _x, y = _y; }\n\tfriend node operator + (const node &a, const node &b)\n\t{ return (node) {min(a.x, b.x), min(a.y, b.y)}; }\n};\n\nnode dat[MAXN*8];\nlong long tag[MAXN*8];\n\ninline void update(int nd)\n{ dat[nd] = dat[lc]+dat[rc]; }\ninline void put_tag(int nd, int dt)\n{ dat[nd].x += dt, dat[nd].y += dt, tag[nd] += dt; }\ninline void pdw(int nd)\n{\n\tput_tag(lc, tag[nd]);\n\tput_tag(rc, tag[nd]);\n\ttag[nd] = 0;\n}\ninline void modify(int nd, int L, int R, int opl, int opr, int dt)\n{\n\tpdw(nd);\n\tif (L == opl && R == opr) put_tag(nd, dt);\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (opr <= mid) modify(lc, L, mid, opl, opr, dt);\n\t\telse if (opl > mid) modify(rc, mid+1, R, opl, opr, dt);\n\t\telse modify(lc, L, mid, opl, mid, dt), modify(rc, mid+1, R, mid+1, opr, dt);\n\t\tupdate(nd);\n\t}\n}\ninline void modify(int nd, int L, int R, int pos, const node &pt)\n{\n\tpdw(nd);\n\tif (L == R) dat[nd] = pt;\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (pos <= mid) modify(lc, L, mid, pos, pt);\n\t\telse modify(rc, mid+1, R, pos, pt);\n\t\tupdate(nd);\n\t}\n}\ninline node query(int nd, int L, int R, int opl, int opr)\n{\n\tif (opl > opr) return (node) {INF, INF}; \n\tpdw(nd);\n\tif (L == opl && R == opr) return dat[nd];\n\telse {\n\t\tint mid = (L+R)>>1;\n\t\tif (opr <= mid) return query(lc, L, mid, opl, opr);\n\t\telse if (opl > mid) return query(rc, mid+1, R, opl, opr);\n\t\telse return query(lc, L, mid, opl, mid)+query(rc, mid+1, R, mid+1, opr);\n\t}\n}\nconst int root = 1;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tmodify(root, 0, n, 0, (node) {0, -2*a[1]});\n\tint pos = -1;\n\tlong long dpv;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (pos+1 < i && 2ll*(a[i]-a[pos+2]) > t) pos++;\n\t\tdpv = min(query(root, 0, n, 0, pos).y+3ll*a[i]-a[i-1], query(root, 0, n, pos+1, i-1).x+a[i]-a[i-1]+t);\n\t\tmodify(root, 0, n, i, (node) {dpv, dpv-2*a[i+1]});\n\t\tmodify(root, 0, n, 0, i-1, a[i]-a[i-1]);\n\t\t// for (int j = 0; j < i; j++) dp[i][i] = min(dp[i][i], dp[i-1][j]+a[i]-a[i-1]+max(t, 2*(a[i]-a[j+1])));\n\t}\n\tcout << dpv+e-a[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\n#define gpf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nll n, e, T;\nll x[110000];\nll ans;\n\nint main(){\n\tscanf(\"%lld%lld%lld\", &n, &e, &T);\n\trep(i, 1, n) scanf(\"%lld\", x + i);\n\tans = x[1];\n\tll now = 1;\n\twhile (now <= n){\n\t\tll tt = 0;\n\t\twhile ((now + tt < n) && (x[now + tt + 1] - x[now] + (tt + 2) * T >= max((x[now + tt + 1] - x[now]) * 3, x[now + tt + 1] - x[now] + T))) tt++;\n\t\tans += max((x[now + tt] - x[now]) * 3, x[now + tt] - x[now] + T);\n\t\tnow += tt + 1;\n\t\tif (now <= n) ans += x[now] - x[now - 1];\n\t}\n\tprintf(\"%lld\\n\", ans + e - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 1;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid build(int u, int l, int r)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] = -x[l] * 2;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tbuild(lchild(u), l, mid);\n\tbuild(rchild(u), mid, r);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nvoid update(int u, int l, int r, int x, int val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nint query(int u, int l, int r, int b, int e)\n{\n\tif (r == l)\n\t\treturn mod;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tint mid = (l + r) / 2, tmp = inf;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 0, n)\n\t\tcin >> x[i];\n\tsort(x, x + n);\n\tbuild(0, 0, n);\n\tfori (i, 0, n)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n, 0, ind), T + (ind ? dp[ind - 1] : 0));\n\t\tif (i)\n\t\t\tupdate(0, 0, n, i, dp[i - 1]);\n\t}\n\tcout << dp[n - 1] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_map>\n# include <unordered_set>\n# include <thread>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing ui32 = unsigned int;\nconstexpr ll INFLL = 1e18;\n\n#define CHECK_IMPL1(cond)              \\\nif (!(cond)) {                         \\\n    DEBUG(\"expected cond: \" << #cond); \\\n    assert(cond);                      \\\n}\n\n#define CHECK_IMPL2(cond, message)                                            \\\nif (!(cond)) {                                                                \\\n    DEBUG(\"expected cond: \" << #cond << \" failed with message: \" << message); \\\n    assert(cond);                                                             \\\n}\n#define CHECK_IMPL(_1, _2, NAME, ...) NAME\n#define CHECK(...) CHECK_IMPL(__VA_ARGS__, CHECK_IMPL2, CHECK_IMPL1, CHECK_IMPL0)(__VA_ARGS__)\n\n#ifdef __APPLE__\n#define DEBUG(message) std::cerr << message << std::endl;\n#else\n#define DEBUG(message)\n#endif\n\nvoid solve() {\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n\n  vector<ll> x(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    cin >> x[i];\n  }\n\n  vector<ll> dp(n + 1, INFLL);\n  dp[0] = 0;\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < i; j++) {\n      dp[i] = min(dp[i], dp[j] + (x[i] - x[j + 1]) * 3 + max(0ll, t - 2 * (x[i] - x[j + 1])) + x[j + 1] - x[j]);\n    }\n//    cout << i << \" \" << dp[i] << endl;\n  }\n\n  cout << dp[n] + e - x[n] << \"\\n\";\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n#ifdef __APPLE__\n  freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", stdout);\n#endif\n  int t = 1;\n//  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r, x)     for (int i = l; i < r; i+=x)\n//#define ForE(i, l, r, x)    for (int i = l; i <= r; i+=x)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O \n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n//#define PrintV(a)           Fora(ii, a) cout << ii << ' '; cout << rl;\n//#define PrintVl(a)          Fora(ii, a) cout << ii << rl;\n//#define PrintA(a, l, r)     for (int ii = l; ii <= r; ii++) cout << a[ii] << ' '; cout << rl;\n//#define PrintAl(a, l, r)    for (int ii = l; ii <= r; ii++) cout << a[ii] << rl;\n//#define Ptest(x)            return cout << x, 0;\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calc    \n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 100005, MAX_M = 200010;\n// code\n#define int long long\nint n, x[MAXN], dp[MAXN], e, t;\n\nvoid Solve() {\n\tcin >> n >> e >> t; \n\tfor (int i = 1; i <= n; i++){\n\t    cin >> x[i];\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t    dp[i] = 1e18;\n\t    for (int j = 0; j < i; j++) \n\t        dp[i] = min(dp[i], dp[j] + max(2 * (x[i] - x[j+1]), t));\n\t}\n\t\n\tcout << dp[n] + e ;\n}\n\nsigned main(){\n    FAST_IO;\n    int TC = 1; \n\t//cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nlong long dp[maxn];\nlong long mi[maxn];\nlong long x[maxn];\nint q[maxn],head,tail;\nint main()\n{\n    int n,e,t;\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",x+i);\n    dp[n]=1LL*e-x[n]+t;\n    head=tail=0;\n    long long mi=5000000000000000000LL;\n    q[tail++]=n;\n    dp[n+1]=0;\n    x[n+1]=e;\n    for(int i=n-1;i;i--)\n    {\n        while(head<tail)\n        {\n            int u=q[head];\n            if((x[u]-x[i])*2>t){\n                mi=min(mi,dp[u+1]+x[u]*2+x[u+1]);\n                head++;\n            }\n            else break;\n        }\n        //printf(\"%d %lld %lld %lld %d %dss\\n\",i,dp[q[head]]+x[q[head]+1]-x[i]+t,mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i],head,tail);\n        dp[i]=min(mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i]);\n        if(head<tail)\n            dp[i]=min(dp[q[head]+1]+x[q[head]+1]-x[i]+t,dp[i]);\n\n        while(head<tail)\n        {\n            int u=q[tail-1];\n            if(dp[u+1]+x[u+1]>=dp[i+1]+x[i+1]){\n                tail--;\n            }\n            else break;\n        }\n        q[tail++]=i;\n    }\n    printf(\"%lld\\n\",dp[1]+x[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <bitset>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAXN = 100009;\nconst long long INF = 1000000000000000000;\n\nstruct SegmentTree {\n    long long tr_min[4 * MAXN];\n    long long tr_add[4 * MAXN];\n    int n;\n\n    SegmentTree(int n) : n(n) {\n        memset(tr_min, 0, sizeof(tr_min));\n        memset(tr_add, 0, sizeof(tr_add));\n    }\n\n    void setVal(int id, long long val) {\n        setVal(0, 0, n, id, val);\n    }\n\n    void setVal(int v, int vl, int vr, int id, long long val) {\n        push(v, vl, vr);\n        if (vl > id || vr <= id) {\n            return;\n        }\n        if (vr - vl == 1) {\n            tr_min[v] = val;\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        setVal(2 * v + 1, vl, vm, id, val);\n        setVal(2 * v + 2, vm, vr, id, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    void addTree(int l, int r, long long val) {\n        if (l > r)\n            return;\n        addTree(0, 0, n, l, r + 1, val);\n    }\n\n    long long getMin(int l, int r) {\n        return getMax(0, 0, n, l, r + 1);\n    }\n\n    void push(int v, int vl, int vr) {\n        tr_min[v] += tr_add[v];\n        if (vr - vl > 1) {\n            tr_add[2 * v + 1] += tr_add[v];\n            tr_add[2 * v + 2] += tr_add[v];\n        }\n        tr_add[v] = 0;\n    }\n\n    void addTree(int v, int vl, int vr, int l, int r, long long val) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return;\n        }\n        if (vl >= l && vr <= r) {\n            tr_add[v] += val;\n            push(v, vl, vr);\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        addTree(2 * v + 1, vl, vm, l, r, val);\n        addTree(2 * v + 2, vm, vr, l, r, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    long long getMax(int v, int vl, int vr, int l, int r) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return INF;\n        }\n        if (vl >= l && vr <= r) {\n            return tr_min[v];\n        }\n        int vm = (vl + vr) / 2;\n        long long max1 = getMax(2 * v + 1, vl, vm, l, r);\n        long long max2 = getMax(2 * v + 2, vm, vr, l, r);\n        return min(max1, max2);\n    }\n};\n\nlong long x[MAXN];\nlong long f[MAXN];\n\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    x[0] = 0;\n    f[0] = 0;\n    SegmentTree tree(n);\n    tree.addTree(0, 0, x[1] - x[0] + t);\n    int idt = 0;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = tree.getMin(0, i - 1);\n        if (i == n)\n            break;\n        int pidt = idt;\n        while ((x[i + 1] - x[idt + 1]) * 2 > t) {\n            tree.setVal(idt, f[idt] + x[i + 1] - x[idt] + (x[i + 1] - x[idt + 1]) * 2);\n            ++idt;\n        }\n        tree.setVal(i, f[i] + x[i + 1] - x[i] + t);\n        tree.addTree(idt, i - 1, x[i + 1] - x[i]);\n        tree.addTree(0, pidt - 1, 3 * (x[i + 1] - x[i]));\n    }\n    long long ans = f[n] + e - x[n];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nlong long dp[N];\nint x[N];\nint main(){\n\tint n,e,t,l;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[l]+max(2*(x[i]-x[l+1]),t);\n\t\twhile(l+1<i&&dp[l+1]+max(2*(x[i]-x[l+2]),t)<dp[i]){\n\t\t\tdp[i]=dp[l+1]+max(2*(x[i]-x[l+2]),t);\n\t\t\tl++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define INF 0x3FFFFFFF\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN],pos[MAXN],m,t,pre=INF;\npriority_queue<pair<ll,int> > q;\nint n;\nint main(){\n\tSF(\"%d%lld%lld\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%lld\",&pos[i]);\n\tq.push(make_pair(0,0));\n\tint las=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=dp[i-1]+t+pos[i]-pos[i-1];\n\t\twhile(1){\n\t\t\tpair<ll,int> x=q.top();\n\t\t\tif(2ll*(pos[i]-pos[x.second+1])<=t){\n\t\t\t\tdp[i]=min(dp[i],-x.first+pos[i]+t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\twhile(2ll*(pos[i]-pos[las+1])>t){\n\t\t\tpre=min(pre,dp[las]-pos[las]-2ll*pos[las+1]);\n\t\t\tlas++;\n\t\t}\n\t\tif(pre!=INF)\n\t\t\tdp[i]=min(dp[i],pre+3ll*pos[i]);\n\t\tq.push(make_pair(-dp[i]+pos[i],i));\n\t}\n\tPF(\"%lld\",dp[n]+m-pos[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N, E;\nlong long T;\nint x[100010];\nlong long dp[100010][2];\n\nint main() {\n  cin >> N >> E >> T;\n  for (int i=0; i<N; i++) cin >> x[i];\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; j<2; j++) {\n      dp[i][j] = 1LL<<60;\n    }\n  }\n  dp[0][0] = x[0];\n  dp[0][1] = x[0] + T;\n  for (int i=0; i<N; i++) {\n    for (int j=i+1; j<N; j++) {\n      long long d = abs(x[j] - x[i]);\n      dp[j][0] = min(dp[j][0], dp[i][0] + d + T*(j-i));\n      dp[j][0] = min(dp[j][0], dp[i][1] + d + T*(j-i-1));\n      dp[j][1] = min(dp[j][1], dp[j][0] + T);\n      dp[j][1] = min(dp[j][1], dp[i][0] + max(2*d, T) + d);\n    }\n  }\n  cout << dp[N-1][1] + E - x[N-1] << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    assert(N <= 2000);\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1,1e18);\n    dp[0] = 0;\n    auto calc=[&](int i, int j) {\n        return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2)*(i-j);\n    };\n    vector<int> rev(N+1);\n    int cur = 0;\n    for (int i = 1; i <= N; i++) {\n        //while (cur < i-1 and calc(i,cur) >= calc(i,cur+1)) cur++;\n        //dp[i] = calc(i,cur);\n        rep(j,i) {\n            if (chmin(dp[i],calc(i,j))) rev[i] = j+1;\n        }\n    }\n    // for (int i = 1; i <= N; i++) {\n    //     cout << i << \" \";\n    // }\n    // cout << ln;\n    // for (int i = 1; i <= N; i++) {\n    //     cout << rev[i] << \" \";\n    // }\n    // cout << ln;\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mini=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[j]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t;\nint x[100005];\nll dp[100005];\nint main(){\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++){\n        dp[i] = 1000000000000000000;\n        while (pivot+1 < i && 2*(x[i]-x[pivot+2]) < t) {\n            mn = min(mn,dp[pivot]-2*x[pivot+1]);\n            pivot++;\n        }\n        //printf(\"pivot for %d = %d\\n\",i,pivot);\n        dp[i] = min(2*x[i]+mn,dp[pivot]+t);\n        //printf(\"%lld first\\n\",dp[i]);\n        /*dp[i] = 1000000000000000000;\n        for (int j = 0; j < i; j++){\n            if ((x[i]-x[j+1])*2 <= t){\n                printf(\"pivot at %d\\n\",j);\n            }\n            //printf(\"%lld + %d\\n\",dp[j],max(t,(x[i]-x[j+1])*2));\n            dp[i] = min(dp[i],dp[j]+max(t,(x[i]-x[j+1])*2));\n        }\n        printf(\"%lld second\\n\",dp[i]);*/\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define maxn 100010\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\nint a[maxn], q[maxn];\nlong long f[maxn];\nint main()\n{\n\tint n,m,T;\n        scanf(\"%d%d%d\",&n,&m,&T);\n\tfor (int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tint p = 1, head = 0, tail = 0;\n        long long fp = 1234567891234567ll;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\twhile ((a[i] - a[p]) * 2 > T) cmin(fp, f[p - 1] - 2 * a[p]), ++p;\n\t\twhile (head < tail && (a[i] - a[q[head + 1]]) * 2 > T) ++head;\n\t\tf[i] = 1ll * i * T;\n\t\tcmin(f[i], fp + 2 * a[i]);\n\t\thead < tail ? cmin(f[i], f[q[head + 1] - 1] + T) : 0;\n\t\tcmin(f[i], f[i - 1] + T);\n\t\twhile (head < tail && f[q[tail] - 1] > f[i]) --tail;\n\t\tq[++tail] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long f[101010];\nlong long a[101010];\nint main()\n{\n\tint n,e,t,now=1;\n\tlong long mi=21474836478ll;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tf[0]=0;\n\tf[1]=t;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile((a[i]-a[now])*2>t)\n\t\t{\n\t\t\tmi=min(mi,f[now-1]-2*a[now]);\n\t\t\tnow++;\n\t\t}\n\t\tf[i]=f[now-1]+t;\n\t\tf[i]=min(f[i],mi+2*a[i]);\n\t}\n\tprintf(\"%lld\",(long long)e+f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 1e5 + 7;\nint n, E, T;\nLL f[N], x[N];\nint main() {\n#ifdef fwat\n#endif\n\tn = gi(), E = gi(), T = gi();\n\tif(n > 2000) return puts(\"gg\"), 0;\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0;\n\trep(i, 1, n) x[i] = gi();\n\trep(i, 1, n) {\n\t\tfor(int j = 0; j < i; ++j) {\n\t\t\tLL dis = 2 * (x[i] - x[j + 1]);\n\t\t\tMin(f[i], f[j] + dis + max(0ll, T - dis));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nint e,n,wait;\nint pos[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&e,&wait);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&pos[i]);\n\tfor (int i=1; i<=n; ++i) f[i]=LLONG_MAX/2;\n\tf[0]=0;\n\tfor (int now=0; now<n; ++now){\n\t\tint x=-1;\n\t\tfor (int l=now+1,r=n,mid=(l+r)>>1; l<=r; mid=(l+r)>>1)\n\t\tif (2*(pos[mid]-pos[now+1])<=wait) x=mid,l=mid+1; else r=mid-1;\n\t\t\n\t\tlong long tmp=0;\n\t\tif (2*(pos[x]-pos[now+1])<=wait){\n\t\t\ttmp+=2ll*(pos[x]-pos[now+1]);\n\t\t\ttmp+=(ll)(wait-2*(pos[x]-pos[now+1]));\n\t\t\tf[x]=min(f[x],f[now]+tmp);\n\t\t}\n\t\tif (x<n){\n\t\t\t++x;\n\t\t\tf[x]=min(f[x],f[now]+2ll*(pos[x]-pos[now+1]));\n\t\t}\n\t\tfor (int x=now+1; x<=n&&x-now<=1000; ++x){\n\t\t\tf[x]=min(f[x],f[now]+max(2*(pos[x]-pos[now+1]),wait));\n\t\t}\n\t\tf[now+1]=min(f[now+1],f[now]+wait);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <memory>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<ll> dp(N + 1, LLONG_MAX);\n\tdp[0] = 0;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tdp[j] = min(dp[j], dp[i] + max(T - (x[j - 1] - x[i]), x[j - 1] - x[i]) + x[j - 1] - x[i]);\n\tcout << dp[N] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define WHOLE(v) (v).begin(), (v).end()\n#define REV_WHOLE(v) (v).rbegin(), (v).rend()\nusing i64 = int64_t;\nusing namespace std;\ntemplate<class F>auto recursive(F f){return[f](auto...a){return f(f,a...);};}\ntemplate<class T>using rev_priority_queue=priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T>using vector2d=vector<vector<T>>;\nstruct fixprec{int p;fixprec(int p):p(p){}};\nostream&operator<<(ostream&o,fixprec f){return o<<fixed<<setprecision(f.p);}\n\n/*!* [minmax_assign] *!*/\n/*+* 最大値、最小値の代入 *+*/\ntemplate<class T>void max_assign(T&x,const T y){x=max(x,y);}\ntemplate<class T>void min_assign(T&x,const T y){x=min(x,y);}\n\n/*!* [binsearch] *!*/\n/*+* 二分探索 *+*/\n// judge を満たすような(l,r]内の下限を求める\n// l:[X] 定義域の下端\n// r:[X] 定義域の上端\n// judge:[F = X -> bool] 値 X を評価する関数\n// lower:[bool] false にすると代わりに[l,r)内の上限を求める\n// eps:[X] 終了距離\n\ntemplate <typename X, typename F>\nX BinSearch(X l, X r, F judge, bool lower = true, X eps = 1) {\n    while (r - l > eps) {\n        X m = (r + l) / 2;\n        if (judge(m) == lower) {\n            r = m;\n        } else {\n            l = m;\n        }\n    }\n    return lower ? r : l;\n}\n\n/*!* [segtree] *!*/\n/*+* セグメント木 *+*/\n// Tは $f : T \\to T$ についてモノイドである必要がある。\n// Fの型をdecltype(f)とすると高速になる。\ntemplate <typename T, typename F = function<T(T, T)>>\nstruct SegTree {\n    int N;\n    vector<T> array; \n    const F f;\n    const T id;\n    SegTree() {}\n    // len : データ長, f : 二項演算, identity: 初期値(単位元)\n    SegTree(int len, const F f, const T &id) : f(f), id(id) {\n        for(N = 1; N < len; N <<= 1);\n        array.reserve(2 * N - 1);\n        array.assign(2 * N - 1, id);\n    }\n    \n    // 値の更新 O(\\log N)$\n    // k : 添字, val : 値\n    void update(int k, T val) {\n        k += N;\n        array[k] = val;\n        while(k >>= 1) array[k] = f(array[2 * k], array[2 * k + 1]);\n    }\n    \n    // 値の取り出し O(1)$\n    // k : 添字\n    T operator[] (int k) { return array[k + N]; }\n\n    // 範囲検索 O(\\log N)$\n    // [L : R] の範囲について、f( [L : R] ) を求める\n    T query(int l, int r) {\n        T L = id, R = id;\n        for(l += N, r += N, r++; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) L = f(L, array[l++]);\n            if(r & 1) R = f(array[--r], R);\n        }\n        return f(L, R);\n    }\n};\n\nint main() {\n    const i64 INF = 1e12;\n    i64 N, E, T;\n    cin >> N >> E >> T;\n    vector<i64> x = {0};\n    for(int i = 0; i < N; i++) {\n        i64 a;\n        cin >> a;\n        x.push_back(a);\n    }\n    auto f_min = [](i64 a, i64 b) -> i64 { return min(a, b); };\n    vector<i64> dp(N + 1, INF);\n    dp[0] = 0;\n    SegTree<i64, decltype(f_min)> seg_front(N + 1, f_min, INF),\n                                   seg_back(N + 1, f_min, INF);\n\n    seg_front.update(0, -2 * x[1]);\n    seg_back.update(0, 0);\n    for(int k = 1; k <= N; k++) {\n        int j = BinSearch<int>(-1, k, [&](int i) -> bool {\n            return 2 * (x[k] - x[i + 1]) < T;\n        });\n        if (j > 0) {\n            min_assign(dp[k], 3 * x[k] + seg_front.query(0, j - 1));\n        }\n        min_assign(dp[k], x[k] + T + seg_back.query(j, N));\n        if(k < N) {\n            seg_front.update(k, dp[k] - x[k] - 2 * x[k + 1]);\n            seg_back.update(k, dp[k] - x[k]);\n        }\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n\n#define llint long long int\n#define N 100005\n#define MAX(x,y) ((x)<(y)?(y):(x))\n\nint main(void){\n  int n,e,t;\n  //std::priority_queue<int, std::vector<int>, std::greater<int> > x;\n  llint x[N];\n  llint total = 0;\n  int now = 0;\n  \n  std::cin >> n >> e >> t;\n\n  //int temp;\n  for(int i=1; i<=n; i++){\n    std::cin >> x[i];\n    //  std::cin >> temp;\n    //    x.push(temp);\n  }\n\n  for(int i=1; i<=n; i++){\n    int nnext = i;\n    while(1){\n      if(x[nnext+1] - x[i] <= t and nnext != n){\n\tnnext++;\n      }else break;\n    }\n\n    \n    total += (x[i]-now) + MAX(0, t-2*(x[nnext]-x[i])) + 3*(x[nnext]-x[i]);\n    i = nnext;\n    now = x[nnext];\n  }\n  std::cout << (total+e-x[n]) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\nusing namespace std;\nlong long dp[100010];\nint x[100010];\nint n,e;\nlong long t;\nint st;\nmultiset<long long>s1,s2;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\ts2.insert(t);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(st+1<i && 2*(x[i]-x[st+1])>=t)\n\t\t{\n\t\t\ts2.erase(dp[st]-x[st]+t);\n\t\t\ts1.insert(dp[st]-x[st]-2LL*x[st+1]);\n\t\t\tst++;\n\t\t}\n\t\tdp[i]=4e18;\n\t\tif(s1.size())dp[i]=min(dp[i],(*s1.begin())+3LL*x[i]);\n\t\tif(s2.size())dp[i]=min(dp[i],x[i]+(*s2.begin())),\n\t\ts2.insert(dp[i]-x[i]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long INF = 1e18;\nconst int N = 210110;\nconst int MOD = 998244353;\nconst double eps = 1e-8;\n\nll n, e, t;\nll a[N];\n\nll dp[N];\nll kek, j = -1;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    kek = 1e18;\n    set<pair<int, int> > ss;\n    for (int i = 0; i < n; i++)\n    {\n        dp[i] = (i > 0 ? dp[i - 1] : 0) + t;\n        while (2 * (a[i] - a[j + 1]) >= t)\n        {\n            ss.erase({dp[j + 1], j + 1});\n            kek = min(kek, (j ? dp[j] : 0) - 2 * a[j + 1]);\n            j++;\n        }\n        if (ss.size())\n        {\n            pair<int, int> it = *(ss.begin());\n            dp[i] = min(dp[i], min(it.first + t, kek + 2 * a[i]));\n        }\n        else\n        {\n            dp[i] = min(dp[i], kek + 2 * a[i]);\n        }\n        ss.insert({dp[i], i});\n        //cout << j << \" \" << kek << \" \" << dp[i] << endl;\n    }\n    cout << dp[n - 1] + e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=2010;\n\tconst ll INF=9223372036854775807ll;\n\tint a[N],b[N];\n\tint n,m;\n\tll ans;\n\tvoid initialize()\n\t{\n\t\tread(n),read(a[n]),read(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tread(a[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tb[i]=a[i]-a[i-1];\n\t}\n\tinline ll get_dis(int i,int j){return a[j]-b[j]-a[i];}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=a[n];\n\t\tfor(int i=1,j;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;j<n && get_dis(i,j+1)*2<=m;j++);\n\t\t\tans+=m;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n//\tfreopen(\"out\",\"w\",stdout);\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node; \npublic:\n    SegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, inf);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b) return node[k];\n \n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    SegmentTree seg1(vector<ll>(N+1,inf)),seg2(vector<ll>(N+1,inf));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.update(0,dp[0]-X[1]);\n    seg2.update(0,dp[0]-3*X[1]);\n    for(int i=1;i<=N;i++){\n        dp[i] = dp[i-1]+X[i+1]-X[i]+T;\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        //cerr << i << \" \" << id << endl;\n        if(id<i) dp[i] = min(dp[i],seg1.getmin(id,i)+T+X[i+1]);\n        if(id>=i-1) id = i-1;\n        dp[i] = min(dp[i],seg2.getmin(0,id)+2*X[i]+X[i+1]);\n        seg1.update(i,dp[i]-X[i+1]);\n        seg2.update(i,dp[i]-3*X[i+1]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nlong long int dp2[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tint p=0,mini=1e9;\n\tdp[0]=t;\n\tdp2[0]=dp[0]-x[1]*2;\n\tfor(int i=1;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Min=0,Max=i-1;\n\t\twhile(Max-1>Min){\n\t\t\tint mid=(Max+Min)/2;\n\t\t\tif((x[i]-x[mid+1])*2<t){\n\t\t\t\tMin=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tMax=mid;\n\t\t\t}\n\t\t}\n\t\tif((x[i]-x[p+1])*2>t)\n\t\tp++;\n\t\tdp[i]=min(x[i]*2+dp2[p-1],t+dp[p]);\n\t\tdp2[i]=min(dp2[i-1],dp[i]-x[i+1]*2);\n\t//\tprintf(\"%d\\n\",dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 100005\n#define INF 0x3f3f3f3f3f3f3f3f\n\ntypedef long long lint;\n\n\nusing namespace std;\n\nint n, t, e;\nlint f[MAXN], d[MAXN], v[MAXN];\ndeque<int> p, q;\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nvoid pushp(int x) {\n    while (!p.empty() && f[x] + v[x + 1] - d[x + 1] < f[p.back()] + v[p.back() + 1] - d[p.back() + 1])\n        p.pop_back();\n    p.push_back(x);\n}\n\nvoid pushq(int x) {\n    while (!q.empty() && f[x] + v[x + 1] - d[x + 1] * 3 < f[q.back()] + v[q.back() + 1] - d[q.back() + 1] * 3)\n        q.pop_back();\n    q.push_back(x);\n}\n\nint main() {\n    n = read();\n    e = read();\n    t = read();\n    for (int i = 1; i <= n; ++i) {\n        d[i] = read();\n        v[i] = d[i] - d[i - 1];\n    }\n    p.push_back(0);\n    for (int i = 1, j; i <= n; ++i) {\n        while (!p.empty() && (d[i] - d[p.front() + 1]) * 2 > t) {\n            pushq(p.front());\n            p.pop_front();\n        }\n        f[i] = INF;\n        if (!p.empty()) {\n            j = p.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] + d[i] + t);\n        }\n        if (!q.empty()) {\n            j = q.front();\n            f[i] = min(f[i], f[j] + v[j + 1] - d[j + 1] * 3 + d[i] * 3);\n        }\n        pushp(i);\n    }\n    printf(\"%lld\\n\", f[n] + abs(e - d[n]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll INF = 1ll<<50;\n\n// セグメント木(RMQ 対応)\n// update: k 番目の値を a に変更\n// query: [l, r) の区間の最大値を求める\ntemplate<typename T>\nstruct ST {\n    vector<T> seg;\n    int size;\n    ST(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        seg.resize(2*size-1, INF);\n    }\n    inline T merge(T x, T y) {\n        return min(x, y);\n    }\n    void update(int k, T a) {\n        k += size-1;\n        seg[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            seg[k] = merge(seg[k*2+1], seg[k*2+2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INF;\n        if (a <= l && r <= b) return seg[k];\n        T vl = query(a, b, k*2+1, l, (l+r)/2);\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, size);\n    }\n};\n\nconst int MAXN = 100100;\nint N, E, T;\nint X[MAXN];\nll dp[MAXN];\n\nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i];\n\tconst ll INF = 1ll<<60;\n\tST<ll> seg(N+10);\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i] = INF;\n\t}\n\tX[N] = E;\n\tdp[N] = 0;\n\tseg.update(N, dp[N] + X[N] + 2*X[N-1]);\n\tfor (int i = N-1; i >= 0; i--) {\n\t\t// まず T が支配的な部分を探索\n\t\tint low = i, high = N;\n\t\twhile (high - low > 1) {\n\t\t\tconst int med = (low + high) / 2;\n\t\t\tif (2*(X[med]-X[i]) <= T) {\n\t\t\t\tlow = med;\n\t\t\t} else {\n\t\t\t\thigh = med;\n\t\t\t}\n\t\t}\n\t\t//cout << i << \" \" << low << endl;\n\t\tdp[i] = dp[low+1] + X[low+1] - X[i] + T;\n\t\tdp[i] = min(dp[i], seg.query(low+1, N) - 3*X[i]);\n\t\tif (i) seg.update(i, dp[i+1] + 2*X[i] + X[i+1]);\n\t\t//cout << i << \" \" << dp[i] << endl;\n\t}\n\tcout << X[0] + dp[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst ll MAX = 1e5 + 10, inf = 1e17+1;\n\nll n, e, t, dp[MAX], x[MAX], p[MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    fill (dp, dp+MAX, inf);\n    fill (p, p+MAX, inf);\n    cin >> n >> e >> t;\n    for (int i = 0; i < n; i++)\n        cin >> x[i + 1];\n    dp[0] = 0;\n    p[0] = -2 * x[1];\n    for (int i = 1; i <= n; i++)\n    {\n        int j = lower_bound(x + 1, x + n + 1, x[i] - t / 2) - x;\n        j--;\n        if (j > 0)\n            dp[i] = p[j-1] + 2 * x[i];\n        dp[i] = min(dp[i], dp[j] + t);\n        p[i] = min(p[i-1], dp[i] - 2 * x[i+1]);\n        //cout << i << \" \" << j << \" \" << dp[i] << \" \" << p[i] << \"\\n\";\n    }\n    cout << dp[n] + e  << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nlong long dp[2020][2020];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    vector<long long> d(n), ds(n + 1);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    if (n > 2000) return 0;\n\n    fill_n(*dp, 2020 * 2020, 1e17);\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            // wait\n            if (j == 0) {\n                chmin(dp[i + 1][0], dp[i][j] + T + d[i]);\n            }\n\n            // return\n            if (j > 0) {\n                long long dist = ds[i] - ds[i - j];\n                chmin(dp[i + 1][0], dp[i][j] + d[i] + max(0LL, T - 2 * dist) + dist * 2);\n            }\n\n            // ignore\n            if (i < n - 1) {\n                chmin(dp[i + 1][j + 1], dp[i][j] + d[i]);\n            }\n        }\n    }\n\n    long long ans = dp[n][0] + x[0] + (E - x[n - 1]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#ifdef LOCAL\n#define TIMER cerr<<clock()<<\"ms\\n\"\n#else\n#define TIMER\n#endif\n#define SZ 666666\nint n,e,t,x[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",x+i);\n\tll ans=x[1];\n\tint pos=0; x[0]=x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint l=x[i]-x[pos];\n\t\tif(l<t) continue;\n\t\tif(l*2>(i-pos)*(ll)(t))\n\t\t{\n\t\t\tint g=i-1;\n\t\t\tint l2=x[g]-x[pos];\n\t\t\tif(2*l2>=t) ans+=min(l2*3LL,(g-pos)*ll(t)+l2);\n\t\t\telse ans+=(g-pos)*ll(t)+l2;\n\t\t\tpos=g;\n\t\t}\n\t}\n\t{\n\t\tint g=n;\n\t\tint l2=x[g]-x[pos];\n\t\tif(2*l2>=t) ans+=min(l2*3LL,(g-pos)*ll(t)+l2);\n\t\telse ans+=(g-pos)*ll(t)+l2;\n\t\tpos=g;\n\t}\n\tans+=e-x[n];\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,t,e;\nint x[100005];\nvector<int>vec[100005],ng;\nll dp[100005];\nint main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tfor(int i=1;i<n;i++){\n\t\tint y = x[i+1]-x[i];\n\t\tif(y > t/2){\n\t\t\tng.pb(i);\n\t\t}\n\t}\n\tng.pb(n);\n\tfor(int i=1;i<=n;i++){\n\t\tint c = x[i]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tvec[i].pb(f-1);\n\t\tvec[i].pb(i);\n\t\tf = lower_bound(ng.begin(),ng.end(),c)-ng.begin();\n\t\tif(f == ng.size()) vec[i].pb(n); else vec[i].pb(ng[f]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = 1e18;\n\t}\n\t//return 0;\n\tdp[0] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i] > 1e17) continue;\n\t\tint c = x[i+1]+t/2;\n\t\tint f = upper_bound(x+1,x+n+1,c)-x;\n\t\tint beg = f-1;\n\t\tfor(int j=beg;j<=min(n,beg+500);j++){\n\t\t    ///cout<<vec[i+1][j]<<endl;\n\t\t\tll dif = x[j]-x[i+1];\n\t\t\tll ans = dp[i];\n\t\t\tans += x[i+1]-x[i];\n\t\t\tans += dif+max(dif*2LL,1LL*t);\n\t\t\tdp[j] = min(dp[j],ans);\n\t\t\t//cout<<dp[vec[i+1][j]]<<\" \"<<dp[i]<<\" \" <<vec[i+1][j]<<\" \"<<i+1<<endl;\n\t\t}\n\t}\n\tcout<<dp[n]+e-x[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:60777216\")  \n\n#include <cassert>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<complex>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<cstdlib>\n#include<memory.h>\n#include<ctime>\n#include<bitset>\n#include<fstream>\n#include<queue>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef long double ld;\n\ntypedef long long ll;\ntypedef pair<int,int>\tpii;\ntypedef pair<ld,ld>\tpdd;\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef pair<ll,ll> pl;\n\n#define FOR(i,a,b)\t\tfor(int i=(a);i<(b);i++)\n#define REP(i,n)\t\tFOR(i,0,n)\n#define SORT(v)\t\t\tsort((v).begin(),(v).end())\n#define UN(v)\t\t\tSORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())\n#define CL(a,b)\t\t\t\tmemset(a,b,sizeof a)\n#define pb\t\t\t\tpush_back\n\nint n,e,t;\nint x[222222];\n\n\nll  r[222222];\nint p[222222];\n\nll solve(int from,int to){\n\treturn max(2*x[to]-2*x[from+1],t);\n}\n\nint main(){\t\n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>e>>t;\n\tif(n>2000)return 0;\n\tREP(i,n)scanf(\"%d\",x+i+1);\n\tFOR(i,1,n+1){\n\t\tr[i]=1e18;\n\t\tREP(prev,i)r[i]=min(r[i],r[prev]+solve(prev,i));\n\t/*\tint prev = p[i-1];\n\t\tr[i] = r[prev] + solve(prev,i);\n\t\twhile(prev+1<i && r[i] > r[prev+1]+solve(prev+1,i)){\n\t\t\tprev++;\n\t\t\tr[i] = r[prev] + solve(prev,i);\n\t\t}\n\t\tp[i] = prev;*/\n\t}\n\n\tcout<<r[n]+e<<endl;\n\n\n\n#ifdef LocalHost\n\tprintf(\"TIME: %.3lf\\n\",ld(clock())/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//By Don4ick\n//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define y1 qwer1234\n\nconst double PI = acos(-1.0);\nconst int DIR = 4;\nconst int X[] = {1, 0, -1, 0};\nconst int Y[] = {0, 1, 0, -1};\n\nusing namespace std;\n\nconst int N = 1e5 + 123;\nconst ll inf = 1e18;\n\nll n, T, e, dp[N], x[N];\nll t[4 * N][2];\n\nll get(int v, int tl, int tr, int l, int r,int k){\n\tif(l > r)\n\t\treturn inf;\n\tif(tl == l && tr == r)\n\t\treturn t[v][k];\n\tint tm = (tl + tr) / 2;\n\treturn min(get(v + v, tl, tm , l, min(tm, r), k), get(v + v + 1, tm + 1, tr, max(tm + 1, l), r, k));\n}\n\nvoid upd(int v, int tl, int tr, int pos, ll val,int k){\n\tt[v][k] = min(t[v][k], val);\n\tif(tl == tr)\n\t\treturn;\n\tint tm = (tl + tr) / 2;\n\tif(pos <= tm)                  \n\t\tupd(v + v, tl, tm, pos, val, k);\n\telse\n\t\tupd(v + v + 1, tm + 1, tr, pos, val, k);\n}\n\n\nint main()\n{\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(NULL);\n\t//cout.tie(NULL);\n\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tfor(int i = 0; i < 4 * N; i++)\n\t\tt[i][0] = t[i][1] = inf;\n\tcin >> n;\n\tcin >> e >> T;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\t\n\tdp[1] = x[1];\n\tx[n + 1] = e;\n\tfor(int i = 1, j = 1; i <= n; i++){\n        upd(1, 1, n, i, dp[i] - x[i], 0);\n\t\tupd(1, 1, n, i, dp[i] - 3 * x[i], 1);  \n\t\t                                         \n        while(j <= i && max(0ll, T - 2 * (x[i] - x[j])) == 0)\n        \tj++;\n        \n        dp[i + 1] = min(T + get(1, 1, n, j, i, 0) + x[i], get(1, 1, n, 1, j - 1, 1) + 3 * x[i]) + x[i + 1] - x[i];\n\t}\n\tcout << dp[n + 1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int \n#define ll long long \n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\nusing namespace std;\nll f[1010100],N,T,E,X[1010000];\nll S[1010000];\ninline void Modify(int now,int l,int r,int pos,ll d) {\n\tif(l==r) {S[now]=d;return ;}\n\tint mid=(l+r)>>1;\n\tif(pos<=mid) Modify(now<<1,l,mid,pos,d);\n\telse Modify(now<<1|1,mid+1,r,pos,d);\n\tS[now]=min(S[now<<1],S[now<<1|1]);\n}\ninline ll Qry(int now,int l,int r,int x,int y){\n\tif(x<=l&&r<=y) return S[now];\n\tll res=1e18;\n\tint mid=(l+r)>>1;\n\tif(x<=mid) res=min(res,Qry(now<<1,l,mid,x,y));\n\tif(y>mid) res=min(res,Qry(now<<1|1,mid+1,r,x,y));\n\treturn res;\n}\nint main(){\n\tcin>>N>>E>>T;\n\tf[1]=0;\n\tfor(rint i=1;i<=N;++i) {\n\t\tcin>>X[i];\n\t}\n\tfor(rint i=1;i<=N<<2;++i) S[i]=1e18;\n\tint now=0;\n\tll Min=1e18;\n\tX[N+1]=E;\n\tModify(1,1,N,1,-X[1]);\n\tfor(rint i=2;i<=N+1;++i){\n\t\twhile((now+1<i)&&2*(X[i-1]-X[now+1])>=T) now++,Min=min(Min,f[now]-3*X[now]);\n\t\tf[i]=Min+3*X[i-1]+X[i]-X[i-1];\n\t\t\n\t\t\n\t\tif(now+1<i)\n\t\tf[i]=min(f[i],Qry(1,1,N,now+1,i-1)+X[i-1]+T+X[i]-X[i-1]);\n\t\tModify(1,1,N,i,f[i]-X[i]);//debug(i);debug(f[i]);\n\t}\n\tcout<<f[N+1]+X[1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\n//pair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>=val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,1000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get(1,0,n,l,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg2[id].first==0||seg2[id].first>val){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    \n    ll N,E,T; cin >> N >> E >> T;\n    //assert(N <= 2000);\n    //cout << N << \" \" << E << \" \" << T << ln;\n    vector<ll> x(N+1);\n    rep(i,N) cin >> x[i+1];\n    //rep(i,N) cout << x[i+1] << \" \";\n    //cout << ln;\n\n    vector<ll> dp(N+1,1e18);\n    dp[0] = 0;\n    auto calc=[&](int i, int j) {\n        return dp[j]+(x[i]-x[j+1])*2+max(0LL,T-(x[i]-x[j+1])*2);\n    };\n    // vector<int> rev(N+1);\n    int cur = 0;\n    for (int i = 1; i <= N; i++) {\n        while (cur < i-1 and calc(i,cur) >= calc(i,cur+1)) cur++;\n        dp[i] = calc(i,cur);\n        // rep(j,i) {\n        //     if (chmin(dp[i],calc(i,j))) rev[i] = j+1;\n        // }\n    }\n    // for (int i = 1; i <= N; i++) {\n    //     cout << i << \" \";\n    // }\n    // cout << ln;\n    // for (int i = 1; i <= N; i++) {\n    //     cout << rev[i] << \" \";\n    // }\n    // cout << ln;\n\n    cout << dp[N]+E << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\t//freopen(\"i.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long n, e, t;\n\tcin >> n >> e >> t;\n\t\n\tlong long arr[n+1];\n\tfor(int i = 1;i <= n;i++) cin >> arr[i];\n\tarr[0] = 0;\n\tlong long dp[n+1];\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tdp[i] = 10234567890123242;\n\t\tfor(int j = 0;j < i;j++){\n\t\t\tlong long ans = dp[j];\n\t\t\tans += arr[j+1] - arr[j];\n\t\t\tans += max(2 * (arr[i] - arr[j+1]), t);\n\t\t\tans += arr[i] - arr[j+1];\n\t\t\tdp[i] = min(dp[i],ans);\n\t\t}\n\t}\n\t\n\t//for(int i = 1;i <= n;i++) cout << dp[i] << \" \";\n\t\n\tcout << dp[n] + (e-arr[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define SZ(a) (int)((a).size())\n\nconst int MAXN = 100007;\nconst int INF = 1000000007;\nconst LL LINF = INF * (LL)INF;\n\nLL A[MAXN], DP[MAXN], T1[4 * MAXN], T2[4 * MAXN];\n\nLL query(int v, int tl, int tr, int l, int r, LL * const T)\n{\n\tif (l > r) return LINF;\n\tif (l == tl && r == tr) return T[v];\n\tint tm = (tl + tr) / 2;\n\treturn min(query(v * 2, tl, tm, l, min(r, tm), T), query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, T));\n}\n\nvoid update(int v, int tl, int tr, int pos, LL val, LL * const T)\n{\n\tif (pos < tl || pos > tr) return;\n\tif (tl == tr)\n\t{\n\t\tT[v] = val;\n\t\treturn;\n\t}\n\tint tm = (tl + tr) / 2;\n\tupdate(v * 2, tl, tm, pos, val, T);\n\tupdate(v * 2 + 1, tm + 1, tr, pos, val, T);\n\tT[v] = min(T[v * 2], T[v * 2 + 1]);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 1, n + 1)\n\t\tcin >> A[i];\n\tDP[0] = A[0] = 0;\n\tupdate(1, 0, n, 0, -2 * A[1], T1);\n\tFOR(i, 1, n + 1)\n\t{\n\t\tint j = lower_bound(A, A + i, A[i] - t / 2) - A;\n\t\tif (j) --j;\n\t\tDP[i] = 3 * A[i] + query(1, 0, n, 0, j - 1, T1);\n\t\tDP[i] = min(DP[i], A[i] + t + query(1, 0, n, j, i - 1, T2));\n\t\tupdate(1, 0, n, i, DP[i] - A[i] - 2 * A[i + 1], T1);\n\t\tupdate(1, 0, n, i, DP[i] - A[i], T2);\n\t}\n\tcout << DP[n] + e - A[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define Pair pair<int, int>\n#define MP(x, y) make_pair(x, y)\n#define fi first\n#define se second\n//#define int long long \n#define LL long long \n#define Fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define Fout(x) {freopen(#x\".out\",\"w\",stdout);}\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)\nchar buf[(1 << 22)], *p1 = buf, *p2 = buf;\nusing namespace std;\nconst int MAXN = 2001, mod = 998244353, INF = 1e9 + 10;\nconst double eps = 1e-9;\ntemplate <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}\ntemplate <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}\ntemplate <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}\ntemplate <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}\ntemplate <typename A> inline void debug(A a){cout << a << '\\n';}\ntemplate <typename A> inline LL sqr(A x){return 1ll * x * x;}\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nLL N, E, T, a[MAXN], f[MAXN];\nint main() {\n\tN = read(); E = read(); T = read();\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i = 1; i <= N; i++) a[i] = read();\n\tf[0] = 0; f[1] = T;\n\tLL mn = 1e18, j = 0;\n\tfor(int i = 2; i <= N; i++) {\n\t\twhile(T <= 2 * (a[i] - a[j + 1])) chmin(mn, f[j] - 2 * a[j + 1]), j++;\n\t\tchmin(f[i], mn + 2 * a[i]);\n\t\tchmin(f[i], f[j] + T);\n\t}\n\tcout << f[N] + E;\n    return 0;\n}\n/*\n1,2,6,14,38,100,268,726,1974,\n\n*/"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n          #define int long long\n            #define inf  1000000007\n            #define pa pair<int,int>\n    #define ll long long\n            #define pal pair<ll,ll>\n            #define ppa pair<int,pa>\n            #define  mp make_pair\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     \n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \n            //----------------kokomade temple------------\nint n,e,t;\nint x[2020];\nint dp[2010][2010][2]={0};\n    signed main(){\n    \tcin>>n>>e>>t;\n    \tif(n>2010){\n    \t\treturn 0;\n    \t}\n    \tfor(int i=1;i<=n;i++) cin>>x[i];\n    \tint mod=100000000000000000ll;\n    \tdp[0][0][0]=0;\n    \tdp[0][0][1]=0;\n    \t\n    \tx[0]=0;\n    \t\n    \tfor(int i=0;i<=n;i++){\n    \t\tfor(int j=0;j<=i;j++){\n    \t\t\tif(i==0 ) continue;\n    \t\t\tif(i==j){\n    \t\t\t\tint u=mod;\n    \t\t\t\tu=min(u,dp[i][i-1][1]+x[i]-x[i-1]);\n    \t\t\t\tu=min(u,dp[i][i-1][0]+t);\n    \t\t\t\tdp[i][i][0]=u;\n    \t\t\t\tdp[i][i][1]=u;\n    \t\t\t\t\n    \t\t\t}\t\n    \t\t\telse{\n    \t\t\tint u=mod;\n    \t\t\tif(i!=j) u=min(u,dp[i-1][j][0]+x[i]-x[i-1]);\n    \t\t\tif(i!=j) u=min(u,dp[i-1][j][1]+x[i]-x[j]);\n    \t\t\t\n    \t\t\tdp[i][j][0]=u;\n    \t\t\t\n    \t\t\tu=mod;\n    \t\t\tif(j!=0) u=min(u,dp[i][j-1][0]+abs(x[j]-x[i]));\n    \t\t\tif(j!=0) u=min(u,dp[i][j-1][1]+x[j]-x[j-1]);\n    \t\t\tu=min(u,dp[i][j][0]+t);\n    \t\t\tdp[i][j][1]=u;\n   // \t\t\tcout<<i<<\" \"<<j<<\" \"<<0<<\" \"<<dp[i][j][0]<<endl;\n    //\t\t\tcout<<i<<\" \"<<j<<\" \"<<1<<\" \"<<dp[i][j][1]<<endl;\n    \t\t}\n    \t\t}\n    \t}\n\n    \tcout<<dp[n][n][1]+e-x[n]<<endl;\n    \t\n    \t\t\treturn 0;\n    \t\n    //\tprintf(\"%.10f\\n\",ans);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nnamespace Segment_tree {\n\ttemplate<typename T>\n\tclass segment_tree {\n\t\tvector<T> dat;\n\t\tint n;\n\t\tT e;\n\t\tstd::function<T(T, T)> f;\n\t\tT query_implement(int a, int b, int k, int l, int r) {\n\t\t\tif (r <= a || b <= l) return e;\n\t\t\tif (a <= l && r <= b) return dat[k];\n\n\t\t\tT v1 = query_implement(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT v2 = query_implement(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn f(v1, v2);\n\t\t}\n\tpublic:\n\t\tsegment_tree(int n_, T _e, T(*calc)(T lhs, T rhs)) {\n\t\t\te = _e;\n\t\t\tf = calc;\n\t\t\tn = 1;\n\t\t\twhile (n < n_) n *= 2;\n\t\t\tdat.resize(2 * n - 1);\n\t\t\tfor (int i = 0; i < 2 * n - 1; i++)\n\t\t\t\tdat[i] = e;\n\t\t}\n\n\t\tvoid update(int k, int a) {\n\t\t\tk += n - 1;\n\t\t\tdat[k] = a;\n\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tdat[k] = f(dat[k * 2 + 2], dat[k * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT query(int a, int b) { return query_implement(a, b, 0, 0, n); }\n\t};\n}\nlong long int f(long long int i, long long int j) { return min(i, j); }\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\t\n\tSegment_tree::segment_tree<long long int> seg(n,1e10,f);\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tint index=lower_bound(ALL(x), x[i]-double(t)/2+0.001) - x.begin();\n\t\tif (index >= i)\n\t\t\tindex = i-1;\n\t\tindex--;\n\t\tif (index > 0)\n\t\t\tres = min(res, dp[index] - 2 * x[index] - x[index + 1]);\n\t\tindex = lower_bound(ALL(x), x[i] - double(t) / 2) - x.begin();\n\t\tif (index < i - 1) {\n\t\t\tlong long int a = seg.query(index, i - 1);\n\t\t\tres = min(res, a + x[i]);\n\t\t}\n\t\tdp[i] = res;\n\t\tif(i<n-1)\n\t\tseg.update(i,dp[i] - 2 * x[i] - x[i + 1] + t - 2 * x[i + 1]);\n\t}\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define gcd            __gcd\n#define setbits(x)     __builtin_popcountll(x)\n#define zrobits(x)     __builtin_ctzll(x)\n#define mod            1000000007\n#define mod2           998244353\n#define maxe           *max_element\n#define mine           *min_element\n#define inf            1e18\n#define deci(x, y)      fixed<<setprecision(y)<<x\n#define w(t)           int t; cin>>t; while(t--)\n#define nitin          ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define PI             3.141592653589793238\nusing namespace std;\nint pre[2001][2001];\nint dp[2001][2001];\nint find_ans(int l,int n,vector<int>&v)\n{\n    if(dp[l][n]!=-1)\n        return dp[l][n];\n    int ans=pre[l][n];\n    for(int j=l;j<n;j++)\n    {\n        ans=min(ans,pre[l][j]+find_ans(j+1,n,v)+v[j+1]-v[j]);\n    }\n    return dp[l][n]=ans;\n}\nint32_t main() {\n    nitin;\n    int n,e,t;\n    cin>>n>>e>>t;\n    vector<int>v(n+1,0);\n    for(int i=0;i<n;i++){\n        cin>>v[i+1];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            pre[i][j]=3*(v[j]-v[i])+(j-i+1)*max(t-2*(v[j]-v[i]),(int)0);\n            dp[i][j]=-1;\n        }\n    }\n    int ans=v[1];\n    ans+=find_ans(1,n,v);\n    ans+=e-v[n];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <bitset>\n#include <random>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <functional>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < int(b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> int(a);)\n#define all(v) v.begin(),v.end()\n#define trav(x, v) for(auto &x : v)\n#define sz(v) int((v).size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long double ld;\n\nconst ll inf = 1e18;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvector<ll> dp(n+1,inf), x(n+1);\n\trep(i,0,n) cin >> x[i];\n\tx[n] = e;\n\tdp[n] = 0;\n\tint r = n;\n\tll mn = inf;\n\tmultiset<ll> ko;\n\tko.insert(x[n]);\n\trrep(i,0,n){\n\t\twhile(2*(x[r-1]-x[i])>t){\n\t\t\tmn = min(mn, 2*x[r-1]+dp[r]+x[r]);\n\t\t\tko.erase(ko.find(dp[r]+x[r]));\n\t\t\t--r;\n\t\t}\n\t\tdp[i] = min(dp[i], mn-3*x[i]);\n\t\t//cerr << dp[i] << ' ';\n\t\tdp[i] = min(dp[i], t-x[i]+*ko.begin());\n\t\t//cerr << dp[i] << endl;\n\t\tko.insert(x[i]+dp[i]);\n\t}\n\t//trav(x, dp) cout << x << endl;\n\tcout << dp[0]+x[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e18;\nint main(){\n    int n;\n    cin>>n;\n    ll t,e;\n    cin>>e>>t;\n    vector<ll> x(n+1);\n    for(int i=1;i<=n;i++) cin>>x[i];\n\n    vector<ll> dp(n+1);    \n    multiset<ll> As;\n    multiset<ll> Bs;\n    vector<ll> A(n);\n    vector<ll> B(n);\n    auto calcA=[&](int i){\n        return dp[i]-2*x[i+1]-x[i];\n    };\n    auto calcB=[&](int i){\n        return dp[i]-x[i];\n    };\n    A[0]=calcA(0),B[0]=calcB(0);\n    Bs.insert(B[0]);\n    int iter=0;\n    for(int i=1;i<=n;i++){\n        while(iter<i && 2*(x[i]-x[iter+1])>=t){\n            As.insert(A[iter]);\n            Bs.erase(B[iter]);\n            iter++;\n        }\n        ll vX=(As.empty() ? INF : *As.begin()+3*x[i]);\n        ll vY=(Bs.empty() ? INF : *Bs.begin()+x[i]+t);\n        dp[i]=min(vX,vY);\n        if(i==n) break;\n        A[i]=calcA(i),B[i]=calcB(i);\n        Bs.insert(B[i]);\n    }\n    cout<<e-x[n]+dp[n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e6 + 100 ;\n\n\nlong long dp[MAXN] , tmp[MAXN] , nx[MAXN] , a[MAXN] ; \n\nint32_t main(){\n\t//ios_base::sync_with_stdio(0) ;\n\t//cin . tie(0) ; cout . tie(0) ; \n\n\tint n ; cin >> n ; \n\tint e , t ; cin >> e >> t ; \n\tfor(int i = 0 ; i < n ; i ++)\n\t\tcin >> a[i] ; \n\tint l = n - 1 ; \n\t//cout << \"Hir\" << endl ; \n\tfor(int i = n - 1 ; i >= 0 ; i --){\n\t\twhile(l > 0 && 2 * (a[i] - a[l - 1]) <= t)\n\t\t\tl -- ; \n\t\tnx[i] = l ; \n\t}\n\t//cout << \"Hir\" << endl ; \n\tmemset(dp , 63 , sizeof dp) ; \n\tmemset(tmp , 63 , sizeof tmp) ; \n\tdp[0] = 0 ; \n\ttmp[0] = -2 * a[0] ;\n\t//cout << 0 << ' ' << dp[0]<< ' '  << tmp[0]<< ' ' << '\\n' ; \n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tdp[i] = t + dp[nx[i - 1]] ;\n\t\tif(nx[i - 1]) dp[i] = min(dp[i] , 2 * a[i - 1] + tmp[nx[i - 1] - 1]) ;\n\t\ttmp[i] = min(tmp[i - 1] , dp[i] - 2 * a[i]) ; \n\t\t//cout << i << ' ' << dp[i] << ' ' << tmp[i] << '\\n' ; \n\t}\n\tcout << dp[n] + e ; \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst ll oo=1ll<<60;\n\nll f[N];\nint d[N],E,T,n;\n\nint main(){\n\tn=IN(),E=IN(),T=IN();\n\tFor(i,1,n+1) d[i]=IN();\n\tFor(i,0,N) f[i]=oo;\n\tf[0]=0;\n\tFor(i,1,n+1){\n\t\tFor(j,1,i+1){\n\t\t\tf[i]=min(f[i],f[j-1]+d[j]-d[j-1]+max(2*(d[i]-d[j]),T)+d[i]-d[j]);\n\t\t}\n\t}\n\tcout<<f[n]+E-d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define maxn 100005\n#define INF (LL)1e16\nusing namespace std;\nint n,m,t,x[maxn];\nLL dp[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tsort(x+1,x+n+1);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0]=0;\n\tLL mn=INF; int now=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=dp[i-1]+t+x[i]-x[i-1];\n\t\twhile(2*(x[i]-x[now+1])>=t)\n\t\t{\n\t\t\tmn=min(mn,dp[now]-2ll*x[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tdp[i]=min(2*x[i]+mn,dp[now]+t);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MAX_N = 100005;\nint64_t cache[MAX_N];\nint bpos[MAX_N];\nint N, E, T;\n\nint main() {\n  scanf(\"%d %d %d\", &N, &E, &T);\n  bpos[0] = 0;\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", bpos + i + 1);\n    cache[i + 1] = 10000000000LL;\n  }\n  for (int i = 0; i < N; ++i) {\n    cache[i + 1] = std::min(cache[i + 1], cache[i] + bpos[i + 1] - bpos[i] + T);\n    for (int j = i + 2; j <= N; ++j) {\n      int64_t d = bpos[j] - bpos[i + 1];\n      int64_t d2 = bpos[j] - bpos[j - 1];\n      int64_t cost = bpos[i + 1] - bpos[i] + 3 * d + std::max(0LL, int64_t(T) - 2LL * d2) + cache[i];\n      if (cost >= cache[j]) break;\n      cache[j] = std::min(cache[j], cost);\n    }\n  }\n  printf(\"%lld\\n\", cache[N] + E - bpos[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << (x) << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate<class T> class segtree {\n\tint n;\n\tvector<T> data;\n\tT id = INF;\n\tT operation(T a, T b) { return min(a, b); };\npublic:\n\tsegtree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n + 2) n <<= 1;\n\t\tdata = vector<T>(2 * n, id);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n;\n\t\tdata[i] = x;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tdata[i] = operation(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t}\n\tvoid add(int i, T x) { change(i, data[i + n] + x); }\n\tT get(int a, int b) {\n\t\tT left = id; T right = id;\n\t\ta += n; b += n;\n\t\twhile (a < b) {\n\t\t\tif (a & 1) left = operation(left, data[a++]);\n\t\t\tif (b & 1) right = operation(data[--b], right);\n\t\t\ta >>= 1; b >>= 1;\n\t\t}\n\t\treturn operation(left, right);\n\t}\n\tT get_all() { return data[1]; }\n\tT operator[](int i) { return data[i + n]; }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll n, e, t;\n\tcin >> n >> e >> t;\n\tassert(n <= 2000);\n\tvector<ll> a(n + 1);\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tvector<vector<int>> ch(n + 2, vector<int>());\n\trep(i, n) {\n\t\tll sum = 2 * a[i + 1] + t;\n\t\tint ng = -1, ok = n + 1;\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (2 * a[mid] > sum) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tch[ok].pb(i);\n\t}\n\tsegtree<ll> dp(n + 1), seg(n + 1);\n\tdp.change(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j : ch[i]) {\n\t\t\tseg.change(j, dp[j] - 2 * a[j + 1]);\n\t\t\tdp.change(j, INF);\n\t\t}\n\t\tll mi = dp.get(0, i) + t;\n\t\tchmin(mi, seg.get(0, i) + 2 * a[i]);\n\t\tdp.change(i, mi);\n\t}\n\tcout << dp[n] + e << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[0]+(x[i]-x[0])*3+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<r)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, r));\n        if (r<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(r, i));\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <deque>\n#include <map>\n#include <set>\n#include <complex>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <chrono>\n\n#define ft first\n#define sc second\n#define pb push_back\n#define len(v) (int)v.size()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint inf = 1e16;\n\nvector<int> tree;\nint N = 1;\n\nvoid upd(int v) {\n\tif(v == 0) \n\t\treturn;\n\ttree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n\tupd(v / 2);\n}\n\nint get(int v, int l, int r, int vl, int vr) {\n\tif(vr <= l || r <= vl)\n\t\treturn inf;\n\tif(vl <= l && r <= vr) {\n\t\treturn tree[v];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(get(v * 2, l, m, vl, vr), get(v * 2 + 1, m, r, vl, vr));\n}\n\nsigned main() {\n\t#ifdef PC\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\t\n\n\tint n, k, e;\n\tcin >> n >> e >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) \n\t\tcin >> a[i];\n\n\twhile(N < (n + 2)) \n\t\tN *= 2;\n\n\ttree = vector<int> (2 * N, inf);\n\tvector<int> suf(n + 1, inf);\n\tsuf[n - 1] = k;\n\tint uk = n - 2;\n\ttree[N + (n - 2)] = k + a[n - 1] + suf[n - 1];\n\tupd((N + (n - 2)) / 2);\n\n\tfor (int i = n - 2; i >= 0; i--) {\n\n\t\twhile(uk > 0 && 2 * (a[uk] - a[i]) >= k) {\n\t\t\ttree[N + uk] = 2 * a[uk] + a[uk + 1] + suf[uk + 1];\n\t\t\tupd((N + (uk - 1)) / 2);\n\t\t\tuk--;\n\t\t}\n\t\tint ans = max(k, 2 * (a[n - 1] - a[i])) + (a[n - 1] - a[i]);\n\t\tint l = uk;\n\t\t// cout << ans << \" \" << i << \" \" << l << \" \" << get(1, 0, N, i, l + 1) << \" \" << uk << endl;\n\t\tans = min(ans, get(1, 0, N, i, l + 1) - a[i]);\n\t\tif(l + 1 < n - 1) {\n\t\t\tans = min(ans, get(1, 0, N, l + 1, n - 1) - 3 * a[i]);\n\t\t}\n\t\tsuf[i] = ans;\n\t\tif(i != 0) {\n\t\t\ttree[N + (i - 1)] = k + a[i] + suf[i];\n\t\t\tupd((N + (i - 1)) / 2);\n\t\t}\n\t\t// cout << i << \" \" << suf[i] << endl;\n\t}\n\tcout << a[0] + suf[0] + (e - a[n - 1]) << endl;\n\treturn 0;\n}\n\n// j\n\n// "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define qwq(x) cerr<<\" #\"<<#x<<\" = \"<<x<<endl;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005;\nll f[N],g[N],x[N],E,T;\nint n;\n\nint main(){\n\tread(n),read(E),read(T);\n\trep(i,1,n)read(x[i]);\n\tmemset(f,0x3f,sizeof f);\n\tmemset(g,0x3f,sizeof g);\n\tf[0]=0;\n\trep(i,1,n){\n\t\tint t=lower_bound(x+1,x+n+1,x[i]+(T+1)/2)-x;\n//\t\tprintf(\"%d  ->  %d\\n\",i-1,t);\n\t\tg[t]=min(g[t],f[i-1]+x[i]-x[i-1]+3ll*(x[t]-x[i]));\n\t\tf[t-1]=min(f[t-1],f[i-1]+x[i]-x[i-1]+T+(x[t-1]-x[i]));\n\t\tg[i]=min(g[i],g[i-1]+3ll*(x[i]-x[i-1]));\n\t\tf[i]=min(f[i],g[i]);\n//\t\tprintf(\"%d   %lld  %lld\\n\",i,f[i],g[i]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+E-x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint N, E, T;\n\twhile(cin >> N >> E >> T){\n\t\tlong long res = E;\n\t\tvector<int> x(N);\n\t\tfor(int i=0;i<N;i++) cin >> x[i];\n\t\tvector<long long> dp(N+1);\n\t\tvector<long long> dp2(N);\n\t\tdp[N-1] = E+T; dp[N] = E;\n\t\tdp2[N-1] = dp[N] + 2*x[N-1];\n\t\tint thr = N-1;\n\t\tfor(int i=N-2;i>=0;i--){\n\t\t\twhile(2*(x[thr] - x[i]) > T) --thr;\n\t\t\tdp[i] = min(T + dp[thr+1], dp2[thr+1] - 2*x[i]);\n\t\t\tdp2[i] = min(dp2[i+1], dp[i+1] + 2*x[i]);\n\t\t}\n\t\tcout << dp[0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100100;\nint N, E, T;\nint X[MAXN];\nll dp[MAXN];\n\nll dfs(int now) {\n\tll& ret = dp[now];\n\tif (ret >= 0) return ret;\n\tif (now == N) return ret = 0;\n\tret = 1ll<<60;\n\tfor (int j = now; j < N; j++) {\n\t\tll dist = X[j] - X[now];\n\t\tll cost = (dist*2 > T) ? dist*3 : T+dist;\n\t\tret = min(ret, cost + dfs(j+1) + (X[j+1] - X[j]));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N >> E >> T;\n\tif (N > 2000) return 0;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i];\n\tX[N] = E;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << X[0] + dfs(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define Pair pair<int, int>\n#define MP(x, y) make_pair(x, y)\n#define fi first\n#define se second\n//#define int long long \n#define LL long long \n#define Fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define Fout(x) {freopen(#x\".out\",\"w\",stdout);}\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)\nchar buf[(1 << 22)], *p1 = buf, *p2 = buf;\nusing namespace std;\nconst int MAXN = 2001, mod = 998244353, INF = 1e9 + 10;\nconst double eps = 1e-9;\ntemplate <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}\ntemplate <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}\ntemplate <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}\ntemplate <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}\ntemplate <typename A> inline void debug(A a){cout << a << '\\n';}\ntemplate <typename A> inline LL sqr(A x){return 1ll * x * x;}\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nLL N, E, T, a[MAXN], f[MAXN];\nint main() {\n\tN = read(); E = read(); T = read();\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i = 1; i <= N; i++) a[i] = read();\n\tf[0] = 0; f[1] = T;\n\tLL mn = 1e18, j = 0;\n\tfor(int i = 2; i <= N; i++) {\n\t\twhile(T <= 2 * (a[i] - a[j + 1]) && j < i) chmin(mn, f[j] - 2 * a[j + 1]), j++;\n\t\tchmin(f[i], mn + 2 * a[i]);\n\t\tchmin(f[i], f[j] + T);\n\t\t//for(int j = i - 1; j >= 0; j--) \n\t\t//\tchmin(f[i], f[j] + max(T, 2 * (a[i] - a[j + 1])));\n\t}\n\tcout << f[N] + E;\n    return 0;\n}\n/*\n1,2,6,14,38,100,268,726,1974,\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,E,T;cin>>N>>E>>T;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    A.push_back(0);\n    A.push_back(INF);\n    sort(all(A));\n    \n    for(int i=1;i<=N+1;i++) dp[i]=INF;\n    dp[0]=0;\n    \n    for(int i=1;i<=N;i++){\n        auto it=lower_bound(all(A),A[i]+(T+1)/2);\n        it--;\n        for(int j=max(i,int(it-A.begin()));j<=N;j++){\n            if((A[j]-A[i])>T) break;\n            chmin(dp[j],dp[i-1]+max((A[j]-A[i])*2,T));\n        }\n        /*auto it=upper_bound(all(A),A[i]+(T+1)/2);\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));\n        \n        if(it==A.begin()) continue;\n        \n        it--;\n        chmin(dp[it-A.begin()],dp[i-1]+max((A[it-A.begin()]-A[i])*2,T));*/\n    }\n    \n    cout<<dp[N]+E<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\nll n, e, t, ans, cnt, bo, a[100005];\n//ll max(ll p, l)\nint main()\n{\n\tint i, j;\n//\tfreopen (\"input.txt\", \"r\", stdin);\n\tcin >> n >> e >> t;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf (\"%lld\", &a[i]);\n\t}\n\ta[n] = e;\n\tans = a[0];\n\tfor (i = 0; i < n; ) {\n\t\tcnt = 1;\n\t\tfor (j = i; j < n; j++) {\n\t\t\tif (i > j) bo = max(0LL, t - (a[j - 1] - a[i]) * 2);\n\t\t\telse bo = 0;\n\t\t\tif (cnt * t < (a[j] - a[i]) * 2 + bo) break;\n\t\t\tcnt++;\n\t\t}\n\t\tans += (a[j - 1] - a[i]) * 2;\n\t\tans += a[j] - a[i];\n\t\tans += max(0LL, t - (a[j - 1] - a[i]) * 2);\n\t\ti = j;\n\t}\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nclass FenwickTree{  // All entries must be >= 0 even after decrement\npublic:             // Every function is O(log n)\n  FenwickTree(int n) : N(n), iBM(1), tree(n,0) {\n    while (iBM < N) iBM *= 2;\n  }\n  \n  // inc/dec the entry at position idx by val\n  void incEntry(int idx, int val) {\n    do tree[idx] += val; while(idx && (idx += (idx & (-idx))) < N);\n  }\n  \n  // return the cumulative sum val[0] + val[1] + ... + val[idx]\n  int cumulativeSum(int idx) const {\n    int sum = tree[0];\n    for( ; idx > 0 ; idx &= idx-1) sum += tree[idx];\n    return sum;\n  }\n  \nprivate:\n  int N, iBM; vector<int> tree;\n};\n\nll A[MAX_N];\nll N,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T+len;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> N >> E >> T;\n  \n  for(int i=0;i<N;i++) cin >> A[i];\n  \n  vector<pair<ll,int> > d;\n  for(int i=1;i<N;i++)\n    d.emplace_back(A[i]-A[i-1],i-1);\n  \n  sort(d.rbegin(),d.rend());\n  \n  vector<pair<int,int> > ints;\n  ints.emplace_back(0ll,N-1);\n  \n  FenwickTree F(N+1);\n  \n  ll ans = E + f(A[N-1]-A[0]);\n  \n  ll best = ans;\n  \n  for(int i=0;i<N-1;i++){\n    int idx = d[i].second;\n    int where = F.cumulativeSum(idx);\n    \n    int len = A[ints[where].second] - A[ints[where].first];\n    ans -= f(len);\n    \n    ints.emplace_back(idx+1,ints[where].second);\n    ints[where].second = idx;\n    F.incEntry(idx+1,(int)ints.size()-1-where);\n    F.incEntry(ints.back().second+1,where+1-(int)ints.size());\n    \n    ans += f(A[ints[where].second]-A[ints[where].first]) + f(A[ints.back().second] - A[ints.back().first]);\n    if(best > ans) best = ans;\n    //cout << ans << \" \" << best << endl;\n  }\n  cout << best << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nconst long long int INF = 1000000000000000000ll;\nint x[MAXN];\nlong long int dp[MAXN];\nlong long int f(int p1, int p2, int t)\n{\n\tlong long int t1 = x[p2] - x[p1];\n\tif(2*t1 > t)\n\t\treturn 3*t1;\n\treturn 3*t1 + (t - 2*t1);\n}\nint main()\n{\n\tint n,e,t;\n\tscanf(\"%d %d %d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tdp[i] = INF;\n\t\tfor (int j = 0; j < i; ++j)\n\t\t{\n\t\t\tlong long int cval = dp[j] + (x[j+1] - x[j]) + f(j+1,i,t);\n\t\t\tdp[i] = min(dp[i], cval);\n\t\t}\n\t\t// cout<<dp[i]<<\"\\n\";\n\t}\n\tcout<<dp[n] + (e - x[n])<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+1,0),dp(N+1,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    LazySegmentTree seg1(vector<ll>(N+1,0)),seg2(vector<ll>(N+1,0));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.add(0,1,dp[0]);\n    seg2.add(0,1,dp[0]);\n    for(int i=1;i<=N;i++){\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        dp[i] = dp[i-1]+T+X[i+1]-X[i];\n        if(id!=i) dp[i] = min(dp[i],seg2.getmin(id,i)+T+X[i+1]-X[i]);\n        if(id>1) dp[i] = min(dp[i],seg1.getmin(0,id-1)+X[i+1]-X[i]);\n        seg1.add(i,i+1,dp[i]);\n        seg1.add(0,i,3*(X[i+1]-X[i]));\n        seg2.add(i,i+1,dp[i]);\n        seg2.add(0,i,X[i+1]-X[i]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n/*\nint main()\n{\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\tvector<int> t;\n\tint pre_x, x, pre_t;\n\tpre_x = 0;\n\tlong long ans = E;\n\tcin >> pre_x;\n\tans += T;\n\tpre_t = T;\n\tfor(int i=1;i<N;i++){\n\t\tcin >> x;\n\t\tif(x - pre_x >= T){\n\t\t\tans += T;\n\t\t\tpre_x = x;\n\t\t\tpre_t = T;\n\t\t}else{\n\t\t\tans-=pre_t;\n\t\t\tpre_t = max(T, 2*(x-pre_x));\n\t\t\tans+=pre_t;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}*/\n\nint main(){\n\tlong long N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long> x(N), dp(N, 1000000000000);\n\tdp[0] = T;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> x[i];\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[i] = min(dp[i], dp[j]+max(T, 2*(x[i]-x[j]) ) );\n\t\t}\n\t}\n\t/*for(int i=0;i<N;i++){\n\t\tcout << dp[i] << \" \";\n\t}cout << endl;*/\n\tcout << dp[N-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll p[2123];\nll cache[2123][2123];\nbool seen[2123][2123];\nll n, e, t;\n\n//x = curpos\n//y = first coin\n//x >= y\nll dp(ll x, ll y)\n{\n\tif (x == n) return 0;\n\tif (seen[x][y]) return cache[x][y];\n\tseen[x][y] = true;\n\n\tll ans1 = -1, ans2 = -1;\n\tif (x + 1 < n)\n\t\tans1 = p[x+1] - p[x] + dp(x+1, y);\n\tans2 = p[x] - p[y] + max(0ll, t - 2*(p[x] - p[y])) + p[x+1] - p[y] + dp(x+1, x+1);\n\tif (ans1 > -1) ans2 = min(ans2, ans1);\n\tcache[x][y] = ans2;\n\treturn ans2;\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> p[n] >> t;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tcout << dp(0, 0) + p[0] << '\\n';\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tcout << i << ' ' << j << ' ' << dp(i, j) << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\nusing ulong = unsigned long;\nusing ll = long long;\nconst int M = 1e9 + 7;\n#pragma unused(M)\n\nint n, e, t;\nvector<ll> xs;\nll solve(int pos, int time){\n    if(pos == 0){\n        return xs[0] + max(0, t - time);\n    }\n    ll dx = xs[pos] - xs[pos - 1];\n    return min(\n            solve(pos - 1, 0) + dx + max(0, (t - time)),\n            solve(pos - 1, 2 * dx) + 3 * dx);\n}\n\nint main(){\n\tcin >> n >> e >> t;\n    vector<ll> xs(n);\n    for(int i=0;i<n;i++){\n        cin >> xs[i];\n    }\n    ::xs = xs;\n\n    cout << solve(n - 1, 0) + e - xs.back() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e17;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 1;\n    ll now = 1e17;\n    for(int i = 1; i <= N; i++) {\n        now += 3 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before]) >= T) {\n            now = min(now, dp[before - 1] + (x[i] - x[before - 1]) + 2 * (x[i] - x[before]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        //dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i - 1] << \" \" << x[i] << \" \" <<x[i - 1] << \" \" << T << endl;\n        //cout << i << \" \" << dp[i - 1] + x[i] - x[i - 1] + T << endl;\n        //cout << i << \" \" << dp[i] << endl;\n        //if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        dp[i] = min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + T + x[i] - x[before]);\n        //cout << i << \" \" << min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + T + x[i] - x[before]) << endl;\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << now << endl;\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nint n;\nll T, e;\nll x[100010];\n\nll dp[100010];\n\ndeque<pl> deq;\nll be;\n\nint main(){\n\n  n = in();\n  e = in();\n  T = in();\n  REP( i , n ){\n    x[i] = in();\n  }\n  x[n] = e;\n\n  dp[0] = x[0];\n\n  deq.emplace_back( T , x[0] );\n  be = INFLL;\n  \n  FOR( i , 1 , n+1 ){\n    while( not deq.empty() and ( x[i-1] - deq.front().se ) * 2 > T ){\n      chmin( be, deq.front().fi - T - 2 * deq.front().se );\n      deq.pop_front();\n    }\n    ll a = INFLL;\n    if( not deq.empty() ){\n      a = x[i-1] + deq.front().fi;\n    }\n    ll b = 3 * x[i-1] + be;\n    dp[i] = min( a, b ) + x[i] - x[i-1];\n    ll nde = dp[i] + T - x[i];\n    while( not deq.empty() and deq.back().fi >= nde ){\n      deq.pop_back();\n    }\n    deq.emplace_back( nde, x[i] );\n  }\n\n  printf( \"%lld\\n\" , dp[n] );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  vector<long long> x(n);\n  for(auto& xx : x){\n    scanf(\"%lld\", &xx);\n  }\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<int> t_min;\n  t_min.push_back(0);\n  long long w = 1ll<<57;\n  long long add = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      if(w + add > dp[j] + 2*(x[i]-x[j])){\n        w = dp[j];\n        add = 2*(x[i] - x[j]);\n      }\n      j++;\n    }\n    while(t_min.size() && t_min.front() < j){\n      t_min.pop_front();\n    }\n\n    dp[i+1] = min(dp[i+1], w+add);\n    if(t_min.size()) dp[i+1] = min(dp[i+1], dp[t_min.front()] + t);\n\n    add += 2*(x[i+1] - x[i]);\n    while(t_min.size() && dp[t_min.back()] >= dp[i+1]){\n      t_min.pop_back();\n    }\n    t_min.push_back( i+1 );\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <functional>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <stdio.h>\n#include <memory.h>\n#include <sstream>\n#include <iterator>\n\nint main () {\n\tint n, t, e;\n\tscanf (\"%d%d%d\", &n, &e, &t);\n\tstd::vector <int> v (n);\n\tstd::vector <char> used(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf (\"%d\", &v[i]);\n\t\tused[i] = 0;\n\t}\n\tlong long tt = v[0];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (used[i]) {\n\t\t\ttt += v[i + 1] - v[i];\n\t\t} else {\n\t\t\tint cur = v[i] + t;\n\t\t\tint j = std::lower_bound (v.begin() + i, v.end(), cur) - (v.begin() + i);\n\t\t\tif (j == v.size()) j--;\n\t\t\tfor (int ii = i; ii <= j; ii++)\n\t\t\t\tused[ii] = true;\n\t\t\ttt += std::max(t, (v[j] - v[i]) * 2);\n\t\t\ttt += v[i + 1] - v[i];\n\t\t}\n\t}\n\tif (used[n - 1] == false) {\n\t\ttt += t;\n\t}\n\ttt += e - v[n - 1];\n\tstd::cout << tt << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\nconst llint inf = 1e18;\n\nint x[MAX];\nllint f[MAX];\n\nint main(void) {\n  int N, E, T;\n  scanf(\"%d %d %d\", &N, &E, &T);\n  REP(i, N) scanf(\"%d\", &x[i]);\n  \n  f[0] = 0;\n  multiset<llint> S2;\n  S2.insert(f[0] - x[0]);\n  \n  int j = 0;\n  llint best = inf;\n  for (int i = 1; i <= N; ++i) {\n    while (j < i && 2*(x[i-1] - x[j]) > T) {\n      S2.erase(S2.find(f[j] - x[j]));\n      best = min(best, f[j] - 2*x[j]);\n      j++;\n    }\n\n    f[i] = best + 2*x[i-1];\n    if (S2.size()) f[i] = min(f[i], *S2.begin() + T + x[i-1]);\n    S2.insert(f[i] - x[i]);\n  }\n\n  llint ans = E + f[N];\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 , inf = 1e18 + 20;\nint n , e , t , x[N] , dp[N] , p , mn = inf ;\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> e >> t ;\n\tfor (int i = 0 ; i < n ; i ++) cin >> x[i] ;\n\n\tp = n ;\n\n\tdp[n - 1] = e - x[n - 1] + t ;\n\tfor (int i = n - 2 ; ~i ; i --) {\n\t\twhile (2 * (x[p - 1] - x[i]) > t){\n\t\t\tp -- ;\n\t\t\tmn = min(mn , dp[p + 1] + ((p == n - 1 ? e : x[p + 1]) - x[p]) + 3 * x[p]) ;\n\t\t}\n\n\t\tdp[i] = mn - 3 * x[i] ;\n\n\t\tint len = x[p - 1] - x[i] ;\n\t\tdp[i] = min(dp[i] , 3 * len + (t - 2 * len) + (p == n ? e - x[n - 1] : x[p] - x[p - 1] + dp[p])) ;\n\t}\n\n\tcout << x[0] + dp[0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n,e,t;\nvi x;\nll dp[MX];\n\nll f(int i, int j) {\n  return dp[j] + max((x[j-1]-x[i])*2, t) + (x[j]-x[i]);\n}\n\nint main() {\n  scanf(\"%d%d%d\",&n,&e,&t);\n  x = vi(n);\n  rep(i,n) scanf(\"%d\",&x[i]);\n  x.pb(e);\n  // int j = n;\n  drep(i,n) {\n    // while (j > i+1) {\n    //   if (f(i,j) < f(i,j-1)) break;\n    //   j--;\n    // }\n    // dp[i] = f(i,j);\n    int l = i, r = n+1;\n    dp[i] = LINF;\n    while (l+2<r) {\n      int c1 = (l*2+r)/3;\n      int c2 = (l+r*2)/3;\n      ll d1 = f(i,c1);\n      ll d2 = f(i,c2);\n      mins(dp[i],min(d1,d2));\n      if (d1 > d2) l = c1; else r = c2;\n    }\n    mins(dp[i], f(i,(l+r)>>1));\n  }\n  cout<<(dp[0]+x[0])<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//hi\n#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\ntypedef long long int LL;\nLL x[2002];\nLL dp[2002];\nLL mn1[2002], mn2[2002];\nint main(void){\n    int n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tsort(x+1,x+n+1);\n\tdp[0]=0;\n\tmn1[0]=mn2[0]=0;\n\t/*for(i=1;i<=n;i++){\n\t\tLL tmp=1000000000000000LL;\n\t\tfor(j=0;j<i;j++)\n\t\t\ttmp=min(tmp,dp[j]+max(2*(x[i]-x[j+1]),(LL)t));\n\t\tdp[i]=tmp;\n\t}*/\n\tfor(i=1;i<=n;i++){\n\t\t//rintf(\"%d %d %d\\n\",i,mn1[i-1],mn2[i-1]);\n\t\tdp[i]=dp[mn1[i-1]]+max(2*(x[i]-x[mn1[i-1]+1]),(LL)t);\n\t\tdp[i]=min(dp[i],dp[mn2[i-1]]+max(2*(x[i]-x[mn2[i-1]+1]),(LL)t));\n\t\tmn1[i]=dp[mn1[i-1]]<dp[i] ? mn1[i-1]:i;\n\t\tmn2[i]=dp[mn2[i-1]]-2*x[mn2[i-1]+1]<dp[i]-2*x[i+1] ? mn2[i-1]:i;\n\t}\n\tprintf(\"%lld\\n\",e+dp[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register ll i=(a);i<=(b);i++)\n#define For(i,a,b) for (register ll i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+5;\nll n,E,T,x[N],f[N],Ans,k=1e18;\nll l=1,r=1,q[N];\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\nint main()\n{\n\tmem(f,0x3f);\n\tn=read(),E=read(),T=read();\n\tFOR(i,1,n) x[i]=read();\n\tf[0]=0;\n\tFOR(i,1,n)\n\t{\n\t\twhile (l<=r&&2*(x[i]-x[q[l]+1])>T)\n\t\t{\n\t\t\tk=min(k,f[q[l]]-2*x[q[l]+1]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[i],f[q[l]]+T);\n\t\tf[i]=min(f[i],k+2*x[i]);\n\t//\twhile (l<=r&&f[q[l]]-x[q[l]]>=f[i]-x[i]) r--;\n\t\tq[++r]=i;\n\t}\n\tAns=f[n]+E;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nLL dp[100010], R[100010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, E, T; cin >> N >> E >> T;\n  vector<LL> xs(N);\n  REP(i,N) cin >> xs[i];\n  fill(dp, dp+100010, 1e15);\n\n  dp[0] = 0;\n  REP(i,N+1) R[i] = i;\n  REP(i,N){\n\tLL t = (i>0?xs[i]-xs[i-1]:xs[i]);\n\tFOR(j,R[i],min(N,R[i+1]+1)){\n\t  LL d = xs[j] - xs[i];\n\t  LL nxt  =dp[i] + t + d*3 + max(0ll, T-2*d);\n\t  if(dp[j+1] >= nxt){\n\t\tdp[j+1] = nxt;\n\t\tR[i+1] = j+1;\n\t  }\n\t}\n  }\n  cout << dp[N] + E - xs.back() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 205\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint64 dp[100005],pre;\nint64 T,E;\nint64 x[100005];\nint N,p;\ndeque<int> que;\nvoid Solve() {\n    read(N);read(E);read(T);\n    for(int i = 1 ; i <= N ; ++i) {read(x[i]);dp[i] = i * T;}\n    p = -1;pre = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(p < i - 1 && 2 * (x[i] - x[p + 2]) > T) {\n\t    ++p;pre = min(pre,dp[p] - 2 * x[p + 1]);\n\t}\n\tif(p != -1) dp[i] = min(dp[i],pre + 2 * x[i]);\n\twhile(!que.empty() && 2 * (x[i] - x[que.front() + 1]) > T ) {que.pop_front();}\n\tif(!que.empty()) {\n\t    dp[i] = min(dp[i],dp[que[0]] + T);\n\t}\n\twhile(!que.empty() && dp[que.back()] > dp[i]) que.pop_back();\n\tque.push_back(i);\n    }\n    out(dp[N] + E);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint i,j,k,n,m,x,y,t,a[100010];\nlong long f[100010];\nint E,T;\nlong long work(int x,int y){\n\tif ((a[y]-a[x+1])*2>=T)return 3ll*(a[y]-a[x+1]); else return T+a[y]-a[x+1];\n}\nvoid update(int x,int y){f[y]=min(f[y],f[x]+work(x,y)+a[x+1]-a[x]);}\nint main(){\n\tscanf(\"%d%d%d\",&n,&E,&T);\n\tfor (i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)f[i]=1ll<<60;\n\tint lim=(T+1)>>1;\n\tfor (i=0;i<n;i++){\n\t\tint l=i+1,r=n,ans=n;\n\t\twhile (l<=r){\n\t\t\tint mid=l+r>>1;\n\t\t\tif (a[mid]-a[i+1]>=lim)ans=mid,r=mid-1;else l=mid+1;\n\t\t}\n\t\tif (ans>i)update(i,ans);\n\t\tif (ans-1>i)update(i,ans-1);\n//\t\tprintf(\"%d %d\\n\",i,ans);\n//\t\tf[i+1]=min(f[i+1],f[i]+a[i+1]-a[i]+T);\n\t}\n//\tfor (i=1;i<=n;i++)printf(\"%lld\\n\",f[i]);\n\tprintf(\"%lld\\n\",f[n]+E-a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    const ll INFL = LLONG_MAX / 3;\n    int N, E, T;\n    cin >> N >> E >> T;\n    vi x(N + 1);\n    vll f(N + 1, INFL), g(N + 1, INFL);\n    f[0] = g[0] = 1;\n    for(int i = 1; i <= N; ++i)cin >> x[i];\n\n    int p = 0;\n    // min(dp[i]+T) // 近い\n    // min(dp[i]-2x[i+1]) // 遠い\n    multiset<ll> aa, bb;\n    for(int i = 1; i <= N; ++i) {\n        aa.insert(f[i - 1] + T);\n        while(T < 2 * (x[i] - x[p + 1])) {\n            bb.insert(f[p] - 2 * x[p + 1]);\n            aa.erase(aa.find(f[p++]+T));\n        }\n        f[i] = *aa.begin();\n        if(sz(bb))smin(f[i], 2 * x[i] + (*bb.begin()));\n    }\n    cout << E + f[N] - x[1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  deque<long long> dq;\n  dq.push_back(0);\n  for(int i=0; i<n; i++){\n    while(dq.size() && (x[i] - x[dq.front()]) * 2 > t){\n      dp[i+1] = min( dp[i+1], dp[dq.front()] + 2*(x[i]-x[dq.front()]) );\n      dq.pop_front();\n    }\n    dq.push_back(i);\n    dp[i+1] = min(dp[i+1], dp[dq.front()] + t);\n  }\n\n  println(dp[n] + e);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\n\ntemplate<typename F>struct NoOp{void setup(ui, F){}void op(F&p,F n,ui,ui){p=n;}void down(F&,F&,F&,ui,ui) {}};\n\ntemplate<typename F,typename SetOp,typename PowerOp>struct Lazy{\n    void setup(ui s,F def){this->def=def;this->s=s;L=new F[s]();fill(L,L+s,def);}\n    void down(F&u,F&l,F&r,ui i,ui s){op(l,L[i],i<<1,s>>1);op(r,L[i],i<<1|1,s>>1);L[i]=def;}\n    void op(F&p,F n,ui i,ui s){p=sop(p,pop(n,s));if(i<this->s)this->L[i]=sop(this->L[i],n);}\n    SetOp sop;PowerOp pop;F*L;ui s;F def;\n};\n\ntemplate <typename F, typename CombineOp, typename ModifyOp = NoOp<F>> struct SegTree {\n\tvoid setup(ui s, F def) {\n\t\tn = 1<<logceil(s);\n\t\tT = vector<F>(2*n, def);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tvoid setup(vector<F> & data, F def = F()) {\n\t\tn = 1<<logceil(data.size());\n\t\tT = vector<F>(2*n, def);\n\t\tcopy(data.begin(), data.end(), T.begin() + n);\n\t\tfor (ui i = n-1; i > 0; i--) T[i] = cop(T[i<<1],T[i<<1|1]);\n\t\tmop.setup(2*n,def);\n\t}\n\n\tinline void put(ui x, F n) { put(x, x, n); }\n\tinline void put(ui from, ui to, F v) { put2(from, to+1, v, 1, n); }\n\tinline F get(ui x) { return get(x, x); }\n\tinline F get(ui from, ui to) { return get2(from, to+1, 1, n); }\n\n\tvoid put2(ui from, ui to, F v, ui i, ui s) {\n\t\tif (from == 0 && to == s) { mop.op(T[i], v, i, s); return; }\n\t\tmop.down(T[i], T[i<<1], T[i<<1|1], i, s);\n        s>>=1;i<<=1;\n        if (to <= s) { put2(from, to, v, i, s); }\n        else if (from >= s) { put2(from-s, to-s, v, i|1, s); }\n        else {\n            put2(from, s, v, i, s);\n            put2(0, to-s, v, i|1, s);\n        }\n\t\tT[i>>1] = cop(T[i], T[i|1]);\n\t}\n\n\tF get2(ui from, ui to, ui i, ui s) {\n        while (true) {\n            if (from == 0 && to == s) return T[i];\n            mop.down(T[i], T[i << 1], T[i << 1 | 1], i, s);\n            s >>= 1;i <<= 1;\n            if (to > s) {\n                to -= s;\n                if (from >= s) { from -= s; i|=1; }\n                else return cop(get2(from, s, i, s), get2(0, to, i|1, s));\n            }\n        }\n    }\n\n\tui n;\n\tvector<F> T;\n\tCombineOp cop;\n    ModifyOp mop;\n};\n\n\ntemplate <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};\ntemplate <typename F> struct MinOp { F operator()(F a, F b) { return std::min(a,b); }};\ntemplate <typename F> struct MaxOp { F operator()(F a, F b) { return std::max(a,b); }};\ntemplate <typename F> struct MultiplyOp { F operator()(F a, F b) { return a*b; }};\ntemplate <typename F> struct MultOp { F operator()(F a, ui b) { return a*b; }};\ntemplate <typename F> struct IdempOp { F operator()(F a, ui b) { return a; }};\ntemplate <typename F> struct InverseOp { F operator()(F a, F b) { return b?b-a:a; }};\n\ntemplate<typename T> using AddSumTree = SegTree<T, AddOp<T>, Lazy<T, AddOp<T>, MultOp<T>>>;\ntemplate<typename T> using AddMaxTree = SegTree<T, MaxOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AddMinTree = SegTree<T, MinOp<T>, Lazy<T, AddOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMinTree = SegTree<T, MinOp<T>, Lazy<T, MinOp<T>, IdempOp<T>>>;\ntemplate<typename T> using AssignMaxTree = SegTree<T, MaxOp<T>, Lazy<T, MaxOp<T>, IdempOp<T>>>;\ntemplate<typename T> using XorTree = SegTree<T, AddOp<T>, Lazy<T, InverseOp<T>, MultOp<T>>>;\n\ntemplate<typename T> using SetMinTree = SegTree<T, MinOp<T>>;\ntemplate<typename T> using SetMaxTree = SegTree<T, MaxOp<T>>;\ntemplate<typename T> using SetMulTree = SegTree<T, MultiplyOp<T>>;\n\n\nclass DShikAndGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, E, T; cin >> N >> E >> T;\n        vector<ll> X(N+1, 0);\n        for (int i = 0; i < N; ++i) cin >> X[i+1];\n        vector<ll> D(N+1, 1e18);\n        SetMinTree<ll> G;\n        G.setup(D, 0);\n\n        D[0] = E;\n        int j = 0;\n        ll lo = 1e18;\n\n        for (int i = 1; i <= N; ++i) {\n            G.put(i-1, D[i-1]);\n            D[i] = 1e18;\n            while (2*(X[i]-X[j+1]) >= T) { lo = min(lo, D[j] - 2 * X[j+1]); ++j; }\n            if (j != i) D[i] = X[i] + T + G.get(j, i-1);\n            if (j != 0) D[i] = min(D[i], /*F.get(0, j-1)*/ lo + 3 * X[i]);\n            D[i] -= X[i];\n        }\n\n        cout << D[N] << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDShikAndGame solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define ii pair<int,int>\n#define INF 1000000000\n#define M 1000000007ll\n#define UQ(x) (x).resize(distance((x).begin(),unique(all((x)))))\nint n;\nll t,e,x[100005],mem[100005],ml[100005];\nmultiset<ll> s;\nint main() {\n\tscanf(\"%d%lld%lld\",&n,&e,&t);\n\tfor (int i=0;i<n;i++) scanf(\"%lld\",&x[i]);\n\tmem[0]=(x[0]+t);\n\tml[0]=mem[0]-x[0]-x[1]-x[1];\n\tint cur=1;\n\tfor (int i=1;i<n;i++) {\n\t\tmem[i]=max(t,x[i]-x[0]+x[i]-x[0])+x[i];\n\t\tmem[i]=min(mem[i],mem[i-1]+x[i]-x[i-1]+t);\n\t\tif (i>1) {\n\t\t\twhile(cur<i && x[i]-x[cur+1]+x[i]-x[cur+1]>t) {\n\t\t\t\ts.erase(s.find(mem[cur]-x[cur]));\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tmem[i]=min(mem[i],ml[min(cur,i-1)-1]+3ll*x[i]);\n\t\t\tif (!s.empty()) mem[i]=min(mem[i],(*s.begin())+t+x[i]);\n\t\t}\n\t\tml[i]=min(ml[i-1],mem[i]-x[i]-x[i+1]-x[i+1]);\n\t\ts.insert(mem[i]-x[i]);\n\t}\n\tprintf(\"%lld\\n\", mem[n-1]+e-x[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\n#define gpf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint n, e, T;\nll x[110000];\nll ans;\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &e, &T);\n\trep(i, 1, n) scanf(\"%lld\", x + i);\n\tans = x[1];\n\tint now = 1;\n\twhile (now <= n){\n\t\tll tt = 0;\n\t\twhile ((now + tt < n) && (x[now + tt + 1] - x[now] + (tt + 2) * T > max((x[now + tt + 1] - x[now]) * 3, x[now + tt + 1] - x[now] + T))) tt++;\n\t\tans += max((x[now + tt] - x[now]) * 3, x[now + tt] - x[now] + T);\n\t\tnow += tt + 1;\n\t\tif (now <= n) ans += x[now] - x[now - 1];\n\t}\n\tprintf(\"%lld\\n\", ans + e - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\npublic:\n    segtree(const vector<T>& v) : n(1), sz((int)v.size()), h(0){\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, numeric_limits<T>::max());\n        lazy_update.resize(2*n, 0); lazyFlag.resize(2*n, false);\n        lazy_add.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i=n-1; i>=1; i--) node[i] = min(node[2*i],node[2*i+1]);\n    }\n    void eval(int k) {\n        if(lazyFlag[k]){\n            lazy_update[k] += lazy_add[k];\n            node[k] = lazy_update[k];\n            if(k < n) {\n                lazy_add[2*k] = lazy_add[2*k+1] = 0;\n                lazy_update[2*k] = lazy_update[2*k+1] = lazy_update[k];\n                lazyFlag[2*k] = lazyFlag[2*k+1] = true;\n            }\n            lazy_add[k] = 0, lazyFlag[k] = false;\n        }else if(lazy_add[k] != 0){\n            node[k] += lazy_add[k];\n            if(k < n){\n                lazy_add[2*k] += lazy_add[k]; lazy_add[2*k+1] += lazy_add[k];\n            }\n            lazy_add[k] = 0;\n        }\n    }\n    void update(int a, int b, T x, int k=1, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true; eval(k);\n        }else{\n            update(a, b, x, 2*k, l, (l+r)/2); update(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = min(node[2*k],node[2*k+1]);\n        }\n    }\n    void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy_add[k] += x; eval(k);\n        }else{\n            add(a, b, x, 2*k, l, (l+r)/2); add(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = min(node[2*k],node[2*k+1]);\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = numeric_limits<T>::max(), res2 = numeric_limits<T>::max();\n        while(a < b) {\n            if(a & 1) eval(a), res1 = min(res1, node[a++]);\n            if(b & 1) eval(--b), res2 = min(res2, node[b]);\n            a >>= 1, b >>= 1;\n        }\n        return min(res1, res2);\n    }\n    void print(){\n        for(int i = 0; i < sz; i++){\n            cout<<query(i,i+1)<< \" \";\n        }\n        cout<<endl;\n    }\n};\n\n\nint main(){\n    ll n,e,t;\n    cin >> n >> e >> t;\n    if(n>=2001)return 0;\n    vector<ll> a(n+1);\n    a[0] = 0;\n    rep(i,n){\n        cin >> a[i+1];\n    }\n    a.push_back(e);\n    n+=2;\n    vector<ll>dp(n,1LL<<60);\n    segtree<ll> sg(dp);\n    int p = 0;\n    rep(i,n-1){\n        if(i==0){\n            sg.update(0,1,a[1]-a[0]);\n            continue;\n        }\n        ll k = sg.query(0,i);\n        //k += a[i+1]-a[i];\n        sg.update(i,i+1,k+t);\n        \n        // rep(j,i-1){\n        //     dp[i] = min(dp[i],dp[j]+(a[j+1]-a[j])+max(3*(a[i]-a[j+1]),t+(a[i]-a[j+1])));\n        // }\n        sg.add(0,p,3*(a[i+1]-a[i]));\n        sg.add(p,i+1,(a[i+1]-a[i]));\n        while(1){\n            if(3*(a[i+1]-a[p+1]) > t+(a[i+1]-a[p+1])){\n                sg.add(p,p+1,-(t+(a[i+1]-a[p+1])));\n                sg.add(p,p+1,3*(a[i+1]-a[p+1]));\n                p++;\n            }else{\n                break;\n            }\n        }\n        cerr << p << endl;\n        // if(i!=n-1){\n        //     dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]+t);\n        //     k = min(k,sg.query(i-1,i)+a[i]-a[i-1]+t);\n        // }else{\n        //     dp[i] = min(dp[i],dp[i-1]+a[i]-a[i-1]);    \n        // }\n        //sg.print();\n    }\n    cout << sg.query(n-2,n-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 100005, sz = 131072;\nconst ll INF = ll(1e18);\n\nstruct Seg{\n    ll d[2 * sz];\n    void ini(){ fill(d, d + 2 * sz, INF); }\n    void upd(int x, ll v){\n        x += sz;\n        d[x] = min(d[x], v);\n        for(x >>= 1; x; x >>= 1) d[x] = min(d[2 * x], d[2 * x + 1]);\n    }\n    ll get(int s, int e){\n        ll r = INF;\n        for(s += sz, e += sz; s <= e; s >>= 1, e >>= 1){\n            if( s & 1) r = min(r, d[s++]);\n            if(~e & 1) r = min(r, d[e--]);\n        }\n        return r;\n    }\n} S, T;\n\nint n, l, t, x[N];\n\nint main(){\n    scanf(\"%d%d%d\", &n, &l, &t);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", x + i);\n    S.ini();\n    T.ini();\n    S.upd(0, 0);\n    T.upd(0, -2 * x[1]);\n    for(int i = 1, j = 0; i <= n; i++){\n        while(j < i - 1 && 2 * (x[i] - x[j + 1]) > t) j++;\n        ll v = min(S.get(j, i - 1) + t + x[i], T.get(0, j - 1) + 3LL * x[i]);\n        S.upd(i, v - x[i]);\n        T.upd(i, v - x[i] - 2 * x[i + 1]);\n    }\n    printf(\"%lld\\n\", S.get(n, n) + l);\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nnamespace Segment_tree {\n\ttemplate<typename T>\n\tclass segment_tree {\n\t\tvector<T> dat;\n\t\tint n;\n\t\tT e;\n\t\tstd::function<T(T, T)> f;\n\t\tT query_implement(int a, int b, int k, int l, int r) {\n\t\t\tif (r <= a || b <= l) return e;\n\t\t\tif (a <= l && r <= b) return dat[k];\n\n\t\t\tT v1 = query_implement(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT v2 = query_implement(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn f(v1, v2);\n\t\t}\n\tpublic:\n\t\tsegment_tree(int n_, T _e, T(*calc)(T lhs, T rhs)) {\n\t\t\te = _e;\n\t\t\tf = calc;\n\t\t\tn = 1;\n\t\t\twhile (n < n_) n *= 2;\n\t\t\tdat.resize(2 * n - 1);\n\t\t\tfor (int i = 0; i < 2 * n - 1; i++)\n\t\t\t\tdat[i] = e;\n\t\t}\n\n\t\tvoid update(int k, int a) {\n\t\t\tk += n - 1;\n\t\t\tdat[k] = a;\n\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tdat[k] = f(dat[k * 2 + 2], dat[k * 2 + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT query(int a, int b) { return query_implement(a, b, 0, 0, n); }\n\t};\n}\nlong long int f(long long int i, long long int j) { return min(i, j); }\nint main()\n{\n\tlong long int n, e, t;\n\tcin >> n >> e >> t;\n\tvector<long long int> x(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\n\tvector<long long int> dp(n,0);\n\tdp[0] = x[0] + t;\n\t\n\tSegment_tree::segment_tree<long long int> seg(n,1e10,f);\n\tfor (int i = 1; i < n; i++) {\n\t\tlong long int res = dp[i-1]+x[i]-x[i-1]+t;\n\t\tres = min(res, x[i] + x[i] - x[0] + max(0LL, t - 2 * (x[i] - x[0])) + x[i] - x[0]);\n\t\tint index=lower_bound(ALL(x), x[i]-double(t)/2+0.001) - x.begin();\n\t\tif (index >= i)\n\t\t\tindex = i-1;\n\t\tindex--;\n\t\tif (index > 0)\n\t\t\tres = min(res, dp[index] - 2 * x[index] - x[index + 1]);\n\t\tindex = lower_bound(ALL(x), x[i] - double(t) / 2+0.001) - x.begin();\n\t\tindex--;\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t\tif (index < i - 1) {\n\t\t\tlong long int a = seg.query(index, i - 1);\n\t\t\tres = min(res, a + x[i]);\n\t\t}\n\t\tdp[i] = res;\n\t\tif(i<n-1)\n\t\tseg.update(i,dp[i] - 2 * x[i] - x[i + 1] + t - 2 * x[i + 1]);\n\t}\n\tcout << dp[n - 1] + e - x[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\n#define int ll\n\nconst int N = 1e5 + 10;\nconst int BINF = 1e18 + 10;\nint dp[N], a[N];\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[1] = a[1] + t;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = BINF;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[j - 1] + (a[j] - a[j - 1]) + (a[i] - a[j]) + max(2 * (a[i] - a[j]), t));\n\t\t}\n\t\t//cout << dp[i] << ' ';\n\t}\n\t//cout << '\\n';\n\tcout << dp[n] + (e - a[n]) << '\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nlong long dp[N], x[N], premin[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, T;\n    cin>>n>>m>>T;\n    premin[0] = 1e18;\n\n    for (int i=1; i<=n; i++) {\n        cin>>x[i];\n        premin[i] = min(dp[i-1]-2*x[i], premin[i-1]);\n        int idx = upper_bound(x+1, x+i, x[i]-T/2)-x-1;\n        dp[i] = min(premin[idx]+2*x[i], dp[idx]+T);\n    }\n    cout<<dp[n]+m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repp(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dp[2010];\nconst int INF = 1e12;\n\nsigned main(){\n    int n, t, e;\n    cin >> n >> e >> t;\n    if(n > 2000) return 0;\n    vector<int> a(n);\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, 2010){\n        dp[i] = INF;\n    }\n    dp[0] = a[0];\n    rep(i, 1, n + 1){\n        rep(j, i, n + 1){\n            int tmp = 2 * (a[j - 1] - a[i - 1]);\n            if(tmp < t) tmp = tmp +  (t - tmp) * (j - i + 1);\n            dp[j] = min(dp[j], dp[i - 1] + tmp);\n            // cout << i << ' ' << j << ' ' << tmp << ' ' << dp[j] << endl;\n        }\n    }\n    // rep(i, 0, n + 1){\n    //     cout << dp[i] << \" \";\n    // }\n    cout << dp[n] + e - a[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define Pair pair<int, int>\n#define MP(x, y) make_pair(x, y)\n#define fi first\n#define se second\n//#define int long long \n#define LL long long \n#define Fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define Fout(x) {freopen(#x\".out\",\"w\",stdout);}\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)\nchar buf[(1 << 22)], *p1 = buf, *p2 = buf;\nusing namespace std;\nconst int MAXN = 2e5 + 10, mod = 998244353, INF = 1e9 + 10;\nconst double eps = 1e-9;\ntemplate <typename A, typename B> inline bool chmin(A &a, B b){if(a > b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmax(A &a, B b){if(a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline LL add(A x, B y) {if(x + y < 0) return x + y + mod; return x + y >= mod ? x + y - mod : x + y;}\ntemplate <typename A, typename B> inline void add2(A &x, B y) {if(x + y < 0) x = x + y + mod; else x = (x + y >= mod ? x + y - mod : x + y);}\ntemplate <typename A, typename B> inline LL mul(A x, B y) {return 1ll * x * y % mod;}\ntemplate <typename A, typename B> inline void mul2(A &x, B y) {x = (1ll * x * y % mod + mod) % mod;}\ntemplate <typename A> inline void debug(A a){cout << a << '\\n';}\ntemplate <typename A> inline LL sqr(A x){return 1ll * x * x;}\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nLL N, E, T, a[MAXN], f[MAXN];\nint main() {\n\tN = read(); E = read(); T = read();\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i = 1; i <= N; i++) a[i] = read();\n\tf[0] = 0; f[1] = T;\n\tLL mn = 1e18, j = 0;\n\tfor(int i = 2; i <= N; i++) {\n\t\twhile(T <= 2 * (a[i] - a[j + 1])) chmin(mn, f[j] - 2 * a[j + 1]), j++;\n\t\tchmin(f[i], mn + 2 * a[i]);\n\t\tchmin(f[i], f[j] + T);\n\t}\n\tcout << f[N] + E;\n    return 0;\n}\n/*\n3 9 23333\n1 3 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF      5000000000000000000\n#define EPS      1e-10\n#define MOD      1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll n, e, t;\nll x[100001];\nll dp[100001];\n\nint main(){\n    cin >> n >> e >> t;\n    rep(i,n) cin >> x[i+1];\n    rep(i,n+1) dp[i] = INF;\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < i; j++){\n            dp[i] = min(dp[i],dp[j]+x[j+1]-x[j]+max((x[i]-x[j+1])*2,t)+x[i]-x[j+1]);\n        }\n    }\n    cout << dp[n]+e-x[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define LL long long\nusing namespace std;\nmultiset<LL> s1, s2;\nLL dp[110000], dp2[110000];\nint x[110000], n, E, T;\nint main(){\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tdp2[0] = T;s1.insert(T);\n\tfor(int i = 1, j = 0; i <= n; i++){\n\t\tscanf(\"%d\", &x[i]);\n\t\twhile(j < i && 2 * (x[i] - x[j + 1]) >= T){\n\t\t\ts1.erase(s1.find(dp2[j]));\n\t\t\tdp2[j] = dp2[j] - T - 2 * (x[j + 1]);\n\t\t\ts2.insert(dp2[j]);\n\t\t\tj++;\n\t\t}\n\t\tdp2[i] = (((LL)1)<<50);\n\t\tif(!s1.empty()) dp[i] = min(dp[i], *s1.begin() + x[i]);\n\t\tif(!s2.empty()) dp[i] = min(dp[i], *s2.begin() + (LL)3 * x[i]);\n\t\tdp2[i] = dp[i] - x[i] + T; \n\t\ts1.insert(dp2[i]);\n\t}\n\tcout<<dp[n] - x[n] + E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e17\n\nstruct StarrySkyTree {\n  vector<ll> seg, lazy;\n  int size;\n  StarrySkyTree() {}\n  StarrySkyTree(int n) {\n    init(n);\n  }\n  void init(int n) {\n    size = 1;\n    while (size < n) size *= 2;\n    seg.resize(size * 2);\n    lazy.resize(size * 2);\n    for(ll i=0;i<size*2;i++)seg[i]=INF;\n  }\n  void update(int k,ll v){\n    k += size-1;\n    seg[k] = v;\n    while(k > 0){\n      k = (k - 1)/2;\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void push(int k, int l, int r) {\n    seg[k] += lazy[k];\n    if (r - l > 1) {\n      lazy[k * 2 + 1] += lazy[k];\n      lazy[k * 2 + 2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n  void add(int a, int b, ll v, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += v;\n      push(k, l, r);\n    } else {\n      add(a, b, v, k * 2 + 1, l, (l + r) / 2);\n      add(a, b, v, k * 2 + 2, (l + r) / 2, r);\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void add(int a, int b, ll v) {\n    add(a, b, v, 0, 0, size);\n  }\n  ll query(int a, int b, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return INF*10; // caution\n    if (a <= l && r <= b) return seg[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return min(vl,vr);\n  }\n  ll query(int a, int b) {\n    return query(a, b, 0, 0, size);\n  }\n};\n\nll n,T,E;\nll x[101010];\nset<P> st;\nStarrySkyTree dp,dp1,dp2;\n\nint main(){\n\tcin>>n>>E>>T;\n  rep(i,n)cin>>x[i];\n  rep(i,n)st.insert(P(-2*x[i],i));\n  x[n]=E;\n  dp.init(n+1); dp1.init(n+1); dp2.init(n+1);\n  rep(i,n+1){\n    dp.update(i,0); dp1.update(i,0); dp2.update(i,0);\n  }\n  dp.update(0,x[0]); dp1.update(0,x[0]-x[0]); dp2.update(0,x[0]-2*x[0]);\n  rep(i,n){\n    ll k;\n    if(st.lower_bound(P(-2*x[i]+T,-INF))==st.end())k=-1;\n    else k=st.lower_bound(P(-2*x[i]+T,-INF))->se;\n    k++;\n    ll crt=INF;\n    // [0,k)\n    minch(crt,dp2.query(0,k)+2*x[i]);\n    // [k,i+1)\n    minch(crt,dp1.query(k,i+1)+x[i]+T);\n    crt+=x[i+1]-x[i];\n    dp.add(i+1,i+2,crt); dp1.add(i+1,i+2,crt-x[i+1]); dp2.add(i+1,i+2,crt-2*x[i+1]);\n    dp.add(0,i+1,x[i+1]-x[i]); dp1.add(0,i+1,x[i+1]-x[i]); dp2.add(0,i+1,x[i+1]-x[i]);\n  }\n  cout<<dp.query(n,n+1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 1LL << 62;\n        for (int j = i - 1; j >= 0; --j) {\n            dp[i] = min((int64_t) dp[i], dp[j] + X[j + 1] - X[j] + \n                    3LL * (X[i] - X[j + 1]) + max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1]))));\n        }\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nint n, T, E;\nll x[N], dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &E, &T);\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n    if (i == 1) continue;\n    int l = 1, r = i - 1, res = 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if ((x[i] - x[mid]) * 2 >= T) {\n        res = mid;\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    dp[i] = min(dp[i], dp[res - 1] + x[res] - x[res - 1] + (x[i] - x[res]) * 3);\n  }\n  printf(\"%lld\\n\", dp[n] + E - x[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[2222];\nLL ans;\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tif(n > 2222) { return 1; }\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tinc1(i, n) {\n\t\tans += x[i] - x[i - 1];\n\t\t\n\t\tint jj = i;\n\t\tincII(j, i, n) {\n\t\t\tLL l = x[j] - x[i];\n\t\t\tLL w = l + t * (j - i + 1);\n\t\t\tLL b = l + max(2 * l, t);\n\t\t\tif(w >= b) { jj = j; }\n\t\t}\n\t\tLL l = x[jj] - x[i];\n\t\tLL w = l + t * (jj - i + 1);\n\t\tLL b = l + max(2 * l, t);\n\t\tans += min(w, b);\n\t\t\n\t\ti = jj;\n\t}\n\tans += e - x[n];\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define SIZE 262144\ntypedef long long ll;\n#define INF 1000000000000000000LL\nclass segtree\n{\npublic:\n\tll seg[SIZE * 2];\n\tvoid init()\n\t{\n\t\tfill(seg, seg + SIZE * 2, INF);\n\t}\n\tvoid update(int a, ll b)\n\t{\n\t\ta += SIZE;\n\t\tseg[a] = min(seg[a], b);\n\t\tfor (;;)\n\t\t{\n\t\t\ta /= 2;\n\t\t\tif (a == 0)break;\n\t\t\tseg[a] = min(seg[a * 2], seg[a * 2 + 1]);\n\t\t}\n\t}\n\tll get(int beg, int end, int node, int lb, int ub)\n\t{\n\t\tif (ub < beg || end < lb)return INF;\n\t\tif (beg <= lb&&ub <= end)return seg[node];\n\t\treturn min(get(beg, end, node * 2, lb, (lb + ub) / 2), get(beg, end, node * 2 + 1, (lb + ub) / 2 + 1, ub));\n\t}\n};\nsegtree tree1,tree2;\nint main()\n{\n\tint num;\n\tll len, gen;\n\tscanf(\"%d%lld%lld\", &num, &len, &gen);\n\tvector<ll>vec;\n\tvec.push_back(0);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tll z;\n\t\tscanf(\"%lld\", &z);\n\t\tvec.push_back(z);\n\t}\n\tvec.push_back(len);\n\ttree1.init();\n\ttree2.init();\n\ttree1.update(0, vec[1] - 3 * vec[1]);\n\ttree2.update(0, vec[1] - vec[1]);\n\tfor (int i = 1; i < vec.size() - 1; i++)\n\t{\n\t\tint low = lower_bound(vec.begin(), vec.end(), vec[i] - gen / 2) - vec.begin() - 1;\n\t\tll mini = min(tree1.get(0, low - 1, 1, 0, SIZE - 1) + vec[i] * 3, tree2.get(low, i - 1, 1, 0, SIZE - 1) + vec[i] + gen) + vec[i + 1] - vec[i];\n\t\ttree1.update(i, mini - vec[i + 1] * 3);\n\t\ttree2.update(i, mini - vec[i + 1]);\n\t}\n\tprintf(\"%lld\\n\", tree2.get(vec.size() - 2, vec.size() - 2, 1, 0, SIZE - 1) + len);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = upper_bound(a, a + n + 1, a[i] - 2 * t) - a;\n\t\tdp[i] = 1ll * N * N;\n\t\tif (x < i) {\n\t\t\tdp[i] = get(i, x);\n\t\t}\n\t\tif (x > 0) {\n\t\t\tdp[i] = min(dp[i], get(i, x - 1));\n\t\t}\t\n\t//\tcout << \"73 \" << i << \" \" << x << \" \" << dp[i] << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst long long inf = 1e18;\n\nstruct SegmentTree {\n\tlong long t[N << 2];\n\tSegmentTree() { for (int i = 0; i < (N << 2); ++i) t[i] = inf; }\n\n\t#define mid ((l + r) >> 1)\n\tvoid upd(int v, int l, int r, int pos, long long val) {\n\t\tif (l > r || pos < l || pos > r) return;\n\t\tif (l == r) { t[v] = val; return; }\n\t\tupd(v << 1, l, mid, pos, val); upd(v << 1 | 1, mid + 1, r, pos, val);\n\t\tt[v] = min(t[v << 1], t[v << 1 | 1]);\n\t}\n\tlong long get(int v, int l, int r, int L, int R) {\n\t\tif (l > r || R < l || L > r) return inf;\n\t\tif (L <= l && r <= R) return t[v];\n\t\treturn min(get(v << 1, l, mid, L, R), get(v << 1 | 1, mid + 1, r, L, R));\n\t}\n} L, R;\n\nint n;\nlong long T, E;\nlong long x[N];\nlong long f[N];\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; ++i) cin >> x[i];\n\t\n\tint ptr = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tL.upd(1, 1, n, i, f[i - 1] - x[i - 1] - x[i] * 2);\n\t\tR.upd(1, 1, n, i, f[i - 1] - x[i - 1]);\n\t\twhile(ptr < i && (x[i] - x[ptr + 1]) * 2 > T) ++ptr;\n\t\tf[i] = L.get(1, 1, n, 1, ptr) + 3LL * x[i];\n\t\tf[i] = min(f[i], R.get(1, 1, n, ptr + 1, i) + T + x[i]);\n\t}\n\n\tlong long ans = f[n] + E - x[n];\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mini=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[i]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long dp[2010];\nint x[2010];\nint n,e;\nlong long t;\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tdp[i]=4e18;\n\t\tfor(int j=0;j+1<i;j++)\n\t\t{\n\t\t\tlong long tt=2*(x[i]-x[j+1]);\n\t\t\tdp[i]=min(dp[i],dp[j]+x[i]-x[j]+min((t+tt-1)/tt*tt,t*(i-j)));\n\t\t}\n\t\tdp[i]=min(dp[i],dp[i-1]+x[i]-x[i-1]+t);\n\t}\n\tprintf(\"%lld\",dp[n]+e-x[n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, E, T;\nint A[100002];\nlong long dp[100002];\nlong long f[100002];\nlong long g[100002];\n\nint main()\n{\n    scanf(\"%d%d%d\", &N, &E, &T);\n    for(int i=1; i<=N; i++)\n        scanf(\"%d\", A+i);\n    A[N+1]=E;\n    dp[0]=A[1];\n    f[0]=dp[0]-3LL*A[1];\n    g[0]=dp[0]-A[1];\n    multiset<long long> s;\n    s.insert(g[0]);\n    int ptr=0;\n    for(int i=1; i<=N; i++)\n    {\n        dp[i]=0x3f3f3f3f3f3f3f3fLL;\n        while(ptr<i && T<2LL*(A[i]-A[ptr+1]))\n        {\n            s.erase(s.find(g[ptr]));\n            ptr++;\n        }\n        if(ptr>0)\n            dp[i]=min(dp[i], f[ptr-1]+2LL*A[i]);\n        if(!s.empty())\n            dp[i]=min(dp[i], *s.begin()+T);\n        dp[i]+=A[i+1];\n        f[i]=min(dp[i]-3LL*A[i+1], f[i-1]);\n        g[i]=dp[i]-A[i+1];\n        s.insert(g[i]);\n    }\n    printf(\"%lld\\n\", dp[N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll INF = 1e17;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nll dp[MAXN];\n\nint x[MAXN];\n\nvoid solve(){\n\tint n, E, T;\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tREPN(i, 1, n){\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tll mn = INF;\n\tfor(int i = 1, j = 1; i <= n; i++){\n\t\tfor(; 2 * (x[i] - x[j]) >= T; j++){\n\t\t\tmn = min(mn, dp[j - 1] - x[j - 1] - 2ll * x[j]);\n\t\t}\n\t\tdp[i] = min(dp[j - 1] - x[j - 1] + x[i] + T, mn + 3ll * x[i]);\n\t\t//printf(\"%d %d %lld %lld %lld %lld\\n\", i, j, mn, dp[j - 1] - x[j - 1] + x[i] + T, mn + 3ll * x[i], dp[i]);\n\t}\n\tll ans = (ll)E - (ll)x[n] /*+ (ll)x[1] - 0ll*/ + dp[n];\n\tprintf(\"%lld\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200006\n#define ll long long\nll n,t,e;\nll x[nn];ll f[nn];\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&x[i]);\n\tdeque<int> q;ll oops=1e17;\n\tq.push_back(0);x[0]=0;int ls=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ls<i and 2*(x[i]-x[ls+1])>t)\n\t\t{\n\t\t\tif(q.size() and ls==q.front()) q.pop_front();\n\t\t\toops=min(oops,f[ls]-x[ls+1]*2-x[ls]);\n\t\t\tls++;\n\t\t}\n\t\t\n\t\tif(q.size()) f[i]=f[q.front()]+t+x[i]-x[q.front()];\n\t\telse f[i]=1e17;\n\t\tf[i]=min(f[i],oops+x[i]*3);\n\t\twhile(q.size() and f[q.back()]-x[q.back()]>=f[i]-x[i]) \n\t\t\tq.pop_back();\n\t\tq.push_back(i);\n\t}\t\n\t\n\tprintf(\"%lld\\n\",f[n]+e-x[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int LL;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            cout<<x<<\"/\"<<y<<endl;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n//////////////////////////\n\n\n\n\ntemplate<typename T, typename Func_mv>\nstruct Segtree {\n    ll n, n_org;\n    vector<T> dat;\n    Func_mv merge_values;  //dataとdataの演算\n    T te; //dataの単位元かつ初期値\n \n    Segtree(){}\n    Segtree(ll n_org,\n                Func_mv merge_values,\n                T te):\n                n_org(n_org),\n                merge_values(merge_values),\n                te(te){\n        n = 1;\n        while(n < n_org) n <<= 1;\n        dat.resize(2*n-1, te);\n    }\n \n    void build(vector<T>& A){\n        for(ll k=0; k<ll(A.size()); k++) dat[k+n-1] = A[k];\n        for(ll k=n-2; k>=0; k--) dat[k] = merge_values(dat[2*k+1], dat[2*k+2]);\n    }\n    void update(ll k, T x){ //位置kの要素を更新\n        k+=n-1;\n        dat[k]=x;\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=merge_values(dat[2*k+1],dat[2*k+2]);\n        }\n    }\n    void add(ll k,T x){//位置kの要素に加算\n        k+=n-1;\n        dat[k]+=x;\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=merge_values(dat[2*k+1],dat[2*k+2]);\n        }\n    }\n    T get(ll a, ll b){ //[a,b]から(最小値とか和とかを)get\n        return query(a, b+1, 0, 0, n);\n    }\n    \nprivate:\n    T query(ll a, ll b, ll k, ll lb, ll rb){\n        if(rb<=a || b<=lb) return te;\n        if(a<=lb && rb<=b) return dat[k];\n        ll mb = (lb+rb)>>1;\n        T vl = query(a, b, 2*k+1, lb, mb);\n        T vr = query(a, b, 2*k+2, mb, rb);\n        return merge_values(vl, vr);\n    }\n};\nauto make_segtree = [](ll N){ //auto make_segtree = [&](ll N)\n    //点更新と区間最小\n    using T = ll;\n    auto merge_values = [](T& a, T& b){return min(a, b);};\n    T te = inf;\n    return Segtree<T, decltype(merge_values)>\n        (N, merge_values, te);\n};\n/*\nauto st = make_segtree(n);\nvector<ll> init(n);\nst.build(init);\n */\n\nint main(){fastio\n    ll n,e,t;cin>>n>>e>>t;\n    vector<ll>x(n+1);\n    rep(i,0,n-1)cin>>x[i];\n    x[n]=e;\n    auto ep=make_segtree(n+1);\n    ep.update(0,-2*x[0]);\n    rep(i,1,n){\n        ll k=POSL(x,(2*x[i-1]-t+1)/2)-1;\n        ll res=x[i]+2*x[i-1]+ep.get(0,k);\n        \n        ll res2=ep.get(i-1,i-1)+3*x[i-1]+t+(x[i]-x[i-1]);\n        if(k+1<i)chmin(res2,((ep.get(k+1,k+1)+3*x[k+1])+x[i]-x[k+1]+t));\n        ep.update(i,min(res,res2)-3*x[i]);\n    }\n    \n    //rep(i,0,n)cout<<ep.get(i,i)<<\" \";cout<<endl;\n    //rep(i,0,n)cout<<ep.get(i,i)+3*x[i]<<\" \";cout<<endl;\n    cout<<ep.get(n,n)+3*x[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n数据不清空，爆零两行泪。\n多测不读完，爆零两行泪。\n边界不特判，爆零两行泪。\n贪心不证明，爆零两行泪。\nD P 顺序错，爆零两行泪。\n大小少等号，爆零两行泪。\n变量不统一，爆零两行泪。\n越界不判断，爆零两行泪。\n调试不注释，爆零两行泪。\n溢出不 l l，爆零两行泪。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int N=100000;\nint n,m,s;\nint a[N+1];\nint dp[N+1];\nint q[N],head,tail;\nsigned main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tq[tail++]=0;\n\tint now=-1,mn=inf;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(now+1<i&&2*a[now+2]<2*a[i]-s)now++,mn=min(mn,dp[now]-a[now]-2*a[now+1]);\n\t\twhile(head<tail&&q[head]<=now)head++;\n\t\twhile(head<tail&&dp[q[tail-1]]-a[q[tail-1]]>=dp[i-1]-a[i-1])tail--;\n\t\tq[tail++]=i-1;\n\t\tdp[i]=mn+3*a[i];\n\t\tif(head<tail)dp[i]=min(dp[i],dp[q[head]]-a[q[head]]+a[i]+s);\n\t}\n\tcout<<dp[n]+m-a[n]<<\"\\n\";\n\treturn 0;\n}\n/*1\n3 9 1\n1 3 8\n*/\n/*2\n3 9 3\n1 3 8\n*/\n/*3\n2 1000000000 1000000000\n1 999999999\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int MAXN = 2000;\nint x[MAXN + 1];\nll dp[MAXN + 1];\n\nint main() {\n    //ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    int n, e, t;\n    cin >> n >> e >> t;\n    for(int i = 1; i <= n; i++)\n        cin >> x[i];\n    for(int i = 0; i <= MAXN; i++)\n        dp[i] = 1e18;\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        dp[i] = min(dp[i], dp[i - 1] + (x[i] - x[i - 1]) + t);\n        for(int j = 0; j < i; j++) {\n            ll need = 2 * (x[i] - x[j]);\n            need += max(0LL, t - need);\n            //cout << i << \" \" << j << \" \" << need << endl;\n            dp[i] = min(dp[i], dp[j - 1] + need + (x[i] - x[j]) + (x[j] - x[j - 1]));\n        }\n    }\n    dp[n] += e - x[n];\n    cout << dp[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\nusing namespace std;\nlong long dp[2005];\nlong long a[2005], n, E, T;\nint main() {\n\tcin >> n >> E >> T; if (n > 2000)return 0;\n\tfor (long long i = 1; i <= n; i++)cin >> a[i];\n\tfor (long long i = 0; i < 2005; i++)dp[i] = 1LL << 60; dp[0] = 0;\n\tfor (long long i = 0; i < n; i++) {\n\t\tfor (long long j = i + 1; j <= n; j++) {\n\t\t\tlong long J1 = a[j] - a[i];\n\t\t\tlong long J2 = a[j] - a[i + 1];\n\t\t\tlong long J3 = 0; if (J2 * 2 < T)J3 = T - J2 * 2;\n\t\t\tlong long J4 = a[j] - a[i + 1];\n\t\t\tdp[j] = min(dp[j], dp[i] + J1 + J2 + J3 + J4);\n\t\t}\n\t}\n\tlong long minx = 1LL << 60;\n\tcout << dp[n] + abs(a[n] - E) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  1000000007;\n\n\n     signed main(){\n   int n,e,t;\n   cin>>n>>e>>t;\n   int x[n+1],ans[n+1];\n   for(int i=1;i<=n;i++)cin>>x[i];\n   ans[0]=e;\n   for(int i=1;i<=n;i++){\n     ans[i]=ans[i-1]+t;\n     for(int j=1;j<i;j++){\n       ans[i]=min(ans[i],ans[j-1]+max(t,2*(x[i]-x[j])));\n     }\n   }\n   cout<<ans[n]<<endl;\n                  \n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmin(long long &x, long long y) {\n    if (x > y) x = y;\n}\n\nstruct RMQ {\n    int N;\n    vector<long long> seg;\n\n    RMQ(int n) {\n        N = 1 << (int)log2(n * 2 - 1);\n        seg.resize(N * 2, 1e18);\n    }\n\n    void update(int k, long long v) {\n        for (seg[k += N] = v; k > 1; k >>= 1) {\n            seg[k >> 1] = min(seg[k], seg[k ^ 1]);\n        }\n    }\n\n    long long minimum(int l, int r) {\n        long long res = 1e18;\n        for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = min(res, seg[l++]);\n            if (r & 1) res = min(res, seg[--r]);\n        }\n        return res;\n    }\n};\n\nlong long dp[101010];\n\nint main() {\n    int n;\n    long long T, E;\n    cin >> n >> E >> T;\n    vector<long long> x(n), d(n), ds(n + 1);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 0; i < n - 1; i++) d[i] = x[i + 1] - x[i];\n    for (int i = 0; i < n; i++) ds[i + 1] = ds[i] + d[i];\n\n    fill_n(dp, 101010, 1e17);\n    dp[0] = 0;\n\n    RMQ L(n + 1), R(n + 1);\n    L.update(0, 0);\n    R.update(0, 0);\n\n    for (int i = 1; i <= n; i++) {\n        // T >= 2 * (ds[i] - ds[j])\n        int ok = i;\n        int ng = -1;\n        while (ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if (T >= 2 * (ds[i] - ds[mid])) ok = mid;\n            else ng = mid;\n        }\n        chmin(dp[i], L.minimum(ok, i));\n        chmin(dp[i], R.minimum(0, ok) + 2 * ds[i]);\n\n        L.update(i, dp[i] + T);\n        R.update(i, dp[i] - 2 * ds[i]);\n    }\n\n    cout << dp[n] + E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <functional>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <stdio.h>\n#include <memory.h>\n#include <sstream>\n#include <iterator>\n\nint main () {\n\tint n, t, e;\n\tstd::cin >> n >> e >> t;\n\tif (n > 2000) {\n\t\treturn 0;\n\t}\n\tstd::vector <long long> d(n + 1, (long long)1e18);\n\tstd::vector <long long> v(n + 1);\n\tfor (int i = 0; i < n; i++)\n\t\tstd::cin >> v[i];\n\tv[n] = e;\n\td[0] = v[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\td[j] = std::min (d[j], d[i] + std::max((v[j - 1] - v[i]) * 3, t + v[j - 1] - v[i]) + v[j] - v[j - 1]);\n\t\t}\n\t}\n\tstd::cout << d[n] << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=2e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tfor(int A=1;A<=N+3;A++)\n\t\tdp[A]=-1;\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]);\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\ntypedef long long LL;\n\ninline int read()\n{\n\tchar c=getchar();int num=0,f=1;\n\tfor(;!isdigit(c);c=getchar())\n\t\tf=c=='-'?-1:f;\n\tfor(;isdigit(c);c=getchar())\n\t\tnum=num*10+c-'0';\n\treturn num*f;\n}\n\nconst int N=1e5+5;\n\nint n,E,T,x[N];\nLL f[N];\n\nint main()\n{\n\tn=read(),E=read(),T=read();\n\tfor(int i=1;i<=n;++i) x[i]=read();\n\tLL mn=1ll<<60;\n\tfor(int i=1,j=0;i<=n;++i)\n\t{\n\t\twhile(T<=2*(x[i]-x[j+1])) mn=min(mn,f[j]-2*x[j+1]),++j;\n\t\tif(i!=j) f[i]=min(mn+2*x[i],f[j]+T);\n\t\telse f[i]=mn+2*x[i];\n\t}\n\tcout<<f[n]+E;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb  push_back\n#define mp  make_pair\n#define int long long\n#define itr ::iterator \n\ntypedef pair<int,int>  pii;\n\nconst int MAX=1e6;\nconst int INF=1e18;\n\nint N,E,T,cur,arr[MAX],dp[MAX],pre[3000][3000];\n\nint cal(int ind)\n{\n\tif(ind==N+1)\n\t\treturn 0;\n\tif(dp[ind]!=-1)\n\t\treturn dp[ind];\n\tdp[ind]=INF;\n\tfor(int A=ind;A<=N;A++)\n\t\tdp[ind]=min(dp[ind],pre[ind][A]+(arr[A+1]-arr[A])+cal(A+1));\n\treturn dp[ind];\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tfor(int A=1;A<=N+3;A++)\n\t\tdp[A]=-1;\n\tcin>>N>>E>>T;\n\tfor(int A=1;A<=N;A++)\n\t\tcin>>arr[A];\n\tarr[N+1]=E;\n\tfor(int A=1;A<=N;A++)\n\t\tfor(int B=A;B<=N;B++)\n\t\t{\n\t\t\tcur=T-2*(arr[B]-arr[A]);\n\t\t\tif(cur<=0)\n\t\t\t\tpre[A][B]=3*(arr[B]-arr[A]);\n\t\t\telse\n\t\t\t\tpre[A][B]=T-2*(arr[B]-arr[A])+3*(arr[B]-arr[A]);\n\t\t}\n\tcout<<cal(1)+arr[1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n       \n          A FAN OF FIZZYDAVID\n           \n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-20\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define debug puts(\"OK\");\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\n#ifdef ONLINE_JUDGE\n#else\n#define DEBUG\n#endif\n\n//---------------------------head----------------------------\n\nconst int N=2333;\n\nint n;\nLL T;\nLL dp[N],x[N];\n\norz yjz()\n{\n\tscf(n); scf(x[n+1]); scf(T);\n\tforn(i,1,n) scf(x[i]);\n\tnrof(i,n,1)\n\t{\n\t\tdp[i]=linf;\n\t\tforn(j,i+1,n+1) dp[i]=min(dp[i],dp[j]+max(2*(x[j-1]-x[i]),T)+x[j]-x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[1]+x[1]);\n\tfizzydavid ak la\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define SZ(a) (int)((a).size())\n\nconst int MAXN = 100007;\nconst int INF = 1000000007;\nconst LL LINF = INF * (LL)INF;\n\nLL A[MAXN], DP[MAXN];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 1, n + 1)\n\t\tcin >> A[i];\n\tDP[0] = A[0] = 0;\n\tDP[1] = A[1] + t;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tint j = lower_bound(A, A + i, A[i] - (t + 1) / 2) - A;\n\t\tif (j) --j;\n\t\tDP[i] = 3 * A[i] + DP[j] - A[j] + max(t - 2 * A[i], -2 * A[j + 1]);\n\t\tif (j) --j;\n\t\tDP[i] = min(DP[i], 3 * A[i] + DP[j] - A[j] + max(t - 2 * A[i], -2 * A[j + 1]));\n\t}\n\tcout << DP[n] + e - A[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<39;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nll n, e, t;\nll x[N], dp[N];\n\nint main(){\n\tcin>>n>>e>>t;\n\trep(i, n) cin>>x[i];\n\tfill(dp, dp+N, INF);\n\tdp[0] = 0;\n\trep(i, n){\n\t\tll r = upper_bound(x, x+n, x[i]+t/2)-x;\n\t\tif(r<n){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t\tr--;\n\t\tif(r>=i){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t\tif(x[i]-x[0]>=t/2) chmin(dp[i+1], dp[i]+2*(x[i+1]-x[i]));\n\t}\n\tcout<<dp[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\nLL dist[MAXN][MAXN];\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=i+1; j<=N; j++) {\n\t\t\t // dist i to j\n\t\t\tdist[i][j] = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\t\t\tdist[i][j] += max( T,  (x[j] - x[i+1]) * 2);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + dist[j][i]);\n\t\t\t\n\t\t}\n\t}\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<39;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nll n, e, t;\nll x[N], dp[N];\n\nint main(){\n\tcin>>n>>e>>t;\n\trep(i, n) cin>>x[i];\n\tfill(dp, dp+N, INF);\n\tdp[0] = 0;\n\trep(i, n){\n\t\tll r = upper_bound(x, x+n, x[i]+t/2)-x;\n\t\tif(r<n){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t\tr--;\n\t\tif(r>=i){\n\t\t\tll d = x[r]-x[i];\n\t\t\tchmin(dp[r+1], dp[i]+2*d+max(t-2*d, 0LL));\n\t\t}\n\t}\n\tcout<<dp[n]+e<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 100005;\nint que[MAXN], x[MAXN], n, T, E;\nLL f[MAXN];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &E, &T);\n\tint he = 1, ta = 0;\n\tLL mn = 1e18;\n\tque[++ta] = 0;\n\tfor (int i = 1, pos = 0; i <= n; i++) {\n\t\tscanf(\"%d\", x + i);\n\t\tfor (; 2 * (x[i] - x[pos + 1]) >= T; ++pos)\n\t\t\tchkmin(mn, f[pos] - x[pos] - 2 * x[pos + 1]);\n\t\tf[i] = mn + 3ll * x[i];\n\t\twhile (he <= ta && que[he] < pos) ++he;\n\t\tchkmin(f[i], f[que[he]] - x[que[he]] + x[i] + T);\n\t\twhile (he <= ta && f[i] - x[i] <= que[ta]) --ta;\n\t\tque[++ta] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + E - x[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define lowbit(a) (a&-a)\ntypedef long long ll;\nconst int maxn = 100010; const ll inf = 1LL<<60;\nint N,T,E,X[maxn]; ll tree1[4*maxn],tree2[4*maxn],f[maxn];\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar(); while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline void build(int now,int l,int r)\n{\n\ttree1[now] = tree2[now] = inf;\n\tif (l == r) return; int mid = (l+r) >> 1;\n\tbuild(now<<1,l,mid); build(now<<1|1,mid+1,r);\n}\n\ninline void modify(ll *tree,int now,int l,int r,int pos,ll key)\n{\n\tif (l == r) { tree[now] = key; return; } int mid = (l+r)>>1;\n\tif (pos <= mid) modify(tree,now<<1,l,mid,pos,key);\n\telse modify(tree,now<<1|1,mid+1,r,pos,key);\n\ttree[now] = min(tree[now<<1],tree[now<<1|1]);\n}\n\ninline ll query(ll *tree,int now,int l,int r,int ql,int qr)\n{\n\tif (ql == l&&qr == r) return tree[now]; int mid = (l+r)>>1;\n\tif (qr <= mid) return query(tree,now<<1,l,mid,ql,qr);\n\telse if (ql > mid) return query(tree,now<<1|1,mid+1,r,ql,qr);\n\telse return min(query(tree,now<<1,l,mid,ql,mid),query(tree,now<<1|1,mid+1,r,mid+1,qr));\n}\n\nint main()\n{\n\t//freopen(\"G.in\",\"r\",stdin);\n\t//freopen(\"G.out\",\"w\",stdout);\n\tN = gi(); E = gi(); T = gi();\n\tfor (int i = 1;i <= N;++i) X[i] = gi(),tree1[i] = tree2[i] = 1LL<<60;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tmodify(tree1,1,1,N,i,f[i-1]-2LL*(ll)X[i]-(ll)X[i-1]);\n\t\tmodify(tree2,1,1,N,i,f[i-1]-(ll)X[i-1]);\n\t\tint l = 0,r = i-1,mid; f[i] = inf;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l+r)>>1;\n\t\t\tif (T-2LL*(X[i]-X[mid+1]) > 0) r = mid-1;\n\t\t\telse l = mid+1;\n\t\t}\n\t\tif (r+1) f[i] = query(tree1,1,1,N,1,r+1)+3LL*X[i];\n\t\tif (r+2 <= i) f[i] = min(f[i],query(tree2,1,1,N,r+2,i)+(ll)X[i]+(ll)T);\n\t}\n\tcout << f[N]+(ll)E-(ll)X[N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long maxn = 1e5 + 10 , inf = 2e18;\nlong long e , n , t , x[maxn] , dp[maxn] , p[maxn];\n\nint main()\n{\n    cin >> n >> e >> t;\n    for(int i=0 ; i<n ; i++) cin >> x[i];\n\n    dp[0] = t; p[0] = dp[0] - 2*x[1];\n    for(int i=1 ; i<n ; i++)\n    {\n        int y = lower_bound(x,x+n , x[i]-(t/2))-x;\n        if(y == 0) dp[i] = t;\n        else if(y == 1) dp[i] = min(2*t , 2*(x[i]-x[0]));\n        else dp[i] = min(p[y-2] + 2*x[i] , dp[y-1] + t);\n        p[i] = min(p[i-1] , dp[i] - 2*(x[i+1]));\n    }\n    cout << dp[n-1] + e;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint dp[100020];\n\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=i-cor;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<=vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse vec[i]=vec[2*i+1];\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<=v2.first)return v1;\n\t\telse return v2;\n\t}\n\t\n};\n\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tfor(int i=0;i<=100010;i++)dp[i]=inf*1000000000ll;\n\t\n\tint n,e,t;\n\tcin>>n>>e>>t;\n\t\n\tvector<int> ve(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\t\n\tSegmin ss;\n\tss.shoki1();\n\tss.shoki2();\n\t\n\tdp[0]=t;\n\tss.updchan(0,dp[0]-2*ve[1]);\n\tfor(int i=1;i<n;i++){\n\t\t// r miman\n\t\tint r =ve[i]-t/2;\n\t\tint it=lower_bound(ve.begin(),ve.end(),r)-ve.begin();\n\t\t// [ 0,it)\n\t\t// [it, i]\n\t\tif(it<=i)it=i;\n\t//\tcout<<it<<\" \"<<i<<endl;\n\t\tif(1){\n\t\t\tif(it)dp[i]=min(dp[i],t+dp[it-1]);\n\t\t\telse dp[i]=min(dp[i],t);\n\t\t}\n\t//cout<<dp[i]<<endl;\n\t\tif(it){\n\t\t\tdp[i]=min(dp[i],2*(ve[i]-ve[0]));\n\t\t\t\tif(it>1){\n\t\t\tint z=ss.segmin(0,it-1).first +2* ve[i];\n\t\t//\tcout<<z<<endl;\n\t\t\tdp[i]=min(dp[i],z);\n\t\t\t\t}\n\t\t}\t\n\t//\tcout<<dp[i]<<endl;\n\t\tss.updchan(i,dp[i]-2*ve[i+1]);\n\t}\n\t\n\tcout<<dp[n-1]+e<<endl;\n\t\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MAXN=1e5+5;\nconst ll inf=(1ll<<63-1);\nll a[MAXN];\nll dp[MAXN];\nint main()\n{\n \n    ll n,e,t;\n    cin>>n>>e>>t;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n    }\n    memset(dp,(ll)0x3f3f3f3f,sizeof(dp));\n    dp[0]=0;\n    ll mn=inf;\n    for(int i=1,now=0;i<=n;i++){\n        while(t<=2*(a[i]-a[now+1]))\n        {\n            mn=min(mn,dp[now]-2*a[now+1]);\n            now++;\n        }\n        dp[i]=dp[now]+t;\n        dp[i]=min(dp[i],mn+2*a[i]);\n \n    }\n    cout<<e+dp[n]<<endl;\n    return 0;\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define INF (1LL << 60)\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nset<LL> st1;\nset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] + t);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define INF 1000000000000000000LL\nusing namespace std;\ntypedef long long LL;\nLL p[MAXN+5];\nLL dp[MAXN+5];\nint N;\nLL M;\nLL T;\nvoid Init()\n{\n\tmemset(dp,-1,sizeof(dp));\n}\nLL GetVal(int i,int j)\n{\n\treturn dp[j-1]+T-2LL*(p[i]-p[j])+3LL*(p[i]-p[j])+p[j]-p[j-1];\n}\nint main()\n{\n//\tfreopen(\"computer.in\",\"r\",stdin);\n//\tfreopen(\"computer.out\",\"w\",stdout);\n\tInit();\n\tdp[0]=0;\n\tscanf(\"%d %lld %lld\",&N,&M,&T);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%lld\",&p[i]);\n\tLL minval=INF;\n\tint pn=-1;\n\tdp[0]=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint pos=lower_bound(p+1,p+1+N,p[i]-T/2)-p;\n\t\tif(2*(p[i]-p[pos])==T)\n\t\t\tpos++;\n\t\tif(2*(p[i]-p[pos-1])>=T)\n\t\t\twhile(pn<pos-1)\n\t\t\t{\n\t\t\t\tpn++;\n\t\t\t\tif(pn!=0)\tminval=min(dp[pn-1]-2LL*p[pn]-p[pn-1],minval);\n\t\t\t\telse\t\tminval=min(-3LL*p[pn],minval);\n\t\t\t}\n\t\tdp[i]=GetVal(i,pos);\n\t\tdp[i]=min(dp[i],minval+3LL*p[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[N]+M-p[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <numeric>\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 1e5 + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nll gcd(ll a, ll b) {return !b ? a : gcd(b, a % b);}\nll sq(ll x) {return (x * x) % MOD;}\nll modP(ll a, ll b) {return (!b ? 1 : (sq(modP(a, b / 2)) * (b % 2 ? a : 1)) % MOD);}\n\nll n, dp[maxN], x[maxN];\n\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll e, t; cin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) cin >> x[i];\n\tdp[0] = 0;\n\tint it = 0;\n\tll ans = INF;\n\tfor (int i = 1; i <= n; i++){\n\t\twhile (2 * x[it + 1] < 2 * x[i] - t){\n\t\t\tans = min(ans, dp[it] - 2 * x[++it]);\n\t\t}\n\t\tdp[i] = min(ans + 2 * x[i], dp[it] + t);\n\t}\n\tcout << e + dp[n] << endl;\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nnamespace a{\n\tusing ll = long long;\n\n\tstruct ll_it : iterator<random_access_iterator_tag, ll, ll, ll*, ll&> {\n\t\tll x;\n\t\tll_it(){}\n\t\tll_it(const ll xx): x(xx){}\n\t\tll_it& operator+=(const ll y){\n\t\t\tx += y;\n\t\t\treturn *this; }\n\t\tll operator-(const ll_it& rhs){\n\t\t\treturn x - rhs.x; }\n\t\tll_it& operator++(){\n\t\t\t++x;\n\t\t\treturn *this; }\n\t\tll operator*(){\n\t\t\treturn x; } };\n\n\tvector<vector<int>> fii;\n\tvector<int> father;\n\tvector<map<int, ll>> dist;\n\n\tvector<vector<array<ll, 2>>> posibilitati;\n\n\tvoid remove_stupidity(vector<array<ll, 2>>& v){\n\t\tif(v.empty()) return;\n\t\tint i0 = 0;\n\t\tfor(int i = 1; i < (int)v.size(); ++i){\n\t\t\tif(v[i0][0] < v[i][0] && v[i0][1] > v[i][1]){\n\t\t\t\tv[++i0] = v[i]; }\n\t\t\telse if(v[i0][0] == v[i][0] && v[i0][1] > v[i][1]){\n\t\t\t\tv[i0] = v[i]; } }\n\n\t\tv.erase(begin(v) + i0 + 1, end(v)); }\n\n\tvoid dfs(const int cur, const ll maxlen){\n\t\tposibilitati[cur].clear();\n\n\t\tif(fii[cur].empty()){\n\t\t\tposibilitati[cur] = vector<array<ll, 2>> { array<ll, 2> { 0, 0 }};\n\t\t\treturn; }\n\n\t\tdfs(fii[cur][0], maxlen), dfs(fii[cur][1], maxlen);\n\t\tif(posibilitati[fii[cur][0]].empty() || posibilitati[fii[cur][1]].empty()) return;\n\n\t\tconst ll ca = dist[cur][fii[cur][0]],\n\t\t\t  cb = dist[cur][fii[cur][1]];\n\n\t\tauto it = --end(posibilitati[fii[cur][1]]);\n\t\tvector<array<ll, 2>> tmpa, tmpb;\n\t\tfor(const auto& pa : posibilitati[fii[cur][0]]){\n\t\t\twhile(it > begin(posibilitati[fii[cur][1]]) && ca + cb + pa[0] + (*it)[0] > maxlen){\n\t\t\t\t--it; }\n\t\t\tif(ca + cb + pa[0] + (*it)[0] <= maxlen){\n\t\t\t\ttmpa.push_back(array<ll, 2> { pa[1]    + ca, (*it)[1] + cb });\n\t\t\t\tif(pa[1] + ca != (*it)[1] + cb) tmpb.push_back(array<ll, 2> { (*it)[1] + cb, pa[1]    + ca }); } }\n\t\tif(!is_sorted(begin(tmpa), end(tmpa))) reverse(begin(tmpa), end(tmpa));\n\t\tif(!is_sorted(begin(tmpb), end(tmpb))) reverse(begin(tmpb), end(tmpb));\n\n\t\tmerge(begin(tmpa), end(tmpa), begin(tmpb), end(tmpb), back_inserter(posibilitati[cur]));\n\t\tremove_stupidity(posibilitati[cur]); }\n\n\tint main(){\n\t\t//ios_base::sync_with_stdio(false);\n\n\t\tfii.resize(n);\n\t\tfather.resize(n);\n\t\tdist.resize(n);\n\t\tposibilitati.resize(n);\n\n\t\tfor(int i = 1, x, y; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\t--x;\n\t\t\tfii[x].push_back(i);\n\t\t\tfather[i] = x;\n\t\t\tdist[x][i] = y; }\n\n\t\tcout << *partition_point(ll_it(0), ll_it( 131072ll * 131072ll * 2ll),\n\t\t\t[](const ll val){\n\t\t\t\tdfs(0, val);\n\t\t\t\treturn posibilitati[0].empty(); }) << endl;\n\t\treturn 0; } }\n\nnamespace b{\n    using ll = long long;\n     \n    struct ll_it : iterator<random_access_iterator_tag, ll, ll, ll*, ll&> {\n    \tll x;\n    \tll_it(){}\n    \tll_it(const ll xx): x(xx){}\n    \tll_it& operator+=(const ll y){\n    \t\tx += y;\n    \t\treturn *this; }\n    \tll operator-(const ll_it& rhs){\n    \t\treturn x - rhs.x; }\n    \tll_it& operator++(){\n    \t\t++x;\n    \t\treturn *this; }\n    \tll operator*(){\n    \t\treturn x; } };\n     \n    vector<vector<int>> fii;\n    vector<int> father;\n    vector<map<int, ll>> dist;\n     \n    vector<vector<array<ll, 2>>> posibilitati;\n     \n    void dfs(const int cur, const ll maxlen){\n    \tif(fii[cur].empty()){\n    \t\tposibilitati[cur].push_back(array<ll, 2> { 0, 0 });\n    \t\treturn; }\n     \n    \tdfs(fii[cur][0], maxlen), dfs(fii[cur][1], maxlen);\n     \n    \tif(posibilitati[fii[cur][0]].empty() || posibilitati[fii[cur][1]].empty()){\n    \t\treturn; }\n     \n    \tconst ll ca = dist[cur][fii[cur][0]],\n    \t\t  cb = dist[cur][fii[cur][1]];\n     \n    \tfor(const auto& pa : posibilitati[fii[cur][0]]){\n    \t\tfor(const auto& pb : posibilitati[fii[cur][1]]){\n     \n    \t\t\tif(ca + cb + pa[0] + pb[0] <= maxlen){\n    \t\t\t\tposibilitati[cur].push_back(array<ll, 2> { ca + pa[1], cb + pb[1] });\n    \t\t\t\tposibilitati[cur].push_back(array<ll, 2> { cb + pb[1], ca + pa[1] }); } } }\n    \tif(posibilitati[cur].empty()) return;\n     \n    \tsort(begin(posibilitati[cur]), end(posibilitati[cur]));\n     \n    \tint i0 = 0;\n    \tfor(int i = 1; i < (int)posibilitati[cur].size(); ++i){\n    \t\tif(posibilitati[cur][i0][1] > posibilitati[cur][i][1]){\n    \t\t\tposibilitati[cur][++i0] = posibilitati[cur][i]; } }\n     \n    \tposibilitati[cur].erase(begin(posibilitati[cur]) + i0 + 1, end(posibilitati[cur])); }\n     \n    int main(){\n    \t//ios_base::sync_with_stdio(false);\n    \tfii.resize(n);\n    \tfather.resize(n);\n    \tdist.resize(n);\n    \tposibilitati.resize(n);\n     \n    \tfor(int i = 1, x, y; i < n; ++i){\n    \t\tcin >> x >> y;\n    \t\t--x;\n    \t\tfii[x].push_back(i);\n    \t\tfather[i] = x;\n    \t\tdist[x][i] = y; }\n     \n    \tcout << *partition_point(ll_it(0), ll_it( 131072ll * 131072ll * 2ll),\n    \t\t[](const ll val){\n    \t\t\tfor(auto& x : posibilitati) x.clear();\n    \t\t\tdfs(0, val);\n    \t\t\treturn posibilitati[0].empty(); }) << endl;\n    \treturn 0; } }\n\nint main(){\n\tcin >> n;\n\tif(n >= 30000){ a::main(); }\n\telse{ b::main(); }\n\treturn 0; }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll x[111111];\nll dp[111111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll lmin=ll(1e18); \n\tdeque<pair<ll,ll> > rmin;\n\tint n; cin>>n; ll e,t; cin>>e>>t;\n\tx[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>x[i];\n\t}\n\tint ptr=1;\n\trmin.pb(mp(dp[0]-x[0]+t,1));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(ptr<=i&&x[i]>=t/2+x[ptr]+1)\n\t\t{\n\t\t\tif(!rmin.empty()&&rmin.front().se==ptr) rmin.pop_front();\n\t\t\tlmin = min(lmin, dp[ptr-1]-2*x[ptr]-x[ptr-1]);\n\t\t\tptr++;\n\t\t}\n\t\tll best=lmin;\n\t\tif(!rmin.empty()) best=min(best,-2*x[i]+rmin.front().fi);\n\t\tdp[i]=best+3LL*x[i];\n\t\tll cost = dp[i]-x[i]+t;\n\t\twhile(!rmin.empty()&&rmin.back().fi>=cost) rmin.pop_back();\n\t\trmin.pb(mp(cost,i+1));\n\t}\n\tcout<<dp[n]+e-x[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tll E,T;\n\tcin>>E>>T;\n\tvint v(n);\n\trep(i,n) cin>>v[i];\n\tv.PB(E);\n\tn++;\n\tvll dp(n,INFL);\n\tdp[0]=0;\n\trep(i,n-1){\n\t\tint it = upper_bound(ALL(v), v[i]+T/2)-v.begin();\n\t\tit--;\n\t\tmins(dp[min(it+1,n-1)],dp[i]+T);\n\t\tint p = it+2;\n\t\twhile(p<n){\n\t\t\tif(dp[p]<=dp[i]+2*(v[p-1]-v[i])) break;\n\t\t\tdp[p]=dp[i]+2*(v[p-1]-v[i]);\n\t\t\tp++;\n\t\t}\n\t\t// reep(j,i+1,n+1){\n\t\t// \tif(2*(v[j-1]-v[i])<=T){\n\t\t// \t\tmins(dp[j],dp[i]+T);\n\t\t// \t}\n\t\t// \telse{\n\t\t// \t\tmins(dp[j],dp[i]+2*(v[j-1]-v[i]));\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<dp[n-1]+E<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  long long int N, E, T, tot = 0;\n  cin >> N >> E >> T;\n  long long int x[N];\n\n  for(int i; i<N; i++){\n    tot += min(2*T+x[i+1]-x[i], 2*(x[i+1]-x[i])+ max(0, T-(x[i+1]-x[i])) + max(0, T-2*(x[i+1]-x[i]));\n  }\n  tot+=x[0]+(E-x[N-1]);\n\n  cout << tot << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<unordered_map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nconst ll inf = (1LL<<62) - 1 + (1LL<<62);\n\nint n,e,t,p[maxn],ti[maxn];\nll f[maxn];\n\nstruct ST {\n    int l,r;\n    ll val[2];\n} st[maxn*3];\nvoid build(int id,int l,int r) {\n    st[id].l=l,st[id].r=r,st[id].val[0]=st[id].val[1]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(id<<1,l,m);\n    build(id<<1|1,m+1,r);\n}\nvoid update(int id,int pos,int sign,ll val) {\n    if(st[id].l==st[id].r) {\n        st[id].val[sign]=val;\n        return;\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(pos<=m)update(id<<1,pos,sign,val);\n    else update(id<<1|1,pos,sign,val);\n    st[id].val[sign]=min(st[id<<1].val[sign],st[id<<1|1].val[sign]);\n}\nll query(int id,int l,int r,int sign) {\n    if(st[id].l==l&&st[id].r==r) {\n        return st[id].val[sign];\n    }\n    int m=(st[id].l+st[id].r)>>1;\n    if(r<=m)return query(id<<1,l,r,sign);\n    else if(l>m)return query(id<<1|1,l,r,sign);\n    else {\n        return min(query(id<<1,l,m,sign),query(id<<1|1,m+1,r,sign));\n    }\n}\n\nint main() {\n   // freopen(\"in.cpp\",\"r\",stdin);\n    cin>>n>>e>>t;\n    for(int i=1; i<=n; i++)cin>>p[i];\n    build(1,1,n);\n    for(int i=1; i<=n; i++) {\n        f[i]=max((p[i]-p[1])*2,t)+(ll)p[i];\n        int l=1,r=i-1,ret=-1;\n        while(l<=r) {\n            int mid = (l+r)>>1;\n            if((p[i]-p[mid+1])*2<=t) {\n                ret=mid;\n                r=mid-1;\n            } else l=mid+1;\n        }\n        ll tt=-1;\n        if(ret!=-1) {\n            ll tmp=query(1,ret,i-1,1) + p[i];\n            tt = tmp;\n            if(ret>1) {\n                tmp=min(tmp,query(1,1,ret-1,0)+3*p[i]);\n                tt = tmp;\n            }\n        } else {\n            if(1<=i-1)\n                tt = query(1,1,i-1,0)+3*p[i];\n        }\n        if(tt!=-1)f[i]=min(f[i],tt);\n        if(i<n) {\n            update(1,i,0,f[i]-2*p[i+1]-p[i]);\n            update(1,i,1,f[i]+t-p[i]);\n        }\n    }\n    cout<<f[n]+e-p[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, E, T;\n    cin >> n >> E >> T;\n\n    vector<int> X(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> X[i];\n    }\n\n    vector<int64_t> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 1LL << 62;\n        for (int j = i - 1; j >= 0; --j) {\n            dp[i] = min(dp[i], dp[j] + X[j + 1] - X[j] + \n                    3LL * (X[i] - X[j + 1]) + max((int64_t) 0, (int64_t) (T - 2LL * (X[i] - X[j + 1]))));\n        }\n    }\n    int64_t ans = dp[n] + E - X[n];\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n#define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 100010;\n\nll N, T, E;\nll X[maxn];\nll dp[maxn], pmn[maxn];\n\nvoid MAIN() {\n\n    cin >> N >> E >> T;\n    fori (i, N) cin >> X[i + 1];\n    dp[N] = E - X[N];\n    pmn[N] = dp[N] + X[N] * 3;\n    pmn[N + 1] = BIG;\n    ll ptr = N;\n    forir (i, N) {\n        while ((X[ptr] - X[i + 1]) * 2 > T) --ptr;\n        dp[i] = T + dp[ptr];\n        smin(dp[i], pmn[ptr + 1] - X[i + 1] * 3);\n        dp[i] += X[i + 1] - X[i];\n        pmn[i] = min(pmn[i + 1], dp[i] + X[i] * 3);\n    }\n    cout << dp[0] << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n3 9 3\n1 3 8\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <climits>\nconst int MAX_N = 100005;\nuint32_t cache[MAX_N];\nint bpos[MAX_N];\nint N, E, T;\n\nint main() {\n  scanf(\"%d %d %d\", &N, &E, &T);\n  bpos[0] = 0;\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", bpos + i + 1);\n    cache[i + 1] = UINT_MAX;\n  }\n  for (int i = 0; i < N; ++i) {\n    cache[i + 1] = std::min(cache[i + 1], cache[i] + bpos[i + 1] - bpos[i] + T);\n    for (int j = i + 2; j <= N; ++j) {\n      uint32_t d = bpos[j] - bpos[i + 1];\n      uint32_t d2 = bpos[j] - bpos[j - 1];\n      uint32_t cost = bpos[i + 1] - bpos[i] + 3 * d + std::max(0LL, uint32_t(T) - 2LL * d2) + cache[i];\n      if (cost >= cache[j]) break;\n      cache[j] = std::min(cache[j], cost);\n    }\n  }\n  printf(\"%u\\n\", cache[N] + E - bpos[N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nLL f[100005], g[100005];\nint x[100005], n, t, e;\nmultiset<LL> S;\nint main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tmemset(g, 0x3f, sizeof(g));\n\tf[0] = 0;\n\tg[0] = 0;\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\trep(i, 1, n) scanf(\"%d\", &x[i]);\n\tint k = 0;\n\tLL ZY = f[n];\n\tS.insert(0);\n\trep(i, 1, n) {\n\t\twhile((x[i] - x[k + 1]) * 2 > t) {\n\t\t\tS.erase(S.find(f[k]));\n\t\t\tZY = min(ZY, f[k] - x[k + 1] * 2);\n\t\t\t++k;\n\t\t}\n\t\tf[i] = min(f[i], ZY + x[i] * 2);\n\t\tif(S.size()) f[i] = min(f[i], (*S.begin()) + t);\n//\t\trop(j, 0, i) {\n//\t\t\tf[i] = min(f[i], f[j] + max((x[i] - x[j + 1]) * 2, t));\n//\t\t}\n\t\tS.insert(f[i]);\n\t}\n\tcout << f[n] + e << endl;\n//\trop(i, 0, n) { \n//\t\trep(j, i + 1, n) {\n//\t\t\tg[j] = min(g[j], g[i] + max((x[j] - x[i + 1]) * 2, t));\n//\t\t}\n//\t}\n//\tcout << g[n] + e << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//sobskdrbhvk\n//remember the flying, the bird dies ):(\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\n\n#define PB push_back\n#define MP make_pair\n#define L first\n#define R second\n#define sz(x) ((int)(x).size())\n#define smax(x, y) ((x) = max((x), (y)))\n#define smin(x, y) ((x) = min((x), (y)))\n#define all(x) x.begin(),x.end()\n\nconst int maxn = 1e5 + 85 - 69;\nconst LL Inf = 1e18;\nint mn[maxn],\n\ta[maxn],\n\tn, E, T;\nLL dp[maxn];\ndeque<int> dq;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\ta[n + 1] = E;\n\tint ptr = 1;\n\tdq.push_front(0);\n\tfor(int i = 1; i <= n; i++){\n\t\twhile(2 * (a[i] - a[ptr]) > T) ptr++;\n\t\twhile(sz(dq) and dq.back() + 1 < ptr) dq.pop_back();\n\t\tdp[i] = Inf;\n\t\tif(sz(dq))\n\t\t\tdp[i] = dp[dq.back()] + (a[i] - a[dq.back()]) + T;\n\t\tif(ptr >= 2)\n\t\t\tsmin(dp[i], dp[mn[ptr - 2]] + 2 * (a[i] - a[mn[ptr - 2] + 1]) + a[i] - a[mn[ptr - 2]]);\n\t\twhile(sz(dq) and dp[i] - a[i + 1] <= dp[dq.front()] - a[dq.front() + 1])\n\t\t\tdq.pop_front();\n\t\tdq.push_front(i);\n\t\tmn[i] = mn[i - 1];\n\t\tif(dp[i] - 3 * a[i + 1] < dp[mn[i]] - 3 * a[mn[i] + 1])\n\t\t\tmn[i] = i;\n\t}\n\tcout << dp[n] + E - a[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<sstream>\n#include<cstdlib>\n#include<ctime>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<fstream>\n#define ld double\n#define ull unsigned long long \n#define ll long long \n#define pii pair<int,int >\n#define iiii pair<int,pii >\n#define mp make_pair \n#define INF 1000000000\n#define inf 10000000000000000ll\n#define MOD 1000000007 \n#define MAXN 100100\nusing namespace std;\n\nint n,e,t,a[MAXN];\nll Dp[MAXN];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\t\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\t\n\tDp[0]=0;\n\tDp[1]=(ll)(a[1])+t;\n\tfor(int i=2;i<=n;i++)Dp[i]=inf;\n\t\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tDp[i]=min(Dp[i],Dp[j]+(ll)(a[i]-a[j])+max((a[i]-a[j+1])*2,t));\n\t\t}\n\n\tll res=Dp[n]+(ll)(e)-a[n];\n\t\n\tprintf(\"%lld\\n\",res);\n\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define SZ(a) (int)((a).size())\n\nconst int MAXN = 100007;\n\nLL A[MAXN], DP[MAXN];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tFOR(i, 1, n + 1)\n\t\tcin >> A[i];\n\tFOR(i, 1, n + 1)\n\t{\n\t\tint l = 0, r = i - 1, m;\n\t\twhile (r - l)\n\t\t{\n\t\t\tm = (l + r) / 2;\n\t\t\tif (DP[m] - A[m] + max(t - 2 * A[i], -2 * A[m + 1]) < \n\t\t\t\tDP[m + 1] - A[m + 1] + max(t - 2 * A[i], -2 * A[m + 2]))\n\t\t\t\tr = m;\n\t\t\telse l = m + 1;\n\t\t}\n\t\tDP[i] = 3 * A[i] + DP[l] - A[l] + max(t - 2 * A[i], -2 * A[l + 1]);\n\t}\n\tcout << DP[n] + e - A[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long LL;\nconst int maxn = 1e5 + 20;\n\nint N, E, T;\nint x[maxn];\nLL f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tLL pmin = 1ll << 60;\n\t\n\tfor(int i = 1, p = 1; i <= N; i++)\n\t{\n\t\twhile(p <= N && (x[i] - x[p]) * 2 > T)\n\t\t{\n\t\t\tpmin = std::min(pmin, f[p - 1] - 2 * x[p]);\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tf[i] = f[i - 1] + T;\n\t\tf[i] = std::min(f[i], f[p - 1] + T);\n\t\tf[i] = std::min(f[i], pmin + 2 * x[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[N] + E);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n    #include <iostream>\n    #include <algorithm>\n    #include <cstring>\n    #include <set>\n    #define N 100010\n    #define INF (1LL << 60)\n    #define LL long long\n    using namespace std;\n    int n, e, t, x[N];\n    LL dp[N], preMin[N];\n    multiset<LL> st;\n     \n    int main() {\n    \tscanf(\"%d%d%d\", &n, &e, &t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\tscanf(\"%d\", &x[i]);\n    \t}\n    \t\n    \tdp[0] = 0;\n    \tx[0] = 0;\n    \tint last = 0;\n    \tpreMin[0] = - 2 * x[1];\n    \tst.insert(t);\n    \tfor (int i = 1; i <= n; ++i) {\n    \t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n    \t\t\tst.erase(dp[last] - x[last] + t);\n    \t\t\t++last;\n    \t\t}\n\t\t\tdp[i] = (((LL)1)<<50);\n\t\t\tif(last - 1 >= 0) dp[i] = min(dp[i], preMin[last - 1] + 3LL * x[i]);\n\t\t\tif(!st.empty()) dp[i] = min(dp[i], *st.begin() + x[i]);\n    \t\t//if (last - 1 >= 0) dp[i] = min(preMin[last - 1] + 3LL * x[i], *st.begin() + x[i]);\n    \t\t//else dp[i] = *st.begin() + x[i];\n    //cout << last << ' ' << preMin[last - 1] << ' ' << *st.begin() << ' ' << dp[i] << endl;\n    \t\tif (i < n) st.insert(dp[i] - x[i] + t);\n    \t\tpreMin[i] = min(dp[i] - x[i] - 2LL * x[i + 1], preMin[i - 1]);\n    //cout << dp[i] << ' ';\n    \t}\n    //cout << endl;\n    \t\n    \tprintf(\"%lld\\n\", dp[n] + e - x[n]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\nconst LL INF = 1e18;\n\nLL f[N];\nint x[N];\nint n, T, E;\n\nLL calc(int j, int i) {\n\tLL ret = x[i] - x[j + 1] + f[j];\n\tret += max(x[i] - x[j] + x[i] - x[j + 1], x[j + 1] - x[j] + T);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\tfor (int j = max(0, i - 150000000 / n); j < i; j++) {\n\t\t\tf[i] = min(f[i], calc(j, i));\t\t\n\t\t}\n\t}\n\tcout << f[n] + E - x[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,e;\nll t;\nint x[252521];\n\nll dp[252521];\nconstexpr ll INF = 1e18;\n\ninline ll calc(int i,int j){\n  return dp[j+1] + max(t,2*(ll)(x[j]-x[i]));\n}\n\nstruct RMQ{\n  int n;\n  vl dat;\n  RMQ(int _n){\n    n=1;\n    while(n<_n)n<<=1;\n    dat.assign(2*n,INF);\n  }\n  void set(int x,int v){\n    x += n-1;\n    dat[x] = v;\n    while(x!=0){\n      x = (x-1)/2;\n      dat[x] = min(dat[2*x+1],dat[2*x+2]);\n    }\n  }\n  ll qmin(int l,int r,int a,int b,int k){\n    if(r<=a || b<=l)return INF;\n    if(l<=a && b<=r){\n      return dat[k];\n    }else{\n      int m = (a+b)/2;\n      return min(qmin(l,r,a,m,2*k+1),qmin(l,r,m,b,2*k+2));\n    }\n  }\n  ll qmin(int l,int r){\n    return qmin(l,r,0,n,0);\n  }\n};\n\nint main(){\n  scanf(\"%d%d%lld\",&n,&e,&t);\n  REP(i,n)scanf(\"%d\",x+i);\n  x[n] = e;\n  REP(i,n)dp[i] = -1;\n  dp[n] = 0;\n  // sum of len\n  ll ans = e;\n  RMQ aa(n),bb(n);\n  // calc dp[i] from n-1 to 0\n  FORR(i,0,n){\n    aa.set(i,2ll*x[i]+dp[i+1]);\n    bb.set(i,t       +dp[i+1]);\n    // find m s.t. 2dij<t\n    int m = upper_bound(x+i,x+n+1,(ll)(t+2ll*x[i])/2ll) - x;\n    m--;\n    ll xx = aa.qmin(m+1,n) - 2ll*x[i];\n    ll yy = bb.qmin(0,m+1);\n    dp[i] = min(xx,yy);\n  }\n  printf(\"%lld\\n\",ans+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[i] = min(dp[j] + cost(i , j);\n                #include <iostream>\n#include <istream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n//#include <unordered_map>\n#include <cstring>\n#include <string.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <list>\n#include <sstream>\n//#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst ll LINF = INF * (ll) INF;\nll dp[100001];\nint N , E , T;\nint a[100001];\nint opt = 0;\nll cost(int i , int opt)\n{\n\tll prev = 0;\n\tif(opt - 1 >= 0)\n\t\tprev = dp[opt - 1];\n\tll cur = (a[i] - a[opt]) * 2;\n\tif(T > (a[i] - a[opt]) * 2)\n\t{\n\t\tcur = T + (a[i] - a[opt]);\n\t}\n\treturn prev + cur;\n}\nint main()\n{\n\tscanf(\"%d %d %d\" , &N , &E , &T);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\" , &a[i]);\n\t}\n\tdp[0] = T;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\t/*while(opt + 1 < i)\n\t\t{\n\t\t\tif(cost(i , opt + 1) <= cost(i , opt))\n\t\t\t{\n\t\t\t\topt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}*/\n\t\tdp[i] = LINF;\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tdp[i] = min(dp[i] , cost(i , j));\n\t}\n\tcout << dp[N - 1] + E;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,e,t,x[100005];\nll dp[100005];\nint main(){\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for (int i = 1 ; i <= n; i++){\n        scanf(\"%d\",&x[i]);\n    }\n    int pivot = 0;\n    ll mn = 1000000000000000000;\n    for (int i = 1; i <= n; i++){\n        dp[i] = 1000000000000000000;\n        while (pivot < i && 2*(x[i]-x[pivot+1]) > t) {\n            mn = min(mn,dp[pivot]-2*x[pivot+1]);\n            pivot++;\n        }\n        dp[i] = min(2*x[i]+mn,dp[pivot]+t);\n    }\n    printf(\"%lld\",dp[n]+e);\n}\n"
  },
  {
    "language": "C++",
    "code": "//漸化式を場合分けして定数を前に出す機械的な式変形\n#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int INF = 1145141919893810;\n\nint n, e, t;\nint x[100001];\t\t//1-indexed, x[0] = 0\nint dp[100001];\t\t//dp[i]  = 左からi個を回収するのにかかる時間の最小値 - x[i], Xiのコインは既に回収済み\nint dp2[100001];\t//dp2[i] = min(dp[j] - 2 * x[j + 1]) (j <= i)\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> e >> t;\n\tx[0] = 0;\n\tfor (i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor (i = 0; i <= n; i++) dp[i] = INF;\n\tfor (i = 0; i <= n; i++) dp2[i] = INF;\n\tdp[0] = 0;\n\tdp2[0] = dp[0] - 2 * x[1];\n\t\n\tj = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\t//2 * (x[i] - x[j + 1]) <= tとなる最小のjを求める (X_j -> X_j+1 -> X_i -> X_j+1 -> Wait -> X_j+1 -> X_i)\n\t\tfor (; 2 * (x[i] - x[j + 1]) > t; j++);\n\t\tdp[i] = min(dp[i], t + dp[j]);\n\t\t\n\t\t//2 * (x[i] - x[j + 1]) > tとなるj(小さい)について\n\t\tif (j > 0) dp[i] = min(dp[i], dp2[j - 1] + 2 * x[i]);\n\t\tdp2[i] = min(dp2[i - 1], dp[i] - 2 * x[i]);\n\t}\n\t\n\tcout << dp[n] + e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N, E, T; cin >> N >> E >> T;\n\n    auto bears = vector<ll>(N+1);\n    for (auto i = 1; i <= N; i++) cin >> bears[i];\n\n    auto best = vector<ll>(N+1);\n    best[0] = 0;\n\n    for (auto i = 1; i <= N; i++)\n    {\n        best[i] = numeric_limits<ll>::max();\n        for (auto j = 0; j < i; j++)\n        {\n            auto option = best[j] + (bears[i] - bears[j]) + (bears[i] - bears[j+1]);\n            if (2*(bears[i]-bears[j+1]) < T) option += T - 2*(bears[i]-bears[j+1]);\n            option += bears[i] - bears[j+1];\n\n            best[i] = min(best[i], option);\n        }\n    }\n\n    cout << best[N] + (E-bears[N]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define all(c) c.begin(), c.end()\n#define gmax(x,y) x=max(x,y)\n#define gmin(x,y) x=min(x,y)\n#define gadd(x,y) x=add(x,y)\n#define gmul(x,y) x=mul(x,y)\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int N = 1e5 + 5;\nconst ll inf = 1e15;\nll dp[N];\n\nint main(){\n\tcin.tie(0);\n\tcout.tie(0);\n\tios_base::sync_with_stdio(0);\n\tll n,e,t;\n\tcin >> n >> e >> t;\t\n\tvector<ll> pos(n+1);\n\trep(i,0,n)cin >> pos[i];\n\tpos[n] = pos[n-1];\n\tll best = inf;\n\tint jp = n - 1;\n\tfor(int i = n - 1;i >= 0; --i){\n\t\tif(pos[n-1] - pos[i] <= t/2){\n\t\t\tdp[i] = t + pos[n-1] - pos[i];\n\t\t}\n\t\telse{\n\t\t\tif(i < n-1)best += 3 * (pos[i+1] - pos[i]);\n\t\t\twhile(jp >= 0 && pos[jp] - pos[i] >= (t+1)/2){\n\t\t\t\tgmin(best, 3 * (pos[jp] - pos[i]) + pos[jp+1] - pos[jp] + dp[jp+1]);\n\t\t\t\t--jp;\n\t\t\t}\n\t\t\tdp[i] = best;\n\t\t\tgmin(dp[i], t + pos[jp+1] - pos[i] + dp[jp+1]);\n\t\t}\n\t}\n\tcout << dp[0] + pos[0] + e - pos[n-1] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,E,T,t,a[100005],f[100005],M=1LL<<60;int main(){scanf(\"%lld%lld%lld\",&n,&E,&T);for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);for(int i=1;i<=n;i++){for (;T<=2*(a[i]-a[t+1]);t++)M=min(M,f[t]-2*a[t+1]);f[i]=min(f[t]+T,M+2*a[i]);}printf(\"%lld\",E+f[n]);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    dp[1] = T;\n    for (ll i = 2, j = 0, k = INF; i <= N;) {\n        ll L = max(2 * (X[i] - X[j + 1]), T);\n        if (L == T) {\n            dp[i] = min(dp[j] + T, k);\n            i++;\n        } else {\n            ll dpj = dp[j] + L;\n            if (dpj < k) {\n                k = dpj;\n            }\n            j++;\n        }\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nint n, e, T, q[N], h, t;\nusing ll = long long;\nll f[N], a[N], p[N], d[N];\n\nint main () {\n\tscanf(\"%d%d%d\", &n, &e, &T); p[0] = -0x3f3f3f3f3f3f3f3f;\n\tfor (int i = h = 1, k = 0; i <= n; ++i) {\n\t\tscanf(\"%lld\", &a[i]); f[i] = 0x3f3f3f3f3f3f3f3f;\n\t\td[i] = f[i - 1] - a[i - 1];\n\t\twhile (h <= t && d[i] < d[q[t]]) --t; q[++t] = i;\n\t\twhile (2 * (a[i] - a[k]) > T) if (q[h] == k++) ++h;\n\t\tf[i] = min(f[i], T + a[i] + d[q[h]]);\n\t\tif (k > 1) f[i] = min(f[i], 3ll * a[i] - p[k - 1]);\n\t\tp[i] = max(p[i - 1], 2ll * a[i] + a[i - 1] - f[i - 1]);\n\t}\n\tprintf(\"%lld\\n\", f[n] + e - a[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[100005];\nint n,e,t;\nint x[100005];\nsigned main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tmemset(dp,inf,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+max(3*(x[i]-x[j]),x[i]-x[j]+t));\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++)cerr<<i<<\" \"<<dp[i]<<endl;\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    i64 g, t; cin >> g >> t;\n    vector<i64> a(n);\n    for(auto& x : a) cin >> x;\n    vector<i64> dp(n + 1, 1e18), dp2(n + 1, 1e18);\n    dp[0] = 0LL;\n    int j = 0;\n    for(int i : in(n)) {\n        while(j < i && t <= 2LL * (a[i] - a[j])) ++j;\n        dp[i + 1] = min(dp[i + 1], dp[j] + t);\n        if(i > 0) dp[i + 1] = min(dp[i + 1], 2 * a[i] + dp2[i - 1]);\n        dp2[i] = dp[i] - 2 * a[i];\n        if(i > 0) dp2[i] = min(dp2[i], dp2[i - 1]);\n    }\n    cout << dp[n] + g << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\t/*\n\tincID(j, m[i - 1], m[i]) {\n\t\tauto it1 = ms.find(dp[j]);\n\t\tauto it2 = it1;\n\t\tit2++;\n\t\tms.erase(it1, it2);\n\t}\n\tms.insert(dp[i - 1]);\n\t*/\n\t\n\tms.clear();\n\tincID(j, m[i], i) { ms.insert(dp[j]); }\n\treturn *(ms.rbegin());\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\nvoid debug_impl() { std::cerr << '\\n'; }\ntemplate <class Head, class... Tail>\nvoid debug_impl(Head&& head, Tail&&... tail) {\n    std::cerr << ' ' << head;\n    debug_impl(std::forward<Tail>(tail)...);\n}\n\n#define ENABLE_DEBUG\n#ifdef ENABLE_DEBUG\n#define debug(...)\\\n    do { std::cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n         debug_impl(__VA_ARGS__); std::cerr << noboolalpha; } while (false)\n#else\n#define debug(...)\n#endif\n\ntypedef long long lint;\nconstexpr lint inf = 1ll << 60;\n\nint N;\nlint T;\nlint X[100002];\nlint dp[100002];\n\ntemplate <class Mn, class Op>\nstruct segment_tree {\nprivate:\n\n    int size;\n    std::vector<Mn> node;\n    const Mn unit;\n    const Op oper;\n\npublic:\n\n    segment_tree(const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { }\n    segment_tree(const int& size_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { init(size_); }\n    segment_tree(const std::vector<Mn>& node_, const Mn& unit_, const Op& oper_) : \n        unit(unit_), oper(oper_) \n    { build(node_); }\n\n    void init(const int& size_) {\n        for(size = 1; size < size_; size <<= 1);\n        node.assign(size << 1, unit);\n    }\n\n    void build(const std::vector<Mn>& node_) {\n        init(node_.size());\n        for (int i = 0; i < node_.size(); ++i) {\n            node[i + size] = node_[i];\n        }\n        for (int i = size - 1; i > 0; --i) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void set_value(const int& idx, const Mn& value) {\n        int i = idx + size;\n        for (node[i] = value; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    void add_value(const int& idx, const Mn& plus) {\n        int i = idx + size;\n        for (node[i] += plus; (i >>= 1) > 0;) {\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n        }\n    }\n\n    Mn fold(const int& l, const int& r) const {\n        Mn result_l = unit, result_r = unit;\n        for(int tl = l + size, tr = r + size; tl < tr; tl >>= 1, tr >>= 1) {\n            if (tl & 1) { result_l = oper(result_l, node[tl]); ++tl; }\n            if (tr & 1) { --tr; result_r = oper(node[tr], result_r); }\n        }\n        return oper(result_l, result_r);\n    }\n\n    Mn operator [] (const int& idx) const {\n        return node[idx + size];\n    }\n\n};\n\nint main() {\n    \n    cin >> N;\n    cin >> X[N + 1] >> T;\n    rep(i, 1, N) cin >> X[i];\n\n    const auto getmin = [](const lint& x, const lint& y) { return x < y ? x : y; };\n    segment_tree<lint, decltype(getmin)> memo1(N + 1, inf, getmin), memo2(N + 1, inf, getmin);\n    memo1.set_value(0, 0);\n    memo2.set_value(0, - 2 * X[1]);\n\n    rep(i, 1, N) {\n        dp[i] = inf;\n        int l = 0, r = (X[i] - X[1]) * 2 < T ? 0 : i;\n        while(r - l > 1) {\n            int md = (l + r) / 2;\n            ((X[i] - X[md + 1]) * 2 >= T ? l : r) = md;\n        }\n        chmin(dp[i], memo1.fold(r, i) + T + X[i]);\n        chmin(dp[i], memo2.fold(0, r) + 3 * X[i]);\n        memo1.set_value(i, dp[i] - X[i]);\n        memo2.set_value(i, dp[i] - 2 * X[i + 1] - X[i]);\n    }\n    \n    cout << dp[N] + X[N + 1] - X[N] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//sobskdrbhvk\n//remember the flying, the bird dies ):(\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\n\n#define PB push_back\n#define MP make_pair\n#define L first\n#define R second\n#define sz(x) ((int)(x).size())\n#define smax(x, y) ((x) = max((x), (y)))\n#define smin(x, y) ((x) = min((x), (y)))\n#define all(x) x.begin(),x.end()\n\nconst int maxn = 1e5 + 85 - 69;\nconst LL Inf = 1e18;\nLL mn[maxn],\n\ta[maxn],\n\tn, E, T;\nLL dp[maxn];\ndeque<int> dq;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> E >> T;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\ta[n + 1] = E;\n\tint ptr = 1;\n\tdq.push_front(0);\n\tfor(int i = 1; i <= n; i++){\n\t\twhile(2 * (a[i] - a[ptr]) > T) ptr++;\n\t\twhile(sz(dq) and dq.back() + 1 < ptr) dq.pop_back();\n\t\tdp[i] = Inf;\n\t\tif(sz(dq))\n\t\t\tdp[i] = dp[dq.back()] + (a[i] - a[dq.back()]) + T;\n\t\tif(ptr >= 2)\n\t\t\tsmin(dp[i], dp[mn[ptr - 2]] + 2 * (a[i] - a[mn[ptr - 2] + 1]) + a[i] - a[mn[ptr - 2]]);\n\t\twhile(sz(dq) and dp[i] - a[i + 1] <= dp[dq.front()] - a[dq.front() + 1])\n\t\t\tdq.pop_front();\n\t\tdq.push_front(i);\n\t\tmn[i] = mn[i - 1];\n\t\tif(dp[i] - 3 * a[i + 1] < dp[mn[i]] - 3 * a[mn[i] + 1])\n\t\t\tmn[i] = i;\n\t}\n\tcout << dp[n] + E - a[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\npair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\tif(seg[id].first==0||seg[id].first>val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\nvoid update2(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2&&r-l==1){\n\tif(seg2[id].first==0||seg2[id].first>val){\n\t\tseg2[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate2(id<<1,l,mid,l2,r2,val);\nupdate2((id<<1)|1,mid,r,l2,r2,val);\nseg2[id]=min(seg2[id<<1],seg2[(id<<1)|1]);\n}\npair<long long int,int>get2(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,100000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg2[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get2(id<<1,l,mid,l2,r2),get2((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t//\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get2(1,0,n,r,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tdp[1][i]=(long long int)1e18;\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*3*(e-a[i])));\n\t\tupdate2(1,0,n,i,i+1,(long long)(dp[0][i]+1ll*2*(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] = x;\n    while(k>0) k = (k-1)/2, dat[k] = min(dat[k*2+1],dat[k*2+2]);\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return min(A, B);\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, e, t;std::cin >> n >> e >> t;\n  if(n>2000) throw runtime_error(\"error\");\n  vll x(n+1, -10000000000);re(i, n) scanf(\"%lld\", &x[i+1]);\n\n  ll INF = 1000000000000000000;\n  vll dp(n+1, INF);\n  dp[0] = e;\n  segtree seg(n+1, INF);\n  seg.update(dp[0]-2*x[1], 0);\n\n  for(int now=1;now<=n;now++){\n    ll l = lower_bound(all(x), x[now]-t/2) - x.begin();\n\n    if(now!=1){\n      dp[now] = dp[l-1] + t;\n      dp[now] = min(dp[now], 2*x[now]+seg.query(0, l-1));\n    }else{\n      dp[now] = dp[0] + t;\n    }\n    if(now!=n) seg.update(dp[now]-2*x[now],now);\n  }\n\n  //std::cout << dp[1] << '\\n';\n  //std::cout << dp[2] << '\\n';\n  std::cout << dp[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint n,t,e,x[100111],fr,rr=1,q[100111];\nLL dp[100111],premn[100111];\n\nint main()\n{\n\tget3(n,e,t);\n\tfor(int i=1;i<=n;i++)get1(x[i]);\n\tint cur=0;\n\tpremn[0]=-2*x[1];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile((x[i]-x[cur+1])*2>t)\n\t\t{\n\t\t\tif(fr!=rr&&q[fr]==cur)fr++;\n\t\t\tcur++;\n\t\t}\n\t\tif(cur)dp[i]=premn[cur-1]+2*x[i];else dp[i]=Linf;\n\t\tif(fr!=rr)dp[i]=min(dp[i],dp[q[fr]]+t);\n\t\twhile(fr!=rr&&dp[q[rr-1]]>dp[i])rr--;\n\t\tq[rr++]=i;\n\t\tpremn[i]=min(premn[i-1],dp[i]-2*x[i+1]);\n\t}\n\tprintendl(dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll ;\nconst int maxn = 1e5 + 10 ;\nint x[maxn] ;\nll dp[maxn] ;\nint main() {\n\tint n, e, t ;\n\tscanf(\"%d%d%d\", &n, &e, &t) ;\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf(\"%d\", &x[i]) ;\n\tmemset (dp, 0x3f, sizeof dp) ;\n\tdp[0] = 0 ;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < i; j ++) {\n\t\t\tdp[i] = min (dp[i], x[j + 1] - x[j] + dp[j] + max (3ll * (x[i] - x[j + 1]), 1ll * x[i] - x[j + 1] + t)) ;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n] + e - x[n]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n//  RMQ\ntemplate<class T>\nclass RMQ\n{\n    int n;\n    vector<T> A;\n\n    T q(int l, int r)\n    {\n        T a = min(A[l], A[r-1]);\n        if ((l+1)/2 < r/2)\n            a = min(a, q((l+1)/2, r/2));\n        return a;\n    }\n\npublic:\n    RMQ(int n_)\n    {\n        n = 1;\n        while (n < n_)\n            n *= 2;\n        A = vector<T>(2*n, numeric_limits<T>::max());\n    }\n\n    void set(int i, T v)\n    {\n        A[i+n] = v;\n        for (int p=(i+n)/2; p>0; p/=2)\n            A[p] = min(A[2*p], A[2*p+1]);\n    }\n\n    T query(int l, int r)\n    {\n        return q(l+n, r+n);\n    }\n};\n\nint main()\n{\n    int N, E, T;\n    cin>>N>>E>>T;\n    vector<int> x(N);\n    for (int &t: x)\n        cin>>t;\n\n    vector<long long> A(N);\n    A[0] = x[0]+T;\n\n    RMQ<long long> Q1(N);   //  A[j-1]-x[j-1]-2*x[j]\n    RMQ<long long> Q2(N);   //  A[j-1]-x[j-1]\n \n    for (int i=1; i<N; i++)\n    {\n        A[i] = A[i-1]+(x[i]-x[i-1])+T;\n        A[i] = min(A[i], 0LL+x[0]+(x[i]-x[0])*3+max(0, T-(x[i]-x[0])*2));\n\n        int l = 0;\n        int r = i+1;\n        while (l+1<r)\n        {\n            int m = (l+r)/2;\n            if ((x[i]-x[m])*2 > T)\n                l = m;\n            else\n                r = m;\n        }\n\n        if (1<l+1)\n            A[i] = min(A[i], 3*x[i] + Q1.query(1, l+1));\n        if (l+1<i)\n            A[i] = min(A[i], T+x[i] + Q2.query(l+1, i));\n\n        Q1.set(i, A[i-1]-x[i-1]-2*x[i]);\n        Q2.set(i, A[i-1]-x[i-1]);\n    }\n \n    cout<<A[N-1]+E-x[N-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\nstruct segtree{\n    static const int SEG=1<<17;\n    vint dat;\n    segtree():dat(SEG*2){}\n    void update(int k,int x){\n        k+=SEG-1;\n        dat[k]=x;\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    int query(int a,int b,int k=0,int l=0,int r=SEG){\n        if(r<=a||b<=l)return INF;\n        if(a<=l&&r<=b)return dat[k];\n        return min(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n    }\n};\n\nint N,E,T;\nint X[111111];\nint dp[111111];\nsigned main(){\n    cin>>N>>E>>T;\n    X[0]=0;\n    for(int i=1;i<=N;i++)cin>>X[i];\n\n    segtree segA;\n    segtree segB;\n    segA.update(0,-2*X[1]);\n    segB.update(0,0);\n    for(int i=1;i<=N;i++){\n        int lb=-1,ub=i;\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            if(2*(X[i]-X[mid+1])<T)ub=mid;\n            else lb=mid;\n        }\n        int val=INF;\n        if(ub)val=segA.query(0,ub)+3*X[i];\n        if(ub!=i)chmin(val,segB.query(ub,i)+T+X[i]);\n        dp[i]=val;\n        segA.update(i,val-X[i]-2*X[i+1]);\n        segB.update(i,val-X[i]);\n    }\n    cout<<dp[N]+E-X[N]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nlong long dp[maxn];\nlong long mi[maxn];\nint x[maxn];\nint q[maxn],head,tail;\nint main()\n{\n    int n,e,t;\n    scanf(\"%d%d%d\",&n,&e,&t);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",x+i);\n    dp[n]=e-x[n]+t;\n    head=tail=0;\n    long long mi=100000000000000000LL;\n    q[tail++]=n;\n    dp[n+1]=0;\n    x[n+1]=e;\n    for(int i=n-1;i;i--)\n    {\n        while(head<tail)\n        {\n            int u=q[head];\n            if((x[u]-x[i])*2>t){\n                mi=min(mi,dp[u+1]+x[u]*2+x[u+1]);\n                head++;\n            }\n            else break;\n        }\n        //printf(\"%d %lld %lld %lld %d %dss\\n\",i,dp[q[head]]+x[q[head]+1]-x[i]+t,mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i],head,tail);\n        dp[i]=min(mi-x[i]*3,dp[i+1]+t+x[i+1]-x[i]);\n        if(head<tail)\n            dp[i]=min(dp[q[head]+1]+x[q[head]+1]-x[i]+t,dp[i]);\n\n        while(head<tail)\n        {\n            int u=q[tail-1];\n            if(dp[u+1]+x[u+1]>=dp[i+1]+x[i+1]){\n                tail--;\n            }\n            else break;\n        }\n        q[tail++]=i;\n    }\n    printf(\"%d\\n\",dp[1]+x[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define gcd            __gcd\n#define setbits(x)     __builtin_popcountll(x)\n#define zrobits(x)     __builtin_ctzll(x)\n#define mod            1000000007\n#define mod2           998244353\n#define maxe           *max_element\n#define mine           *min_element\n#define inf            1e18\n#define deci(x, y)      fixed<<setprecision(y)<<x\n#define w(t)           int t; cin>>t; while(t--)\n#define nitin          ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define PI             3.141592653589793238\nusing namespace std;\nint pre[2001][2001];\nint find_ans(int l,int n,vector<int>&v)\n{\n    int ans=pre[l][n];\n    for(int j=l;j<n;j++)\n    {\n        ans=min(ans,pre[l][j]+find_ans(j+1,n,v)+v[j+1]-v[j]);\n    }\n    return ans;\n}\nint32_t main() {\n    nitin;\n    int n,e,t;\n    cin>>n>>e>>t;\n    vector<int>v(n+1,0);\n    int a[n+1][n+1];\n    for(int i=0;i<n;i++){\n        cin>>v[i+1];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            int temp=0;\n            int d=v[j]-v[i];\n            temp+=2*d;\n            int last=v[i];\n            for(int k=i;k<=j;k++)\n            {\n                temp+=v[k]-last+max(t-2*d-(v[k]-v[i]),(int)0);\n                last=v[k];\n            }\n            pre[i][j]=temp;\n        }\n    }\n    int ans=v[1];\n    ans+=find_ans(1,n,v);\n    ans+=e-v[n];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace bf\n{\n\ttypedef long long ll;\n\tconst int N=2010;\n\tconst ll INF=9223372036854775807ll;\n\tint pos[N];\n\tll f[N];\n\tint n,m;\n\tvoid initialize()\n\t{\n\t\tread(n),read(pos[n+1]),read(m);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tread(pos[i]);\n\t}\n\tll calc(int i,int j)\n\t{\n\t\tll dis=pos[j]-pos[i+1], ret=dis*3+pos[j+1]-pos[j];\n\t\tret+=std::max(0ll,m-dis*2);\n\t\treturn ret;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tf[0]=pos[1];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tf[i]=INF;\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\tcheck_min(f[j]+calc(j,i),f[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]);\n\t}\n}\nint main()\n{\n\tbf::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register ll i=(a);i<=(b);i++)\n#define For(i,a,b) for (register ll i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+5;\nll n,E,T,x[N],f[N],Ans,k=1e18;\nll l=1,r=1,q[N];\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\nint main()\n{\n\tmem(f,0x3f);\n\tn=read(),E=read(),T=read();\n\tFOR(i,1,n) x[i]=read();\n\tf[0]=0;\n\tFOR(i,1,n)\n\t{\n\t\twhile (l<=r&&2*(x[i]-x[q[l]+1])>T)\n\t\t{\n\t\t\tk=min(k,f[q[l]]-2*x[q[l]+1]);\n\t\t\tl++;\n\t\t}\n\t\tf[i]=min(f[i],f[q[l]]+T);\n\t\tf[i]=min(f[i],k+2*x[i]);\n\t\twhile (l<=r&&f[q[r]]-x[q[r]]>=f[i]-x[i]) r--;\n\t\tq[++r]=i;\n\t}\n\tAns=f[n]+E;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = upper_bound(a, a + n + 1, a[i] - t) - a;\n\t\tdp[i] = 1ll * N * N;\n\t\tif (x < i) {\n\t\t\tdp[i] = get(i, x);\n\t\t}\n\t\tif (x > 0) {\n\t\t\tdp[i] = min(dp[i], get(i, x - 1));\n\t\t}\t\n\t//\tcout << \"73 \" << i << \" \" << x << \" \" << dp[i] << endl;\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> PII;\n\nint n, E, T, a[1<<17];\nlong long dp[1<<17], dp2[1<<17];\n\nint main() {\n    cin >> n >> E >> T;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    dp2[0] = -2*a[1];\n    for (int i = 1, it = 1; i <= n; i++) {\n        while (2 * (a[i] - a[it]) > T) it++;\n        dp[i] = dp[it-1] + T;\n        if (it > 1) dp[i] = min(dp[i], dp2[it-2] + 2*a[i]);\n        dp2[i] = dp[i] - 2 * a[i+1];\n    }\n    cout << dp[n] + E;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t/*\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;*/\n\t\tdp[i] = get(i, 0);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAXN = 2010;\n//LL dist[MAXN][MAXN];\n\nLL getdist(vector<LL> &x, LL T, int i, int j, bool& param) {\n\tLL ret = 0;\n\t\n\tret = x[j] - x[i] ; //+ (x[j] - x[i+1]) * 2;\n\tret += max( T,  (x[j] - x[i+1]) * 2);\n\tif(T < (x[j] - x[i]) * 2) param = true;\n\telse param = false;\n\treturn ret;\n}\n\n\nint main() {\n\tLL N, E, T;\n\tcin >> N >> E >> T;\n\tvector<LL> x;\n\tx.push_back(0);\n\tfor(int i=0; i<N; i++) {\n\t\tLL y;\n\t\tcin >> y;\n\t\tx.push_back(y);\n\t}\n\tLL INF = 1000000;\n\tINF *= INF * INF;\n\tLL ret = INF;\n\tvector<LL> ans(N+1, INF);\n\tans[0] = 0;\n\t/*\n\tfor(int i=1; i<=N; i++) {\n\t\tint j = 0;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[i] = min(ans[i], ans[j] + getdist(x, T,j, i));\n\t\t\t\n//\t\t}\n\t}*/\n\tLL pos = 0;\n\tLL p2 = 0;\n\tfor(int i=1; i<=N; i++) {\n\t\tLL prev = INF;\n\t\tpos = p2;\n\t\tpos--;\n\t\tpos = max((LL)0, pos);\n\t\twhile(true) {\n\t\t\tif(pos == i) break;\n\t\t\tbool a;\n\t\t\tLL data = getdist(x, T, pos , i, a);\n\t\t\tif(ans[i] < ans[pos] + data) break;\n\t\t\tif(ans[i] > ans[pos] + data) p2 = pos;\n\t\t\tans[i] = min(ans[i], ans[pos] + data);\n//\t\t\tif(data > prev) break;\n\t\t\tprev = data;\n\t\t\tif(!a) break;\n\t\t\tpos++;\n\t\t}\n\t\t\n\t}\n\t\n\tbool tmp;\n\tfor(int i=0; i<N; i++) {\n\t\tint j = N;\n//\t\tfor(int j=0; j<i; j++) {\n\t\t\tans[j] = min(ans[j], ans[i] + getdist(x, T,i, j, tmp));\n\t\t\t\n//\t\t}\n\t}\n\t\n\tcout << ans[N] + (E - x[N]) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\nclass starry_sky_tree{\npublic:\n  static const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n  using Int = long long;\n  Int segMin[2 * MAX_SIZE - 1], segAdd[2 * MAX_SIZE - 1];\n\n  starry_sky_tree(){\n    fill(segMin, segMin + 2*MAX_SIZE-1, 0);\n    fill(segAdd, segAdd + 2*MAX_SIZE-1, 0);\n  }\n\n  //区間[a, b)に値xを加算する.\n  void add(int a, int b, Int x, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return; //もし交差しない区間であれば終える.\n    \n    if (a <= l && r <= b){ //もし今みている区間[l, r)が[a, b)に完全に内包されていれば\n      segAdd[k] += x;  //区間[l, r)にkを加算する.\n      return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子の区間に(必要があれば)xを加算する.\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃\n\n    //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である.一様に加算される値は更新しなくて良い.\n    segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n  }\n\n  Int getMin(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n  {\n    if (r <= a || b <= l) return (LLONG_MAX);\n    \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]); //完全に内包されていれば,その区間の最小値を返す.\n    \n    Int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2); //子の区間の最小値を求める.\n    Int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r); //子の区間の最小値を求める\n    \n    return (min(left, right) + segAdd[k]); //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である (大切なので2回書きました!!)\n    \n  }\n};\n\nint main(){\n  int n;\n  long long e,t;\n  cin >> n,e,t;\n\n  //assert(n<=2000);\n\n  vector<long long> x(n);\n  cin >> x;\n  x.push_back(e);\n  x.push_back(1ll<<57);\n\n  starry_sky_tree a, b;\n\n  vector<long long> dp(n+1, 1ll<<57);\n  dp[0] = 0;\n\n  for(int i=0, j=0; i<n; i++){\n    while(j<i && t < 2*(x[i] - x[j]) ){\n      j++;\n    }\n    if(j) dp[i+1] = min(dp[i+1], a.getMin(0, j));\n    dp[i+1] = min(dp[i+1], t+ b.getMin(j, i+1));\n\n    a.add(0,i+1, 2*(x[i+1]-x[i]));\n    b.add(i+1, i+2, dp[i+1]);\n  }\n  println(dp[n] + e);\n\n  //eprintln(join(dp, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+10;\npair<long long int,int>seg[4*maxn];\n//pair<long long int,int>seg2[4*maxn];\nint a[maxn];\nlong long int dp[2][maxn];\nint n;\nint e;\nint d;\nvoid update(int id,int l,int r,int l2,int r2,long long int val){\nif(l>=r2||r<=l2){\n\treturn;\n}\t\nif(l2<=l&&r<=r2){\n\tif(seg[id].first==0||seg[id].first>=val){\n\t\tseg[id]={val,l2};\n\t\treturn ;\n\t}\n}\nint mid=(l+r)>>1;\nupdate(id<<1,l,mid,l2,r2,val);\nupdate((id<<1)|1,mid,r,l2,r2,val);\nseg[id]=min(seg[id<<1],seg[(id<<1)|1]);\n}\npair<long long int,int>get(int id,int l,int r,int l2,int r2){\n\tif(l>=r2||r<=l2){\n\t\treturn {(long long int)1e18,1000};\n\t}\n\tif(l2<=l&&r<=r2){\n\t\treturn seg[id];\n\t}\n\tint mid=(l+r)>>1;\n\treturn min(get(id<<1,l,mid,l2,r2),get((id<<1)|1,mid,r,l2,r2));\n}\ninline void input();\nint main(){\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tinput();\n}\ninline void input(){\n\tcin>>n>>e>>d;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tdp[0][i]=a[i];\n\t\t\tdp[1][i]=a[i];\n\t\t\tdp[1][i]+=d;\n\t\t}\n\t\telse{\n\t\tint l=0;\n\t\tint r=i;\n\t\twhile(l!=r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(2*(a[i]-a[mid])>=d){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=mid;\n\t\t\t}\n\t\t}\n\t\tcout<<l<<\": \"<<r<<\" \"<<i<<endl;\n\t\tpair<long long int,int>p=get(1,0,n,0,l+1);\n\t\t//cout<<l<<endl;\n\t\tpair<long long int,int>w=get(1,0,n,l,i);\n\t\tdp[0][i]=dp[1][i-1]+(a[i]-a[i-1]);\n\t\tif(2*(a[i]-a[0])>=d){\n\t\t\tdp[1][i]=(dp[0][p.second]+1ll*3*(a[i]-a[p.second]));\n\t\t}\n\t\tif(2*(a[i]-a[i-1])<d){\n\t\t\tdp[1][i]=min(dp[1][i],(long long)(dp[0][w.second]+d+1ll*2*(a[i]-a[w.second])));\n\t\t}\n\t\t}\n\t\tif(dp[1][i-1]+a[i]-a[i-1]+d<=dp[1][i]){\n\t\t\tdp[1][i]=(long long)(dp[1][i-1]+a[i]-a[i-1]+d);\n\t\t}\n\t//\tcout<<dp[0][i]<<\" \"<<dp[1][i]<<endl;\n\t\t//cout<<i<<endl;\n\t\tupdate(1,0,n,i,i+1,(long long)(dp[0][i]+(e-a[i])));\n\t}\n\tcout<<dp[1][n-1]+(e-a[n-1]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double \n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\nusing namespace :: std;\n\n\nconst ll  maxn=1e5+500;\nconst ll inf=2e18+7;\n\nll dp[maxn];\nll a[maxn];\nll parminn[maxn];\nint main(){\n    fill(dp,dp+maxn,inf);\n    ll n,e,t;\n    cin>>n>>e>>t;\n    t*=2;\n    e*=2;\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n        a[i]*=2;\n    }\n    ll p=0;\n    dp[0]=0;\n    for(ll i=1;i<=n;i++){\n        while(p+1<i && a[i]-a[p+1]>=t/2){\n            p++;\n        }\n        if(p==0){\n            dp[i]=t;\n        }else{\n            dp[i]=min(dp[p]+t,parminn[p]+a[i]*2);\n        }\n        parminn[i]=min(parminn[i-1],dp[i-1]-a[i]*2);\n    }\n    cout<<(dp[n]+e)/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint x[MN+5],T,n,q[MN+5],top,tail;\nlong long f[MN+5];\nint main()\n{\n\tn=read();x[n+1]=read();T=read();\n\tfor(int i=1;i<=n;++i) x[i]=read();\n\tf[0]=x[1];q[top=tail=1]=0;long long mn=1e18;\n\tfor(int i=1,j=0;i<=n;++i)\n\t{\n\t\twhile(j<i&&(x[i]-x[j+1])*2>=T) mn=min(mn,f[j]-3LL*x[j+1]),++j; \n\t\twhile(top>=tail&&(x[i]-x[q[tail]+1])*2>=T) ++tail;\n\t\tf[i]=min(mn+3LL*x[i],top>=tail?f[q[tail]]-x[q[tail]+1]+x[i]+T:(long long)1e18);\n\t\tf[i]=min(f[i],f[i-1]+T);f[i]+=x[i+1]-x[i];\n\t//\tcout<<i<<\" \"<<mn<<\" \"<<(top>=tail?q[tail]:-1)<<\" \"<<f[i]<<endl;\n\t\twhile(top>=tail&&f[i]-x[i+1]<=f[q[top]]-x[q[top]+1]) --top;q[++top]=i;\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,E,T;\nll p[N];\nvoid input()\n{\n\tn=read<int>(),E=read<int>(),T=read<int>();\n\tFor(i,1,n)p[i]=read<ll>();\n}\nconst ll inf=1e18;\nll dp[N];\nvoid work()\n{\n\tmemset(dp,63,sizeof dp);\n\tdp[0]=0;\n\tint now=0;\n\tll Min;\n\tFor(i,1,n)\n\t{\n\t\t//dp[i]=dp[i-1]+T;\t\n\t\tMin=inf;\n\t\twhile(T<=2*(p[i]-p[now+1]))\n\t\t{\n\t\t\tcmin(Min,dp[now]-2*p[now+1]);\n\t\t\tnow++;\n\t\t}\n\t\tif(now<i)cmin(dp[i],dp[now]+T);\n\t\tcmin(dp[i],Min+2*p[i]);\n\t\t//cout<<dp[i]<<endl;\n\t}\n\twrite(dp[n]+E,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tlong long int N, E, T;\n\tcin >> N >> E >> T;\n\tvector<long long int>X( N + 2 );\n\tmap<long long int, long long int>M;\n\tM[0] = 0;\n\tfor( size_t i = 1; i <= N; i++ ) {\n\t\tcin >> X[i];\n\t\tM[X[i]] = i;\n\t}\n\tX[N + 1] = E;\n\tM[E] = N + 1;\n\tvector<long long int>DP( N + 2, LLONG_MAX / 6 );\n\tDP[0] = 0;\n\tfor( size_t now = 0; now < N; now++ ) {\n\t\tlong long int nowidx = M[now];\n\t\tlong long int nextidx = nowidx + 1;\n\t\tlong long int len = T / 2;\n\t\tlong long int idxmax = N + 1, idxmin = 0;\n\t\twhile( idxmin + 1 < idxmax ) {\n\t\t\tlong long int idxmid = (idxmin + idxmax) / 2;\n\t\t\tif( len + X[nextidx] > X[idxmid] ) {\n\t\t\t\tidxmin = idxmid;\n\t\t\t} else {\n\t\t\t\tidxmax = idxmid;\n\t\t\t}\n\t\t}\n\t\tidxmin = max( 0LL, idxmin - 1 );\n\t\t//cout << idxmin << endl;\n\t\tfor( size_t i = idxmin; i < N + 1; i++ ) {\n\t\t\tDP[i] = min( DP[i], DP[now] + X[nextidx] - X[nowidx] + (X[i] - X[nextidx]) * 3 + max( 0LL, T - (X[i] - X[nextidx]) * 2 ) );\n\t\t}\n\t\tDP[now + 1] = min( DP[now + 1], DP[now] + X[now + 1] - X[now] + T );\n\t}\n\tcout << DP[N] + X[N + 1] - X[N] << endl;\n\t/*\n\tfor( size_t i = 0; i < N + 2; i++ ) {\n\t\tcout << DP[i] << \" \";\n\t}\n\tcout << endl;\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long int ll;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n\nconst int MAX_N = 1 << 19;\nconst int MAX_M = 2;\n\n// セグメント木を持つグローバル配列\nint nn;\nll  dat[2 * MAX_N - 1][2];\n\n// 初期化\nvoid init(int n_){\n    // n_が小さいときの変な挙動を防ぐ\n    if(n_ < 10)n_ = 10;\n    // 簡単のため要素数を2のべき乗に\n    nn = 1;\n    while(nn < n_)nn *= 2;\n\n    // 全ての値をINT_MAXに\n    for(int i = 0; i < 2 * nn - 1; i++)for(int j = 0; j < MAX_M; j++)dat[i][j] = 123456789123456789;\n}\n\n// k番目の値(0-indexed)をaに変更\nvoid update(int k, ll a, int m){\n    // 葉の接点\n    k += nn - 1;\n    dat[k][m] = a;\n    // 登りながら更新\n    while(k > 0){\n        k = (k - 1) / 2;\n        dat[k][m] = min(dat[k * 2 + 1][m], dat[k * 2 + 2][m]);\n    }\n}\n\n// [a,b)の最小値を求める\n// 後ろのほうの引数は、計算の簡単のための引数。\n// kは節点の番号、l, rはその節点が[l, r)に対応づいていることを表す。\n// したがって、外からはquery(a, b, 0, 0, nn)として呼ぶ。\nll query(int a, int b, int k, int l, int r, int m){\n    // [a, b)と[l, r)が交差しなければ、INT_MAX\n    if (r <= a || b <= l)return (ll)123456789123456789;\n\n    // [a, b)が[l, r)を完全に含んでいれば、この節点の値\n    if (a <= l && r <= b)return dat[k][m];\n    else {\n        // そうでなければ、2つの子の最小値\n        ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, m);\n        ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, m);\n        return min(vl, vr);\n    }\n}\n\n\nint main(){\n    ll n, E, T;\n    cin >> n >> E >> T;\n    n++;\n    init(n);\n\n    ll x[n] = {};\n    srep(i,1,n) cin >> x[i];\n\n    if(n == 2){\n        cout << E + T << endl;\n        return 0;\n    }\n\n    ll INF = 1001001001001001001;\n    ll dp[n] = {};\n    srep(i,1,n) dp[i] = INF;\n\n    update(0,dp[0]-x[0]-2*x[1],0);\n    update(0,dp[0]-x[0],1);\n\n    srep(i,1,n){\n        int l = 0, r = i - 1;\n        if((x[i]-x[1])*2 < T){\n            r = 0;\n        }\n        while(l+1<r){\n            int m = (l+r)/2;\n            if((x[i]-x[m+1])*2 < T){\n                r = m;\n            }else{\n                l = m;\n            }\n        }\n\n        \n\n\n        ll tmp1 = INF, tmp2 = INF;\n        tmp1 = query(r,i,0,0,nn,1) + T + x[i];\n        if(r>0) tmp2 = query(0,r,0,0,nn,0) + 3 * x[i];\n        dp[i] = min(tmp1, tmp2);\n\n        // cout << i << ' ' << l << ' ' << r << ' ' << tmp1 << ' ' << tmp2 << endl;\n\n        if(i == n - 1) break;\n\n        update(i,dp[i]-x[i]-2*x[i+1],0);\n        update(i,dp[i]-x[i],1);\n    }\n\n    cout << dp[n-1] + E - x[n-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = (long long) 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector<int> x(n + 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i + 1];\n  }          \n  vector<int> first(n + 1); // first no wait from right to left\n  for (int i = n, j = n; i >= 0; i--) {\n    while (j > 0 && 2 * x[i] - 2 * x[j] <= t) {\n      j--;\n    }\n    first[i] = j;\n  }\n  vector<long long> dp(n + 1, inf);\n  dp[0] = 0;\n  long long min_prefix = inf;\n  for (int i = 1, j = 0; i <= n; i++) {\n    while (j < first[i]) {\n      min_prefix = min(min_prefix, dp[j] - 2 * x[j + 1]);\n      j++;\n    }\n    dp[i] = min(t + dp[j], min_prefix + 2 * x[i]); \n  }\n  cout << dp[n] + e << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint n, p[200020];\nll d[200020];\nint E, t;\n\nstruct deq{\n\tdeq(){f=r=0;}\n\tll q[200020];\n\tint f, r;\n\tvoid push(ll x){\n\t\twhile(f-r > 0 && q[f-1] > x)--f;\n\t\tq[f++] = x;\n\t}\n\tvoid pop(ll x){if(x==q[r])++r;}\n\tll read(){return f==r ? 1e18 : q[r];}\n}Q;\n\nvoid solve(){\n\tscanf(\"%d%d%d\", &n, &E, &t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\", p+i);\n\tQ.push(t);\n\tll mn = 1e18;\n\tfor(int i=1, j=1;i<=n;i++){\n\t\twhile((p[i] - p[j]) * 2 > t){\n\t\t\tQ.pop(d[j-1] - p[j-1] + t);\n\t\t\tmn = min(mn, d[j-1] - p[j-1] - 2 * p[j]);\n\t\t\t++j;\n\t\t}\n\t\td[i] = min(Q.read() + p[i], mn + 3LL * p[i]);\n\t\tQ.push(d[i] - p[i] + t);\n\t}\n\tprintf(\"%lld\", (E - p[n]) + d[n]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\nint n;\nlong long e, t;\n\nlong long a[N];\nlong long dp[N];\n\nlong long get(int i, int j) {\n//\tif (j == 0) {\n//\t\treturn a[i] + t * (i - j);\n//\t}\n//\tcout << \"48 \" << i << \" \" << j << \" \" << t * (i - j) + a[i] - a[j] << \" \" << 2ll * (a[i] - a[j - 1]) + (a[i] - a[j]) + 1ll * (i - j) * max(0ll, t - 2 * (a[i] - a[j])) << endl;\n\treturn min(t * (i - j) + a[i] - a[j], 0ll + 2ll * (a[i] - a[j + 1]) + (a[i] - a[j]) + 1ll * max(0ll, t - 2ll * (a[i] - a[j + 1]))) + dp[j];\n}\n\nint32_t main() {\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a + 1, a + n + 1);\n\tdp[0] = 0;\n\tint p = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (p < i - 1 && get(i, p + 1) <= get(i, p)) {\n\t//\t\tcout << \"72 \" << i << \" \" << p << \" \" << get(i, p) << endl;\n\t\t\tp++;\n\t\t}\n\t\tdp[i] = get(i, p);\n\t//\tcout << \"73 \" << i << \" \" << p << \" \" << dp[i] << endl;\n\t/*\tdp[i] = get(i, 0);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tdp[i] = min(dp[i], get(i, j));\n\t\t}*/\n\t}\n\tcout << dp[n] + e - a[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N,E,T;\nint x[2200],dp[2200];\nsigned main() {\n    cin>>N>>E>>T;\n    for(int i=0;i<N;i++)cin>>x[i];\n    x[N]=E;\n    dp[N]=0;\n    for(int i=N-1;i>=0;i--){\n        dp[i]=LLONG_MAX;\n        for(int j=i+1;j<=N;j++){\n            dp[i]=min(dp[i],dp[j]+max(T,2*(x[j-1]-x[i]))+x[j]-x[i]);\n        }\n    }\n    cout<<x[0]+dp[0]<<endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid M. Note that constructing this tree requires the identity\n * element of M and the operation of M.\n * Header requirement: vector, algorithm\n * Verified by AtCoder ABC017-D (http://abc017.contest.atcoder.jp/submissions/660402)\n */\ntemplate<class I, class BiOp = I (*) (I, I)>\nclass SegTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\npublic:\n  SegTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_) { n *= 2; } // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  void update_array(int k, int len, const I *vals) {\n    for (int i = 0; i < len; ++i) {\n      update(k + i, vals[i]);\n    }\n  }\n  /*\n    Updates all elements. O(n)\n   */\n  void update_all(const I *vals, int len) {\n    for (int k = 0; k < std::min(n, len); ++k) {\n      dat[k + n - 1] = vals[k];\n    }\n    for (int k = std::min(n, len); k < n; ++k) {\n      dat[k + n - 1] = e;\n    }\n    for (int b = n / 2; b >= 1; b /= 2) {\n      for (int k = 0; k < b; ++k) {\n\tdat[k + b - 1] = op(dat[k * 2 + b * 2 - 1], dat[k * 2 + b * 2]);\n      }\n    }\n  }\n  /* l,r are for simplicity */\n  I querySub(int a, int b, int k, int l, int r) const {\n    // [a,b) and  [l,r) intersects?\n    if (r <= a || b <= l) return e;\n    if (a <= l && r <= b) return dat[k];\n    I vl = querySub(a, b, 2 * k + 1, l, (l + r) / 2);\n    I vr = querySub(a, b, 2 * k + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n  /* [a, b] (note: inclusive) */\n  I query(int a, int b) const {\n    return querySub(a, b + 1, 0, 0, n);\n  }\n};\n\n\nconst int N = 8001;\nll dp[N];\nconst ll inf = 1e16;\n\nstruct max_fun {\n  ll operator()(ll x, ll y) const {\n    return min(x, y);\n  }\n};\n\nint main(void){\n  int n;\n  ll e, t;\n  cin >> n >> e >> t;\n  assert (n < N);\n  VL x(n);\n  SegTree<ll, max_fun> raw(n + 1, max_fun(), inf); // dp[i]\n  SegTree<ll, max_fun> boiled(n + 1, max_fun(), inf); // dp[i] - 2 * x[i]\n  REP(i, 0, n) {\n    cin >> x[i];\n  }\n  dp[0] = 0;\n  raw.update(0, 0);\n  boiled.update(0, -2 * x[0]);\n  REP(i, 0, n) {\n    // Compute the range of j s.t. t <= 2 * (x[i] - x[j]) (0 <= j <= i)\n    int j_boundary =\n      upper_bound(x.begin(), x.begin() + i + 1, x[i] - (t+1)/2) - x.begin();\n    ll ret = inf;\n    ret = min(ret, boiled.query(0, j_boundary - 1) + 2 * x[i]);\n    ret = min(ret, raw.query(j_boundary, i) + t);\n    dp[i + 1] = ret;\n    raw.update(i + 1, ret);\n    if (i < n - 1) {\n      boiled.update(i + 1, ret - 2 * x[i + 1]);\n    }\n  }\n  cout << dp[n] + e << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\nll n, e, t, ans, cnt, a[100005];\n//ll max(ll p, l)\nint main()\n{\n\tint i, j;\n//\tfreopen (\"input.txt\", \"r\", stdin);\n\tcin >> n >> e >> t;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf (\"%lld\", &a[i]);\n\t}\n\ta[n] = e;\n\tans = a[0];\n\tfor (i = 0; i < n; ) {\n\t\tcnt = 1;\n\t\tfor (j = i; j < n; j++) {\n\t\t\tif (cnt * t < (a[j] - a[i]) * 2) break;\n\t\t\tcnt++;\n\t\t}\n\t\tans += (a[j - 1] - a[i]) * 2;\n\t\tans += a[j] - a[i];\n\t\tans += max(0LL, t - (a[j - 1] - a[i]) * 2);\n\t\ti = j;\n\t}\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return 0;\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i])) + F[mid] + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i])) + F[mid+1] + dp(mid+2);\n    if(t2 > t1){\n        l = mid;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i])) + F[l] + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + F[r] + dp(r+1);;\nll ans = min(t1,t2);\n//cout << i << \" \" << ans << \"\\n\";\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d,e;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0)+X[0] << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n\nunsigned readUnsigned() {\n    int c;\n    do { c = ::getchar_unlocked(); } while (c < '0');\n    unsigned result = c - '0';\n    while ((c = ::getchar_unlocked()) >= '0') {\n        result *= 10;\n        result += c - '0';\n    }\n    return result;\n}\n\n\nconst unsigned MAX_N = 100 * 1000;\nuint64_t N, E, T;\nuint64_t xs[MAX_N];\n\nlong long unsigned reallySimpleDP() {\n    /*\n     * dp[i]: After just giving candy to bear xs[i] and given that all coins\n     *        from bears xs[0]...xs[i-1] have been collected, how long does it\n     *        take to end the game?\n     *\n     */\n    uint64_t dp[MAX_N];\n    dp[N - 1] = T + E - xs[N - 1];\n    for (unsigned i = N - 1; i--;) {\n        dp[i] = T + xs[i+1] - xs[i] + dp[i+1];\n\n        /*\n         * Try all routes xs[i] -> xs[i+k] -> xs[i] -> xs[i+k].\n         *\n         * 1) Instead of waiting at xs[i], we go walk xs[i+k].\n         * 2) We walk back to xs[i].\n         * 3) If the coin hasn't appeared yet, we wait for it.\n         * 4) We go to xs[i+k+1], if it exists.  The coin xs[i+k] is ready.\n         * 5) To finish the game, the cost is dp[i+k+1].\n         */\n        for (unsigned j = i + 1; j < N; ++j) {\n            uint64_t cost = 2 * (xs[j] - xs[i]);\n            if (cost < T) cost = T;\n            if (j + 1 < N) {\n                cost += xs[j+1] - xs[i] + dp[j+1];\n            }\n            else {\n                cost += E - xs[i];\n            }\n            dp[i] = std::min(dp[i], cost);\n        }\n    }\n    return xs[0] + dp[0];\n}\n\nlong long unsigned fastDP() {\n    uint64_t dp[MAX_N];\n    dp[N - 1] = T + E - xs[N - 1];\n    uint64_t mintail = ~0u;\n    uint64_t J = N - 2;\n    for (unsigned i = N - 1; i--;) {\n        dp[i] = T + xs[i+1] - xs[i] + dp[i+1];\n\n        /*\n         * Find the largest j for which distance < T.\n         */\n        unsigned j = i + 1;\n        for (unsigned step = 1 + (N - j) / 2; step; step /= 2) {\n            for (; j + step < N; j += step) {\n                uint64_t distance = 2 * (xs[j + step] - xs[i]);\n                if (distance >= T) {\n                    break;\n                }\n            }\n        }\n\n        /* Special case: distance < T */\n        if (j + 1 < N) {\n            uint64_t cost = 2 * (xs[j] - xs[i]);\n            if (cost < T) cost = T;\n            cost += xs[j+1] - xs[i] + dp[j+1];\n            dp[i] = std::min(dp[i], cost);\n        }\n\n        for (; J > 0 && 2 * (xs[J] - xs[i]) >= T; --J) {\n            mintail = std::min(mintail, dp[J+1] + xs[J+1] + 2*xs[J]);\n        }\n        dp[i] = std::min(dp[i], mintail - 3*xs[i]);\n\n#if 0\n        /* It turns out that this loop does not depend on i.  Coolio. */\n        for (; j + 1 < N; ++j) {\n            uint64_t cost = (2*xs[j] + xs[j+1] + dp[j+1]) - 3*xs[i];\n            dp[i] = std::min(dp[i], cost);\n        }\n#endif\n\n        /* Special case: j+1==N and dp[j+1] is out of bounds. */\n        if (i + 1 < N) {\n            j = N - 1;\n            uint64_t cost = 2 * (xs[j] - xs[i]);\n            if (cost < T) cost = T;\n            cost += E - xs[i];\n            dp[i] = std::min(dp[i], cost);\n        }\n    }\n    return xs[0] + dp[0];\n}\n\nint main() {\n#if 0\n    ::srand(42);\n    for (;;) {\n        N = 1000;\n        T = 1 + ::rand();\n        xs[0] = 1 + ::rand() % 5;\n        for (unsigned i = 1; i < N; ++i) {\n            xs[i] = xs[i-1] + 1 + ::rand() % 100000;\n        }\n        E = xs[N-1] + 1 + ::rand() % 100000;\n        /*\n        printf(\"N=%u, E=%u, T=%u\\n\", (unsigned)N, (unsigned)E, (unsigned)T);\n        printf(\"xs =\");\n        for (unsigned i = 0; i < N; ++i) {\n            printf(\" %u\", (unsigned)xs[i]);\n        }\n        putchar('\\n');\n        */\n        if (fastDP() != reallySimpleDP()) {\n            printf(\"%llu != %llu\\n\", fastDP(), reallySimpleDP());\n            assert(0);\n        }\n    }\n    return 0;\n#endif\n\n    N = readUnsigned();\n    E = readUnsigned();\n    T = readUnsigned();\n    for (unsigned i = 0; i < N; ++i) {\n        xs[i] = readUnsigned();\n    }\n\n    printf(\"%llu\\n\", fastDP());\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(), v.end()\n#define fori(i, j, k) for (int i = (j); i < (int)(k); i++)\n#define forb(i, j, k) for (int i = (j); i >= (int)k; i--)\n#define lchild(ind) 2 * ind + 1\n#define rchild(ind) 2 * ind + 2\n#define bug(val) cout << \"# \" << val << endl;\n#define bugs(val) cout << '_' << val;\n#define bugl(val) cout << \"## \" << val << endl;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\ntypedef pair<ll, pll> plp;\ntypedef pair<pll, int> ppi;\ntypedef pair<pll, ll> ppl;\ntypedef pair<pll, pll> ppp;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int maxn = 1e5 + 500;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nll n, x[maxn], dp[maxn], seg[4 * maxn], E, T, ind;\n\nvoid update(ll u, ll l, ll r, ll x, ll val)\n{\n\tif (r - l == 1)\n\t{\n\t\tseg[u] += val;\n\t\treturn;\n\t}\n\tll mid = (l + r) / 2;\n\tif (x < mid)\n\t\tupdate(lchild(u), l, mid, x, val);\n\telse\n\t\tupdate(rchild(u), mid, r, x, val);\n\tseg[u] = min(seg[lchild(u)], seg[rchild(u)]);\n}\n\nll query(ll u, ll l, ll r, ll b, ll e)\n{\n\tif (e <= b)\n\t\treturn inf;\n\tif (b <= l && r <= e)\n\t\treturn seg[u];\n\tll mid = (l + r) / 2, tmp = inf;\n\tif (b < mid)\n\t\ttmp = min(tmp, query(lchild(u), l, mid, b, e));\n\tif (e > mid)\n\t\ttmp = min(tmp, query(rchild(u), mid, r, b, e));\n\treturn tmp;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> E >> T;\n\tfori (i, 1, n + 1)\n\t\tcin >> x[i];\n\tupdate(0, 0, n + 1, 0, -2 * x[1]);\n\tfori (i, 1, n + 1)\n\t{\n\t\tind = lower_bound(x, x + n, x[i] - T / 2) - x;\n\t\tif (2 * (x[i] - x[ind]) < T)\n\t\t\tind--;\n\t\tdp[i] = min(2 * x[i] + query(0, 0, n + 1, 0, ind), T + dp[ind]);\n\t\tupdate(0, 0, n + 1, i, dp[i] - 2 * x[i + 1]);\n\t}\n\tcout << dp[n] + E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n#define INF 1e18\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef vector < pair<int, int> > vii;\ntypedef long double ld;\ntypedef tree<pair<int,int>, null_type, less<pair<int,int> >, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll dp[111111], x[111111];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tll n, e, T;\n\tcin >> n >> e >> T;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> x[i];\n\t}\n\tdp[1]=x[1]+T;\n\tfor(int i = 2; i <= n; i++){\n\t\tdp[i]=INF;\n\t\tfor(int j = 1; j <= i; j++){\n\t\t\tif(2*(x[i]-x[j])>=T){\n\t\t\t\tdp[i]=min(dp[i],x[j]-x[j-1]+3*(x[i]-x[j])+dp[j-1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i]=min(dp[i],x[j]-x[j-1]+3*(x[i]-x[j])+dp[j-1]+T-2*(x[i]-x[j]));\n\t\t\t}\n\t\t}\n\t}cout << dp[n]+e-x[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k;\nll T;\nll e;\n\nvector<ll> X;\nvector<ll> F;\nvector<ll> B;\nll DP[100001] = {0};\n\nll dp(ll i){\nif(i == n)return e-X[n-1];\nif(DP[i] != -1)return DP[i];\nll l = i;\nll r = n-1;\n/*\nll ans = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i])) + F[i] + dp(i+1);\nfor(ll c1 = i+1; c1 < n; c1++){\n    ans = min(ans , 3*(X[c1]-X[i]) + max(0ll , T-2*(X[c1]-X[i])) + F[c1] + dp(c1+1));\n}\n*/\n\n\nwhile(l < r-1){\n    ll mid = (l+r)/2;\n    ll t1 = 3*(X[mid]-X[i]) + max(0ll , T-2*(X[mid]-X[i]))  + dp(mid+1);\n    ll t2 = 3*(X[mid+1]-X[i]) + max(0ll , T-2*(X[mid+1]-X[i]))  + dp(mid+2);\n    if(t2 <= t1){\n        l = mid+1;\n    }\n    else{\n        r = mid;\n    }\n}\n\n\nll t1 = 3*(X[l]-X[i]) + max(0ll , T-2*(X[l]-X[i]))  + dp(l+1);\nll t2 = 3*(X[r]-X[i]) + max(0ll , T-2*(X[r]-X[i])) + dp(r+1);\n\nll edge1 = 3*(X[i]-X[i]) + max(0ll , T-2*(X[i]-X[i]))  + dp(i+1);\nll edge2 = 3*(X[n-1]-X[i]) + max(0ll , T-2*(X[n-1]-X[i]))  + dp(n);\n\nll ans = min(t1,t2);\nans = min(ans , edge1);\nans = min(ans , edge2);\n//cout << i << \" \" << ans  << \"\\n\";\nans += B[i];\nDP[i] = ans;\nreturn ans;\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n    ll c1,c2,c3,c4;\n\n   cin >> n >> e >> T;\n   for(c1 = 0; c1 < n; c1++){\n        cin >> a;\n        X.push_back(a);\n        DP[c1] = -1;\n   }\n\n    B.push_back(X[0]);\n\n   for(c1 = 0; c1 < n-1; c1++){\n        F.push_back(X[c1+1] - X[c1]);\n        B.push_back(X[c1+1] - X[c1]);\n   }\n    F.push_back(e-X[n-1]);\n    cout << dp(0) << \"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, e, t;\n  cin >> n >> e >> t;\n  vector <ll> x(n + 1);\n  for (int i = 0; i < n; ++i) cin >> x[i + 1];\n  x[0] = 0;\n  vector <ll> dp(n + 1, Inf);\n  dp[0] = 0;\n  ll bestF = Inf; \n  auto relaxF = [&] (int i) {\n    bestF = min(bestF, dp[i] - x[i] - (ll)t * i);\n  };\n  auto get0 = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1]; \n  };\n  auto gett = [&] (int i) {\n    return dp[i] - x[i] - 2 * x[i + 1] + 2 * x[i + 1];\n  };\n  relaxF(0);\n  //multiset <ll> h0, ht;\n  //ht.insert(gett(0));\n  //int uk = 0;\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = bestF + x[i] + (ll)t * i;\n    for (int j = 0; j < i; ++j) {\n      if (t - 2 * x[i] + 2 * x[j + 1] >= 0) {\n        dp[i] = min(dp[i], gett(j) + 3 * x[i] + t);\n      } else {\n        dp[i] = min(dp[i], get0(j) + 3 * x[i]);\n      }\n    }\n    //if (!h0.empty()) dp[i] = min(dp[i], *h0.begin() + 3 * x[i]); \n    //if (!ht.empty()) dp[i] = min(dp[i], *ht.begin() + 3 * x[i] + t);\n    /*for (int j = i + 1; j <= n; ++j) {\n      ll extra = max(0LL, t - 2 * x[j] + 2 * x[i + 1]);\n      dp[j] = min(dp[j], dp[i] + 3 * x[j] - x[i] - 2 * x[i + 1] + extra);\n    }*/\n    relaxF(i);\n    //if (i < n) ht.insert(gett(i));\n  }\n  cout << dp[n] + e - x[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\nll n,d[N],t,e;\n\nll f[N][N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    if(n>N)return 0;\n    lol(i,n)cin>>d[i+1];\n    lol(i,N)lol(j,N)f[i][j]=1e17; f[0][0]=0;\n    lol(i,n+1){\n\tlol(j,i+1){\n\t    if(i>j){\n\t\tchmin(f[i+1][j],f[i][j]+d[i+1]-d[i]);\n\t\tll dis=d[i]-d[j+1];\n\t\tchmin(f[i+1][i],f[i][j]+max(dis,t-dis));\n\t    }\n\t    //cout<<f[i][j]<<\" \";\n\t}//cout<<endl;\n    }\n    cout<<e+f[n+1][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    dp[1] = T;\n    for (ll i = 2, j = 0; i <= N;) {\n        ll L = max(2 * (X[i] - X[j + 1]), T);\n        if (L == T) {\n            dp[i] = min(dp[j] + T, dp[j - 1] + 2 * (X[i] - X[j]));\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector< vector<int> > vvi;\ntypedef vector<ll> vl;\ntypedef vector< vector<ll> > vvl;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n#define forv(i, v) forn(i, v.size())\n#define all(v) v.begin(), v.end()\n#define mp make_pair\n#define pb push_back\n\nconst ll INF = 1e18;\n\nint main() {\n#ifdef NEREVAR_PROJECT\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    ll t, e;\n    cin >> n >> e >> t;\n    vl x(n);\n    forn(i, n) {\n        scanf(\"%lld\", &x[i]);\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    forn(i, n) {\n        ll pos = i == 0 ? 0 : x[i - 1];\n        \n        int lf = i, rg = n - 1;\n        while (rg - lf > 1) {\n            int mid = (lf + rg) / 2;\n            if ((x[mid] - x[i]) * 2 <= t) {\n                lf = mid;\n            } else {\n                rg = mid - 1;\n            }\n        }\n        \n        for (int j = max(i, lf - 20); j < min(n, rg + 20); j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n    }\n    cout << dp[n] + e - x[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tll mini=inf;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[j]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconstexpr ll MAX_N = 1e5;\nconstexpr ll INF = 1e10;\nll N, E, T;\nvector<ll> X;\n\nint main(void) {\n    cin >> N >> E >> T;\n    X.push_back(0);\n    for (size_t i = 0; i < N; i++) {\n        ll x;\n        cin >> x;\n        X.push_back(x);\n    }\n\n    vector<ll> dp(N + 1, 0);\n\n    for (auto&& d : dp) {\n        cout << d << endl;\n    }\n\n    for (ll i = 1; i <= N; i++) {\n        ll m = INF;\n        for (ll j = 0; j < i; j++) {\n            ll d = dp[j] + max(2 * (X[i] - X[j + 1]), T);\n            if (d < m) {\n                m = d;\n            }\n        }\n        dp[i] = m;\n    }\n\n    for (auto&& d : dp) {\n        cout << d << endl;\n    }\n\n    cout << dp[N] + E << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int maxn = 1e5 + 20;\n\nint N, E, T;\nint x[maxn];\nlong long f[maxn];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &E, &T);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tfor(int i = 1; i <= N; i++) f[i] = 1e18;\n\t\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint y = x[i + 1] - x[i];\n\t\t\n\t\tf[i + 1] = std::min(f[i + 1], f[i - 1] + 2 * y);\n\t\tf[i] = std::min(f[i], f[i - 1] + T);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[N] + E);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst long long inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int N = 1e5 + 10; \nint a[N], nxt[N], n, e, t;\nlong long val;\nlong long seg[N << 2], lazy[N << 2], dp[N];\nvector<int> fnd[N];\nvoid relax(int id) {\n\tint lc = id * 2, rc = lc + 1;\n\tseg[lc] += lazy[id], lazy[lc] += lazy[id];\n\tseg[rc] += lazy[id], lazy[rc] += lazy[id];\n\tlazy[id];\n\treturn;\n}\nvoid add(int l, int r, int id = 1, int s = 0, int e = n) {\n\tif (l == r)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn;\n\t}\n\tif (e <= l || r <= s)\n\t\treturn;\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tadd(l, r, lc, s, mid);\n\tadd(l, r, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n}\nvoid upd(int p, int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tseg[id] = val;\n\t\tlazy[id] = 0;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\tif (p < mid)\n\t\tupd(p, lc, s, mid);\n\telse\n\t\tupd(p, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n\treturn;\n}\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint st = -1;\n\tn++;\n\tfor (int i = 0; i < n; i++) {\n\t\tval = inf;\n\t\tupd(i);\n\t\twhile ((a[i] - a[st + 1]) * 2 >= t)\n\t\t\tst++;\n\t\tif (st != -1)\n\t\t\tfnd[st].push_back(i);\n\t}\n\tst = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile ((a[st - 1] - a[i]) >= t)\n\t\t\tst--;\n\t\tnxt[i] = st;\n\t}\n//\tcout << \"HO\" << endl;\n\tval = t;\n\tupd(n - 1);\n\tfor (int i = n - 2; i >= 0; i--) {\n//\t\tcout << \"i = \" << i << endl;\n\t\tlong long toall = a[i + 1] - a[i], tosome = a[i + 2] - a[i + 1];\n\t\tval = toall, add(i + 1, n);\n\t\tif (tosome > 0)\n\t\t\tval = tosome, add(nxt[i + 1], n);\n\t\tfor (auto plc : fnd[i + 1]) {\n\t\t\tlong long dis = 1ll * (a[plc] - a[i + 1]) * 3 + 1ll * toall;\n\t\t\tval = dis + dp[plc], upd(plc);\n//\t\t\tcout << \"plc = \" << plc << \" : \" << dis << \" val = \" << val << endl;\n\t\t}\n\t\tdp[i] = seg[1], val = dp[i] + t;\n//\t\tcout << \"i = \" << i << \" : \" << a[i] << \" : \" << dp[i] << \" toall = \" << toall << \" tosome = \" << tosome << \" : \" << nxt[i + 1] << endl;\n\t\tupd(i);\n\t}\n\tcout << dp[0] + e - a[n - 1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n  using G = function<Monoid(Monoid, OperatorMonoid)>;\n  using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  int sz, height;\n  vector<Monoid> data;\n  vector<OperatorMonoid> lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n  LazySegmentTree(int n, const F f, const G g, const H h, const Monoid &M1, const OperatorMonoid OM0) : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while (sz < n) sz <<= 1, ++height;\n    data.assign(2*sz, M1);\n    lazy.assign(2*sz, OM0);\n  }\n\n  void set(int k, const Monoid &x) {\n    data[k+sz] = x;\n  }\n\n  void build() {\n    for (int k = sz-1; k>0; --k) {\n      data[k] = f(data[2*k+0], data[2*k+1]);\n    }\n  }\n\n  inline void propagate(int k) {\n    if (lazy[k] != OM0) {\n      lazy[2*k+0] = h(lazy[2*k+0], lazy[k]);\n      lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while (k >>= 1) data[k] = f(reflect(2*k+0), reflect(2*k+1));\n  }\n\n  inline void thrust(int k) {\n    for (int i = height; i>0; --i) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz-1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if (r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz-1);\n    Monoid L = M1, R = M1;\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) L = f(L, reflect(l++));\n      if (r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k+1);\n  }\n\n  template<typename C>\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while (a < sz) {\n      propagate(a);\n      Monoid nxt = type ? f(reflect(2*a+type), M) : f(M, reflect(2*a+type));\n      if (check(nxt)) a = 2*a + type;\n      else M = nxt, a = 2*a+1 - type;\n    }\n    return a - sz;\n  }\n\n  template<typename C>\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if (a <= 0) {\n      if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    int b = sz;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template<typename C>\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if (b >= sz) {\n      if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz-1);\n    int a = sz;\n    for (b += sz; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nvoid solve() {\n  int n, e, t; cin >> n >> e >> t;\n  vi arr(n); cin >> arr;\n\n  vi diff(n);\n  rep(i,n-1) diff[i] = arr[i+1] - arr[i];\n  diff.back() = e - arr.back();\n\n  auto f = [](const ll &a, const ll &b) { return max(a, b); };\n\n  LazySegmentTree<ll> seg(n+2, f, f, f, -t, -t);\n  vl dp(n+1, -(1LL<<60));\n  dp[0] = arr[0] * 2;\n  const int d = (t-1) / 2;\n\n  rep(i,n) {\n    int prev = upper_bound(ALL(arr), arr[i] + d) - arr.begin();\n    seg.update(prev, prev + 1, dp[i] - (t - (arr[prev - 1] - arr[i]) * 2));\n    seg.update(prev + 1, n+2, dp[i]);\n    chmax(dp[i+1], seg[i+1] + diff[i] * 2);\n  }\n\n  cout << 3LL * e - dp[n] << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MAXN = 1e6 + 100 ;\n \n \nlong long dp[MAXN] , tmp[MAXN] , nx[MAXN] , a[MAXN] ; \n \nint32_t main(){\n\t//ios_base::sync_with_stdio(0) ;\n\t//cin . tie(0) ; cout . tie(0) ; \n \n\tint n ; cin >> n ; \n\tint e , t ; cin >> e >> t ; \n\tfor(int i = 0 ; i < n ; i ++)\n\t\tcin >> a[i] ; \n\tint l = n - 1 ; \n\t//cout << \"Hir\" << endl ; \n\tfor(int i = n - 1 ; i >= 0 ; i --){\n\t\twhile(l > 0 && 2 * (a[i] - a[l - 1]) <= t)\n\t\t\tl -- ; \n\t\tnx[i] = l ; \n\t}\n\t//cout << \"Hir\" << endl ; \n\tmemset(dp , 63 , sizeof dp) ; \n\tmemset(tmp , 63 , sizeof tmp) ; \n\tdp[0] = 0 ; \n\ttmp[0] = -2 * a[0] ;\n\t//cout << 0 << ' ' << dp[0]<< ' '  << tmp[0]<< ' ' << '\\n' ; \n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tdp[i] = t + dp[nx[i - 1]] ;\n\t\tif(nx[i - 1]) dp[i] = min(dp[i] , 2 * a[i - 1] + tmp[nx[i - 1] - 1]) ;\n\t\ttmp[i] = min(tmp[i - 1] , dp[i] - 2 * a[i]) ; \n\t\t//cout << i << ' ' << dp[i] << ' ' << tmp[i] << '\\n' ; \n\t}\n\tcout << dp[n] + e ; \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=1e5+10;\nint n;\nLL e,t,x[N],dp[N],tt=1e18;\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline I mi(const I&a,const I&b){return a<b ? a : b;}\nint main()\n{\n//\tfreopen(\"Shik and Game.in\",\"r\",stdin);\n\tread(n,e,t);\n\tfor(RG int i=1;i<=n;i++) read(x[i]), dp[i]=2e9;\n\tfor(RG int i=1,j=0;i<=n;i++)\n\t{\n\t\twhile(2*(x[i]-x[j+1])>=t) \n\t\t{\n\t\t\ttt=mi(tt,dp[j]-2*x[j+1]);\n\t\t\tj++;\n\t\t}\n\t\tdp[i]=mi(dp[j]+t,tt+2*x[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, E, T;\nll x[100050];\nll dp[100050];\nint main() {\n    //cout.precision(10);\n    cin >> N >> E >> T;\n    for(int i = 1; i <= N; i++) {\n        dp[i] = 1e17;\n        cin >> x[i];\n    }\n    x[0] = 0;\n    int before = 1;\n    ll now = 1e17;\n    for(int i = 1; i <= N; i++) {\n        now += 2 * (x[i] - x[i - 1]);\n        while(2 * (x[i] - x[before]) >= T) {\n            now = min(now, dp[before - 1] + (x[i] - x[before - 1]) + 2 * (x[i] - x[before]));\n            //cout << i << \" \" << before << \" \" << now << endl;\n            before++;\n        }\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = dp[i - 1] + x[i] - x[i - 1] + T;\n        //cout << i << \" \" << dp[i] << endl;\n        //if(before < i - 1) dp[i] = min(dp[i], dp[before] + 2 * T + x[i] - x[before]);\n        dp[i] = min(dp[i], dp[before - 1] + (x[before] - x[before - 1]) + T + x[i] - x[before]);\n        //cout << i << \" \" << dp[i] << endl;\n        dp[i] = min(dp[i], now);\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[N] + E - x[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <bitset>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAXN = 100009;\nconst long long INF = 1000000000000000000;\n\nstruct SegmentTree {\n    long long tr_min[4 * MAXN];\n    long long tr_add[4 * MAXN];\n    int n;\n\n    SegmentTree(int n) : n(n) {\n        memset(tr_min, 0, sizeof(tr_min));\n        memset(tr_add, 0, sizeof(tr_add));\n    }\n\n    void setVal(int id, long long val) {\n        setVal(0, 0, n, id, val);\n    }\n\n    void setVal(int v, int vl, int vr, int id, long long val) {\n        push(v, vl, vr);\n        if (vl > id || vr <= id) {\n            return;\n        }\n        if (vr - vl == 1) {\n            tr_min[v] = val;\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        setVal(2 * v + 1, vl, vm, id, val);\n        setVal(2 * v + 2, vm, vr, id, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    void addTree(int l, int r, long long val) {\n        if (l > r)\n            return;\n        addTree(0, 0, n, l, r + 1, val);\n    }\n\n    long long getMin(int l, int r) {\n        return getMax(0, 0, n, l, r + 1);\n    }\n\n    void push(int v, int vl, int vr) {\n        tr_min[v] += tr_add[v];\n        if (vr - vl > 1) {\n            tr_add[2 * v + 1] += tr_add[v];\n            tr_add[2 * v + 2] += tr_add[v];\n        }\n        tr_add[v] = 0;\n    }\n\n    void addTree(int v, int vl, int vr, int l, int r, long long val) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return;\n        }\n        if (vl >= l && vr <= r) {\n            tr_add[v] += val;\n            push(v, vl, vr);\n            return;\n        }\n        int vm = (vl + vr) / 2;\n        addTree(2 * v + 1, vl, vm, l, r, val);\n        addTree(2 * v + 2, vm, vr, l, r, val);\n        tr_min[v] = min(tr_min[2 * v + 1], tr_min[2 * v + 2]);\n    }\n\n    long long getMax(int v, int vl, int vr, int l, int r) {\n        push(v, vl, vr);\n        if (vl >= r || l >= vr) {\n            return INF;\n        }\n        if (vl >= l && vr <= r) {\n            return tr_min[v];\n        }\n        int vm = (vl + vr) / 2;\n        long long max1 = getMax(2 * v + 1, vl, vm, l, r);\n        long long max2 = getMax(2 * v + 2, vm, vr, l, r);\n        return min(max1, max2);\n    }\n};\n\nlong long x[MAXN];\nlong long f[MAXN];\n\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    x[0] = 0;\n    f[0] = 0;\n    SegmentTree tree(n);\n    tree.addTree(0, 0, x[1] - x[0] + t);\n    int idt = 0;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = tree.getMin(0, i - 1);\n        if (i == n)\n            break;\n        int pidt = idt;\n        while ((x[i + 1] - x[idt + 1]) * 2 > t) {\n            tree.setVal(idt, x[i + 1] - x[idt] + (x[i + 1] - x[idt + 1]) * 2);\n            ++idt;\n        }\n        tree.setVal(i, f[i] + x[i + 1] - x[i] + t);\n        tree.addTree(idt, i - 1, x[i + 1] - x[i]);\n        tree.addTree(0, pidt - 1, 3 * (x[i + 1] - x[i]));\n    }\n    long long ans = f[n] + e - x[n];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define N (100000+1000)\n#define LL long long\nusing namespace std;\n\nLL n,e,t,f[N],a[N],Segt[N<<2],p;\n\nvoid Update(LL now,LL l,LL r,LL x,LL v)\n{\n\tif (l==r) {Segt[now]=v; return;}\n\tLL mid=(l+r)>>1;\n\tif (x<=mid) Update(now<<1,l,mid,x,v);\n\telse Update(now<<1|1,mid+1,r,x,v);\n\tSegt[now]=min(Segt[now<<1],Segt[now<<1|1]);\n}\n\nLL Query(LL now,LL l,LL r,LL l1,LL r1)\n{\n\tif (l>r1 || r<l1) return 1e17;\n\tif (l1<=l && r<=r1) return Segt[now];\n\tLL mid=(l+r)>>1;\n\treturn min(Query(now<<1,l,mid,l1,r1),Query(now<<1|1,mid+1,r,l1,r1));\n}\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&e,&t);\n\tfor (int i=1; i<=n; ++i)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\twhile (p<=i-1 && 2*(a[i]-a[p])>=t) Update(1,1,n,p,-2*a[p]),p++;\n\t\tLL temp=1e17;\n\t\ttemp=min(temp,Query(1,1,n,1,p-1));\n\t\tif (p<=i-1) temp=min(temp,Query(1,1,n,p,i-1)+t-2*a[i]);\n\t\tf[i]=min(temp+3*a[i],f[i-1]+a[i]-a[i-1]+t);\n\t\tUpdate(1,1,n,i,-a[i-1]+f[i-1]);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e-a[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nll A[MAX_N],DP[MAX_N];\n\nll n,E,T;\n\nll f(ll len){\n  if(2*len >= T) return 2*len;\n  return T;\n}\n\nint last;\n\nll g(int idx){\n  ll& x = DP[idx];\n  if(x >= 0) return x;\n  \n  int idx2 = lower_bound(A,A+n,A[idx]+T/2)-A;\n  idx2--;\n  if(idx2 <= idx) idx2 = idx+1;\n  \n  for(int i=idx2;i<=n;i++){\n    ll val = g(i) + f(A[i-1]-A[idx]);\n    if(x == -1 || val < x){\n      x = val;\n    } else {\n      break;\n    }\n  }\n  \n  return x;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n >> E >> T;\n  \n  last = n;\n  \n  for(int i=0;i<n;i++) cin >> A[i];\n  \n  for(int i=0;i<n;i++) DP[i] = -1;\n  \n  for(int i=n-1;i>=0;i--) g(i);\n  \n  cout << E+g(0) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector< vector<int> > vvi;\ntypedef vector<ll> vl;\ntypedef vector< vector<ll> > vvl;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n#define forv(i, v) forn(i, v.size())\n#define all(v) v.begin(), v.end()\n#define mp make_pair\n#define pb push_back\n\nconst ll INF = 1e18;\n\nint main() {\n#ifdef NEREVAR_PROJECT\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n;\n    ll t, e;\n    cin >> n >> e >> t;\n    vl x(n);\n    forn(i, n) {\n        scanf(\"%lld\", &x[i]);\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    vl minCF(n + 1, INF);\n    ll minC = INF;\n    forn(i, n) {\n        ll pos = i == 0 ? 0 : x[i - 1];\n        \n        minC = min(minC, minCF[i + 1]);\n        dp[i + 1] = min(dp[i + 1], x[i] * 3 + minC);\n        \n        int lf = i, rg = n - 1;\n        while (rg - lf > 1) {\n            int mid = (lf + rg) / 2;\n            if ((x[mid] - x[i]) * 2 <= t) {\n                lf = mid;\n            } else {\n                rg = mid - 1;\n            }\n        }\n        \n        int L = max(i, lf - 20);\n        int R = min(n, rg + 20);\n        \n        minCF[R] = min(minCF[R], dp[i] + x[i] - pos - x[i] * 3);\n        \n        for (int j = L; j < R; j++) {\n            ll delta = x[j] - x[i];\n            ll add = x[i] - pos + delta + max(delta * 2, t);\n            dp[j + 1] = min(dp[j + 1], dp[i] + add);\n        }\n    }\n    cout << dp[n] + e - x[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <climits>\n\nint x[100010];\nlong long dp[100010];\n\nint main(){\n  int N, E, T; scanf(\"%d%d%d\", &N, &E, &T);\n  for(int i = 1; i <= N; i++) scanf(\"%d\", &x[i]);\n  assert(N <= 2000);\n\n  for(int i = 1; i <= N; i++) dp[i] = LLONG_MAX;\n\n  for(int i = 1; i <= N; i++){\n    for(int j = 1; j <= i; j++){\n      int d1 = x[j] - x[j - 1];\n      int d2 = 2 * (x[i] - x[j]); if(d2 < T) d2 = T;\n      int d3 = x[i] - x[j];\n\n      long long v = dp[j - 1] + d1 + d2 + d3;\n      if(v < dp[i]) dp[i] = v;\n    }\n  }\n\n  printf(\"%lld\\n\", dp[N] + E - x[N]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nmultiset<LL> st1;\nmultiset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(st2.find(dp[last] - x[last] + t));\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template\n#include <bits/stdc++.h>\n#define rep_override(x, y, z, name, ...) name\n#define rep2(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rep3(i, l, r) for (int i = (int)(l); i < (int)(r); ++i)\n#define rep(...) rep_override(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define per(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\nconstexpr int inf = 1001001001;\nconstexpr ll INF = 3003003003003003003LL;\ntemplate <typename T> inline bool chmin(T &x, const T &y) {if (x > y) {x = y; return 1;} return 0;}\ntemplate <typename T> inline bool chmax(T &x, const T &y) {if (x < y) {x = y; return 1;} return 0;}\nstruct IOSET {IOSET() {cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10);}} ioset;\n\n// Main\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t;\n    vector<ll> x(n);\n    rep(i, n) cin >> x[i];\n    \n    x.push_back(e);\n    vector<ll> dp(n + 1, INF);\n    dp[n] = 0;\n    vector<ll> mn(n + 1, INF);\n    per(i, n) {\n        int idx = upper_bound(all(x), x[i] + t / 2) - x.begin();\n        if (idx == n + 1) {\n            dp[i] = t + e - x[i];\n        } else {\n            chmin(dp[i], t + x[idx] - x[i] + dp[idx]);\n            chmin(dp[i], mn[idx] - 3 * x[i]);\n        }\n        mn[i] = min(mn[i + 1], dp[i + 1] + 2 * x[i] + x[i + 1]);\n    }\n    \n    cout << dp[0] + x[0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint x[1000005];\nlong long int dp[1000005];\nint main(){\n\tint n,e,t;\n\tscanf(\"%d %d %d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++)\n\tdp[i]=1e18;\n\tdp[0]=t;\n\tscanf(\"%d\",&x[0]);\n\tfor(int i=1;i<n;i++)\n\tscanf(\"%d\",&x[i]),x[i]-=x[0];\n\tx[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=max(t,x[i]*2);\n\t\tint Max=i,Min=0;\n\t\twhile(1){\n\t\t\tint mid1=(Min*2+Max)/3,mid2=(Min+Max*2)/3;\n\t\t\tif(mid1==Min||mid2==Max)\n\t\t\tbreak;\n\t\t\tint a1=max(t,(x[i]-x[mid1+1])*2)+dp[mid1],a2=max(t,(x[i]-x[mid2+1])*2)+dp[mid2];\n\t\t\tif(a1<a2){\n\t\t\t\tMax=mid2;\n\t\t\t}\n\t\t\telse if(a1==a2){\n\t\t\t\tMax=mid1;\n\t\t\t\tMin=mid2;\n\t\t\t} \n\t\t\telse{\n\t\t\t\tMin=mid2;\n\t\t\t}\n\t\t}\n\t\tif(Min==-1)\n\t\tMin++;\n\t//\tprintf(\"%d %d\\n\",Max,Min);\n\t\tfor(int j=Min;j<Max;j++){\n\t//\t\tprintf(\"%d \",j);\n\t\t\tdp[i]=min(dp[i],max(t,(x[i]-x[j+1])*2)+dp[j]);\n\t\t}\n\t//\tprintf(\"\\n\");\n\t\t//printf(\"dp[%d] %lld\\n\",i,dp[i]);\n\t}\n\tprintf(\"%lld\",dp[n-1]+e);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[100005];\nint n,e,t;\nint x[100005];\nstruct SGT{\n\t#define SIZE 131072\n\tint f[SIZE<<1],ql,qr;\n\tvoid modify(int x,int v){\n\t\tx+=SIZE;f[x]=v;\n\t\twhile(x!=1){\n\t\t\tx>>=1;\n\t\t\tf[x]=min(f[x<<1],f[x<<1|1]);\n\t\t}\n\t}\n\tint _query(int L,int R,int k){\n\t\tif(R<ql||qr<L)return inf*inf;\n\t\tif(ql<=L&&R<=qr)return f[k];\n\t\treturn min(_query(L,(L+R)/2,k<<1),_query((L+R)/2+1,R,k<<1|1));\n\t}\n\tint query(int l,int r){\n\t\tif(l>r)return inf*inf;\n\t\tql=l;qr=r;return _query(0,SIZE-1,1);\n\t}\n}T1,T2;\nsigned main(){\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++)cin>>x[i];\n\tmemset(dp,inf,sizeof dp);\n\tdp[0]=0;T1.modify(0,-x[1]*2);T2.modify(0,0);\n\tfor(int i=1;i<=n;i++){\n\t\t/*\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j-1]+x[j]-x[j-1]+max(3ll*(x[i]-x[j]),x[i]-x[j]+t));\n\t\t}*/\n\t\tint L=0,R=i+1;\n\t\twhile(R-L>1){\n\t\t\tint mid=(L+R)/2;\n\t\t\tif(2ll*(x[i]-x[mid])>=t)L=mid;\n\t\t\telse R=mid;\n\t\t}\n\t\t//[0,L-1]\n\t\tdp[i]=min(dp[i],T1.query(0,L-1)+x[i]*3);\n\t\t//[L,i-1]\n\t\tdp[i]=min(dp[i],T2.query(L,i-1)+t+x[i]);\n\t\tT1.modify(i,dp[i]-x[i]-x[i+1]-x[i+1]); \n\t\tT2.modify(i,dp[i]-x[i]);\n\t}\n//\tfor(int i=1;i<=n;i++)cerr<<i<<\" \"<<dp[i]<<endl;\n\tcout<<dp[n]+e-x[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst long long inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int N = 1e5 + 10; \nint a[N], nxt[N], n, e, t;\nlong long val;\nlong long seg[N << 2], lazy[N << 2], dp[N];\nvector<int> fnd[N];\n//\nvoid relax(int id) {\n\tint lc = id * 2, rc = lc + 1;\n\tseg[lc] += lazy[id], lazy[lc] += lazy[id];\n\tseg[rc] += lazy[id], lazy[rc] += lazy[id];\n\tlazy[id] = 0;\n\treturn;\n}\nvoid add(int l, int r, int id = 1, int s = 0, int e = n) {\n\tif (e <= l || r <= s)\n\t\treturn;\n\tif (l <= s && e <= r) {\n\t\tseg[id] += val;\n\t\tlazy[id] += val;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tadd(l, r, lc, s, mid);\n\tadd(l, r, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n//\tcout << \"s = \" << s << \" e = \" << e << \" : \" << seg[id] << endl;\n}\nvoid upd(int p, int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tseg[id] = val;\n\t\tlazy[id] = 0;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\tif (p < mid)\n\t\tupd(p, lc, s, mid);\n\telse\n\t\tupd(p, rc, mid, e);\n\tseg[id] = min(seg[lc], seg[rc]);\n\treturn;\n}\nvoid open(int id = 1, int s = 0, int e = n) {\n\tif (e - s == 1) {\n\t\tcout << \"s = \" << s << \" : \" << seg[id] << endl;\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2, lc = id * 2, rc = lc + 1;\n\trelax(id);\n\topen(lc, s, mid);\n\topen(rc, mid, e);\n}\n//\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n >> e >> t;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tint st = -1;\n\tn++;\n\tfor (int i = 0; i < n; i++) {\n\t\tval = inf;\n\t\tupd(i);\n\t\twhile ((a[i] - a[st + 1]) * 2 >= t)\n\t\t\tst++;\n\t\tif (st != -1)\n\t\t\tfnd[st].push_back(i);\n\t}\n\tst = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile ((a[st - 1] - a[i]) >= t)\n\t\t\tst--;\n\t\tnxt[i] = st;\n\t}\n//\tcout << \"HO\" << endl;\n\tval = t;\n\tupd(n - 1);\n\tfor (int i = n - 2; i >= 0; i--) {\n//\t\tcout << \"i = \" << i << endl;\n\t\tlong long toall = a[i + 1] - a[i], tosome = a[i + 2] - a[i + 1];\n\t\tval = toall, add(i + 1, n);\n\t\tif (tosome > 0)\n\t\t\tval = tosome, add(nxt[i + 1], n);\n\t\tfor (auto plc : fnd[i + 1]) {\n\t\t\tlong long dis = 1ll * (a[plc] - a[i + 1]) * 3 + 1ll * toall;\n\t\t\tval = dis + dp[plc], upd(plc);\n//\t\t\tcout << \"plc = \" << plc << \" : \" << dis << \" val = \" << val << endl;\n\t\t}\n//\t\tcout << \" open : \" << endl;\n//\t\topen();\n//\t\tcout << endl;\n\t\tdp[i] = seg[1], val = dp[i] + t;\n//\t\tcout << \"i = \" << i << \" a[i] =  \" << a[i] << \" dp = \" << dp[i] << \" toall = \" << toall << \" tosome = \" << tosome << \" nxt = \" << nxt[i + 1] << endl;\n\t\tupd(i);\n\t}\n\tcout << dp[0] + e - a[n - 1];\n//\tcout << endl;\n//\topen();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n#define MP make_pair \n#define PB push_back \n#define INF (1000000007) \n#define eps 1e-8\n#define MOD (1000003)\n#define IOS ios::sync_with_stdio(false)\n\ntypedef pair<int,int> pii ;\ntypedef pair<double,double> pdd ;\ntypedef long long ll ;\n\nll n,e,t;\nll dp[100005],p[100005];\nll mx=1e18;\nmultiset<ll>s;\n\nint main()\n{\n\tIOS;\n\tcin>>n>>e>>t;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tdp[0]=0;\n\tll pos=1;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\ts.insert(dp[i-1]);\n\t\twhile(pos<=i)\n\t\t{\n\t\t\tif((p[i]-p[pos])*2>t) \n\t\t\t{\n\t\t\t\tmx=min(dp[pos-1]-p[pos]*2,mx);\n\t\t\t\ts.erase(s.find(dp[pos-1]));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdp[i]=min(*s.begin()+t,mx+2*p[i]);\n\t}\n\tcout<<dp[n]+e;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<climits>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 2005\n#define M 10005\n#define INF 1000000000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint is_mul_overflow(ll a, ll b) {\n        return LLONG_MAX / a < b;\n}\n\nint x[N];\nll dp[N][N];\nint n,e,t;\nll get(int a,int b)\n{\n    int d = x[b]-x[a];\n    return t>2*d?t-d:d+d;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n>>e>>t)\n    {\n        FOR(i,1,n)cin>>x[i];\n        FOR(i,0,n)FOR(j,0,n)dp[i][j] = INF;\n        x[0] = 0;\n        dp[0][0] = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,0,i-1)\n            {\n                dp[i][j] = min(dp[i][j],dp[i-1][j]+x[i]-x[i-1]);\n                dp[i][i] = min(dp[i][i],dp[i][j]+get(j+1,i));\n            }\n            //cout<<i<<\" \"<<dp[i][i]<<endl;\n        }\n        //cout<<dp[n][n]<<endl;\n        cout<<dp[n][n]+e-x[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\nconst int maxn = 1e5 + 100;\nconst ll inf = 2e18 + 13;\n\nll dp[maxn] , partial_min[maxn] , a[maxn];\n\nint main()\n{\n    fill(dp , dp + maxn , inf);\n    ll n , e , T;\n    cin >> n >> e >> T;\n    e *= 2;\n    T *= 2;\n    for(int i = 1; i <= n; i++)\n        cin >> a[i] , a[i] *= 2;\n    dp[0] = 0;\n    int pt = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        while(pt + 1 < i && a[pt + 1] <= a[i] - T / 2)\n            pt++;\n        if(!pt)\n            dp[i] = T;\n        else\n            dp[i] = min(dp[pt] + T , partial_min[pt] + a[i] * 2);\n        partial_min[i] = min(partial_min[i - 1] , dp[i - 1] - 2 * a[i]);\n    }\n    cout << (dp[n] + e) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n\nusing namespace std;\n\nlong long int N;\nlong long int E;\nlong long int T;\nlong long int dp[200001];\nlong long int place[200001];\n\nlong long int min(long long int a, long long int b) {\n\tif (a > b)return b;\n\treturn a;\n}\n\nlong long int max(long long int a, long long int b) {\n\tif (a > b)return a;\n\treturn b;\n}\n\nint main() {\n\tcin >> N >> E >> T;\n\tfor (int i = 1; i <= N; i++)cin >> place[i];\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = ULONG_MAX;\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = min(max(place[i] + (place[i] - place[1]) * 2, T+place[i]),T*i+place[i]);\n\t\t//cout<< i<<\" \"<<  dp[i] << \"\\n\";\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = max(i,1); j <= N; j++) {\n\t\t\tdp[j] = min(dp[j], dp[i] + max((place[j] - place[i]) * 3, T + place[j] - place[i]));\n\t\t\t//cout << j << \" \" << dp[j] << \"\\n\";\n\t\t\tdp[j] = min(dp[j], dp[j - 1] + T + place[j] - place[j - 1]);\n\t\t//\tcout << j << \" \" << dp[j] << \"\\n\";\n\t\t}\n\t}\n\tcout << dp[N] + E - place[N]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    LazySegmentTree seg1(vector<ll>(N+1,0)),seg2(vector<ll>(N+1,0));\n    X[N+1] = E;\n    dp[0] = X[1];\n    seg1.add(0,1,dp[0]);\n    seg2.add(0,1,dp[0]);\n    for(int i=1;i<=N;i++){\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        dp[i] = dp[i-1]+T+X[i+1]-X[i];\n        if(id!=i) dp[i] = min(dp[i],seg2.getmin(id,i)+T+X[i+1]-X[i]);\n        if(id>1) dp[i] = min(dp[i],seg1.getmin(0,id-1)+X[i+1]-X[i]);\n        seg1.add(i,i+1,dp[i]);\n        seg1.add(0,i,3*(X[i+1]-X[i]));\n        seg2.add(i,i+1,dp[i]);\n        seg2.add(0,i,X[i+1]-X[i]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, e, t, x[100002];\nLL dp[100001];\nint m[100001];\nconst LL MAX = 1000000000000000LL;\n\nstd::multiset<LL> ms;\n\nLL mi1_v = MAX;\nLL mi1(int i) {\n\tincID(j, m[i - 1], m[i]) { setmin(mi1_v, dp[j] - 2 * x[j + 1]); }\n\treturn mi1_v;\n}\n\nLL mi2(int i) {\n\tincID(j, m[i - 1], m[i]) {\n\t\tauto it1 = ms.find(dp[j]);\n\t\tauto it2 = it1;\n\t\tit2++;\n\t\tms.erase(it1, it2);\n\t}\n\tms.insert(dp[i - 1]);\n\treturn *ms.begin();\n\t\n\t/*\n\tms.clear();\n\tincID(j, m[i], i) { ms.insert(dp[j]); }\n\treturn *(ms.begin());\n\t*/\n}\n\nint main() {\n\tscanf(\"%lld%lld%lld\", &n, &e, &t);\n\tinc1(i, n) { scanf(\"%lld\", &x[i]); }\n\t\n\tint mm = 0;\n\tinc1(i, n) {\n\t\twhile( (x[i] - x[mm + 1]) * 2 > t) { mm++; }\n\t\tm[i] = mm;\n\t}\n\t\n\tinc1(i, n) {\n\t\tdp[i] = min(mi1(i) + 2 * x[i], mi2(i) + t);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n] + e);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 200010\nll n,d[N],t,e;\nll BN(ll key){\n    ll l=-1,r=n,m=(l+r)/2;\n    for(;l<r-1;m=(l+r)/2){\n\tif(d[m+1]*2<key)l=m;\n\telse r=m;\n    }\n    return l;\n}\nll f[N],g[N];\nint main(){\n    cin>>n>>e>>t; d[0]=0;\n    lol(i,n)cin>>d[i+1];\n    lol(i,N)f[i]=1e18; f[0]=0,g[0]=-2*d[1];\n    for(ll i=1;i<=n;i++){\n\tll surf=BN(d[i]*2-t);\n\tll res=1e17;\n\tif(surf+1<i)chmin(res,f[surf+1]+t);\n\tif(~surf)chmin(res,g[surf]+2*d[i]);\n\tf[i]=res;\n\tg[i]=min(g[i-1],f[i]-2*d[i+1]);\n    }\n    cout<<f[n]+e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define int ll\nconst int maxn =2e5;\nint n,e,t,dp[maxn],x[maxn],bt[4*maxn];\nvoid up(int u,int l,int r,int x,int y)\n{\n\tif(r-l==1)\n\t{\n\t\tbt[u]=y;\n\t\treturn ;\n\t}\n\tint md=(l+r)>>1;\n\tif(x<md)up(2*u,l,md,x,y);\n\telse up(2*u+1,md,r,x,y);\n\tbt[u]=min(bt[2*u],bt[2*u+1]);\n}\nint query(int u,int l,int r,int f,int s)\n{\n\tif(l>=s||f>=r)return 1e18;\n\tif(f<=l&&r<=s)\n\t{\n\t\treturn bt[u];\n\t}\n\tint md=(l+r)>>1;\n\treturn min(query(2*u,l,md,f,s),query(2*u+1,md,r,f,s));\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n>>e>>t;\n    rep(i,0,n)cin>>x[i];\n    int v=0;\n    while(v<n&&x[v]-x[0]<(t+1)/2)v++;\n    if(v==n)\n    {\n    \tcout<<t+e;\n    \texit(0);\n    }\n    int g=0;\n    up(1,0,n,0,-2*x[0]);\n    rep(j,1,v)\n    {\n        if(x[v]-x[j]>=(t+1)/2)up(1,0,n,j,-2*x[j]+t);\n        else\n        {\n            up(1,0,n,j,2*t);\n            break;\n        }\n    }\n    rep(i,v,n)\n    {\n        while(x[i]-x[g]>=(t+1)/2)g++;\n    \tdp[i]=2*x[i]+query(1,0,n,0,g+1);\n    \tup(1,0,n,i,dp[i-1]-2*x[i]);\n    \tif(g>=v)dp[i]=min(dp[i],dp[g]+t);\n        else dp[i]=min(dp[i],2*t);\n    }\n    cout<<dp[n-1]+e;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class Monoid> struct RMQ {\n    const Monoid INF;\n    int SIZE_R;\n    vector<pair<Monoid,int> > dat;\n    \n    RMQ(int n, const Monoid &inf): INF(inf) { init(n); }\n    void init(int n) {\n        SIZE_R = 1;\n        while (SIZE_R < n) SIZE_R *= 2;\n        dat.assign(SIZE_R * 2, pair<Monoid,int>(INF, -1));\n    }\n    \n    /* set, a is 0-indexed */\n    void set(int a, const Monoid &v) { dat[a + SIZE_R] = make_pair(v, a); }\n    void build() {\n        for (int k = SIZE_R - 1; k > 0; --k) {\n            dat[k] = min(dat[k*2], dat[k*2+1]);\n        }\n    }\n    \n    /* update, a is 0-indexed */\n    void update(int a, const Monoid &v) {\n        int k = a + SIZE_R;\n        dat[k] = make_pair(v, a);\n        while (k >>= 1) dat[k] = min(dat[k*2], dat[k*2+1]);\n    }\n    \n    /* get {min-value, min-index}, a and b are 0-indexed */\n    pair<Monoid,int> get(int a, int b) {\n        pair<Monoid,int> vleft = make_pair(INF, -1), vright = make_pair(INF, -1);\n        for (int left = a + SIZE_R, right = b + SIZE_R; left < right; left >>= 1, right >>= 1) {\n            if (left & 1) vleft = min(vleft, dat[left++]);\n            if (right & 1) vright = min(dat[--right], vright);\n        }\n        return min(vleft, vright);\n    }\n    inline Monoid operator [] (int a) { return dat[a + SIZE_R].first; }\n    \n    /* debug */\n    void print() {\n        for (int i = 0; i < SIZE_R; ++i) {\n            Monoid val = (*this)[i];\n            if (val < INF) cout << val;\n            else cout << \"INF\";\n            if (i != SIZE_R-1) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n\nconst long long INF = 1LL<<60;\nint N;\nlong long T, E;\nvector<long long> x;\n\nlong long solve() {\n    vector<long long> dp(N+1, INF);\n    RMQ<long long> r1(N+1, INF), r2(N+1, INF);\n    dp[0] = 0;\n    r1.update(0, -x[0] * 2);\n    r2.update(0, 0);\n    for (int i = 1; i <= N; ++i) {\n        int ut = upper_bound(x.begin(), x.end(), x[i-1] - (T+1)/2) - x.begin() - 1;\n        int lt = lower_bound(x.begin(), x.end(), x[i-1] - (T-1)/2) - x.begin();\n        chmin(ut, i-1);\n        chmin(dp[i], r1.get(0, ut+1).first + x[i-1] * 3);\n        chmin(dp[i], r2.get(lt, i).first + x[i-1] + T);\n        r1.update(i, dp[i] - x[i] * 2 - x[i-1]);\n        r2.update(i, dp[i] - x[i-1]);\n    }\n    return dp[N] + (E - x[N-1]);\n}\n\nint main() {\n    cin >> N >> E >> T;\n    x.resize(N);\n    for (int i = 0; i < N; ++i) cin >> x[i];\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int64 INF = (1LL<<60);\n\nint64 N, E, T;\n\nvector<int64> pref;\nvector<int64> dp;\nvector<int64> x;\n\nint main() {\n    cin >> N >> E >> T;\n\n    pref.resize(N + 1);\n    x.resize(N + 1);\n\n    for (int i = 0; i < N; i++) {\n        cin >> x[i];\n    }\n    x[N] = E;\n\n    for (int i = N - 1; i >= 0; i--) {\n        pref[i] = pref[i + 1] + (x[i + 1] - x[i]);\n    }\n\n    dp.resize(N + 1);\n\n    int j = N;\n\n    int64 suf_min = INF;\n\n    set<pair<int64, int64>> heap;\n\n    heap.insert(make_pair(dp[N] + T, N));\n\n    for (int i = N - 1; i >= 0; i--) {\n        // Query max T\n        // Query max distance\n        // Update\n\n        dp[i] = (1LL<<60);\n\n        while (j > i && 2 * (pref[i] - pref[j-1]) > T) {\n            suf_min = min(suf_min, - 2 * pref[j - 1] - pref[j] + dp[j]);\n            j--;\n        }\n\n        dp[i] = min(dp[i], 3 * pref[i] + suf_min);\n\n        while(!heap.empty()) {\n            auto el = *heap.begin();\n            if (2 * (pref[i] - pref[el.second - 1]) > T) {\n                heap.erase(heap.begin());\n            } else {\n                dp[i] = min(dp[i], pref[i] + el.first);\n                break;\n            }\n        }        \n\n        heap.insert(make_pair(-pref[i] + dp[i] + T, i));\n\n        // int64 d = pref[i] - pref[j-1];\n        // int64 l = pref[i] - pref[j];\n\n        // if (2 * d <= T) {\n        //     dp[i] = min(dp[i], T + l + dp[j]);\n        // } else {\n        //     dp[i] = min(dp[i], 2 * d + l + dp[j]);\n        // }\n\n        //}\n    }\n\n    cout << dp[0] + x[0] << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#define ll long long\n#define inf 1e9\n#define eps 1e-10\n#define mod 9901\n#define mkp make_pair\nusing namespace std;\nint i,j,k,m,s,t,n,ans1,ans2,n1,nn,m1,mx;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint kabs(int a)\n{\n   if (a<0) return -a;\n   return a; \n}\nvoid add(int &x,int y)\n{\n   x+=y;\n   if (x>=mod) x-=mod;\n}\nvoid dec(int &x,int y)\n{\n\tx-=y;\n\tif (x<0) x+=mod;\n}\nint a[101000];\nll f[101000];\nint main()\n{\n\tint e;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tj=0;\n\tll s=1e18;\n\tfor (i=1;i<=n;i++)\n\t\tf[i]=1e18;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\twhile (2*(a[i]-a[j+1])>=t)\n\t\t\ts=min(s,f[j]-2ll*a[j+1]),j++;\n\t\tf[i]=min(f[j]+t,2ll*a[i]+s);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 1e5 + 7;\nint n, E, T;\nLL f[N], x[N];\nint q[N], hd = 1, tl;\nint main() {\n#ifdef fwat\n#endif\n\tn = gi(), E = gi(), T = gi();\n\tif(n > 2000) return puts(\"gg\"), 0;\n\tmemset(f, 0x3f, sizeof f); f[0] = 0;\n\trep(i, 1, n) x[i] = gi();\n\tLL mi = 1e18;\n\tq[++tl] = 0;\n\tfor(int i = 1, j = 0; i <= n; ++i) {\n\t\tfor(; j < i && 2 * (x[i] - x[j + 1]) >= T; ++j) Min(mi, f[j] - 2 * x[j + 1]);\n\t\tMin(f[i], mi + 2 * x[i]);\n\t\twhile(hd <= tl && 2 * (x[i] - x[q[hd] + 1]) >= T) ++hd;\n\t\tif(hd <= tl)\n\t\t\tMin(f[i], f[q[hd]] + T);\n\t\tfor(; hd <= tl && f[i] <= f[q[tl]]; --tl);\n\t\tq[++tl] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n] + E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint N, E, T;\n\twhile(cin >> N >> E >> T){\n\t\tlong long res = E;\n\t\tvector<int> x(N);\n\t\tfor(int i=0;i<N;i++) cin >> x[i];\n\t\tvector<long long> dp(N+1);\n\t\tvector<long long> dp2(N);\n\t\tdp[N-1] = E+T; dp[N] = E;\n\t\tdp2[N-1] = dp[N] + 2*x[N-1];\n\t\tint thr = N-1;\n\t\tfor(int i=N-2;i>=0;i--){\n\t\t\twhile(2*(x[thr] - x[i]) > T) --thr;\n\t\t\tdp[i] = T+dp[thr+1];\n\t\t\tif(thr+1 < N) dp[i] = min(dp[i], dp2[thr+1]-2*x[i]);\n\t\t\tdp2[i] = min(dp2[i+1], dp[i+1] + 2*x[i]);\n\t\t}\n\t\tcout << dp[0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[200000];\nint main() {\n#define int long long\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tassert(n <= 2000);\n\tvector<long long> inputs;\n\tinputs.push_back(0);\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t\tdp[i + 1] = 1e18;\n\t}\n\tn++;\n\tdp[0] = 0;\n\tlong long now_cost = 1e18;//t < 2*(inputs[i] - inputs[q+1])を管理,cost =  2 * inputs[i] + now_cost;\n\tpriority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> next;//t >= 2*(inputs[i] - inputs[q+1])を管理,cost =  t + (inputs[i] - next.second)\n\tnext.push(make_pair(0, 1));\n\tint now_back = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (2 * (inputs[i] - inputs[now_back + 1]) > t) {\n\t\t\tlong long geko = -2 * inputs[now_back + 1] + dp[now_back];\n\t\t\tnow_cost = min(now_cost, geko);\n\t\t\tnow_back++;\n\t\t}\n\t\tdp[i] = min(dp[i],now_cost + 2 * inputs[i]);\n\t\twhile (next.empty() == false&&2 * (inputs[i] - inputs[next.top().second])> t) {\n\t\t\tnext.pop();\n\t\t}\n\t\t/*\n\t\tif (next.size() != 0) {\n\t\t\tdp[i] = min(dp[i], next.top().first + inputs[i] + t);\n\t\t}\n\t\t*/\n\t\t\n\t\tfor (int q = now_back; q < i; ++q) {\n\t\t\tlong long cost = inputs[i] - inputs[q + 1] + t - (inputs[i] - inputs[q + 1]);\n\t\t\tdp[i] = min(dp[i], dp[q] + cost);\n\t\t}\n\t\t\n\t\tif(i != n-1)\n\t\tnext.push(make_pair(dp[i] - inputs[i + 1], i + 1));\n\t}\n\tcout << dp[n - 1] + e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 1e18;\nconst int N = 100010;\n\nLL f[N];\n\nint x[N];\nint n, T, E;\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &E, &T);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\tint p = 0;\n\tLL mn = INF;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = INF;\n\t\twhile(2 * (x[i] - x[p + 1]) > T) {\n\t\t\tmn = min(f[p] - 2 * x[p + 1], mn);\n\t\t\t++p;\n\t\t}\n\t\tf[i] = min(f[i], mn + 2 * x[i]);\n\t\tf[i] = min(f[i], f[p] + T);\n\t}\n\tcout << f[n] + E << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst double pi = 3.141592653589793;\n\nll n,e,t;\nll x[2005];\nll dp[2005][2005];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> e >> t;\n    if (n>2000) return 0;\n    rep(i,n) cin >> x[i+1];\n    rep(i,n+2)rep(j,n+2) dp[i][j]=1e15;\n    dp[0][0]=0;\n    rep(i,n+1){\n        ll nx=x[i+1]-x[i];\n        rep(j,i+1){\n            dp[i+1][j]=min(dp[i+1][j],dp[i][j]+nx);\n            if (i==j) continue;\n            if (2*(x[i]-x[j+1])>=t){\n                dp[i][i]=min(dp[i][i],dp[i][j]+2*(x[i]-x[j+1]));\n            }\n            else{\n                dp[i][i]=min(dp[i][i],dp[i][j]+t);\n            }\n                /*\n                if (2*(x[i+1]-x[j])>=t){\n                    dp[i+1][j]=min(dp[i+1][j],dp[i+1][j-1]+x[i+1]-x[j]);\n                }\n                else{\n                    dp[i+1][j]=min(dp[i+1][j],dp[i+1][j-1]+t-(x[i+1]-x[j]));\n                }\n                */\n                /*\n                if (2*(x[i]-x[j])>=t) {\n                    dp[i+1][j]=min(dp[i+1][j],dp[i][j-1]+nx+2*(x[i]-x[j]));\n                }\n                else {\n                    dp[i+1][j]=min(dp[i+1][j],dp[i][j-1]+nx+t);\n                }\n                */\n        }\n    }\n    //rep(i,n+1)rep(j,n+1) cout << dp[i][j] << endl;\n    //cout << dp[2][2] << endl;\n    cout << dp[n][n]+e-x[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define N 100010\n#define INF (1LL << 60)\n#define LL long long\nusing namespace std;\nint n, e, t;\nint x[N];\nLL dp[N];\nset<LL> st1;\nset<LL> st2;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tdp[0] = 0;\n\tx[0] = 0;\n\tint last = 0;\n\tst1.insert(- 2LL * x[1]);\n\tst2.insert(t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (last + 1 <= i && 2LL * (x[i] - x[last + 1]) >= t) {\n\t\t\tst1.insert(dp[last] - x[last] - 2LL * x[last + 1]);\n\t\t\tst2.erase(dp[last] - x[last] + t);\n\t\t\t++last;\n\t\t}\n\t\tif (last - 1 >= 0) dp[i] = min(*st1.begin() + 3LL * x[i], *st2.begin() + x[i]);\n\t\telse dp[i] = *st2.begin() + x[i];\n\t\tst2.insert(dp[i] - x[i] + t);\n//cout << dp[i] << ' ';\n\t}\n//cout << endl;\n\t\n\tcout << dp[n] + e - x[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e18;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1], node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    ll getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return inf;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n};\n\n\nint N;\nll T,E;\n\nint main(){\n    cin >> N >> E >> T;\n    vector<ll> X(N+2,0),dp(N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> X[i];\n        dp[i] = inf;\n    }\n    LazySegmentTree seg1(vector<ll>(N+1,0)),seg2(vector<ll>(N+1,0));\n    X[N+2] = E;\n    dp[0] = X[1];\n    seg1.add(0,1,dp[0]);\n    seg2.add(0,1,dp[0]);\n    for(int i=1;i<=N;i++){\n        int id = lower_bound(X.begin(),X.end(),X[i]-T/2)-X.begin();\n        dp[i] = dp[i-1]+T+X[i+1]-X[i];\n        if(id!=i) dp[i] = min(dp[i],seg2.getmin(id,i)+T+X[i+1]-X[i]);\n        if(id>1) dp[i] = min(dp[i],seg1.getmin(0,id-1)+X[i+1]-X[i]);\n        seg1.add(i,i+1,dp[i]);\n        seg1.add(0,i,3*(X[i+1]-X[i]));\n        seg2.add(i,i+1,dp[i]);\n        seg2.add(0,i,X[i+1]-X[i]);\n    }\n//    for(int i=0;i<=N;i++) cerr << dp[i] << (i!=N? \" \":\"\\n\");\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nint n, E, T, a[N], dp[N];\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> E >> T;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tmemset(dp, 31, sizeof dp);\n\tdp[n + 1] = 0;\n\ta[n + 1] = E;\n\tfor (int i = n; i >= 1; i--){\n\t\tint mx = 0;\n\t\tfor (int j = i; j <= n; j++){\n\t\t\t//cout << i << ' ' << j << ' ' << mx << '\\n';\n\t\t\tdp[i] = min(dp[i], dp[j + 1] + 3 * (a[j] - a[i]) + a[j + 1] - a[j] + max(0ll, T - 2 * a[j] + 2 * a[i]));\n\t\t\t//cout << i << ' ' << j <<  ' ' << T - 2 * a[j] + 2 * a[i] << '\\n';\n\t\t}\n\t\t//cout << dp[i] << '\\n';\n\t}\n\tcout << dp[1] + a[1];\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\n// hj cho minh bulli bai nay\nll dp[200005], a[200005];\nint st[800005][2]; \nvoid update(ll root, ll l, ll r, ll i, ll val, ll id){\n\tif (i < l || r < i) return;\n\tif (l == r){\n\t\tst[root][id] = val; return;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(root * 2 + 1, l, mid, i, val, id);\n\tupdate(root * 2 + 2, mid + 1, r, i, val, id);\n\tst[root][id] = min(st[root * 2 + 1][id], st[root * 2 + 2][id]);\n}\nll query(ll root, ll l, ll r, ll u, ll v, ll id){\n\tif (v < l || r < u) return 1e18;\n\tif (u <= l && r <= v) return st[root][id];\n\tll mid = (l + r) / 2;\n\treturn min(query(root * 2 + 1, l, mid, u, v, id), query(root * 2 + 2, mid + 1, r, u, v, id));\n}\nint main(){\n\tfastio;\n\tll n, e, t; cin >> n >> e >> t;\n\tfor (ll i = 1; i <= n; i++) cin >> a[i];\n\tdp[0] = 0;\n\tupdate(0, 0, n - 1, 0, dp[0] - 2 * a[1], 0);\n\tfor (ll i = 1; i <= n; i++){\n\t\tdp[i] = 1e18;\n\t\tll lw; \n\t\tll l = 0, r = i - 1;\n\t\twhile (l < r){\n\t\t\tll mid = (l + r) / 2;\n\t\t\tif ((a[i] - a[mid]) * 2 <= t) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tlw = l;\n\t\tdp[i] = min(query(0, 0, n - 1, 0, lw - 1, 0) + 3 * a[i], query(0, 0, n - 1, lw, i - 1, 1) + a[i] + t);\n\t\tupdate(0, 0, n - 1, i, dp[i] - 2 * a[i + 1] - a[i], 0); update(0, 0, n - 1, i, dp[i] - a[i], 1);\n\t}\n\tcout << dp[n] + (e - a[n]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nusing namespace std;\n\nint n;\nlong long a[N];\nlong long d[N];\nlong long E, T;\nlong long pref[N];\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> E >> T;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        long long inf = 1e18;\n        pref[0] = inf;\n        for(int i = 1, h = 0; i <= n; i++){\n                d[i] = inf;\n                pref[i] = pref[i - 1];\n                while(2 * (a[i] - a[h + 1]) >= T){\n                        h += 1;\n                }\n                if(h > 0){\n                        d[i] = 3 * a[i] + pref[h];\n                }\n\n                for(int dx = -50; dx <= 50; dx++){\n                        int j = h + dx;\n                        if(j < 1 || j > i){\n                                continue;\n                        }\n                        long long D = a[i] - a[j];\n                        d[i] = min(d[i], d[j - 1] + D + max(D * 2, T) + a[j] - a[j - 1]);\n                }\n                pref[i] = min(pref[i], - 2 * a[i] - a[i - 1] + d[i - 1]);\n        }\n        cout << d[n] + E - a[n] << \"\\n\";\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Bifunctor (first)\nimport Data.Bool      (bool)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go e\n  where\n    go s []  = s\n    go s [_] = s + t\n    go s xs = uncurry go . first (s +) $ inner 1 0 . head <*> id $ xs\n    inner k l b (x : xs)\n      | 2 * d <= s = inner (succ k) d b xs\n      | otherwise  = (bool (min (pred k * t) (2 * l)) t (k == 2), x : xs)\n      where\n        d = x - b\n        s = k * t\n    inner k l _ _  = (min (pred k * t) (2 * l), [])\n"
  },
  {
    "language": "Haskell",
    "code": "module D where\n\nimport Control.Monad\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    when (n > 2000) undefined\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go e []\n  where\n    go x js (i : is)\n      | null is   = z\n      | otherwise = go z ((i, x) : js) is\n      where\n        z = dp js i (x + t)\n\n    dp              []  _ = id\n    dp ((j, x) : js) i\n      | t > 2 * d = next dp  id (x + t)\n      | otherwise = next dp2 (subtract $ 2 * i) (x - 2 * j)\n      where\n        d = i - j\n        next f g = flip $ (f js i .) . flip min . g\n\n    dp2              []  i = (2 * i +)\n    dp2 ((j, x) : js) i = dp2 js i . min (x - 2 * j)\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    when (n > 2000) undefined\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go e []\n  where\n    go x js (i : is)\n      | null is   = z\n      | otherwise = go z ((i, x) : js) is\n      where\n        z = dp js i (x + t)\n\n    dp              []  _ = id\n    dp ((j, x) : js) i\n      | t > 2 * d = next dp  id (x + t)\n      | otherwise = next dp2 (subtract $ 2 * i) (x - 2 * j)\n      where\n        d = i - j\n        next f g = flip $ (f js i .) . flip min . g\n\n    dp2           []  i = (2 * i +)\n    dp2 ((j, x) : js) i = dp2 js i . min (x - 2 * j)\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Bifunctor (bimap, first)\nimport Data.Maybe     (fromJust, fromMaybe, listToMaybe)\n\nimport Control.DeepSeq (deepseq)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = negate . fromJust . inner (Just (-e), Nothing) []\n\n    inner dp js      []  = fst dp\n    inner dp js (i : is) = inner (deepseq dp (x, y)) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        l   = snd <$> listToMaybe (init js')\n        x  = max `uncurry` bimap (?- t) (?- 2 * i) (fromMaybe dp l)\n        y  = max `uncurry` first (?+ 2 * i) dp\n\nm ?+ x = deepseq <*> id $ (x +)      <$> m\nm ?- x = deepseq <*> id $ subtract x <$> m\ninfixl 6 ?+, ?-\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Bifunctor (bimap, first)\nimport Data.Maybe     (fromJust, fromMaybe, listToMaybe)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = negate . fromJust . inner (Just (-e), Nothing) []\n\n    inner dp js      []  = fst dp\n    inner dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        l   = snd <$> listToMaybe (init js')\n        x   = max `uncurry` bimap (?- t) (?- 2 * i) (fromMaybe dp l)\n        y   = max `uncurry` first (?+ 2 * i) dp\n\nm ?+ x = (x +) <$> m\nm ?- x = subtract x <$> m\ninfixl 6 ?+, ?-\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Data.Bool  (bool)\nimport Data.Maybe (fromMaybe, listToMaybe)\n\nimport Data.Bifunctor (bimap, first)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = inner (e, maxBound) []\n\n    inner !dp js      []  = fst dp\n    inner !dp js (i : is) = inner (x, y) js' is\n      where\n        p    = i - succ t `div` 2\n        !js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        !l   = snd <$> listToMaybe (init js')\n        !x   = min `uncurry` bimap (+ t) (restrict . (+ 2 * i)) (fromMaybe dp l)\n        !y   = min `uncurry` first (subtract $ 2 * i) dp\n\nrestrict :: Int -> Int\nrestrict = until (0 <=) (const maxBound)\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Bifunctor (bimap, first)\nimport Data.Maybe     (fromJust, fromMaybe, listToMaybe)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = negate . fromJust . inner (Just (-e), Nothing) []\n\n    inner dp js      []  = fst dp\n    inner dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = seq js $ dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        l   = snd <$> listToMaybe (init js')\n        x   = max `uncurry` bimap (?- t) (?- 2 * i) (fromMaybe dp l)\n        y   = max `uncurry` first (?+ 2 * i) dp\n\nm ?+ x = (x +) <$> m\nm ?- x = subtract x <$> m\ninfixl 6 ?+, ?-\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Bool  (bool)\nimport Data.Maybe (fromMaybe, listToMaybe)\n\nimport Data.Bifunctor (bimap, first)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = inner (e, maxBound) []\n\n    inner dp js      []  = fst dp\n    inner dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        l   = snd <$> listToMaybe (init js')\n        x   = min `uncurry` bimap (+ t) (strict . (+ 2 * i)) (fromMaybe dp l)\n        y   = min `uncurry` first (subtract $ 2 * i) dp\n\nstrict :: Int -> Int\nstrict = until (0 <=) (const maxBound)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Data.Bool  (bool)\nimport Data.Maybe (fromMaybe, listToMaybe)\n\nimport Data.Bifunctor (bimap, first)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = inner (e, maxBound) []\n\n    inner !dp js      []  = fst dp\n    inner !dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        !l  = snd <$> listToMaybe (init js')\n        !x  = min `uncurry` bimap (+ t) (restrict . (+ 2 * i)) (fromMaybe dp l)\n        !y  = min `uncurry` first (subtract $ 2 * i) dp\n\nrestrict :: Int -> Int\nrestrict = until (0 <=) (const maxBound)\n"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go e [] <*> id\n  where\n    go x ks (j : js) (i : is)\n      | null js   = z\n      | otherwise = go z ((j, z, x) : ks) js is\n      where\n        z = dp ks i (x + t)\n\n    dp              []  _ = id\n    dp ((j, k, x) : js) i\n      | t > 2 * d = next dp  id k\n      | otherwise = next dp2 (subtract $ 2 * i) (x - 2 * j)\n      where\n        d = i - j\n        next f g = flip $ (f js i .) . flip min . g\n\n    dp2              []  i = (2 * i +)\n    dp2 ((j, _, x) : js) i = dp2 js i . min (x - 2 * j)\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Data.Bifunctor (bimap, first)\nimport Data.Maybe     (fromJust, fromMaybe, listToMaybe)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = negate . fromJust . inner (Just (-e), Nothing) []\n\n    inner !dp js      []  = fst dp\n    inner !dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        l   = snd <$> listToMaybe (init js')\n        !x  = max `uncurry` bimap (?- t) (?- 2 * i) (fromMaybe dp l)\n        !y  = max `uncurry` first (?+ 2 * i) dp\n\nm ?+ x = (x +) <$> m\nm ?- x = subtract x <$> m\ninfixl 6 ?+, ?-\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Data.Bifunctor (bimap, first)\nimport Data.Maybe     (fromJust, fromMaybe, listToMaybe)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = negate . fromJust . inner (Just (-e), Nothing) []\n\n    inner dp js      []  = fst dp\n    inner dp js (i : is) = inner (x, y) js' is\n      where\n        p   = i - succ t `div` 2\n        js' = dropWhile ((p >=) . fst) js ++ [(i, dp)]\n        !l  = snd <$> listToMaybe (init js')\n        !x  = max `uncurry` bimap (?- t) (?- 2 * i) (fromMaybe dp l)\n        !y  = max `uncurry` first (?+ 2 * i) dp\n\nm ?+ x = (x +) <$> m\nm ?- x = subtract x <$> m\ninfixl 6 ?+, ?-\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE MultiWayIf #-}\n\nimport Data.Bifunctor (first)\n\nmain :: IO ()\nmain = do\n    [n, e, t] <- fmap read . words <$> getLine\n    xs        <- fmap read . words <$> getLine\n    answer $ solve e t xs\n\ntype Answer = Int\nanswer :: Answer -> IO ()\nanswer = print\n\nsolve :: Int -> Int -> [Int] -> Answer\nsolve e t = go\n  where\n    go = fst <$> inner e maxBound id `flip` []\n\n    inner x y dp      []  = (,) x . dp\n    inner x y dp (i : is) = do\n        js <- dp\n        let\n          (j, r) = head js\n          p      = i - t `div` 2\n          x'     = x + t\n          w      = min y (x - 2 * i)\n          (z, f) = min x' `first` if\n            | null js   -> (x', id)\n            | j > p     -> (r + t, id)\n            | otherwise -> (y + 2 * i, dropWhile ((<= p) . fst))\n          dp' = f . dp . ((i, x) :)\n        inner z w dp' is\n"
  },
  {
    "language": "Text",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nclass seg{\n\tvl S,D;\npublic:\n\tseg(int n):S(1<<MSB(n-1)+2,e18),D(1<<MSB(n-1)+2,0ll){}\n\tvoid eval(int k,int l,int r){\n\t\tS[k]+=D[k];\n\t\tif(r-l>1){\n\t\t\tD[k<<1  ]+=D[k];\n\t\t\tD[k<<1|1]+=D[k];\n\t\t}\n\t\tD[k]=0;\n\t}\n\tvoid add(int a,int b,ll x,int k=1,int l=0,int r=-1){\n\t\tif(r<0)r=S.size()>>1;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\tif(a<=l&&r<=b){\n\t\t\tD[k]+=x;\n\t\t\teval(k,l,r);\n\t\t}else{\n\t\t\tadd(a,b,x,k<<1  ,l,l+r>>1);\n\t\t\tadd(a,b,x,k<<1|1,l+r>>1,r);\n\t\t\tS[k]=std::min(S[k<<1],S[k<<1|1]);\n\t\t}\n\t}\n\tll min(int a,int b,int k=1,int l=0,int r=-1){\n\t\tif(r<0)r=S.size()>>1;\n\t\tif(b<=l||r<=a)return e18;\n\t\teval(k,l,r);\n\t\tif(a<=l&&r<=b)return S[k];\n\t\tll L=min(a,b,k<<1  ,l,l+r>>1);\n\t\tll R=min(a,b,k<<1|1,l+r>>1,r);\n\t\treturn std::min(L,R);\n\t}\n};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;ll E,T;cin>>N>>E>>T;\n\tvl x(N+1);\n\tfoor(i,1,N)cin>>x[i];\n\tll d=0;\n\tint k=0;\n\tseg s(N+1);\n\ts.add(0,N+1,-e18);\n\tfoor(i,1,N){\n\t\td=s.min(0,i);\n\t}\n\tprint(d+E);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint N,E,T;\n\tscanf(\"%d%d%d\",&N,&E,&T);\n\tlong long int i,j,k=0,x[N+1],num=0,flag=T;\n\n\tfor(i=0;i<N;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tx[N]=-1000;\n\tnum=x[0];\n\n\tfor(i=0;i<N;i++){\n\t\tfor(j=1;i+j<N;j++){\n\t\t\tif((x[i+j])-x[i]<=T){\n\t\t\t\tk+=x[i+j]-x[i];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(k!=0){\n\t\t\tnum+=3*k;\n\t\t\tk=0;\n\t\t\tflag=0;\n\t\t\ti=i+j-2;\n\t\t}else{\n\t\t\tif(i+1!=N){\n\t\t\t\tnum+=x[i+1]-x[i]+flag;\n\t\t\t}else{\n\t\t\t\tnum+=E-x[i]+flag;\n\t\t\t}\n\t\t\tflag=T;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",num );\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abs(a) ((a)<0?-(a):(a))\n\n\n\nint main(void){\n\tint n,e,t;\n\tint *x;\n\n\tint i,j;\n\tlli res;\n\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tx = calloc(sizeof(int),n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\ti=0;\n\tres = x[i];\n\twhile(i<n){\n\t\t//printf(\"%d\\n\", res);\n\t\tj=0;\n\t\twhile(i+j < n && x[i] + t > x[i+j])j++;\n\t\tj--;\n\t\tres += max((x[i+j]-x[i])*2,t);\n\t\tj++;\n\t\tif(i+j == n){\n\t\t\tres += e - x[i];\n\t\t\tbreak;\n\t\t}\n\t\tres += x[i+j]-x[i];\n\t\ti=i+j;\n\t}\n\tprintf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid run(void){\n  int n,e,t;\n  scanf(\"%d%d%d\",&n,&e,&t);\n  if(n>2000) exit(1);\n  int *x=(int *)calloc(n+1,sizeof(int));\n  int i;\n  for(i=1;i<=n;i++) scanf(\"%d\",x+i);\n  int64 *dp=(int64 *)calloc(n+1,sizeof(int64));\n  for(i=1;i<=n;i++){\n    int64 min=1000000000LL*3;\n    int j;\n    for(j=i;j>0;j--){\n      int64 moveJ=dp[j]+x[j]-x[j-1];\n      int64 d=x[i]-x[j];\n      int64 v=moveJ+2*d+MAX(t-2*d,0)+d;\n      min=MIN(min,v);\n    }\n    dp[i]=min;\n  }\n  int64 ans=dp[n]+e-x[n];\n  printf(\"%lld\\n\",ans);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "long long i,j,e,t,w=1ll<<50,u,x[1<<17],y[1<<17];int main(n){scanf(\"%d%lld%lld\",&n,&e,&t);for(x[n]=2*e;i<n;){scanf(\"%lld\",&x[i]);x[i++]*=2;}for(i=0;i<n;){for(;j<i&&t<x[i]-x[j];){u=y[j]+x[i]-x[j++];w=w<u?w:u;}u=x[i]-x[j];u=y[j]+(u<t?t:u);y[i+1]=w<u?w:u;w+=(x[i+1]-x[i++]);}printf(\"%lld\\n\",y[n]+e);return 0;}"
  },
  {
    "language": "C",
    "code": "long long i,j,e,t,w,u,x[1<<17],y[1<<17];\nint main(n){\n  scanf(\"%d%lld%lld\",&n,&e,&t);\n  for(x[n]=2*e;i<n;){\n    scanf(\"%lld\",&x[i]);\n    x[i++]*=2;\n  }\n  for(i=0,w=1ll<<50;i<n;){\n    for(;j<i&&t<x[i]-x[j];){\n      u=y[j]+x[i]-x[j++];\n      w=w<u?w:u;\n    }\n    u=x[i]-x[j];\n    u=y[j]+(u<t?t:u);\n    y[i+1]=w<u?w:u;\n    w+=(x[i+1]-x[i++]);\n  }\n  printf(\"%lld\\n\",y[n]+e);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nvoid run (void) {\n  i32 n, e, t;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &e, &t);\n  i32 *x = (i32 *) calloc (n + 2, sizeof (i32));\n  for (i32 i = 1; i <= n; ++i) {\n    scanf (\"%\" SCNi32, x + i);\n  }\n  x[n + 1] = e;\n  i64 *dp = (i64 *) calloc (n + 1, sizeof (i64));\n  i64 min = (i64) n * t + e;\n  for (i32 i = 1, j = 1; i <= n; ++i) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + t;\n    for (; 2 * (x[i] - x[j]) >= t; ++j) {\n      min = MIN(min, dp[j - 1] + x[j] - x[j - 1] - (i64) 3 * x[j]);\n    }\n    dp[i] = MIN(dp[i], min + (i64) 3 * x[i]);\n    if (j < i) {\n      i64 p = dp[j - 1] + x[j] - x[j - 1];\n      p += t;\n      p += x[i] - x[j];\n      dp[i] = MIN(dp[i], p);\n    }\n  }\n  printf(\"%\" PRIi64 \"\\n\", dp[n] + e - x[n]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\n// char t[N_MAX + 1];\nchar t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\null dp1[N_MAX];\null dp2[N_MAX];\n\nvoid smaller (ull *x, ull y) {\n\tif (*x > y) *x = y;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i <= n; i++) {\n\t\tdp1[i] = dp2[i] = VERYBIG;\n\t}\n\tdp1[0] = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tull ok = i, ng = n + 1;\n\t\twhile (ok + 1 < ng) {\n\t\t\tull med = (ok + ng) / 2;\n\t\t\tif (2 * (a[med] - a[i + 1]) < k) {\n\t\t\t\tok = med;\n\t\t\t} else {\n\t\t\t\tng = med;\n\t\t\t}\n\t\t}\n\n\t\tsmaller(&dp2[i + 1], dp2[i] + 3 * (a[i + 1] - a[i]));\n\t\tull x = umin(dp1[i], dp2[i]);\n\t\tsmaller(&dp1[ok], x + k + (a[ok] - a[i]));\n\t\tsmaller(&dp2[ng], x + 3 * (a[ng] - a[i + 1]) + (a[i + 1] - a[i]));\n\t}\n\n\tresult = umin(dp1[n], dp2[n]) + (m - a[n]);\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid run(void){\n  int n,e,t;\n  scanf(\"%d%d%d\",&n,&e,&t);\n  if(n>2000) exit(1);\n  int *x=(int *)calloc(n+1,sizeof(int));\n  int i;\n  for(i=1;i<=n;i++) scanf(\"%d\",x+i);\n  int64 *dp=(int64 *)calloc(n+1,sizeof(int64));\n  for(i=1;i<=n;i++){\n    int64 min=1000000000LL*3;\n    int j;\n    for(j=i;j>0;j--){\n      int64 moveJ=dp[j-1]+x[j]-x[j-1];\n      int64 d=x[i]-x[j];\n      int64 v=moveJ+2*d+MAX(t-2*d,0)+d;\n      min=MIN(min,v);\n    }\n    dp[i]=min;\n  }\n  int64 ans=dp[n]+e-x[n];\n  printf(\"%lld\\n\",ans);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abs(a) ((a)<0?-(a):(a))\n\n\n\nint main(void){\n\tint n,e,t;\n\tint *x;\n\n\tint i,j;\n\tlli res;\n\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tx = calloc(sizeof(int),n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\ti=0;\n\tres = x[i];\n\twhile(i<n){\n\t\t//printf(\"%d\\n\", res);\n\t\tj=0;\n\t\twhile(i+j <= n && x[i] + t > x[i+j])j++;\n\t\tj--;\n\t\tres += max((x[i+j]-x[i])*2,t);\n\t\tj++;\n\t\tif(i+j == n){\n\t\t\tres += e - x[i];\n\t\t\tbreak;\n\t\t}\n\t\tres += x[i+j]-x[i];\n\t\ti=i+j;\n\t}\n\tprintf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n\n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n\n#define INF 100000000000\n#define M 1000000007\n\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\nlong N, E, T;\nlong x[100001];\n\nint main() {\n\tlong i, j;\n\tlong a, b, c;\n\tlong now;\n\tlong tmp;\n\tlong mid;\n\tlong left;\n\tlong right;\n\t\n\tsl(N); sl(E); sl(T);\n\tfor(i=1;i<=N;i++) {\n\t\tsl(x[i]);\n\t}\n\t\n\ta = now = 0;\n\tfor(i=1;i<=N;i++) {\n\t\ta += x[i] - now;\n\t\ta += T;\n\t\tnow = x[i];\n\t}\n\ta += labs(E - now);\n\t\n\tb = x[N] + T;\n\tb += x[N] - x[1];\n\tb += labs(E - x[1]);\n\t\n\ta = min(a, b);\n\t\n\tb = x[N];\n\tb += x[N] - x[1];\n\ttmp = T - x[N] + x[1];\n\tb += max(0, tmp - x[N] + x[1]);\n\tb += x[N] - x[1];\n\tb += labs(E - x[N]);\n\t\n\ta = min(a, b);\n\t\n\ti = 1;\n\tb = x[1];\n\twhile(i < N) {\n\t\tfor(j=i+1;j<=N;j++) {\n\t\t\tif((x[j] - x[i]) * 2 >= T && j < N && (x[j+1] - x[j]) <= T) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb += (x[j] - x[i]) * 3;\n\t\tif(j == N - 1) {\n\t\t\tc = b;\n\t\t\tc -= (x[j] - x[i]) * 3;\n\t\t\tc += (x[N] - x[i]) * 3;\n\t\t\tc += labs(E - x[N]);\n\t\t\ta = min(a, c);\n\t\t\tbreak;\n\t\t}\n\t\tif(j == N) break;\n\t\ti = j + 1;\n\t}\n\t\n\tif(j == N - 1) {\n\t\tb += (x[N] - x[j]);\n\t\tb += T;\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t} else {\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t}\n\t\n\tpl(a);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n\n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n\n#define INF 100000000000\n#define M 1000000007\n\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\nlong N, E, T;\nlong x[100001];\n\nint main() {\n\tlong i, j;\n\tlong a, b;\n\tlong now;\n\tlong tmp;\n\tlong mid;\n\tlong left;\n\tlong right;\n\t\n\tsl(N); sl(E); sl(T);\n\tfor(i=1;i<=N;i++) {\n\t\tsl(x[i]);\n\t}\n\t\n\ta = now = 0;\n\tfor(i=1;i<=N;i++) {\n\t\ta += x[i] - now;\n\t\ta += T;\n\t\tnow = x[i];\n\t}\n\ta += labs(E - now);\n\t\n\tb = x[N] + T;\n\tb += x[N] - x[1];\n\tb += labs(E - x[1]);\n\t\n\ta = min(a, b);\n\t\n\tb = x[N];\n\tb += x[N] - x[1];\n\ttmp = T - x[N] + x[1];\n\tb += max(0, tmp - x[N] + x[1]);\n\tb += x[N] - x[1];\n\tb += labs(E - x[N]);\n\t\n\ta = min(a, b);\n\t\n\ti = 1;\n\tb = x[1];\n\twhile(i < N) {\n\t\tfor(j=i+1;j<=N;j++) {\n\t\t\tif((x[j] - x[i]) * 2 >= T) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb += (x[j] - x[i]) * 3;\n\t\tif(j >= N) break;\n\t\ti = j + 1;\n\t}\n\t\n\tif(j == N - 1) {\n\t\tb += (x[N] - x[j]);\n\t\tb += T;\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t} else {\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t}\n\t\n\tpl(a);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nvoid run (void) {\n  i32 n, e, t;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &e, &t);\n  if (n > 2000) exit (1);\n  i32 *x = (i32 *) calloc (n + 2, sizeof (i32));\n  for (i32 i = 1; i <= n; ++i) {\n    scanf (\"%\" SCNi32, x + i);\n  }\n  x[n + 1] = e;\n  i64 *dp = (i64 *) calloc (n + 1, sizeof (i64));\n  for (i32 i = 1; i <= n; ++i) {\n    i64 local = dp[i - 1] + x[i] - x[i - 1] + t;\n    for (i32 j = i - 1; j > 0; --j) {\n      i64 p = x[j] - x[j - 1];\n      p += MAX(2 * (x[i] - x[j]), t);\n      p += x[i] - x[j];\n      local = MIN(local, p);\n    }\n    dp[i] = local;\n  }\n  printf(\"%\" PRIi64 \"\\n\", dp[n] + e - x[n]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nvoid run (void) {\n  i32 n, e, t;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &e, &t);\n  if (n > 2000) exit (1);\n  i32 *x = (i32 *) calloc (n + 2, sizeof (i32));\n  for (i32 i = 1; i <= n; ++i) {\n    scanf (\"%\" SCNi32, x + i);\n  }\n  x[n + 1] = e;\n  i64 *dp = (i64 *) calloc (n + 1, sizeof (i64));\n  i64 min = (i64) n * t + e;\n  for (i32 i = 1, j = 1; i <= n; ++i) {\n    dp[i] = dp[i - 1] + x[i] - x[i - 1] + t;\n    for (; 2 * (x[i] - x[j]) >= t; ++j) {\n      min = MIN(min, dp[j - 1] + x[j] - x[j - 1] - (i64) 3 * x[j]);\n    }\n    dp[i] = MIN(dp[i], min + (i64) 3 * x[i]);\n    if (j < i) {\n      i64 p = dp[j - 1] + x[j] - x[j - 1];\n      p += t;\n      p += x[i] - x[j];\n      dp[i] = MIN(dp[i], p);\n    }\n  }\n  printf(\"%\" PRIi64 \"\\n\", dp[n] + e - x[n]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n\n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n\n#define INF 100000000000\n#define M 1000000007\n\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\nlong N, E, T;\nlong x[100001];\n\nint main() {\n\tlong i, j;\n\tlong a, b;\n\tlong now;\n\tlong tmp;\n\tlong mid;\n\tlong left;\n\tlong right;\n\t\n\tsl(N); sl(E); sl(T);\n\tfor(i=1;i<=N;i++) {\n\t\tsl(x[i]);\n\t}\n\t\n\ta = now = 0;\n\tfor(i=1;i<=N;i++) {\n\t\ta += x[i] - now;\n\t\ta += T;\n\t\tnow = x[i];\n\t}\n\ta += labs(E - now);\n\t\n\tb = x[N] + T;\n\tb += x[N] - x[1];\n\tb += labs(E - x[1]);\n\t\n\ta = min(a, b);\n\t\n\tb = x[N];\n\tb += x[N] - x[1];\n\ttmp = T - x[N] + x[1];\n\tb += max(0, tmp - x[N] + x[1]);\n\tb += x[N] - x[1];\n\tb += labs(E - x[N]);\n\t\n\ta = min(a, b);\n\t\n\ti = 1;\n\tb = x[1];\n\twhile(i < N) {\n\t\tfor(j=i+1;j<=N;j++) {\n\t\t\tif((x[j] - x[i]) * 2 >= T) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb += (x[j] - x[i]) * 3;\n\t\tif(j >= N - 1) break;\n\t\ti = j + 1;\n\t}\n\t\n\tif(j == N - 1) {\n\t\tb += (x[N] - x[j]);\n\t\tb += T;\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t} else {\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t}\n\t\n\tpl(a);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint N,E,T;\n\tscanf(\"%d%d%d\",&N,&E,&T);\n\tint i,j,k=0,num=0,f=T;\n\tlong long int x[N+1];\n\n\tfor(i=0;i<N;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tnum=x[0]; x[N]=E;\n\n\tfor(i=0;i<N;i++){\n\t\tfor(j=1;i+j<N;j++){\n\t\t\tif((x[i+j]-x[i])<T){\n\t\t\t\tk+=x[i+j]-x[i];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(k!=0){\n\t\t\tnum+=3*k+x[i+j]-x[i+j-1];\n\t\t\tk=0; f=0;\n\t\t\ti=i+j-1;\n\t\t}else{\n\t\t\tnum+=x[i+1]-x[i]+f;\t\n\t\t\tf=T;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",num );\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abs(a) ((a)<0?-(a):(a))\n\n\n\nint main(void){\n\tint n,e,t;\n\tint *x;\n\n\tint i,j;\n\tlli res;\n\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tx = calloc(sizeof(int),n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t}\n\ti=0;\n\tres = x[i];\n\twhile(i<n){\n\t\t//printf(\"%d\\n\", res);\n\t\tj=0;\n\t\twhile(i+j < n && x[i] + t >= x[i+j])j++;\n\t\tj--;\n\t\tres += max((x[i+j]-x[i])*2,t);\n\t\tj++;\n\t\tif(i+j == n){\n\t\t\tres += e - x[i];\n\t\t\tbreak;\n\t\t}\n\t\tres += x[i+j]-x[i];\n\t\ti=i+j;\n\t}\n\tprintf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nvoid run (void) {\n  i32 n, e, t;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &e, &t);\n  if (n > 2000) exit (1);\n  i32 *x = (i32 *) calloc (n + 2, sizeof (i32));\n  for (i32 i = 1; i <= n; ++i) {\n    scanf (\"%\" SCNi32, x + i);\n  }\n  x[n + 1] = e;\n  i64 *dp = (i64 *) calloc (n + 1, sizeof (i64));\n  for (i32 i = 1; i <= n; ++i) {\n    i64 local = 100000000000000000LL;\n    for (i32 j = i; j > 0; --j) {\n      i64 p = dp[j - 1] + x[j] - x[j - 1];\n      p += MAX(2 * (x[i] - x[j]), t);\n      p += x[i] - x[j];\n      local = MIN(local, p);\n    }\n    dp[i] = local;\n  }\n  printf(\"%\" PRIi64 \"\\n\", dp[n] + e - x[n]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n\n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n\n#define INF 100000000000\n#define M 1000000007\n\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\nlong N, E, T;\nlong x[100001];\n\nint main() {\n\tlong i, j;\n\tlong a, b, c;\n\tlong now;\n\tlong tmp;\n\tlong mid;\n\tlong left;\n\tlong right;\n\t\n\tsl(N); sl(E); sl(T);\n\tfor(i=1;i<=N;i++) {\n\t\tsl(x[i]);\n\t}\n\t\n\ta = now = 0;\n\tfor(i=1;i<=N;i++) {\n\t\ta += x[i] - now;\n\t\ta += T;\n\t\tnow = x[i];\n\t}\n\ta += labs(E - now);\n\t\n\tb = x[N] + T;\n\tb += x[N] - x[1];\n\tb += labs(E - x[1]);\n\t\n\ta = min(a, b);\n\t\n\tb = x[N];\n\tb += x[N] - x[1];\n\ttmp = T - x[N] + x[1];\n\tb += max(0, tmp - x[N] + x[1]);\n\tb += x[N] - x[1];\n\tb += labs(E - x[N]);\n\t\n\ta = min(a, b);\n\t\n\ti = 1;\n\tb = x[1];\n\twhile(i < N) {\n\t\tfor(j=i+1;j<=N;j++) {\n\t\t\tif((x[j] - x[i]) * 2 >= T) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb += (x[j] - x[i]) * 3;\n\t\tif(j == N - 1) {\n\t\t\tc = b;\n\t\t\tc -= (x[j] - x[i]) * 3;\n\t\t\tc += (x[N] - x[i]) * 3;\n\t\t\tc += labs(E - x[N]);\n\t\t\ta = min(a, c);\n\t\t\tbreak;\n\t\t}\n\t\tif(j == N) break;\n\t\ti = j + 1;\n\t}\n\t\n\tif(j == N - 1) {\n\t\tb += (x[N] - x[j]);\n\t\tb += T;\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t} else {\n\t\tb += labs(E - x[N]);\n\t\ta = min(a, b);\n\t}\n\t\n\tpl(a);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    class Q implements Comparable<Q> {\n      int right;\n      int left;\n      long time;\n      Q(int right, int left, long time) {\n        this.right = right;\n        this.left = left;\n        this.time = time;\n      }\n\n      @Override\n      public int compareTo(Q o) {\n        if (this.time - o.time > 0) return 1;\n        if (this.time - o.time < 0) return -1;\n        return 0;\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      long E = in.nextInt();\n      long T = in.nextInt();\n\n      int[] x = in.nextIntArray(N);\n      PriorityQueue<Q> queue = new PriorityQueue<>();\n      queue.add(new Q(0, 0, x[0]));\n      while (!queue.isEmpty()) {\n        Q q = queue.poll();\n        if (q.right == N) {\n          out.println(q.time);\n          return;\n        }\n\n        if (q.right < N - 1) {\n          queue.add(new Q(q.right + 1, q.left, q.time + (x[q.right + 1] - x[q.right])));\n        }\n\n        //back\n        long d = x[q.right] - x[q.left];\n        long remain = Math.max(0, T - d * 2);\n        long cur = q.time + d + remain + d;\n        if (q.right < N - 1) {\n          queue.add(new Q(q.right + 1, q.right + 1, cur + x[q.right + 1] - x[q.right]));\n        } else {\n          queue.add(new Q(q.right + 1, q.right + 1, cur + E - x[q.right]));\n        }\n      }\n\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] ld = r.readLine().split(\"\\\\s\");\n\t\tint N = Integer.parseInt(ld[0]);\n\t\tlong E = Long.parseLong(ld[1]);\n\t\tlong T = Long.parseLong(ld[2]);\n\t\tString[] ps = r.readLine().split(\"\\\\s\");\n\t\tlong[] p = new long[N];\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tp[j] = Long.parseLong(ps[j]);\n\t\tint current = 0;\n\t\tlong result = p[0];\n\t\twhile (current < N) {\n\t\t\tint k = current + 1;\n\t\t\twhile (k < N && p[k] - p[current] <= T)\n\t\t\t\tk++;\n\t\t\tresult += 3 * (p[k - 1] - p[current]);\n\t\t\tif (2 * (p[k - 1] - p[current]) < T)\n\t\t\t\tresult += T - 2 * (p[k - 1] - p[current]);\n\t\t\tif (k < N)\n\t\t\t\tresult += p[k] - p[k - 1];\n\t\t\tcurrent = k;\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tpw.println(result + E - p[N - 1]);\n\t\tpw.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    if (N > 2000) {\n      return;\n    }\n    int E = sc.nextInt();\n    int T = sc.nextInt();\n    int[] X = new int[N + 1];\n    for (int i = 0; i < N; i++) {\n      X[i + 1] = sc.nextInt();\n    }\n    long[] dp = new long[N + 1];\n    Arrays.fill(dp, 1L << 50);\n    dp[0] = 0;\n    for (int i = 0; i < N; i++) {\n      int cur = X[i];\n      for (int j = i + 1; j <= N; j++) {\n        int fp = X[i + 1];\n        int lp = X[j];\n        dp[j] = Math.min(dp[j], dp[i] + (lp - cur) + Math.max((lp - fp) * 2, T));\n      }\n    }\n    System.out.println(dp[N] + E - X[N]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n \n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n \n \n    static class Task {\n \n        long E,T;\n        int n;\n        final int MAGIC = 5000;\n \n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n \n        public void solve(InputReader in, PrintWriter out) {\n \n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            opt = new int[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + 1);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n \n    }\n \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tSolver_agc007d solver = new Solver_agc007d();\n\t\tsolver.input();\n\t\tsolver.solve();\n\t}\n}\n\nclass FastScanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\tpublic FastScanner(Reader in) {\n\t\tbr = new BufferedReader(in);\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new RuntimeException(\"Can't read more inputs.\");\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\tString readNextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\nclass Solver_agc007d {\n\tstatic FastScanner in = new FastScanner(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tint n, e, T, a[];\n\tlong f[];\n\tvoid input() {\n\t\tn = in.nextInt(); e = in.nextInt(); T = in.nextInt();\n\t\ta = new int[n + 1];\n\t\tf = new long[n + 1];\n\t\tfor(int i = 1; i <= n; i++) a[i] = in.nextInt();\n\t}\n\tclass DequeItem {\n\t\tDequeItem(int index_, long val_) {\n\t\t\tindex = index_;\n\t\t\tval = val_;\n\t\t}\n\t\tint index;\n\t\tlong val;\n\t}\n\tvoid solve() {\n\t\tint j_ = 1;\n\t\tlong min_j_ = Long.MAX_VALUE >> 1;\n\t\tDeque<DequeItem> deque = new LinkedList<>();\n\t\tdeque.offer(new DequeItem(1, f[0]));\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\twhile(2 * (a[i] - a[j_]) > T) {\n\t\t\t\tj_++;\n\t\t\t\tmin_j_ = Math.min(min_j_, f[j_ - 2] - 2 * a[j_ - 1]);\n\t\t\t}\n\t\t\tf[i] = min_j_ + 2 * a[i];\n\t\t\twhile(deque.getLast().val > f[i - 1]) deque.removeLast();\n\t\t\tdeque.offer(new DequeItem(i, f[i - 1]));\n\t\t\twhile(deque.getFirst().index < j_) deque.removeFirst();\n\t\t\tf[i] = Math.min(f[i], deque.getFirst().val + T);\n\t\t}\n\t\tout.println(f[n] + e);\n\t\tout.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    class Q implements Comparable<Q> {\n      int right;\n      int left;\n      long time;\n      Q(int right, int left, long time) {\n        this.right = right;\n        this.left = left;\n        this.time = time;\n      }\n\n      @Override\n      public int compareTo(Q o) {\n        if (this.time - o.time > 0) return 1;\n        if (this.time - o.time < 0) return -1;\n        return 0;\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      long E = in.nextInt();\n      long T = in.nextInt();\n\n      int[] x = in.nextIntArray(N);\n\n      PriorityQueue<Q> queue = new PriorityQueue<>();\n      queue.add(new Q(0, 0, x[0]));\n      while (!queue.isEmpty()) {\n        Q q = queue.poll();\n        int cur = q.right;\n        int grow = q.left;\n        long time = q.time;\n        if (cur == N) {\n          out.println(time);\n          return;\n        }\n\n        long d = x[cur] - x[grow];\n        long remain = T - 2 * d;\n        if (cur == N - 1) {\n          remain = Math.max(remain, 0);\n          long t = time + d + remain + d + (E - x[cur]);\n          queue.add(new Q(cur + 1, cur + 1, t));\n          continue;\n        }\n\n        long e = x[cur + 1] - x[cur];\n        long next = x[cur + 1] - x[grow];\n        long nextRemain = T - 2 * next;\n        if (nextRemain >= 0) {\n          time += x[cur + 1] - x[cur];\n          cur++;\n          queue.add(new Q(cur, grow, time));\n          continue;\n        }\n        remain = Math.max(remain, 0);\n        if (e < remain) {\n          // 進む\n          time += e;\n          cur++;\n          queue.add(new Q(cur, grow, time));\n        } else {\n          long t = time + d + remain + d + e;\n          queue.add(new Q(cur + 1, cur + 1, t));\n        }\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        long e = nextInt();\n        long t = nextInt();\n        long[] x = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            x[i] = nextInt();\n        }\n        x[n] = e;\n        long[] d = new long[n + 1];\n        long min = Long.MAX_VALUE;\n        int j = n - 1;\n\n        for (int i = n - 1; i >= 0; i--) {\n            while ((x[j] - x[i]) * 2 > t) {\n                min = Math.min(min, d[j + 1] + (x[j + 1] - x[j]) + 3 * x[j]);\n                j--;\n            }\n            d[i] = d[j + 1] + t + (x[j + 1] - x[i]);\n            if (min < Long.MAX_VALUE) {\n                d[i] = Math.min(d[i], min - 3 * x[i]);\n            }\n        }\n        out.println(x[0] + d[0]);\n    }\n\n    private BufferedReader br;\n    private PrintWriter out;\n    private StringTokenizer st;\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tlong e = io.nextInt();\n\t\t\tlong T = io.nextInt();\n\t\t\tlong[] x = io.nextLongArray(n);\n\t\t\tlong[] d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = x[i] - (i > 0 ? x[i-1] : 0);\n\t\t\t}\n\t\t\t\n\t\t\tSegRMQLong seg = new SegRMQLong(n+1);\n\t\t\tlong[] ans = new long[n+1];\n\t\t\tfor (int i = 0, l = 0; i < n; i++) {\n\t\t\t\tseg.add(0, i, 2 * d[i]);\n\t\t\t\tfor (; (x[i] - x[l]) * 2 > T; l++) {\n\t\t\t\t\tseg.set(l, ans[l] + d[l] + (x[i] - x[l]) * 3);\n\t\t\t\t}\n\t\t\t\tans[i+1] = ans[i] + d[i] + T;\n\t\t\t\tans[i+1] = Math.min(ans[i+1], seg.get(0, i));\n//\t\t\t\tdump(i, ans[i] + d[i] + T, seg.get(0, 1), seg.get(1, 2));\n\t\t\t\tseg.set(i, ans[i] + d[i]);\n\t\t\t}\n//\t\t\tdump(ans);\n\t\t\tio.out.println(ans[n] + e - x[n-1]);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SegRMQLong {\n\t\tfinal long INF = 1L<<60;\n\t\t\n\t\tfinal int n;\n\t\tfinal long[] seg;\n\t\tfinal long[] add;\n\t\t\n\t\tpublic SegRMQLong(final int n) {\n\t\t\tthis.n = Integer.highestOneBit(n) << 1;\n\t\t\tseg = new long[this.n << 1];\n\t\t\tadd = new long[this.n << 1];\n\t\t\tArrays.fill(seg, INF);\n\t\t}\n\t\t\n\t\tvoid propagate(int curL, int curR, int k) {\n\t\t\tif(add[k] != 0) {\n\t\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\t\tadd(curL, curR, 2 * k + 1, add[k], curL, curM);\n\t\t\t\tadd(curL, curR, 2 * k + 2, add[k], curM, curR);\n\t\t\t\tadd[k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tlong get(int l, int r) { return get(l, r, 0, 0, n); }\n\t\tlong get(int l, int r, int k, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return INF;\n\t\t\tif(l <= curL && curR <= r) { return seg[k]; }\n\t\t\tpropagate(curL, curR, k);\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\treturn Math.min(\n\t\t\t\t\tget(l, r, 2 * k + 1, curL, curM),\n\t\t\t\t\tget(l, r, 2 * k + 2, curM, curR));\n\t\t}\n\n\t\tvoid add(int l, int r, long v) { add(l, r, 0, v, 0, n); }\n\t\tvoid add(int l, int r, int k, long v, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return;\n\t\t\tif(l <= curL && curR <= r) { seg[k] += v; add[k] += v; return; }\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\tpropagate(curL, curR, k);\n\t\t\tadd(l, r, 2 * k + 1, v, curL, curM);\n\t\t\tadd(l, r, 2 * k + 2, v, curM, curR);\n\t\t\tseg[k] = Math.min(seg[2*k+1], seg[2*k+2]);\n\t\t}\n\t\t\n\t\tvoid set(int i, long v) {\n\t\t\tadd(i, i + 1, 0);\n\t\t\t\n\t\t\ti += n - 1;\n\t\t\tseg[i] = v;\n\t\t\tadd[i] = 0;\n\t\t\twhile(i != 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tseg[i] = Math.min(seg[2*i+1], seg[2*i+2]) + add[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid shuffle(int[] p) {\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tint idx = random.nextInt(i + 1);\n\t\t\tswap(p, i, idx);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\t\n\t\t// s+max(T, 2*(x_j-x_i))+x_j-x_{i-1}\n\t\t// x_i x_j\n\t\t// s\n\t\tint n = ni(), E = ni(), T = ni();\n\t\tint[] xs = na(n);\n\t\tlong[] dp = new long[n+1];\n\t\tArrays.fill(dp, Long.MAX_VALUE / 2);\n\t\tdp[0] = 0;\n\t\tSegmentTreeRMQL st = new SegmentTreeRMQL(n+1);\n\t\tst.update(0, dp[0] - 2L*xs[0]);\n\t\tint pre = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(pre < i && T < 2L*(xs[i]-xs[pre])){\n\t\t\t\tpre++;\n\t\t\t}\n\t\t\tdp[i+1] = Math.min(dp[i+1], dp[pre] + Math.max(T, 2L*(xs[i]-xs[pre])));\n\t\t\tif(pre > 0){\n//\t\t\t\ttr(dp[pre-1], st.minx(0, pre), 2L*xs[i]);\n\t\t\t\tdp[i+1] = Math.min(dp[i+1], dp[pre-1] + st.minx(0, pre) + 2L*xs[i]);\n\t\t\t}\n\t\t\tif(i+1 < n){\n\t\t\t\tst.update(i+1, dp[i+1] - 2L*xs[i+1]);\n\t\t\t}\n\t\t}\n//\t\ttr(dp);\n\t\tout.println(dp[n]+E);\n\t}\n\t\n\tpublic static class SegmentTreeRMQL {\n\t\tpublic int M, H, N;\n\t\tpublic long[] st;\n\t\t\n\t\tpublic SegmentTreeRMQL(int n)\n\t\t{\n\t\t\tN = n;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tArrays.fill(st, 0, M, Long.MAX_VALUE);\n\t\t}\n\t\t\n\t\tpublic SegmentTreeRMQL(long[] a)\n\t\t{\n\t\t\tN = a.length;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tst[H+i] = a[i];\n\t\t\t}\n\t\t\tArrays.fill(st, H+N, M, Long.MAX_VALUE);\n\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t}\n\t\t\n\t\tpublic void update(int pos, long x)\n\t\t{\n\t\t\tst[H+pos] = x;\n\t\t\tfor(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n\t\t}\n\t\t\n\t\tprivate void propagate(int i)\n\t\t{\n\t\t\tst[i] = Math.min(st[2*i], st[2*i+1]);\n\t\t}\n\t\t\n\t\tpublic long minx(int l, int r){\n\t\t\tif(l >= r)return 0L;\n\t\t\tlong min = Long.MAX_VALUE;\n\t\t\twhile(l != 0){\n\t\t\t\tint f = l&-l;\n\t\t\t\tif(l+f > r)break;\n\t\t\t\tlong v = st[(H+l)/f];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tl += f;\n\t\t\t}\n\t\t\t\n\t\t\twhile(l < r){\n\t\t\t\tint f = r&-r;\n\t\t\t\tlong v = st[(H+r)/f-1];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tr -= f;\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t\t\n\t\tpublic long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n\t\t\n\t\tprivate long min(int l, int r, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\treturn st[cur];\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tlong ret = Long.MAX_VALUE;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int firstle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcur++;\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tif((cur&1)==0)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int lastle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur--;\n\t\t\t\t\tif((cur&1)==1)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    class Q implements Comparable<Q> {\n      int right;\n      int left;\n      long time;\n      Q(int right, int left, long time) {\n        this.right = right;\n        this.left = left;\n        this.time = time;\n      }\n\n      @Override\n      public int compareTo(Q o) {\n        if (this.time - o.time > 0) return 1;\n        if (this.time - o.time < 0) return -1;\n        return 0;\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      long E = in.nextInt();\n      long T = in.nextInt();\n\n      int[] x = in.nextIntArray(N);\n      PriorityQueue<Q> queue = new PriorityQueue<>();\n      queue.add(new Q(0, 0, x[0]));\n      while (!queue.isEmpty()) {\n        Q q = queue.poll();\n        if (q.right == N) {\n          out.println(q.time);\n          return;\n        }\n\n        //back\n        long d = x[q.right] - x[q.left];\n        long remain = Math.max(0, T - d * 2);\n        long cur = q.time + d + remain + d;\n        if (q.right < N - 1) {\n          queue.add(new Q(q.right + 1, q.right + 1, cur + x[q.right + 1] - x[q.right]));\n        } else {\n          queue.add(new Q(q.right + 1, q.right + 1, cur + E - x[q.right]));\n        }\n        if (q.right < N - 1 && remain > 0) {\n          queue.add(new Q(q.right + 1, q.left, q.time + (x[q.right + 1] - x[q.right])));\n        }\n      }\n\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 3000;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            opt = new int[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + 1);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int e = in.readInt();\n            int t = in.readInt();\n\n            long[] bears = new long[n + 2];\n            for (int i = 1; i <= n; i++) {\n                bears[i] = in.readInt();\n            }\n            bears[n + 1] = e;\n\n            Segment seg1 = new Segment(0, n);\n            Segment seg2 = new Segment(0, n);\n\n            long[] dp = new long[n + 1];\n            seg1.update(0, 0, 0, n, dp[0] + bears[1] - bears[0] - 3 * bears[1] + 2 * bears[1]);\n            seg2.update(0, 0, 0, n, dp[0] + bears[1] - bears[0] - 3 * bears[1]);\n\n            int j = -1;\n            for (int i = 1; i <= n; i++) {\n                while (j + 1 < n && bears[j + 2] * 2 <= bears[i] * 2 - t) {\n                    j++;\n                }\n                long ans1 = seg1.query(j + 1, i - 1, 0, n) + bears[i] + t;\n                long ans2 = seg2.query(0, j, 0, n) + 3 * bears[i];\n                dp[i] = Math.min(ans1, ans2);\n\n                seg1.update(i, i, 0, n, dp[i] + bears[i + 1] - bears[i] - 3 * bears[i + 1] + 2 * bears[i + 1]);\n                seg2.update(i, i, 0, n, dp[i] + bears[i + 1] - bears[i] - 3 * bears[i + 1]);\n            }\n\n            long ans = e - bears[n] + dp[n];\n            out.println(ans);\n        }\n\n    }\n    static class Segment implements Cloneable {\n        private Segment left;\n        private Segment right;\n        private long min = (long) 1e18;\n\n        public void set(long x) {\n            min = x;\n        }\n\n        public void pushUp() {\n            min = Math.min(left.min, right.min);\n        }\n\n        public void pushDown() {}\n\n        public Segment(int l, int r) {\n            if (l < r) {\n                int m = (l + r) >> 1;\n                left = new Segment(l, m);\n                right = new Segment(m + 1, r);\n                pushUp();\n            } else {\n\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void update(int ll, int rr, int l, int r, long x) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                set(x);\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.update(ll, rr, l, m, x);\n            right.update(ll, rr, m + 1, r, x);\n            pushUp();\n        }\n\n        public long query(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return (long) 1e18;\n            }\n            if (covered(ll, rr, l, r)) {\n                return min;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            return Math.min(left.query(ll, rr, l, m), right.query(ll, rr, m + 1, r));\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n + 1];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      x[n] = e;\n      long[][] state = new long[3][n + 1];\n      for (int i = 1; i <= n; ++i) {\n        state[0][i] = state[1][i - 1] + Math.max(2 * x[i - 1] + state[2][i - 1], t);\n        state[0][i] = Math.min(state[0][i], state[0][i - 1] + t);\n        if (state[0][i - 1] - 2 * x[i - 1] < state[1][i - 1] + state[2][i - 1]) {\n          state[1][i] = state[0][i - 1];\n          state[2][i] = - 2 * x[i - 1];\n        } else {\n          state[1][i] = state[1][i - 1]; \n          state[2][i] = state[2][i - 1]; \n        }\n      }\n      state[0][n] += e;\n      out.println(state[0][n]);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint T = sc.nextInt();\n\t\tint[] x = new int[N+1];\n\t\tx[0] = 0;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tx[i+1] = sc.nextInt();\n\t\t\n\t\tlong[] dp = new long[N+1];\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tdp[i] = Long.MAX_VALUE;\n\t\t\tfor(int j=0; j<i; j++) {\n\t\t\t\tdp[i] = Math.min(dp[i], dp[j]+x[i]-x[j]+Math.max(T, 2*(x[i]-x[j+1])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[N]+E-x[N]);\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n \n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n \n \n    static class Task {\n \n        long E,T;\n        int n;\n        final int MAGIC = 2500;\n \n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n \n        public void solve(InputReader in, PrintWriter out) {\n \n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n \n    }\n \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    int n = s.nextInt();\n    if (n > 2000) {\n      throw new RuntimeException(\"too many\");\n    }\n    long e = s.nextLong();\n    long t = s.nextLong();\n    long[] x = new long[n+1];\n    for (int i = 1; i <= n; i++) {\n      x[i] = s.nextLong();\n    }\n    long[] dptable = new long[n+1];\n    dptable[0] = 0;\n    for (int i = 1; i <= n; i++) {\n      dptable[i] = dptable[i-1] + t;\n      for (int k = 1; k < i; k++) {\n        dptable[i] = Math.min(\n            dptable[i],\n            dptable[k-1] + 2*(x[i] - x[k]) + Math.max(t - 2*x[i] + 2*x[k], 0));\n      }\n    }\n    System.out.println(e + dptable[n]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int e = ni();\n    int t = ni();\n    int[] x = new int[n + 1];\n    for (int i = 1; i <= n; i ++) {\n      x[i] = ni();\n    }\n    \n    long[] dp = new long[n + 1];\n    Arrays.fill(dp, Long.MAX_VALUE);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; i ++) {\n      for (int j = 0; j < i; j ++) {\n        dp[i] = Math.min(dp[i], dp[j] + Math.max((x[i] - x[j + 1]) * 2, t) + x[i] - x[j]);\n      }\n    }\n    long ret = dp[n] + (e - x[n]);\n    System.out.println(ret);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        int n,E,T;\n        final int MAGIC = 200;\n\n        long dp[];\n        int[] x;\n        int[] next;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextInt();\n            T = in.nextInt();\n            x = new int[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextInt();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = (long)T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = (long)T + (long)x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int n = ni();\n        int e = ni();\n        int t = ni();\n\n        int[] x = nia(n);\n\n        long ans = x[0] + e - x[n - 1];\n\n        int time = x[0];\n        int[] get = new int[n];\n        int bear = 0;\n        while (true) {\n            int idx = bear;\n            int tmpt = Math.min(time - get[bear], t);\n            while (2 * (x[idx + 1] - x[bear]) <= tmpt) {\n                idx++;\n                if (get[idx] == 0)\n                    get[idx] = time + x[idx + 1] - x[bear];\n            }\n            time = Math.max(time + tmpt, get[bear] + tmpt);\n\n            time += x[bear + 1] - x[bear];\n            bear++;\n\n            if (bear == n - 1) break;\n        }\n\n        out.println(time + ans);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    class Q implements Comparable<Q> {\n      int right;\n      int left;\n      long time;\n      Q(int right, int left, long time) {\n        this.right = right;\n        this.left = left;\n        this.time = time;\n      }\n\n      @Override\n      public int compareTo(Q o) {\n        if (this.time - o.time > 0) return 1;\n        if (this.time - o.time < 0) return -1;\n        return 0;\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      long E = in.nextInt();\n      long T = in.nextInt();\n\n      int[] x = in.nextIntArray(N);\n\n      PriorityQueue<Q> queue = new PriorityQueue<>();\n      queue.add(new Q(0, 0, x[0]));\n      while (!queue.isEmpty()) {\n        Q q = queue.poll();\n        int cur = q.right;\n        int grow = q.left;\n        long time = q.time;\n        if (cur == N) {\n          out.println(time);\n          return;\n        }\n\n        long d = x[cur] - x[grow];\n        long remain = Math.max(T - 2 * d, 0);\n        if (cur == N - 1) {\n          long t = time + d + remain + d + (E - x[cur]);\n          queue.add(new Q(cur + 1, cur + 1, t));\n          continue;\n        }\n\n        long e = x[cur + 1] - x[cur];\n        long next = x[cur + 1] - x[grow];\n        long nextRemain = T - 2 * next;\n        if (nextRemain >= 0) {\n          queue.add(new Q(cur + 1, grow, time + e));\n          continue;\n        }\n        if (remain > 0) queue.add(new Q(cur + 1, grow, time + e));\n        long t = time + d + remain + d + e;\n        queue.add(new Q(cur + 1, cur + 1, t));\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        int n,E,T;\n        final int MAGIC = 100;\n\n        long dp[];\n        boolean wasInState[];\n        int[] x;\n        int[] next;\n\n        long rec(int p) {\n            if (wasInState[p]) {\n                return dp[p];\n            }\n            wasInState[p] = true;\n            if (p == n - 1) {\n                dp[p] = (long)T + E - x[p];\n                return dp[p];\n            }\n            long res = T + (long)x[p + 1] - x[p] + rec(p + 1);\n            int from = Math.max(p + 1, next[p] - MAGIC);\n            int to = Math.min(n, next[p] + MAGIC);\n            for (int i = from; i < to; ++i) {\n                if (i + 1 != n) {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + rec(i + 1));\n                } else {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                }\n            }\n            dp[p] = res;\n            return res;\n            /*long res = Long.MAX_VALUE;\n            if (last == p) {\n                if (p + 1 != n) {\n                    res = Math.min(res, T + x[p + 1] - x[p] + rec(last + 1, p + 1));\n                    res = Math.min(res, x[p + 1] - x[p] + rec(p, p + 1));\n                } else {\n                    res = Math.min(res, T + E - x[p]);\n                }\n            } else {\n                if (p + 1 != n) {\n                    res = Math.min(res, x[p + 1] - x[p] + rec(last, p + 1));\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + x[p + 1] - x[p] + rec(p + 1, p + 1));\n                } else {\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + E - x[p]);\n                }\n            }\n            dp[last][p] = res;\n            return res;*/\n        }\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextInt();\n            T = in.nextInt();\n            x = new int[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextInt();\n            }\n            int p = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((p < n) && (x[p] - x[i] <= T)) {\n                    p++;\n                }\n                next[i] = p;\n            }\n            dp = new long[n];\n            wasInState = new boolean[n];\n            long res = rec(0);\n            out.println(res + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "Int();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      if (n == 1) {\n        out.println(e + t);\n        return;\n      }\n      long ans = x[0];\n      int idx = 0;\n      while (idx < n - 1) { \n        long cnt = 2;\n        int nxt = idx;\n        long temp = (x[nxt] - x[idx]) + cnt * t;\n        while (nxt < n && (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]) < (x[nxt] - x[idx]) + cnt * t) {\n          temp = (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]);\n          ++nxt;\n          ++cnt;\n        }\n        ans += temp;\n        if (nxt < n)\n          ans += x[nxt] - x[nxt - 1];\n        if (nxt == n - 1)\n          ans += t;\n        idx = nxt;\n      }\n      ans += e - x[n - 1];\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 400;\n\n        long dp[];\n        long[] x;\n        int[] next;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc007;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final long INF = (long)1e18;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long e = in.nextInt();\n        long t = in.nextInt();\n\n        if (n > 2000) {\n            throw new RuntimeException(\"oh\");\n        }\n\n        long[] x = in.nextLongs(n);\n        long[] dp = new long[n+1];\n\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n\n        for (int i = 1 ; i <= n ; i++) {\n            long to = x[i-1];\n            long min = INF;\n            for (int fr = 0 ; fr < i ; fr++) {\n                long st = fr == 0 ? 0 : x[fr-1];\n                long go = to - st;\n                long back = to - x[fr];\n                long req = Math.max(t, back * 2);\n                min = Math.min(min, dp[fr] + x[fr] - st + req + back);\n            }\n            dp[i] = min;\n        }\n\n        out.println(dp[n] + e - x[n-1]);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        int n,E,T;\n        final int MAGIC = 20;\n\n        long dp[];\n        boolean wasInState[];\n        int[] x;\n        int[] next;\n\n        long rec(int p) {\n            if (wasInState[p]) {\n                return dp[p];\n            }\n            wasInState[p] = true;\n            if (p == n - 1) {\n                dp[p] = T + E - x[p];\n                return dp[p];\n            }\n            long res = T + x[p + 1] - x[p] + rec(p + 1);\n            int from = Math.max(p + 1, next[p] - MAGIC);\n            int to = Math.min(n, next[p] + MAGIC);\n            for (int i = from; i < to; ++i) {\n                if (i + 1 != n) {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + rec(i + 1));\n                } else {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                }\n            }\n            dp[p] = res;\n            return res;\n            /*long res = Long.MAX_VALUE;\n            if (last == p) {\n                if (p + 1 != n) {\n                    res = Math.min(res, T + x[p + 1] - x[p] + rec(last + 1, p + 1));\n                    res = Math.min(res, x[p + 1] - x[p] + rec(p, p + 1));\n                } else {\n                    res = Math.min(res, T + E - x[p]);\n                }\n            } else {\n                if (p + 1 != n) {\n                    res = Math.min(res, x[p + 1] - x[p] + rec(last, p + 1));\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + x[p + 1] - x[p] + rec(p + 1, p + 1));\n                } else {\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + E - x[p]);\n                }\n            }\n            dp[last][p] = res;\n            return res;*/\n        }\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextInt();\n            T = in.nextInt();\n            x = new int[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextInt();\n            }\n            int p = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((p < n) && (x[p] - x[i] <= T)) {\n                    p++;\n                }\n                next[i] = p;\n            }\n            dp = new long[n];\n            wasInState = new boolean[n];\n            long res = rec(0);\n            out.println(res + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n + 1];\n      for (int i = 1; i <= n; ++i)\n        x[i] = in.nextInt();\n      long[][] state = new long[3][n + 1];\n      int ptr = 0;\n      for (int i = 1; i <= n; ++i) {\n        while (2 * (x[i] - x[ptr + 1]) > t)\n          ++ptr;\n        state[1][i] = ptr;\n      }\n      long min = Long.MAX_VALUE / 2;\n      for (int i = 1; i <= n; ++i) {\n        for (int j = (int) state[1][i - 1]; j < (int) state[1][i]; ++j)\n          min = Math.min(min, state[0][j] - 2 * x[j + 1]);\n        state[0][i] = Math.min(min + 2 * x[i], state[0][(int) state[1][i]] + t);\n      }\n      long ans = state[0][n] + e;\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*;\n\nclass Main{ \n\n\tstatic class RMQ{\n\t\tint n;\n\t\tlong[] data;\n\t\tRMQ(int nn){\n\t\t\tn=1;\n\t\t\twhile(n<nn)n*=2;\n\t\t\tdata = new long[n*2];\n\t\t\tArrays.fill(data, Long.MAX_VALUE/10);\n\t\t}\n\t\tvoid set(int i, long v){\n\t\t\ti+=n-1;data[i]=v;\n\t\t\tfor(i/=2;i>0;i/=2)data[i]=Math.min(data[2*i], data[2*i+1]);\n\t\t}\n\t\tlong getMin(int a,int b){\n\t\t\treturn getMin(a, b, 1, 1, n+1);\n\t\t}\n\t\tlong getMin(int a, int b, int k, int l, int r){\n\t\t\tif(r<=a||b<=l)return Long.MAX_VALUE/10;\n\t\t\tif(a<=l&&r<=b)return data[k];\n\t\t\treturn Math.min(getMin(a,b,2*k,l,(l+r)/2), getMin(a,b,2*k+1,(l+r)/2, r));\n\t\t}\n\t}\n\n\tstatic void solve(){\n\t\tint n = ni();\n\t\tlong E = nl(), T=nl();\n\t\tlong[] x = new long[n+3];\n\t\tfor(int i=0;i<n;++i)x[i+2]=nl();\n\t\tx[n+2] = E;\n\t\tlong[] dp = new long[n+2];\n\t\tRMQ larea = new RMQ(n+3);\n\t\tRMQ tarea = new RMQ(n+3);\n\t\tlarea.set(1, -2*x[2]);\n\t\ttarea.set(1, T);\n\t\tint index = 1;\n\t\tfor(int i=2;i<n+2;++i){\n\t\t\twhile((x[i]-x[index+1])*2 > T)++index;\n\t\t\tdp[i] = Math.min(larea.getMin(1, index)+3*x[i], tarea.getMin(index, i)+x[i]);\n\t\t\tdp[i] = Math.min(dp[i], dp[i-1] + x[i]-x[i-1] + T);\n\t\t\tlarea.set(i, dp[i]-2*x[i+1]-x[i]);\n\t\t\ttarea.set(i, dp[i]-x[i]+T);\n\t\t}\n\t\tout.println(dp[n+1] + E-x[n+1]);\n\t} \n \n \n \n \n\tpublic static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DShikAndGame solver = new DShikAndGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DShikAndGame {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), e = in.nextInt(), t = in.nextInt();\n            int[] x = in.readIntArray(n);\n            long[] dp = new long[n + 1];\n            int f = 0;\n            long m2 = 1L << 50;\n            MinQueue mq = new MinQueue(n + 10);\n            mq.add(dp[0], 0);\n            for (int i = 1; i <= n; i++) {\n                while (2 * (x[i - 1] - x[f]) >= t) {\n                    m2 = Math.min(m2, dp[f] - 2 * x[f]);\n                    f++;\n                }\n                dp[i] = Math.min(m2 + 2 * x[i - 1], mq.getMin(f) + t);\n                mq.add(dp[i], i);\n            }\n            out.println(dp[n] + e);\n        }\n\n    }\n\n    static class MinQueue {\n        public long[] value;\n        public int front;\n        public int back;\n        public int[] index;\n\n        public MinQueue(int N) {\n            value = new long[N];\n            index = new int[N];\n            front = back = 0;\n        }\n\n        public void add(long val, int idx) {\n            while (front < back && value[back - 1] >= val) back--;\n            value[back] = val;\n            index[back++] = idx;\n        }\n\n        public long getMin(int idx) {\n            while (front < back && index[front] < idx) front++;\n            return front == back ? Integer.MAX_VALUE : value[front];\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret = new int[tokens];\n            for (int i = 0; i < tokens; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n  private static final int BASE = 30000;\n  private static final int MAX_N = 20000;\n\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    int n = s.nextInt();\n    long e = s.nextLong();\n    long t = s.nextLong();\n    long[] x = new long[n+1];\n    for (int i = 1; i <= n; i++) {\n      x[i] = s.nextLong();\n    }\n    long[] dptable = new long[n+1];\n    dptable[0] = 0;\n    for (int i = 1; i <= n; i++) {\n      dptable[i] = dptable[i-1] + t;\n      for (int k = 1; k < i; k++) {\n        dptable[i] = Math.min(\n            dptable[i],\n            dptable[i-k-1] + 2*(x[i] - x[k]) + Math.max(t - 2*x[i] + 2*x[k], 0));\n      }\n//      System.out.println(dptable[i]);\n    }\n    System.out.println(e + dptable[n]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int n = ni();\n        int e = ni();\n        int t = ni();\n\n        int[] x = nia(n);\n\n        long ans = x[0] + e - x[n - 1];\n\n        int time = x[0];\n        int[] get = new int[n];\n        int bear = 0;\n        while (true) {\n            int idx = bear;\n            while (2 * (x[idx + 1] - x[bear]) <= t) {\n                idx++;\n                if (get[idx] == 0)\n                    get[idx] = time + x[idx + 1] - x[bear];\n            }\n            time = Math.max(time + t, get[bear] + t);\n\n            time += x[bear + 1] - x[bear];\n            bear++;\n\n            if (bear == n - 1) break;\n        }\n\n        out.println(time + ans);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      if (n == 1) {\n        out.println(e + t);\n        return;\n      }\n      long ans = x[0];\n      int idx = 0;\n      while (idx < n - 1) { \n        long cnt = 2;\n        int nxt = idx + 1;\n        long temp = (x[nxt] - x[idx]) + cnt * t;\n        while (nxt < n && (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]) <= (x[nxt] - x[idx]) + cnt * t) {\n          temp = (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]);\n          ++nxt;\n          ++cnt;\n        }\n        ans += temp;\n        if (nxt < n)\n          ans += x[nxt] - x[nxt - 1];\n        if (nxt == n - 1)\n          ans += t;\n        idx = nxt;\n      }\n      ans += e - x[n - 1];\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 1600;\n\n        long dp[];\n        long[] x;\n        int[] next;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic class BIT {\n\t\tint L;\n\t\tlong[] min;\n\t\tpublic BIT(int N) {\n\t\t\tL = 1;\n\t\t\twhile(L<N) {\n\t\t\t\tL<<=1;\n\t\t\t}\n\t\t\tmin = new long[L*2-1];\n\t\t\tArrays.fill(min, Long.MAX_VALUE);\n\t\t}\n\t\tpublic void set(int x, long v) {\n\t\t\tint p = L-1+x;\n\t\t\tmin[p] = v;\n\t\t\twhile(p>0) {\n\t\t\t\tp=(p-1)/2;\n\t\t\t\tmin[p] = Math.min(min[p*2+1], min[p*2+2]);\n\t\t\t}\n\t\t}\n\t\tpublic long getMin(int a, int b) {\n\t\t\treturn getMin(a, b, 0, L, 0);\n\t\t}\n\t\t\n\t\tpublic long getMin(int a, int b, int l, int r, int idx) {\n\t\t\tif(r<=a || b<=l)\n\t\t\t\treturn Long.MAX_VALUE;\n\t\t\telse if(a<=l && r<=b)\n\t\t\t\treturn min[idx];\n\t\t\telse\n\t\t\t\treturn Math.min(getMin(a, b, l,(l+r)/2,idx*2+1), getMin(a, b, (l+r)/2,r,idx*2+2));\n\t\t}\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint T = sc.nextInt();\n\t\tlong[] x = new long[N+1];\n\t\tfor(int i=0; i<N; i++)\n\t\t\tx[i+1] = sc.nextInt();\n\t\t\n\t\tlong[] dp = new long[N+1];\n\t\tBIT bit = new BIT(N+1);\n\t\tbit.set(0, E+(E-x[1])*2);\n\t\tint j=0;\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\twhile((x[i]-x[j+1])*2>T)\n\t\t\t\tj++;\n\t\t\t\n\t\t\tlong min = bit.getMin(0, j);\n\t\t\tdp[i] = Math.min(min-(E-x[i])*3, dp[j]+x[i]-x[j]+T);\n\t\t\tif(i<N)\n\t\t\t\tbit.set(i, dp[i]+E-x[i]+(E-x[i+1])*2);\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[N]+E-x[N]);\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 800;\n\n        long dp[];\n        long[] x;\n        int[] next;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      long[] state = new long[n];\n      for (int i = 0; i < n; ++i) {\n        long temp = Long.MAX_VALUE;\n        for (int j = 0; j <= i; ++j)\n          temp = Math.min(temp, (j == 0 ? 0 : state[j - 1]) + Math.max(t, 2 * (x[i] - x[j])));\n        state[i] = temp;\n      }\n      state[n - 1] += e;\n      out.println(state[n - 1]);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tlong e = io.nextInt();\n\t\t\tlong T = io.nextInt();\n\t\t\tlong[] x = io.nextLongArray(n);\n\t\t\tlong[] d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = x[i] - (i > 0 ? x[i-1] : 0);\n\t\t\t}\n\t\t\t\n\t\t\tSegRMQLong seg = new SegRMQLong(n+1);\n\t\t\tlong[] ans = new long[n+1];\n\t\t\tfor (int i = 0, l = 0; i < n; i++) {\n\t\t\t\tseg.add(0, i, 2 * d[i]);\n\t\t\t\tfor (; (x[i] - x[l]) * 2 > T; l++) {\n\t\t\t\t\tseg.set(l, ans[l] + d[l] + (x[i] - x[l]) * 3);\n\t\t\t\t}\n\t\t\t\tans[i+1] = ans[i] + d[i] + T;\n\t\t\t\tans[i+1] = Math.min(ans[i+1], seg.get(0, i));\n//\t\t\t\tdump(i, ans[i] + d[i] + T, seg.get(0, 1), seg.get(1, 2));\n\t\t\t\tseg.set(i, ans[i] + T + d[i]);\n\t\t\t}\n//\t\t\tdump(ans);\n\t\t\tio.out.println(ans[n] + e - x[n-1]);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SegRMQLong {\n\t\tfinal long INF = 1L<<60;\n\t\t\n\t\tfinal int n;\n\t\tfinal long[] seg;\n\t\tfinal long[] add;\n\t\t\n\t\tpublic SegRMQLong(final int n) {\n\t\t\tthis.n = Integer.highestOneBit(n) << 1;\n\t\t\tseg = new long[this.n << 1];\n\t\t\tadd = new long[this.n << 1];\n\t\t\tArrays.fill(seg, INF);\n\t\t}\n\t\t\n\t\tvoid propagate(int curL, int curR, int k) {\n\t\t\tif(add[k] != 0) {\n\t\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\t\tadd(curL, curR, 2 * k + 1, add[k], curL, curM);\n\t\t\t\tadd(curL, curR, 2 * k + 2, add[k], curM, curR);\n\t\t\t\tadd[k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tlong get(int l, int r) { return get(l, r, 0, 0, n); }\n\t\tlong get(int l, int r, int k, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return INF;\n\t\t\tif(l <= curL && curR <= r) { return seg[k]; }\n\t\t\tpropagate(curL, curR, k);\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\treturn Math.min(\n\t\t\t\t\tget(l, r, 2 * k + 1, curL, curM),\n\t\t\t\t\tget(l, r, 2 * k + 2, curM, curR));\n\t\t}\n\n\t\tvoid add(int l, int r, long v) { add(l, r, 0, v, 0, n); }\n\t\tvoid add(int l, int r, int k, long v, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return;\n\t\t\tif(l <= curL && curR <= r) { seg[k] += v; add[k] += v; return; }\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\tpropagate(curL, curR, k);\n\t\t\tadd(l, r, 2 * k + 1, v, curL, curM);\n\t\t\tadd(l, r, 2 * k + 2, v, curM, curR);\n\t\t\tseg[k] = Math.min(seg[2*k+1], seg[2*k+2]);\n\t\t}\n\t\t\n\t\tvoid set(int i, long v) {\n\t\t\tadd(i, i + 1, 0);\n\t\t\t\n\t\t\ti += n - 1;\n\t\t\tseg[i] = v;\n\t\t\tadd[i] = 0;\n\t\t\twhile(i != 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tseg[i] = Math.min(seg[2*i+1], seg[2*i+2]) + add[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid shuffle(int[] p) {\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tint idx = random.nextInt(i + 1);\n\t\t\tswap(p, i, idx);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nclass SegmentTreeRMQL {\n  public int M, H, N;\n  public long[] st;\n  \n  public SegmentTreeRMQL(int n)\n  {\n      N = n;\n      M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n      H = M>>>1;\n      st = new long[M];\n      Arrays.fill(st, 0, M, Long.MAX_VALUE);\n  }\n  \n  public SegmentTreeRMQL(long[] a)\n  {\n      N = a.length;\n      M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n      H = M>>>1;\n      st = new long[M];\n      for(int i = 0;i < N;i++){\n          st[H+i] = a[i];\n      }\n      Arrays.fill(st, H+N, M, Long.MAX_VALUE);\n      for(int i = H-1;i >= 1;i--)propagate(i);\n  }\n  \n  public void update(int pos, long x)\n  {\n      st[H+pos] = x;\n      for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n  }\n  \n  private void propagate(int i)\n  {\n      st[i] = Math.min(st[2*i], st[2*i+1]);\n  }\n  \n  public long minx(int l, int r){\n      long min = Long.MAX_VALUE;\n      if(l >= r)return min;\n      while(l != 0){\n          int f = l&-l;\n          if(l+f > r)break;\n          long v = st[(H+l)/f];\n          if(v < min)min = v;\n          l += f;\n      }\n      \n      while(l < r){\n          int f = r&-r;\n          long v = st[(H+r)/f-1];\n          if(v < min)min = v;\n          r -= f;\n      }\n      return min;\n  }\n  \n  public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n  \n  private long min(int l, int r, int cl, int cr, int cur)\n  {\n      if(l <= cl && cr <= r){\n          return st[cur];\n      }else{\n          int mid = cl+cr>>>1;\n          long ret = Long.MAX_VALUE;\n          if(cl < r && l < mid){\n              ret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n          }\n          if(mid < r && l < cr){\n              ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n          }\n          return ret;\n      }\n  }\n  \n  public int firstle(int l, long v) {\n      int cur = H+l;\n      while(true){\n          if(st[cur] <= v){\n              if(cur < H){\n                  cur = 2*cur;\n              }else{\n                  return cur-H;\n              }\n          }else{\n              cur++;\n              if((cur&cur-1) == 0)return -1;\n              if((cur&1)==0)cur>>>=1;\n          }\n      }\n  }\n  \n  public int lastle(int l, long v) {\n      int cur = H+l;\n      while(true){\n          if(st[cur] <= v){\n              if(cur < H){\n                  cur = 2*cur+1;\n              }else{\n                  return cur-H;\n              }\n          }else{\n              if((cur&cur-1) == 0)return -1;\n              cur--;\n              if((cur&1)==1)cur>>>=1;\n          }\n      }\n  }\n}\n\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    long e = ni();\n    long t = ni();\n    long[] x = nal(n);\n    \n    long[] dp = new long[n + 1];\n    Arrays.fill(dp, Long.MAX_VALUE / 2);\n    dp[0] = 0;\n    SegmentTreeRMQL st = new SegmentTreeRMQL(n + 1);\n    st.update(0, dp[0] - 2L * x[0]);\n    \n    int pre = 0;\n    for (int i = 0; i < n; i ++) {\n      while (pre < i && 2 * (x[i] - x[pre]) > t) {\n        pre ++;\n      }\n      \n      dp[i + 1] = Math.min(dp[i + 1], dp[pre] + Math.max(t,  2 * (x[i] - x[pre])));\n      if (pre > 0) {\n        dp[i + 1] = Math.min(dp[i + 1], st.min(0, pre) + 2 * x[i]);\n      }\n      if (i + 1 < n) {\n        st.update(i + 1, dp[i + 1] - 2 * x[i + 1]);\n      }\n    }\n    \n    System.out.println(dp[n] + e);\n\n  }\n\n  \n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/D2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong INF = (long) 1e15;\n\tpublic void solve() {\n\t\tint N = in.nextInt(), E = in.nextInt(), T = in.nextInt();\n\t\tint[] x = new int[N+2];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t}\n\t\tx[0] = 0;\n\t\tx[N+1] = E;\n\t\t\n\t\tif (N > 2000) return;\n\t\tif (N == 1) {\n\t\t\tSystem.out.println(E + T);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] dp = new long[N+2][N+2];\n\t\tfor (int i = 0; i < N + 2; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tfor (int curPos = 0; curPos < N + 1; curPos++) {\n\t\t\tfor (int coinPos = 0; coinPos < curPos; coinPos++) {\n\t\t\t\tlong d1 = x[curPos+1] - x[curPos];\n\t\t\t\tlong d2 = x[curPos] - x[coinPos+1];\n\t\t\t\tdp[curPos+1][coinPos] = Math.min(dp[curPos+1][coinPos], dp[curPos][coinPos] + d1);\n\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][coinPos] + Math.max(T, 2 * d2));\n\t\t\t}\n\t\t\tif (curPos > 0)\n\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][curPos-1] + T); \n\t\t\tdp[curPos+1][curPos] = Math.min(dp[curPos+1][curPos], dp[curPos][curPos] + x[curPos+1] - x[curPos]);\n\t\t}\n\t\tSystem.out.println(dp[N+1][N]);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      if (n == 1) {\n        out.println(e + t);\n        return;\n      }\n      long ans = x[0];\n      int idx = 0;\n      while (idx < n - 1) { \n        long cnt = 1;\n        int nxt = idx;\n        long temp = (x[nxt] - x[idx]) + cnt * t;\n        while (nxt < n && (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]) <= (x[nxt] - x[idx]) + cnt * t) {\n          temp = (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]);\n          ++nxt;\n          ++cnt;\n        }\n        ans += temp;\n        if (nxt < n)\n          ans += x[nxt] - x[nxt - 1];\n        if (nxt == n - 1)\n          ans += t;\n        idx = nxt;\n      }\n      ans += e - x[n - 1];\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 3200;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, next[p] - MAGIC);\n                int to = Math.min(n, next[p] + MAGIC);\n                for (int i = from; i < to; ++i) {\n                    if (i + 1 != n) {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1]);\n                    } else {\n                        res = Math.min(res, (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                    }\n                }\n                dp[p] = res;\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/D2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong INF = (long) 1e15;\n\tpublic void solve() {\n\t\tint N = in.nextInt(), E = in.nextInt(), T = in.nextInt();\n\t\tint[] x = new int[N+2];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t}\n\t\tx[0] = 0;\n\t\tx[N+1] = E;\n\t\t\n\t\tif (N > 2000) return;\n\t\tif (N == 1) {\n\t\t\tSystem.out.println(E + T);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] dp = new long[N+2][N+2];\n\t\tfor (int i = 0; i < N + 2; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tfor (int curPos = 0; curPos < N + 1; curPos++) {\n\t\t\tfor (int coinPos = 0; coinPos < curPos; coinPos++) {\n\t\t\t\tlong d1 = x[curPos+1] - x[curPos];\n\t\t\t\tlong d2 = x[curPos] - x[coinPos];\n\t\t\t\tlong d3 = d2 - x[1] - x[0];\n\t\t\t\tdp[curPos+1][coinPos] = Math.min(dp[curPos+1][coinPos], dp[curPos][coinPos] + d1);\n\t\t\t\tif (coinPos == 0)\n\t\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][coinPos] + d3 + Math.max(T - 2 * d3, d3));\n\t\t\t\telse\n\t\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][coinPos] + d2 + Math.max(T - 2 * d2, d2));\n\t\t\t}\n\t\t\tif (curPos > 0)\n\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][curPos-1] + T); \n\t\t\tdp[curPos+1][curPos] = Math.min(dp[curPos+1][curPos], dp[curPos][curPos] + x[curPos+1] - x[curPos]);\n\t\t}\n\t\tSystem.out.println(dp[N+1][N]);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      if (n == 1) {\n        out.println(e + t);\n        return;\n      }\n      long ans = x[0];\n      int idx = 0;\n      while (idx < n - 1) { \n        long cnt = 2;\n        int nxt = idx;\n        long temp = (x[nxt] - x[idx]) + cnt * t;\n        while (nxt < n && (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]) < (x[nxt] - x[idx]) + cnt * t) {\n          temp = (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]);\n          ++nxt;\n          ++cnt;\n        }\n        ans += temp;\n        if (nxt < n)\n          ans += x[nxt] - x[nxt - 1];\n        if (nxt == n - 1)\n          ans += t;\n        idx = nxt;\n      }\n      ans += e - x[n - 1];\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/D2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong INF = (long) 1e15;\n\tpublic void solve() {\n\t\tint N = in.nextInt(), E = in.nextInt(), T = in.nextInt();\n\t\tint[] x = in.nextIntArray(N);\n\t\t\n\t\tif (N > 2000) return;\n\n\t\tlong[] dp = new long[N+1];\n\t\tArrays.fill(dp, INF);\n\t\tdp[0] = 0;\n\t\t\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + Math.max(T, 2 * (x[i-1] - x[j])));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[N] + E);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 2500;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            opt = new int[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + MAGIC);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 1600;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            opt = new int[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + MAGIC);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tlong e = io.nextInt();\n\t\t\tlong T = io.nextInt();\n\t\t\tlong[] x = io.nextLongArray(n);\n\t\t\tlong[] d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = x[i] - (i > 0 ? x[i-1] : 0);\n\t\t\t}\n\t\t\t\n\t\t\tSegRMQLong seg = new SegRMQLong(n+1);\n\t\t\tlong[] ans = new long[n+1];\n\t\t\tfor (int i = 0, l = 0; i < n; i++) {\n\t\t\t\tseg.add(0, l, 2 * d[i]);\n\t\t\t\tseg.add(l, i, d[i]);\n\t\t\t\tfor (; (x[i] - x[l]) * 2 > T; l++) {\n\t\t\t\t\tseg.set(l, ans[l] + d[l] + (x[i] - x[l]) * 3);\n\t\t\t\t}\n\t\t\t\t// T - 2*d(j)\n\t\t\t\tans[i+1] = ans[i] + d[i] + T;\n\t\t\t\tans[i+1] = Math.min(ans[i+1], seg.get(0, i));\n//\t\t\t\tdump(i, ans[i] + d[i] + T, seg.get(0, 1), seg.get(1, 2));\n\t\t\t\tseg.set(i, ans[i] + T + d[i]);\n\t\t\t}\n//\t\t\tdump(ans);\n\t\t\tio.out.println(ans[n] + e - x[n-1]);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SegRMQLong {\n\t\tfinal long INF = 1L<<60;\n\t\t\n\t\tfinal int n;\n\t\tfinal long[] seg;\n\t\tfinal long[] add;\n\t\t\n\t\tpublic SegRMQLong(final int n) {\n\t\t\tthis.n = Integer.highestOneBit(n) << 1;\n\t\t\tseg = new long[this.n << 1];\n\t\t\tadd = new long[this.n << 1];\n\t\t\tArrays.fill(seg, INF);\n\t\t}\n\t\t\n\t\tvoid propagate(int curL, int curR, int k) {\n\t\t\tif(add[k] != 0) {\n\t\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\t\tadd(curL, curR, 2 * k + 1, add[k], curL, curM);\n\t\t\t\tadd(curL, curR, 2 * k + 2, add[k], curM, curR);\n\t\t\t\tadd[k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tlong get(int l, int r) { return get(l, r, 0, 0, n); }\n\t\tlong get(int l, int r, int k, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return INF;\n\t\t\tif(l <= curL && curR <= r) { return seg[k]; }\n\t\t\tpropagate(curL, curR, k);\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\treturn Math.min(\n\t\t\t\t\tget(l, r, 2 * k + 1, curL, curM),\n\t\t\t\t\tget(l, r, 2 * k + 2, curM, curR));\n\t\t}\n\n\t\tvoid add(int l, int r, long v) { add(l, r, 0, v, 0, n); }\n\t\tvoid add(int l, int r, int k, long v, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return;\n\t\t\tif(l <= curL && curR <= r) { seg[k] += v; add[k] += v; return; }\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\tpropagate(curL, curR, k);\n\t\t\tadd(l, r, 2 * k + 1, v, curL, curM);\n\t\t\tadd(l, r, 2 * k + 2, v, curM, curR);\n\t\t\tseg[k] = Math.min(seg[2*k+1], seg[2*k+2]);\n\t\t}\n\t\t\n\t\tvoid set(int i, long v) {\n\t\t\tadd(i, i + 1, 0);\n\t\t\t\n\t\t\ti += n - 1;\n\t\t\tseg[i] = v;\n\t\t\tadd[i] = 0;\n\t\t\twhile(i != 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tseg[i] = Math.min(seg[2*i+1], seg[2*i+2]) + add[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid shuffle(int[] p) {\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tint idx = random.nextInt(i + 1);\n\t\t\tswap(p, i, idx);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 3600;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            opt = new int[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + MAGIC);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        int n,E,T;\n\n        long dp[][];\n        boolean wasInState[][];\n        int[] x;\n\n        long rec(int last, int p) {\n            if (wasInState[last][p]) {\n                return dp[last][p];\n            }\n            wasInState[last][p] = true;\n            long res = Long.MAX_VALUE;\n            if (last == p) {\n                if (p + 1 != n) {\n                    res = Math.min(res, T + x[p + 1] - x[p] + rec(last + 1, p + 1));\n                    res = Math.min(res, x[p + 1] - x[p] + rec(p, p + 1));\n                } else {\n                    res = Math.min(res, T + E - x[p]);\n                }\n            } else {\n                if (p + 1 != n) {\n                    res = Math.min(res, x[p + 1] - x[p] + rec(last, p + 1));\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + x[p + 1] - x[p] + rec(p + 1, p + 1));\n                } else {\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + E - x[p]);\n                }\n            }\n            dp[last][p] = res;\n            return res;\n        }\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextInt();\n            T = in.nextInt();\n            x = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextInt();\n            }\n            dp = new long[n][n];\n            wasInState = new boolean[n][n];\n            long res = rec(0, 0);\n            out.println(res + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tlong e = io.nextInt();\n\t\t\tlong T = io.nextInt();\n\t\t\tlong[] x = io.nextLongArray(n);\n\t\t\tlong[] d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = x[i] - (i > 0 ? x[i-1] : 0);\n\t\t\t}\n\t\t\t\n\t\t\tSegRMQLong seg = new SegRMQLong(n+1);\n\t\t\tlong[] ans = new long[n+1];\n\t\t\tfor (int i = 0, l = 0; i < n; i++) {\n\t\t\t\tseg.add(0, l, 3 * d[i]);\n\t\t\t\tseg.add(l, i, d[i]);\n\t\t\t\tfor (; (x[i] - x[l]) * 2 > T; l++) {\n\t\t\t\t\tseg.set(l, ans[l] + d[l] + (x[i] - x[l]) * 3);\n\t\t\t\t}\n\t\t\t\t// T - 2*d(j)\n\t\t\t\tans[i+1] = ans[i] + d[i] + T;\n\t\t\t\tans[i+1] = Math.min(ans[i+1], seg.get(0, i));\n//\t\t\t\tdump(i, ans[i] + d[i] + T, seg.get(0, 1), seg.get(1, 2));\n\t\t\t\tseg.set(i, ans[i] + T + d[i]);\n\t\t\t}\n//\t\t\tdump(ans);\n\t\t\tio.out.println(ans[n] + e - x[n-1]);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SegRMQLong {\n\t\tfinal long INF = 1L<<60;\n\t\t\n\t\tfinal int n;\n\t\tfinal long[] seg;\n\t\tfinal long[] add;\n\t\t\n\t\tpublic SegRMQLong(final int n) {\n\t\t\tthis.n = Integer.highestOneBit(n) << 1;\n\t\t\tseg = new long[this.n << 1];\n\t\t\tadd = new long[this.n << 1];\n\t\t\tArrays.fill(seg, INF);\n\t\t}\n\t\t\n\t\tvoid propagate(int curL, int curR, int k) {\n\t\t\tif(add[k] != 0) {\n\t\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\t\tadd(curL, curR, 2 * k + 1, add[k], curL, curM);\n\t\t\t\tadd(curL, curR, 2 * k + 2, add[k], curM, curR);\n\t\t\t\tadd[k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tlong get(int l, int r) { return get(l, r, 0, 0, n); }\n\t\tlong get(int l, int r, int k, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return INF;\n\t\t\tif(l <= curL && curR <= r) { return seg[k]; }\n\t\t\tpropagate(curL, curR, k);\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\treturn Math.min(\n\t\t\t\t\tget(l, r, 2 * k + 1, curL, curM),\n\t\t\t\t\tget(l, r, 2 * k + 2, curM, curR));\n\t\t}\n\n\t\tvoid add(int l, int r, long v) { add(l, r, 0, v, 0, n); }\n\t\tvoid add(int l, int r, int k, long v, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return;\n\t\t\tif(l <= curL && curR <= r) { seg[k] += v; add[k] += v; return; }\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\tpropagate(curL, curR, k);\n\t\t\tadd(l, r, 2 * k + 1, v, curL, curM);\n\t\t\tadd(l, r, 2 * k + 2, v, curM, curR);\n\t\t\tseg[k] = Math.min(seg[2*k+1], seg[2*k+2]);\n\t\t}\n\t\t\n\t\tvoid set(int i, long v) {\n\t\t\tadd(i, i + 1, 0);\n\t\t\t\n\t\t\ti += n - 1;\n\t\t\tseg[i] = v;\n\t\t\tadd[i] = 0;\n\t\t\twhile(i != 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tseg[i] = Math.min(seg[2*i+1], seg[2*i+2]) + add[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid shuffle(int[] p) {\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tint idx = random.nextInt(i + 1);\n\t\t\tswap(p, i, idx);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        long E,T;\n        int n;\n        final int MAGIC = 1600;\n\n        long dp[];\n        long[] x;\n        int[] next;\n        int[] opt;\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextLong();\n            T = in.nextLong();\n            x = new long[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextLong();\n            }\n            int pos = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((pos < n) && (2*(x[pos] - x[i]) <= T)) {\n                    pos++;\n                }\n                next[i] = pos;\n            }\n            dp = new long[n];\n            dp[n - 1] = T + E - x[n - 1];\n            opt[n - 1] = n - 1;\n            for (int p = n - 2; p >= 0; --p) {\n                long res = T + x[p + 1] - x[p] + dp[p + 1];\n                int from = Math.max(p + 1, opt[p + 1] - MAGIC);\n                int to = Math.min(n, opt[p + 1] + MAGIC);\n                long nres = Long.MAX_VALUE;\n                for (int i = from; i < to; ++i) {\n                    long now = 0;\n                    if (i + 1 != n) {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + dp[i + 1];\n                    } else {\n                        now = (x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p];\n                    }\n                    if (now < nres) {\n                        nres = now;\n                        opt[p] = i;\n                    }\n                }\n                dp[p] = Math.min(res, nres);\n            }\n            out.println(dp[0] + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc007;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final long INF = (long)1e18;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long E = in.nextInt();\n        long T = in.nextInt();\n        long[] a = new long[n+1];\n        for (int i = 0; i < n ; i++) {\n            a[i] = in.nextInt();\n        }\n        a[n] = E;\n\n        long[] init = new long[n+10];\n        Arrays.fill(init, INF);\n        init[0] = a[0];\n\n        SegmentTreeRARMQ far = new SegmentTreeRARMQ(init);\n        SegmentTreeRARMQ near = new SegmentTreeRARMQ(init);\n\n        int l = 0;\n        for (int i = 0 ; i <= n ; i++) {\n            if (i >= 1) {\n                long D = a[i] - a[i - 1];\n                near.add(0, i+1, D);\n                far.add(0, i+1, 3*D);\n            }\n            if (i == n) {\n                break;\n            }\n\n            while (l < i && a[i] - a[l] > T / 2) {\n                l++;\n            }\n\n            // [l, i+1]\n\n            long cost = near.min(l, i+1) + T;\n            if (l >= 1) {\n                cost = Math.min(cost, far.min(0, l));\n            }\n\n            near.set(i+1, cost);\n            far.set(i+1, cost);\n        }\n\n        out.println(near.min(n, n+1));\n        out.flush();\n    }\n\n    public static class SegmentTreeRARMQ {\n        int N;\n        int M;\n        long[] segMin;\n        long[] lazy;\n\n        public SegmentTreeRARMQ(long[] data) {\n            N = Integer.highestOneBit(data.length-1)<<2;\n            M = (N >> 1) - 1;\n\n            segMin = new long[N];\n            lazy = new long[N];\n            Arrays.fill(segMin, Long.MAX_VALUE);\n            for (int i = 0 ; i < data.length ; i++) {\n                segMin[M+i] = data[i];\n            }\n            for (int i = M-1 ; i >= 0 ; i--) {\n                segMin[i] = compute(i);\n            }\n        }\n\n        private void propagate(int i) {\n            if (lazy[i] == 0) {\n                return;\n            }\n            segMin[i] += lazy[i];\n            if (i*2+2 < segMin.length) {\n                lazy[i*2+1] += lazy[i];\n                lazy[i*2+2] += lazy[i];\n            }\n            lazy[i] = 0;\n        }\n\n        private long compute(int i) {\n            return Math.min(segMin[i*2+1], segMin[i*2+2]);\n        }\n\n        public void set(int l, long x) {\n            long m = min(l, l+1);\n            long d = x - m;\n            add(l, l+1, d);\n        }\n\n        public void add(int l, int r, long k) {\n            add(l, r, k, 0, 0, M+1);\n        }\n\n        public void add(int l, int r, long x, int idx, int fr, int to) {\n            propagate(idx);\n\n            if (to <= l || r <= fr) {\n                return;\n            }\n            if (l <= fr && to <= r) {\n                lazy[idx] += x;\n                propagate(idx);\n                return;\n            }\n\n            int med = (fr + to) / 2;\n            add(l, r, x, idx*2+1, fr, med);\n            add(l, r, x, idx*2+2, med, to);\n\n            segMin[idx] = compute(idx);\n        }\n\n        public long min(int l, int r) {\n            return min(l, r, 0, 0, M+1);\n        }\n\n        public long min(int l, int r, int idx, int fr, int to) {\n            propagate(idx);\n\n            if (to <= l || r <= fr) {\n                return Long.MAX_VALUE;\n            }\n            if (l <= fr && to <= r) {\n                return segMin[idx];\n            }\n\n            int med = (fr+to) / 2;\n            long ret = Long.MAX_VALUE;\n            ret = Math.min(ret, min(l, r, idx*2+1, fr, med));\n            ret = Math.min(ret, min(l, r, idx*2+2, med, to));\n            return ret;\n        }\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int E = sc.nextInt();\n    int T = sc.nextInt();\n    long[] X = new long[N + 1];\n    for (int i = 0; i < N; i++) {\n      X[i + 1] = sc.nextInt();\n    }\n    long time = 0;\n    int pos = 0;\n    while (pos < N) {\n      int next = pos + 1;\n      while (next < N && (X[next + 1] - X[next]) < T) {\n        ++next;\n      }\n      time += X[pos + 1] - X[pos] + Math.max((X[next] - X[pos + 1]) * 2, T) + X[next] - X[pos + 1];\n      pos = next;\n    }\n    System.out.println(time + E - X[N]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] ld = r.readLine().split(\"\\\\s\");\n\t\tint N = Integer.parseInt(ld[0]);\n\t\tlong E = Long.parseLong(ld[1]);\n\t\tlong T = Long.parseLong(ld[2]);\n\t\tString[] ps = r.readLine().split(\"\\\\s\");\n\t\tlong[] p = new long[N];\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tp[j] = Long.parseLong(ps[j]);\n\t\tint current = 0;\n\t\tlong result = p[0];\n\t\twhile (current < N) {\n\t\t\tint k = current + 1;\n\t\t\twhile (k < N && p[k] - p[current] < T)\n\t\t\t\tk++;\n\t\t\tresult += 3 * (p[k - 1] - p[current]);\n\t\t\tif (2 * (p[k - 1] - p[current]) < T)\n\t\t\t\tresult += T - 2 * (p[k - 1] - p[current]);\n\t\t\tif (k < N)\n\t\t\t\tresult += p[k] - p[k - 1];\n\t\t\tcurrent = k;\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tpw.println(result + E - p[N - 1]);\n\t\tpw.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      long[] state = new long[n];\n      state[0] = t;\n      for (int i = 1; i < n; ++i) {\n        long temp = Long.MAX_VALUE;\n        for (int j = 0; j <= i; ++j)\n          temp = Math.min(temp, (j == 0 ? 0 : state[j - 1]) + Math.max(t, 2 * (x[i] - x[j])));\n        state[i] = temp;\n      }\n      state[n - 1] += e;\n      out.println(state[n - 1]);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      if (n == 1) {\n        out.println(e + t);\n        return;\n      }\n      long ans = x[0];\n      int idx = 0;\n      while (idx < n - 1) { \n        long cnt = 1;\n        int nxt = idx;\n        long temp = (x[nxt] - x[idx]) + cnt * t;\n        while (nxt < n && (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]) < (x[nxt] - x[idx]) + cnt * t) {\n          temp = (long) Math.max(t, 2 * (x[nxt] - x[idx])) + (x[nxt] - x[idx]);\n          ++nxt;\n          ++cnt;\n        }\n        ans += temp;\n        if (nxt < n)\n          ans += x[nxt] - x[nxt - 1];\n        if (nxt == n - 1)\n          ans += t;\n        idx = nxt;\n      }\n      ans += e - x[n - 1];\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc007;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final long INF = (long)1e18;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long E = in.nextInt();\n        long T = in.nextInt();\n        long[] a = new long[n+1];\n        for (int i = 0; i < n ; i++) {\n            a[i] = in.nextInt();\n        }\n        a[n] = E;\n\n        long[] init = new long[n+10];\n        Arrays.fill(init, INF);\n        init[0] = a[0];\n\n        SegmentTreeRARMQ far = new SegmentTreeRARMQ(init);\n        SegmentTreeRARMQ near = new SegmentTreeRARMQ(init);\n\n        int l = 0;\n        for (int i = 0 ; i <= n ; i++) {\n            if (i >= 1) {\n                long D = a[i] - a[i - 1];\n                near.add(0, i, D);\n                far.add(0, i, 3*D);\n            }\n            if (i == n) {\n                break;\n            }\n\n            while (l < i && a[i] - a[l] > T / 2) {\n                l++;\n            }\n\n            long cost = near.min(l, i+1) + T;\n            if (l >= 1) {\n                cost = Math.min(cost, far.min(0, l));\n            }\n            cost += a[i+1] - a[i];\n\n            near.set(i+1, cost);\n            far.set(i+1, cost);\n        }\n\n        out.println(Math.min(near.min(n, n+1), far.min(n, n+1)));\n        out.flush();\n    }\n\n    public static class SegmentTreeRARMQ {\n        int N;\n        int M;\n        long[] segMin;\n        long[] lazy;\n\n        public SegmentTreeRARMQ(long[] data) {\n            N = Integer.highestOneBit(data.length-1)<<2;\n            M = (N >> 1) - 1;\n\n            segMin = new long[N];\n            lazy = new long[N];\n            Arrays.fill(segMin, Long.MAX_VALUE);\n            for (int i = 0 ; i < data.length ; i++) {\n                segMin[M+i] = data[i];\n            }\n            for (int i = M-1 ; i >= 0 ; i--) {\n                segMin[i] = compute(i);\n            }\n        }\n\n        private void propagate(int i) {\n            if (lazy[i] == 0) {\n                return;\n            }\n            segMin[i] += lazy[i];\n            if (i*2+2 < segMin.length) {\n                lazy[i*2+1] += lazy[i];\n                lazy[i*2+2] += lazy[i];\n            }\n            lazy[i] = 0;\n        }\n\n        private long compute(int i) {\n            return Math.min(segMin[i*2+1], segMin[i*2+2]);\n        }\n\n        public void set(int l, long x) {\n            long m = min(l, l+1);\n            long d = x - m;\n            add(l, l + 1, d);\n        }\n\n        public void add(int l, int r, long k) {\n            add(l, r, k, 0, 0, M+1);\n        }\n\n        public void add(int l, int r, long x, int idx, int fr, int to) {\n            propagate(idx);\n\n            if (to <= l || r <= fr) {\n                return;\n            }\n            if (l <= fr && to <= r) {\n                lazy[idx] += x;\n                propagate(idx);\n                return;\n            }\n\n            int med = (fr + to) / 2;\n            add(l, r, x, idx*2+1, fr, med);\n            add(l, r, x, idx*2+2, med, to);\n\n            segMin[idx] = compute(idx);\n        }\n\n        public long min(int l, int r) {\n            return min(l, r, 0, 0, M+1);\n        }\n\n        public long min(int l, int r, int idx, int fr, int to) {\n            propagate(idx);\n\n            if (to <= l || r <= fr) {\n                return Long.MAX_VALUE;\n            }\n            if (l <= fr && to <= r) {\n                return segMin[idx];\n            }\n\n            int med = (fr+to) / 2;\n            long ret = Long.MAX_VALUE;\n            ret = Math.min(ret, min(l, r, idx*2+1, fr, med));\n            ret = Math.min(ret, min(l, r, idx*2+2, med, to));\n            return ret;\n        }\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\t\n\t\t// s+max(T, 2*(x_j-x_i))+x_j-x_{i-1}\n\t\t// x_i x_j\n\t\t// s\n\t\tint n = ni(), E = ni(), T = ni();\n\t\tint[] xs = na(n);\n\t\tlong[] dp = new long[n+1];\n\t\tArrays.fill(dp, Long.MAX_VALUE / 2);\n\t\tdp[0] = 0;\n\t\tSegmentTreeRMQL st = new SegmentTreeRMQL(n+1);\n\t\tst.update(0, dp[0] - 2L*xs[0]);\n\t\tint pre = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(pre < i && T < 2L*(xs[i]-xs[pre])){\n\t\t\t\tpre++;\n\t\t\t}\n//\t\t\ttr(i, pre);\n\t\t\tdp[i+1] = Math.min(dp[i+1], dp[pre] + Math.max(T, 2L*(xs[i]-xs[pre])));\n\t\t\tif(pre > 0){\n//\t\t\t\ttr(dp[pre-1], st.minx(0, pre), 2L*xs[i]);\n\t\t\t\tdp[i+1] = Math.min(dp[i+1], st.minx(0, pre) + 2L*xs[i]);\n\t\t\t}\n\t\t\tif(i+1 < n){\n\t\t\t\tst.update(i+1, dp[i+1] - 2L*xs[i+1]);\n//\t\t\t\ttr(\"update\", i+1, dp[i+1] - 2L*xs[i+1]);\n\t\t\t}\n\t\t}\n//\t\ttr(dp);\n\t\tout.println(dp[n]+E);\n\t}\n\t\n\tpublic static class SegmentTreeRMQL {\n\t\tpublic int M, H, N;\n\t\tpublic long[] st;\n\t\t\n\t\tpublic SegmentTreeRMQL(int n)\n\t\t{\n\t\t\tN = n;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tArrays.fill(st, 0, M, Long.MAX_VALUE);\n\t\t}\n\t\t\n\t\tpublic SegmentTreeRMQL(long[] a)\n\t\t{\n\t\t\tN = a.length;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tst[H+i] = a[i];\n\t\t\t}\n\t\t\tArrays.fill(st, H+N, M, Long.MAX_VALUE);\n\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t}\n\t\t\n\t\tpublic void update(int pos, long x)\n\t\t{\n\t\t\tst[H+pos] = x;\n\t\t\tfor(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n\t\t}\n\t\t\n\t\tprivate void propagate(int i)\n\t\t{\n\t\t\tst[i] = Math.min(st[2*i], st[2*i+1]);\n\t\t}\n\t\t\n\t\tpublic long minx(int l, int r){\n\t\t\tif(l >= r)return 0L;\n\t\t\tlong min = Long.MAX_VALUE;\n\t\t\twhile(l != 0){\n\t\t\t\tint f = l&-l;\n\t\t\t\tif(l+f > r)break;\n\t\t\t\tlong v = st[(H+l)/f];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tl += f;\n\t\t\t}\n\t\t\t\n\t\t\twhile(l < r){\n\t\t\t\tint f = r&-r;\n\t\t\t\tlong v = st[(H+r)/f-1];\n\t\t\t\tif(v < min)min = v;\n\t\t\t\tr -= f;\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t\t\n\t\tpublic long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n\t\t\n\t\tprivate long min(int l, int r, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\treturn st[cur];\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tlong ret = Long.MAX_VALUE;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int firstle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcur++;\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tif((cur&1)==0)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int lastle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur--;\n\t\t\t\t\tif((cur&1)==1)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n  private static final int BASE = 30000;\n  private static final int MAX_N = 20000;\n\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    int n = s.nextInt();\n    if (n > 2000) {\n      throw new RuntimeException(\"too many\");\n    }\n    long e = s.nextLong();\n    long t = s.nextLong();\n    long[] x = new long[n+1];\n    for (int i = 1; i <= n; i++) {\n      x[i] = s.nextLong();\n    }\n    long[] dptable = new long[n+1];\n    dptable[0] = 0;\n    for (int i = 1; i <= n; i++) {\n      dptable[i] = dptable[i-1] + t;\n      for (int k = 1; k < i; k++) {\n        dptable[i] = Math.min(\n            dptable[i],\n            dptable[k-1] + 2*(x[i] - x[k]) + Math.max(t - 2*x[i] + 2*x[k], 0));\n      }\n//      System.out.println(dptable[i]);\n    }\n    System.out.println(e + dptable[n]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n + 1];\n      for (int i = 1; i <= n; ++i)\n        x[i] = in.nextInt();\n      long[][] state = new long[2][n + 1];\n      int ptr = 0;\n      long min = Long.MAX_VALUE / 2;\n      for (int i = 1; i <= n; ++i) {\n        while (2 * (x[i] - x[ptr + 1]) > t)\n          ++ptr;\n        state[1][i] = ptr;\n        for (int j = (int) state[1][i - 1]; j < (int) state[1][i]; ++j)\n          min = Math.min(min, state[0][j] - 2 * x[j + 1]);\n        state[0][i] = Math.min(min + 2 * x[i], state[0][(int) state[1][i]] + t);\n      }\n      long ans = state[0][n] + e;\n      out.println(ans);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    class Q implements Comparable<Q> {\n      int right;\n      int left;\n      long time;\n      Q(int right, int left, long time) {\n        this.right = right;\n        this.left = left;\n        this.time = time;\n      }\n\n      @Override\n      public int compareTo(Q o) {\n        if (this.time - o.time > 0) return 1;\n        if (this.time - o.time < 0) return -1;\n        return 0;\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      long E = in.nextInt();\n      long T = in.nextInt();\n\n      int[] x = in.nextIntArray(N);\n\n      PriorityQueue<Q> queue = new PriorityQueue<>();\n      queue.add(new Q(0, 0, x[0]));\n      while (!queue.isEmpty()) {\n        Q q = queue.poll();\n        int cur = q.right;\n        int grow = q.left;\n        long time = q.time;\n        if (cur == N) {\n          out.println(time);\n          return;\n        }\n\n        long d = x[cur] - x[grow];\n        long remain = Math.max(T - 2 * d, 0);\n        if (cur == N - 1) {\n          long t = time + d + remain + d + (E - x[cur]);\n          queue.add(new Q(cur + 1, cur + 1, t));\n          continue;\n        }\n\n        long e = x[cur + 1] - x[cur];\n        long next = x[cur + 1] - x[grow];\n        long nextRemain = T - 2 * next;\n        if (nextRemain >= 0) {\n          time += x[cur + 1] - x[cur];\n          cur++;\n          queue.add(new Q(cur, grow, time));\n          continue;\n        }\n        queue.add(new Q(cur + 1, grow, time + e));\n        long t = time + d + remain + d + e;\n        queue.add(new Q(cur + 1, cur + 1, t));\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      long[][] state = new long[3][n + 1];\n      for (int i = 1; i <= n; ++i) {\n        state[0][i] = state[1][i - 1] + Math.max(2 * x[i - 1] + state[2][i - 1], t);\n        state[0][i] = Math.min(state[0][i], state[0][i - 1] + t);\n        if (state[0][i - 1] - 2 * x[i - 1] < state[1][i - 1]) {\n          state[1][i] = state[0][i - 1];\n          state[2][i] = - 2 * x[i - 1];\n        } else {\n          state[1][i] = state[1][i - 1]; \n          state[2][i] = state[2][i - 1]; \n        }\n      }\n      state[0][n] += e;\n      out.println(state[0][n]);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/D2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong INF = (long) 1e15;\n\tpublic void solve() {\n\t\tint N = in.nextInt(), E = in.nextInt(), T = in.nextInt();\n\t\tint[] x = new int[N+2];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t}\n\t\tx[0] = 0;\n\t\tx[N+1] = E;\n\t\t\n\t\tif (N > 2000) return;\n\t\tif (N == 1) {\n\t\t\tSystem.out.println(E + T);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] dp = new long[N+2][N+2];\n\t\tfor (int i = 0; i < N + 2; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tfor (int curPos = 0; curPos < N + 1; curPos++) {\n\t\t\tfor (int coinPos = 0; coinPos < curPos; coinPos++) {\n\t\t\t\tlong d1 = x[curPos+1] - x[curPos];\n\t\t\t\tlong d2 = x[curPos] - x[coinPos+1];\n\t\t\t\tdp[curPos+1][coinPos] = Math.min(dp[curPos+1][coinPos], dp[curPos][coinPos] + d1);\n\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][coinPos] + d2 + Math.max(T - 2 * d2, d2));\n\t\t\t}\n\t\t\tif (curPos > 0)\n\t\t\t\tdp[curPos][curPos] = Math.min(dp[curPos][curPos], dp[curPos][curPos-1] + T); \n\t\t\tdp[curPos+1][curPos] = Math.min(dp[curPos+1][curPos], dp[curPos][curPos] + x[curPos+1] - x[curPos]);\n\t\t}\n\t\tSystem.out.println(dp[N+1][N]);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n  static int N, T, E;\n  static int x[];\n\n  public static void main(String[] args) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter W = new PrintWriter(System.out);\n\n    N = in.nextInt();\n    E = in.nextInt();\n    T = in.nextInt();\n\n    x = new int[N + 1];\n    for (int i = 1; i <= N; i++)\n      x[i] = in.nextInt();\n    \n    //W.println(brute() + E);\n    W.println(solve1D1D() + E);\n\n    /*\n    int x[] = new int[1000];\n    for (int i = 0; i < x.length; i++)\n      x[i] = new Random().nextInt(10000);\n    \n    int T = new Random().nextInt(250);\n    \n    Arrays.sort(x);\n    \n    for (int i = 2; i + 2 < x.length; i++) {\n      for (int j = i + 2; j + 2 < x.length; j++) {\n        int L = w(i, j, x, T) + w(i + 1, j + 1,x, T);\n        int R = w(i + 1, j, x, T) + w(i, j + 1, x, T);\n        if (L > R) {\n          System.out.println(\"Rekt \" + x[i] + \" \" + x[j] + \" \" + x[i + 1] + \" \" + x[j + 1] + \" \" + L + \" \" + R);\n        }\n      }\n    }\n    */\n\n    W.close();\n  }\n  \n  public static long brute(){\n    \n    long dp[] = new long[N + 1];\n    for(int i = 1; i <= N; i++){\n      dp[i] = Long.MAX_VALUE;\n      for(int j = 0; j < i; j++)\n        dp[i] = Math.min(dp[i], dp[j] + cost(j + 1, i));\n    }\n    \n    System.out.println(Arrays.toString(dp));\n    return dp[N];\n  }\n\n  public static long solve1D1D() {\n    MyStack stack = new MyStack(N + 5);\n    long[] dp = new long[N + 1];\n    dp[0] = 0;\n    stack.push(new Pair(0, 1)); //(l,w) = (idx, segment start)\n\n    for (int i = 1; i <= N; i++) {\n      { //find last segment such that stack.p[mid].w <= i\n        int start = 0, end = stack.top + 1, mid, ret = -1;\n        while (start < end) {\n          mid = (start + end) >> 1;\n          if (stack.p[mid].w > i)\n            end = mid;\n          else {\n            ret = mid;\n            start = mid + 1;\n          }\n        }\n        dp[i] = dp[stack.p[ret].l] + cost(stack.p[ret].l + 1, i);\n      }\n      if (i == N)\n        break;\n      while (!stack.isEmpty()) {\n        Pair top = stack.peek();\n        if (top.w > i && dp[i] + cost(i + 1, top.w) < dp[top.l] + cost(top.l + 1, top.w))\n          stack.pop();\n        else {\n          int start = top.w, end = N + 1;\n          int ret = -1;\n          while (start < end) {\n            int mid = (start + end) >> 1;\n            if (dp[i] + cost(i + 1, mid) < dp[top.l] + cost(top.l + 1, mid))\n              ret = end = mid;\n            else\n              start = mid + 1;\n          }\n          if (ret != -1)\n            stack.push(new Pair(i, ret));\n          break;\n        }\n      }\n      if (stack.isEmpty())\n        stack.push(new Pair(i, 1));\n    }\n\n    return dp[N];\n  }\n\n  static int cost(int i, int j) {\n    int X = x[j] - x[i];\n    if (2 * X >= T)\n      return 2 * X;\n    else\n      return T;\n  }\n\n  static class MyStack {\n    int top;\n    Pair p[];\n\n    MyStack(int n) {\n      p = new Pair[n];\n      top = -1;\n    }\n\n    void push(Pair x) {\n      p[++top] = x;\n    }\n\n    Pair pop() {\n      return p[top--];\n    }\n\n    Pair peek() {\n      return p[top];\n    }\n\n    boolean isEmpty() {\n      return top == -1;\n    }\n\n    void print() {\n      for (int i = 0; i <= top; i++)\n        System.out.print(p[i] + \" \");\n      System.out.println();\n    }\n  }\n\n  static class Pair implements Comparable<Pair> {\n    int l, w;\n\n    Pair(int l, int w) {\n      this.l = l;\n      this.w = w;\n    }\n\n    public int compareTo(Pair o) {\n      if (w != o.w)\n        return Integer.compare(o.w, w);\n      return Integer.compare(o.l, l);\n    }\n\n    public String toString() {\n      return l + \" \" + w;\n    }\n  }\n\n  static class InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int snext() {\n      if (snumChars == -1)\n        throw new InputMismatchException();\n      if (curChar >= snumChars) {\n        curChar = 0;\n        try {\n          snumChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (snumChars <= 0)\n          return -1;\n      }\n      return buf[curChar++];\n    }\n\n    public int nextInt() {\n      int c = snext();\n      while (isSpaceChar(c)) {\n        c = snext();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = snext();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9')\n          throw new InputMismatchException();\n        res *= 10;\n        res += c - '0';\n        c = snext();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public long nextLong() {\n      int c = snext();\n      while (isSpaceChar(c)) {\n        c = snext();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = snext();\n      }\n      long res = 0;\n      do {\n        if (c < '0' || c > '9')\n          throw new InputMismatchException();\n        res *= 10;\n        res += c - '0';\n        c = snext();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n      int a[] = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    public String readString() {\n      int c = snext();\n      while (isSpaceChar(c)) {\n        c = snext();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = snext();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public String nextLine() {\n      int c = snext();\n      while (isSpaceChar(c))\n        c = snext();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = snext();\n      } while (!isEndOfLine(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null)\n        return filter.isSpaceChar(c);\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n      return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * Created by fcdkbear on 15.10.16.\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        new Task().solve(in, out);\n        out.close();\n    }\n\n\n    static class Task {\n\n        int n,E,T;\n        final int MAGIC = 100;\n\n        long dp[];\n        boolean wasInState[];\n        int[] x;\n        int[] next;\n\n        long rec(int p) {\n            if (wasInState[p]) {\n                return dp[p];\n            }\n            wasInState[p] = true;\n            if (p == n - 1) {\n                dp[p] = (long)T + E - x[p];\n                return dp[p];\n            }\n            long res = T + (long)x[p + 1] - x[p] + rec(p + 1);\n            int from = Math.max(p + 1, next[p] - MAGIC);\n            int to = Math.min(n, next[p] + MAGIC);\n            for (int i = from; i < to; ++i) {\n                if (i + 1 != n) {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + x[i + 1] - x[p] + rec(i + 1));\n                } else {\n                    res = Math.min(res, (long)(x[i] - x[p]) + Math.max(T - x[i] + x[p], x[i] - x[p]) + E - x[p]);\n                }\n            }\n            dp[p] = res;\n            return res;\n            /*long res = Long.MAX_VALUE;\n            if (last == p) {\n                if (p + 1 != n) {\n                    res = Math.min(res, T + x[p + 1] - x[p] + rec(last + 1, p + 1));\n                    res = Math.min(res, x[p + 1] - x[p] + rec(p, p + 1));\n                } else {\n                    res = Math.min(res, T + E - x[p]);\n                }\n            } else {\n                if (p + 1 != n) {\n                    res = Math.min(res, x[p + 1] - x[p] + rec(last, p + 1));\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + x[p + 1] - x[p] + rec(p + 1, p + 1));\n                } else {\n                    res = Math.min(res, Math.max(T - x[p] + x[last], x[p] - x[last]) + x[p] - x[last] + E - x[p]);\n                }\n            }\n            dp[last][p] = res;\n            return res;*/\n        }\n\n        public void solve(InputReader in, PrintWriter out) {\n\n            n = in.nextInt();\n            E = in.nextInt();\n            T = in.nextInt();\n            x = new int[n];\n            next = new int[n];\n            for (int i = 0; i < n; ++i) {\n                x[i] = in.nextInt();\n            }\n            int p = 0;\n            for (int i = 0; i < n; ++i) {\n                while ((p < n) && (2*(x[p] - x[i]) <= T)) {\n                    p++;\n                }\n                next[i] = p;\n            }\n            dp = new long[n];\n            wasInState = new boolean[n];\n            long res = rec(0);\n            out.println(res + x[0]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskD {    \n    int n, e, t;\n    int[] x;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      e = in.nextInt();\n      t = in.nextInt();\n      x = new int[n];\n      for (int i = 0; i < n; ++i)\n        x[i] = in.nextInt();\n      long[][] state = new long[3][n + 1];\n      for (int i = 1; i <= n; ++i) {\n        long a = 2 * x[i - 1] + state[2][i - 1];\n        if (a < t)\n          a = t;\n        state[0][i] = Math.min(state[1][i - 1] + a, state[0][i - 1] + t);\n        long b = state[0][i - 1] - 2 * x[i - 1];\n        if (b < state[1][i - 1]) {\n          state[1][i] = state[0][i - 1];\n          state[2][i] = - 2 * x[i - 1];\n        } else {\n          state[1][i] = state[1][i - 1]; \n          state[2][i] = state[2][i - 1]; \n        }\n      }\n      state[0][n] += e;\n      out.println(state[0][n]);\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tlong e = io.nextInt();\n\t\t\tlong T = io.nextInt();\n\t\t\tlong[] x = io.nextLongArray(n);\n\t\t\tlong[] d = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = x[i] - (i > 0 ? x[i-1] : 0);\n\t\t\t}\n\t\t\t\n\t\t\tSegRMQLong seg = new SegRMQLong(n+1);\n\t\t\tlong[] ans = new long[n+1];\n\t\t\tfor (int i = 0, l = 0; i < n; i++) {\n\t\t\t\tseg.add(0, i, 2 * d[i]);\n\t\t\t\tfor (; x[i] - x[l] > T; l++) {\n\t\t\t\t\tseg.set(l, ans[l] + d[l] + (x[i] - x[l]) * 3);\n\t\t\t\t}\n\t\t\t\tans[i+1] = ans[i] + d[i] + T;\n\t\t\t\tans[i+1] = Math.min(ans[i+1], seg.get(0, i));\n//\t\t\t\tdump(i, ans[i] + d[i] + T, seg.get(0, 1), seg.get(1, 2));\n\t\t\t\tseg.set(i, ans[i] + T + d[i]);\n\t\t\t}\n//\t\t\tdump(ans);\n\t\t\tio.out.println(ans[n] + e - x[n-1]);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SegRMQLong {\n\t\tfinal long INF = 1L<<60;\n\t\t\n\t\tfinal int n;\n\t\tfinal long[] seg;\n\t\tfinal long[] add;\n\t\t\n\t\tpublic SegRMQLong(final int n) {\n\t\t\tthis.n = Integer.highestOneBit(n) << 1;\n\t\t\tseg = new long[this.n << 1];\n\t\t\tadd = new long[this.n << 1];\n\t\t\tArrays.fill(seg, INF);\n\t\t}\n\t\t\n\t\tvoid propagate(int curL, int curR, int k) {\n\t\t\tif(add[k] != 0) {\n\t\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\t\tadd(curL, curR, 2 * k + 1, add[k], curL, curM);\n\t\t\t\tadd(curL, curR, 2 * k + 2, add[k], curM, curR);\n\t\t\t\tadd[k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tlong get(int l, int r) { return get(l, r, 0, 0, n); }\n\t\tlong get(int l, int r, int k, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return INF;\n\t\t\tif(l <= curL && curR <= r) { return seg[k]; }\n\t\t\tpropagate(curL, curR, k);\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\treturn Math.min(\n\t\t\t\t\tget(l, r, 2 * k + 1, curL, curM),\n\t\t\t\t\tget(l, r, 2 * k + 2, curM, curR));\n\t\t}\n\n\t\tvoid add(int l, int r, long v) { add(l, r, 0, v, 0, n); }\n\t\tvoid add(int l, int r, int k, long v, int curL, int curR) {\n\t\t\tif(curR <= l || curL >= r) return;\n\t\t\tif(l <= curL && curR <= r) { seg[k] += v; add[k] += v; return; }\n\t\t\tfinal int curM = (curL + curR) / 2;\n\t\t\tpropagate(curL, curR, k);\n\t\t\tadd(l, r, 2 * k + 1, v, curL, curM);\n\t\t\tadd(l, r, 2 * k + 2, v, curM, curR);\n\t\t\tseg[k] = Math.min(seg[2*k+1], seg[2*k+2]);\n\t\t}\n\t\t\n\t\tvoid set(int i, long v) {\n\t\t\tadd(i, i + 1, 0);\n\t\t\t\n\t\t\ti += n - 1;\n\t\t\tseg[i] = v;\n\t\t\tadd[i] = 0;\n\t\t\twhile(i != 0) {\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t\tseg[i] = Math.min(seg[2*i+1], seg[2*i+2]) + add[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid shuffle(int[] p) {\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tint idx = random.nextInt(i + 1);\n\t\t\tswap(p, i, idx);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n//using System.Numerics;  //comment out if AOJ\nusing System.Text;\n\nusing Problem = Tmp.Problem;\nusing MyIO;\n\n#pragma warning disable   //for AOJ\n\nnamespace Tmp\n{\n    class Problem : IDisposable\n    {\n        bool IsGCJ;\n        int Repeat;\n        Scanner sc;\n        Printer pr;\n        public Problem(bool isGCJ, Scanner scanner, Printer printer)\n        {\n            sc = scanner;\n            pr = printer;\n            IsGCJ = isGCJ;\n            if (isGCJ) Repeat = sc.nextInt();\n            else Read();\n        }\n        public Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n        public Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n        public Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n        public void Solve()\n        {\n            if (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n            else SolveOne();\n        }\n        public void Dispose()\n        {\n            sc.Dispose();\n            pr.Dispose();\n        }\n        public int Size { get { return 1; } }\n        public const long Mod = 1000000007;\n\n        // 使用する変数をここに書く\n        // string S;\n        // int a;\n        /// <summary>\n        /// 読み込み処理をここに書く\n        /// </summary>\n        void Read()\n        {\n\n        }\n        /// <summary>\n        /// メイン処理をここに書く\n        /// </summary>\n        void SolveOne()\n        {\n            long n = sc.nextLong();\n            long e = sc.nextLong();\n            long t = sc.nextLong();\n            long[] x = sc.nextLong((int)n);\n\n            long[] dp = new long[n + 1];   //dp[i+1]: ibanme ga owatta\n            int[] bgnls = new int[n + 1];\n\n            dp[0] = x[0];\n            dp[1] = x[0] + t;\n            for (int now = 1; now < n; now++)\n            {\n                dp[now + 1] = dp[now] + (x[now] - x[now - 1]) + t;\n                int bgn = bgnls[now - 1];\n                long katamiti = x[now] - x[bgn];\n                long tmp = Math.Max(t + katamiti, katamiti * 3);\n                if (dp[now + 1] > x[bgn] + tmp)\n                {\n                    dp[now + 1] = x[bgn] + tmp;\n                }\n                else\n                {\n                    bgnls[now] = now;\n                }\n            }\n\n            Console.WriteLine(dp[n] + e - x[n - 1]);\n        }\n    }\n}\nclass Program\n{\n    //public static RandomSFMT rand = new RandomSFMT();\n    public static bool IsJudgeMode = true;\n    public static bool IsGCJMode = false;\n    public static bool IsSolveCreated = true;\n    static void Main()\n    {\n        if (IsJudgeMode)\n            if (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n            else using (var problem = new Problem(false, new Printer())) problem.Solve();\n        else\n        {\n            var num = 1;\n            int size = 0;\n            decimal time = 0;\n            for (var tmp = 0; tmp < num; tmp++)\n            {\n                using (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n                {\n                    size = P.Size;\n                    //time += Func.MeasureTime(() => P.Solve());\n                }\n            }\n            Console.WriteLine(\"{0}, {1}ms\", size, time / num);\n        }\n    }\n}\n\n/// <summary>\n/// カスタマイズしたIO\n/// </summary>\nnamespace MyIO\n{\n    class Printer : IDisposable\n    {\n        bool isConsole;\n        TextWriter file;\n        public Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n        public Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n        public void Write<T>(T value) { file.Write(value); }\n        public void Write(bool b) { file.Write(b ? \"YES\" : \"NO\"); }\n        public void Write(string str, params object[] args) { file.Write(str, args); }\n        public void WriteLine() { file.WriteLine(); }\n        public void WriteLine<T>(T value) { file.WriteLine(value); }\n        public void WriteLine(bool b) { file.WriteLine(b ? \"YES\" : \"NO\"); }\n        public void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine(string str, params object[] args) { file.WriteLine(str, args); }\n        public void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n    }\n    class Scanner : IDisposable\n    {\n        bool isConsole;\n        TextReader file;\n        public Scanner() { file = Console.In; }\n        public Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n        public void Dispose() { if (!isConsole) file.Dispose(); }\n\n        #region next読み込み\n        string[] nextBuffer = new string[0];\n        int BufferCnt = 0;\n\n        char[] cs = new char[] { ' ' };\n\n        public string next()\n        {\n            while (BufferCnt >= nextBuffer.Length)\n            {\n                string st = file.ReadLine();\n                while (st == \"\") st = file.ReadLine();\n                nextBuffer = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                BufferCnt = 0;\n            }\n            return nextBuffer[BufferCnt++];\n        }\n\n        public int nextInt()\n        {\n            return int.Parse(next());\n        }\n\n        public long nextLong()\n        {\n            return long.Parse(next());\n        }\n\n        public double nextDouble()\n        {\n            return double.Parse(next());\n        }\n\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public string[] next(int n) { return enumerate(n, next); }\n        public double[] nextDouble(int n) { return enumerate(n, nextDouble); }\n        public int[] nextInt(int n) { return enumerate(n, nextInt); }\n        public long[] nextLong(int n) { return enumerate(n, nextLong); }\n        #endregion\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n//using System.Numerics;  //comment out if AOJ\nusing System.Text;\n\nusing Problem = Tmp.Problem;\nusing MyIO;\n\n#pragma warning disable   //for AOJ\n\nnamespace Tmp\n{\n    class Problem : IDisposable\n    {\n        bool IsGCJ;\n        int Repeat;\n        Scanner sc;\n        Printer pr;\n        public Problem(bool isGCJ, Scanner scanner, Printer printer)\n        {\n            sc = scanner;\n            pr = printer;\n            IsGCJ = isGCJ;\n            if (isGCJ) Repeat = sc.nextInt();\n            else Read();\n        }\n        public Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n        public Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n        public Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n        public void Solve()\n        {\n            if (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n            else SolveOne();\n        }\n        public void Dispose()\n        {\n            sc.Dispose();\n            pr.Dispose();\n        }\n        public int Size { get { return 1; } }\n        public const long Mod = 1000000007;\n\n        // 使用する変数をここに書く\n        // string S;\n        // int a;\n        /// <summary>\n        /// 読み込み処理をここに書く\n        /// </summary>\n        void Read()\n        {\n\n        }\n        /// <summary>\n        /// メイン処理をここに書く\n        /// </summary>\n        void SolveOne()\n        {\n            long n = sc.nextLong();\n            long e = sc.nextLong();\n            long t = sc.nextLong();\n            long[] x = sc.nextLong((int)n);\n\n            long[] dp = new long[n + 1];   //dp[i+1]: ibanme ga owatta\n            int[] bgnls = new int[n + 1];\n\n            dp[0] = x[0];\n            dp[1] = x[0] + t;\n            for (int now = 1; now < n; now++)\n            {\n                dp[now + 1] = dp[now] + (x[now] - x[now - 1]) + t;\n                int bgn = bgnls[now - 1];\n                long katamiti = x[now] - x[bgn];\n                long tmp = Math.Max(t + katamiti, katamiti * 3);\n                if (dp[now + 1] > x[bgn] + tmp)\n                {\n                    dp[now + 1] = x[bgn] + tmp;\n                    bgnls[now] = bgnls[now - 1];\n                }\n                else\n                {\n                    bgnls[now] = now;\n                }\n            }\n\n            Console.WriteLine(dp[n] + e - x[n - 1]);\n        }\n    }\n}\nclass Program\n{\n    //public static RandomSFMT rand = new RandomSFMT();\n    public static bool IsJudgeMode = true;\n    public static bool IsGCJMode = false;\n    public static bool IsSolveCreated = true;\n    static void Main()\n    {\n        if (IsJudgeMode)\n            if (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n            else using (var problem = new Problem(false, new Printer())) problem.Solve();\n        else\n        {\n            var num = 1;\n            int size = 0;\n            decimal time = 0;\n            for (var tmp = 0; tmp < num; tmp++)\n            {\n                using (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n                {\n                    size = P.Size;\n                    //time += Func.MeasureTime(() => P.Solve());\n                }\n            }\n            Console.WriteLine(\"{0}, {1}ms\", size, time / num);\n        }\n    }\n}\n\n/// <summary>\n/// カスタマイズしたIO\n/// </summary>\nnamespace MyIO\n{\n    class Printer : IDisposable\n    {\n        bool isConsole;\n        TextWriter file;\n        public Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n        public Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n        public void Write<T>(T value) { file.Write(value); }\n        public void Write(bool b) { file.Write(b ? \"YES\" : \"NO\"); }\n        public void Write(string str, params object[] args) { file.Write(str, args); }\n        public void WriteLine() { file.WriteLine(); }\n        public void WriteLine<T>(T value) { file.WriteLine(value); }\n        public void WriteLine(bool b) { file.WriteLine(b ? \"YES\" : \"NO\"); }\n        public void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine(string str, params object[] args) { file.WriteLine(str, args); }\n        public void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n    }\n    class Scanner : IDisposable\n    {\n        bool isConsole;\n        TextReader file;\n        public Scanner() { file = Console.In; }\n        public Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n        public void Dispose() { if (!isConsole) file.Dispose(); }\n\n        #region next読み込み\n        string[] nextBuffer = new string[0];\n        int BufferCnt = 0;\n\n        char[] cs = new char[] { ' ' };\n\n        public string next()\n        {\n            while (BufferCnt >= nextBuffer.Length)\n            {\n                string st = file.ReadLine();\n                while (st == \"\") st = file.ReadLine();\n                nextBuffer = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                BufferCnt = 0;\n            }\n            return nextBuffer[BufferCnt++];\n        }\n\n        public int nextInt()\n        {\n            return int.Parse(next());\n        }\n\n        public long nextLong()\n        {\n            return long.Parse(next());\n        }\n\n        public double nextDouble()\n        {\n            return double.Parse(next());\n        }\n\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public string[] next(int n) { return enumerate(n, next); }\n        public double[] nextDouble(int n) { return enumerate(n, nextDouble); }\n        public int[] nextInt(int n) { return enumerate(n, nextInt); }\n        public long[] nextLong(int n) { return enumerate(n, nextLong); }\n        #endregion\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n//using System.Numerics;  //comment out if AOJ\nusing System.Text;\n\nusing Problem = Tmp.Problem;\nusing MyIO;\n\n#pragma warning disable   //for AOJ\n\nnamespace Tmp\n{\n    class Problem : IDisposable\n    {\n        bool IsGCJ;\n        int Repeat;\n        Scanner sc;\n        Printer pr;\n        public Problem(bool isGCJ, Scanner scanner, Printer printer)\n        {\n            sc = scanner;\n            pr = printer;\n            IsGCJ = isGCJ;\n            if (isGCJ) Repeat = sc.nextInt();\n            else Read();\n        }\n        public Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n        public Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n        public Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n        public void Solve()\n        {\n            if (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n            else SolveOne();\n        }\n        public void Dispose()\n        {\n            sc.Dispose();\n            pr.Dispose();\n        }\n        public int Size { get { return 1; } }\n        public const long Mod = 1000000007;\n\n        // 使用する変数をここに書く\n        // string S;\n        // int a;\n        /// <summary>\n        /// 読み込み処理をここに書く\n        /// </summary>\n        void Read()\n        {\n\n        }\n        /// <summary>\n        /// メイン処理をここに書く\n        /// </summary>\n        void SolveOne()\n        {\n            long n = sc.nextLong();\n            long e = sc.nextLong();\n            long t = sc.nextLong();\n            long[] x = sc.nextLong((int)n);\n\n            long[] dp = new long[n + 10];   //dp[i+1]: ibanme ga owatta\n\n            dp[0] = x[0];\n            dp[1] = x[0] + t;\n            for (int now = 1; now < n; now++)\n            {\n                dp[now + 1] = dp[now] + (x[now] - x[now - 1]) + t;\n                for (int bgn = 0; bgn < now; bgn++)\n                {\n                    long katamiti = x[now] - x[bgn];\n                    long tmp =Math.Max(t+katamiti, katamiti * 3);\n                    dp[now + 1] = Math.Min(dp[now + 1], x[bgn] + tmp);\n                }\n            }\n\n            Console.WriteLine(dp[n ] + e - x[n-1]);\n        }\n    }\n}\nclass Program\n{\n    //public static RandomSFMT rand = new RandomSFMT();\n    public static bool IsJudgeMode = true;\n    public static bool IsGCJMode = false;\n    public static bool IsSolveCreated = true;\n    static void Main()\n    {\n        if (IsJudgeMode)\n            if (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n            else using (var problem = new Problem(false, new Printer())) problem.Solve();\n        else\n        {\n            var num = 1;\n            int size = 0;\n            decimal time = 0;\n            for (var tmp = 0; tmp < num; tmp++)\n            {\n                using (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n                {\n                    size = P.Size;\n                    //time += Func.MeasureTime(() => P.Solve());\n                }\n            }\n            Console.WriteLine(\"{0}, {1}ms\", size, time / num);\n        }\n    }\n}\n\n/// <summary>\n/// カスタマイズしたIO\n/// </summary>\nnamespace MyIO\n{\n    class Printer : IDisposable\n    {\n        bool isConsole;\n        TextWriter file;\n        public Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n        public Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n        public void Write<T>(T value) { file.Write(value); }\n        public void Write(bool b) { file.Write(b ? \"YES\" : \"NO\"); }\n        public void Write(string str, params object[] args) { file.Write(str, args); }\n        public void WriteLine() { file.WriteLine(); }\n        public void WriteLine<T>(T value) { file.WriteLine(value); }\n        public void WriteLine(bool b) { file.WriteLine(b ? \"YES\" : \"NO\"); }\n        public void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine(string str, params object[] args) { file.WriteLine(str, args); }\n        public void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n    }\n    class Scanner : IDisposable\n    {\n        bool isConsole;\n        TextReader file;\n        public Scanner() { file = Console.In; }\n        public Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n        public void Dispose() { if (!isConsole) file.Dispose(); }\n\n        #region next読み込み\n        string[] nextBuffer = new string[0];\n        int BufferCnt = 0;\n\n        char[] cs = new char[] { ' ' };\n\n        public string next()\n        {\n            while (BufferCnt >= nextBuffer.Length)\n            {\n                string st = file.ReadLine();\n                while (st == \"\") st = file.ReadLine();\n                nextBuffer = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                BufferCnt = 0;\n            }\n            return nextBuffer[BufferCnt++];\n        }\n\n        public int nextInt()\n        {\n            return int.Parse(next());\n        }\n\n        public long nextLong()\n        {\n            return long.Parse(next());\n        }\n\n        public double nextDouble()\n        {\n            return double.Parse(next());\n        }\n\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public string[] next(int n) { return enumerate(n, next); }\n        public double[] nextDouble(int n) { return enumerate(n, nextDouble); }\n        public int[] nextInt(int n) { return enumerate(n, nextInt); }\n        public long[] nextLong(int n) { return enumerate(n, nextLong); }\n        #endregion\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, e, t;\n        sc.Multi(out n, out e, out t);\n        if (n > 50000) return;\n\n        var x = sc.LongArr;\n        var dp = new long[n + 1];\n        dp[0] = 0;\n        dp[1] = t;\n        for (int i = 2; i < n + 1; i++)\n        {\n            dp[i] = dp[i - 1] + x[i - 1] - x[i - 2] + t;\n            for (int j = 0; j < i - 1; j++)\n            {\n                dp[i] = Math.Min(dp[i], Math.Max((x[i - 1] - x[j]) * 2, t) + x[i - 1] - x[j] + dp[j]);\n            }\n        }\n        sw.WriteLine(dp[n] + e - x[n - 1] + x[0]);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) => a.Max();\n    static T Min<T>(params T[] a) => a.Min();\n    static void DBG<T>(params T[] a) => Console.WriteLine(string.Join(\" \", a));\n    static void DBG(params object[] a) => Console.WriteLine(string.Join(\" \", a));\n    static void Prt<T>(params T[] a) => sw.WriteLine(string.Join(\" \", a));\n    static void Prt(params object[] a) => sw.WriteLine(string.Join(\" \", a));\n}\nclass Score : IComparable\n{\n    int score, time;\n    public int CompareTo(object obj)\n    {\n        var x = obj as Score;\n        return this.score == x.score ? x.time.CompareTo(this.time) : this.score.CompareTo(x.score);\n    }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\npublic static class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass scanCHK : sc\n{\n    public static new string Str { get { var s = Console.ReadLine(); return s == s.Trim() ? s : \"\"; } }\n}\nclass sc\n{\n    public static int Int => int.Parse(Str);\n    public static long Long => long.Parse(Str);\n    public static double Double => double.Parse(Str);\n    public static string Str => Console.ReadLine().Trim();\n    public static int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public static long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public static double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public static string[] StrArr => Str.Split();\n    static bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    static T ct<T, U>(U inp) => (T)Convert.ChangeType(inp, typeof(T));\n    static T cv<T>(string inp) => eq<T, int>() ? ct<T, int>(int.Parse(inp))\n                         : eq<T, long>() ? ct<T, long>(long.Parse(inp))\n                         : eq<T, double>() ? ct<T, double>(double.Parse(inp))\n                         : eq<T, char>() ? ct<T, char>(inp[0])\n                         : ct<T, string>(inp);\n    public static void Multi<T>(out T a) => a = cv<T>(Str);\n    public static void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public static void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public static void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public static void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nstruct ModInt\n{\n    public static long Mod = 1000000007;\n    long val;\n    public ModInt(long v) { val = (v % Mod + Mod) % Mod; }\n\n    public static implicit operator ModInt(long x) => new ModInt(x);\n    public static explicit operator long(ModInt x) => x.val;\n\n    public static ModInt operator+(ModInt x, ModInt y) => x.val + y.val;\n    public static ModInt operator-(ModInt x, ModInt y) => x.val - y.val;\n    public static ModInt operator*(ModInt x, ModInt y) => x.val * y.val;\n    // must : gcd(y, Mod) == 1\n    public static ModInt operator/(ModInt x, ModInt y) => x * ~y;\n    // powmod(x, y, Mod);\n    public static ModInt operator^(ModInt x, long y)\n    {\n        if (x.val == 0) return x;\n        if (y == 0) return 1;\n        var t = x ^ (y / 2);\n        if ((y & 1) == 0) return t * t;\n        return t * t * x;\n    }\n\n    public static ModInt operator-(ModInt x) => -(x.val);\n    // inv(x) : x * inv(x) == 1\n    // must : gcd(x, Mod) == 1\n    public static ModInt operator~(ModInt x) => x ^ (Mod - 2);\n\n    public override string ToString() => this.val.ToString();\n\n    // public static bool operator==(ModInt x, ModInt y) => x.val == y.val;\n    // public static bool operator!=(ModInt x, ModInt y) => x.val != y.val;\n    // public override bool Equals(object obj) => obj != null && this.GetType() == obj.GetType() && this.val == ((ModInt)obj).val;\n    // public override int GetHashCode() => (int)this.val;\n\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] trans(long[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++)\n        {\n            ret[i] = new long[m];\n            for (int j = 0; j < m; j++) ret[i][j] = A[j][i];\n        }\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a;\n        x = 1;\n        y = 0;\n        if (b != 0)\n        {\n            g = extgcd(b, a % b, out y, out x);\n            y -= a / b * x;\n        }\n        return g;\n    }\n    public static long lcm(long a, long b) => a * (b / gcd(a, b));\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AGC007\n{\n    public class D\n    {\n        private int N;\n        private long E;\n        private long T;\n        private long[] xs;\n\n        private long F(int current, int target)\n        {\n            long move = xs[target] - xs[current];\n            long t = 2 * move; // →←の順に進み、進み際にキャンディを上げた状態\n            if (t < T) { t = T; }   // 最初のクマがコインを吐き出すまで待つ\n            return t + move;   // 移動分\n        }\n\n        private void Run()\n        {\n            var input = Console.ReadLine().Trim().Split();\n            N = int.Parse(input[0]);\n            E = long.Parse(input[1]);\n            T = long.Parse(input[2]);\n            xs = Console.ReadLine().Trim().Split().Select(long.Parse).ToArray();\n\n            if (N > 1000) { throw new Exception(\"worth 600 points algorithm.\"); }\n\n            long res = xs[0];   // 開始地点から最初のクマまで移動\n            int i = 0;\n            while (i < N)\n            {\n                int go = i;\n                while (true)\n                {\n                    int next = go + 1;\n                    if (next >= N) { break; }\n                    long temp1 = (xs[next] - xs[i] + (next - i + 1) * T);   // キャンディを与えて毎回待つ\n                    long temp2 = F(i, next);    // 先までキャンディをあげて、戻ってコインを取る\n                    if (temp1 < temp2) { break; }\n                    go = next;\n                }\n                res += F(i, go);\n                if (go + 1 < N)\n                {\n                    res += xs[go + 1] - xs[go];\n                }\n                i = go + 1;\n            }\n            res += E - xs.Last();   // 最後のクマからゴールへ移動\n\n            Console.WriteLine(res);\n        }\n\n        public static void Main()\n        {\n            var old = Console.Out;\n            using (var writer = new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false })\n            {\n                Console.SetOut(writer);\n                new D().Run();\n                Console.Out.Flush();\n                Console.SetOut(old);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, e, t;\n        sc.Multi(out n, out e, out t);\n        if (n > 5000) return;\n\n        var x = sc.LongArr;\n        var dp = new long[n + 1];\n        dp[0] = 0;\n        dp[1] = t;\n        for (int i = 1; i < n; i++)\n        {\n            dp[i + 1] = Math.Min(dp[i] + x[i] - x[i - 1] + t, Math.Max((x[i] - x[0]) * 2, t) + x[i] - x[0]);\n            for (int j = 0; j < i; j++)\n            {\n                dp[i + 1] = Math.Min(dp[i + 1], Math.Max((x[i] - x[j + 1]) * 2, t) + x[i] - x[j] + dp[j + 1]);\n            }\n        }\n        sw.WriteLine(dp[n] + e - x[n - 1] + x[0]);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) => a.Max();\n    static T Min<T>(params T[] a) => a.Min();\n    static void DBG<T>(params T[] a) => Console.WriteLine(string.Join(\" \", a));\n    static void DBG(params object[] a) => Console.WriteLine(string.Join(\" \", a));\n    static void Prt<T>(params T[] a) => sw.WriteLine(string.Join(\" \", a));\n    static void Prt(params object[] a) => sw.WriteLine(string.Join(\" \", a));\n}\nclass Score : IComparable\n{\n    int score, time;\n    public int CompareTo(object obj)\n    {\n        var x = obj as Score;\n        return this.score == x.score ? x.time.CompareTo(this.time) : this.score.CompareTo(x.score);\n    }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\npublic static class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass scanCHK : sc\n{\n    public static new string Str { get { var s = Console.ReadLine(); return s == s.Trim() ? s : \"\"; } }\n}\nclass sc\n{\n    public static int Int => int.Parse(Str);\n    public static long Long => long.Parse(Str);\n    public static double Double => double.Parse(Str);\n    public static string Str => Console.ReadLine().Trim();\n    public static int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public static long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public static double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public static string[] StrArr => Str.Split();\n    static bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    static T ct<T, U>(U inp) => (T)Convert.ChangeType(inp, typeof(T));\n    static T cv<T>(string inp) => eq<T, int>() ? ct<T, int>(int.Parse(inp))\n                         : eq<T, long>() ? ct<T, long>(long.Parse(inp))\n                         : eq<T, double>() ? ct<T, double>(double.Parse(inp))\n                         : eq<T, char>() ? ct<T, char>(inp[0])\n                         : ct<T, string>(inp);\n    public static void Multi<T>(out T a) => a = cv<T>(Str);\n    public static void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public static void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public static void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public static void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nstruct ModInt\n{\n    public static long Mod = 1000000007;\n    long val;\n    public ModInt(long v) { val = (v % Mod + Mod) % Mod; }\n\n    public static implicit operator ModInt(long x) => new ModInt(x);\n    public static explicit operator long(ModInt x) => x.val;\n\n    public static ModInt operator+(ModInt x, ModInt y) => x.val + y.val;\n    public static ModInt operator-(ModInt x, ModInt y) => x.val - y.val;\n    public static ModInt operator*(ModInt x, ModInt y) => x.val * y.val;\n    // must : gcd(y, Mod) == 1\n    public static ModInt operator/(ModInt x, ModInt y) => x * ~y;\n    // powmod(x, y, Mod);\n    public static ModInt operator^(ModInt x, long y)\n    {\n        if (x.val == 0) return x;\n        if (y == 0) return 1;\n        var t = x ^ (y / 2);\n        if ((y & 1) == 0) return t * t;\n        return t * t * x;\n    }\n\n    public static ModInt operator-(ModInt x) => -(x.val);\n    // inv(x) : x * inv(x) == 1\n    // must : gcd(x, Mod) == 1\n    public static ModInt operator~(ModInt x) => x ^ (Mod - 2);\n\n    public override string ToString() => this.val.ToString();\n\n    // public static bool operator==(ModInt x, ModInt y) => x.val == y.val;\n    // public static bool operator!=(ModInt x, ModInt y) => x.val != y.val;\n    // public override bool Equals(object obj) => obj != null && this.GetType() == obj.GetType() && this.val == ((ModInt)obj).val;\n    // public override int GetHashCode() => (int)this.val;\n\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] trans(long[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++)\n        {\n            ret[i] = new long[m];\n            for (int j = 0; j < m; j++) ret[i][j] = A[j][i];\n        }\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a;\n        x = 1;\n        y = 0;\n        if (b != 0)\n        {\n            g = extgcd(b, a % b, out y, out x);\n            y -= a / b * x;\n        }\n        return g;\n    }\n    public static long lcm(long a, long b) => a * (b / gcd(a, b));\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Number = System.Int64;\n\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var xs = new long[n + 1];\n            long t;\n            {\n                var e = sc.Long();\n                t = sc.Long();\n                for (int i = 0; i < n; i++)\n                    xs[i] = sc.Long();\n                xs[n] = e;\n            }\n            var dp = Enumerate(n + 1, x => 1L << 60);\n            dp[0] = xs[0];\n\n            var min = 1L << 60;\n            var deq = new Deque<KeyValuePair<int, long>>();\n            deq.PushBack(new KeyValuePair<int, long>(0, dp[0]));\n\n            for (int i = 1; i <= n; i++)\n            {\n                while (deq.Count > 0)\n                {\n                    var p = deq[0].Key;\n                    if (2 * (xs[i - 1] - xs[p]) >= t)\n                        min = Math.Min(min, 3 * (xs[i - 1] - xs[p]) + deq.PopFront().Value);\n                    else break;\n                }\n                dp[i] = Math.Min(dp[i], min);\n                if (deq.Count > 0)\n                    dp[i] = Math.Min(dp[i], deq[0].Value + t + xs[i - 1] - xs[deq[0].Key]);\n                /*\n                for (int j = i + 1; j <= n; j++)\n                {\n                    var dx = xs[j] - xs[j - 1];\n                    dp[j] = Math.Min(dp[j], Math.Max(3 * d, t + d) + dp[i] + dx);\n                    d += dx;\n                }\n                Debug.WriteLine(dp.Items.AsJoinedString());\n                */\n                var dx = xs[i] - xs[i - 1];\n                min += 3 * dx;\n                dp[i] += dx;\n                //\n                while (deq.Count > 0)\n                {\n                    var p = deq[deq.Count - 1];\n                    if (p.Value + xs[i] - xs[p.Key] > dp[i]) deq.PopBack();\n                    else break;\n                }\n                deq.PushBack(new KeyValuePair<int, Number>(i, dp[i]));\n            }\n            IO.Printer.Out.WriteLine(dp[n]);\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region Deque<T>\n\npublic class Deque<T>\n{\n    T[] buf;\n    int offset;\n    int count;\n    int capacity;\n    public int Count { get { return count; } }\n    public Deque(int cap) { buf = new T[capacity = cap]; }\n    public Deque() { buf = new T[capacity = 8]; }\n    public T this[int index]\n    {\n        get { return buf[getIndex(index)]; }\n        set { buf[getIndex(index)] = value; }\n    }\n    private int getIndex(int index)\n    {\n        if (index >= capacity)\n            throw new IndexOutOfRangeException(\"out of range\");\n        var ret = index + offset;\n        if (ret >= capacity)\n            ret -= capacity;\n        return ret;\n    }\n    public void PushFront(T item)\n    {\n        if (count == capacity) Extend();\n        if (--offset < 0) offset += buf.Length;\n        buf[offset] = item;\n        ++count;\n    }\n    public T PopFront()\n    {\n        if (count == 0)\n            throw new InvalidOperationException(\"collection is empty\");\n        --count;\n        var ret = buf[offset++];\n        if (offset >= capacity) offset -= capacity;\n        return ret;\n    }\n    public void PushBack(T item)\n    {\n        if (count == capacity) Extend();\n        var id = count++ + offset;\n        if (id >= capacity) id -= capacity;\n        buf[id] = item;\n    }\n    public T PopBack()\n    {\n        if (count == 0)\n            throw new InvalidOperationException(\"collection is empty\");\n        return buf[getIndex(--count)];\n    }\n    public void Insert(T item, int index)\n    {\n        if (index > count) throw new IndexOutOfRangeException();\n        this.PushFront(item);\n        for (int i = 0; i < index; i++)\n            this[i] = this[i + 1];\n        this[index] = item;\n    }\n    public T RemoveAt(int index)\n    {\n        if (index < 0 || index >= count) throw new IndexOutOfRangeException();\n        var ret = this[index];\n        for (int i = index; i > 0; i--)\n            this[i] = this[i - 1];\n        this.PopFront();\n        return ret;\n    }\n    private void Extend()\n    {\n        T[] newBuffer = new T[capacity << 1];\n        if (offset > capacity - count)\n        {\n            var len = buf.Length - offset;\n            Array.Copy(buf, offset, newBuffer, 0, len);\n            Array.Copy(buf, 0, newBuffer, len, count - len);\n        }\n        else Array.Copy(buf, offset, newBuffer, 0, count);\n        buf = newBuffer;\n        offset = 0;\n        capacity <<= 1;\n    }\n    public T[] Items\n    {\n        get\n        {\n            var a = new T[count];\n            for (int i = 0; i < count; i++)\n                a[i] = this[i];\n            return a;\n        }\n    }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Threading;\n\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n\tpublic Program() { }\n\n\tstatic void Main(string[] args)\n\t{\n\t\tnew Program().prog();\n\t}\n\tScanner cin;\n\tconst int MOD = 1000000007;\n\tconst int INF = int.MaxValue - 10;\n\tconst long INFL = long.MaxValue - 10;\n\tconst double EPS = 1e-7;\n\tconst double PI = 3.1415926536;\n\n\tint N;\n\tvoid prog()\n\t{\n\t\tcin = new Scanner();\n\t\tint[,] dir8 = new int[8, 2] { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };\n\t\tint[,] dir4 = new int[4, 2] { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tint T = cin.nextInt();\n\t\tint[] x = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tx[i] = cin.nextInt();\n\t\t}\n\t\tlong ans = E;\n\t\tint left = 0, right = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif(right == N - 1)\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x[right + 1] - x[left] <= T)\n\t\t\t{\n\t\t\t\tif (right != N - 2 && x[right + 2] - x[right + 1] <x[right + 1] - x[right])\n\t\t\t\t{\n\t\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\t\tleft = right + 1;\n\t\t\t\t\tright = left;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tright++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tleft = right + 1;\n\t\t\t\tright = left;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(ans);\n\t}\n}\n\nclass Scanner\n{\n\tstring[] s;\n\tint i;\n\n\tchar[] cs = new char[] { ' ' };\n\n\tpublic Scanner()\n\t{\n\t\ts = new string[0];\n\t\ti = 0;\n\t}\n\n\tpublic string next()\n\t{\n\t\tif (i < s.Length) return s[i++];\n\t\tstring st = Console.ReadLine();\n\t\twhile (st == \"\") st = Console.ReadLine();\n\t\ts = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n\t\ti = 0;\n\t\treturn next();\n\t}\n\n\tpublic int nextInt()\n\t{\n\t\treturn int.Parse(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn long.Parse(next());\n\t}\n\n\tpublic double nextDouble()\n\t{\n\t\treturn double.Parse(next());\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        long E = long.Parse(str[1]);\n        long T = long.Parse(str[2]);\n        long[] x = new long[N];\n        str = Console.ReadLine().Split(' ');\n        for(int i=0;i<N;i++){\n            x[i] = long.Parse(str[i]);\n        }\n        long[] dp = new long[N];\n        long m = -2 * x[0];\n        int p = -1;\n        for(int i=0;i<N;i++){\n            while(2 * x[p+1] + T < 2 * x[i]){\n                p++;\n                if(p != 0){\n                    m = m > dp[p-1] - 2 * x[p] ? dp[p-1] - 2 * x[p] : m;\n                }\n            }\n            if(p == -1){\n                dp[i] = T;\n            }\n            else{\n                dp[i] = T + dp[p] < 2 * x[i] + m ? T + dp[p] : 2 * x[i] + m;\n            }\n        }\n        Console.WriteLine(E+dp[N-1]);\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    public void Solve()\n    {\n        int n = ReadInt();\n        int e = ReadInt();\n        int m = ReadInt();\n        var a = ReadIntArray();\n        \n        if (n > 2000)\n            throw new Exception();\n\n        var dp = new long[n + 1];\n        for (int i = 0; i < n; i++)\n        {\n            dp[i + 1] = dp[i] + a[i] - (i > 0 ? a[i - 1] : 0) + m;\n            for (int j = 0; j < i; j++)\n            {\n                int p = j > 0 ? a[j - 1] : 0; \n                dp[i + 1] = Math.Min(dp[i + 1], dp[j] + Math.Max(2 * a[i] - p - a[j], a[j] - p + m) + a[i] - a[j]);\n            }\n        }\n\n        Write(dp[n] + e - a[n - 1]);\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        long E = long.Parse(str[1]);\n        long T = long.Parse(str[2]);\n        long[] x = new long[N];\n        str = Console.ReadLine().Split(' ');\n        for(int i=0;i<N;i++){\n            x[i] = long.Parse(str[i]);\n        }\n        long[] dp = new long[N];\n        int p = -1;\n        for(int i=0;i<N;i++){\n            while(2 * x[p+1] + T < 2 * x[i]){\n                p++;\n            }\n            if(p == -1){\n                dp[i] = T;\n            }\n            else if(p == i-1){\n                if(i == 1){\n                    dp[i] = T + dp[i-1] > 2 * (x[i] - x[i-1]) ? 2 * (x[i] - x[i-1]) : T + dp[i-1];\n                }\n                else{\n                    dp[i] = T + dp[i-1] > 2 * (x[i] - x[i-1]) + dp[i-2] ? 2 * (x[i] - x[i-1]) + dp[i-2] : T + dp[i-1];\n                }\n            }\n            else{\n                dp[i] = T + dp[p+1] < 2 * (x[i] - x[p+1]) + dp[p] ? T + dp[p+1] : 2 * (x[i] - x[p+1]) + dp[p];\n            }\n        }\n        Console.WriteLine(E+dp[N-1]);\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Threading;\n\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n\tpublic Program() { }\n\n\tstatic void Main(string[] args)\n\t{\n\t\tnew Program().prog();\n\t}\n\tScanner cin;\n\tconst int MOD = 1000000007;\n\tconst int INF = int.MaxValue - 10;\n\tconst long INFL = long.MaxValue - 10;\n\tconst double EPS = 1e-7;\n\tconst double PI = 3.1415926536;\n\n\tint N;\n\tvoid prog()\n\t{\n\t\tcin = new Scanner();\n\t\tint[,] dir8 = new int[8, 2] { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };\n\t\tint[,] dir4 = new int[4, 2] { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tint T = cin.nextInt();\n\t\tint[] x = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tx[i] = cin.nextInt();\n\t\t}\n\t\tlong ans = E;\n\t\tint pre = x[0];\n\t\tint left = 0, right = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif(right == N - 1)\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x[right + 1] - x[left] <= T)\n\t\t\t{\n\t\t\t\tright++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tleft = right + 1;\n\t\t\t\tright = left;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(ans);\n\t}\n}\n\nclass Scanner\n{\n\tstring[] s;\n\tint i;\n\n\tchar[] cs = new char[] { ' ' };\n\n\tpublic Scanner()\n\t{\n\t\ts = new string[0];\n\t\ti = 0;\n\t}\n\n\tpublic string next()\n\t{\n\t\tif (i < s.Length) return s[i++];\n\t\tstring st = Console.ReadLine();\n\t\twhile (st == \"\") st = Console.ReadLine();\n\t\ts = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n\t\ti = 0;\n\t\treturn next();\n\t}\n\n\tpublic int nextInt()\n\t{\n\t\treturn int.Parse(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn long.Parse(next());\n\t}\n\n\tpublic double nextDouble()\n\t{\n\t\treturn double.Parse(next());\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AGC007\n{\n    public class D\n    {\n        private int N;\n        private long E;\n        private long T;\n        private long[] xs;\n\n        private long F(int current, int target)\n        {\n            long move = xs[target] - xs[current];\n            long t = 2 * move; // →←の順に進み、進み際にキャンディを上げた状態\n            if (t < T) { t = T; }   // 最初のクマがコインを吐き出すまで待つ\n            return t + move;   // 移動分\n        }\n\n        private void Run()\n        {\n            var input = Console.ReadLine().Trim().Split();\n            N = int.Parse(input[0]);\n            E = long.Parse(input[1]);\n            T = long.Parse(input[2]);\n            xs = Console.ReadLine().Trim().Split().Select(long.Parse).ToArray();\n\n            if (N > 2000) { throw new Exception(\"worth 600 points algorithm.\"); }\n\n            long res = xs[0];   // 開始地点から最初のクマまで移動\n            int i = 0;\n            while (i < N)\n            {\n                int go = i;\n                while (true)\n                {\n                    int next = go + 1;\n                    if (next >= N) { break; }\n                    long temp1 = (xs[next] - xs[i] + (next - i + 1) * T);   // キャンディを与えて毎回待つ\n                    long temp2 = F(i, next);    // 先までキャンディをあげて、戻ってコインを取る\n                    if (temp1 < temp2) { break; }\n                    go = next;\n                }\n                res += F(i, go);\n                if (go + 1 < N)\n                {\n                    res += xs[go + 1] - xs[go];\n                }\n                i = go + 1;\n            }\n            res += E - xs.Last();   // 最後のクマからゴールへ移動\n\n            Console.WriteLine(res);\n        }\n\n        public static void Main()\n        {\n            var old = Console.Out;\n            using (var writer = new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false })\n            {\n                Console.SetOut(writer);\n                new D().Run();\n                Console.Out.Flush();\n                Console.SetOut(old);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tif(N>2000){\n\t\t\tConsole.WriteLine(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong[] dp = new long[N+1];\n\t\tdp[0] = 0;\n\t\tfor(int i=1;i<N+1;i++){\n\t\t\tdp[i] = long.MaxValue;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<=N;j++){\n\t\t\t\tlong dist = X[j] - X[i];\n\t\t\t\tif(j==i+1){\n\t\t\t\t\tdp[j] = Math.Min(dp[j],dp[i]+dist+T);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong x = Math.Max(dist+T,(Math.Max(T,dist+dist-(X[i+1]-X[i])) + dist)-(X[i+1]-X[i]));\n\t\t\t\tdp[j] = Math.Min(dp[j],x+dp[i]);\n\t\t\t}\n//Console.WriteLine(String.Join(\" \",dp));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(dp[N] + (X[N+1]-X[N]));\n\t\t\n\t\t\n\t}\n\tint N;\n\tlong E,T;\n\tlong[] X;\n\tpublic Sol(){\n\t\tvar d = ria();\n\t\tN = d[0];\n\t\tE = d[1];\n\t\tT = d[2];\n\t\tX = new long[N+2];\n\t\tvar dd = rla();\n\t\tX[0] = 0;\n\t\tfor(int i=0;i<N;i++) X[i+1] = dd[i];\n\t\tX[N+1] = E;\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Threading;\n\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n\tpublic Program() { }\n\n\tstatic void Main(string[] args)\n\t{\n\t\tnew Program().prog();\n\t}\n\tScanner cin;\n\tconst int MOD = 1000000007;\n\tconst int INF = int.MaxValue - 10;\n\tconst long INFL = long.MaxValue - 10;\n\tconst double EPS = 1e-7;\n\tconst double PI = 3.1415926536;\n\n\tint N;\n\tvoid prog()\n\t{\n\t\tcin = new Scanner();\n\t\tint[,] dir8 = new int[8, 2] { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };\n\t\tint[,] dir4 = new int[4, 2] { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tint T = cin.nextInt();\n\t\tint[] x = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tx[i] = cin.nextInt();\n\t\t}\n\t\tlong ans = E;\n\t\tint left = 0, right = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif(right == N - 1)\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x[right + 1] - x[left] <= T)\n\t\t\t{\n\t\t\t\tif (right != N - 2 && x[right + 2] - x[right + 1] < x[right + 1] - x[right] && x[right + 2] - x[right] > T)\n\t\t\t\t{\n\t\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\t\tleft = right + 1;\n\t\t\t\t\tright = left;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tright++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += Math.Max(2 * (x[right] - x[left]), T);\n\t\t\t\tleft = right + 1;\n\t\t\t\tright = left;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(ans);\n\t}\n}\n\nclass Scanner\n{\n\tstring[] s;\n\tint i;\n\n\tchar[] cs = new char[] { ' ' };\n\n\tpublic Scanner()\n\t{\n\t\ts = new string[0];\n\t\ti = 0;\n\t}\n\n\tpublic string next()\n\t{\n\t\tif (i < s.Length) return s[i++];\n\t\tstring st = Console.ReadLine();\n\t\twhile (st == \"\") st = Console.ReadLine();\n\t\ts = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n\t\ti = 0;\n\t\treturn next();\n\t}\n\n\tpublic int nextInt()\n\t{\n\t\treturn int.Parse(next());\n\t}\n\n\tpublic long nextLong()\n\t{\n\t\treturn long.Parse(next());\n\t}\n\n\tpublic double nextDouble()\n\t{\n\t\treturn double.Parse(next());\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "n,e,t=gets.split.map &:to_i\nx=gets.split.map{|x|x.to_i*2}\nx.push(e*2)\nw=10**15\nj=0\ny=Array.new(n+1,0)\n0.upto(n-1){|i|\nwhile j<i&&t<x[i]-x[j] do\nw=[w,y[j]+x[i]-x[j]].min\nj+=1\nend\ny[i+1]=[w,y[j]+[t, x[i]-x[j]].max].min\nw+=x[i+1]-x[i]}\nputs y[n]+e"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\n// import dcomp.scanner;\n// import dcomp.algorithm;\n\nint n;\nstruct Edge {\n    int to;\n    long dist;\n}\nEdge[][] g;\nlong md;\n\nlong[2][] dfs(int p) {\n    if (g[p].empty) {\n        return [[0L, 0L]];\n    }\n    Edge le = g[p][0], re = g[p][1];\n    auto lt = dfs(le.to);\n    auto rt = dfs(re.to);\n    if (lt.length > rt.length) {\n        swap(le, re);\n        swap(lt, rt);\n    }\n    long ld = le.dist, rd = re.dist;\n    long[2][] ans;\n    foreach (co; lt) {\n        //co[1] + ld + rd + rco[0] <= md\n        int idx = binSearch!((i){return co[1]+ld+rd+rt[i][0] > md;})(-1L, rt.length).to!int-1;\n        if (idx == -1) continue;\n        ans ~= [co[0]+ld, rt[idx][1]+rd];\n        ans ~= [rt[idx][1]+rd, co[0]+ld];\n    }\n    sort(ans);\n    if (ans.empty) return ans;\n    long[2][] buf;\n    long ma = 10L^^15;\n    foreach (e; ans) {\n        if (ma <= e[1]) continue;\n        ma = min(ma, e[1]);\n        buf ~= e;\n    }\n    return buf;\n}\n\n//md以下にできるか？\nbool solve(long _md) {\n    md = _md;\n    return !dfs(0).empty;\n}\n\nint main() {\n    auto sc = new Scanner();\n    int n;\n    sc.read(n);\n    g = new Edge[][](n);\n    foreach (i; 1..n) {\n        int a; long b;\n        sc.read(a, b); a--;\n        g[a] ~= Edge(i, b);\n    }\n\n    writeln(binSearch!solve(-1L, 10L^^12));\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, readln, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeString, isDynamicArray;\n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = readln.split;\n        }\n        return true;\n    }\n    int read(Args...)(auto ref Args args) {\n        foreach (i, ref v; args) {\n            if (!succ()) return i;\n            alias VT = typeof(v);\n            static if (!isSomeString!VT && isDynamicArray!VT) {\n                v = buf.map!(to!(ElementType!VT)).array;\n                buf.length = 0;\n            } else {\n                v = buf.front.to!VT;\n                buf.popFront();\n            }\n        }\n        return args.length;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nclass A{\n\tulong s, w;\n\tthis(ulong s, ulong w){\n\t\tthis.s = s;\n\t\tthis.w = w;\n\t\t}\n\tA son1(ulong t, ulong x){\n\t\tdebug writeln(\"1\", [s, w, t, x]);\n\t\tif(w < x + x){\n\t\t\tif(t < x + x) return new A(s - w + x + x + x, 0);\n\t\t\telse return new A(s - w + x + t, t - x - x);\n\t\t\t}\n\t\telse return new A(s - w + x + t, t - w);\n\t\t}\n\tA son2(ulong t, ulong x){\n\t\tdebug writeln(\"2\", [s, w, t, x]);\n\t\treturn new A(s + x + t, t);\n\t\t}\n\tstring toString(){\n\t\treturn \"(\" ~ s.to!string ~ \",\" ~ w.to!string ~ \")\";\n\t\t}\n\t}\n\nvoid main(){\n\tint n, t, e;\n\t{\n\t\tint[] tmp = readln.chomp.split.map!(to!int).array;\n\t\tn = tmp[0], e = tmp[1], t = tmp[2];\n\t\t}\n\t\n\tint[] xs = readln.chomp.split.map!(to!int).array;\n\tint[] ys = [xs[0]];\n\tforeach(i; 1 .. n) ys ~= xs[i] - xs[i - 1];\n\t\n\tA[] as = [new A(0, 0)];\n\tforeach(y; ys){\n\t\tA[] tmpas;\n\t\tforeach(a; as){\n\t\t\ttmpas ~= a.son1(t, y);\n\t\t\ttmpas ~= a.son2(t, y);\n\t\t\t}\n\t\tas = [];\n\t\ttmpas.sort!(\"(a.s == b.s)? (a.w > b.w): (a.s < b.s)\")();\n\t\tulong maxw = 0;\n\t\tforeach(a; tmpas){\n\t\t\tif(a.w > maxw){\n\t\t\t\tas ~= a;\n\t\t\t\tmaxw = a.w;\n\t\t\t\t}\n\t\t\t}\n\t\tdebug tmpas.writeln;\n\t\tdebug as.writeln;\n\t\t}\n\t\n\t\n\tulong mins = ulong.max;\n\tforeach(a; as) if(a.s < mins) mins = a.s;\n\t\n\tulong ans = mins + (e - xs[$ - 1]);\n\tans.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.typecons;\nimport std.range;\nimport std.random;\nimport std.range;\n\nvoid main() {\n  auto input = readln.split;\n  auto N = input[0].to!int;\n  auto E = input[1].to!long;\n  auto T = input[2].to!long;\n  auto X = readln.split.map!(to!long).array;\n\n  Tuple!(long, int, int)[] hoge;\n  foreach (i; 0..N)\n    foreach (j; i+1..N) {\n      long d = X[j] - X[i];\n      long score = d*2+max(0, T-2*d) - (j-i+1)*T;\n      if (score < 0)\n\thoge ~= tuple(score, i, j);\n    }\n  hoge = hoge.sort;\n\n  Tuple!(long, int, int)[] piyo;\n  foreach (h; hoge) {\n    bool flag = true;\n    foreach (p; piyo) {\n      if ((p[1] <= h[1] && h[1] <= p[2] ||\n\t   p[1] <= h[2] && h[2] <= p[2])) {\n\t    flag = false;\n\t    break;\n      }\n    }\n    if (flag)\n      piyo ~= h;\n  }\n\n  long ans = E+T*N;\n  foreach (p; piyo)\n    ans -= p[0];\n  writeln(ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nclass A{\n\tulong s, w;\n\tthis(ulong s, ulong w){\n\t\tthis.s = s;\n\t\tthis.w = w;\n\t\t}\n\tA son1(ulong t, ulong x){\n\t\tdebug writeln(\"1\", [s, w, t, x]);\n\t\tif(w < x + x){\n\t\t\tif(t < x + x) return new A(s - w + x + x + x, 0);\n\t\t\telse return new A(s - w + x + t, t - x - x);\n\t\t\t}\n\t\telse return new A(s - w + x + t, t - w);\n\t\t}\n\tA son2(ulong t, ulong x){\n\t\tdebug writeln(\"2\", [s, w, t, x]);\n\t\treturn new A(s + x + t, t);\n\t\t}\n\tstring toString(){\n\t\treturn \"(\" ~ s.to!string ~ \",\" ~ w.to!string ~ \")\";\n\t\t}\n\t}\n\nvoid main(){\n\tint n, t, e;\n\t{\n\t\tint[] tmp = readln.chomp.split.map!(to!int).array;\n\t\tn = tmp[0], e = tmp[1], t = tmp[2];\n\t\t}\n\t\n\tint[] xs = readln.chomp.split.map!(to!int).array;\n\tint[] ys = [xs[0]];\n\tforeach(i; 1 .. n) ys ~= xs[i] - xs[i - 1];\n\t\n\tA[] as = [new A(0, 0)];\n\tforeach(y; ys){\n\t\tA[] tmpas;\n\t\tforeach(a; as){\n\t\t\ttmpas ~= a.son1(t, y);\n\t\t\ttmpas ~= a.son2(t, y);\n\t\t\t}\n\t\tas = [];\n\t\ttmpas.sort!(\"a.s < b.s\")();\n\t\tulong maxw = 0;\n\t\tforeach(a; tmpas){\n\t\t\tif(a.w > maxw){\n\t\t\t\tas ~= a;\n\t\t\t\tmaxw = a.w;\n\t\t\t\t}\n\t\t\t}\n\t\tdebug tmpas.writeln;\n\t\tdebug as.writeln;\n\t\t}\n\t\n\t\n\tulong mins = ulong.max;\n\tforeach(a; as) if(a.s < mins) mins = a.s;\n\t\n\tulong ans = mins + (e - xs[$ - 1]);\n\tans.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\nimport dcomp.scanner;\nimport dcomp.algorithm;\n\nstruct Node {\n    alias NP = Node*;\n    long mi;\n    NP l, r;\n    int sz;\n    this(int sz) {\n        this.sz = sz;\n        if (sz == 1) return;\n        l = new Node(sz/2);\n        r = new Node(sz-sz/2);\n    }\n    void set(int k, long x) {\n        if (sz == 1) {\n            mi = x;\n            return;\n        }\n        if (k < sz/2) {\n            l.set(k, x);\n        } else {\n            r.set(k-sz/2, x);\n        }\n        mi = min(l.mi, r.mi);\n    }\n    long get(int a, int b) {\n        if (b <= 0 || sz <= a) return 10L^^12;\n        if (a <= 0 && sz <= b) return mi;\n        return min(l.get(a, b), r.get(a-sz/2, b-sz/2));\n    }\n    string toString() {\n        if (sz == 1) {\n            return mi.to!string ~ \", \";\n        }\n        return l.toString ~ r.toString;\n    }\n}\n\nint main() {\n    import std.conv;\n    auto sc = new Scanner();\n    int n; long e, T;\n    long[] x;\n    sc.read(n, e, T, x);\n    x ~= e;\n    long[] next = iota(n).map!(i => x[i+1]-x[i]).array;\n//    writeln(next);\n    long[] dp = new long[](n+1);\n    Node* tr1 = new Node(n); //dp[i+1] + 3*dist[j] + next[j]\n    Node* tr2 = new Node(n); //dp[i+1] + T + dist[j] + next[j]\n    dp[n] = 0;\n    foreach_reverse (i; 0..n) {\n        tr1.set(i, dp[i+1] + 3*x[i] + next[i]);\n        tr2.set(i, dp[i+1] + T + x[i] + next[i]);\n//        writeln(tr1.toString);\n//        writeln(tr2.toString);\n        int div = binSearch!(j => 2*(x[j]-x[i]) >= T)(i, n);\n        //[div, n-1) tr1\n        //[i, div) tr2\n        long ans = 10L^^12;\n        ans = min(ans, tr1.get(div, n) - 3*x[i]);\n//        writeln(i, \" a \", div, \" \", tr1.get(div, n));\n        ans = min(ans, tr2.get(i, div) - x[i]);\n        dp[i] = ans;\n    }\n//    writeln(dp);\n    writeln(dp[0] + x[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nclass A{\n\tulong s, w;\n\tthis(ulong s, ulong w){\n\t\tthis.s = s;\n\t\tthis.w = w;\n\t\t}\n\tA son1(ulong t, ulong x){\n\t\tdebug writeln(\"1\", [s, w, t, x]);\n\t\tif(w < x + x){\n\t\t\tif(t < x + x) return new A(s - w + x + x + x, 0);\n\t\t\telse return new A(s - w + x + t, t - x - x);\n\t\t\t}\n\t\telse return new A(s - w + x + t, t - w);\n\t\t}\n\tA son2(ulong t, ulong x){\n\t\tdebug writeln(\"2\", [s, w, t, x]);\n\t\treturn new A(s + x + t, t);\n\t\t}\n\tstring toString(){\n\t\treturn \"(\" ~ s.to!string ~ \",\" ~ w.to!string ~ \")\";\n\t\t}\n\t}\n\nvoid main(){\n\tint n, t, e;\n\t{\n\t\tint[] tmp = readln.chomp.split.map!(to!int).array;\n\t\tn = tmp[0], e = tmp[1], t = tmp[2];\n\t\t}\n\t\n\tint[] xs = readln.chomp.split.map!(to!int).array;\n\tint[] ys = [xs[0]];\n\tforeach(i; 1 .. n) ys ~= xs[i] - xs[i - 1];\n\t\n\tA[] as = [new A(0, 0)];\n\tforeach(y; ys){\n\t\tA[] tmpas;\n\t\tforeach(a; as){\n\t\t\ttmpas ~= a.son1(t, y);\n\t\t\ttmpas ~= a.son2(t, y);\n\t\t\t}\n\t\tas = [];\n\t\ttmpas.sort!(\"a.s < b.s\")();\n\t\tulong maxw = 0;\n\t\tforeach(a; tmpas){\n\t\t\tif(a.w >= maxw){\n\t\t\t\tas ~= a;\n\t\t\t\tmaxw = a.w;\n\t\t\t\t}\n\t\t\t}\n\t\tdebug tmpas.writeln;\n\t\tdebug as.writeln;\n\t\t}\n\t\n\t\n\tulong mins = ulong.max;\n\tforeach(a; as) if(a.s < mins) mins = a.s;\n\t\n\tulong ans = mins + (e - xs[$ - 1]);\n\tans.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.typecons;\nimport std.range;\nimport std.random;\nimport std.range;\n\nvoid main() {\n  auto input = readln.split;\n  auto N = input[0].to!int;\n  auto E = input[1].to!long;\n  auto T = input[2].to!long;\n  auto X = readln.split.map!(to!long).array;\n\n  Tuple!(long, int, int)[] hoge;\n  foreach (i; 0..N)\n    foreach (j; i+1..N) {\n      long d = X[j] - X[i];\n      long score = d*2+max(0, T-2*d) - (j-i+1)*T;\n      if (score < 0)\n\thoge ~= tuple(score, i, j);\n    }\n  hoge = hoge.sort;\n\n  Tuple!(long, int, int)[] piyo;\n  foreach (h; hoge) {\n    bool flag = true;\n    foreach (p; piyo) {\n      if ((p[1] <= h[1] && h[1] <= p[2] ||\n\t   p[1] <= h[2] && h[2] <= p[2])) {\n\t    flag = false;\n\t    break;\n      }\n    }\n    if (flag)\n      piyo ~= h;\n  }\n\n  long ans = E+T*N;\n  foreach (p; piyo)\n    ans += p[0];\n  writeln(ans);\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\n// import dcomp.scanner;\n// import dcomp.algorithm;\n// import dcomp.container.simpleSeg;\nimport std.container.util;\n\nint main() {\n    auto sc = new Scanner();\n    int n; long e, T;\n    long[] x;\n    sc.read(n, e, T, x);\n    x ~= e;\n    long[] next = iota(n).map!(i => x[i+1]-x[i]).array;\n    long[] dp = new long[](n+1);\n    auto tr1 = SimpleSeg!(long, min, 10L^^12)(n);\n    auto tr2 = SimpleSeg!(long, min, 10L^^12)(n);\n    dp[n] = 0;\n    foreach_reverse (i; 0..n) {\n        tr1[i] = dp[i+1] + 3*x[i] + next[i];\n        tr2[i] = dp[i+1] + T + x[i] + next[i];\n        int div = binSearch!(j => 2*(x[j]-x[i]) >= T)(i, n);\n        //[div, n-1) tr1\n        //[i, div) tr2\n        long ans = 10L^^12;\n        ans = min(ans, tr1.sum(div, n) - 3*x[i]);\n        ans = min(ans, tr2.sum(i, div) - x[i]);\n        dp[i] = ans;\n    }\n    writeln(dp[0] + x[0]);\n\treturn 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, readln, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeString, isDynamicArray;\n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = readln.split;\n        }\n        return true;\n    }\n    int read(Args...)(auto ref Args args) {\n        foreach (i, ref v; args) {\n            if (!succ()) return i;\n            alias VT = typeof(v);\n            static if (!isSomeString!VT && isDynamicArray!VT) {\n                v = buf.map!(to!(ElementType!VT)).array;\n                buf.length = 0;\n            } else {\n                v = buf.front.to!VT;\n                buf.popFront();\n            }\n        }\n        return args.length;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/container/simpleSeg.d */\n// module dcomp.container.simpleSeg;\n\n// simpleなsegtree\n// a op b op .. op x が求められる、遅延評価なし\n// (T, op)はモノイドの必要がある、eはモノイド\nstruct SimpleSeg(T, alias op, T e) {\n    const size_t n, sz;\n    T[] d;\n    @disable this();\n    this(size_t n) {\n        import std.algorithm : fill;\n        import core.bitop : bsr;\n        int lg = n.bsr;\n        if ((2^^lg) < n) lg++;\n        this.n = n;\n        this.sz = 2^^lg;\n        d = new T[](2*this.sz);\n        d.fill(e);\n    }\n    void opIndexAssign(T v, int idx) {\n        import std.stdio : writeln;\n        idx += sz;\n        d[idx] = v;\n        while (idx/2 >= 1) {\n            idx /= 2;\n            d[idx] = op(d[2*idx], d[2*idx+1]);\n        }\n    }\n    //todo more beautiful?\n    T sum(size_t a, size_t b, size_t l, size_t r, size_t k) {\n        if (b <= l || r <= a) return e;\n        if (a <= l && r <= b) return d[k];\n        size_t md = (l+r)/2;\n        return op(sum(a, b, l, md, 2*k),\n            sum(a, b, md, r, 2*k+1));\n    }\n    //[a, b)\n    T sum(size_t a, size_t b) {\n        return sum(a, b, 0, sz, 1);\n    }\n    //todo formatspec?\n    string toString() {\n        import std.conv : to;\n        return d[sz..sz+n].to!string;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\n// import dcomp.scanner;\n// import dcomp.algorithm;\n\nint n;\nstruct Edge {\n    int to;\n    long dist;\n}\nEdge[][] g;\nlong md;\n\nlong[2][] dfs(int p) {\n    if (g[p].empty) {\n        return [[0L, 0L]];\n    }\n    Edge le = g[p][0], re = g[p][1];\n    auto lt = dfs(le.to);\n    auto rt = dfs(re.to);\n    if (lt.length > rt.length) {\n        swap(le, re);\n        swap(lt, rt);\n    }\n    long ld = le.dist, rd = re.dist;\n    long[2][] ans;\n    foreach (co; lt) {\n        //co[1] + ld + rd + rco[0] <= md\n        int idx = binSearch!((i){return co[1]+ld+rd+rt[i][0] > md;})(-1L, rt.length).to!int-1;\n        if (idx == -1) continue;\n        ans ~= [co[0]+ld, rt[idx][1]+rd];\n        ans ~= [rt[idx][1]+rd, co[0]+ld];\n    }\n    sort(ans);\n    if (ans.empty) return ans;\n    long ma = 10L^^15;\n    int co = 0;\n    foreach (e; ans) {\n        if (ma <= e[1]) continue;\n        ma = min(ma, e[1]);\n        ans[co] = e;\n        co++;\n    }\n    return ans[0..co];\n}\n\n//md以下にできるか？\nbool solve(long _md) {\n    md = _md;\n    return !dfs(0).empty;\n}\n\nint main() {\n    auto sc = new Scanner();\n    int n;\n    sc.read(n);\n    g = new Edge[][](n);\n    foreach (i; 1..n) {\n        int a; long b;\n        sc.read(a, b); a--;\n        g[a] ~= Edge(i, b);\n    }\n\n    writeln(binSearch!solve(-1L, 10L^^12));\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, readln, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeString, isDynamicArray;\n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = readln.split;\n        }\n        return true;\n    }\n    int read(Args...)(auto ref Args args) {\n        foreach (i, ref v; args) {\n            if (!succ()) return i;\n            alias VT = typeof(v);\n            static if (!isSomeString!VT && isDynamicArray!VT) {\n                v = buf.map!(to!(ElementType!VT)).array;\n                buf.length = 0;\n            } else {\n                v = buf.front.to!VT;\n                buf.popFront();\n            }\n        }\n        return args.length;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\n// import dcomp.scanner;\n// import dcomp.algorithm;\n\nstruct Node {\n    alias NP = Node*;\n    long mi;\n    NP l, r;\n    int sz;\n    this(int sz) {\n        this.sz = sz;\n        if (sz == 1) return;\n        l = new Node(sz/2);\n        r = new Node(sz-sz/2);\n    }\n    void set(int k, long x) {\n        if (sz == 1) {\n            mi = x;\n            return;\n        }\n        if (k < sz/2) {\n            l.set(k, x);\n        } else {\n            r.set(k-sz/2, x);\n        }\n        mi = min(l.mi, r.mi);\n    }\n    long get(int a, int b) {\n        if (b <= 0 || sz <= a) return 10L^^12;\n        if (a <= 0 && sz <= b) return mi;\n        return min(l.get(a, b), r.get(a-sz/2, b-sz/2));\n    }\n    string toString() {\n        if (sz == 1) {\n            return mi.to!string ~ \", \";\n        }\n        return l.toString ~ r.toString;\n    }\n}\n\nint main() {\n    import std.conv;\n    auto sc = new Scanner();\n    int n; long e, T;\n    long[] x;\n    sc.read(n, e, T, x);\n    x ~= e;\n    long[] next = iota(n).map!(i => x[i+1]-x[i]).array;\n//    writeln(next);\n    long[] dp = new long[](n+1);\n    Node* tr1 = new Node(n); //dp[i+1] + 3*dist[j] + next[j]\n    Node* tr2 = new Node(n); //dp[i+1] + T + dist[j] + next[j]\n    dp[n] = 0;\n    foreach_reverse (i; 0..n) {\n        tr1.set(i, dp[i+1] + 3*x[i] + next[i]);\n        tr2.set(i, dp[i+1] + T + x[i] + next[i]);\n//        writeln(tr1.toString);\n//        writeln(tr2.toString);\n        int div = binSearch!(j => 2*(x[j]-x[i]) >= T)(i, n);\n        //[div, n-1) tr1\n        //[i, div) tr2\n        long ans = 10L^^12;\n        ans = min(ans, tr1.get(div, n) - 3*x[i]);\n//        writeln(i, \" a \", div, \" \", tr1.get(div, n));\n        ans = min(ans, tr2.get(i, div) - x[i]);\n        dp[i] = ans;\n    }\n//    writeln(dp);\n    writeln(dp[0] + x[0]);\n\treturn 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, readln, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeString, isDynamicArray;\n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = readln.split;\n        }\n        return true;\n    }\n    int read(Args...)(auto ref Args args) {\n        foreach (i, ref v; args) {\n            if (!succ()) return i;\n            alias VT = typeof(v);\n            static if (!isSomeString!VT && isDynamicArray!VT) {\n                v = buf.map!(to!(ElementType!VT)).array;\n                buf.length = 0;\n            } else {\n                v = buf.front.to!VT;\n                buf.popFront();\n            }\n        }\n        return args.length;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\ntemplate binSearch(alias pred) {\n    T binSearch(T)(T l, T r) {\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (!pred(md)) l = md;\n            else r = md;\n        }\n        return r;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.0.2\"\n+/\n\nimport std.algorithm, std.range, std.stdio, std.math, std.conv, core.bitop;\n\n// import dcomp.scanner;\n// import dcomp.algorithm;\n// import dcomp.container.simpleSeg;\n\nint main() {\n    import std.conv;\n    auto sc = new Scanner();\n    int n; long e, T;\n    long[] x;\n    sc.read(n, e, T, x);\n    x ~= e;\n    long[] next = iota(n).map!(i => x[i+1]-x[i]).array;\n    long[] dp = new long[](n+1);\n    auto tr1 = SimpleSeg!(long, min, 10L^^12)(n);\n    auto tr2 = SimpleSeg!(long, min, 10L^^12)(n);\n    dp[n] = 0;\n    foreach_reverse (i; 0..n) {\n        tr1[i] = dp[i+1] + 3*x[i] + next[i];\n        tr2[i] = dp[i+1] + T + x[i] + next[i];\n        int div = binSearch!(j => 2*(x[j]-x[i]) >= T)(i, n);\n        //[div, n-1) tr1\n        //[i, div) tr2\n        long ans = 10L^^12;\n        ans = min(ans, tr1.sum(div, n) - 3*x[i]);\n        ans = min(ans, tr2.sum(i, div) - x[i]);\n        dp[i] = ans;\n    }\n    writeln(dp[0] + x[0]);\n\treturn 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, readln, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeString, isDynamicArray;\n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = readln.split;\n        }\n        return true;\n    }\n    int read(Args...)(auto ref Args args) {\n        foreach (i, ref v; args) {\n            if (!succ()) return i;\n            alias VT = typeof(v);\n            static if (!isSomeString!VT && isDynamicArray!VT) {\n                v = buf.map!(to!(ElementType!VT)).array;\n                buf.length = 0;\n            } else {\n                v = buf.front.to!VT;\n                buf.popFront();\n            }\n        }\n        return args.length;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/container/simpleSeg.d */\n// module dcomp.container.simpleSeg;\n\n// simpleなsegtree\n// a op b op .. op x が求められる、遅延評価なし\n// (T, op)はモノイドの必要がある、eはモノイド\nstruct SimpleSeg(T, alias op, T e) {\n    size_t n;\n    T[] d;\n    this(size_t n) {\n        import std.algorithm : fill;\n        import core.bitop : bsr;\n        int lg = n.bsr;\n        if ((2^^lg) < n) lg++;\n        this.n = 2^^lg;\n        d = new T[](2*this.n);\n        d.fill(e);\n    }\n    void opIndexAssign(T v, int idx) {\n        import std.stdio : writeln;\n        idx += n;\n        d[idx] = v;\n        while (idx/2 >= 1) {\n            idx /= 2;\n            d[idx] = op(d[2*idx], d[2*idx+1]);\n        }\n    }\n    T sum(size_t a, size_t b, size_t l, size_t r, size_t k) {\n        import std.stdio: writefln;\n        if (b <= l || r <= a) return e;\n        if (a <= l && r <= b) return d[k];\n        size_t md = (l+r)/2;\n        return op(sum(a, b, l, md, 2*k),\n            sum(a, b, md, r, 2*k+1));\n    }\n    //[a, b)\n    T sum(size_t a, size_t b) {\n        return sum(a, b, 0, n, 1);\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<stack>\n#include<set>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<bitset>\n#include<functional>\n#include<utility>\n#include<list>\n#include<iomanip>\n#include<ctime>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9+1;\nll n,t,e,st,pos[100005],dist; \nll ans=0;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&pos[i]);\n\tans+=pos[0]+e-pos[n-1];\n\twhile(st<n-1)\n\t{\n\t\t//cout<<\"*************\"<<endl;\n\t\t//cout<<st<<\"*****\";\n\t\tint ed=st;\n\t\tdist=0;\n\t\tfor(int i=st+1;i<n;i++)\n\t\t{\n\t\t\tdist+=pos[i]-pos[i-1];\n\t\t\t//cout<<dist<<\" \";\n\t\t\tif(dist>t)\n\t\t\t{\n\t\t\t\tdist-=pos[i]-pos[i-1];\n\t\t\t\ted=i-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(i==n-1) ed=1;\n\t\t}\n\t\tans+=3*dist;\n\t\tif(2*dist<t) ans+=(ed-st+1)*(t-dist*2);\n\t\tif(ed<n-1) ans+=pos[ed+1]-pos[ed];\n\t\tif(ed==n-2) ans+=t;\n\t\tst=ed+1;\n\t}\n\tif(n==1) ans+=t;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n \nint p[100001],s[100001],l,r;\nlong long f[100001];\nint main(){\n\tint n,e,t;scanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tlong long z=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\ts[++r]=i;\n\t\tfor(;2*(p[i]-p[s[l]])>=t;l++)\n\t\t\tz=min(z,f[s[l]-1]-2*p[s[l]]);\n\t\tf[i]=f[s[l]-1]+t;\n\t\tf[i]=min(f[i],2*p[i]+z);\n\t}\n\tcout<<f[n]+e;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,inf=(1<<30);\nll f[N];int n,e,t,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tmemset(f,63,sizeof(f));f[0]=0;\n\tfor(int i=1,j=0;i<=n;i++) {\n\t\tll mini=inf;\n\t\tfor(;t<=(p[i]-p[j+1])<<1;j++)\n\t\t\tmini=min(mini,ll((p[i]-p[j+1])<<1));\n\t\t\tif(j<i) f[i]=min(f[i],f[j]+t);\n\t\t\tf[i]=min(f[i],f[i]+mini);\n\t}\n\tprintf(\"%lld\\n\",f[n]+e);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=100010;\nint n,t,e,x[nMax];\nlong long time[nMax];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tsort(x+1,x+1+n);\n\tint last=1;\n\tlong long ans=time[1]=x[1];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(ans+2*(x[i+1]-x[i])+x[i]-x[last]<=time[last]+t)\n\t\t\ttime[i+1]=ans=ans+x[i+1]-x[i];\n\t\telse\n\t\t{\n\t\t\tlong long v1=max((time[last]+t)-(ans+x[i]-x[last]),(long long)0);\n\t\t\tv1+=(long long)2*(x[i]-x[last])+x[i+1]-x[i]+t;\n\t\t\tlong long v2=(long long)3*(x[i+1]-x[i])+(long long)2*(x[i]-x[last]);\n\t\t\tif(v1<=v2)\n\t\t\t{\n\t\t\t\ttime[i+1]=ans=ans+v1-t;\n\t\t\t\tlast=i+1;\n\t\t\t} else\n\t\t\t\ttime[i+1]=ans=ans+x[i+1]-x[i];\n\t\t}\n\t}\n\tans+=max((time[last]+t)-(ans+x[n]-x[last]),(long long)0)+(long long)2*(x[n]-x[last])+e-x[n];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define N 100010\ntypedef long long ll;\n\nconst ll INF=1e18;\n\nint n,E,T;\nint dis[N];\nll Dp[N];\n\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nint main()\n{\n    n=read();E=read();T=read();\n    for(int i=1;i<=n;i++)\n        dis[i]=read();\n    Dp[0]=0;\n    int pos=0;\n    for(int i=1;i<=n;i++)\n    {\n        Dp[i]=Dp[i-1]+T;\n        ll Min=INF;\n        while(pos+1<=i&&2*(dis[i]-dis[pos+1])>T)\n        {\n            Min=min(Min,Dp[pos]-2*dis[pos+1]+2*dis[i]);\n            pos++;\n        }\n        Dp[i]=min(min(Dp[i],Dp[pos]+T),Min);\n    }\n    cout<<Dp[n]+E<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<stack>\n#include<set>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<bitset>\n#include<functional>\n#include<utility>\n#include<list>\n#include<iomanip>\n#include<ctime>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9+1;\nll n,t,e,st,pos[100005],dist; \nll ans=0;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&pos[i]);\n\tans+=pos[0]+e-pos[n-1];\n\twhile(st<n-1)\n\t{\n\t\t//cout<<\"*************\"<<endl;\n\t\t//cout<<st<<\"*****\";\n\t\tint ed=st;\n\t\tdist=0;\n\t\tfor(int i=st+1;i<n;i++)\n\t\t{\n\t\t\tdist+=pos[i]-pos[i-1];\n\t\t\t//cout<<dist<<\" \";\n\t\t\tif(dist>t)\n\t\t\t{\n\t\t\t\tdist-=pos[i]-pos[i-1];\n\t\t\t\ted=i-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(i==n-1) ed=1;\n\t\t}\n\t\tans+=3*dist;\n\t\tif(2*dist<t) ans+=(ed-st+1)*(t-dist*2);\n\t\tif(ed<n-1) ans+=pos[ed+1]-pos[ed];\n\t\tif(ed==n-2) ans+=t;\n\t\tst=ed+1;\n\t}\n\tif(n==1) ans+=t;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn =  1e5 + 5;\n\nint n, E, T, pos;\nint a[maxn];\nll f[maxn], mn = 1e18;\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &E, &T);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n    {\n        while(T < 2 * (a[i] - a[pos + 1]))\n        {\n            mn = min(mn, f[pos] - 2 * a[pos + 1]);\n            pos++;\n        }\n        f[i] = min(f[i - 1] + T, mn + 2 * a[i]);\n        if(pos < i - 1)\n            f[i] = min(f[pos + 1] + T, f[i]);\n    }\n    printf(\"%lld\\n\", f[n] + E);\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, a[N];\nll ans, f[N];\n\nll move(int i, int j) {\n\treturn f[j] - a[j] + std::max((a[i] - a[j + 1]) << 1, k);\n}\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint j = std::lower_bound(a, a + i, (a[i] * 2 - k + 1) >> 1) - a - 1;\n\t\t// printf(\"i=%d j=%d\\n\", i, j);\n\t\tfor (int k = 0; k < 5000; k++) if (j - k >= 0) {\n\t\t\tf[i] = std::min(f[i], move(i, j - k));\n\t\t} else break;\n\t\tfor (int k = 0; k < 5000; k++) if (j + k < i) {\n\t\t\tf[i] = std::min(f[i], move(i, j + k));\n\t\t} else break;\n\t\tf[i] += a[i];\n\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "Bash",
    "code": "// =================================\n//   author: memset0\n//   date: 2019.03.20 22:54:35\n//   website: https://memset0.cn/\n// =================================\n#include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate <class T> inline void read(T &x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 1e5 + 10;\nint n, m, k, ans, a[N], f[N];\n\nvoid main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n), read(m), read(k);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\t// printf(\"[%d] -> [%d] : %d %d %d\\n\", j, i, f[j], a[i] - a[j], std::max((a[i] - a[j]) << 1, k));\n\t\t\tf[i] = std::min(f[i], f[j] + a[i] - a[j] + std::max((a[i] - a[j + 1]) << 1, k));\n\t\t}\n\t// for (int i = 1; i <= n; i++) print(f[i], \" \\n\"[i == n]);\n\tans = f[n] + m - a[n];\n\tprint(ans, '\\n');\n}\n\n} signed main() { return ringo::main(), 0; }"
  },
  {
    "language": "Python",
    "code": "N, E, T = map(int, raw_input().split())\nX = map(int, raw_input().split())\nhoge = []\n\nfor i in xrange(N):\n    for j in xrange(i+1, N):\n        d = X[j] - X[i]\n        score = d*2+max(0, T-2*d) - (j-i+1)*T\n        if score < 0:\n            hoge.append((score, i, j))\nhoge.sort()\npiyo = []\nfor h in hoge:\n    for p in piyo:\n        if p[0] <= h[1] <= p[1] or p[0] <= h[2] <= p[1]:\n            break\n    else:\n        piyo.append(h)\n\nprint E+T*N + sum(p[0] for p in piyo)\n"
  },
  {
    "language": "Python",
    "code": "N,E,T=map(int,input().split())\nif N>2000:\n    exit()\nx=list(map(int,input().split()))\nx=[0]+x\n\ndp=[0 for i in range(N+1)]\ndp[N]=abs(E-x[N])\n\nfor i in range(N-1,-1,-1):\n    test1=min(max(T,2*x[j]-2*x[i+1])+dp[j]+x[j] for j in range(i+1,N+1))-x[i]\n    test2=x[N]-x[i]+T+x[N]-x[i+1]+abs(E-x[i+1])\n    dp[i]=min(test1,test2)\n\nprint(dp[0])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nhalf = T//2\nI = [bisect_left(X,x-half) for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = I[n]\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n            t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        else:\n            t1 = min((dp[k]-X[k] for k in range(n)),default=INF)+x+T\n            t2 = INF\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nclass MinSegTree():\n    def __init__(self,N):\n        self.Nelem = N\n        self.size = 1<<(N.bit_length()) # 葉の要素数\n        \n    def build(self,raw_data):\n        # raw_data は 0-indexed\n        INF = 10**18\n        self.data = [INF] * (2*self.size)\n        for i,x in enumerate(raw_data):\n            self.data[self.size+i] = x\n        for i in range(self.size-1,0,-1):\n            x = self.data[i+i]; y = self.data[i+i+1]\n            self.data[i] = x if x<y else y\n    \n    def update(self,i,x):\n        i += self.size\n        self.data[i] = x\n        i >>= 1\n        while i:\n            x = self.data[i+i]; y = self.data[i+i+1]\n            self.data[i] = x if x<y else y\n            i >>= 1\n    \n    def get_value(self,L,R):\n        # [L,R] に対する値を返す\n        L += self.size\n        R += self.size + 1\n        # [L,R) に変更\n        x = 10**18\n        while L < R:\n            if L&1:\n                y = self.data[L]\n                if x > y: x = y\n                L += 1\n                \n            if R&1:\n                R -= 1\n                y = self.data[R]\n                if x > y: x = y\n            L >>= 1; R >>= 1\n        return x\n\ndp1 = MinSegTree(N+1) # dp[k]-X[k] を格納する\ndp2 = MinSegTree(N+1) # dp[k]-X[k]-2X[k+1] を格納する\ndp1.build([0]*(N+1))\ndp2.build([0]*(N+1))\ndp2.update(0,-2*X[1])\nX.append(E)\nfor n in range(1,N+1):\n    x = X[n]; i = I[n]\n    if i >= 1:\n        t1 = dp1.get_value(i-1,n-1)+x+T\n        t2 = dp2.get_value(0,i-2)+3*x\n        t = t1 if t1<t2 else t2\n    else:\n        t = dp1.get_value(0,n-1)+x+T\n    dp1.update(n,t-x)\n    dp2.update(n,t-x-2*X[n+1])\nanswer = t+E-x\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "n,e,t=map(int,raw_input().split())\nx=[0]+map(int,raw_input().split())\ndp1=[0]*(n+1)\ndp1[n]=e-x[n]\ndp2=[0]*(n+1)\ndp2[n]=t+e-x[n]\nfor i in reversed(range(n)):\n    dp1[i]=x[i+1]-x[i]+dp2[i+1]\n    u=[max(t,(x[j]-x[i])*2)+x[j]-x[i]+dp1[j] for j in range(i,n+1)]\n    dp2[i]=min(u)\nprint dp1[0]\n"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, raw_input().split())\nX = map(int, raw_input().split())\n\nif n > 2001:\n    exit(1)\nans = 0\nd = [0]*n\ndef f(j, i):\n    return d[j] + max(2*(X[i] - X[j+1]), t) + X[i] - X[j]\nd[0] = t\nfor i in xrange(1, n):\n    d[i] = max(2*(X[i] - X[0]), t) + X[i] - X[0]\n    le = 0; ri = i\n    while 1:\n        k1 = (le*2 + ri) / 3\n        k2 = (le + ri*2) / 3\n        r1 = f(k1, i)\n        r2 = f(k2, i)\n        if r1 <= r2:\n            if ri == k2:break\n            ri = k2\n        else:\n            if le == k1:break\n            le = k1\n    d[i] = min(d[i], r1, r2)\nprint d[n-1]+ e - X[-1] + X[0]"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, raw_input().split())\nX = map(int, raw_input().split())\n\nif n > 2001:\n    exit(1)\nans = 0\nbef = 0\nbef_i = 0\n\nd = [[0 for i in xrange(n)] for j in xrange(n)]\nfor i in xrange(n):\n    el = d[i]\n    xi = X[i]\n    for j in xrange(i, n):\n        el[j] = max(2*(X[j] - xi), t) + X[j] - xi\nfor i in xrange(n):\n    for j in xrange(i):\n        d[0][i] = min(d[0][j]+d[j+1][i]+(X[j+1]-X[j]), d[0][i])\nprint d[0][n-1]+ e - X[-1] + X[0]"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, e, t = map(int, stdin.readline().split())\n    x = [0] + map(int, stdin.readline().split(), repeat(10, n)) + [e]\n    dp = [0] * (n + 1)\n    f = [0] * (n + 1)\n    f[0] = -x[1] * 2\n    j = 0\n    for i in xrange(1, n + 1):\n        while j < i - 1 and (x[i] - x[j+1]) * 2 > t:\n            j += 1\n        dp[i] = dp[j] + t\n        if j > 0 and dp[i] > f[j-1] + x[i] * 2:\n            dp[i] = f[j-1] + x[i] * 2\n        f[i] = dp[i] - x[i+1] * 2\n        if i and f[i] > f[i-1]:\n            f[i] = f[i-1]\n    print dp[n] + e\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N,E,T=map(int,input().split())\nif N>2000:\n    exit()\nx=list(map(int,input().split()))\nx=[0]+x\n\ndp=[0 for i in range(N+1)]\ndp[N]=abs(E-x[N])\n\nfor i in range(N-1,-1,-1):\n    dp[i]=min(max(T,2*x[j]-2*x[i+1])+dp[j]+x[j] for j in range(i+1,N+1))-x[i]\n\nprint(dp[0])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx - self.N0\n        else:\n            pre = self.data[l+self.N0]\n            for idx in (SL + SR[::-1]):\n                if not check(self.segf(pre, self.data[idx])):\n                    pre = self.segf(pre, self.data[idx])\n                else:\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.segf(pre, self.data[2*idx])):\n                    idx = 2*idx\n                else:\n                    pre = self.segf(pre, self.data[2*idx])\n                    idx = 2*idx + 1\n            return idx - self.N0\n\n\nINF = 10**9 + 7\nN, E, T = map(int, readline().split())\nX = list(map(int, readline().split()))\nX = [0] + [x-X[0]  for x in X] + [INF]\nE -= X[0]\ndp = [0]*(N+2)\ndpl = Segtree([0]*(N+2), INF, initialize = False, segf = min)\ndpr = Segtree([0]*(N+2), INF, initialize = False, segf = min)\ndpl.update(0, 0)\ndpr.update(0, 0)\n\nfor i in range(1, N+1):\n    di = X[i]\n    dn = X[i+1]\n    ok = i\n    ng = -1\n    while abs(ok-ng) > 1:\n        med = (ok+ng)//2\n        if (X[i] - X[med])*2 <= T:\n            ok = med\n        else:\n            ng = med\n    left = ok-1\n    resr = dpr.query(left, i) + T + di\n    resl = dpl.query(0, left) + 3*di\n    dp[i] = min(resl, resr)\n    dpl.update(i, dp[i] - di - 2*dn)\n    dpr.update(i, dp[i] - di)\n\nprint(dp[N] + E - X[N])"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, e, t = map(int, stdin.readline().split())\n    x = map(int, stdin.readline().split(), repeat(10, n))\n    i = 1\n    j = 0\n    dp = [0] * n\n    f = [0] * n\n    dp[0] = t\n    f[0] = -x[0] * 2\n    for i in xrange(1, n):\n        dp[i] = dp[i-1] + t\n        while j < i and (x[i] - x[j]) * 2 > t:\n            j += 1\n        if j > 0 and dp[i] > f[j-1] + x[i] * 2:\n            dp[i] = f[j-1] + x[i] * 2\n        f[i] = dp[i] - x[i] * 2\n        if f[i] > f[i-1]:\n            f[i] = f[i-1]\n    print dp[-1] + e\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k,e;\nint main()\n{\n\tcin>>n>>k>>e;\n\tcout<<k+n*e<<endl;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nX2 = [2*x for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = bisect_left(X2,2*x-T)\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n            t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        else:\n            t1 = min((dp[k]-X[k] for k in range(n)),default=INF)+x+T\n            t2 = INF\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nif N >= 10**4:\n    raise Exception\nbase_solution()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "n,e,t=map(int,raw_input().split())\nx=[0]+map(int,raw_input().split())\ndp1=[0]*(n+1)\ndp1[n]=e-x[n]\ndp2=[0]*(n+1)\ndp2[n]=t+e-x[n]\nfor i in reversed(range(n)):\n    dp1[i]=x[i+1]-x[i]+dp2[i+1]\n    dp2[i]=min((x[i+1]-x[i])*3+dp1[i+1],t+x[i+1]-x[i]+dp2[i+1])\nprint dp1[0]\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx - self.N0\n        else:\n            pre = self.data[l+self.N0]\n            for idx in (SL + SR[::-1]):\n                if not check(self.segf(pre, self.data[idx])):\n                    pre = self.segf(pre, self.data[idx])\n                else:\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.segf(pre, self.data[2*idx])):\n                    idx = 2*idx\n                else:\n                    pre = self.segf(pre, self.data[2*idx])\n                    idx = 2*idx + 1\n            return idx - self.N0\n\n\nINF = 10**18 + 3\nN, E, T = map(int, readline().split())\nX = list(map(int, readline().split()))\nX = [0] + [x-X[0]  for x in X] + [INF]\nE -= X[0]\ndp = [0]*(N+2)\ndpl = Segtree([0]*(N+2), INF, initialize = False, segf = min)\ndpr = Segtree([0]*(N+2), INF, initialize = False, segf = min)\ndpl.update(0, 0)\ndpr.update(0, 0)\n\nfor i in range(1, N+1):\n    di = X[i]\n    dn = X[i+1]\n    ok = i\n    ng = -1\n    while abs(ok-ng) > 1:\n        med = (ok+ng)//2\n        if (X[i] - X[med])*2 <= T:\n            ok = med\n        else:\n            ng = med\n    left = ok-1\n    resr = dpr.query(left, i) + T + di\n    resl = dpl.query(0, left) + 3*di\n    dp[i] = min(resl, resr)\n    dpl.update(i, dp[i] - di - 2*dn)\n    dpr.update(i, dp[i] - di)\n\nprint(dp[N] + E - X[N])"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, e, t = map(int, stdin.readline().split())\n    x = map(int, stdin.readline().split(), repeat(10, n))\n    x.append(e)\n    i = 0\n    ans = x[0]\n    while i < n:\n        j = i + 1\n        while j < n and x[j] - x[i] <= t:\n            j += 1\n        ans += x[j] - x[i] + max(t, (x[j-1] - x[i]) * 2)\n        i = j\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nhalf = T//2\nI = [bisect_left(X,x-half) for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = I[n]\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n            t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        else:\n            t1 = min((dp[k]-X[k] for k in range(n)),default=INF)+x+T\n            t2 = INF\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nif N >= 10**4:\n    print(-1)\n    exit()\nbase_solution()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, e, t = map(int, stdin.readline().split())\n    x = map(int, stdin.readline().split(), repeat(10, n))\n    i = 1\n    j = 0\n    dp = [0] * n\n    f = [0] * n\n    dp[0] = t\n    f[0] = -x[0] * 2\n    for i in xrange(1, n):\n        dp[i] = dp[i-1]\n        while j < i and (x[i] - x[j]) * 2 > t:\n            j += 1\n        dp[i] = dp[j] + t\n        if j > 0 and dp[i] > f[j-1] + x[i] * 2:\n            dp[i] = f[j-1] + x[i] * 2\n        f[i] = dp[i-1] - x[i] * 2\n        if f[i] > f[i-1]:\n            f[i] = f[i-1]\n    print dp[-1] + e\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N,E,T=map(int,input().split())\nx=list(map(int,input().split()))\nx=[0]+x\n\ndp=[0 for i in range(N+1)]\ndp[N]=abs(E-x[N])\n\nfor i in range(N-1,-1,-1):\n    test1=min(max(T,2*x[j]-2*x[i+1])+dp[j]+x[j] for j in range(i+1,N+1))-x[i]\n    test2=x[N]-x[i]+T+x[N]-x[i+1]+abs(E-x[N])\n    dp[i]=min(test1,test2)\n\nprint(dp[0])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nhalf = T//2\nI = [bisect_left(X,x-half) for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = I[n]\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n            t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        else:\n            t1 = min((dp[k]-X[k] for k in range(n)),default=INF)+x+T\n            t2 = INF\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nclass MinSegTree():\n    def __init__(self,N):\n        self.Nelem = N\n        self.size = 1<<(N.bit_length()) # 葉の要素数\n        \n    def build(self,raw_data):\n        # raw_data は 0-indexed\n        INF = 10**18\n        self.data = [INF] * (2*self.size)\n        for i,x in enumerate(raw_data):\n            self.data[self.size+i] = x\n        for i in range(self.size-1,0,-1):\n            x = self.data[i+i]; y = self.data[i+i+1]\n            self.data[i] = x if x<y else y\n    \n    def update(self,i,x):\n        i += self.size\n        self.data[i] = x\n        i >>= 1\n        while i:\n            x = self.data[i+i]; y = self.data[i+i+1]\n            self.data[i] = x if x<y else y\n            i >>= 1\n    \n    def get_value(self,L,R):\n        # [L,R] に対する値を返す\n        L += self.size\n        R += self.size + 1\n        # [L,R) に変更\n        x = 10**18\n        while L < R:\n            if L&1:\n                y = self.data[L]\n                if x > y: x = y\n                L += 1\n                \n            if R&1:\n                R -= 1\n                y = self.data[R]\n                if x > y: x = y\n            L >>= 1; R >>= 1\n        return x\n\ndp1 = MinSegTree(N+1) # dp[k]-X[k] を格納する\ndp2 = MinSegTree(N+1) # dp[k]-X[k]-2X[k+1] を格納する\ndp1.build([0]*(N+1))\ndp2.build([0]*(N+1))\ndp2.update(0,-2*X[1])\nX.append(E)\nfor n in range(1,N+1):\n    x = X[n]; i = I[n]\n    if i >= 1:\n        t1 = dp1.get_value(i-1,n-1)+x+T\n        t2 = dp2.get_value(0,i-2)+3*x\n        t = t1 if t1<t2 else t2\n    else:\n        t = dp1.get_value(0,n-1)+x+T\n    dp1.update(n,t-x)\n    dp2.update(n,t-x-2*X[n+1])\nanswer = t+E-x\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "N,E,T=map(int,input().split())\nif N>2000:\n    exit()\nx=list(map(int,input().split()))\nx=[0]+x\n\ndp=[0 for i in range(N+1)]\ndp[N]=abs(E-x[N])\n\nfor i in range(N-1,-1,-1):\n    test1=min(max(T,2*x[j]-2*x[i+1])+dp[j]+x[j] for j in range(i+1,N+1))-x[i]\n    test2=x[N]-x[i]+T+x[N]-x[i+1]+abs(E-x[N])\n    dp[i]=min(test1,test2)\n\nprint(dp[0])\n"
  },
  {
    "language": "Python",
    "code": "n,e,t=map(int,input().split())\na,f,l,c=[0]+list(map(int,input().split())),[0]*(n+1),1,int(1e18)\nfor i in range(1,n+1):\n\twhile 2*(a[i]-a[l])>=t:\n\t\tc=min(c,f[l-1]-2*a[l])\n\t\tl+=1\n\tf[i]=min(f[l-1]+t,c+2*a[i])\nprint(f[n]+e)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, E, T = map(int, raw_input().split())\nx = np.array(map(int, raw_input().split()))\n\ndp = np.zeros(N, dtype='int')\nfor i in range(N):\n    if i == 0:\n        dp[i] = T\n    else:\n        dp[i] = (dp[0:i] + np.maximum(T, 2*(x[i] - x[1:(i+1)]))).min()\n\nprint dp[N-1] + E"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, raw_input().split())\nX = map(int, raw_input().split())\n\nif n > 2001:\n    exit(1)\nans = 0\nbef = 0\nbef_i = 0\n\nd = [[0 for i in xrange(n)] for j in xrange(n)]\nfor i in xrange(n):\n    el = d[i]\n    xi = X[i]\n    for j in xrange(i, n):\n        el[j] = max(2*(X[j] - xi), t) + X[j] - xi\nfor i in xrange(n):\n    for j in xrange(i):\n        d[0][i] = min(d[0][j]+d[j+1][i]+(X[j+1]-X[j]), d[0][i])\nprint d[0][n-1]+ e - X[-1] + X[0]"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(n, e, t, xxx):\n    if n == 1:\n        return e + t\n\n    ans = xxx[0] + (e - xxx[-1])\n\n    i = 0\n    while i < n:\n        for j in range(i, n - 1):\n            dx0 = xxx[j] - xxx[i]\n            dx1 = xxx[j + 1] - xxx[i]\n            stop = max(2 * dx0, t) + dx0 + xxx[j + 1] - xxx[j] + t\n            through = max(2 * dx1, t) + dx1\n            if stop < through:\n                ans += stop - t\n                i = j + 1\n                break\n        else:\n            dx1 = xxx[n - 1] - xxx[i]\n            ans += max(2 * dx1, t) + dx1\n            i = n\n\n    return ans\n\n\nn, e, t, *xxx = map(int, sys.stdin.buffer.read().split())\nprint(solve(n, e, t, xxx))\n"
  },
  {
    "language": "Python",
    "code": "#####segfunc#####\ndef segfunc(x, y):\n    return min(x,y)\n#################\n\n#####ide_ele#####\nide_ele = float(\"inf\")\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): 配列init_valで初期化 O(N)\n    update(k, x): k番目の値をxに更新 O(logN)\n    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)\n    \"\"\"\n    def __init__(self, n, segfunc, ide_ele):\n        \"\"\"\n        init_val: 配列の初期値\n        segfunc: 区間にしたい操作\n        ide_ele: 単位元\n        n: 要素数\n        num: n以上の最小の2のべき乗\n        tree: セグメント木(1-index)\n        \"\"\"\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # 配列の値を葉にセット\n        # 構築していく\n\n    def update(self, k, x):\n        \"\"\"\n        k番目の値をxに更新\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)のsegfuncしたものを得る\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nimport bisect,random\n\nN,E,T=map(int,input().split())\nx=list(map(int,input().split()))\nx=[0]+x\nX=[2*x[i] for i in range(N+1)]\n\n\n\ndp=[0 for i in range(N+1)]\ndp[N]=abs(E-x[N])\n\nseg1=SegTree(N+1,segfunc,ide_ele)\nseg3=SegTree(N+1,segfunc,ide_ele)\nseg1.update(N,E-x[N]+x[N])\nseg3.update(N,E-x[N]+3*x[N])\n\nfor i in range(N-1,-1,-1):\n    id=bisect.bisect_right(X,T+2*x[i+1])\n    test,test2=10**20,10**20\n    if id>i+1:\n        #test1=min(dp[j]+x[j] for j in range(i+1,id))+T\n        test1=seg1.query(i+1,id)+T\n    if N+1>id:\n        #test2=min(3*x[j]+dp[j] for j in range(id,N+1))-2*x[i+1]\n        test2=seg3.query(id,N+1)-2*x[i+1]\n    dp[i]=min(test1,test2)-x[i]\n    seg1.update(i,dp[i]+x[i])\n    seg3.update(i,dp[i]+3*x[i])\n    #dp[i]=min(max(T,2*x[j]-2*x[i+1])+dp[j]+x[j] for j in range(i+1,N+1))-x[i]\n\nprint(dp[0])\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc007/tasks/agc007_d\n\nまぁdpだよね\n選択は\n1.前の奴から引き継ぐ\n2.新たに始める\nの2択か？\n\nABCDの4つを同時に回収するとき\nAアメ→Dコインまでの時間は\nmax(3*(D-A),T+D-A)\n\n待ち時間がちょうどないくらいが望ましいはず\nすなわち、2*(D-A)と Tの差が小さくなるように選ぶべき？\n\n左から歩いて行き、毎回止まって待つ場合\n時間はE+NTである\nここからどれだけ減らせるかを基準に考えてみよう\n\nT以内にx個追加で回ってこれた場合、減少するのはxT\nx個回ってきたが、aだけ時間制限を超えた場合、減少はxT-a\n少なくとも回れるならばすべて回ったほうが良い→右方向T/2以下にあるやつは確定で同時に取る\nそうでない場合、新たに始める or x-増加分　のコストを払うを選択できる\n\nこれをうまくdpに落とし込めないか？？\n\ndp[ai][連続/始点] = その頂点が始点 or 連続点の場合の減少量の最大値\n始点は,T/2より1つだけ右にある要素にあげるdpをする(二分探索で位置を求める)\n連続の場合、+1のところの連続or始点にあげるdpをする\n\nあげるものは、E+NTからの減少量。よって最大値を求める\n\n始点から上げる場合\niからT/2より+1右にある要素jの始点にあげる場合、(j-i-1)*T 可算\n連続にあげる場合は、あまり分を考慮\n(j-i)*T - 2*(A[j]-A[i])-T\n\n連続から始点にあげる場合、+-0であげちゃう\n連続から連続にあげる場合、T-(A[i+1]-A[i])*2 可算\n\n大体おｋだと思うけど　始点と終点の処理は？\n始点は考慮する必要無し\n終点は…ちょっと面倒くさい　座標infをおいておけばいいかな\n座標infの始点が答えになりそう\n\"\"\"\nimport bisect\nN,E,T = map(int,input().split())\n\nA = list(map(int,input().split()))\nA.append(float(\"inf\"))\n\ndp = [[float(\"-inf\")] * 2 for i in range(N+1)]\ndp[0][0] = 0\n\nfor i in range(N):\n\n    j = bisect.bisect_right(A,A[i] + T//2)\n    dp[j][0] = max(dp[j][0] , dp[i][0] + (j-i-1)*T )\n    dp[j][1] = max(dp[j][1] , dp[i][0] + (j-i)*T - (2*(A[j]-A[i]) - T) )\n\n    dp[i+1][0] = max(dp[i+1][0] , dp[i][1])\n    dp[i+1][1] = max(dp[i+1][1] , dp[i][1] + T - (A[i+1]-A[i])*2 )\n\n#print (dp)\nprint (E+N*T - dp[-1][0])\n"
  },
  {
    "language": "Python",
    "code": "\nN, E, T = map(int, raw_input().split())\nX = map(int, raw_input().split())\nhoge = []\n \nfor i in xrange(N):\n    for j in xrange(i+1, N):\n        d = X[j] - X[i]\n        score = d*2+max(0, T-2*d) - (j-i+1)*T\n        if score < 0:\n            hoge.append((score, i, j))\nhoge.sort()\npiyo = []\nfor h in hoge:\n    for p in piyo:\n        if p[1] <= h[1] <= p[2] or p[1] <= h[2] <= p[2]:\n            break\n    else:\n        piyo.append(h)\n \nprint E+T*N + sum(p[0] for p in piyo)"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, raw_input().split())\nX = map(int, raw_input().split())\n\nif n > 2001:\n    exit(1)\nans = 0\nbef = 0\nbef_i = 0\n\nd = [[0 for i in xrange(n)] for j in xrange(n)]\nfor i in xrange(n):\n    for j in xrange(n):\n        d[i][j] = (j-i+1)*t + X[j] - X[i]\nfor i in xrange(n):\n    for j in xrange(i):\n        d[0][i] = min(d[0][j]+d[j+1][i]+(X[j+1]-X[j]), d[0][i])\nprint d[0][n-1]+e - X[-1] + X[0]\n"
  },
  {
    "language": "Python",
    "code": "s=input().split();n,e,t=int(s[0]),int(s[1]),int(s[2])\ns=input().split()\nif (int(s[n-1])-int(s[0]))+t>t*n:\n    print(e+t*n)\nelif t>int(s[n-1])*2:\n    print(int(s[0])+(int(s[n-1])-int(s[0]))+t+(e-int(s[0])))\nelse:\n    print(int(s[0])+(int(s[n-1])-int(s[0]))*2+(e-int(s[0])))\n"
  },
  {
    "language": "Python",
    "code": "N, E, T = map(int, raw_input().split())\nX = map(int, raw_input().split())\nhoge = []\n\nfor i in xrange(N):\n    for j in xrange(i+1, N):\n        d = X[j] - X[i]\n        score = d*2+max(0, T-2*d) - (j-i+1)*T\n        if score < 0:\n            hoge.append((score, i, j))\nhoge.sort()\npiyo = []\nfor h in hoge:\n    for p in piyo:\n        if p[0] <= h[1] <= p[1] or p[0] <= h[2] <= p[1]:\n            break\n    else:\n        piyo.append(h[0])\n\nprint E+T*N + sum(piyo)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = bisect_left(X,x-T/2)\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n        else:\n            t1 = INF\n        t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nbase_solution()"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nX2 = [2*x for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = bisect_left(X2,2*x-T)\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n        else:\n            t1 = INF\n        t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nif N >= 10**4:\n    raise Exception\nbase_solution()"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, raw_input().split())\nX = map(int, raw_input().split())\n\nans = 0\nd = [0]*n\ndef f(j, i):\n    return d[j] + max(2*(X[i] - X[j+1]), t) + X[i] - X[j]\nd[0] = t\nfor i in xrange(1, n):\n    d[i] = max(2*(X[i] - X[0]), t) + X[i] - X[0]\n    le = 0; ri = i\n    while 1:\n        k1 = (le*2 + ri) / 3.\n        k2 = (le + ri*2) / 3.\n        r1 = f(int(k1), i)\n        r2 = f(int(k2), i)\n        if r1 <= r2:\n            if ri == k2:break\n            ri = k2\n        else:\n            if le == k1:break\n            le = k1\n    d[i] = min(d[i], r1, r2)\nprint d[n-1]+ e - X[-1] + X[0]"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left\n\nN,E,T = map(int,readline().split())\nX = [0] + list(map(int,read().split()))\n\nX2 = [2*x for x in X]\nI = [bisect_left(X2,2*x-T) for x in X]\n\nINF = 10**18\n\ndef base_solution():\n    # これをseg木に乗せまーす\n    dp = [0] * (N+1)\n    for n in range(1,N+1):\n        x = X[n]\n        i = I[n]\n        # i-1番目まで戻る → 待ち時間なし\n        # i番目まで戻る → 待ち時間発生\n        if i >= 1:\n            t1 = min((dp[k]-X[k] for k in range(i-1,n)),default=INF)+x+T\n            t2 = min((dp[k]-X[k]-2*X[k+1] for k in range(i-1)),default=INF)+3*x\n        else:\n            t1 = min((dp[k]-X[k] for k in range(n)),default=INF)+x+T\n            t2 = INF\n        dp[n] = min(t1,t2)\n    answer = dp[N] + (E-X[-1])\n    print(answer)\n\nif N >= 10**4:\n    print(-1)\n    exit()\nbase_solution()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect, bisect_left\n\n\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.size = n\n        self.INF = 10 ** 18\n        self.tree = [self.INF] * (n + 1)\n\n    def get_min(self, i):\n        s = self.INF\n        while i > 0:\n            s = min(s, self.tree[i])\n            i -= i & -i\n        return s\n\n    def update(self, i, x):\n        while i <= self.size:\n            if self.tree[i] <= x:\n                break\n            self.tree[i] = x\n            i += i & -i\n\n\ndef solve(n, e, t, xxx):\n    if n == 1:\n        return e + t\n\n    dp1 = [0] * (n + 1)\n    dp2 = BinaryIndexedTree(n + 1)\n    dp2.update(1, -xxx[0] * 2)\n\n    for i in range(n):\n        x = xxx[i]\n        j = bisect_left(xxx, x - t // 2, hi=i)\n        ex_time = dp1[j] + t\n        if j > 0:\n            ex_time = min(ex_time, x * 2 + dp2.get_min(j))\n        dp1[i + 1] = ex_time\n        if i < n - 1:\n            dp2.update(i + 2, ex_time - xxx[i + 1] * 2)\n\n    return e + dp1[-1]\n\n\nn, e, t, *xxx = map(int, sys.stdin.buffer.read().split())\nprint(solve(n, e, t, xxx))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, E, T = map(int, raw_input().split())\nx = np.array(map(int, raw_input().split()))\n\ndp = np.zeros(N+1, dtype='int')\nfor i in range(N+1):\n    if i == 0:\n        dp[i] = 0\n    else:\n        dp[i] = (dp[0:i] + np.maximum(T, 2*(x[i-1] - x[0:i]))).min()\n\nprint dp[N] + E"
  },
  {
    "language": "Python",
    "code": "n, e, t = map(int, input().split())\nx = list(map(int, input().split()))\ndp = [0] + [float('inf')] * n\nfor i in range(n):\n    ndp = dp.copy()\n    for j in range(i, n):\n        ndp[j + 1] = min(dp[j + 1], dp[i] + max(t, 2 * (x[j] - x[i])))\n    dp = ndp\nprint(e + dp[-1])\n"
  },
  {
    "language": "Python",
    "code": "N, E, T= map(int, raw_input().split())\nnums = [int(t) for t in raw_input().split()]\n\ntime = nums[0]\ni = 0\n\nwhile i < len(nums):\n    j = i\n    while j < len(nums):\n        if nums[j] - nums[i] < T:\n            j += 1\n        else:\n            break\n    length = nums[j-1] - nums[i]\n    time += max(2 * length, T)\n    if j < len(nums):\n        time += nums[j] - nums[i]\n        i = j\n    else:\n        time += E - nums[i] \n        i = j\n        \nprint time\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, e, t = map(int, stdin.readline().split())\n    x = map(int, stdin.readline().split(), repeat(10, n))\n    i = 1\n    j = 0\n    dp = [0] * n\n    f = [0] * n\n    dp[0] = t\n    f[0] = -x[0] * 2\n    for i in xrange(1, n):\n        dp[i] = dp[i-1]\n        while j < i and (x[i] - x[j]) * 2 > t:\n            j += 1\n        dp[i] = dp[j] + t\n        if j > 0 and dp[i] > f[j-1] + x[i] * 2:\n            dp[i] = f[j-1] + x[i] * 2\n        f[i] = dp[i] - x[i] * 2\n        if f[i] > f[i-1]:\n            f[i] = f[i-1]\n    print dp[-1] + e\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        e: usize,\n        t: usize,\n        v: [usize; n]\n    }\n    let mut ps = vec![0; n];\n    let mut p = 0;\n    for i in 0..n {\n        while 2 * v[i] > t + 2 * v[p] {\n            p += 1;\n        }\n        ps[i] = p;\n    }\n    let mut dp = vec![usize::max_value(); n + 1];\n    dp[0] = 0;\n    dp[1] = t;\n    let mut m = i64::max_value() >> 2;\n    for i in 1..n {\n        for j in ps[i - 1]..ps[i] {\n            m = min(m, dp[j] as i64 - 2 * v[j] as i64);\n        }\n        dp[i + 1] = min(dp[ps[i]] + t, (m + 2 * v[i] as i64) as usize);\n    }\n    println!(\"{}\", dp[n] + e);\n}\n"
  }
]