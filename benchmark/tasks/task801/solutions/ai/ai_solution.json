[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nchar grid[MAX_H][MAX_W + 1];\nbool visited[MAX_H][MAX_W];\nint H, W;\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool dfs(int x1, int y1, int x2, int y2, bool is_black, int steps) {\n    if (x1 == x2 && y1 == y2) return true;\n    \n    visited[x1][y1] = true;\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    for (int k = 0; k < 4; k++) {\n        int nx = x1 + dx[k];\n        int ny = y1 + dy[k];\n        \n        if (is_valid(nx, ny) && !visited[nx][ny]) {\n            bool next_is_black = grid[nx][ny] == '#';\n            \n            if (steps == 0 && is_black != next_is_black) {\n                if (dfs(nx, ny, x2, y2, next_is_black, steps + 1)) \n                    return true;\n            }\n            else if (steps > 0 && is_black != next_is_black) {\n                if (dfs(nx, ny, x2, y2, next_is_black, steps + 1)) \n                    return true;\n            }\n        }\n    }\n    \n    visited[x1][y1] = false;\n    return false;\n}\n\nint count_path_pairs() {\n    int count = 0;\n    \n    for (int x1 = 0; x1 < H; x1++) {\n        for (int y1 = 0; y1 < W; y1++) {\n            if (grid[x1][y1] == '#') {\n                for (int x2 = 0; x2 < H; x2++) {\n                    for (int y2 = 0; y2 < W; y2++) {\n                        if (grid[x2][y2] == '.') {\n                            memset(visited, 0, sizeof(visited));\n                            if (dfs(x1, y1, x2, y2, true, 0)) {\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    printf(\"%d\\n\", count_path_pairs());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_H 400\n#define MAX_W 400\n\ntypedef struct {\n    int r, c;\n} Position;\n\nchar grid[MAX_H][MAX_W + 1];\nint visited[MAX_H][MAX_W];\nint H, W;\nlong long count = 0;\n\nint dr[] = {-1, 1, 0, 0};\nint dc[] = {0, 0, -1, 1};\n\nvoid bfs(int r, int c) {\n    Position queue[MAX_H * MAX_W];\n    int front = 0, rear = 0;\n    queue[rear++] = (Position){r, c};\n    visited[r][c] = 1;\n    long long black = 0, white = 0;\n\n    while (front < rear) {\n        Position current = queue[front++];\n        if (grid[current.r][current.c] == '#') {\n            black++;\n        } else {\n            white++;\n        }\n        for (int i = 0; i < 4; i++) {\n            int nr = current.r + dr[i];\n            int nc = current.c + dc[i];\n            if (nr >= 0 && nr < H && nc >= 0 && nc < W && !visited[nr][nc]) {\n                if (grid[current.r][current.c] == '#' && grid[nr][nc] == '.') {\n                    visited[nr][nc] = 1;\n                    queue[rear++] = (Position){nr, nc};\n                } else if (grid[current.r][current.c] == '.' && grid[nr][nc] == '#') {\n                    visited[nr][nc] = 1;\n                    queue[rear++] = (Position){nr, nc};\n                }\n            }\n        }\n    }\n    count += black * white;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!visited[i][j]) {\n                bfs(i, j);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<vector<int>> color(H, vector<int>(W, -1));\n    long long black = 0, white = 0;\n    queue<pair<int, int>> q;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (color[i][j] == -1) {\n                q.push({i, j});\n                color[i][j] = 0;\n                long long cnt[2] = {0, 0};\n                cnt[color[i][j]]++;\n\n                while (!q.empty()) {\n                    auto p = q.front();\n                    q.pop();\n                    int x = p.first, y = p.second;\n                    for (int d = 0; d < 4; ++d) {\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                            if (grid[x][y] != grid[nx][ny] && color[nx][ny] == -1) {\n                                color[nx][ny] = color[x][y] ^ 1;\n                                cnt[color[nx][ny]]++;\n                                q.push({nx, ny});\n                            }\n                        }\n                    }\n                }\n                black += cnt[0];\n                white += cnt[1];\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (color[i][j] == 0 && grid[i][j] == '#') {\n                ans += white;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static int[][] color; // 0: unvisited, 1: black start, 2: white start\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n        }\n        color = new int[H][W];\n        long blackCount = 0, whiteCount = 0;\n        long result = 0;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (color[i][j] == 0) {\n                    blackCount = 0;\n                    whiteCount = 0;\n                    Deque<int[]> queue = new ArrayDeque<>();\n                    queue.add(new int[]{i, j});\n                    color[i][j] = (grid[i][j] == '#') ? 1 : 2;\n                    if (grid[i][j] == '#') blackCount++;\n                    else whiteCount++;\n\n                    while (!queue.isEmpty()) {\n                        int[] current = queue.poll();\n                        int x = current[0];\n                        int y = current[1];\n                        for (int k = 0; k < 4; k++) {\n                            int nx = x + dx[k];\n                            int ny = y + dy[k];\n                            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                                if (color[nx][ny] == 0) {\n                                    if (grid[x][y] == '#' && grid[nx][ny] == '.') {\n                                        color[nx][ny] = 2;\n                                        whiteCount++;\n                                        queue.add(new int[]{nx, ny});\n                                    } else if (grid[x][y] == '.' && grid[nx][ny] == '#') {\n                                        color[nx][ny] = 1;\n                                        blackCount++;\n                                        queue.add(new int[]{nx, ny});\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    result += blackCount * whiteCount;\n                }\n            }\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:59:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        visited = new boolean[H][W];\n\n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n        }\n\n        int result = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '#') {\n                    result += bfs(i, j);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    static int bfs(int startX, int startY) {\n        Queue<int[]> queue = new LinkedList<>();\n        visited = new boolean[H][W];\n        queue.offer(new int[]{startX, startY, 1});\n        visited[startX][startY] = true;\n        int whiteCount = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], color = current[2];\n\n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                    if (color == 1 && grid[nx][ny] == '.') {\n                        queue.offer(new int[]{nx, ny, 2});\n                        visited[nx][ny] = true;\n                    } else if (color == 2 && grid[nx][ny] == '#') {\n                        queue.offer(new int[]{nx, ny, 1});\n                        visited[nx][ny] = true;\n                        whiteCount++;\n                    }\n                }\n            }\n        }\n\n        return whiteCount;\n    }\n}",
    "timestamp": "2025-08-05 22:59:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<string> grid(H);\n    for (int i = 0; i < H; i++) {\n        cin >> grid[i];\n    }\n    \n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    long long result = 0;\n    \n    for (int sx = 0; sx < H; sx++) {\n        for (int sy = 0; sy < W; sy++) {\n            if (grid[sx][sy] != '#') continue;\n            \n            for (int ex = 0; ex < H; ex++) {\n                for (int ey = 0; ey < W; ey++) {\n                    if (grid[ex][ey] != '.') continue;\n                    \n                    queue<tuple<int, int, int, bool>> q;\n                    vector<vector<vector<bool>>> vis(H, vector<vector<bool>>(W, vector<bool>(2, false)));\n                    \n                    q.push({sx, sy, 0, true});\n                    vis[sx][sy][1] = true;\n                    \n                    while (!q.empty()) {\n                        auto [x, y, dist, is_black] = q.front();\n                        q.pop();\n                        \n                        if (x == ex && y == ey) {\n                            result++;\n                            break;\n                        }\n                        \n                        for (int k = 0; k < 4; k++) {\n                            int nx = x + dx[k];\n                            int ny = y + dy[k];\n                            \n                            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                            \n                            bool next_is_black = (grid[nx][ny] == '#');\n                            \n                            if (is_black && !next_is_black && !vis[nx][ny][0]) {\n                                q.push({nx, ny, dist + 1, false});\n                                vis[nx][ny][0] = true;\n                            }\n                            else if (!is_black && next_is_black && !vis[nx][ny][1]) {\n                                q.push({nx, ny, dist + 1, true});\n                                vis[nx][ny][1] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef count_black_white_pairs(H, W, grid):\n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        black_count, white_count = 0, 0\n\n        while queue:\n            x, y, color = queue.popleft()\n            if color == '#':\n                black_count += 1\n            else:\n                white_count += 1\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != color and (nx, ny, grid[nx][ny]) not in visited:\n                    visited.add((nx, ny, grid[nx][ny]))\n                    queue.append((nx, ny, grid[nx][ny]))\n\n        return black_count, white_count\n\n    total_pairs = 0\n    visited = set()\n\n    for i in range(H):\n        for j in range(W):\n            if (i, j, grid[i][j]) not in visited:\n                visited.add((i, j, grid[i][j]))\n                black_count, white_count = bfs((i, j, grid[i][j]))\n                total_pairs += black_count * white_count\n\n    return total_pairs\n\n# Example of usage:\nH = 3\nW = 3\ngrid = [\n    \"##.\",\n    \"#..\",\n    \".##\"\n]\n\nprint(count_black_white_pairs(H, W, grid))",
    "timestamp": "2025-08-13 13:08:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridPathFinder {\n\n    private static final char BLACK = '#';\n    private static final char WHITE = '.';\n\n    public static int countAlternatingPaths(String[] grid) {\n        int H = grid.length;\n        int W = grid[0].length();\n        \n        int count = 0;\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char current = grid[i].charAt(j);\n                if (current == BLACK) {\n                    count += countAdjacentAlternating(grid, i, j, WHITE);\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    private static int countAdjacentAlternating(String[] grid, int x, int y, char target) {\n        int H = grid.length;\n        int W = grid[0].length();\n        int count = 0;\n        \n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        for (int[] dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            \n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx].charAt(ny) == target) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        String[] grid = {\n            \"#.#\",\n            \".##\",\n            \"#.#\"\n        };\n        \n        System.out.println(countAlternatingPaths(grid)); // Output: 8\n    }\n}",
    "timestamp": "2025-08-13 13:08:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 100\n\nint H, W;\nchar grid[MAX][MAX];\nbool visited[MAX][MAX];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint dfs(int x, int y, char currentColor) {\n    visited[x][y] = true;\n    int count = (currentColor == '#') ? -1 : 1;\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isValid(nx, ny) && !visited[nx][ny] && grid[nx][ny] != currentColor) {\n            count += dfs(nx, ny, grid[nx][ny]);\n        }\n    }\n    return count;\n}\n\nint main() {\n    scanf(\"%d%d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!visited[i][j] && grid[i][j] == '#') {\n                int whiteSquares = dfs(i, j, grid[i][j]);\n                if (whiteSquares > 0) {\n                    result += whiteSquares * -whiteSquares;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:09:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countAlternatingPairs(H, W, grid) {\n    function isBlack(i, j) {\n        return grid[i][j] === '#';\n    }\n\n    function isWhite(i, j) {\n        return grid[i][j] === '.';\n    }\n\n    let pairsCount = 0;\n\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (isBlack(i, j)) {\n                if (i > 0 && isWhite(i - 1, j)) pairsCount++;\n                if (j > 0 && isWhite(i, j - 1)) pairsCount++;\n                if (i < H - 1 && isWhite(i + 1, j)) pairsCount++;\n                if (j < W - 1 && isWhite(i, j + 1)) pairsCount++;\n            } else if (isWhite(i, j)) {\n                if (i > 0 && isBlack(i - 1, j)) pairsCount++;\n                if (j > 0 && isBlack(i, j - 1)) pairsCount++;\n                if (i < H - 1 && isBlack(i + 1, j)) pairsCount++;\n                if (j < W - 1 && isBlack(i, j + 1)) pairsCount++;\n            }\n        }\n    }\n\n    return pairsCount / 2;\n}",
    "timestamp": "2025-08-13 13:09:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\n\ndef solve(H: int, W: int, grid: List[str]) -> int:\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < H and 0 <= y < W\n\n    def dfs(x: int, y: int, color: bool, length: int) -> int:\n        total = 0\n        if length % 2 == 1 and not color:\n            total += 1\n\n        visited.add((x, y))\n        \n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                next_color = grid[nx][ny] == '#'\n                if next_color != color:\n                    total += dfs(nx, ny, next_color, length + 1)\n        \n        visited.remove((x, y))\n        return total\n\n    total_pairs = 0\n    for x in range(H):\n        for y in range(W):\n            visited = set()\n            color = grid[x][y] == '#'\n            total_pairs += dfs(x, y, color, 0)\n\n    return total_pairs // 2\n\n# Input reading and solution calling\nH, W = map(int, input().split())\ngrid = [input().strip() for _ in range(H)]\nprint(solve(H, W, grid))",
    "timestamp": "2025-08-13 13:09:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(H, W, grid) {\n    function isValid(x, y) {\n        return x >= 0 && x < H && y >= 0 && y < W;\n    }\n\n    function isBlack(x, y) {\n        return grid[x][y] === '#';\n    }\n\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let count = 0;\n\n    for (let x1 = 0; x1 < H; x1++) {\n        for (let y1 = 0; y1 < W; y1++) {\n            if (!isBlack(x1, y1)) continue;\n\n            for (let x2 = 0; x2 < H; x2++) {\n                for (let y2 = 0; y2 < W; y2++) {\n                    if (isBlack(x2, y2)) continue;\n\n                    const visited = new Set();\n                    const queue = [[x1, y1, true]];\n                    visited.add(`${x1},${y1}`);\n\n                    while (queue.length > 0) {\n                        const [x, y, isBlackSquare] = queue.shift();\n\n                        if (x === x2 && y === y2) {\n                            count++;\n                            break;\n                        }\n\n                        for (const [dx, dy] of directions) {\n                            const nx = x + dx;\n                            const ny = y + dy;\n\n                            if (isValid(nx, ny) && !visited.has(`${nx},${ny}`)) {\n                                if (isBlackSquare && !isBlack(nx, ny)) {\n                                    queue.push([nx, ny, false]);\n                                    visited.add(`${nx},${ny}`);\n                                } else if (!isBlackSquare && isBlack(nx, ny)) {\n                                    queue.push([nx, ny, true]);\n                                    visited.add(`${nx},${ny}`);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}",
    "timestamp": "2025-08-13 13:09:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Visited and distance tracking\n    visited = [[False for _ in range(W)] for _ in range(H)]\n    color = [[None for _ in range(W)] for _ in range(H)]\n    \n    total_black = 0\n    total_white = 0\n    \n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                queue = deque()\n                queue.append((i, j))\n                visited[i][j] = True\n                color[i][j] = 0 if grid[i][j] == '#' else 1\n                black = 0\n                white = 0\n                if color[i][j] == 0:\n                    black += 1\n                else:\n                    white += 1\n                \n                while queue:\n                    x, y = queue.popleft()\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < H and 0 <= ny < W:\n                            if not visited[nx][ny] and grid[nx][ny] != grid[x][y]:\n                                visited[nx][ny] = True\n                                color[nx][ny] = 0 if grid[nx][ny] == '#' else 1\n                                if color[nx][ny] == 0:\n                                    black += 1\n                                else:\n                                    white += 1\n                                queue.append((nx, ny))\n                total_black += black\n                total_white += white\n    \n    print(total_black * total_white)\n\nsolve()",
    "timestamp": "2025-08-13 13:09:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [H, W] = input[0].split(' ').map(Number);\n    const grid = input.slice(1, H + 1).map(row => row.split(''));\n    \n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const visited = Array.from({ length: H }, () => Array(W).fill(false));\n    let blackCount = 0;\n    let whiteCount = 0;\n    let totalPairs = 0;\n    \n    const bfs = (i, j) => {\n        let queue = [[i, j]];\n        visited[i][j] = true;\n        let currentColor = grid[i][j];\n        let localBlack = 0;\n        let localWhite = 0;\n        \n        if (currentColor === '#') localBlack++;\n        else localWhite++;\n        \n        while (queue.length > 0) {\n            const [x, y] = queue.shift();\n            for (const [dx, dy] of directions) {\n                const nx = x + dx;\n                const ny = y + dy;\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && grid[nx][ny] !== grid[x][y]) {\n                    visited[nx][ny] = true;\n                    if (grid[nx][ny] === '#') localBlack++;\n                    else localWhite++;\n                    queue.push([nx, ny]);\n                }\n            }\n        }\n        return [localBlack, localWhite];\n    };\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (!visited[i][j]) {\n                const [b, w] = bfs(i, j);\n                totalPairs += b * w;\n            }\n        }\n    }\n    \n    console.log(totalPairs);\n};\n\nsolve();",
    "timestamp": "2025-08-13 13:09:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint H, W;\nvector<string> grid;\nvector<vector<bool>> visited;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool isValid(int x, int y) {\n    return x >= 0 && y >= 0 && x < H && y < W;\n}\n\nint bfs(int startX, int startY) {\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = true;\n    \n    int countBlack = 0, countWhite = 0;\n    \n    if (grid[startX][startY] == '#') countBlack++;\n    else countWhite++;\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        for (int direction = 0; direction < 4; direction++) {\n            int newX = x + dx[direction];\n            int newY = y + dy[direction];\n\n            if (isValid(newX, newY) && !visited[newX][newY] && grid[newX][newY] != grid[x][y]) {\n                visited[newX][newY] = true;\n                if (grid[newX][newY] == '#') countBlack++;\n                else countWhite++;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    return countBlack * countWhite;\n}\n\nint main() {\n    cin >> H >> W;\n    grid.resize(H);\n    visited.resize(H, vector<bool>(W, false));\n\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n    \n    int result = 0;\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (!visited[i][j]) {\n                result += bfs(i, j);\n            }\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:38:17"
  }
]