[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tup = min(up, bs[i].ys[0]);\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-7;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\n\n\n// usage:\n// g++ -Wall -Dvisualize hoge.cpp\n// ./a.out 2> data.js\n// firefox Visualize.html\nint zoom = 10;\n#ifdef visualize\nvoid ChangeColor(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\nvoid DrawPoint(const Point &p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\",\n      (int)(zoom*p.real()), 1980-(int)(zoom*p.imag()), 2);\n}\nvoid DrawLine(const Line &l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\",\n      (int)(zoom*l[0].real()), 1980-(int)(zoom*l[0].imag()),\n      (int)(zoom*l[1].real()), 1980-(int)(zoom*l[1].imag()));\n}\nvoid DrawCircle(const Circle &c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\",\n      (int)(zoom * c.p.real()), 1980 - (int)(zoom * c.p.imag()), (int)(zoom * c.r));\n}\n#else\nvoid DrawPoint(const Point &p) {;}\nvoid ChangeColor(int r, int g, int b) {;}\nvoid DrawLine(Line l) {;}\nvoid DrawPolygon(const Polygon &p) {;}\nvoid DrawCircle(Circle c) {;}\n#endif\n\nstruct Rect {\n  double x1, y1, x2, y2;\n  Rect() {;}\n  Rect(double x1, double y1, double x2, double y2) :\n    x1(x1), y1(y1), x2(x2), y2(y2) {;}\n};\nvoid DrawRect(const Rect &rect) {\n  DrawLine(Line(Point(rect.x1, rect.y1), Point(rect.x2, rect.y1)));\n  DrawLine(Line(Point(rect.x2, rect.y1), Point(rect.x2, rect.y2)));\n  DrawLine(Line(Point(rect.x2, rect.y2), Point(rect.x1, rect.y2)));\n  DrawLine(Line(Point(rect.x1, rect.y2), Point(rect.x1, rect.y1)));\n}\n\nconst double G = 9.8;\nint n;\nRect rect[400];\ndouble v, ex, ey;\n\n// y = -G / 2 * t^2 + v * sinA * t\n// x = v * cosA * t\n// t = X / (v * cosA)\n\ndouble Y(double theta, double x) {\n  double t = x / (v * cos(theta));\n  return -G / 2.0 * t * t + v * sin(theta) * t;\n}\n\nbool calc(double theta) {\n  if (Y(theta, ex) - ey < -EPS) { return false; }\n  double mx, my;\n  {\n    double left = 0.0;\n    double right = 500;\n    REP(iter, 100) {\n      double midl = (left * 2.0 + right) / 3.0;\n      double midr = (left + right * 2.0) / 3.0;\n      double yl = Y(theta, midl);\n      double yr = Y(theta, midr);\n      if (yl > yr) {\n        right = midr;\n      } else {\n        left = midl;\n      }\n    }\n    mx = left;\n    my = Y(theta, mx);\n  }\n  static int cnt = 0;\n  cnt++;\n  if (cnt == 11) {\n    Point prev(0.0, 0.0);\n    REP(x, 120) {\n      Point next(x + 1, Y(theta, x + 1));\n      DrawLine(Line(prev, next));\n      prev = next;\n    }\n  }\n  REP(i, n) {\n    double ly = Y(theta, rect[i].x1);\n    double ry = Y(theta, rect[i].x2);\n    if (EPS >= rect[i].y2 - ly && EPS >= rect[i].y2 - ry) { continue; }\n    if ((-EPS >= rect[i].y1 -ly && EPS <= rect[i].y2 - ry) ||\n        (EPS <= rect[i].y2 - ly && -EPS >= rect[i].y1 - ry) ||\n        (rect[i].y1 - ly < -EPS && EPS < rect[i].y2 - ly) ||\n        (rect[i].y1 - ry < -EPS && EPS < rect[i].y2 - ry)) { return false; }\n    if (EPS < rect[i].y2 - ly && EPS < rect[i].y2 - ry && rect[i].x1 <= mx && mx <= rect[i].x2 && rect[i].y1 - my <= -EPS) { return false; }\n  }\n  return true;\n}\n\ndouble CalcTheta(double left, double right, double tx, double ty, int dir) {\n  REP(iter, 100) {\n    double mid = (left + right) / 2.0;\n    if (Y(mid, tx) < ty) {\n      if (dir == 1) {\n        right = mid;\n      } else {\n        left = mid;\n      }\n    } else {\n      if (dir == 1) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n  }\n  return left;\n}\n\nbool OK(double tx, double ty) {\n  double left = 0;\n  double right = PI / 2 - EPS;\n  REP(iter, 200) {\n    double midl = (left * 2.0 + right) / 3.0;\n    double midr = (left + right * 2.0) / 3.0;\n    double yl = Y(midl, tx);\n    double yr = Y(midr, tx);\n    if (yl > yr) {\n      right = midr;\n    } else {\n      left = midl;\n    }\n  }\n  //if (Y(left, tx) - ty < -EPS) { return false; }\n  bool ret = false;\n  ret |= calc(CalcTheta(0, left, tx, ty, -1));\n  ret |= calc(CalcTheta(left, PI / 2 - EPS, tx, ty, 1));\n  return ret;\n}\n\nint main(int argc, char *argv[]) {\n  if (argc > 1) { zoom = atoi(argv[1]); }\n  while (scanf(\"%d %lf %lf %lf\", &n, &v, &ex, &ey) > 0) {\n    DrawCircle(Circle(Point(0, 0), 1));\n    DrawCircle(Circle(Point(ex, ey), 1));\n    REP(i, n) {\n      double x1, x2, y1, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      if (x1 <= ex && ex <= x2 && y2 >= ey) {\n        y2 = 1e+5;\n      }\n      x2 = min(x2, ex + EPS);\n      if (ex < x1) {\n        x1 = 1e+5;\n        x2 = 2e+5;\n        y1 = 1e+5;\n        y2 = 2e+5;\n      }\n      rect[i] = Rect(x1, y1, x2, y2);\n      DrawRect(rect[i]);\n    }\n    bool ok = false;\n    ok |= OK(ex, ey + EPS);\n    REP(i, n) {\n      if (ok) { break; }\n      ok |= OK(rect[i].x1, rect[i].y2 + EPS);\n      ok |= OK(rect[i].x2, rect[i].y2 + EPS);\n      ok |= OK(rect[i].x1, rect[i].y1 - EPS);\n      ok |= OK(rect[i].x2, rect[i].y1 - EPS);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int i = -1; i <= 1; i += 2)\n\t{\n\t\tdouble t2 = (-b + i * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = (y + g * t * t / 2) / t;//sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X == bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, calc(vx, vy / g));\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tr = min(r, X);\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * px / sqrt(px*px+py*py);\n  ld vy = V * py / sqrt(px*px+py*py);\n  ld t1 = (double)l/vx;\n  ld t2 = (double)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  bool ok = true;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) ok = false;\n  }\n  REP(i,N){\n    REP(j,N){\n      if(check(L[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(L[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n    }\n    if(ok == false) break;\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-8;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nbool is_up(double rad, double x){\n  return x < calc_x_y0(rad) / 2.0 - EPS;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPS){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  //if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << \"fir \" << equal(calc_y(res2, x), y) << endl;\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << res2 * 180.0 / M_PI << endl;\n  //cout << \"sec \" << equal(calc_y(res2, x), y) << endl;\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    double y[2] = {imag(rv[i].ll), imag(rv[i].ur)};\n    if(x[0] > real(target) + EPS) continue;\n    if(calc_y(rad, x[0]) < y[0] - EPS && calc_y(rad, x[1]) > y[0] + EPS || calc_y(rad, x[0]) > y[1] + EPS && calc_y(rad, x[1]) < y[1] - EPS) return true;\n    if(calc_y(rad, x[0]) > y[0] + EPS && calc_y(rad, x[0]) < y[1] - EPS) return true;\n    if(equal(calc_y(rad, x[0]), y[0]) && is_up(rad, x[0]) || equal(calc_y(rad, x[1]), y[1]) && !is_up(rad, x[1])) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  //if(calc_x_y0(M_PI/4.0) < imag(target) - EPS) return false;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) {\n      //cout << calc_res[i] * 180.0 / M_PI << endl;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_min - eps < b.ys[0] && b.ys[1] < y_max + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tup = min(up, bs[i].ys[0]);\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down <= ay&&ay <= up) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double eps = 1e-10;\nconst int MAX_N = 50;\nconst double g = 9.8;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble position(double vy, double t) {\n\treturn vy*t-g*t*t/2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n\treturn a < lb + eps?-1:a>ub-eps?1:0;\n}\n\n// 射出路径经过(qx,qy)时，能否击中猪\nbool check(double qx, double qy) {\n\tdouble a = g*g/4.0, b=g*qy-V*V, c=qx*qx+qy*qy;\n\tdouble D = b*b-4*a*c;\n\tif (D < 0 && D > -eps) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2) { // 验证解的循环\n\t\tdouble t2 = (-b + d*sqrt(D))/(2*a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx/t, vy=(qy+g*t*t/2.0)/t;\n\t\t// 是否通过猪的正上方？\n\t\tdouble yt = position(vy, X/vx);\n\t\tif (yt < Y-eps) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (L[i] >= X) continue;\n\t\t\tif (R[i] == X &&  Y <= T[i] && B[i] <= yt) ok = false;\n\t\t\tint yL = cmp(B[i], T[i], position(vy, L[i]/vx)); // 左侧相对位置\n\t\t\tint yR = cmp(B[i], T[i], position(vy, R[i]/vx)); // 右侧相对位置\n\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g)); // 最高点相对位置\n\t\t\tint yH = cmp(B[i], T[i], position(vy, vy/g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0) ok = false;\n\t\t\tif (yL * yR <= 0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tok |= check(L[i], T[i]);\n\t\tok |= check(R[i], T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 55;\nconst double g = 9.8;   //重力加速度\nconst int EPS = 1e-10;\nint N, V, X, Y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\n\n//&#35745;算以vy的速度&#31446;直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相&#23545;lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//判断当射出路径&#32463;&#36807;点(qx, qy)&#26102;，卵是否能&#20987;中猪\nbool check(double qx, double qy)\n{\n    //&#35774;初速度在x方向和y方向的分量分&#21035;&#20026;vx和vy，&#35774;通&#36807;(qx, qy)的&#26102;&#38388;&#20026;t\n    //&#35774;解&#32852;立方程式vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //&#39564;&#35777;&#32852;立方程式上的&#20004;个解的循&#29615;\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //判断是否通&#36807;猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //判断在猪正上方的&#40479;和猪之&#38388;是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //判断在&#39134;到猪的正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //左&#20391;的相&#23545;位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //右&#20391;的相&#23545;位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //最高点的相&#23545;位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    //截掉猪以右的障碍物\n    for (int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);      //直接撞上猪的情况\n    for (int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);     //&#32463;&#36807;左上角的情况\n        ok |= check(R[i], T[i]);     //&#32463;&#36807;右上角的情况\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while (scanf(\"%d%d%d%d\", &N, &V, &X, &Y) != EOF){\n        for (int i = 0; i < N; i++){\n            scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-6\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=v,mid = (l+r)/2;\n     double t,vx,vy,len;\n     vy=v;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           vy=mid;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           len = vx*2*t;\n           if ( len<xx )\n              r=mid;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LTE(h,lb)?-1:(GTE(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      double rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      double rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      //cout << \"getY = \" <<vy << \" \" << R[j] << endl;\n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      //if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  rep(i,N) R[i] = min(R[i],X);\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n\n  cin >> N >> v0 >> X >> Y;\n  rep(i,N) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\nconst int N = 60;\nint n, v, x, y, L[N], B[N], R[N], T[N];\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\nbool check(double qx, double qy) {\n    double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n    double d = b * b - 4 * a * c;\n    if (d < 0 && d > -eps) d = 0;\n    if (d < 0) return false;\n    for (int co = -1; co <= 1; co += 2) {\n        double t2 = (-b + co * sqrt(d)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        double yt = calc(vy, x / vx);\n        if (yt < y - eps) continue;\n        bool ok = true;\n        for (int i = 0; i < n; i++) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y == T[i] && B[i] <= yt) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        R[i] = min(R[i], x);\n    }\n    bool ok = check(x,y);\n    for (int i = 0; i < N; i++) {\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d%d%d\", L + i, B + i, R + i, T + i);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n \nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n \n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n \n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n     \n    int comp(double lb, double ub, double x){\n        if(x < lb + EPS) return -1;\n        if(x > ub - EPS) return 1;\n        return 0;\n    }\n \n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            for(int i = 0; i < n; i++){\n                if(x1[i] >= gx) continue;\n                if(comp(x1[i], x2[i], gx) == 0 && comp(y1[i], y2[i], gy) <= 0 && comp(y1[i], y2[i], fh) >= 0) {\n                    ok = false;\n                }\n                int yl = comp(y1[i], y2[i], calc_y(vx, vy, x1[i]));\n                int yr = comp(y1[i], y2[i], calc_y(vx, vy, x2[i]));\n                int xh = comp(x1[i], x2[i], vx * vy / g);\n                int yh = comp(y1[i], y2[i], calc_y(vx, vy, vx * vy / g));\n                if(xh == 0 && yh >= 0 && yl <= 0) ok = false;\n                if(yl * yr <= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        REP(i, n) x2[i] = min(x2[i], gx);\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n \nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=500000;i++ )\n     {\n           vy=double(i)/500000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double eps = 1-10;\nconst int N = 55;\nconst double g = 9.8;\ndouble x, y, v, u[N], d[N], l[N], r[N];\nint n;\n\ndouble cal(double tv, double tt) {\n    return tv*tt - g*tt*tt/2;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool sol(double qx, double qy) {\n    double a = g*g/4, b = g*qy - v*v, c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D < 0 && D > -eps) D = 0;\n    if(D < 0) return 0;\n    for(int td = -1; td <= 1; td += 2) {\n        double t2 = (-b+td*sqrt(D)) / (2*a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy+g*t*t/2) / t;\n\n        double yt = cal(vy, x / vx);\n        if(yt < y - eps) continue;\n\n        bool ok = 1;\n        for(int i = 0; i < n; ++i) {\n            if(l[i] >= x) continue;\n            if(r[i] == x && yt-d[i] >= 0 && y-u[i] <= 0) ok = 0;\n            int L = cmp(d[i], u[i], cal(vy, l[i] / vx));\n            int R = cmp(d[i], u[i], cal(vy, r[i] / vx));\n            int HX = cmp(l[i], r[i], vx * vy / g);\n            int HY = cmp(d[i], u[i], cal(vy, vy / g));\n            if(L * R <= 0) ok = 0;\n            if(HX == 0 && HY >= 0 && L == -1) ok = 0;\n        }\n        if(ok) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %lf %lf %lf\", &n, &v, &x, &y);\n    for(int i = 0; i < n; ++i) scanf(\"%lf%lf%lf%lf\", &l[i], &d[i], &r[i], &u[i]);\n    for(int i = 0; i < N; ++i) r[i] = min(r[i], x);\n    int ok = 0;\n    if(sol(x, y)) ok = 1;\n    for(int i = 0; i < n; ++i) if(sol(l[i], u[i]) || sol(r[i], u[i]) ) ok = 1;\n    puts(ok ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\n#define MAX_N (50+10)\nconst double G = 9.8;\n#define EPS 1e-20\n\nint N,V,X,Y;\n// (L[i],B[i]) , (R[i],T[i]) // 左下,右上\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\n// 速度vyで上に打ち出した際のt秒後のy座標を計算する\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2;\n}\n\n// aのlbとubに対する相対的な位置\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n// 点(qx,qy)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool check(double qx, double qy) {\n    // 初速のx方向成分をvx,y方向成分をvyとし、(qx,qy)を通る時刻をtとしたときの連立方程式\n    // vx^2 + vy^2 = V^2, vx * t = qx, vy * t - 1/2 g t^2 = qy を解く\n    double a = 1.0/4.0 * G * G,\n           b = qy * G - V * V,\n           c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D<0 && D > -EPS) D = 0;\n    if(D<0) return false; // 虚数\n    for(int d=-1;d<=1;d+=2) { // 連立方程式の2つの解を試すループ\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2) / t;\n\n        // 豚より上を通過できるか判定\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS) continue;\n\n        bool ok = true;\n        for(int i=0;i<N;i++) {\n            if (L[i] >= X) continue;\n            // 豚の真上まで来たときに、間に障害物がないか判定\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            // 途中で障害物にぶつからないか判定\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx)); // 左端での相対位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx)); // 右端での相対位置\n            int xH = cmp(L[i], R[i], vx * (vy / G)); // 最も高くなる地点の相対位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / G));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    // 豚より右にある障害物を縮めておく\n    for(int i=0;i<N;i++) {\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y); // 直接ぶつける場合\n    for(int i=0;i<N;i++) {\n        ok |= check(L[i], T[i]); // 左上の角を通る場合\n        ok |= check(R[i], T[i]); // 右上の角を通る場合\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nmain() {\n    cin>>N>>V>>X>>Y;\n    for(int i=0;i<N;i++) {\n        cin>>L[i]>>B[i]>>R[i]>>T[i];\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\n//int dcmp(double d){\n//\tif(d<-eps) return -1;\n//\telse if(d>eps) return 1;\n//\telse return 0;\n//}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a<lb+eps?-1:ub<a+eps?1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(D<0&&D>-eps) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(yt<Y-eps) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nn本の棒があり、各棒iの端点の座標は(pix,piy)と(qix,qiy)\n指定されたm個の棒のペア(ai,bi)について、それらが連結であるか判定せよ。\n\n2つの棒が共有点を持つとき連結\n*/\nusing namespace std;\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nconst double EPS = 1e-10;\nconst double g = 9.8;\nint N, V, X, Y;\nint L[50], B[50], R[50], T[50];\n\n//速度vyで上に打ち出した際のt秒後の位置を計算する\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n//aのlbとubに対する相対的な位置 -1 0 1 のどれかを返す\nint cmp (double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n//点(qx,qy)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool check(double qx, double qy) {\n    //初速のx方向成分をvx, y方向成分をvyとし、(qx,qy)を通る時刻をtとしたときの連立方程式\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS) D = 0;\n    if (D < 0) return false;\n    for (int d = -1; d <= 1; d+=2) { //連立方程式の二つの解を試すループ\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //豚より上を通過できるか判定\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS) continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++) {\n            if (L[i] >= X) continue;\n            //豚の真上まで来たときに、間に障害物がないか判定\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            //途中で障害物にぶつからないか判定\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx)); //左端での相対位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx)); //右端での相対位置\n            int xH = cmp(L[i], R[i], vx * (vy / g)); //最も高くなる地点の相対位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g)); //右端での相対位置\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    //豚より右にある障害物を縮めておく\n    for (int i = 0; i < N; i++) {\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y); //直接ぶつける\n    for (int i = 0; i < N; i++) {\n        ok |= check(L[i], T[i]); //左上の角を通る場合\n        ok |= check(R[i], T[i]); //右上の角を通る場合\n    }\n    cout << (ok ? \"Yes\\n\" : \"No\\n\");\n}\n\nint main() {\n    cin >> N >> V >> X >> Y;\n    for (int i = 0; i < N; i++) {\n        cin >> L[i] >> B[i] >> R[i] >> T[i];\n    }\n    solve();\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\t//tans = ntans;\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPSILON = 1e-10;\n\nconst double g = 9.8;\n\nconst int N = 50 + 5;\n\nstruct Point {\n  double x, y;\n  Point(double x, double y): x(x), y(y) {}\n};\n\nstatic int n;\n\ndouble L[N], B[N], R[N], T[N];\n\nint dcmp(double x, double y) {\n  if (fabs(x - y) < EPSILON) {\n    return 0;\n  }\n  return x < y ? -1 : 1;\n}\n\ndouble farthest_x(double a, double b) {\n  double x_t = -b / a;\n\n  for (int i = 0; i < n; ++i) {\n    double y0 = a * L[i] * L[i] + b * L[i];\n    if (dcmp(B[i], y0) < 0 && dcmp(y0, T[i]) < 0) {\n      x_t = min(x_t, L[i]);\n    }\n\n    double delta = b * b + 4 * a * B[i];\n    if (dcmp(delta, 0.0) > 0) {\n      double x0 = (-b + sqrt(delta)) / (2 * a);\n      if (dcmp(L[i], x0) <= 0 && dcmp(x0, R[i]) < 0) {\n        x_t = min(x_t, x0);\n      }\n    }\n\n    delta = b * b + 4 * a * T[i];\n    if (dcmp(delta, 0.0) >= 0) {\n      double x1 = (-b - sqrt(delta)) / (2 * a);\n      if (dcmp(L[i], x1) <= 0 && dcmp(x1, R[i]) < 0) {\n        x_t = min(x_t, x1);\n      }\n    }\n  }\n\n  return x_t;\n}\n\nint main() {\n#ifdef DEBUG\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n  double v, x, y;\n\n  while (scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y) != EOF) {\n    vector<Point> points;\n    points.push_back(Point(x, y));\n\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n      points.push_back(Point(L[i], B[i]));\n      points.push_back(Point(R[i], B[i]));\n      points.push_back(Point(L[i], T[i]));\n      points.push_back(Point(R[i], T[i]));\n    }\n\n    bool impossible = true;\n\n    double A = 0.25 * g * g;\n    for (size_t i = 0; i < points.size(); ++i) {\n      const Point &p = points[i];\n\n      if (p.x == 0.0) {\n        continue;\n      }\n\n      double B = p.y * g - v * v;\n      double C = p.x * p.x + p.y * p.y;\n\n      double delta = B * B - 4 * A * C;\n      if (delta >= 0.0) {\n        double t_2s[2] = { (-B - sqrt(delta)) / (2 * A), (-B + sqrt(delta)) / (2 * A) };\n        for (int j = 0; j < 2; ++j) {\n          double t_2 = t_2s[j];\n          if (t_2 > 0) {\n            double t = sqrt(t_2);\n            double vx = p.x / t;\n            double vy = sqrt(v * v - vx * vx);\n            double a = -0.5 * g / (vx * vx), b = vy / vx;\n            if (dcmp(a * x * x + b * x, y) >= 0 && dcmp(farthest_x(a, b), x) >= 0) {\n              // printf(\"(%lf, %lf), a = %lf, b = %lf, vx = %lf, vy = %lf, t = %lf, x_t = %lf\\n\", p.x, p.y, a, b, vx, vy, t, farthest_x(a, b));\n              impossible = false;\n            }\n          }\n        }\n      }\n    }\n\n    printf(\"%s\\n\", impossible ? \"No\" : \"Yes\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <iomanip>\n#include <queue>\n#include <ctime>\nusing namespace std;\ntemplate <class T> void checkmin(T &t,T x){if (x < t) t = x;}\ntemplate <class T> void checkmax(T &t,T x){if (x > t) t = x;}\ntemplate <class T> void _checkmin(T &t, T x){if (t == -1) t = x; if (x < t) t = x;}\ntemplate <class T> void _checkmax(T &t, T x){if (t == -1) t = x; if (x > t) t = x;}\ntypedef pair <int,int> PII;\ntypedef pair <double,double> PDD;\ntypedef long long lld;\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin();it != (v).end();it++)\n#define DEBUG(a) cout << #a\" = \" << (a) << endl;\n#define DEBUGARR(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\nvector<PDD> inter[100];\ndouble V,X,Y;\ndouble pi = acos(-1.0);\ndouble x0[100],_y0[100],x1[100],_y1[100];\nint N;\ntypedef vector<PDD> VP;\ndouble sqr(double x){return x*x;}\ndouble yatx(double thita,double x){\n\tdouble t=x / (V * cos(thita));\n\treturn (V*sin(thita) -4.9 * t) *t;\n}\ndouble g = 9.8;\nvector<PDD> zup(double xx,double yy) {\n\tdouble tmp =(g * sqr(xx) + sqr(V) * yy )/(sqr(V)*hypot(xx,yy));\n\tif (tmp>1) return vector<PDD>();\n\tdouble A = asin((g * sqr(xx) + sqr(V) * yy )/(sqr(V)*hypot(xx,yy))),\n\t\t   B = atan(yy/xx);\n\tvector<PDD> ret;\n\tret.push_back(PDD(0.5*(A+B),0.5*(M_PI - A +B)));\n\treturn ret;\n}\nPDD getU(PDD A,PDD B){\n\tdouble a = max(A.first,B.first);\n\tdouble b = min(A.second,B.second);\n\treturn PDD(a,b);\n}\nVP Unoin(VP A,VP B){\n\tVP ans;\n\tif (A.size()==0||B.size()==0) return ans;\n\tfor (int j,i=0;i<A.size();i++)\n\t\tfor (j=0;j<B.size();j++){\n\t\t\tPDD tmp = getU(A[i],B[j]);\n\t\t\tif (tmp.first<tmp.second){\n\t\t\t\tans.push_back(tmp);\n\t\t\t}\n\t\t}\n\treturn ans;\n}\n\nVP calc_up(double x0,double x1,double y){\n\tVP inter0 = zup(x0,y);\n\tVP inter1 = zup(x1,y);\n\treturn Unoin(inter0,inter1);\n\n}\nVP calc_below(double x0,double x1,double y){\n\tVP up = zup(x1,0);\n\tVP inter0 = zup(x0,y),inter1;\n\tif (inter0.size()==0){\n\t\tinter1.push_back(PDD(0,pi/2));\n\t}else {\n\t\tinter1.push_back(PDD(0,inter0[0].first));\n\t\tinter1.push_back(PDD(inter0[0].second,pi/2));\n\t}\n\treturn Unoin(up,inter1);\n}\n\nVP calc_down(double x0,double x1,double y){\n\tVP inter0 = calc_below(x0,x1,y);\n\tVP inter1 = calc_below(x1,x1,y);\n\treturn Unoin(inter0,inter1);\n}\n\n\nVP calc(int now){\n\tinter[now].clear();\n\tVP up = calc_up(x0[now],x1[now],_y0[now]);\n\tVP down = calc_down(x0[now],x1[now],_y1[now]);\n\tVP ret ;\n\tfor (int i=0;i<up.size();i++)\n\t\tret.push_back(up[i]);\n\tfor (int i=0;i<down.size();i++)\n\t\tret.push_back(down[i]);\n\n\treturn ret;\n}\n\t\nint main(){\n#ifdef cwj\n\tfreopen(\"in\", \"r\", stdin);\n#endif\n\twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n\t\tVP ans;\n\t\tans.push_back(PDD(0,pi/2));\n\t\tfor (int i=0;i<N;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x0[i],&_y0[i],&x1[i],&_y1[i]);\n\t\t\tif (x1[i]>X) x1[i] = X;\n\t\t\tcalc(i);\n\t\t\tans = Unoin(ans,inter[i]);\n\t\t}\n\t\tVP up ;\n\t\tup = zup(X,Y);\n\t\tans = Unoin(ans,up);\n\t\tif (ans.size()>0) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\n\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  Created by TaoSama on 2016-08-22\n//  Copyright (c) 2016 TaoSama. All rights reserved.\n//\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n\nusing namespace std;\n#define pr(x) cout << #x << \" = \" << x << \"  \"\n#define prln(x) cout << #x << \" = \" << x << endl\nconst int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nconst double EPS = 1e-8, g = 9.8;\n\nint sgn(double x) {\n    return x < -EPS ? -1 : x > EPS;\n}\n\nint n;\ndouble V, X, Y;\ndouble L[N], B[N], R[N], T[N];\n\ndouble getY(double vy, double t) {\n    return vy * t - 0.5 * g * t * t;\n}\n\nbool check(double qx, double qy) {\n    //vx^2 + vy^2 = v^2, vx * t = qx,  vy*t -0.5*g*t^2=qy\n    //qx^2+qy^2+qy*g*t^2+(0.5*g*t^2)^2-v^2*t=0\n    double a = g * g / 4, b = qy * g - V * V, c = qx * qx + qy * qy;\n\n    double delta = b * b - 4 * a * c;\n    if(sgn(delta) < 0) return false;\n    delta = sqrt(abs(delta));\n\n    for(int d = -1; d <= 1; d += 2) {\n        double t = (-b + d * delta) / (2 * a);\n        if(sgn(t) < 0) continue;\n        t = sqrt(abs(t));\n        double vx = qx / t, vy = (qy + 0.5 * g * t * t) / t;\n\n        double yt = getY(vy, X / vx);\n        if(sgn(yt - Y) < 0) continue;\n\n        bool ok = true;\n        for(int i = 1; i <= n && ok; ++i) {\n            if(sgn(L[i] - X) > 0) continue;\n\n            //target is in or below the obstacle\n            if(sgn(X - L[i]) >= 0 && sgn(X - R[i]) <= 0 &&\n                    sgn(yt - B[i]) >= 0 && sgn(Y - T[i]) <= 0) ok = false;\n\n\n            double yL = getY(vy, L[i] / vx), yR = getY(vy, R[i] / vx);\n            //hit left\n            if(sgn(yL - B[i]) >= 0 && sgn(yL - T[i]) <= 0) ok = false;\n            //hit right\n            if(sgn(yR - B[i]) >= 0 && sgn(yR - T[i]) <= 0) ok = false;\n\n            //highest point\n            double xH = vx * vy / g, yH = getY(vy, vy / g);\n            //hit inside, this time highest point is in or above the obstacle\n            if(sgn(xH - L[i]) >= 0 && sgn(xH - R[i]) <= 0 &&\n                    sgn(yL - L[i]) < 0 && sgn(yH - B[i]) >= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\TaoSama\\\\Desktop\\\\in.txt\", \"r\", stdin);\n//  freopen(\"C:\\\\Users\\\\TaoSama\\\\Desktop\\\\out.txt\",\"w\",stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n\n    while(scanf(\"%d%lf%lf%lf\", &n, &V, &X, &Y) == 4) {\n        for(int i = 1; i <= n; ++i) {\n            scanf(\"%lf%lf%lf%lf\", L + i, B + i, R + i, T + i);\n            R[i] = min(R[i], X);\n        }\n\n        bool ok = check(X, Y);\n        for(int i = 1; i <= n && !ok; ++i) {\n            ok |= check(L[i], T[i]);\n            ok |= check(R[i], T[i]);\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst double g=9.8;\ndouble EPS=1e-6;\nint N,V,X,Y;\nint L[55],B[55],R[55],T[55];\ndouble calc(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double lb,double ub,double a)\n{\n    return a<lb+EPS?-1:a>ub-EPS?1:0;\n}\nbool check(double qx,double qy)\n{\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double D=b*b-4*a*c;\n    if(D<0&&D>-EPS)\n    {\n        D=0;\n    }\n    if(D<0)\n    {\n        return false;\n    }\n    for(int d=-1;d<=1;d+=2)\n    {\n        double t2=(-b+d*sqrt(D))/(2*a);\n        if(t2<0)\n        {\n            continue;\n        }\n        double t=sqrt(t2);\n        double vx=qx/t,vy=(qy+g*t*t/2)/2;\n        double yt=calc(vy,X/vx);\n        if(yt<Y-EPS)\n        {\n            continue;\n        }\n        bool ok=true;\n        for(int i=0;i<N;++i)\n        {\n            if(L[i]>=X)\n            {\n                continue;\n            }\n            if(R[i]==X&&Y<=T[i]&&B[i]<=yt)\n            {\n                ok=false;\n            }\n            int yL=cmp(B[i],T[i],calc(vy,L[i]/vx));\n            int yR=cmp(B[i],T[i],calc(vy,R[i]/vx));\n            int xH=cmp(L[i],R[i],vx*(vy/g));\n            int yH=cmp(B[i],T[i],calc(vy,vy/g));\n            if(xH==0&&yH>=0&&yL<0)\n            {\n                ok=false;\n            }\n            if(yL*yR<=0)\n            {\n                ok=false;\n            }\n        }\n        if(ok)\n        {\n            return true;\n        }\n    }\n    return false;\n}\nint main()\n{\n    scanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n    for(int i=0;i<N;++i)\n    {\n        scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n    }\n    for(int i=0;i<N;++i)\n    {\n        R[i]=min(R[i],X);\n    }\n    bool ok=check(X,Y);\n    for(int i=0;i<N;++i)\n    {\n        ok|=check(L[i],T[i]);\n        ok|=check(R[i],T[i]);\n    }\n    if(ok)\n    {\n        printf(\"Yes\\n\");\n    }\n    else\n    {\n        printf(\"No\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-9;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n  /*\n  cout<<\"!!!\"<<endl;\n  cout<<\"t = \"<<t<<endl;\n  cout<<\"vx = \"<<vx<<endl;\n  cout<<\"vy = \"<<vy<<endl;  \n  */\n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = vy/g;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt,vy);\n    //    cout<<\"fh = \"<<fh<<endl;\n    //    cout<<\"sh = \"<<sh<<endl;\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n    if( check( B[i], T[i], fh, zh ) )return false;\n    if( check( B[i], T[i], zh, sh ) )return false;\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  //cout<<\"lastY = \"<<lastY<<endl;\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  //  cout<<\"??????\"<<endl;\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < -eps )return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n  }\n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n        if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-6;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0; rad < M_PI / 2.0; rad += 0.0000001){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(!((double)gy - EPS <= y && y <= (double)gy + EPS)){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(y1 < 0 || y2 < 0){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y1 + EPS\n             || (double)obstacles[i].top_y < y1 - EPS)){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y2 + EPS\n             || (double)obstacles[i].top_y < y2 - EPS)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-6;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\n// a<lb?±????-1 lb<=a<=ub?±????0 ub<a?±????1\n//?±????????????°??? \nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}\n/*????´???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(eps)?1:0);\n}*/ \n\n/*????¶???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}*/ \n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            //printf(\"vx:%f vy:%d\\n\", vx, vy);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            // テ」ツδ禿」ツつーテ」ツ?ォテ・ツ債オテ」ツ?古・ツスツ禿」ツ?淌」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                if(x1[i] < gx && gx < x2[i] && fh > y1[i]) {\n                    ok = false;\n                }\n            }\n            // テ」ツδ氾」ツつーテ」ツ?ョテ、ツクツ甘ァツゥツコテ」ツ?セテ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                double h1 = calc_y(vx, vy, x1[i]);\n                double h2 = calc_y(vx, vy, x2[i]);\n                if(sign(h1 - y1[i]) > 0 && sign(y2[i] - h1) > 0) ok = false;\n                if(sign(h2 - y1[i]) > 0 && sign(y2[i] - h2) > 0) ok = false;\n                if(sign(y1[i] - h1) >= 0 && sign(h2 - y2[i]) >= 0) ok = false;\n                if(sign(y1[i] - h2) >= 0 && sign(h1 - y2[i]) >= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define _USE_MATH_DEFINES\n\nconst int NMax = 150;\nconst double eps = 1e-8;\nconst double eps1 = 1e-4;\nconst double gravity = 9.8;\nconst double PI = 3.14159265;\n\nint N, V, X, Y;\nint L[NMax], B[NMax], R[NMax], T[NMax];\n\nint main()\n{\n\tcin >>N >>V >>X >>Y;\n\n\tfor (int i = 1; i <= N; ++i)\n\t\tcin >>L[i] >>B[i] >>R[i] >>T[i];\n\n\tfor (double alpha = -eps1; alpha <= PI/2; alpha += eps1)\n\t{\n\t\tdouble V_0x = V * cos(alpha);\n\t\tdouble V_0y = V * sin(alpha);\n\t\tdouble Time = X / V_0x;\n\t\tdouble LandY = V_0y * Time - 0.5*gravity*(Time*Time);\n\n\t\tif (Y - LandY <= eps)\n\t\t{\n            bool intersect = 0;\n\n            for (int i = 1; i <= N; ++i)\n                if (X - L[i] >= eps && X - R[i] <= eps &&\n\t\t\t\t\tLandY - B[i] >= eps && LandY - T[i] <= eps)\n\t\t\t\t\tintersect = 1;\n\n            for (int i = 1; i <= N; ++i)\n\t\t\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t\t{\n\t\t\t\t\tdouble TimeToJ = j / V_0x;\n\t\t\t\t\tif (Time - TimeToJ >= eps)\n\t\t\t\t\t{\n                        double newY = V_0y * TimeToJ - 0.5*gravity*(TimeToJ*TimeToJ);\n                        if (newY - B[i] - eps >= 0 &&\n\t\t\t\t\t\t\tnewY - T[i] - eps <= 0)\n\t\t\t\t\t\t\t\tintersect = 1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\tif (!intersect)\n\t\t\t{\n                cout <<\"Yes\" <<'\\n';\n                return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout <<\"No\" <<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nvector<ld> sq_eq(ld a, ld b, ld c) {\n  ld D = b*b - 4.0*a*c;\n  if (D < eps) return vector<ld>();\n  vector<ld> res;\n  if (b > 0) {\n    res.push_back((-b + sqrt(D)) / (2.0 * a));\n    res.push_back((2.0 * c) / (b - sqrt(D)));\n  } else {\n    res.push_back(- (2.0 * c) / (b + sqrt(D)));\n    res.push_back((-b - sqrt(D)) / (2.0 * a));\n  }\n  return res;\n}\n\nvector<ld> p2tan(ld x, ld y, ld v) {\n  if (x == 0) return vector<ld>(1,-1);\n  ld b = -v*v/(4.9*x);\n  ld c = 1-b*y/x;\n  return sq_eq(1.0,b,c);\n}\n\nvector<ld> l2tan(ld y, ld v) {\n  ld a = -v*v/4.9;\n  ld zsq = 1.0/(1.0/(a*a*4.0)+y/a);\n  ld z1 = sqrt(zsq);\n  ld z2 = -z1;\n  vector<ld> res;\n  res.push_back(-z1/(2.0*a));\n  res.push_back(-z2/(2.0*a));\n  return res;\n}\n\nint main() {\n  int n,v;\n  ld x,y;\n  cin>>n>>v>>x>>y;\n  vector<ld> tanl = p2tan(x,y,v);\n  vector<tuple<ld,ld,ld>> lx;\n  vector<tuple<ld,ld,ld>> ly;\n  ld mn_oby_atx = 1000;\n  REP(i,n){\n    ld l,b,r,t;\n    cin>>l>>b>>r>>t;\n    if (l <= x && x <= r && b >= y)\n      mn_oby_atx = min(mn_oby_atx, b);\n    if (l >= x) continue;\n    r=min(r,x);\n    lx.emplace_back(t,l,r);\n    lx.emplace_back(b,l,r);\n    ly.emplace_back(l,b,t);\n    ly.emplace_back(r,b,t);\n    vector<vector<ld>> s(6);\n    s[0] = p2tan(l,t,v);\n    s[1] = p2tan(r,t,v);\n    s[2] = p2tan(l,b,v);\n    s[3] = p2tan(r,b,v);\n    s[4] = l2tan(t,v);\n    s[5] = l2tan(b,v);\n    REP(j,6)\n      tanl.insert(end(tanl),begin(s[j]),end(s[j]));\n  }\n  if (v == 0) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  auto itr = remove_if(begin(tanl),end(tanl),[](ld val){return val < 0.0;});\n  tanl.erase(itr, end(tanl));\n  bool ok = false;\n  for (ld t : tanl) {\n    ld a = (-4.9/(v*v))*(1+t*t);\n    ld b = t;\n    bool reachable = true;\n    for (auto p : lx) {\n      ld py, mnx, mxx;\n      tie(py,mnx,mxx) = p;\n      auto res = sq_eq(a,b,-py);\n      for (ld ans:res) {\n        if (mnx + eps< ans && ans + eps < mxx) {\n          reachable = false;\n          break;\n        }\n      }\n    }\n    for (auto p : ly) {\n      ld px, mny, mxy;\n      tie(px, mny, mxy) = p;\n      ld cy = a*px*px+b*px;\n      if (mny + eps < cy && cy + eps < mxy) {\n        reachable = false;\n        break;\n      }\n    }\n    if (reachable) {\n      ld cy = a*x*x+b*x;\n      if (y < cy + eps && cy < mn_oby_atx + eps) {\n        ok = true;\n        break;\n      }\n    }\n  }\n  if (ok)\n    cout << \"Yes\" << endl;\n  else\n    cout << \"No\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-8\nusing namespace std;\nconst int maxn = 100;\nint V,n,X,Y;\ndouble vx,vy;\ndouble g=9.8;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint cmp(double qx,double qy)\n{\n    double qyy=vy/vx*qx-0.5*g*(qx/vx)*(qx/vx);\n    if(fabs(qyy-qy)<eps) return 0;\n    return qyy<qy?1:-1;\n}\nbool f(double qx,double qy,int k,int o)\n{\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if(fabs(d)<eps) d=0;\n    if(d<0) return false;\n    for(int tmp=-1; tmp<=1; tmp+=2)\n    {\n        double t=(-b+tmp*sqrt(d))/(2*a);\n        if(t<=0) continue;\n        t=sqrt(t);\n        vx=qx/t;\n        if(vx==0) vx=0.000001;\n        vy=(qy+g*t*t/2)/t;\n        double qyy=vy/vx*X-0.5*g*(X/vx)*(X/vx);\n        if(qyy<Y-eps)\n        {\n            continue;\n        }\n        bool ok=true;\n        for(int i=0; i<n; i++)\n        {\n            if(L[i]>=X) continue;\n            if(R[i]>=X && Y<=T[i] && B[i]<=qyy) ok=false;\n            if(cmp(L[i],B[i])*cmp(L[i],T[i])<=0 || cmp(L[i],T[i])*cmp(R[i],T[i])<=0 || cmp(R[i],B[i])*cmp(R[i],T[i])<=0 || cmp(L[i],B[i])*cmp(R[i],B[i])<=0)\n            {\n                ok=false;\n            }\n            double tt=vy/g;\n            double xx=tt*vx;\n            double yy=vy*tt/2;\n            if(yy>B[i] && cmp(L[i],B[i])==1)\n            {\n                ok=false;\n            }\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main()\n{\n    cin>>n>>V>>X>>Y;\n    for(int i=0; i<n; i++) cin>>L[i]>>B[i]>>R[i]>>T[i];\n    for(int i=0;i<n;i++) R[i]=min(R[i],X);\n    bool ans = f(X,Y,-1,0);\n\n    for(int i=0; i<n; i++)\n    {\n        ans = ans || f(L[i],T[i],i,0) || f(R[i],T[i],i,1);\n    }\n    puts(ans?\"Yes\":\"No\");\n    return 0;\n}\n/*\n0 7 3 1\n\n1 7 3 1\n1 1 2 2\n\n1 7 2 2\n0 1 1 2\n1 1 2 2\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\n//ÀWiX,Y)ðÊéæ¤ÈtanÌlðßApush·é\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]<=X && X<=R[i])\n\t\t\tOB=min(OB,B[i]);\n\t\tL[i]=min(L[i],X);\n\t\tR[i]=min(R[i],X);\n\t}\n\t//^[QbgðÊéæ¤ÈtanÌlðßé\n\tadd(X,Y);\n\n\t//e¸_ðÆ¨éæ¤Ètanðßé\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t\tadd(L[i],B[i]);\n\t\tadd(R[i],B[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\t//^[QbgÌ^ãÉ½Æ«OBæèà¢A»à»àÍ©È¢ÍÌtanð·\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\t//eáQ¨ÆÕË»èð·é\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\t//XÀWªáQ¨ÌÍÍàÌÆ«ÌÅåÌ³AÅáÌá³ðßé\n\t\t\t//XÀWªáQ¨Ì¶[ÆE[ÌÆ«Ì³ðßé\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t//å«¢ûªMy\n\t\t\tif(my>My) swap(my,My);\n\t\t\t//¸_ªÜÜêéÆ«ÍA¸_ªÅåÌ³\n\t\t\tif(L[j]<center && center<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0*9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t\n\t\t\t//àµÔÂ©éÈçÌtanð·\n\t\t\tif(!(My<B[j]+eps || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//àµ`FbNðNAµ½tanª¶Ýµ½çYesðoÍµÄIíè\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb+eps ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) delta=0.0;\n  else if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++) ok|=Check(L[i],T[i]);\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-8\nusing namespace std;\nconst int maxn = 100;\nint V,n,X,Y;\ndouble vx,vy;\ndouble g=9.8;\nint L[maxn],B[maxn],R[maxn],T[maxn];\ndouble calc(double t)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double l,double h,double x)\n{\n    return x<l+eps?-1:x>h-eps?1:0;\n}\nbool f(double qx,double qy)\n{\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if(d<0 && d>-eps) d=0;\n    if(d<0) return false;\n    for(int tmp=-1; tmp<=1; tmp+=2)\n    {\n        double t=(-b+tmp*sqrt(d))/(2*a);\n        if(t<=0) continue;\n        t=sqrt(t);\n        vx=qx/t;\n        vy=(qy+g*t*t/2)/t;\n        double qyy=calc(X/vx);\n        if(qyy<Y-eps)\n        {\n            continue;\n        }\n        bool ok=true;\n        for(int i=0; i<n; i++)\n        {\n            if(L[i]>=X) continue;\n            if(R[i]<=X && Y<=T[i] && B[i]<=qyy) ok=false;\n            int yl=cmp(B[i],T[i],calc(L[i]/vx));\n            int yr=cmp(B[i],T[i],calc(R[i]/vx));\n            int xh=cmp(L[i],R[i],vx*vy/g);\n            int yh=cmp(B[i],T[i],calc(vy/g));\n\n            if(xh==0 && yh>=0 && yl<0) ok=false;\n            if(yl*yr<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main()\n{\n    cin>>n>>V>>X>>Y;\n    for(int i=0; i<n; i++) cin>>L[i]>>B[i]>>R[i]>>T[i];\n    for(int i=0;i<n;i++) R[i]=min(R[i],X);\n    bool ans = f(X,Y);\n\n    for(int i=0; i<n; i++)\n    {\n        ans |=f(L[i],T[i]);\n        ans |=f(R[i],T[i]);\n    }\n    puts(ans?\"Yes\":\"No\");\n    return 0;\n}\n/*\n0 7 3 1\n\n1 7 3 1\n1 1 2 2\n\n1 7 2 2\n0 1 1 2\n1 1 2 2\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 I : White Bird\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ndouble calc(double X, double Y, double V, double vy){\n\treturn 2*vy*sqrt(V*V-vy*vy)*X-9.8*X*X-2*Y*(V*V-vy*vy);\n}\n\nvoid getVy(vector<double> &vd, double X, double Y, double V){\n\tdouble L = 0, R = V;\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble midA = (2*L+R)/3;\n\t\tdouble midB = (L+2*R)/3;\n\t\tif(calc(X, Y, V, midA) < calc(X, Y, V, midB)) L = midA;\n\t\telse                                          R = midB;\n\t}\n\tif(calc(X, Y, V, 0.5*(L+R)) < EPS) return ;\n\tdouble vl = 0, vr = 0.5*(L+R);\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble mid = 0.5*(vl+vr);\n\t\tif(calc(X, Y, V, mid) < 0) vl = mid;\n\t\telse                       vr = mid;\n\t}\n\tvd.push_back(0.5*(vl+vr));\n\tvl = 0.5*(L+R), vr = V;\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble mid = 0.5*(vl+vr);\n\t\tif(calc(X, Y, V, mid) > 0) vl = mid;\n\t\telse                       vr = mid;\n\t}\n\tvd.push_back(0.5*(vl+vr));\n}\n\nint main(){\n\tint N, V, X, Y;\n\tint L[50], B[50], R[50], T[50];\n\twhile(cin >> N >> V >> X >> Y){\n\t\tvector<double> vd;\n\t\tgetVy(vd, X, Y, V);\n\t\tint low = Y, high = 1000000007;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> L[i] >> B[i] >> R[i] >> T[i];\n\t\t\tgetVy(vd, L[i], B[i], V);\n\t\t\tgetVy(vd, R[i], B[i], V);\n\t\t\tgetVy(vd, L[i], T[i], V);\n\t\t\tgetVy(vd, R[i], T[i], V);\n\t\t\tif(L[i]<=X&&X<=R[i]) high = min(high, B[i]);\n\t\t}\n\t\tbool clear = false;\n\t\tfor(int i=0;i<vd.size();i++){\n\t\t\tdouble vx = sqrt(V*V-vd[i]*vd[i]);\n\t\t\tdouble vy = vd[i];\n\t\t\tbool ok = true;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdouble my = vy*(L[j]/vx) - 4.9*(L[j]/vx)*(L[j]/vx);\n\t\t\t\tdouble My = vy*(R[j]/vx) - 4.9*(R[j]/vx)*(R[j]/vx);\n\t\t\t\tif(my > My) swap(my, My);\n\t\t\t\tif(min(My, (double)T[j]) - max(my, (double)B[j]) > EPS) ok = false;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tdouble y = vy*(X/vx) - 4.9*(X/vx)*(X/vx);\n\t\t\t\tif(low-EPS < y && y < high+EPS) clear = true;\n\t\t\t}\n\t\t}\n\t\tcout << (clear ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstatic const double EPS = 1e-10;\nstatic const int MAX_N = 50;\nstatic const double G = 9.8;\n\nint N;\ndouble V, X, Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nint cmp(double a, double b, double x) {\n  if (x < a + EPS) return -1;\n  if (x > b - EPS) return 1;\n  return 0;\n}\n\nbool check(double tx, double ty) {\n  double a = (1.0 / 4.0) * G * G;\n  double b = G * ty - V * V;\n  double c = tx * tx + ty * ty;\n\n  double D = b * b - 4.0 * a * c;\n  if (fabs(D) <= EPS) D = 0.0;\n  if (D < 0) return false;\n  for (int d = -1; d <= 1; d+=2) {\n    double t_squared = (-b + d * sqrt(D)) / (2.0 * a);\n    if (t_squared <= 0) continue;\n\n    // calc initial velocity to hit (tx, ty)\n    double t = sqrt(t_squared);\n    double vx = tx / t;\n    double vy = (ty + 0.5 * G * t * t) / t;\n\n    // check if the course is beyond pig\n    double pt = X / vx;\n    double py = vy * pt - 0.5 * G * pt * pt;\n    if (py < Y - EPS) continue;\n\n    // check if the course is clear\n    bool isClear = true;\n    for (int i = 0; i < N; i++) {\n      if (L[i] >= X) continue;\n      if (R[i] >= X && T[i] >= Y && B[i] <= py) {\n        isClear = false;\n        break;\n      }\n      double lt = L[i] / vx;\n      double ly = vy * lt - 0.5 * G * lt * lt;\n      double rt = R[i] / vx;\n      double ry = vy * rt - 0.5 * G * rt * rt;\n      int posL = cmp(B[i], T[i], ly);\n      int posR = cmp(B[i], T[i], ry);\n      if (posL * posR <= 0) {\n        isClear = false;\n        break;\n      }\n\n      double ht = vy / G;\n      int posX_high = cmp(L[i], R[i], vx * ht);\n      double hy = vy * ht - 0.5 * G * ht * ht;\n      int posH = cmp(B[i], T[i], hy);\n      if (posX_high == 0 && posH >= 0 && posL < 0) {\n        isClear = false;\n        break;\n      }\n    }\n    if (isClear) return true;\n  }\n  return false;\n}\n\nbool solve() {\n  if (check(X, Y)) return true;\n  for (int i = 0; i < N; i++) {\n    if (check(L[i], T[i]) || check(R[i], T[i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> V >> X >> Y;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n\n  bool isOK = solve();\n  cout << (isOK ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<utility>\n#include<sstream>\n#define mem0(x) memset(x,0,sizeof x)\n#define mem1(x) memset(x,-1,sizeof x)\n#define dbug cout<<\"here\"<<endl;\n//#define LOCAL\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e6+10;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nconst double g = 9.8;\n\nint N, V, X, Y;\nint L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble calc(double vy, double t){\t\t//?算以vy的速度?直向上射出t秒后的位置\n\treturn vy*t-g*t*t/2;\n}\n\nint cmp(double lb, double ub, double a){\t\t//a相?lb和ub的位置\n\treturn a<lb+EPS ? -1 : a>ub-EPS?1:0;\n}\n\nbool check(double qx, double qy){\t\t\t\t//判断当射出路径??点(qx, qy)?， 卵是否能?中猪\n\t//?初速度在x方向和y方向的分量分??vx和vy，?通?(qx,qy)的???t\n\t//求解?立方程式vx?+vy?=V?， vx*t = qx， vy*t-?gt?=qy\n\tdouble a = g*g/4;\n\tdouble b = g*qy - V*V;\n\tdouble c = qx*qx + qy*qy;\n\tdouble D = b*b - 4*a*c;\n\tif(D<0 && D>-EPS)\n\t\tD = 0;\n\tif(D < 0)\n\t\treturn false;\n\tfor(int d = -1; d <= 1; d += 2){\t\t\t//???立方程式的?个解的循?\n\t\tdouble t2 = (-b + d*sqrt(D)) / (2*a);\n\t\tif(t2 <= 0)\n\t\t\tcontinue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx/t;\n\t\tdouble vy = (qy+g*t*t/2) / t;\n\t\t//判断是否通?猪的正上方\n\t\tdouble yt = calc(vy, X/vx);\n\t\tif(yt < Y-EPS)\n\t\t\tcontinue;\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tif(L[i] >= X)\t\t\t\t\t//判断在猪正上方的?和猪之?是否有障碍物\n\t\t\t\tcontinue;\n\t\t\tif(R[i]==X && Y<=T[i] && B[i]<=yt)\t\t//判断在?到猪正上方之前是否会撞到障碍物\n\t\t\t\tok = false;\n\t\t\tint yL = cmp(B[i], T[i], calc(vy, L[i]/vx));\t//左?的相?位置\n\t\t\tint yR = cmp(B[i], T[i], calc(vy, R[i]/vx));\t//右?的相?位置\n\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g));\t\t\t//最高点的相?位置\n\t\t\tint yH = cmp(B[i], T[i], calc(vy, vy/g));\n\t\t\tif(xH==0 && yH>=0 && yL<0)\n\t\t\t\tok = false;\n\t\t\tif(yL*yR <= 0)\n\t\t\t\tok = false;\n\t\t}\n\t\tif(ok)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\t\t\t\t\t//截掉猪以右的障碍物\n\tfor(int i = 0; i < N; ++i){\n\t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\t\t\t//直接撞上猪的情况\n\tfor(int i = 0; i < N; ++i){\n\t\tok |= check(L[i], T[i]);\t\t//??左上角的情况\n\t\tok |= check(R[i], T[i]);\t\t//??右上角的情况\n\t}\n\tprintf(\"%s\\n\", ok? \"Yes\":\"No\");\n}\n\nint main(){\n\t#ifdef LOCAL\n\t\tfreopen(\"C:\\\\Users\\\\asus-z\\\\Desktop\\\\input.txt\",\"r\",stdin);\n\t\tfreopen(\"C:\\\\Users\\\\asus-z\\\\Desktop\\\\output.txt\",\"w\",stdout);\n\t#endif\n\twhile(scanf(\"%d%d%d%d\", &N, &V, &X, &Y) != EOF){\n\t\tmem0(L);\n\t\tmem0(B);\n\t\tmem0(R);\n\t\tmem0(T);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 55;\nconst double eps = 1e-8, inf = 1e10, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\nV Vec;\ndouble MaxAc;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n}\n\nvoid cal(double a, double b, double c, V &vec)\n{\n\tdouble delta = b*b - 4*a*c;\n\tif (dcmp(delta) <= 0)\n\t{\n\t\tif (dcmp(a) > 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, 1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\n\tdelta = sqrt(delta);\n\tdouble t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n\tif (dcmp(a) > 0)\n\t{\n\t\twhile (t1 < -inf);\n\t\twhile (t2 > inf);\n\t\tvec.push_back(make_pair(-inf, 1));\n\t\tvec.push_back(make_pair(t1, -1));\n\t\tvec.push_back(make_pair(t2, 1));\n\t\tvec.push_back(make_pair(inf, -1));\n\t}\n\telse\n\t{\n\t\tvec.push_back(make_pair(t1, 1));\n\t\tvec.push_back(make_pair(t2, -1));\n\t}\n}\n\nvoid add(double x1, double y1, double x2, double y2, int sign)\n{\n\tdouble a1 = -g*x1*x1/2/v/v, b1 = x1, c1 = -g*x1*x1/2/v/v - y1;\n\tdouble a2 = -g*x2*x2/2/v/v, b2 = x2, c2 = -g*x2*x2/2/v/v - y2;\n\n\tif (sign) a1 = -a1, a2 = -a2, b1 = -b1, b2 = -b2, c1 = -c1, c2 = -c2;\n\n\tV vec;\n\tcal(a1, b1, c1, vec);\n\tcal(a2, b2, c2, vec);\n\tsort(vec.begin(), vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\ttmp += vec[i].second;\n\t\tif (tmp == 2)\n\t\t{\n\t\t\tdouble t = vec[i].first;\n\t\t\tVec.push_back(make_pair(vec[i].first, 1));\n\t\t\tVec.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n}\n\nbool judge(double l1, double r1, double l2, double r2)\n{\n\tdouble l = max(l1, l2), r = min(r1, r2);\n\tif (dcmp(l - r) > 0)\n\t\treturn false;\n\n\treturn dcmp(r-Y) >= 0;\n}\n\nbool judge(double l, double r)\n{\n\tdouble a = -g*X*X/2/v/v, b = X, c = -g*X*X/2/v/v;\n\tdouble fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n\tdouble Min = min(fl, fr);\n\twhile (dcmp(l-r) < 0)\n\t{\n\t\tdouble m1 = l + (r-l) / 3, m2 = r - (r-l) / 3;\n\t\tdouble f1 = a*m1*m1 + b*m1 + c, f2 = a*m2*m2 + b*m2 + c;\n\t\tif (dcmp(f1-f2) < 0) l = m1; else r = m2;\n\t}\n\tdouble Max = a*l*l + b*l + c;\n\n\treturn dcmp(Y-Min) >= 0 && dcmp(Y-Max) <= 0 || dcmp(MaxAc-Min) >= 0 && dcmp(MaxAc-Max) <= 0;\n}\n\nbool solve()\n{\n\tif (!dcmp(v))\n\t\treturn false;\n\n\tVec.clear();\n\tdouble a = -g*X*X/2/v/v, b = X, c = -g*X*X/2/v/v - Y;\n\tMaxAc = inf;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp(x[i][0]-X) < 0)\n\t\t{\n\t\t\tx[i][1] = min(X, x[i][1]);\n\t\t\tadd(x[i][0], y[i][0], x[i][1], y[i][0], 1);\n\t\t\tadd(x[i][0], y[i][1], x[i][1], y[i][1], 0);\n\t\t}\n\t\tif (dcmp(x[i][0]-X) < 0 && dcmp(x[i][1]-X) > 0)\n\t\t{\n\t\t\tif (dcmp(y[i][0]-Y) <= 0 && dcmp(y[i][1]-Y) >= 0)\n\t\t\t\treturn false;\n\t\t\tif (dcmp(y[i][0]-Y) >= 0)\n\t\t\t\tMaxAc = min(MaxAc, y[i][0]);\n\t\t}\n\t}\n\n\tVec.push_back(make_pair(-inf, 0));\n\tVec.push_back(make_pair(inf, 0));\n\tsort(Vec.begin(), Vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < Vec.size(); i++)\n\t{\n\t\ttmp += Vec[i].second;\n\t\tif (tmp == n && judge(Vec[i].first, Vec[i+1].first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n\t{\n\t\tinit();\n\t\tputs(solve()? \"Yes\": \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nbool operator < (const P& a, const P& b) {\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0*(projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t//if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nconst double g = 9.8;\nint N, V, X, Y;\nint PL[50], PB[50], PR[50], PT[50];\n\ndouble calc(double vy, double t)\n{\n\treturn vy*t - g*t*t / 2;\n}\n\nint cmp(double lb, double ub, double a)\n{\n\treturn a<lb? -1 : a>ub? 1 : 0;\n}\n\nbool check(double qx, double qy)\n{\n\tdouble a = g*g / 4, b = g*qy - V*V, c = qx*qx + qy*qy;\n\tdouble D = b*b - 4 * a*c;\n\tif (D<0 && D>-EPS)D = 0;\n\tif (D < 0)return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d*sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0)continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx / t, vy = (qy + g*t*t / 2) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y - EPS)continue;\n\n\t\tbool ok = true;\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tif (PL[i] >= X)continue;\n\t\t\tif (PR[i] == X&&Y <= PT[i] && PB[i] <= yt)ok = false;\n\t\t\tint yL = cmp(PB[i], PT[i], calc(vy, PL[i] / vx));\n\t\t\tint yR = cmp(PB[i], PT[i], calc(vy, PR[i] / vx));\n\t\t\tint xH = cmp(PL[i], PR[i], vx*(vy / g));\n\t\t\tint yH = cmp(PB[i], PT[i], calc(vy, vy / g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0)ok = false;\n\t\t\tif (yL*yR <= 0)ok = false;\n\t\t}\n\t\tif (ok)return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> V >> X >> Y;\n\trep(i, 0, N)\n\t{\n\t\tcin >> PL[i] >> PB[i] >> PR[i] >> PT[i];\n\t\tchmin(PR[i], X);\n\t}\n\n\tbool ok = check(X, Y);\n\trep(i, 0, N)\n\t{\n\t\tok |= check(PL[i], PT[i]);\n\t\tok |= check(PR[i], PT[i]);\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\nbool ok[50]={};\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nbool on(double lb,double ub,double x){\n\treturn (lb+eps<x&&x+eps<ub);\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<l[i]||r[i]<x||u[i]<y) continue;\n\t\t\tif(d[i]<ry) ok=false;\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,2){\n\t\t\t\tdouble rx=(j==0 ? l[i] : r[i]);\n\t\t\t\t//vx=0\n\t\t\t\tdouble tt=rx/vx,ry=calcy(vy,tt);\n\t\t\t\tif(on(d[i],u[i],ry)) ok=false;\n\t\t\t}\n\t\t\trep(j,2){\n\t\t\t\tdouble ry=(j==0 ? d[i] : u[i]);\n\t\t\t\tdouble a=-g/2,b=vy,c=-ry,D=b*b-4*a*c;\n\t\t\t\t//show(a);\n\t\t\t\t//show(b);\n\t\t\t\t//show(c);\n\t\t\t\tfix(D);\n\t\t\t\t//show(D);\n\t\t\t\tif(D<0) continue;\n\t\t\t\tdouble si=-1;\n\t\t\t\trep(ss,2){\n\t\t\t\t\tsi*=-1;\n\t\t\t\t\tdouble tt=(-b+si*sqrt(D))/(2*a),rx=tt*vx;\n\t\t\t\t\t//show(rx);\n\t\t\t\t\tif(on(l[i],r[i],rx)) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\t//cout << vx << \" \" << vy << endl;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P; \n#define MAX_N 55\n#define EPS 1e-10\nconst double g=9.8;\nint N,V,X,Y;\nint L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calc(double vy,double t)\n{\n\treturn vy*t-g*t*t/2;\n}\n\ndouble cmp(double lb,double ub,double a)\n{\n\treturn a<lb+EPS?-1:a>ub-EPS?1:0;\n}\n\nbool check(double qx,double qy)\n{\n\tdouble a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(D<0&&D>-EPS)D=0;\n\tif(D<0)return false;\n\tfor(int d=-1;d<=1;d+=2)\n\t{\n\t\tdouble t2=(-b+d*sqrt(D))/(2*a);\n\t\tif(t2<=0)continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g*t*t/2)/t;\n\n\t\tdouble yt=calc(vy,X/vx);\n\t\tif(yt<Y-EPS)continue;\n\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(L[i]>=X)continue;\n\t\t\tif(R[i]==X&&Y<T[i]&&B[i]<=yt)ok=false;\n\t\t\tint yL=cmp(B[i],T[i],calc(vy,L[i]/vx));\n\t\t\tint yR=cmp(B[i],T[i],calc(vy,R[i]/vx));\n\t\t\tint xH=cmp(L[i],R[i],vx*(vy/g));\n\t\t\tint yH=cmp(B[i],T[i],calc(vy,vy/g));\n\t\t\tif(yL*yR<=0)ok=false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(R[i],X);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n}\n\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tsolve();\n\n}"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 I : White Bird\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint main(){\n\tint N, V, X, Y;\n\tint L[50], B[50], R[50], T[50];\n\twhile(cin >> N >> V >> X >> Y){\n\t\tvector<double> vd;\n\t\tint low = Y, high = 1000000007;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> L[i] >> B[i] >> R[i] >> T[i];\n\t\t\tL[i] = min(L[i], X);\n\t\t\tR[i] = min(R[i], X);\n\t\t\tif(L[i]<=X&&X<=R[i]&&B[i]>=high) high = min(high, B[i]);\n\t\t}\n\t\tbool clear = false;\n\t\tfor(int i=1;i<900000;i++){\n\t\t\tdouble angle = (double)i/10000/180*acos(-1);\n\t\t\tdouble vx = V*cos(angle);\n\t\t\tdouble vy = V*sin(angle);\n\t\t\tbool ok = true;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdouble my = vy*(L[j]/vx) - 4.9*(L[j]/vx)*(L[j]/vx);\n\t\t\t\tdouble My = vy*(R[j]/vx) - 4.9*(R[j]/vx)*(R[j]/vx);\n\t\t\t\tif(my > My) swap(my, My);\n\t\t\t\tif(L[j]+EPS < vx*vy/9.8 && vx*vy/9.8 < R[j]-EPS)\n\t\t\t\t\tMy = vy*(vy/9.8) - 4.9*(vy/9.8)*(vy/9.8);\n\t\t\t\tif(min(My, (double)T[j]) - max(my, (double)B[j]) > EPS) ok = false;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tdouble y = vy*(X/vx) - 4.9*(X/vx)*(X/vx);\n\t\t\tif(low-EPS < y && y < high+EPS) clear = true;\t\t\t\n\t\t}\n\t\tcout << (clear ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb ? -1 : a>ub ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) delta=0.0;\n  else if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#define eps 1.0e-9\nusing namespace std;\nconst double g=9.8;\nint n;\ndouble v,X,Y,L[55],B[55],R[55],T[55];\nint sgn(double f)\n{\n    if(fabs(f)<eps) return 0;\n    else return f<0?-1:1;\n}\nbool cal(double v,double t)\n{\n    return v*t-g*t*t/2;\n}\nint isin(double l,double r,double x)\n{\n    if(sgn(x-l)<0) return -1;\n    if(sgn(x-r)>0) return 1;\n    return 0;\n}\nbool check(double tx,double ty,double t)\n{\n    double vx=tx/t,vy=(ty+g*t*t/2)/t,yt=cal(vy,X/vx);\n    if(sgn(yt-Y)<0) return false;\n    for(int i=0;i<n;++i)\n    {\n        if(sgn(L[i]-X)>=0) continue;\n        if(sgn(R[i]-X)==0&&sgn(Y-T[i])<=0&&sgn(yt-B[i])>=0) return false;\n        int y1,y2;\n        y1=isin(B[i],T[i],cal(vy,L[i]/vx));\n        y2=isin(B[i],T[i],cal(vy,L[i]/vx));\n        if(y1*y2<=0) return false;\n        int y3,x1;\n        y3=isin(B[i],T[i],cal(vy,vy/g));\n        x1=isin(L[i],R[i],vx*vy/g);\n        if(x1==0&&y3>=0&&y1<0) return false;\n    }\n    return true;\n}\nbool solve(double tx,double ty)\n{\n    double a=g*g/4,b=g*ty-v*v,c=tx*tx+ty*ty;\n    double delt=b*b-4*a*c;\n    if(sgn(delt)<0) return false;\n    if(sgn(delt)==0) delt=0;\n    else delt=sqrt(delt);\n    double t=(-b+sqrt(delt))/(2*a);\n    if(sgn(t)>0&&check(tx,ty,t)) return true;\n    t=(-b-sqrt(delt))/(2*a);\n    if(sgn(t)>0&&check(tx,ty,t)) return true;\n    return false;\n}\nint main()\n{\n    scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n    for(int i=0;i<n;++i)\n    {\n        scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        R[i]=min(X,R[i]);\n    }\n    bool ok=false;\n    if(solve(X,Y)) ok=true;\n    for(int i=0;i<n;++i)\n    {\n        if(solve(L[i],T[i])) ok=true;\n        if(solve(R[i],T[i])) ok=true;\n    }\n    if(ok) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double g = 9.8;\nconst double eps = 1e-8;\n\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : (a > ub - eps ? 1 : 0);\n}\n\nint main() {\n    int n, v, x, y; cin >> n >> v >> x >> y;\n    vector<int> l(n), B(n), r(n), t(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> l[i] >> B[i] >> r[i] >> t[i];\n        r[i] = min(x, r[i]);\n    }\n\n    // tx, ty を通るように打ち出してぶつけられるか\n    auto check = [&] (double tx, double ty) {\n        const double a = g * g / 4,\n                     b = g * ty - v * v,\n                     c = tx * tx + ty * ty;\n        double D = b * b - 4 * a * c;\n        if(D < 0 && D > -eps) D = 0;\n        if(D < 0) return false;\n        for(int d = -1; d <= 1; d += 2) {\n            const double t2 = (-b + d * sqrt(D)) / (2 * a);\n            if(t2 <= 0) continue;\n            const double tt = sqrt(t2);\n            const double vx = tx / tt, vy = (ty + g * tt * tt / 2) / tt;\n            const double yt = calc(vy, x / vx);\n            if(yt < y - eps) continue;\n\n            bool ok = true;\n            for(int i = 0; i < n; ++i) {\n                if(l[i] >= x) continue;\n                if(r[i] == x && y <= t[i] && B[i] <= yt) ok = false;\n                const int yl = cmp(B[i], t[i], calc(vy, l[i] / vx));\n                const int yr = cmp(B[i], t[i], calc(vy, r[i] / vx));\n                const int xh = cmp(l[i], r[i], vx * (vy / g));\n                const int yh = cmp(B[i], t[i], calc(vy, vy / g));\n                if(xh == 0 && yh >= 0 && yl < 0) ok = false;\n                if(yl * yr <= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    };\n\n    bool ok = check(x, y);\n    for(int i = 0; i < n; ++i) {\n        ok |= check(l[i], t[i]);\n        ok |= check(r[i], t[i]);\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if(l<=X){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {cout <<\"todokanai\"<<endl;return -1;}\n  else {cout << rs1 << \" \" <<rs2<<endl; return rs1 * rs2;}\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(T[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X == bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, vx* vy / g);\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tr = min(r, X);\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g*y-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y || gy > f) return false;\n    const double tt = vy/g, tx = vx*tt, ty = yof(vy, tt);\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]-EPS<l && l<T[i]+EPS) return false;\n        if(B[i]-EPS<r && r<T[i]+EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS) {\n            if(L[i]-EPS<tx && tx<R[i]+EPS && ty>B[i]-EPS) return false;\n        }\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]-EPS < m && m < T[i]+EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    const double pi = atan2(0.0, -1.0);\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i] && T[i]>=Y) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) {\n        rep(i, 7) {\n            const P p(vs[k]*P(cos((i-3)/180*pi), sin((i-3)/180)*pi));\n            if(can(real(p), imag(p))) ans = true;\n        }\n    }\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-7;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n\n  if( vy < eps ) return false;\n  \n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = vy / g;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt ,vy);\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n\n    if( ft<= zt && zt <= st ){\n      if( check( B[i], T[i], fh, zh ) )return false;\n      if( check( B[i], T[i], zh, sh ) )return false;\n    }\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < 0 )return false;\n  if( abs(A) < eps ) return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n\n  if( V < eps ){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  \n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n    if( X+1.0<R[i])R[i]=X+1.0;\n    if( X+1.0<L[i])L[i]=X+1.0;\n  }\n  \n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n    if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAX_N = 55;\nconst double EPS=1e-10;\nconst double g=9.8;\nint N,V,X,Y;\nint L[MAX_N],B[MAX_N],T[MAX_N],R[MAX_N];\ndouble height(double vy, double t) {\n    return vy*t-g*t*t/2;\n}\nint cmp(double lb,double ub,double a) {\n    return a<lb+EPS?-1:a>ub-EPS?1:0;\n}\nbool check(double x,double y) {\n    // ??????\n    double a=g*g/4,b=y*g-V*V,c=x*x+y*y,vx,vy,t,t2,yt;\n    double det=b*b-4*a*c;\n    if(det>-EPS&&det<0) det=0;\n    if(det<0) return false;\n    for(int d=-1;d<=1;d+=2) {\n        t2=(-b+d*sqrt(det))/(2*a);\n        if(t2<=0) continue;\n        t=sqrt(t2);\n        vx=x/t;vy=(y+g*t*t/2)/t;\n        yt=height(vy,X/vx);\n        if(yt<Y-EPS) continue;\n\n        bool ok=true;\n        for(int i=0;i<N;i++) {\n            if(L[i]>=X) continue;\n            if(R[i]>X&&Y<=T[i]&&yt>=B[i]) ok=false;\n            int yL=cmp(B[i],T[i],height(vy,L[i]/vx));\n            int yR=cmp(B[i],T[i],height(vy,R[i]/vx));\n            int xH=cmp(L[i],R[i],vx*(vy/g));\n            int yH=cmp(B[i],T[i],height(vy,vy/g));\n            if(xH==0&&yH>=0&&yL<0) ok=false;\n            if(yL*yR<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main() {\n    scanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d%d%d%d\",L+i,B+i,R+i,T+i);\n    }\n    bool ok=check(X,Y);\n    for(int i=0;i<N;i++) {\n        ok|=check(L[i],T[i]);\n        ok|=check(R[i],T[i]);\n    }\n    printf(\"%s\\n\",ok?\"Yes\":\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-7;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0; rad <= M_PI / 2.0; rad += 0.0000001){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(!((double)gy - EPS <= y && y <= (double)gy + EPS)){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(y1 < 0 || y2 < 0){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y1 + EPS\n             || (double)obstacles[i].top_y < y1 - EPS)){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y2 + EPS\n             || (double)obstacles[i].top_y < y2 - EPS)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nconst double G = 9.8;\nint N,V,X,Y;\nvector<int> L(N),B(N),R(N),T(N);\nld calcv(ld vy,ld t){\n  return vy*t-G*t*t/2;\n}\n\nint cmp(ld lb,ld ub,ld a){\n  return a< lb+eps ? -1 : a>ub-eps ? 1 :0;\n}\nbool check(ld qX,ld qY){\n  //solve g^2/4*t^4 + (g*qY-V)*t^2 + (qX^2+qY^2) = 0;\n  ld a = G*G/4; ld b = G*qY-V*V; ld c = qX*qX+qY*qY;\n  ld D = b*b-4*a*c;\n  //cout << D << endl;\n  if((D<0)&&(D>-eps)) D=0;\n  if(D<0) return false;\n  for(int k=-1;k<=1;k+=2){\n    //find t\n    ld t2 = -1*b+k*sqrt(D)/(2*a);\n    if(t2<=0) continue;\n    ld t = sqrt(t2);\n    ld vx = qX/t; ld vy = (qY+G*t*t/2)/t;\n\n    //can reach Y?\n    double reachy = calcv(vy,X/vx);\n    if(reachy<Y-eps) return false;\n\n    bool ok = true;\n    //find colision\n    REP(i,N){\n      if(L[i] >= X) continue;//ignore\n      if(R[i]==X && Y<=T[i] && B[i]<=reachy) ok = false;\n      //cout << vx << \" : \" << vy << endl;\n      int yL = cmp(B[i],T[i],calcv(vy,L[i]/vx));\n      int yR = cmp(B[i],T[i],calcv(vy,R[i]/vx));\n      int xH = cmp(L[i],R[i],vx*(vy/G));\n      int yH = cmp(B[i],T[i],calcv(vy,vy/G));\n      if(xH==0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  } \n  return false;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  REP(i,N){\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    L.push_back(a); B.push_back(b); R.push_back(c); T.push_back(d);\n    //cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n    R[i] = min(R[i],X);\n  }\n  bool ok = check(X,Y);\n  REP(i,N){\n    ok |= check(L[i],T[i]);\n    ok |= check(R[i],T[i]);\n  }\n  cout << (ok ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/10/22 17:01:43\n * File Name: I.cpp\n */\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nint n;\ndouble v, X, Y, L[64], R[64], B[64], T[64], vx, vy;\n\nbool solve();\nbool check();\ndouble get_y(double x);\n\nint main() {\n    while (solve());\n    return 0;\n}\n\nbool solve() {\n    if (scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y) == EOF)\n        return false;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n        if (L[i] > R[i])\n            swap(L[i], R[i]);\n        if (B[i] > T[i])\n            swap(B[i], T[i]);\n    }\n    double step = 0.0001;\n    for (vx = step; vx <= v; vx += step) {\n        vy = sqrt(v * v - vx * vx);\n        if (check()) {\n            //printf(\"-- %lf %lf\\n\", vx, vy);\n            puts(\"Yes\");\n            return true;\n        }\n    }\n    puts(\"No\");\n    return true;\n}\n\nbool check() {\n    double bx = X, by = get_y(X);\n    if (by < Y)\n        return false;\n    for (int i = 0; i < n; ++i) {\n        if (L[i] < X) {\n            double l = L[i], r = min(X, R[i]);\n            double y1 = get_y(l), y2 = get_y(r);\n            //printf(\"-- %lf %lf %lf %lf\\n\", l, y1, r, y2);\n            if (y1 >= B[i] && y1 <= T[i])\n                return false;\n            if (y2 >= B[i] && y2 <= T[i])\n                return false;\n            if (y1 <= B[i] && y2 >= B[i])\n                return false;\n            if (y1 >= B[i] && y2 <= B[i])\n                return false;\n            if (y1 <= T[i] && y2 >= T[i])\n                return false;\n            if (y1 >= T[i] && y2 <= T[i])\n                return false;\n        }\n        if (L[i] <= bx && R[i] >= bx) {\n            if (B[i] <= Y && T[i] >= Y)\n                return false;\n            if (B[i] >= Y && B[i] <= by)\n                return false;\n        }\n    }\n    return true;\n}\n\ndouble get_y(double x) {\n    double t = x / vx;\n    return vy * t - 0.5 * 9.8 * t * t;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            // テ」ツδ禿」ツつーテ」ツ?ォテ・ツ債オテ」ツ?古・ツスツ禿」ツ?淌」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                if(x1[i] < gx && gx < x2[i] && fh > y1[i] && y1[i] >= gy) {\n                    ok = false;\n                }\n            }\n            // テ」ツδ氾」ツつーテ」ツ?ョテ、ツクツ甘ァツゥツコテ」ツ?セテ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                double h1 = calc_y(vx, vy, x1[i]);\n                double h2 = calc_y(vx, vy, x2[i]);\n                double h_min = min(h1, h2);\n                double h_max = max(h1, h2);\n                if(x1[i] < vx * vy / g && vx * vy / g < x2[i]) h_max = max(h_max, calc_y(vx, vy, vx * vy / g));\n                if(sign(y1[i] - h_min) > 0 && sign(h_max - y1[i])) ok = false;\n                if(sign(y2[i] - h_min) > 0 && sign(h_max - y2[i])) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nconst double G = 9.8;\nint N,V,X,Y;\nvector<int> L(N),B(N),R(N),T(N);\nld calcv(ld vy,ld t){\n  return vy*t-G*t*t/2;\n}\n\nint cmp(ld lb,ld ub,ld a){\n  return a< lb+eps ? -1 : a>ub-eps ? 1 :0;\n}\nbool check(ld qX,ld qY){\n  //solve g^2/4*t^4 + (g*qY-V)*t^2 + (qX^2+qY^2) = 0;\n  ld a = G*G/4; ld b = G*qY-V*V; ld c = qX*qX+qY*qY;\n  ld D = b*b-4*a*c;\n  //cout << D << endl;\n  if((D<0)&&(D>-eps)) D=0;\n  if(D<0) return false;\n  for(int k=-1;k<=1;k+=2){\n    //find t\n    ld t2 = (-1*b+k*sqrt(D))/(2*a);\n    if(t2<=0) continue;\n    ld t = sqrt(t2);\n    ld vx = qX/t; ld vy = (qY+G*t*t/2)/t;\n\n    //can reach Y?\n    double reachy = calcv(vy,X/vx);\n    if(reachy<Y-eps) return false;\n\n    bool ok = true;\n    //find colision\n    REP(i,N){\n      if(L[i] >= X) continue;//ignore\n      if(R[i]==X && Y<=T[i] && B[i]<=reachy) ok = false;\n      //cout << vx << \" : \" << vy << endl;\n      int yL = cmp(B[i],T[i],calcv(vy,L[i]/vx));\n      int yR = cmp(B[i],T[i],calcv(vy,R[i]/vx));\n      int xH = cmp(L[i],R[i],vx*(vy/G));\n      int yH = cmp(B[i],T[i],calcv(vy,vy/G));\n      if(xH==0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  } \n  return false;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  REP(i,N){\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    L.push_back(a); B.push_back(b); R.push_back(c); T.push_back(d);\n    //cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n    R[i] = min(R[i],X);\n  }\n  bool ok = check(X,Y);\n  REP(i,N){\n    ok |= check(L[i],T[i]);\n    ok |= check(R[i],T[i]);\n  }\n  cout << (ok ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nbool operator < (const P& a, const P& b) {\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0*(projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t//if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nconst double g = 9.8;\nint N, V, X, Y;\nint PL[50], PB[50], PR[50], PT[50];\n\ndouble calc(double vy, double t)\n{\n\treturn vy*t - g*t*t / 2;\n}\n\nint cmp(double lb, double ub, double a)\n{\n\treturn a<lb + EPS ? -1 : a>ub - EPS ? 1 : 0;\n}\n\nbool check(double qx, double qy)\n{\n\tdouble a = g*g / 4, b = g*qy - V*V, c = qx*qx + qy*qy;\n\tdouble D = b*b - 4 * a*c;\n\tif (D<0 && D>-EPS)D = 0;\n\tif (D < 0)return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d*sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0)continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx / t, vy = (qy + g*t*t / 2) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y - EPS)continue;\n\n\t\tbool ok = true;\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tif (PL[i] >= X)continue;\n\t\t\tif (PR[i] == X&&Y <= PT[i] && PB[i] <= yt)ok = false;\n\t\t\tint yL = cmp(PB[i], PT[i], calc(vy, PL[i] / vx));\n\t\t\tint yR = cmp(PB[i], PT[i], calc(vy, PR[i] / vx));\n\t\t\tint xH = cmp(PL[i], PR[i], vx*(vy / g));\n\t\t\tint yH = cmp(PB[i], PT[i], calc(vy, vy / g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0)ok = false;\n\t\t\tif (yL*yR <= 0)ok = false;\n\t\t}\n\t\tif (ok)return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> V >> X >> Y;\n\trep(i, 0, N)\n\t{\n\t\tcin >> PL[i] >> PB[i] >> PR[i] >> PT[i];\n\t\tchmin(PR[i], X);\n\t}\n\n\tbool ok = check(X, Y);\n\trep(i, 0, N)\n\t{\n\t\tok |= check(PL[i], PT[i]);\n\t\tok |= check(PR[i], PT[i]);\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 4.9;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * (1+tanv * tanv);\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\tdouble hy = 1e9;\n\tvector<double> uxtmp;\n\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) and b.p1.y() > Y ){\n\t\t\thy = min(hy,b.p1.y());\n\t\t}\n\t}\n\tfor( auto b : box ){\n\t\tdouble x = b.p1.x();\n\t\tuxtmp.push_back(x);\n\t\tdouble y = f(x);\n\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble x = b.p2.x();\n\t\tdouble y = f(x);\n\t\tuxtmp.push_back(x);\n\t\tif( inner(b.p2.y(),y,b.p3.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble y = b.p1.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\t\tdouble y = b.p3.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\t\t\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) ){\n\t\t\tif( inner(b.p1.y(),Y,b.p4.y()) ){\n\t\t\t\thx = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\t\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << f(1) << endl;\n\t//cout << hy << endl;\n\t//cout << V << \" \" << tanv << \" \" << a << \" \" << b << \" \" << X << \" \" << f(X)  << endl;\n\tif( hx + EPS > X ){\n\t\t//cout << f(X) << \" \" << Y - EPS << endl;\n\t\tif( f(X) > Y - EPS and f(X) < hy - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t//cout << atan(tanv) << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\tps.push_back(a);\n\t\tps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(b);\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < 3000 ; i++){\n\t\ttrying(0.001*i);\n\t}\n\tif(true){\n\t\tdouble x = X;\n\t\tdouble y = Y;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\t\t//cout << a << \" \" << b << \" \" << c << \" ( \" << g << \" \" << V << \" \" << x << endl;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\t\n\t\t}else{\n\t\t\tD = max(0.0,D);\n\t\t\tD = sqrt(D);\n\t\t\tdouble t1 = (-b+D)/(2*a);\n\t\t\tdouble t2 = (-b-D)/(2*a);\n\t\t\ttrying(t1);\n\t\t\ttrying(t2);\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\t\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int MAXN=57;\nconst double EPS=1e-7;\nconst double g=9.8;\n\ndouble cmp(double a,double b)\n{\n\tif (abs(a-b)<EPS)\n\t{\n\t\treturn 0;\n\t}\n\treturn a-b;\n}\n\ndouble add(double a,double b)//用在向量叉?点?上的?数加法，修正0的偏差\n{\n\tif (abs(a+b)<EPS*(abs(a)+abs(b)))\n\t{\n\t\treturn 0;\n\t}\n\treturn a+b;\n}\n\nstruct Point//??是向量,不?也可以当点用\n{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint(const Point &p):x(p.x),y(p.y){}\n\tPoint operator +(Point p)\n\t{\n\t\treturn Point(add(x,p.x),add(y,p.y));\n\t}\n\tPoint operator -(Point p)\n\t{\n\t\treturn Point(add(x,-p.x),add(y,-p.y));\n\t}\n\tPoint operator *(double d)\n\t{\n\t\treturn Point(x*d,y*d);\n\t}\n\tdouble dot(Point p) // 内? 点乘\n\t{\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(Point p) // 外? 叉乘\n\t{\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble distance(Point p)\n\t{\n\t\treturn sqrt(add((x-p.x)*(x-p.x),(y-p.y)*(y-p.y)));\n\t}\n\tfriend ostream& operator <<(ostream &os, const Point &p)\n\t{\n\t\tos<<p.x<<\" \"<<p.y;\n\t\treturn os;\n\t}\n\tfriend istream& operator >>(istream &is, Point &p)\n\t{\n\t\tis>>p.x>>p.y;\n\t\treturn is;\n\t}\n};\n\nstruct Rectangle\n{\n\tPoint s,t;//s:left bottom t:right top\n\tRectangle(){}\n\tRectangle(double sx,double sy,double tx,double ty):s(sx,sy),t(tx,ty){}\n\tRectangle(Point &s,Point &t):s(s),t(t){}\n\tRectangle(const Rectangle &p):s(p.s),t(p.t){}\n\tdouble left()\n\t{\n\t\treturn s.x;\n\t}\n\tdouble right()\n\t{\n\t\treturn t.x;\n\t}\n\tdouble bottom()\n\t{\n\t\treturn s.y;\n\t}\n\tdouble top()\n\t{\n\t\treturn t.y;\n\t}\n\tPoint leftBottom()\n\t{\n\t\treturn s;\n\t}\n\tPoint leftTop()\n\t{\n\t\treturn Point(s.x,t.y);\n\t}\n\tPoint rightBottom()\n\t{\n\t\treturn Point(t.x,s.y);\n\t}\n\tPoint rightTop()\n\t{\n\t\treturn t;\n\t}\n\tfriend ostream& operator <<(ostream &os, const Rectangle &p)\n\t{\n\t\tos<<p.s<<\" \"<<p.t;\n\t\treturn os;\n\t}\n\tfriend istream& operator >>(istream &is, Rectangle &p)\n\t{\n\t\tis>>p.s>>p.t;\n\t\treturn is;\n\t}\n};\n\n\nint i,j,k,n,m;\ndouble x,y,v,vx,vy,t,tt;\nbool f;\nPoint pig;\nRectangle obs[MAXN];\n\nbool nonAbove(const Point &p)\n{\n\tint i;\n\tdouble t,ty;\n\tt=p.x/vx;\n\tty=vy*t-g*t*t/2;\n\tif (cmp(ty,p.y)>=0)\n\t{\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tif (cmp(obs[i].left(),p.x)<=0 && cmp(obs[i].right(),p.x)>=0 && (cmp(obs[i].top(),p.y)>=0 && cmp(obs[i].top(),ty)<=0 || cmp(obs[i].bottom(),p.y)>=0 && cmp(obs[i].bottom(),ty)<=0))\n\t\t\t{\n\t\t\t\t// cout<<\"here obs[\"<<i<<\"]\"<<endl;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// cout<<ty<<\"<\"<<p.y<<endl;\n\t\treturn false;\n\t}\n\t// cout<<\"nonAbove!\"<<endl;\n\treturn true;\n}\n\nbool nonBetween(const Point &p)\n{\n\tint i;\n\tdouble tl,tr,tyl,tyr,tx,ty;\n\ttx=vx*vy/g;\n\tty=vy*vy/g/2;\n\tfor (i=0;i<n;i++)\n\t{\n\t\tif (cmp(obs[i].left(),p.x)>0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\ttl=obs[i].left()/vx;\n\t\ttyl=vy*tl-g*tl*tl/2;\n\t\ttr=obs[i].right()/vx;\n\t\ttyr=vy*tr-g*tr*tr/2;\n\t\tif (cmp(obs[i].top(),tyl)<0 && cmp(obs[i].top(),tyr)<0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (cmp(obs[i].bottom(),tyl)>0 && cmp(obs[i].bottom(),tyr)>0 && (cmp(obs[i].left(),tx)>0 || cmp(obs[i].right(),tx)<0) || cmp(obs[i].bottom(),ty)>0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\t// cout<<\"nonBetween!\"<<endl;\n\treturn true;\n}\n\nbool checkOK(const Point &p)\n{\n\tdouble a,b,c,dt,sdt;\n\ta=g*g/4;\n\tb=p.y*g-v*v;\n\tc=p.x*p.x+p.y*p.y;\n\tdt=b*b-4*a*c;\n\t// cout<<\"p=\"<<p<<\" v=\"<<v<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<dt<<endl;\n\tif (dt<0)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tsdt=sqrt(dt);\n\n\t\ttt=(-b+sdt)/a/2;\n\t\tif (tt>0)\n\t\t{\n\t\t\tt=sqrt(tt);\n\t\t\tvx=p.x/t;\n\t\t\tvy=(p.y+g*tt/2)/t;\n\t\t\t// cout<<p<<\" \"<<vx<<\" \"<<vy<<endl;\n\t\t\tif (nonAbove(pig) && nonBetween(pig))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\ttt=(-b-sdt)/a/2;\n\t\tif (tt>0)\n\t\t{\n\t\t\tt=sqrt(tt);\n\t\t\tvx=p.x/t;\n\t\t\tvy=(y+g*tt/2)/t;\n\t\t\t// cout<<p<<\" \"<<vx<<\" \"<<vy<<endl;\n\t\t\tif (nonAbove(pig) && nonBetween(pig))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin>>n>>v>>pig)\n\t{\n\t\tf=false;\n\t\tmemset(obs,0,sizeof(obs));\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>obs[i];\n\t\t}\n\n\t\tif (checkOK(pig))\n\t\t{\n\t\t\tf=true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif (checkOK(obs[i].leftTop()))\n\t\t\t\t{\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (checkOK(obs[i].rightTop()))\n\t\t\t\t{\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (f)\n\t\t{\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <stack>\n#include <bitset>\n#define INF 1000000005\n#define eps 1e-10\n#define PI acos(-1.0)\n#define K (0.017453292519943295769236907684886l)\n\nusing namespace std;\n\nconst int maxn = 55;\nconst double gav = 9.8;\n\nint n, v, x, y;\n\nint L[maxn], B[maxn], R[maxn], T[maxn];\n\nint Can(double vx, double vy)\n{\n    double t, py, cy, cx;\n    t = x / vx; py = vy * t - gav * t * t / 2;\n    t = vy / gav; cy = vy * t - gav * t * t / 2; cx = vx * t;\n    if (vy < y) return 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (L[i] > x) continue;\n        t = L[i] / x; double pyl = vy * t - gav * t * t / 2;\n        if (pyl < T[i] && pyl > B[i]) return 0;\n        if (R[i] > x) continue;\n        t = R[i] / x; double pyr = vy * t - gav * t * t / 2;\n        if (pyr < T[i] && pyr > B[i]) return 0;\n        if (cx < L[i] || fabs(cx - L[i]) < eps)\n        {\n            if ((pyl > T[i] || fabs(pyl - T[i])) && pyr < B[i]) return 0;\n        }\n        if (cy > B[i] && cy < T[i]) return 0;\n        if (cx > L[i] && cx < R[i])\n        {\n            if (cy > T[i] || fabs(cy - T[i]) < eps)\n            {\n                if (pyl < T[i] || pyr < T[i]) return 0;\n            }\n        }\n        if (cx > R[i] || fabs(cx - R[i]) < eps)\n        {\n            if ((pyr > T[i] || fabs(pyr - T[i])) && pyl < B[i]) return 0;\n        }\n    }\n    return 1;\n}\n\nint Check(int px, int py)\n{\n    double A = gav * gav / 4, B = py * gav - v * v, C = px * px + py * py;\n    double tp = B * B - 4 * A * C;\n    if (fabs(tp) < eps || tp > 0)\n    {\n        double t2 = (-B + sqrt(tp)) / (2 * A);\n        if (t2 > 0)\n        {\n            double t = sqrt(t2);\n            double vx = px / t, vy = (py + gav * t * t / 2) / t;\n            if (vx < v)\n            {\n                if (Can(vx, vy)) return 1;\n            }\n        }\n        t2 = (-B - sqrt(tp)) / (2 * A);\n        if (t2 > 0)\n        {\n            double t = sqrt(t2);\n            double vx = px / t, vy = (py + gav * t * t / 2) / t;\n            if (vx < v)\n            {\n                if (Can(vx, vy)) return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d%d\", &n, &v, &x, &y))\n    {\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n        int tag = Check(x, y);\n        for (int i = 1; i <= n; i++)\n        {\n            if (tag) break;\n            if (L[i] > x) continue;\n            if (Check(L[i], T[i])) tag = 1;\n            if (Check(R[i], T[i])) tag = 1;\n            if (Check(L[i], B[i])) tag = 1;\n            if (Check(R[i], B[i])) tag = 1;\n        }\n        if (tag) printf(\"Yes\\n\"); else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    if(yof(vy, X/vx) < Y-EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS && yof(vy, vy/g)>B[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\n#define int_ int64_t\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=55;\nconst db G=9.8;\nconst db eps=1e-10;\n\nint n,v,x,y;\nint l[N],b[N],r[N],t[N];\n\ndb calc(db vy,db t) {\n    return vy*t-0.5*G*t*t;\n}\n\nint cmp(db lb,db rb,db val) {\n    return val<lb+eps?-1:val>rb-eps?1:0;\n}\n\nbool ok(int qx,int qy) {\n    db a=0.25*G*G,b_=G*qy-v*v,c=qx*qx+qy*qy;\n    db Delta=b_*b_-4*a*c;\n    if (Delta<0) return false;\n    for (int i=-1;i<=1;i+=2) {\n        db t2=(-b_+i*sqrt(Delta))/(2*a);\n        if (t2<0) continue;\n        db t1=sqrt(t2);\n        db vx=qx/t1;\n        db vy=qy/t1+0.5*G*t1;\n        db yt=calc(vy,x/vx);\n        if (yt<y-eps) continue;\n        bool ok=true;\n        for (int i=1;i<=n;i++) {\n            if (l[i]>=x) continue;\n            if (r[i]==x&&y<=t[i]&&yt>=b[i]) ok=false;\n            int yL=cmp(b[i],t[i],calc(vy,l[i]/vx));\n            int yR=cmp(b[i],t[i],calc(vy,r[i]/vx));\n            int xT=cmp(l[i],r[i],vx*(vy/G));\n            int yT=cmp(b[i],t[i],calc(vy,vy/G));\n            if (xT==0&&yT>=0&&yL<0) ok=false;\n            if (yL*yR<=0) ok=false;\n        }\n        if (ok) { return true; }\n    }\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\",&n,&v,&x,&y);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%d%d\",l+i,b+i,r+i,t+i);\n        r[i]=min(r[i],x);\n    }\n    bool ans=ok(x,y);\n    for (int i=1;i<=n;i++) {\n        if (ok(l[i],t[i])||ok(r[i],t[i])) {\n            ans=true;\n            break;\n        }\n    }\n    if (ans) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//head                \n#include <cstdlib>    \n#include <cstring>    \n#include <memory>     \n#include <cstdio>     \n#include <fstream>    \n#include <iostream>   \n#include <cmath>      \n#include <string>     \n#include <sstream>    \n#include <stack>      \n#include <queue>      \n#include <vector>     \n#include <set>        \n#include <map>        \n#include <algorithm>  \n#include <deque>      \n#include <list>       \n#include <climits>    \n\nusing namespace std;  \n\nconst int maxn = 52;\nconst double g = 9.8;\nconst double step = 0.01;\nconst double eps = 1e-8;\n\ninline double sqr(double a) { return a * a; }\n\nint N; double V, X, Y, vx, vy;\ndouble L[maxn], B[maxn], R[maxn], T[maxn];\n\ndouble getY(double x) {\n    double t = x / vx;\n    return vy * t - 0.5 * 9.8 * t * t;\n}\n\nbool check() {\n    double bx = X, by = getY(X);\n    if (by < Y) return false;\n    for (int i = 0; i < N; ++i) {\n        if (L[i] < X) {\n            double l = L[i], r = min(X, R[i]);\n            double y1 = getY(l), y2 = getY(r);\n            if (y1 >= B[i] && y1 <= T[i]) return false;\n            if (y2 >= B[i] && y2 <= T[i]) return false;\n            if (y1 <= B[i] && y2 >= B[i]) return false;\n            if (y1 >= B[i] && y2 <= B[i]) return false;\n            if (y1 <= T[i] && y2 >= T[i]) return false;\n            if (y1 >= T[i] && y2 <= T[i]) return false;\n        }\n        if (L[i] <= X && R[i] >= X) {\n            if (B[i] <= Y && T[i] >= Y) return false;\n            if (B[i] >= Y && B[i] <= by) return false;\n        }\n    }\n    return true;\n}\n\nvoid solved(int nT) {\n    scanf(\"%d %lf %lf %lf\", &N, &V, &X, &Y);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lf %lf %lf %lf\", &L[i], &B[i], &R[i], &T[i]);\n    }\n    bool flag = false;\n    for (vx = step; vx <= V && !flag; vx += step) {\n        vy = sqrt(sqr(V) - sqr(vx));\n        double t = X / vx;\n        double y = vy * t - 0.5 * g * t * t;\n        if (y < Y) continue;\n        if (check()) flag = true;\n    }\n    puts(flag?\"Yes\":\"No\");\n}\n\nint main() { \n    int T = 1;\n    //scanf(\"%d\", &T);\n    for (int nT = 1; nT <= T; ++nT) {\n        solved(nT);\n    }\n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-9;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n\n  if( vy < eps ) return false;\n  \n  /*\n  cout<<\"!!!\"<<endl;\n  cout<<\"t = \"<<t<<endl;\n  cout<<\"vx = \"<<vx<<endl;\n  cout<<\"vy = \"<<vy<<endl;  \n  */\n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = vy / g;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt ,vy);\n    //    cout<<\"fh = \"<<fh<<endl;\n    //    cout<<\"sh = \"<<sh<<endl;\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n\n    if( ft<= zt && zt <= st ){\n      if( check( B[i], T[i], fh, zh ) )return false;\n      if( check( B[i], T[i], zh, sh ) )return false;\n    }\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  //  cout<<\"lastY = \"<<lastY<<endl;\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  //  cout<<\"??????\"<<endl;\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < 0 )return false;\n  if( abs(A) < eps ) return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n  }\n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n    if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nconst double g = 9.8;\nconst double EPS=1e-10;\nconst int maxn = 1000;\ndouble a,b;//抛物??迹系数\nint n,v,px,py;\nint lx[maxn],ly[maxn],rx[maxn],ry[maxn];\n\nbool ok(double l,double r,double k)//抛物?当会不会与y=k(l<=x<=r)\n{\n    if(b*b+4*k<0) return true;\n    double d = sqrt(b*b+4*k);\n    if((-b+d)/(2*a)<r+EPS&&(-b+d)/(2*a)>l-EPS) return false;\n    if((-b-d)/(2*a)<r+EPS&&(-b-d)/(2*a)>l-EPS) return false;\n    return true;\n}\n\nbool check(int x,int y)//求抛物??迹\n{\n    bool res = true;\n    double a_=g*x*x/(2*v*v);\n    double b_=-x;\n    double c_=g*x*x/(2*v*v)+y;\n    if(b_*b_-4*a_*c_<-EPS) return false;\n    double d_=sqrt(b_*b_-4*a_*c_);\n    int cnt=0;\n    for(int k=-1;k<=1;k+=2)\n    {\n        b = (-b_+k*d_)/(2*a_);\n        a = (y-b*x)/(1.0*x*x);\n\n        if(a*px*px+b*px<py){\n            cnt++;\n            continue;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            res &= ok(lx[i],rx[i],ly[i]);\n            res &= ok(lx[i],rx[i],ry[i]);\n            res &= a*lx[i]*lx[i]+b*lx[i]<ly[i]+EPS||a*lx[i]*lx[i]+b*lx[i]>ry[i]-EPS;\n            res &= a*rx[i]*rx[i]+b*rx[i]<ly[i]+EPS||a*rx[i]*rx[i]+b*rx[i]>ry[i]-EPS;\n        }\n    }\n    if(cnt==2) res=false;\n    return res;\n}\n\nint main()\n{\n    cin>>n>>v>>px>>py;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>lx[i]>>ly[i]>>rx[i]>>ry[i];\n        rx[i]=min(rx[i],px);\n    }\n    bool ans = check(px,py);\n    for(int i=1;i<=n;i++)\n    {\n        if(check(lx[i],ry[i])||check(rx[i],ry[i])) ans=true;\n    }\n    if(ans) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-3;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y)) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n    \n    int comp(double lb, double ub, double x){\n        if(x < lb + EPS) return -1;\n        if(x > ub - EPS) return 1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            for(int i = 0; i < n; i++){\n                if(x1[i] >= gx) continue;\n                if(comp(x1[i], x2[i], gx) == 0 && comp(y1[i], y2[i], gy) <= 0 && comp(y1[i], y2[i], fh) >= 0) {\n                    ok = false;\n                }\n                int yl = comp(y1[i], y2[i], calc_y(vx, vy, x1[i]));\n                int yr = comp(y1[i], y2[i], calc_y(vx, vy, x2[i]));\n                int xh = comp(x1[i], x2[i], vx * vy / g);\n                int yh = comp(y1[i], y2[i], calc_y(vx, vy, vx * vy / g));\n                if(xh == 0 && yh >= 0 && yl <= 0) ok = false;\n                if(yl * yr <= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        REP(i, n) x2[i] = min(x2[i], gx);\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define RREP(i,s,e) for (i = s; i >= e; i--)\n#define rrep(i,n) RREP(i,n,0)\n#define REP(i,s,e) for (i = s; i < e; i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 100000000\n\ntypedef long long ll;\n\nint n;\ndouble v, x, y;\ndouble l[50], b[50], r[50], t[50];\ndouble g = 9.8;\n\ndouble cmp(double l, double u, double a) {\n    return a < l ? -1 : a > u ? 1 : 0;\n}\n\ndouble height(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n\nbool solve(int bx, int by) {\n    int i, j;\n    if (v*v-2*g*by < 0)\n        return false;\n    for (int i = -1; i <= 1; i+=2) {\n        double t2 = (-2*(g*by-v*v)+i*v*sqrt(v*v-2*g*by))/(g*g);\n        if (t2 <= 0)\n            continue;\n        double t1 = sqrt(t2);\n        double vx = bx / t1;\n        double vy = y/t1 + g*t1/2;\n        if (height(vy,x/vx) < y-1e-9) continue;\n        bool ok = true;\n        rep (j,n) {\n            if (l[j] >= x) continue;\n            if (r[j] == x && height(vy,x/vx) >= b[j] && y <= t[j]) ok = false;\n            int yL = cmp(b[j],t[j],height(vy,l[j]/vx));\n            int yR = cmp(b[j],t[j],height(vy,r[j]/vx));\n            int xH = cmp(l[j],r[j],vx*vy/g);\n            int yH = cmp(b[j],t[j],height(vy,vy/g));\n            if (yL*yR <= 0) ok = false;\n            if (yR < 0 && xH == 0 && yH >= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    int i;\n    bool ans;\n    cin >> n >> v >> x >> y;\n    rep (i,n) cin >> l[i] >> b[i] >> r[i] >> t[i];\n    rep (i,n) r[i] = min(r[i],x);\n    ans = solve(x,y);\n    rep (i,n) {\n        ans |= solve(l[i],t[i]);\n        ans |= solve(r[i],t[i]);\n    }\n    if (ans)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         /*if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && yy-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-yy>eps )//pig在矩形中 \n             return false;*/\n         if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && hh-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) //pig 在一个矩形的下面 \n              if ( h1-rec[i].b>eps || (rec[i].b-h1>eps && hh-rec[i].b>eps ) ) return false;//抛物&#32447;撞上了障碍物 \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\nconst int N = 60;\nint n, v, x, y, L[N], B[N], R[N], T[N];\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\nbool check(double qx, double qy) {\n    double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n    double d = b * b - 4 * a * c;\n    if (d < 0 && d > -eps) d = 0;\n    if (d < 0) return false;\n    for (int co = -1; co <= 1; co += 2) {\n        double t2 = (-b + co * sqrt(d)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        double yt = calc(vy, x / vx);\n        if (yt < y - eps) continue;\n        bool ok = true;\n        for (int i = 0; i < n; i++) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y <= T[i] && B[i] <= yt) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        R[i] = min(R[i], x);\n    }\n    bool ok = check(x,y);\n    for (int i = 0; i < N; i++) {\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d%d%d\", L + i, B + i, R + i, T + i);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = (y + g * t * t / 2) / t;//sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X == bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, vx* vy / g);\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tr = min(r, X);\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-5;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        if(l > X) continue;\n        if(r > X) r = X;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-8\nusing namespace std;\nconst int maxn = 100;\nint V,n,X,Y;\ndouble vx,vy;\ndouble g=9.8;\nint L[maxn],B[maxn],R[maxn],T[maxn];\ndouble calc(double t)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double l,double h,double x)\n{\n    return x<l+eps?-1:x>h-eps?1:0;\n}\nbool f(double qx,double qy)\n{\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if(d<0 && d>-eps) d=0;\n    if(d<0) return false;\n    for(int tmp=-1; tmp<=1; tmp+=2)\n    {\n        double t=(-b+tmp*sqrt(d))/(2*a);\n        if(t<=0) continue;\n        t=sqrt(t);\n        vx=qx/t;if(fabs(vx)<eps) vx=eps;\n        vy=(qy+g*t*t/2)/t;\n        double temp=X/vx;\n        double qyy=calc(X/vx);\n\n        if(qyy<Y-eps)\n        {\n            continue;\n        }\n        bool ok=true;\n        for(int i=0; i<n; i++)\n        {\n            if(L[i]>=X) continue;\n            if(R[i]==X && Y<=T[i] && B[i]<=qyy) ok=false;\n            int yl=cmp(B[i],T[i],calc(L[i]/vx));\n            int yr=cmp(B[i],T[i],calc(R[i]/vx));\n            int xh=cmp(L[i],R[i],vx*vy/g);\n            int yh=cmp(B[i],T[i],calc(vy/g));\n\n            if(xh==0 && yh>=0 && yl<0) ok=false;\n            if(yl*yr<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main()\n{\n    cin>>n>>V>>X>>Y;\n    for(int i=0; i<n; i++) cin>>L[i]>>B[i]>>R[i]>>T[i];\n    for(int i=0;i<n;i++) R[i]=min(R[i],X);\n    bool ans = f(X,Y);\n\n    for(int i=0; i<n; i++)\n    {\n        ans |=f(L[i],T[i]);\n        ans |=f(R[i],T[i]);\n    }\n    puts(ans?\"Yes\":\"No\");\n    return 0;\n}\n/*\n0 7 3 1\n\n1 7 3 1\n1 1 2 2\n\n1 7 2 2\n0 1 1 2\n1 1 2 2\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-5;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\nint v0,X,Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %d %d %d\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%d %d %d %d\",L+i,B+i,R+i,T+i);\n  puts(\"No\");\n  return 0;\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst double g=9.8;\nconst double eps= 1e-8;\n\nint N; double V,X,Y;\n\ndouble L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\ndouble Calcy(double vy,double t){return vy*t-0.5*g*t*t;}\ndouble Calcx(double vx,double t){return vx*t;}\n\nint cmp(double lb,double ub,double a)\n{\n  return a<lb ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(double x,double y) // ????????????(x,y) \n{\n  double a=0.25*g*g; double b=g*y-V*V; double c=x*x+y*y;\n  double delta= b*b-4*a*c;\n  if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    double vx=x/t; double vy=(y+0.5*g*t*t)/t; //?????????\n    double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y);\n  for(int i=1;i<=N;i++) scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nconst double g = 9.8, eps = 1e-10;\nconst int maxn = 50;\n\nint N, V, X, Y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\n\n//计算以vy的速度竖直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相对于lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\n//判断当射出路线经过点（gx，gy）时，卵是否能击中猪\nbool check(double gx, double gy)\n{\n    //设初速度在x方向和y方向的分量分别为vx和vy，设通过(gx, gy)的时间为t\n    //求解联立方程式vx^2 + vy^2 = V^2，vx * t = gx，vy * t - 1/2 g t^2 = gy\n    double a = g * g / 4, b = g * gy - V * V, c = gx * gx + gy * gy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -eps) D = 0;\n    if (D < 0) return false;\n    for (int d=-1; d<=1; d+=2)\n    {//验证联立方程式的两个解的循环\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = gx / t, vy = (gy + g * t * t / 2) / t;\n        \n        //判断是否通过猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - eps) continue;\n        \n        bool ok = true;\n        for (int i=0; i<N; ++i)\n        {\n            if (L[i] >= X) continue;\n            //判断在猪正上方的鸟和猪之间是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            //判断在飞到猪正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));//左侧的相对位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));//右侧的相对位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));//最高点的相对位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{//裁掉猪以右的障碍物\n    for (int i=0; i<N; ++i) R[i] = min(R[i], X);\n    bool ok = check(X, Y);//直接撞上猪的情况\n    for (int i=0; i<N; ++i)\n    {\n        ok |= check(L[i], T[i]);//经过左上角的情况\n        ok |= check(R[i], T[i]);//经过右上角的情况\n    }\n    puts(ok ? \"Yes\" : \"No\");\n    return;\n}\n\nint main()\n{\n    while (~scanf(\"%d %d %d %d\", &N, &V, &X, &Y))\n    {\n        for (int i=0; i<N; ++i)\n        {\n            scanf(\"%d %d %d %d\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble lx[100];\ndouble ly[100];\ndouble rx[100];\ndouble ry[100];\ndouble EPS=1e-9;\nvector<pair<double,double> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a;\n\tdouble b,c,d;\n\tscanf(\"%d%lf%lf%lf\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf%lf\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(min(rx[i],c),ly[i]));\n\t\tv.push_back(make_pair(min(rx[i],c),ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-9.8*9.8*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\tdouble hg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=x)continue;\n\t\t\tif(ABS(rx[j]-x)<EPS&&d<=ly[j]&&ry[i]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t\tif(th-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(th-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\thg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=x)continue;\n\t\t\tif(ABS(rx[j]-x)<EPS&&d<=ly[j]&&ry[i]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t\tif(th-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(th-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS && yof(vy, vy/g)>B[i]-EPS) return false;\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i] && T[i]>=Y) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-8\nconst int maxn=800;\nconst int INF=199999999;\nconst double pi=asin(1.0)*2.0;\nint dcmp(double x)\n{\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\nstruct ju\n{\n    double l,b,r,t;\n}p[maxn];\nbool ok(double l,double r,double x)\n{\n    if(dcmp(x-r)<=0&&dcmp(x-l)>=0)  return 1;\n    return 0;\n}\nint main()\n{\n    int n;\n    double v,X,Y;\n    scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p[i].l,&p[i].b,&p[i].r,&p[i].t);\n    }\n    double g=9.8;\n    for(int k=0;k<=999999;k++)\n    {\n        double jiao=pi*k/2000000.0;\n\n        bool sign=0;\n        for(int i=0;i<n;i++)\n        {\n            double x=p[i].l;\n            double y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            x=p[i].r;\n            y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            double a=-g/2.0/(v*v*cos(jiao)*cos(jiao));\n            double b=tan(jiao);\n            double c=-p[i].b;\n            if(b*b-4.0*a*c>0)\n            {\n                double x1=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n                double x2=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n                if(ok(p[i].l,p[i].r,x1))    sign=1;\n                if(ok(p[i].l,p[i].r,x2))    sign=1;\n            }\n            if(sign)    break;\n        }\n        if(sign) continue;\n        double y=tan(jiao)*X-g/2.0*X*X/(v*v*cos(jiao)*cos(jiao));\n        if(dcmp(y-Y)<0) continue;\n        for(int j=0;j<n;j++)\n        {\n            if(p[j].l<X&&p[j].r>X)\n            {\n                if(dcmp(y-p[j].b)<=0)   continue;\n                if(dcmp(Y-p[j].t)>=0)   continue;\n                sign=1;\n                break;\n            }\n        }\n        if(!sign)\n        {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && yy-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && hh-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) //pig 在一个矩形的下面 \n              if ( h1-rec[i].b>eps || (rec[i].b-h1>eps && hh-rec[i].b>eps ) ) return false;//抛物&#32447;撞上了障碍物 \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = (y + g * t * t / 2) / t;//sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X == bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, calc(vx, vy / g));\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tr = min(r, X);\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB eps = 1e-8;\nconst int N = 150007;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\n\nconst double PI = acos(-1);\nconst double gg = 9.8;\n\n//double CalcMaxCeta(double X) {\n//    double l = 0.0, r = PI / 2;\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid1 = l + (r - l) / 3.0;\n//        double mid2 = r - (r - l) / 3.0;\n//        if (CalcHeight(mid1, X) > CalcHeight(mid2, X)) {\n//            l = mid2;\n//        } else {\n//            r = mid1;\n//        }\n//    }\n//    return l;\n//}\n//\n//double BinarySearch(bool op, double l, double r, double X, double Y) {\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid = (l + r) / 2.0;\n//        double height = CalcHeight(mid, X);\n//        if (op == 0) { // ascending\n//            if (height > Y) r = mid; else l = mid;\n//        } else { // descending\n//            if (height > Y) l = mid; else r = mid;\n//        }\n//    }\n//}\n\n\ndouble V;\nint low;\n\nint sgn(double x){\n    return x < -eps ? -1 : x > eps;\n}\n\n\ninline double CalcHeight(double ceta, double X) {\n    double t = X / (V * cos(ceta));\n    double y = (V * sin(ceta)) * t - 0.5 * gg * t * t;\n    return y;\n}\n\ninline double GetM(double ceta) {\n    double t = V * sin(ceta) / gg;\n    return V * cos(ceta) * t;\n}\n\n\nint n, X, Y, l[N], b[N], r[N], t[N];\n\nbool Gao(double ceta) {\n    double hh = CalcHeight(ceta, X);\n//    cout << ceta << ' ' << X << ' ' << hh << ' ' << Y << ' ' << low << endl;\n    if (sgn(hh - Y ) < 0  || sgn(hh-low) > 0 )  {\n        return false;\n    }\n//    cout << \"~\";\n\n    double mx = GetM(ceta);\n    double my = CalcHeight(ceta, mx);\n\n\n    for (int i = 1; i <= n; i ++) {\n        if (l[i] > X) continue;\n\n        /*DB h1 = CalcHeight(ceta, l[i]);\n        DB h2 = CalcHeight(ceta, r[i]);\n\n\n        //cout << h1 << \" \" << h2 <<\" \" << mx << \" \"<< my << endl;\n\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (! (h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (! (h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        } */\n\n\n\n        double delta = (r[i] - l[i]) / 100.0;\n        int sum1 = 0, sum2 = 0;\n        for (int j = 0; j < 100; j ++) {\n            double ss = delta * j + l[i];\n            double h3 = CalcHeight(ceta, ss);\n            sum1 += sgn(h3 - b[i]);\n            sum2 += sgn(h3 - t[i]);\n        }\n        if (sum1 == -100 || sum2 == 100) {\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool Check() {\n//    double maxCeta = CalcMaxCeta(X);\n//    double maxHeight = CalcHeight(maxCeta, X);\n//    if (maxHeight < Y) {\n//        return false;\n//    }\n//    if (Gao(PI / 4.0)) return true;\n    if (X == 0 && Y == 0) {\n        return true;\n    }\n    else if (X == 0){\n        double hhh = CalcHeight(PI / 2, 0);\n        if (sgn(hhh - Y) < 0) return false;\n        for (int i = 1; i <= n; i ++) {\n            if (l[i] == 0 && b[i] <= Y)\n                return false;\n        }\n        return true;\n    }\n    for (int i = 1; i <= n; i ++){\n        if (l[i] == 0 && b[i] == 0) {\n            return false;\n        }\n\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n\n    }\n    for (double i = 0, delta = PI / 2 / 15000.0; i <= PI / 2; i += delta) {\n        if (Gao(i)) return true;\n    }\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (scanf(\"%d%lf%d%d\", &n, &V, &X, &Y) == 4) {\n        low = INF;\n        //n = 0;\n        for (int i = 1; i <= n; i ++) {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (r[i] >= X) r[i] = X;\n            if (l[i] <= X && X <= r[i]) {\n                if (Y >= t[i])continue;\n                low = min(low, (int)b[i]);\n            }\n        }\n//        cout << low << endl;\n        if (Check()) puts(\"Yes\");\n        else puts(\"No\");\n//        break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) delta=0.0;\n  else if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++) ok|=Check(L[i],T[i]);\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\t\tbool okflg = false;\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define POJ\n#ifdef POJ\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cfloat>\n#include <cstring>\n#include <climits>\n#include <utility>\n#include <set>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#include <unordered_set>\n#include <random>\n#endif\nusing namespace std;\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef double db;\n#ifndef POJ\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n#endif\nconst ll mod = 1000000007;\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\n#ifndef POJ\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void resize_array(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void resize_array(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) resize_array(v, args...); }\n#endif\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\nll powmod(ll a, ll b)\n{\n    ll res = 1;\n    a %= mod;\n    assert(b >= 0);\n    for (; b; b >>= 1)\n    {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n    }\n    return res;\n}\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\n#ifndef POJ\nstatic uint MD = mod;\nstruct ModInt\n{\n    using M = ModInt;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M &set_v(uint _v)\n    {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M &r) const { return M().set_v(v + r.v); }\n    M operator-(const M &r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M &r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M &r) const { return *this * r.inv(); }\n    M &operator+=(const M &r) { return *this = *this + r; }\n    M &operator-=(const M &r) { return *this = *this - r; }\n    M &operator*=(const M &r) { return *this = *this * r; }\n    M &operator/=(const M &r) { return *this = *this / r; }\n    bool operator==(const M &r) const { return v == r.v; }\n    M pow(ll n) const\n    {\n        M x = *this, r = 1;\n        while (n)\n        {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream &operator<<(ostream &os, const M &r) { return os << r.v; }\n};\nusing Mint = ModInt;\n#endif\n\nconst double g = 9.8;\nconst double EPS = 1E-8;\nclass Solution\n{\n\tstruct Rect \n    {\n        int l,b,r,t;\n    };\n    int cmp(double lb, double ub, double val) {\n        return val < lb+EPS? -1: val > ub-EPS?1:0;\n    }\n    double getY(double vy, double t) {\n        return vy*t - g*t*t/2;\n    }\n    bool CanDropEggTowardThePigOrNot(int x, int y) {\n        double a = g*g/4, b = y*g-v*v, c = x*x + y*y;\n        double d = b*b - 4*a*c;\n        if(abs(d) < EPS) d = 0;\n        // if(d<0 && d>-EPS) d = 0;\n        if(d < 0) return false;\n\n        for(int step=-1;step<=1;step+=2) {\n            double t2 = (-b + step*sqrt(d)) / (2*a);\n            if(abs(t2) < EPS) t2=0;\n            if(t2<=0) continue;\n            \n            double t = sqrt(t2);\n            double vx = x/t;\n            double vy = (y+g*t*t/2)/t;\n\n            double eggx = pigx;\n            double t1 = eggx / vx;\n            // double eggy = vy*t1 - g*t1*t1/2;\n            double eggy = getY(vy, t1);\n\n            if(eggy < pigy - EPS) continue;\n\n            bool ok = true;\n            rep(i,0,sz(rects)) {\n                if(rects[i].l > pigx) continue;\n                if(rects[i].r >= pigx && pigy < rects[i].t && eggy >= rects[i].b) {ok = false; break;}\n                int lefty = cmp(rects[i].b, rects[i].t, getY(vy, rects[i].l/vx));\n                int righty = cmp(rects[i].b, rects[i].t, getY(vy, min(rects[i].r, pigx)/vx));\n                if(lefty*righty <=0) {ok = false; break;}\n                int highestx = cmp(rects[i].l, min(rects[i].r, pigx), vx * vy/g);\n                int highesty = cmp(rects[i].b, rects[i].t, getY(vy, vy/g));\n                if(highestx ==0 && highesty >= 0 && lefty <= 0) {ok=false;break;}\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\npublic:\n\tvoid Solve()\n\t{\n\t\tint n;\n        while(cin>>n>>v>>pigx>>pigy) {\n            if(n>0) {\n                rects.resize(n);\n                rep(i,0,n) {\n                    cin>>rects[i].l>>rects[i].b>>rects[i].r>>rects[i].t;\n                }\n            }\n            bool is_ok = CanDropEggTowardThePigOrNot(pigx,pigy);\n            if(!is_ok) {\n                rep(i,0,n) {\n                    is_ok = CanDropEggTowardThePigOrNot(rects[i].l, rects[i].t);\n                    if(is_ok) break;\n                    is_ok = CanDropEggTowardThePigOrNot(rects[i].r, rects[i].t);\n                    if(is_ok) break;\n                }\n            }\n            cout<<(is_ok?\"Yes\":\"No\")<<endl;\n        }\n\t}\n\nprivate:\n    vector<Rect> rects;\n    int v, pigx, pigy;\n};\n//head\n// cin >> t;\n// for (int cas = 1; cas <= t; ++cas)\n// {\n// \tcout << \"Case #\" << cas << \": \";\n// }\nint main()\n{\n// \tfreopen(\"input.txt\", \"r\", stdin);\n\t// freopen(\"output.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tSolution().Solve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<time.h>\n#define forn(i,n) for(int i=0;i<n;i++)\n#define clr(a,b) memset(a,b,sizeof(a))\n#define ll long long\n#define lowb(i) (i&(-i))\n#define bug(n,m,x) forn(i,n){forn(j,m)printf(\"%d \",x[i][j]);puts(\"\");}puts(\"\")\nusing namespace std;\nconst int inf=1<<30;\nconst double eps=1e-6;\nconst double pi=acos(-1.0);\n//const double inf = 1e10;\n\nint n;\ndouble v,X,Y;\ndouble L[60],B[60],R[60],T[60];\ndouble vx,vy;\nconst double g=9.8;\ndouble gety(double x){\n    double t=x/vx;\n    return vy*t-g*t*t/2;\n}\nbool judge(){\n    double bx=X,by=gety(X);\n    if(by<Y)return false;\n    forn(i,n){\n        if(L[i]<X){\n            double l=L[i],r=min(R[i],X);\n            double y1=gety(l),y2=gety(r);\n            if(y1>=B[i]&&y1<=T[i])return false;\n            if(y2>=B[i]&&y2<=T[i])return false;\n//            if(y1<)\n        }\n        if(L[i]<=bx&&R[i]>=bx){\n            if(B[i]<=Y&&T[i]>=Y)return false;\n            if(B[i]>=Y&&B[i]<=by)return false;\n        }\n    }return true;\n}\nint main(){\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n    forn(i,n)scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n    double step=0.001;\n    for(vx=step;vx<=v;vx+=step){\n        vy=sqrt(v*v-vx*vx);\n        if(judge()){\n            puts(\"Yes\");return 0;\n        }\n    }\n    puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\nconst int NUM=60;\nint L[NUM],B[NUM],R[NUM],T[NUM];\nint n,v,x,y;\n/////////////////////////////////////////////\nint cmp(double l,double r,double now);\ndouble cal(double vy,double t);\nbool check(double qx,double qy);\n/////////////////////////////////////////////\n\nint main()\n{\n    scanf(\"%d %d %d %d\",&n,&v,&x,&y);\n    for (int i=0; i<n; i++)\n    {\n        scanf(\"%d %d %d %d\",&L[i],&B[i],&R[i],&T[i]);\n        R[i]=min(R[i],x);\n    }\n    bool ans=check(x,y);\n    for (int i=0; i<n; i++)\n    {\n        ans|=check(L[i],T[i]);\n        ans|=check(R[i],T[i]);\n    }\n    if (ans)\n        printf(\"Yes\\n\");\n    else\n        printf(\"No\\n\");\n    return 0;\n}\nint cmp(double l,double r,double now)\n{\n    return (now<l+eps)?-1:(now>r-eps)?1:0;\n}\ndouble cal(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nbool check(double qx,double qy)\n{\n    double a=g*g/4;\n    double b=g*qy-v*v;\n    double c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if (d<0&&d+eps>=0)\n        d=0;\n    else if (d<0)\n        return false;\n    for (int i=-1; i<=1; i+=2)\n    {\n        double t=(-b+i*sqrt(d))/(2*a);\n        if (t-eps<0) continue;\n        t=sqrt(t);\n        double vy=(qy+g*t*t/2)/t;\n        double vx=qx/t;\n        double yt=cal(vy,x/vx);//能不能经过猪的上方\n        if (eps<y-yt) continue;\n        bool ok=true;\n        for (int j=0; j<n&&ok; j++)\n        {\n            int yl=cmp(B[j],T[j],cal(vy,L[j]/vx));\n            int yr=cmp(B[j],T[j],cal(vy,R[j]/vx));\n            int xh=cmp(L[i],R[i],vx*(vy/g));\n            int yh=cmp(B[i],T[i],cal(vy,vy/g));\n            if (xh==0&&yh>=0&&yl<0) ok=false;\n            if (yl*yr<=0)\n                ok=false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst double g = 9.8;\nconst double eps = 1e-10;\nconst int maxn = 500;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ndouble cal(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool check(double qx, double qy)\n{\n    double a = g * g / 4, B = g * qy - v * v, c = qx * qx + qy * qy;\n    double d = B * B - 4 * a * c;\n    if(d < 0 && d > -eps) d = 0;\n    if(d < 0) return false;\n    for(int D = -1; D <= 1; D += 2)\n    {\n        double t2 = (-B + D * sqrt(d)) / (2 * a);\n        if(t2 <= 0) continue;\n        double T = sqrt(t2);\n        double vx = qx / T, vy = (qy + g * T * T / 2) / T;\n        double yt = cal(vy, x / vx);\n        if(yt < y - eps) continue;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++)\n        {\n            if(l[i] >= x) continue;\n            if(r[i] == x && y <= t[i] && b[i] <= yt)\n                ok = false;\n            int yl = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy, l[i]/ vx));\n            int yr = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy, r[i]/ vx));\n            int xh = cmp(1.0 * l[i], 1.0 * r[i], 1.0 * vx * (vy / g));\n            int yh = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy , vy / g));\n            if(xh == 0 && yh >= 0 && yl < 0) ok = false;\n            if(yl * yr <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    for(int i = 0; i < n; i++)\n    {\n        r[i] = min(r[i], x);\n    }\n    bool ok = check(x, y);\n    for(int i = 0; i < n; i++)\n    {\n        ok |= check(l[i], t[i]);\n        ok |= check(r[i], t[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d%d\", &n, &v, &x, &y))\n    {\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    R[i] = min(R[i],X);\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(B[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <iomanip>\n#include <queue>\n#include <ctime>\nusing namespace std;\ntemplate <class T> void checkmin(T &t,T x){if (x < t) t = x;}\ntemplate <class T> void checkmax(T &t,T x){if (x > t) t = x;}\ntemplate <class T> void _checkmin(T &t, T x){if (t == -1) t = x; if (x < t) t = x;}\ntemplate <class T> void _checkmax(T &t, T x){if (t == -1) t = x; if (x > t) t = x;}\ntypedef pair <int,int> PII;\ntypedef pair <double,double> PDD;\ntypedef long long lld;\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin();it != (v).end();it++)\n#define DEBUG(a) cout << #a\" = \" << (a) << endl;\n#define DEBUGARR(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\nvector<PDD> inter[100];\ndouble V,X,Y;\ndouble pi = acos(-1.0);\ndouble x0[100],_y0[100],x1[100],_y1[100];\nint N;\ntypedef vector<PDD> VP;\ndouble sqr(double x){return x*x;}\nvoid out(VP A,string s){\n\treturn ;\n\tprintf(\"---------\\n\");\n\tcout<<s<<endl;\n\tfor (int i=0;i<A.size();i++)\n\t\tprintf(\"%lf %lf\\n\",A[i].first,A[i].second);\n}\n\ndouble yatx(double thita,double x){\n\tdouble t=x / (V * cos(thita));\n\treturn (V*sin(thita) -4.9 * t) *t;\n}\ndouble g = 9.8;\nvector<PDD> zup(double xx,double yy) {\n\tdouble tmp =(g * sqr(xx) + sqr(V) * yy )/(sqr(V)*hypot(xx,yy));\n\tif (tmp>1) return vector<PDD>();\n\tdouble A = asin((g * sqr(xx) + sqr(V) * yy )/(sqr(V)*hypot(xx,yy))),\n\t\t   B = atan(yy/xx);\n\tvector<PDD> ret;\n\tret.push_back(PDD(0.5*(A+B),0.5*(M_PI - A +B)));\n\treturn ret;\n}\nPDD getU(PDD A,PDD B){\n\tdouble a = max(A.first,B.first);\n\tdouble b = min(A.second,B.second);\n\treturn PDD(a,b);\n}\nVP Unoin(VP A,VP B){\n\tVP ans;\n\tif (A.size()==0||B.size()==0) return ans;\n\tfor (int j,i=0;i<A.size();i++)\n\t\tfor (j=0;j<B.size();j++){\n\t\t\tPDD tmp = getU(A[i],B[j]);\n\t\t\tif (tmp.first<tmp.second){\n\t\t\t\tans.push_back(tmp);\n\t\t\t}\n\t\t}\n\treturn ans;\n}\n\nVP calc_up(double x0,double x1,double y){\n\tVP inter0 = zup(x0,y);\n\tVP inter1 = zup(x1,y);\n\tout(inter0,\"up 0\");\n\tout(inter1,\"up 1\");\n\treturn Unoin(inter0,inter1);\n\n}\nVP calc_below(double x0,double x1,double y){\n\tVP up = zup(x1,0);\n\tVP inter0 = zup(x0,y),inter1;\n\tif (inter0.size()==0){\n\t\tinter1.push_back(PDD(0,pi/2));\n\t}else {\n\t\tinter1.push_back(PDD(0,inter0[0].first));\n\t\tinter1.push_back(PDD(inter0[0].second,pi/2));\n\t}\n\treturn Unoin(up,inter1);\n}\n\nVP calc_down(double x0,double x1,double y){\n\tVP inter0 = calc_below(x0,x1,y);\n\tout(inter0,\"down 0\");\n\tVP inter1 = calc_below(x1,x1,y);\n\tout(inter1,\"down 1\");\n\treturn Unoin(inter0,inter1);\n}\n\n\nVP calc(int now){\n\tinter[now].clear();\n\tVP up = calc_up(x0[now],x1[now],_y1[now]);\n\tout(up,\"up\");\n\tVP down = calc_down(x0[now],x1[now],_y0[now]);\n\tout(down,\"down\");\n\n\tfor (int i=0;i<up.size();i++)\n\t\tinter[now].push_back(up[i]);\n\tfor (int i=0;i<down.size();i++)\n\t\tinter[now].push_back(down[i]);\n\n\treturn inter[now];\n}\n\nint main(){\n#ifdef cwj\n\tfreopen(\"in\", \"r\", stdin);\n#endif\n\twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n\t\tVP ans;\n\t\tans.push_back(PDD(0,pi/2));\n\t\tfor (int i=0;i<N;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x0[i],&_y0[i],&x1[i],&_y1[i]);\n\t\t\tif (x1[i]>X) x1[i] = X;\n\t\t\tcalc(i);\n\t\t\tans = Unoin(ans,inter[i]);\n\t\t\tout(inter[i],\"i\");\n\t\t}\n\t\tVP up ;\n\t\tup = zup(X,Y);\n\t\tans = Unoin(ans,up);\n\t\tif (ans.size()>0) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-8;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPS){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << \"fir \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << res2 * 180.0 / M_PI << endl;\n  //cout << \"sec \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    if(x[0] > real(target) + EPS) continue;\n    for(int j=0;j<2;j++){\n      if(calc_y(rad, x[j]) < imag(rv[i].ur) - EPS){\n        return true;\n      }\n    }\n    if(calc_x_y0(rad) >= x[0] + EPS && calc_x_y0(rad) <= x[1] - EPS){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  if(calc_x_y0(M_PI/4.0) < imag(target) - EPS) return false;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) return true;\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\n#define MAX_N (50+10)\nconst double G = 9.8;\n#define EPS 1e-06\n\nint N,V,X,Y;\n// (L[i],B[i]) , (R[i],T[i]) // 左下,右上\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\n// 速度vyで上に打ち出した際のt秒後のy座標を計算する\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2;\n}\n\n// aのlbとubに対する相対的な位置\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n// 点(qx,qy)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool check(double qx, double qy) {\n    // 初速のx方向成分をvx,y方向成分をvyとし、(qx,qy)を通る時刻をtとしたときの連立方程式\n    // vx^2 + vy^2 = V^2, vx * t = qx, vy * t - 1/2 g t^2 = qy を解く\n    double a = 1.0/4.0 * G * G,\n           b = qy * G - V * V,\n           c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D<0 && D > -EPS) D = 0;\n    if(D<0) return false; // 虚数\n    for(int d=-1;d<=1;d+=2) { // 連立方程式の2つの解を試すループ\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2) / t;\n\n        // 豚より上を通過できるか判定\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS) continue;\n\n        bool ok = true;\n        for(int i=0;i<N;i++) {\n            if (L[i] >= X) continue;\n            // 豚の真上まで来たときに、間に障害物がないか判定\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            // 途中で障害物にぶつからないか判定\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx)); // 左端での相対位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx)); // 右端での相対位置\n            int xH = cmp(L[i], R[i], vx * (vy / G)); // 最も高くなる地点の相対位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / G));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    // 豚より右にある障害物を縮めておく\n    for(int i=0;i<N;i++) {\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y); // 直接ぶつける場合\n    for(int i=0;i<N;i++) {\n        ok |= check(L[i], T[i]); // 左上の角を通る場合\n        ok |= check(R[i], T[i]); // 右上の角を通る場合\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nmain() {\n    cin>>N>>V>>X>>Y;\n    for(int i=0;i<N;i++) {\n        cin>>L[i]>>B[i]>>R[i]>>T[i];\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\nvector<int> L(N),B(N),R(N),T(N);\nld calcv(ld vy,ld t){\n  return vy*t+G*t*t/2;\n}\n\nld cmp(ld lb,ld ub,ld a){\n  return a< lb+eps ? -1 :a>ub-eps ? 1 :0;\n}\nbool check(ld qX,ld qY){\n  //solve g^2/4*t^4 + (g*qY-V)*t^2 + (qX^2+qY^2) = 0;\n  ld a = G*G/4; ld b = G+qY-V; ld c = qX*qX+qY*qY;\n  ld D = b*b-4*a*c;\n  if((D<0)&&(D>-eps)) D=0;\n  if(D<0) return false;\n  for(int k=-1;k<=1;k+=2){\n    //find t\n    ld t = sqrt((-1*b+k*sqrt(D))/2);\n    if(t<=0) continue;\n    ld vx = qX/t; ld vy = sqrt(V*V-vx*vx);\n\n    //can reach Y?\n    double reachy = calcv(qY,t);\n    if(reachy<Y-eps) return false;\n\n    bool ok = true;\n    //find colision\n    REP(i,N){\n      if(L[i] >= X) continue;//ignore\n      if(R[i]==X && Y<=T[i] && B[i]<=reachy) ok = false;\n      int yL = cmp(B[i],T[i],calcv(vy,L[i]/vx));\n      int yR = cmp(B[i],T[i],calcv(vy,R[i]/vx));\n      int xH = cmp(L[i],R[i],vx*(vy/G));\n      int yH = cmp(B[i],T[i],calcv(vy,vy/G));\n      if(xH==0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  } \n  return false;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    R[i] = min(R[i],X);\n  }\n  bool ok = check(X,Y);\n  REP(i,N){\n    ok |= check(L[i],T[i]);\n    ok |= check(R[i],T[i]);\n  }\n  cout << (ok ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst double eps = 1-10;\nconst int N = 55;\nconst double g = 9.8;\ndouble x, y, v, u[N], d[N], l[N], r[N];\nint n;\n\ndouble cal(double tv, double tt) {\n    return tv*tt - g*tt*tt/2;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool sol(double qx, double qy) {\n    double a = g*g/4, b = g*qy - v*v, c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D < 0 && D > -eps) D = 0;\n    if(D < 0) return 0;\n    for(int td = -1; td <= 1; td += 2) {\n        double t2 = (-b+td*sqrt(D)) / 2 / a;\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy+g*t*t/2) / t;\n\n        double yt = cal(vy, x / vx);\n        if(yt < y - eps) continue;\n\n        bool ok = 1;\n        for(int i = 0; i < n; ++i) {\n            if(l[i] >= x) continue;\n            if(r[i] >= x && yt-d[i] >= 0 && y-u[i] <= 0) ok = 0;\n            int L = cmp(d[i], u[i], cal(vy, l[i] / vx));\n            int R = cmp(d[i], u[i], cal(vy, r[i] / vx));\n            int HX = cmp(l[i], r[i], vx * vy / g);\n            int HY = cmp(d[i], u[i], cal(vy, vy / g));\n            if(L * R <= 0) ok = 0;\n            if(HX == 0 && HY >= 0 && L == -1) ok = 0;\n        }\n        if(ok) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %lf %lf %lf\", &n, &v, &x, &y);\n    for(int i = 0; i < n; ++i) scanf(\"%lf%lf%lf%lf\", &l[i], &d[i], &r[i], &u[i]);\n    int ok = 0;\n    if(sol(x, y)) ok = 1;\n    for(int i = 0; i < n; ++i) if(sol(l[i], u[i]) || sol(r[i], u[i]) ) ok = 1;\n    puts(ok ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Teletubbies\n * Created Time:  2012年08月29日 星期三 16&#26102;07分14秒\n * File Name: 1009.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\n#include <cctype>\n#include <functional>\n#include <deque>\n#include <iomanip>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <utility>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORD(i,a,b) for (int i=(a); i>=(b); i--)\n#define REP(i,b) FOR(i,0,b)\n#define sf scanf\n#define pf printf\nusing namespace std;\nconst int maxint = -1u>>1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<int>::iterator vit;\n\ndouble px,py,vx,vy;\nint l[55],r[55],b[55],t[55];\nint n,v;\n\nbool check(double vx,double vy,double px){\n    double tmpt,yy1,yy2,tt,ppy;\n    //cout << vx << \" \" << vy << endl;\n    tt=px/vx;\n    ppy=vy*tt-0.5*9.8*tt*tt;\n    if (ppy<py) return false;//diguo egg\n    for (int i=0; i<n; i++) {\n        if (l[i]<px && px<=r[i]) { //muban zhongjian de \n            tmpt=l[i]/vx;\n            yy1=vy*tmpt-0.5*9.8*tmpt*tmpt;\n            tmpt=px/vx;\n            yy2=vy*tmpt-0.5*9.8*tmpt*tmpt; //zhuangqiang de \n            if (yy1>=b[i] && yy1<=t[i]) return false;\n            if (yy2>=b[i] && yy2<=t[i]) return false;\n            if (yy1<=b[i] && yy2>=b[i]) return false;\n            if (yy1>=b[i] && yy2<=b[i]) return false;\n            if (yy1>=t[i] && yy1<=t[i]) return false;\n            if (yy1<=t[i] && yy2>=t[i]) return false;\n        }\n        else {\n            if (l[i]<px) { //shifou ke feiguo \n                tmpt=l[i]/vx;\n                yy1=vy*tmpt-0.5*9.8*tmpt*tmpt;\n                tmpt=r[i]/vx;\n                yy2=vy*tmpt-0.5*9.8*tmpt*tmpt; //zhuangqiang de \n                if (yy1>=b[i] && yy1<=t[i]) return false;\n                if (yy2>=b[i] && yy2<=t[i]) return false;\n                if (yy1<=b[i] && yy2>=b[i]) return false;\n                if (yy1>=b[i] && yy2<=b[i]) return false;\n                if (yy1>=t[i] && yy1<=t[i]) return false;\n                if (yy1<=t[i] && yy2>=t[i]) return false;\n            }\n        }      \n        \n    }\n    return true;\n}\n\nint main() \n{\n    while (~scanf(\"%d%d%lf%lf\",&n,&v,&px,&py)) {\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d%d%d\",&l[i],&b[i],&r[i],&t[i]);\n        }    \n        bool flag=false;\n        for (int i=1; i<=v*1000; i++) {\n            vx=i*1.0/1000;\n            vy=sqrt(v*v-vx*vx);\n            if (check(vx,vy,px)) {\n                flag=true;\n                puts(\"Yes\");\n                break;\n            }\n        }\n        if (!flag) puts(\"No\");\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\tgettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<cstring>\n#include<map>\n#include<set>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<time.h>\nusing namespace std;\nconst int INF=1<<30;\ntypedef long long ll;\nconst double eps=1e-8;\n\n\nconst double g=9.8;\n\nint n,m;\ndouble v,x,y;\n\nstruct point{\n    double x,y;\n};\n\nstruct Matrix{\n    point a,b,c,d;\n}e[100];\n\ndouble gety(double vy,double t){\n    return vy*t-0.5*g*t*t;\n}\n\nint cmp(int l,int r,int a){\n    return a<l?-1:a>r?1:0;\n}\n\nbool juge(point Q){\n    int i,j,k;\n    double a=0.25*g*g,b=g*Q.y-v*v,c=Q.x*Q.x+Q.y*Q.y;\n    double D=(b*b-4.0*a*c);\n    if(D<0&&D>-eps)D=0;\n    if(D<0)return false;\n    for(i=-1;i<=1;i+=2){\n        double t=(i*sqrt(D)-b)/(2.0*a);\n        if(t<=0)continue;\n        double t1=sqrt(t);\n        double vx=Q.x/t1,vy=(0.5*g*t+Q.y)/t1;\n        double yt=gety(vy,x/vx);\n        if(yt<y-eps)continue;\n\n        bool ok=true;\n        for(j=0;j<n;j++){\n            if(e[j].a.x>=x)continue;\n            if(yt>=e[j].a.y&&y<=e[j].c.y&&e[j].d.x==x)ok=false;\n\n            int yL=cmp(e[j].c.y,e[j].a.y,gety(vy,e[j].a.x/vx));\n            int yR=cmp(e[j].d.y,e[j].b.y,gety(vy,e[j].b.x/vx));\n            int xH=cmp(e[j].a.x,e[j].b.x,vx*(vy/g));\n            int yH=cmp(e[j].c.y,e[j].a.y,gety(vy,(vy/g)));\n            if(xH==0&&yH>=0&&yL<0)ok=false;\n            if(yL*yR<=0)ok=false;\n        }\n        if(ok)return true;\n    }\n    return false;\n}\n\nint main()\n{\n    int i,j;\n    cin>>n>>v>>x>>y;\n    int cnt=0;\n    for(i=0;i<n;i++){\n        double x1,y1,x2,y2;\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n        if(x1>=x)continue;\n        if(x2>x)x2=x;\n        point a,b,c,d;\n        a.x=x1,a.y=y2;\n        b.x=x2,b.y=y2;\n        c.x=x1,c.y=y1;\n        d.x=x2,d.y=y1;\n        e[cnt].a=a,e[cnt].b=b,e[cnt].c=c,e[cnt++].d=d;\n    }\n    n=cnt;\n    int ok=0;\n    point W;W.x=x,W.y=y;\n    if(juge(W))ok=1;\n    if(ok){\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    for(i=0;i<n;i++){\n        if(juge(e[i].a)||juge(e[i].b))ok=1;\n    }\n    if(ok)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define sqr(x) ((x)*(x))\ntypedef pair<double,double> point;\n\nconst double g=9.8;\nconst double eps=1e-8;\ndouble v;\n\nstruct para\n{\n\tdouble a,b;\n\tpara(){a=b=0;}\n\tpara(double te){b=te;a=-g*(b*b+1)/2/v/v;}\n\tdouble qz(double x) {return a*x*x+b*x;}\n};\n\nvector<para> init(double x,double y)\n{\n\tvector<para> res;\n\tdouble at=g*x*x/2/v/v,bt=-x,ct=y+g/2/v/v*x*x;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(para(pbt));return res;}\n\tres.push_back(para(pbt+sqrt(pbs)/2/at));\n\tres.push_back(para(pbt-sqrt(pbs)/2/at));\n\treturn res;\n}\nvector<double> sol(double at,double bt,double ct)\n{\n\tvector<double> res;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(pbt);return res;}\n\tres.push_back(pbt+sqrt(pbs)/2/at);\n\tres.push_back(pbt-sqrt(pbs)/2/at);\n\treturn res;\n}\n\nstruct rect\n{\n\tdouble xl,xu,yl,yu;\n\trect(double xt=0,double yt=0,double xtt=0,double ytt=0):xl(xt),xu(xtt),yl(yt),yu(ytt){}\n};\n\nbool intersect(rect r,para p)\n{\n\tdouble t1=p.qz(r.xl),t2=p.qz(r.xu);\n\tif(t1>r.yl+eps&&t1<r.yu-eps) return true;\n\tif(t2>r.yl+eps&&t2<r.yu-eps) return true;\n\tif(fabs(t1-r.yl)<eps&&fabs(t2-r.yu)<eps) return true;\n\tif(fabs(t2-r.yl)<eps&&fabs(t1-r.yu)<eps) return true;\n\tvector<double> r1=sol(p.a,p.b,-r.yl);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\tr1=sol(p.a,p.b,-r.yu);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\treturn false;\n}\n\nint n;\nint v12,x12,y12;\ndouble x,y;\nvector<point> po;\nvector<rect> ret;\n\nvoid solve()\n{\n\tint i,j,k,l;\n\tv=v12;x=x12;y=y12;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tint xt[5];\n\t\tfor(j=0;j<4;j++) scanf(\"%d\",xt+j);\n\t\tif(xt[0]>xt[2]||xt[1]>xt[3]) continue;\n\t\tfor(j=0;j<4;j+=2) for(k=1;k<4;k+=2) if(xt[j]&&xt[k]) po.push_back(point(xt[j],xt[k]));\n\t       \tret.push_back(rect(xt[0],xt[1],xt[2],xt[3]));\n\t}\n\tpo.push_back(point(x,y));\n\tn=ret.size();\n\tfor(i=0;i<po.size();i++)\n\t{\n\t\tvector<para> tet=init(po[i].first,po[i].second);\n\t\tif(tet.empty()) continue;\n\t\tfor(l=0;l<tet.size();l++)\n\t\t{\n\t\t\tif(tet[l].qz(x)<y-eps) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(intersect(ret[j],tet[l])) break;\n\t\t\t}\n\t\t\tif(j<n) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tif(x>ret[j].xl+eps&&x<ret[j].xu-eps&&tet[l].qz(x)>ret[j].yl+eps&&y<ret[j].yl+eps) break;\n\t\t\tif(j<n) continue;\n\t\t\tprintf(\"Yes\\n\");return;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\nint main()\n{\n\twhile(scanf(\"%d %d %d %d\",&n,&v12,&x12,&y12)!=EOF)\n\t{solve();}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=300000;i++ )\n     {\n           vy=double(i)/300000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if(l<=X){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(T[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double inf = 1e8;\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble getY(double x, double vx, double vy) {\n  return -g/(2*vx*vx) * x*x + vy/vx * x;\n}\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int i = 0; i < u.size(); ++i) {\n        if(u[i] <= 0) continue;\n        vxs.push_back(sqrt(u[i]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        double vx = vxs[k];\n        double vy = sqrt(V*V - vx*vx);\n        bool flag = true;\n        for(int i = 0; i < N; ++i) {\n          if(X <= L[i]) continue;\n          vector<double> v;\n          vector<double> u;\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          {\n            double y = getY(L[i], vx, vy);\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(L[i]);\n            }\n          }\n          {\n            double y = getY(R[i], vx, vy);\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(R[i]);\n            }\n          }\n          sort(v.begin(), v.end());\n          v.erase(unique(v.begin(), v.end(), equals), v.end());\n          if(v.size() == 2) {\n            double mx = (v[0] + v[1]) / 2.0;\n            double my = getY(mx, vx, vy);\n            if(L[i]+eps < mx && mx < R[i]-eps && \n               B[i]+eps < my && my < T[i]-eps) {\n              flag = false;\n              break;\n            }\n          }\n        }\n        if(!flag) continue;\n        double py = getY(X, vx, vy);\n        if(equals(Y, py)) throw 0;\n        if(py < Y) continue;\n        bool ok = true;\n        for(int i = 0; i < N; ++i) {\n          if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n            ok = false;\n            break;\n          }\n        }\n        if(ok) throw 0;\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst double eps = 1-10;\nint dcmp(double x) {\n    if(abs(x) < eps) return 0;\n    return x > 0 ? 1 : -1;\n}\n\nconst int N = 55;\nconst double g = 9.8;\ndouble x, y, v, u[N], d[N], l[N], r[N];\nint n;\n\ndouble cal(double tv, double tt) {\n    return tv*tt - g*tt*tt/2;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool sol(double qx, double qy) {\n    double a = g*g/4, b = g*qy - v*v, c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D < 0 && D > -eps) D = 0;\n    if(D < 0) return 0;\n    for(int td = -1; td <= 1; td += 2) {\n        double t2 = (-b+td*sqrt(D)) / 2 / a;\n        if(dcmp(t2) == -1) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy+g*t*t/2) / t;\n\n        double yt = cal(vy, x / vx);\n        if(dcmp(yt - y) == -1) continue;\n\n        bool ok = 1;\n        for(int i = 0; i < n; ++i) {\n            if(dcmp(l[i] - x) == 1) continue;\n            if(r[i] >= x && yt-d[i] >= 0 && y-u[i] <= 0) ok = 0;\n            int L = cmp(d[i], u[i], cal(vy, l[i] / vx));\n            int R = cmp(d[i], u[i], cal(vy, r[i] / vx));\n            int HX = cmp(l[i], r[i], vx * vy / g);\n            int HY = cmp(d[i], u[i], cal(vy, vy / g));\n            if(L * R <= 0) ok = 0;\n            if(HX == 0 && HY >= 1 && L == -1) ok = 0;\n        }\n        if(ok) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %lf %lf %lf\", &n, &v, &x, &y);\n    for(int i = 0; i < n; ++i) scanf(\"%lf%lf%lf%lf\", &l[i], &d[i], &r[i], &u[i]);\n    int ok = 0;\n    if(sol(x, y)) ok = 1;\n    for(int i = 0; i < n; ++i) if(sol(l[i], u[i]) || sol(r[i], u[i]) ) ok = 1;\n    puts(ok ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n    \n    int comp(double lb, double ub, double x){\n        if(x < lb + EPS) return -1;\n        if(x > ub - EPS) return 1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            for(int i = 0; i < n; i++){\n                if(x1[i] >= gx) continue;\n                if(comp(x1[i], x2[i], gx) == 0 && comp(y1[i], y2[i], gy) <= 0 && comp(y1[i], y2[i], gh) >= 0) {\n                    ok = false;\n                }\n                int yl = comp(y1[i], y2[i], calc_y(vx, vy, x1[i]));\n                int yr = comp(y1[i], y2[i], calc_y(vx, vy, x2[i]));\n                int xh = comp(x1[i], x2[i], vx * vy / g);\n                int yh = comp(y1[i], y2[i], calc_y(vx, vy, vx * vy / g));\n                if(xh == 0 && yh >= 0 && yl <= 0) ok = false;\n                if(yl * yr <= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        REP(i, n) x2[i] = min(x2[i], gx);\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-4;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y)) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-9;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n  /*\n  cout<<\"!!!\"<<endl;\n  cout<<\"t = \"<<t<<endl;\n  cout<<\"vx = \"<<vx<<endl;\n  cout<<\"vy = \"<<vy<<endl;  \n  */\n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = (ft+st)*0.5;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt ,vy);\n    //    cout<<\"fh = \"<<fh<<endl;\n    //    cout<<\"sh = \"<<sh<<endl;\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n    if( check( B[i], T[i], fh, zh ) )return false;\n    if( check( B[i], T[i], zh, sh ) )return false;\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  //  cout<<\"lastY = \"<<lastY<<endl;\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  //  cout<<\"??????\"<<endl;\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < -eps )return false;\n  if( abs(A) < eps ) return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n  }\n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n    if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n//#include\nusing namespace std;\nconst double EPS = 1e-10;\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[55], B[55], R[55], T[55];\n//?算以 vy 的速度?直向上射出 t 秒后的高度\ndouble calc(double tv, double tt) {\n    return tv*tt - g*tt*tt/2;\n}\n//a 相? lb 和 ub 的位置\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n//判断当射出路径?? （qx, qy) ?，蛋能否?中猪\nbool check(double qx, double qy) {\n    double a = g*g/4, b = g*qy - V*V, c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D < 0 && D > -EPS) D = 0;\n    if(D < 0) return 0;\n    for(int td = -1; td <= 1; td += 2) {\n        double t2 = (-b+td*sqrt(D)) / (2*a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy+g*t*t/2) / t;\n\n        double yt = calc(vy, X / vx);\n        if(yt < Y - EPS) continue;\n\n        bool ok = 1;\n        for(int i = 0; i < N; ++i) {\n            if(L[i] >= X) continue;\n            if(R[i] == X && Y <= T[i] && B[i] <= yt) ok = 0;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int HX = cmp(L[i], R[i], vx * vy / g);\n            int HY = cmp(B[i], T[i], calc(vy, vy / g));\n            if(yL * yR <= 0) ok = 0;\n            if(HX == 0 && HY >= 0 && yL == -1) ok = 0;\n        }\n        if(ok) return 1;\n    }\n    return 0;\n}\nvoid solve(void)\n{\n   //截掉猪以右的障碍物\n   for(int i = 0; i < N; i++)\n       R[i] = min(R[i], X);\n   bool ok = check(X, Y);   //直接撞上猪\n   for(int i = 0; i < N; i++)\n   {\n       ok |= check(L[i], T[i]);\n       ok |= check(R[i], T[i]);\n   }\n   puts(ok ? \"Yes\" : \"No\");\n}\nint main()\n{\n   scanf(\"%d %lf %lf %lf\", &N, &V, &X, &Y);\n   for(int i = 0; i < N; i++)\n       scanf(\"%lf %lf %lf %lf\", &L[i], &B[i], &R[i], &T[i]);\n   solve();\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Teletubbies\n * Created Time:  2012年08月29日 星期三 16&#26102;07分14秒\n * File Name: 1009.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\n#include <cctype>\n#include <functional>\n#include <deque>\n#include <iomanip>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <utility>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORD(i,a,b) for (int i=(a); i>=(b); i--)\n#define REP(i,b) FOR(i,0,b)\n#define sf scanf\n#define pf printf\nusing namespace std;\nconst int maxint = -1u>>1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<int>::iterator vit;\n\ndouble px,py,vx,vy;\nint l[55],r[55],b[55],t[55];\nint n,v;\n\nbool check(double vx,double vy,double px){\n    double tmpt,yy1,yy2,tt,ppy;\n    //cout << vx << \" \" << vy << endl;\n    tt=px/vx;\n    ppy=vy*tt-0.5*9.8*tt*tt;\n    if (ppy<py) return false;//diguo egg\n    for (int i=0; i<n; i++) {\n        if (l[i]<px && px<=r[i]) { //muban zhongjian de \n            tmpt=l[i]/vx;\n            yy1=vy*tmpt-0.5*9.8*tmpt*tmpt;\n            tmpt=px/vx;\n            yy2=vy*tmpt-0.5*9.8*tmpt*tmpt; //zhuangqiang de \n            if (yy1>=b[i] && yy1<=t[i]) return false;\n            if (yy2>=b[i] && yy2<=t[i]) return false;\n            if (yy1<=b[i] && yy2>=b[i]) return false;\n            if (yy1>=b[i] && yy2<=b[i]) return false;\n            if (yy1>=t[i] && yy1<=t[i]) return false;\n            if (yy1<=t[i] && yy2>=t[i]) return false;\n        }\n        else {\n            if (l[i]<px) { //shifou ke feiguo \n                tmpt=l[i]/vx;\n                yy1=vy*tmpt-0.5*9.8*tmpt*tmpt;\n                tmpt=r[i]/vx;\n                yy2=vy*tmpt-0.5*9.8*tmpt*tmpt; //zhuangqiang de \n                if (yy1>=b[i] && yy1<=t[i]) return false;\n                if (yy2>=b[i] && yy2<=t[i]) return false;\n                if (yy1<=b[i] && yy2>=b[i]) return false;\n                if (yy1>=b[i] && yy2<=b[i]) return false;\n                if (yy1>=t[i] && yy1<=t[i]) return false;\n                if (yy1<=t[i] && yy2>=t[i]) return false;\n            }\n        }      \n        \n    }\n    return true;\n}\n\nint main() \n{\n    while (~scanf(\"%d%d%lf%lf\",&n,&v,&px,&py)) {\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d%d%d\",&l[i],&b[i],&r[i],&t[i]);\n        }    \n        bool flag=false;\n        for (int i=1; i<=v*1000; i++) {\n            vx=i*1.0/1000;\n            vy=sqrt(v*v-vx*vx);\n            if (check(vx,vy,px)) {\n                flag=true;\n                puts(\"Yes\");\n                break;\n            }\n        }\n        if (!flag) puts(\"No\");\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=1000000;i++ )\n     {\n           vy=double(i)/1000000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 55\n\nconst double g = 9.8;\n\nint N,V,X,Y;\nint L[NUM],B[NUM],R[NUM],T[NUM];\n\ndouble calc(double vy,double t){\n\treturn vy*t-g*t*t/2;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a < lb + EPS ? -1: a > ub - EPS? 1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a = g*g/4, b = g*qy-V*V, c = qx*qx + qy*qy;\n\tdouble D = b*b-4*a*c;\n\n\tif(D < 0 && D > -EPS)D = 0;\n\tif(D < 0)return false;\n\n\tfor(int d = -1; d <= 1; d += 2){\n\t\tdouble t2 = (-b + d*sqrt(D)) / (2 * a);\n\t\tif(t2 <= 0)continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx/t,vy = (qy+g*t*t/2)/t;\n\n\t\tdouble yt = calc(vy,X/vx);\n\t\tif(yt < Y-EPS)continue;\n\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(L[i] >= X)continue;\n\t\t\tif(R[i] == X && Y <= T[i] && B[i] <= yt)ok = false;\n\t\t\tint yL = cmp(B[i],T[i],calc(vy,L[i]/vx));\n\t\t\tint yR = cmp(B[i],T[i],calc(vy,R[i]/vx));\n\t\t\tint xH = cmp(L[i],R[i],vx*(vy/g));\n\t\t\tint yH = cmp(B[i],T[i],calc(vy,vy/g));\n\t\t\tif(xH == 0 && yH >= 0 && yL < 0)ok = false;\n\t\t\tif(yL * yR <= 0)ok = false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tR[i] = min(R[i],X);\n\t}\n\n\tbool ok = check(X,Y);\n\n\tfor(int i = 0; i < N; i++){\n\t\tok |= check(L[i],T[i]);\n\t\tok |= check(R[i],T[i]);\n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\nint main(){\n\n\tscanf(\"%d %d %d %d\",&N,&V,&X,&Y);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d %d\",&L[i],&B[i],&R[i],&T[i]);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\nconst int NUM=60;\nint L[NUM],B[NUM],R[NUM],T[NUM];\nint n,v,x,y;\n/////////////////////////////////////////////\nint cmp(double l,double r,double now);\ndouble cal(double vy,double t);\nbool check(double qx,double qy);\n/////////////////////////////////////////////\n\nint main()\n{\n    scanf(\"%d %d %d %d\",&n,&v,&x,&y);\n    for (int i=0; i<n; i++)\n    {\n        scanf(\"%d %d %d %d\",&L[i],&B[i],&R[i],&T[i]);\n        R[i]=min(R[i],x);\n    }\n    bool ans=check(x,y);\n    for (int i=0; i<n; i++)\n    {\n        ans|=check(L[i],T[i]);\n        ans|=check(R[i],T[i]);\n    }\n    if (ans)\n        printf(\"Yes\\n\");\n    else\n        printf(\"No\\n\");\n    return 0;\n}\nint cmp(double l,double r,double now)\n{\n    return (now<l+eps)?-1:(now>r-eps)?1:0;\n}\ndouble cal(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nbool check(double qx,double qy)\n{\n    double a=g*g/4;\n    double b=g*qy-v*v;\n    double c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if (d<0&&d+eps>=0)\n        d=0;\n    else if (d<0)\n        return false;\n    for (int i=-1; i<=1; i+=2)\n    {\n        double t=(-b+i*sqrt(d))/(2*a);\n        if (t-eps<0) continue;\n        t=sqrt(t);\n        double vy=(qy+g*t*t/2)/t;\n        double vx=qx/t;\n        double yt=cal(vy,x/vx);//能不能经过猪的上方\n        if (eps<y-yt) continue;\n        bool ok=true;\n        for (int j=0; j<n&&ok; j++)\n        {\n            double lh=cmp(B[j],T[j],cal(vy,L[j]/vx));\n            double rh=cmp(B[j],T[j],cal(vy,R[j]/vx));\n            if (lh<=0||rh<=0)\n                ok=false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\n//ÀWiX,Y)ðÊéæ¤ÈtanÌlðßApush·é\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\t//OBæèàá­È¯êÎ^ãÉáQ¨ª é\n\t\tif(L[i]<X && X<R[i])\n\t\t\tOB=min(OB,B[i]);\n\t}\n\t//^[QbgðÊéæ¤ÈtanÌlðßé\n\tadd(X,Y);\n\n\t//áQ¨Ì¶ãAEãðÊéæ¤ÈtanÌlßé\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t\tadd(L[i],B[i]);\n\t\tadd(R[i],B[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\t//^[QbgÌ^ãÉ½Æ«OBæèà¢A»à»àÍ©È¢ÍO\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\t//eáQ¨ÆÕË»èð·é\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\t//XÀWªáQ¨ÌÍÍàÌÆ«ÌÅåÌ³AÅáÌá³ðßé\n\t\t\t//XÀWªáQ¨Ì¶[ÆE[ÌÆ«Ì³ðßé\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\t//¸_ªÜÜêéÆ«ÍA¸_ªÅåÌ³\n\t\t\tif(L[j]<center && center<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t\n\t\t\t//àµÔÂ©éÈçÌtanð·\n\t\t\tif(!(My<B[j] || T[j]<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//àµ`FbNðNAµ½tanª¶Ýµ½çYesðoÍµÄIíè\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\t\treturn a<lb+eps?-1:ub<a+eps?1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 50;\nconst double g = 9.8;\nconst double EPS = 1e-8;\n\nint N, V, X, Y, L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t){\n  return vy * t - g * t * t / 2.0;\n}\n\nint cmp(double lb, double ub, double a){\n  return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check(double qx, double qy){\n  double a = g * g / 4.0, b = g * qy - V * V, c = qx * qx + qy * qy;\n  double D = b * b - 4 * a * c;\n  if(D < 0 && D > -EPS) D = 0;\n  if(D < 0) return false;\n  for(int d = -1;d<=1;d += 2){\n    double t2 = (-b + d * sqrt(D)) / (2.0 * a);\n    if(t2 <= 0) continue;\n    double t = sqrt(t2);\n    double vx = qx / t, vy = (qy + g * t * t / 2.0) / t;\n    double yt = calc(vy, X / vx);\n    if(yt < Y - EPS) continue;\n\n    bool ok = true;\n    for(int i=0;i<N;i++){\n      if(L[i] >= X) continue;\n      if(R[i] >= X && Y <= T[i] && B[i] <= yt) ok = false;\n      int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n      int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n      int xH = cmp(L[i], R[i], vx * (vy / g));\n      int yH = cmp(B[i], T[i], calc(vy, vy / g));\n      if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  bool ok = check(X, Y);\n  for(int i=0;i<N;i++){\n    ok |= check(L[i], T[i]);\n    ok |= check(R[i], T[i]);\n  }\n  return ok;\n}\n\nmain(){\n  cin >> N >> V >> X >> Y;\n  for(int i=0;i<N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  cout << (solve() ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n\n#define M 1e9+7\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define  mem(a) memset(a,0,sizeof a)\n#define pi acos(-1.0)\n#define inf 0x3f3f3f3f //1.7e9\nconst double eps = 1e-8;\nint n, v,x,y;\nconst int maxn = 55;const double g = 9.8;\ndouble L[maxn],B[maxn],R[maxn],T[maxn];\ndouble calc(double vy,double t) { return vy*t - g*t*t/2; }\nint cmp(double lb,double ub,double a) { return a < lb +eps ? -1: a > ub-eps ? 1: 0;}\n\nbool check(double qx,double qy)\n{\n        double a = g*g/4, b = g*qy-v*v,c = qx*qx + qy*qy;\n        double D = b*b - 4*a*c;\n        if(D < 0 && D > -eps )\n                D = 0;\n        if(D < 0)\n                return false;\n        for(int d = -1 ; d <= 1 ; d += 2)\n        {\n                double t2 = (-b + d*sqrt(D))/(2*a);\n                if(t2 <= 0)\n                        continue;\n                double t = sqrt(t2);\n                double vx = qx / t ,vy = (qy + g*t*t/2)/t;\n                double yt = calc(vy,x/vx);\n                if(yt < y - eps)\n                        continue;\n                bool ok = true;\n                for(int j = 0 ; j < n ; j ++)\n                {\n                        if(L[j] >= x)\n                                continue;\n                        if(R[j] == x && y <= T[j] && B[j] <= yt)\n                                ok = false;\n                        int yl = cmp(B[j],T[j],calc(vy,L[j]/vx));\n                        int yr = cmp(B[j],T[j],calc(vy,R[j]/vx));\n                        int xh = cmp(L[j],R[j],vx*(vy/g));\n                        int yh = cmp(B[j],T[j],calc(vy,vy/g));\n                        if(xh == 0 && yh >= 0 && yl < 0)\n                                ok = false;\n                        if(yl * yr <= 0)\n                                ok = false;\n                }\n                if(ok) return true;\n        }\n        return false;\n}\nvoid solve()\n{\n        for(int i = 0 ; i < n ; i ++)\n                if(R[i] > x)\n                        R[i] = double(x);\n        bool ok = check(x,y);\n        for(int i = 0 ; i < n ; i ++)\n        {\n                ok |= check(L[i],T[i]);\n                ok |= check(R[i],T[i]);\n        }\n        if(ok)\n                printf(\"Yes\\n\");\n        else\n                printf(\"No\\n\");\n}\nint main()\n{\n        while(~scanf(\"%d %d %d %d\",&n,&v,&x,&y))\n        {\n                for(int i = 0 ; i < n ; i ++)\n                        scanf(\"%lf %lf %lf %lf\",&L[i],&B[i],&R[i],&T[i]);\n                solve();\n        }\n        return 0;\n}\n/*\n0 7 3 1\n\n1 7 3 1\n1 1 2 2\n\n1 7 2 2\n0 1 1 2\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\n\npair<double, double> tanth(int x, int y, int v)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\n\tif(d<0) return make_pair<double, double>(-1, -1);\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(1){\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(i==0) continue;\n\t\t\t\tallTH.push_back(90.0/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = 0.5*v*v*si*si/g;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;\n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );\n         double h2 = a*rec[i].r*(rec[i].r-len );\n         if ( h1<rec[i].b && h2<rec[i].b ) continue;\n         if ( rec[i].l>xx ) continue;\n         if ( len/2<rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;\n         if ( h1-rec[i].b>eps && h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) return false;\n         if ( rec[i].r>xx )  continue;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-6;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0.0000001; rad < M_PI / 2.0; rad += 0.0000001){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(!((double)gy - EPS <= y && y <= (double)gy + EPS)){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(y1 < 0 || y2 < 0){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y1 + EPS\n             || (double)obstacles[i].top_y < y1 - EPS)){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y2 + EPS\n             || (double)obstacles[i].top_y < y2 - EPS)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LTE(h,lb)?-1:(GTE(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      double rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      double rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      //cout << \"getY = \" <<vy << \" \" << R[j] << endl;\n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 0 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  rep(i,N) R[i] = min(R[i],X);\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    success |= exec(R[i],T[i]);\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n\n  cin >> N >> v0 >> X >> Y;\n  rep(i,N) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int x, int y, int v)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K - x*x*(x*x+2*K*y);\n\n\tif(d<0) return make_pair<double, double>(-1, -1);\n\tdouble kai1 = (K + sqrt(d)) / x / x;\n\tdouble kai2 = (K - sqrt(d)) / x / x;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(0){\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(i==0) continue;\n\t\t\t\tallTH.push_back(90.0/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\n\nvoid kouhoth(int x, int y, int v, vector<double> &allTH)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\n\tif(d<0) return;\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\tif(kai1+EPS>0) allTH.push_back(atan(kai1+EPS));\n\tif(kai1-EPS>0) allTH.push_back(atan(kai1-EPS));\n\tif(kai2+EPS>0) allTH.push_back(atan(kai2+EPS));\n\tif(kai2-EPS>0) allTH.push_back(atan(kai2-EPS));\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha * kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³ÊÈª»\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tkouhoth(l, b, v, allTH);\n\t\t\tkouhoth(r, b, v, allTH);\n\t\t\tkouhoth(l, t, v, allTH);\n\t\t\tkouhoth(r, t, v, allTH);\n\t\t}\n\t\tkouhoth(x, y, v, allTH);\n\n\t\t// áQ¨ª éÆ«\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<ctype.h>\n#include<set>\n#include<vector>\n#include<map>\n#include<time.h>\n#include<list>\nusing namespace std;\ntypedef long long ll;\n//freopen(\"D.in\",\"r\",stdin);\n//freopen(\"D.out\",\"w\",stdout);\nint N,V,X,Y;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\nconst double g=4.9;\nbool DY(double a,double b) {return fabs(a-b)<eps;}\nstruct note{\n    int xz,xr,yx,ys;\n} L[1000];\ndouble YY(int X,double x){\n    return tan(x)*X-g*X*X/V/V/cos(x)/cos(x);\n}\nbool PAN(int i,double x){\n    double A1=YY(L[i].xz,x);\n    double A2=YY(L[i].xr,x);\n    if (A1-eps>L[i].ys&&A2-eps>L[i].ys) return 0;\n    if (A1+eps<L[i].yx&&A2+eps<L[i].yx&&(A1>0||DY(A1,0))&&(A2>0||DY(A2,0))) return 0;\n    return 1;\n}\nint main()\n{\n    int xz,xr,ys,yx;\n\tint i,j,T,n,m;\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tn=0;\n\tfor (i=0;i<N;i++){\n        scanf(\"%d%d%d%d\",&xz,&yx,&xr,&ys);\n        if (xz<=X) {\n            if (xr>X) xr=X;\n            L[n].xz=xz;\n            L[n].xr=xr;\n            L[n].yx=yx;\n            L[n++].ys=ys;\n        }\n\t}\n\tdouble PII=PI/2;\n\tbool F=0;\n\tfor (double x=0.1;x<=1.5;x+=0.0001){\n        F=1;\n        if (YY(X,x)+eps<Y) {\n            continue;\n        }\n        for (i=0;i<n;i++){\n            if (PAN(i,x)) {\n                F=0;\n                break;\n            }\n        }\n        if (F==0) continue;\n        printf(\"Yes\\n\");\n        return 0;\n\t}\n\tprintf(\"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble lx[100];\ndouble ly[100];\ndouble rx[100];\ndouble ry[100];\ndouble EPS=1e-9;\nvector<pair<double,double> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a;\n\tdouble b,c,d;\n\tscanf(\"%d%lf%lf%lf\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf%lf\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\n\t\t//v.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\t//v.push_back(make_pair(min(rx[i],c),ly[i]));\n\t\tv.push_back(make_pair(min(rx[i],c),ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-9.8*9.8*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\tdouble hg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=x-EPS)continue;\n\t\t\tif(ABS(rx[j]-x)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t\tif(th-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(th-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\thg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=x)continue;\n\t\t\tif(ABS(rx[j]-x)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t\tif(th-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(th-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;\n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );\n         double h2 = a*rec[i].r*(rec[i].r-len );\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) \n         {\n              if ( h1<=rec[i].b && h2<=rec[i].b && hh-yy>eps )\n                 return true;\n              return false;\n         }\n         if ( h1<rec[i].b && h2<rec[i].b ) continue;\n         if ( rec[i].l>xx ) continue;\n         if ( len/2<rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;\n         if ( h1-rec[i].b>eps && h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;\n         \n         if ( rec[i].r>xx )  continue;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\n\nconst double EPS = 1e-10;\nconst int MAX_N = 55;\nconst double g = 9.8;\n\n\n//一对抛物线\nstruct Para\n{\n\tbool t;\n\tdouble a[2];\n\tdouble b[2];\n};\n\n//点\nstruct P\n{\n\tdouble x;\n\tdouble y;\n};\n\n//矩形的顶点\nP rectp[MAX_N][4];\n\nint N, V, X, Y, _n;\n\n\nPara getpara(P p, int v);\n\nbool check(Para q);\n\nbool cmp(double & lb, double & rb, double & a);\n\nint main()\n{\n\tint L, B, R, T;\n\n\tcin >> N >> V >> X >> Y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> L >> B >> R >> T;\n\n\t\tif (L < X && T > (double)Y * L / X)\n\t\t{\n\t\t\tif (R > X)\n\t\t\t{\n\t\t\t\tR = X;\n\t\t\t}\n\n\t\t\trectp[_n][0].x = L;\n\t\t\trectp[_n][1].x = R;\n\t\t\trectp[_n][2].x = L;\n\t\t\trectp[_n][3].x = R;\n\n\t\t\trectp[_n][0].y = T;\n\t\t\trectp[_n][1].y = T;\n\t\t\trectp[_n][2].y = B;\n\t\t\trectp[_n][3].y = B;\n\n\t\t\t_n++;\n\t\t}\n\t}\n\n\tP t;\n\tt.x = X;\n\tt.y = Y;\n\n\tbool ans = false;\n\n\tif (check(getpara(t, V)))\n\t{\n\t\tans = true;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < _n; i++)\n\t\t{\n\t\t\tif (check(getpara(rectp[i][0], V)))\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (check(getpara(rectp[i][1], V)))\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ans)\n\t{\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t{\n\t\tcout << \"No\\n\";\n\t}\n\n\treturn 0;\n}\n\nPara getpara(P p, int v)\n{\n\tPara res;\n\n\tdouble D = v * v * (v * v - 2 * g * p.y) - g * g * p.x * p.x;\n\n\tif (D > 0)\n\t{\n\t\tres.t = true;\n\n\t\tD = sqrt(D);\n\t\tres.b[0] = (v * v + D) / (g * p.x);\n\t\tres.b[1] = (v * v - D) / (g * p.x);\n\n\t\tres.a[0] = (p.y - res.b[0] * p.x) / (p.x * p.x);\n\t\tres.a[1] = (p.y - res.b[1] * p.x) / (p.x * p.x);\n\t}\n\telse\n\t{\n\t\tres.t = false;\n\t}\n\n\treturn res;\n}\n\nbool check(Para q)\n{\n\tif (q.t)\n\t{\n\t\tbool ok = false;\n\t\tP cross;\n\n\t\tfor (int p = 0; p < 2; p++)\n\t\t{\n\t\t\tdouble tar = q.a[p] * X * X + q.b[p] * X;\n\n\t\t\tif (tar > Y - EPS)\n\t\t\t{\n\t\t\t\tok = true;\n\n\t\t\t\tfor (int i = 0; i < _n; i++)\n\t\t\t\t{\n\t\t\t\t\tif (rectp[i][0].x < X && rectp[i][1].x > X && Y <= rectp[i][2].y && tar >= rectp[i][0].y)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcross.x = rectp[i][0].x;\n\t\t\t\t\tcross.y = cross.x * (q.a[p] * cross.x + q.b[p]);\n\t\t\t\t\tif (cmp(rectp[i][2].y, rectp[i][0].y, cross.y))\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcross.x = rectp[i][1].x;\n\t\t\t\t\tcross.y = cross.x * (q.a[p] * cross.x + q.b[p]);\n\t\t\t\t\tif (cmp(rectp[i][3].y, rectp[i][1].y, cross.y))\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble D = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][0].y;\n\t\t\t\t\tif (D >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD = sqrt(D);\n\t\t\t\t\t\tcross.y = rectp[i][0].y;\n\n\t\t\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\t\t\tif (cmp(rectp[i][0].x, rectp[i][1].x, cross.x))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcross.x += D / q.a[p];\n\t\t\t\t\t\tif (cmp(rectp[i][0].x, rectp[i][1].x, cross.x))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tD = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][2].y;\n\t\t\t\t\tif (D >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD = sqrt(D);\n\t\t\t\t\t\tcross.y = rectp[i][2].y;\n\n\t\t\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\t\t\tif (cmp(rectp[i][2].x, rectp[i][3].x, cross.x))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcross.x += D / q.a[p];\n\t\t\t\t\t\tif (cmp(rectp[i][2].x, rectp[i][3].x, cross.x))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool cmp(double & lb, double & rb, double & a)\n{\n\treturn a > lb + EPS && a < rb - EPS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && yy-rec[i].b>eps && rec[i].t-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && hh-rec[i].b>eps && rec[i].t-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n         {\n              if ( rec[i].b-hi>eps ) return true;//抛物&#32447;没有&#30896;到矩形 \n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;从矩形上方&#39134;&#36807; \n              if ( rec[i].b-h1>eps && hh-rec[i].b>eps ) return false;//pig的&#23545;&#24212;点高于矩形的下&#36793;界\n              if ( len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps ) return false; //矩形最高点高于矩形下&#36793;界\n              \n              return true; \n         } \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(1){\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tallTH.push_back(89.9999/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<=x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-10\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=v,mid = (l+r)/2;\n     double t,vx,vy,len;\n     vy=v;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           vy=mid;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           len = vx*2*t;\n           if ( len<xx )\n              r=mid;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define sqr(x) ((x)*(x))\ntypedef pair<double,double> point;\n\nconst double g=9.8;\nconst double eps=1e-8;\ndouble v;\n\nstruct para\n{\n\tdouble a,b;\n\tpara(){a=b=0;}\n\tpara(double te){b=te;a=-g*(b*b+1)/2/v/v;}\n\tdouble qz(double x) {return a*x*x+b*x;}\n};\n\nvector<para> init(double x,double y)\n{\n\tvector<para> res;\n\tdouble at=g*x*x/2/v/v,bt=-x,ct=y+g/2/v/v*x*x;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(para(pbt));return res;}\n\tres.push_back(para(pbt+sqrt(pbs)/2/at));\n\tres.push_back(para(pbt-sqrt(pbs)/2/at));\n\treturn res;\n}\nvector<double> sol(double at,double bt,double ct)\n{\n\tvector<double> res;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(pbt);return res;}\n\tres.push_back(pbt+sqrt(pbs)/2/at);\n\tres.push_back(pbt-sqrt(pbs)/2/at);\n\treturn res;\n}\n\nstruct rect\n{\n\tdouble xl,xu,yl,yu;\n\trect(double xt=0,double yt=0,double xtt=0,double ytt=0):xl(xt),xu(xtt),yl(yt),yu(ytt){}\n};\n\nbool intersect(rect r,para p)\n{\n\tdouble t1=p.qz(r.xl),t2=p.qz(r.xu);\n\tif(t1>r.yl-eps&&t1<r.yu+eps) return true;\n\tif(t2>r.yl-eps&&t2<r.yu+eps) return true;\n\tvector<double> r1=sol(p.a,p.b,-r.yl);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\tr1=sol(p.a,p.b,-r.yu);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\treturn false;\n}\n\nint n;\nint v12,x12,y12;\ndouble x,y;\nvector<point> po;\nvector<rect> ret;\n\nvoid solve()\n{\n\tint i,j,k,l;\n\tv=v12;x=x12;y=y12;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tint xt[5];\n\t\tfor(j=0;j<4;j++) scanf(\"%d\",xt+j);\n\t\tif(xt[0]>xt[2]||xt[1]>xt[3]) continue;\n\t\tfor(j=0;j<4;j+=2) for(k=1;k<4;k+=2) if(xt[j]&&xt[k]) po.push_back(point(xt[j],xt[k]));\n\t       \tret.push_back(rect(xt[0],xt[1],xt[2],xt[3]));\n\t}\n\tpo.push_back(point(x,y));\n\tn=ret.size();\n\tfor(i=0;i<po.size();i++)\n\t{\n\t\tvector<para> tet=init(po[i].first,po[i].second);\n\t\tif(tet.empty()) continue;\n\t\tfor(l=0;l<tet.size();l++)\n\t\t{\n\t\t\tif(tet[l].qz(x)<y-eps) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(intersect(ret[j],tet[l])) break;\n\t\t\t}\n\t\t\tif(j<n) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tif(x>ret[j].xl+eps&&x<ret[j].xu-eps&&tet[l].qz(x)>ret[j].yl+eps&&y<ret[j].yl+eps) break;\n\t\t\tif(j<n) continue;\n\t\t\tprintf(\"Yes\\n\");return;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\nint main()\n{\n\twhile(scanf(\"%d %d %d %d\",&n,&v12,&x12,&y12)!=EOF)\n\t{solve();}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        if(l > X) continue;\n        if(r > X) r = X;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]-EPS && r>B[i]+EPS) return false;\n        if(l<T[i]-EPS && r>T[i]+EPS) return false;\n        if(l<B[i]-EPS && r<B[i]-EPS && yof(vy, vy/g)>B[i]+EPS) return false;\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i]) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <cstdio>\n# include <cmath>\n# include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double g = 9.8;\nconst int MAX_N = 50;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ninline double calc(double vy , double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\n\ninline int cmp(double lb , double ub , double a)\n{\n\treturn a < lb + EPS  ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check(double qx , double qy)\n{\n\tdouble a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n\tdouble D = b * b - 4 * a * c;\n\t\n\tif(D < 0 && D > -EPS)\n\t\tD = 0;\n\t\n\tif(D < 0)\n\t\treturn 0;\n\t\n\tint d, i;\n\tfor(d = -1 ; d <= 1 ; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\t\n\t\tif(t2 <= 0)\n\t\t\tcontinue;\n\t\t\t\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\t\t\n\t\tdouble yt = calc(vy , X / vx);\n\t\tif(yt < Y - EPS)\n\t\t\tcontinue;\n\t\t\t\n\t\tbool ok = 1;\n\t\tfor(i = 0 ; i < N ; i++)\n\t\t{\n\t\t\tif(L[i] >= X)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tif(R[i] == X && Y <= T[i] && B[i] <= yt)\n\t\t\t\tok = 0;\n\t\t\t\t\n\t\t\tint yL = cmp(B[i] , T[i] , calc(vy , L[i] / vx));\n\t\t\tint yR = cmp(B[i] , T[i] , calc(vy , R[i] / vx));\n\t\t\tint xH = cmp(L[i] , R[i] , vx * (vy / g));\n\t\t\tint yH = cmp(B[i] , T[i] , calc(vy , vy / g));\n\t\t\t\n\t\t\tif(yH == 0 && yH >= 0 && yL < 0 && yL < 0)\n\t\t\t\tok = 0;\n\t\t\t\t\n\t\t\tif(yL * yR <= 0)\n\t\t\t\tok = 0;\n\t\t}\n\t\tif(ok)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid solve()\n{\n\tint i;\n\tfor(i = 0 ; i < N ; i++)\n\t{\n\t\tR[i] = min(R[i] , X);\n\t}\n\t\n\tbool ok = check(X , Y);\n\t\n\tfor(i = 0 ; i < N ; i++)\n\t{\n\t\tok |= check(L[i] , T[i]);\n\t\tok |= check(R[i] , T[i]);\n\t}\n\t\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d %d %d\", &N, &V, &X, &Y))\n\t{\n\t\tint i;\n\t\tfor(i = 0 ; i < N ; i++)\\\n\t\t\tscanf(\"%d %d %d %d\", &L[i], &B[i], &R[i], &T[i]); \n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tdouble ta = allTAN[i];\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\t\tif(y<=allB[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "const double EPS = 1e-6;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        if(l > X) continue;\n        if(r > X) r = X;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  Created by TaoSama on 2016-08-22\n//  Copyright (c) 2016 TaoSama. All rights reserved.\n//\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n\nusing namespace std;\n#define pr(x) cout << #x << \" = \" << x << \"  \"\n#define prln(x) cout << #x << \" = \" << x << endl\nconst int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nconst double EPS = 1e-8, g = 9.8;\n\nint sgn(double x) {\n    return x < -EPS ? -1 : x > EPS;\n}\n\nint n;\ndouble V, X, Y;\ndouble L[N], B[N], R[N], T[N];\n\ndouble getY(double vy, double t) {\n    return vy * t - 0.5 * g * t * t;\n}\n\nbool check(double qx, double qy) {\n    if(sgn(qx) == 0) return false;\n\n    //vx^2 + vy^2 = v^2, vx * t = qx,  vy*t -0.5*g*t^2=qy\n    //qx^2+qy^2+qy*g*t^2+(0.5*g*t^2)^2-v^2*t=0\n    double a = g * g / 4, b = qy * g - V * V, c = qx * qx + qy * qy;\n\n    double delta = b * b - 4 * a * c;\n    if(sgn(delta) < 0) return false;\n    delta = sqrt(abs(delta));\n\n//  pr(qx); prln(qy);\n    for(int d = -1; d <= 1; d += 2) {\n        double t = (-b + d * delta) / (2 * a);\n        if(sgn(t) < 0) continue;\n        t = sqrt(abs(t));\n//        pr(d); prln(t);\n        double vx = qx / t, vy = (qy + 0.5 * g * t * t) / t;\n\n        double yt = getY(vy, X / vx);\n        if(sgn(yt - Y) < 0) continue;\n\n        bool ok = true;\n        for(int i = 1; i <= n && ok; ++i) {\n            if(sgn(L[i] - X) > 0) continue;\n\n            //target is in or below the obstacle\n            if(sgn(X - L[i]) > 0 && sgn(X - R[i]) < 0 &&\n                    sgn(yt - B[i]) > 0 && sgn(Y - T[i]) < 0) ok = false;\n\n            double yL = getY(vy, L[i] / vx), yR = getY(vy, R[i] / vx);\n            //hit left\n            if(sgn(yL - B[i]) > 0 && sgn(yL - T[i]) < 0) ok = false;\n            //hit right\n            if(sgn(yR - B[i]) > 0 && sgn(yR - T[i]) < 0) ok = false;\n\n            //highest point\n            double xH = min(vx * vy / g, R[i]), yH = getY(vy, xH / vx);\n            //hit inside, this time highest point is in or above the obstacle\n            if(sgn(yL - B[i]) < 0 && sgn(yH - B[i]) > 0) ok = false;\n\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\TaoSama\\\\Desktop\\\\in.txt\", \"r\", stdin);\n//  freopen(\"C:\\\\Users\\\\TaoSama\\\\Desktop\\\\out.txt\",\"w\",stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n\n    while(scanf(\"%d%lf%lf%lf\", &n, &V, &X, &Y) == 4) {\n        for(int i = 1; i <= n; ++i) {\n            scanf(\"%lf%lf%lf%lf\", L + i, B + i, R + i, T + i);\n            R[i] = min(R[i], X);\n        }\n\n        bool ok = check(X, Y);\n        for(int i = 1; i <= n && !ok; ++i) {\n            ok |= check(L[i], T[i]);\n            ok |= check(R[i], T[i]);\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=2*v,mid = (l+r)/2;\n     double h,t,vx,vy,len;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           //cout<<l<<\" \"<<r<<endl;\n           vy=mid;\n           if ( vy-v>eps )\n              break;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps )\n              r=mid;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               //cout<<a<<\" *** \"<<len<<\" \"<<h<<endl;\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              if ( rec[i].t>=yy && rec[i].r>=xx )\n                 flag=false;\n          }\n          if ( !flag )\n          {\n               printf(\"No\\n\");\n               continue;\n          }\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn dcmp(a-lb)<0?-1:dcmp(ub-a)<0?1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double g = 9.8;\t//??????????????? \nconst int MAX_N = 55; \n\n//?????\\ \nint N;\ndouble V, X, Y;\ndouble L[MAX_N], R[MAX_N], B[MAX_N], T[MAX_N];\n\n//????????\\vy??????????????´???????°????t?§????????????? \ndouble calc(double vy, double t){\n\treturn vy * t - g * t * t / 2;\n}\n\n//a??????lb???ub????????? \nint cmp(double lb, double ub, double a){\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n\n//??????????°???????????????????(qx, qy)??¶,????????????????????? \nbool check(double qx, double qy){\n \t/*  ??????????????¨x?????????y????????????????????????vx???vy,?????????(qx, qy)?????¶??´???t \n \t\t?±??§£??????????¨????vx^2 + vy^2 = V^2, vy * t = qx, vy * t - 1/2 g t^2 = qy\n \t\t\n\t\tVx^2 + Vy^2 = V^2;\n\t\tVx*t = Qx;\n\t\tVy*t - 1/2*g*t^2 = Qy;\n\t\t\n\t\t???x = t^2\n\t\t1/4*g^2*x^2 + (g*Qy - V^2)*x + Qx^2 + Qy^2 = 0;\n\t\ta = 1/4*g^2   b = g*Qy - V^2   c = Qx^2 + Qy^2\n\t\t\n\t*/\n \tdouble a = g * g / 4,  b = g * qy - V * V, c = qx * qx + qy * qy;\n \tdouble D = b * b - 4 * a * c;\n \tif(D < 0 && D > -EPS) D = 0;\t\t\t\t\t\t\t\t\t\n \tif(D < 0) return false;\t\t\t\t\t\t\t\t\t\t\t//????§£ \n \tfor(int d = -1; d <= 1; d += 2){\t\t\t\t\t\t\t\t//????????????????¨??????????????§£????????? \n \t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\t\t\t\t\t\n \t\tif(t2 <= 0) continue;\n \t\tdouble t = sqrt(t2);\n \t\tdouble vx = qx / t, vy = (qy + g * t * t / 2) / t;\n \t\t\n \t\t//??????????????????????????£??????\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //????????¨?????£???????????????????????´?????????????¢????\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //????????¨?£???°????????£??????????????????????????°????¢????\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //?????§???????????????\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //?????§???????????????\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //????????????????????????\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n\t}\n \treturn false;\n}\n \nvoid solve(){\n\t//???????????\\??????????¢???? \n \tfor(int i = 0; i < N; i++){\n \t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\t\t\t//??´??\\?????????????????? \n\tfor(int i = 0; i < N; i++){\n\t \tok |= check(L[i], T[i]);\t//?????????????§?????????? \n\t \tok |= check(R[i], T[i]);\t//?????????????§?????????? \n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\n \nint main(){\n \twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n \t\tfor(int i = 0; i < N; i++)\n \t\t\tscanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\t\n\t\tsolve();\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef complex<double> Point;\nconst double G = 9.8, EPS = 1.0e-11;\nint N;\ndouble V;\nPoint aim;\nvector<Point> L, R;\n\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1: a > ub - EPS ? 1: 0;\n}\nbool check(Point q) {\n    double qx = q.real(), qy = q.imag();\n    double a = G * G / 4, b = G * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -EPS) D = 0.0;\n    if(D < 0) return false;\n    for(int d = -1; d <= 1; d += 2) {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2.0) / t;\n\n        double yt = calc(vy, aim.real() / vx);\n        if(yt < aim.imag() - EPS) continue;\n\n        bool ok = true;\n        rep(i, N) {\n            if(L[i].real() >= aim.real()) continue;\n            if(R[i].real() == aim.real() && aim.imag() <= R[i].imag() && L[i].imag() <= yt) ok = false;\n            int yL = cmp(L[i].imag(), R[i].imag(), calc(vy, L[i].real() / vx));\n            int yR = cmp(L[i].imag(), R[i].imag(), calc(vy, R[i].real() / vx));\n            int xH = cmp(L[i].real(), R[i].real(), vx * (vy / G));\n            int yH = cmp(L[i].imag(), R[i].imag(), calc(vy, vy / G));\n            if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if(yL * yR <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> V >> aim.real() >> aim.imag();\n    L.resize(N); R.resize(N);\n    double a, b, c, d;\n    rep(i, N) {\n        cin >> a >> b >> c >> d;\n        L[i] = Point(a, b);\n        R[i] = Point(min(c, aim.real()), d);\n    }\n    bool ok = check(aim);\n    rep(i, N) {\n        ok |= check(L[i]);\n        ok |= check(R[i]);\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\n#define MAX_N 50\nconst double G = 9.8;\n#define EPS 1e-20\n\nint N,V,X,Y;\n// (L[i],B[i]) , (R[i],T[i]) // 左下,右上\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\n// 速度vyで上に打ち出した際のt秒後のy座標を計算する\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2;\n}\n\n// aのlbとubに対する相対的な位置\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n// 点(qx,qy)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool check(double qx, double qy) {\n    // 初速のx方向成分をvx,y方向成分をvyとし、(qx,qy)を通る時刻をtとしたときの連立方程式\n    // vx^2 + vy^2 = V^2, vx * t = qx, vy * t - 1/2 g t^2 = qy を解く\n    double a = 1.0/4.0 * G * G,\n           b = qy * G - V * V,\n           c = qx*qx + qy*qy;\n    double D = b*b - 4*a*c;\n    if(D<0 && D > -EPS) D = 0;\n    if(D<0) return false; // 虚数\n    for(int d=-1;d<=1;d+=2) { // 連立方程式の2つの解を試すループ\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2) / t;\n\n        // 豚より上を通過できるか判定\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS) continue;\n\n        bool ok = true;\n        for(int i=0;i<N;i++) {\n            if (L[i] >= X) continue;\n            // 豚の真上まで来たときに、間に障害物がないか判定\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            // 途中で障害物にぶつからないか判定\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx)); // 左端での相対位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx)); // 右端での相対位置\n            int xH = cmp(L[i], R[i], vx * (vy / G)); // 最も高くなる地点の相対位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / G));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    // 豚より右にある障害物を縮めておく\n    for(int i=0;i<N;i++) {\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y); // 直接ぶつける場合\n    for(int i=0;i<N;i++) {\n        ok |= check(L[i], T[i]); // 左上の角を通る場合\n        ok |= check(R[i], T[i]); // 右上の角を通る場合\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nmain() {\n    cin>>N>>V>>X>>Y;\n    for(int i=0;i<N;i++) {\n        cin>>L[i]>>B[i]>>R[i]>>T[i];\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-5;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y)) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstatic const double EPS = 1e-10;\nstatic const int MAX_N = 50;\nstatic const double G = 9.8;\n\nint N;\ndouble V, X, Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nint cmp(double a, double b, double x) {\n  if (x < a + EPS) return -1;\n  if (x > b - EPS) return 1;\n  return 0;\n}\n\nbool check(double tx, double ty) {\n  double a = (1.0 / 4.0) * G * G;\n  double b = G * ty - V * V;\n  double c = tx * tx + ty * ty;\n\n  double D = b * b - 4.0 * a * c;\n  if (abs(D) <= EPS) D = 0.0;\n  if (D < 0) return false;\n  for (int d = -1; d <= 1; d+=2) {\n    double t_squared = (-b + d * D) / (2.0 * a);\n    if (t_squared <= 0) continue;\n\n    // calc initial velocity to hit (tx, ty)\n    double t = sqrt(t_squared);\n    double vx = tx / t;\n    double vy = (ty + 0.5 * G * t * t) / t;\n\n    // check if the course is beyond pig\n    double pt = X / vx;\n    double py = vy * pt - 0.5 * G * pt * pt;\n    if (py < Y) continue;\n\n    // check if the course is clear\n    bool isClear = true;\n    for (int i = 0; i < N; i++) {\n      if (L[i] >= X) continue;\n      if (R[i] >= X && T[i] >= Y && B[i] <= py) {\n        isClear = false;\n        break;\n      }\n      double lt = L[i] / vx;\n      double ly = vy * lt - 0.5 * G * lt * lt;\n      double rt = R[i] / vx;\n      double ry = vy * rt - 0.5 * G * rt * rt;\n      int posL = cmp(B[i], T[i], ly);\n      int posR = cmp(B[i], T[i], ry);\n      if (posL * posR <= 0) {\n        isClear = false;\n        break;\n      }\n\n      double ht = vy / G;\n      int posX_high = cmp(L[i], R[i], vx * ht);\n      double hy = vy * ht - 0.5 * G * ht * ht;\n      int posH = cmp(B[i], T[i], hy);\n      if (posX_high == 0 && posH >= 0 && posL < 0) {\n        isClear = false;\n        break;\n      }\n    }\n    if (isClear) return true;\n  }\n  return false;\n}\n\nbool solve() {\n  if (check(X, Y)) return true;\n  for (int i = 0; i < N; i++) {\n    if (check(L[i], T[i]) || check(R[i], T[i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> V >> X >> Y;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n\n  bool isOK = solve();\n  cout << (isOK ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\nusing namespace std;\ntypedef long double ld;\ntypedef double db;\nconst int maxn = 100;\nconst ld g = 9.8;\nconst db eps = 1e-8;\nint n, v, x, y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\ndb calc(db vy, db t)\n{\n    return vy * t - g * t * t / 2;\n}\nint c1(db l, db r, db a)\n{\n    if (a < l + eps)\n        return -1;\n    if (a > r - eps)\n        return 1;\n    return 0;\n}\nbool check(ld qx, ld qy)\n{\n    ld a = g * g / 4, b = (g * qy - v * v), c = qx * qx + qy * qy;\n    ld delta = b * b - 4 * a * c;\n    if (delta <= 0 && delta > -eps)\n        delta = 0;\n    if (delta < 0)\n        return 0;\n    for (int d = -1; d < 1; d += 2)\n    {\n        ld t2 = (-b + d * sqrt(delta)) / 2 / a;\n        if (t2 <= 0)\n            continue;\n        ld t = sqrt(t2);\n        ld vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        ld yt = calc(vy, x / vx);\n        if (yt < y - eps)\n            continue;\n        bool ok = 1;\n        for (int i = 1; i <= n; i++)\n        {\n            if (L[i] >= x)\n                continue;\n            if (R[i] == x && y <= T[i] && B[i] <= yt)\n                ok = 0;\n            int yl = c1(B[i], T[i], calc(vy, L[i] / vx));\n            int yr = c1(B[i], T[i], calc(vy, R[i] / vx));\n            int xh = c1(L[i], R[i], vx * (vy / g));\n            int yh = c1(B[i], T[i], calc(vy, vy / g));\n            if (xh == 0 && yh >= 0 && yl < 0)\n                ok = 0;\n            if (yl * yr <= 0)\n                ok = 0;\n        }\n        if (ok)\n            return 1;\n    }\n    return 0;\n}\nint main()\n{\nios::sync_with_stdio(0);\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = min(R[i], x);\n    }\n    bool ans = check(x, y);\n    for (int i = 1; i <= n; i++)\n    {\n        ans |= check(L[i], T[i]);\n        ans |= check(R[i], T[i]);\n    }\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tdouble ta = allTAN[i];\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<=x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<=allB[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<cstring>\n#include<map>\n#include<set>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<time.h>\nusing namespace std;\nconst int INF=1<<30;\ntypedef long long ll;\nconst double eps=1e-6;\n\n\nconst double g=9.8;\n\nint n,m;\ndouble v,x,y;\n\nstruct point{\n    double x,y;\n};\n\nstruct Matrix{\n    point a,b,c,d;\n}e[100];\n\ndouble gety(double vy,double t){\n    return vy*t-0.5*g*t*t;\n}\n\nint cmp(int l,int r,int a){\n    return a<l?-1:a>r?1:0;\n}\n\nbool juge(point Q){\n    int i,j,k;\n    double a=0.25*g*g,b=g*Q.y-v*v,c=Q.x*Q.x+Q.y*Q.y;\n    double D=(b*b-4.0*a*c);\n    if(D<0&&D>-eps)D=0;\n    if(D<0)return false;\n    for(i=-1;i<=1;i+=2){\n        double t=(i*sqrt(D)-b)/(2.0*a);\n        if(t<=0)continue;\n        double t1=sqrt(t);\n        double vx=Q.x/t1,vy=(0.5*g*t+Q.y)/t1;\n        double yt=gety(vy,x/vx);\n        if(yt<y-eps)continue;\n\n        bool ok=true;\n        for(j=0;j<n;j++){\n            if(e[j].a.x>=x)continue;\n            if(yt>=e[j].a.y&&y<=e[j].c.y&&e[j].d.x==x)ok=false;\n\n            int yL=cmp(e[j].c.y,e[j].a.y,gety(vy,e[j].a.x/vx));\n            int yR=cmp(e[j].d.y,e[j].b.y,gety(vy,e[j].b.x/vx));\n            int xH=cmp(e[j].a.x,e[j].b.x,vx*(vy/g));\n            int yH=cmp(e[j].c.y,e[j].a.y,gety(vy,(vy/g)));\n            if(xH==0&&yH>=0&&yL<0)ok=false;\n            if(yL*yR<=0)ok=false;\n        }\n        if(ok)return true;\n    }\n    return false;\n}\n\nint main()\n{\n    int i,j;\n    cin>>n>>v>>x>>y;\n    int cnt=0;\n    for(i=0;i<n;i++){\n        double x1,y1,x2,y2;\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n        if(x1>=x)continue;\n        if(x2>x)x2=x;\n        point a,b,c,d;\n        a.x=x1,a.y=y2;\n        b.x=x2,b.y=y2;\n        c.x=x1,c.y=y1;\n        d.x=x2,d.y=y1;\n        e[cnt].a=a,e[cnt].b=b,e[cnt].c=c,e[cnt++].d=d;\n    }\n    n=cnt;\n    int ok=0;\n    point W;W.x=x,W.y=y;\n    if(juge(W))ok=1;\n    if(ok){\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    for(i=0;i<n;i++){\n        if(juge(e[i].a)||juge(e[i].b))ok=1;\n    }\n    if(ok)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define maxn 55\nconst double g=9.8;\ndouble EPS=1e-6;\nint N;\ndouble V, X ,Y;\ndouble L[maxn], B[maxn], R[maxn], T[maxn];\ndouble calc(double vy, double t) {\n    return vy*t-g*t*t/2;\n}\nint cmp(double lb, double ub, double a) {\n    return a<lb+EPS?-1:a>ub-EPS?1:0;\n}\nbool check(double qx, double qy) {\n    double a=g*g/4, b=g*qy-V*V, c=qx*qx+qy*qy;\n    double D=b*b-4*a*c;\n    if (D<0&&D>-EPS)\n        D=0;\n    if (D<0)\n        return false;\n    for (int d=-1; d<=1; d+=2) {\n        double t2=(-b+d*sqrt(D))/(2*a);\n        if (t2<=0)\n            continue;\n        double t=sqrt(t2);\n        double vx=qx/t, vy=(qy+g*t*t/2)/t;\n        double yt=calc(vy, X/vx);\n        if (yt<Y-EPS)\n            continue;\n        bool ok=true;\n        for (int i=0; i<N; i++) {\n            if (L[i]>=X)\n                continue;\n            if (R[i]==X&&Y<=T[i]&&B[i]<=yt)\n                ok=false;\n            int yL=cmp(B[i], T[i], calc(vy, L[i]/vx));\n            int yR=cmp(B[i], T[i], calc(vy, R[i]/vx));\n            int xH=cmp(L[i], R[i], vx*(vy/g));\n            int yH=cmp(B[i], T[i], calc(vy, vy/g));\n            if (xH==0&&yH>=0&&yL<0)\n                ok=false;\n            if (yL*yR<=0)\n                ok=false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\nvoid solve() {\n    for (int i=0; i<N; i++)\n        R[i]=min(R[i], X);\n    bool ok=check(X, Y);\n    for (int i=0; i<N; i++) {\n        ok|=check(L[i], T[i]);\n        ok|=check(R[i], T[i]);\n    }\n    puts(ok?\"Yes\":\"No\");\n}\nint main()\n{\n    scanf(\"%d%lf%lf%lf\", &N, &V, &X, &Y);\n    for (int i=0; i<N; i++)\n        scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst double G = 9.8;\nconst double EPS = 1e-4;\nconst int SIZE = 60;\n\nint N;\ndouble V, X, Y, vx, vy;\ndouble L[SIZE], R[SIZE], T[SIZE], B[SIZE] ;\n\ndouble getY( double x )\n{\n    double t = x/vx;\n    return vy*t-0.5*G*t*t;\n}\n\nbool check()\n{\n    double pigx = X, pigy = getY(pigx);\n    if ( pigy < Y ) return false;\n\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( L[i] < X )\n        {\n            double l = L[i], r = min(X, R[i]);\n            double y1 = getY(l), y2 = getY(r) ;\n            if ( y1 >= B[i] && y1 <= T[i] )\n                return false;\n            if ( y2 >= B[i] && y2 <= T[i] )\n                return false;\n            if ( y1 >= B[i] && y2 <= B[i] )\n                return false;\n            if ( y1 <= B[i] && y2 >= B[i] )\n                return false;\n            if ( y1 >= T[i] && y2 <= T[i] )\n                return false;\n            if ( y1 <= T[i] && y2 >= T[i] )\n                return false;\n        }\n        if ( L[i] <= X && X <= R[i] )\n        {\n            if ( B[i] <= Y && Y <= T[i] )\n                return false;\n            if ( B[i] <= Y && B[i] <= pigy )\n                return false;\n        }\n    }\n    return true;\n}\n\nbool solve( )\n{\n    for ( vx = EPS; vx < V; vx += EPS )\n    {\n        vy = sqrt( V*V-vx*vx );\n        if ( check() ) return true;\n    }\n    return false;\n}\n\nint main()\n{\n//    freopen(\"test.txt\",\"r\", stdin);\n    while ( scanf(\"%d%lf%lf%lf\", &N, &V, &X, &Y) != EOF )\n    {\n        for ( int i = 0; i < N; i ++ )\n        {\n            scanf( \"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i] );\n            if (L[i] > R[i]) swap(L[i], R[i]);\n            if (B[i] > T[i]) swap(B[i], T[i]);\n        }\n\n\n        if ( solve() ) puts(\"Yes\");\n        else puts(\"No\");\n\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB EPS = 1e-8;\nconst DB PI = acos(-1);\nconst DB gg = 9.8;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\n\n\ninline void checkMin(int &a, int b){\n    if (b < a) a = b;\n}\n\ninline int sgn(double x){\n    return x < -EPS ? -1 : x > EPS;\n}\n\nconst int N = int(1e2) + 9;\nint n, l[N], b[N], r[N], t[N];\nint X, Y; DB V; int low;\n\ninline DB y(DB a, DB x) {\n    DB t = x/(V*cos(a));\n    return V*sin(a)*t - 0.5*gg*t*t;\n}\n\ninline DB getM(DB a){\n    DB t = V*sin(a)/gg;\n    return V*cos(a)*t;\n}\n\nbool ck(DB a) {\n\n    DB h = y(a, X); if (sgn(h-Y) < 0 || sgn(h-low) > 0 ) return false;\n    DB mx = getM(a), my = y(a, mx);\n\n    REP(i, n){\n\n        DB h1 = y(a, l[i]), h2 = y(a, r[i]);\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (!(h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (!(h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n    }\n    return true;\n}\n\nbool ck() {\n\n    REP(i, n){\n        if (l[i] == 0 && b[i] == 0) return false;\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n    }\n\n    DB d = PI/2/15000;\n    for (DB a=d;a<=PI/2;a+=d) if (ck(a)) return true;\n    return false;\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    while (~scanf(\"%d%lf%d%d\", &n, &V, &X, &Y)) {\n        low = INF; REP(i, n){\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] > X){\n                --i; --n;\n                continue;\n            }\n            if (r[i] >= X){\n                if (b[i] >= Y) checkMin(low, b[i]);\n                r[i] = X;\n            }\n        }\n        puts(ck() ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int maxn = 55;\nconst double eps = 1e-10, inf = 1e5, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\ndouble MaxAc;\nV all;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init(int T)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n\tif (0 && T == 191)\n\t{\n\t\tfreopen(\"in\", \"w\", stdout);\n\t\tprintf(\"%d %lf %lf %lf\\n\", n, v, X, Y);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%lf %lf %lf %lf\\n\", x[i][0], y[i][0], x[i][1], y[i][1]);\n\t\texit(0);\n\t}\n}\n\n// sign == 0: >= 0\n// sign == 1: <= 0\nvoid cal(double a, double b, double c, int sign, V &vec)\n{\n\tif (sign)\n\t\ta = -a, b = -b, c = -c;\n\tvec.clear();\n\tif (!dcmp(a))\n\t{\n\t\tif (!dcmp(b))\n\t\t{\n\t\t\tif (dcmp(c) >= 0)\n\t\t\t{\n\t\t\t\tvec.push_back(make_pair(-inf, +1));\n\t\t\t\tvec.push_back(make_pair(+inf, -1));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tdouble d = -c/b;\n\t\tif (dcmp(b) < 0)\n\t\t{\n\t\t\twhile (d < -inf);\n\t\t\tvec.push_back(make_pair(-inf, +1));\n\t\t\tvec.push_back(make_pair(d, -1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (d > inf);\n\t\t\tvec.push_back(make_pair(d, +1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\tdouble delta = b*b - 4*a*c;\n\tif (dcmp(delta) <= 0)\n\t{\n\t\tif (dcmp(a) > 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, 1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\n\tdelta = sqrt(delta);\n\tdouble t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n\tif (dcmp(t1-t2) > 0) swap(t1, t2);\n\tdouble f1 = a*t1*t1 + b*t1 + c;\n\tdouble f2 = a*t2*t2 + b*t2 + c;\n\n\twhile (t1<-inf);\n\twhile (t2>inf);\n\tif (dcmp(a) > 0)\n\t{\n\t\tvec.push_back(make_pair(-inf, +1));\n\t\tvec.push_back(make_pair(t1, -1));\n\t\tvec.push_back(make_pair(t2, +1));\n\t\tvec.push_back(make_pair(inf, -1));\n\t}\n\telse\n\t{\n\t\tvec.push_back(make_pair(t1, +1));\n\t\tvec.push_back(make_pair(t2, -1));\n\t}\n}\n\nvoid Bing(V vecs[], int n, V &vec)\n{\n\tvec.clear();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < vecs[i].size(); j++)\n\t\t{\n\t\t\tvec.push_back(vecs[i][j]);\n\t\t\tif (vecs[i][j].second > 0)\n\t\t\t\tvec.back().second = +(i+1);\n\t\t\telse\n\t\t\t\tvec.back().second = -(i+1);\n\t\t}\n\t}\n}\n\nV And(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tLL need = (1LL<<n) - 1;\n\tneed <<= 1;\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\n\t\tif (mask == need)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nV Or(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\t\tif (mask)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nV Exclusive(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\t\tif (mask == 2)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid show(V &v)\n{\n\tfor (int i = 0; i < v.size(); i += 2)\n\t\tprintf(\"%lf ~ %lf\\n\", v[i].first, v[i+1].first);\n}\n\nvoid add(double x1, double x2, double y, int sign, V &vec)\n{\n\tvec.clear();\n\n\tdouble p = g / (2 * v * v);\n\tstatic V tmp[4], tmp2[2];\n\tstatic V mid[2];\n\n\tcal(2*p*x1, -1, 2*p*x1, 1, tmp[0]);\n\tcal(2*p*x2, -1, 2*p*x2, 0, tmp[1]);\n\n\tmid[0] = all;\n\tmid[1] = And(tmp, 2);\n\n\tV &Mid = mid[1];\n\tV Other = Exclusive(mid, 2);\n\n\ttmp[0] = Mid;\n\tcal(1-4*p*y, 0, -4*p*y, sign, tmp[1]);\n\tcal(-p*x1*x1, x1, -p*x1*x1 - y, sign, tmp[2]);\n\tcal(-p*x2*x2, x2, -p*x2*x2 - y, sign, tmp[3]);\n\ttmp2[0] = And(tmp, 4);\n\n\ttmp[0] = Other;\n\tcal(-p*x1*x1, x1, -p*x1*x1 - y, sign, tmp[1]);\n\tcal(-p*x2*x2, x2, -p*x2*x2 - y, sign, tmp[2]);\n\ttmp2[1] = And(tmp, 3);\n\n\tvec = Or(tmp2, 2);\n}\n\nbool judge(double l, double r)\n{\n\tdouble p = g / (2*v*v);\n\tdouble a = -p*X*X, b = X, c = -p*X*X;\n\n\t//\tprintf(\"%.2lf %.2lf %.2lf\\n\", a, b, c);\n\tdouble fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n\tdouble t = -b / (2 * a);\n\tdouble Min = min(fl, fr);\n\tdouble Max = max(fl, fr);\n\tdouble ft = a*t*t + b*t + c;\n\tif (dcmp(t-l) >= 0 && dcmp(t-r) <= 0)\n\t\tMax = ft;\n\n\t//printf(\"l(%.2lf) ~~ r(%.2lf)\\n\", l, r);\n\t//printf(\"Min = %.2lf Max = %.2lf\\n\", Min, Max);\n\t//printf(\"Y = %.2lf MaxAc = %.2lf\\n\", Y, MaxAc);\n\t//puts(\"\");\n\n\treturn dcmp(Y-Min) >= 0 && dcmp(Y-Max) <= 0 || dcmp(MaxAc-Min) >= 0 && dcmp(MaxAc-Max) <= 0;\n}\n\nbool solve()\n{\n\tif (!dcmp(v))\n\t\treturn false;\n\n\tstatic V res[maxn];\n\n\tint m = 0;\n\tMaxAc = inf;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp(X-x[i][0]) > 0 && dcmp(X-x[i][1]) < 0)\n\t\t{\n\t\t\tif (dcmp(y[i][1]-Y) >= 0)\n\t\t\t\tMaxAc = min(MaxAc, y[i][0]);\n\t\t}\n\t\tif (dcmp(x[i][0]-X) < 0)\n\t\t{\n\t\t\tx[i][1] = min(X, x[i][1]);\n\t\t\tstatic V tmp[2];\n\t\t\tadd(x[i][0], x[i][1], y[i][0], 1, tmp[0]);\n\t\t\tadd(x[i][0], x[i][1], y[i][1], 0, tmp[1]);\n\t\t\tres[m++] = Or(tmp, 2);\n\t\t}\n\t}\n\tres[m++] = all;\n\n//\tprintf(\"%lf %lf\\n\", Y, MaxAc);\n\tif (dcmp(MaxAc-Y) < 0)\n\t\treturn false;\n\n\tV suf = And(res, m);\n\tfor (int i = 0; i < suf.size(); i += 2)\n\t\tif (judge(suf[i].first, suf[i+1].first))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main()\n{\n\tall.push_back(make_pair(-inf, +1));\n\tall.push_back(make_pair(+inf, -1));\n//\tfreopen(\"out1\", \"w\", stdout);\n\tint T = 0;\n\twhile (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n\t{\n\t\tinit(++T);\n\t\tputs(solve()? \"Yes\": \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size()-1; i++){\n\t\t\tdouble ta = (allTAN[i] + allTAN[i+1])/2;\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\t\tif(y<=allB[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n      /*\n      cout << \"sine \" << vy << \",\" << top_t << \" = \" << getY(vy,top_t) << endl;\n      cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n      */\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %lf %lf %lf\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%lf %lf %lf %lf\",L+i,B+i,R+i,T+i);\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-7;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0; rad < M_PI / 2.0; rad += 0.0000001){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(!((double)gy - EPS <= y && y <= (double)gy + EPS)){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(y1 < 0 || y2 < 0){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y1 + EPS\n             || (double)obstacles[i].top_y < y1 - EPS)){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y2 + EPS\n             || (double)obstacles[i].top_y < y2 - EPS)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size()-1; i++){\n\t\t\tdouble ta = (allTAN[i] + allTAN[i+1])/2;\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\t\tif(y<allB[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=200000;i++ )\n     {\n           vy=double(i)/200000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB eps = 1e-8;\nconst int N = 150007;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\n\nconst double PI = acos(-1);\nconst double gg = 9.8;\n\n//double CalcMaxCeta(double X) {\n//    double l = 0.0, r = PI / 2;\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid1 = l + (r - l) / 3.0;\n//        double mid2 = r - (r - l) / 3.0;\n//        if (CalcHeight(mid1, X) > CalcHeight(mid2, X)) {\n//            l = mid2;\n//        } else {\n//            r = mid1;\n//        }\n//    }\n//    return l;\n//}\n//\n//double BinarySearch(bool op, double l, double r, double X, double Y) {\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid = (l + r) / 2.0;\n//        double height = CalcHeight(mid, X);\n//        if (op == 0) { // ascending\n//            if (height > Y) r = mid; else l = mid;\n//        } else { // descending\n//            if (height > Y) l = mid; else r = mid;\n//        }\n//    }\n//}\n\n\ndouble V;\nint low;\n\nint sgn(double x){\n    return x < -eps ? -1 : x > eps;\n}\n\n\ninline double CalcHeight(double ceta, double X) {\n    double t = X / (V * cos(ceta));\n    double y = (V * sin(ceta)) * t - 0.5 * gg * t * t;\n    return y;\n}\n\ninline double GetM(double ceta) {\n    double t = V * sin(ceta) / gg;\n    return V * cos(ceta) * t;\n}\n\n\nint n, X, Y, l[N], b[N], r[N], t[N];\n\nbool Gao(double ceta) {\n    double hh = CalcHeight(ceta, X);\n//    cout << ceta << ' ' << X << ' ' << hh << ' ' << Y << ' ' << low << endl;\n    if (sgn(hh - Y ) < 0  || sgn(hh-low) > 0 )  {\n        return false;\n    }\n//    cout << \"~\";\n\n    double mx = GetM(ceta);\n    double my = CalcHeight(ceta, mx);\n\n\n    for (int i = 1; i <= n; i ++) {\n        if (l[i] > X) continue;\n\n        DB h1 = CalcHeight(ceta, l[i]);\n        DB h2 = CalcHeight(ceta, r[i]);\n\n\n        //cout << h1 << \" \" << h2 <<\" \" << mx << \" \"<< my << endl;\n\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (! (h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (! (h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n\n\n\n        /*double delta = (r[i] - l[i]) / 100.0;\n        int sum1 = 0, sum2 = 0;\n        for (int j = 0; j < 100; j ++) {\n            double ss = delta * j + l[i];\n            double h3 = CalcHeight(ceta, ss);\n            sum1 += sgn(h3 - b[i]);\n            sum2 += sgn(h3 - t[i]);\n        }\n        if (sum1 == -100 || sum2 == 100) {\n        } else {\n            return false;\n        }*/\n    }\n    return true;\n}\n\nbool Check() {\n//    double maxCeta = CalcMaxCeta(X);\n//    double maxHeight = CalcHeight(maxCeta, X);\n//    if (maxHeight < Y) {\n//        return false;\n//    }\n//    if (Gao(PI / 4.0)) return true;\n    if (X == 0 && Y == 0) {\n        return true;\n    }\n    else if (X == 0){\n        double hhh = CalcHeight(PI / 2, 0);\n        if (sgn(hhh - Y) < 0) return false;\n        for (int i = 1; i <= n; i ++) {\n            if (l[i] == 0 && b[i] <= Y)\n                return false;\n        }\n        return true;\n    }\n    for (int i = 1; i <= n; i ++){\n        if (l[i] == 0 && b[i] == 0) {\n            return false;\n        }\n\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n\n    }\n    for (double i = 0, delta = PI / 2 / 15000.0; i <= PI / 2; i += delta) {\n        if (Gao(i)) return true;\n    }\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (scanf(\"%d%lf%d%d\", &n, &V, &X, &Y) == 4) {\n        low = INF;\n        //n = 0;\n        for (int i = 1; i <= n; i ++) {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (r[i] >= X) r[i] = X;\n            if (l[i] <= X && X <= r[i]) {\n                if (Y >= t[i])continue;\n                low = min(low, (int)b[i]);\n            }\n        }\n//        cout << low << endl;\n        if (Check()) puts(\"Yes\");\n        else puts(\"No\");\n//        break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 55;\nconst double g = 9.8;   //重力加速度\nconst double EPS = 1e-10;\nint N;\ndouble V, X, Y;\ndouble L[maxn], B[maxn], R[maxn], T[maxn];\n\n//&#35745;算以vy的速度&#31446;直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相&#23545;lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//判断当射出路径&#32463;&#36807;点(qx, qy)&#26102;，卵是否能&#20987;中猪\nbool check(double qx, double qy)\n{\n    //&#35774;初速度在x方向和y方向的分量分&#21035;&#20026;vx和vy，&#35774;通&#36807;(qx, qy)的&#26102;&#38388;&#20026;t\n    //&#35774;解&#32852;立方程式vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //&#39564;&#35777;&#32852;立方程式上的&#20004;个解的循&#29615;\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //判断是否通&#36807;猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //判断在猪正上方的&#40479;和猪之&#38388;是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //判断在&#39134;到猪的正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //左&#20391;的相&#23545;位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //右&#20391;的相&#23545;位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //最高点的相&#23545;位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    //截掉猪以右的障碍物\n    for (int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);      //直接撞上猪的情况\n    for (int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);     //&#32463;&#36807;左上角的情况\n        ok |= check(R[i], T[i]);     //&#32463;&#36807;右上角的情况\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\", &N, &V, &X, &Y) != EOF){\n        for (int i = 0; i < N; i++){\n            scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double g = 9.8;\t//??????????????? \nconst int MAX_N = 55; \n\n//?????\\ \nint N;\ndouble V, X, Y;\ndouble L[MAX_N], R[MAX_N], B[MAX_N], T[MAX_N];\n\n//????????\\vy??????????????´???????°????t?§????????????? \ndouble calc(double vy, double t){\n\treturn vy * t - g * t * t / 2;\n}\n\n//a??????lb???ub????????? \nint cmp(double lb, double ub, double a){\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n\nbool check(double qx, double qy)\n{\n    //??????????????¨x?????????y????????????????????????vx???vy????????????(qx, qy)?????¶??´???t\n    //????§£??????????¨????vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //????????????????¨?????????????????§£?????????\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //??????????????????????????£??????\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //????????¨?????£???????????????????????´?????????????¢????\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //????????¨?£???°????????£??????????????????????????°????¢????\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //?????§???????????????\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //?????§???????????????\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //????????????????????????\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\n \nvoid solve(){\n\t//???????????\\??????????¢???? \n \tfor(int i = 0; i < N; i++){\n \t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\t\t\t//??´??\\?????????????????? \n\tfor(int i = 0; i < N; i++){\n\t \tok |= check(L[i], T[i]);\t//?????????????§?????????? \n\t \tok |= check(R[i], T[i]);\t//?????????????§?????????? \n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\n \nint main(){\n \twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n \t\tfor(int i = 0; i < N; i++)\n \t\t\tscanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\t\n\t\tsolve();\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tdouble ta = allTAN[i];\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<=x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<set>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\ndouble v;\nconst double g=9.8;\nconst double eps=1e-8;\nint dcmp(double x)\n{\n\tif(x<-eps) return -1;\n\treturn x>eps;\n}\n\nstruct para\n{\n\tdouble ta;\n\tdouble a,b;\n\tpara(double te=0):ta(te){b=tan(ta);a=-g/2/v/v*(b*b+1);}\n\tpara(double x,double y,int ty)\n\t{\n\t\tdouble at=g*x*x/2/v/v,bt=-x,ct=y+g*x*x/2/v/v;\n\t\tdouble sqt=bt*bt-4*at*ct;\n\t\tif(sqt<-eps||fabs(at)<eps) a=b=ta=0;\n\t\telse\n\t\t{\n\t\t\tta=atan(-bt/2/at+ty*sqrt(sqt)/2/at);\n\t\t\tb=-bt/2/at+ty*sqrt(sqt)/2/at;a=-g/2/v/v*(b*b+1);\n\t\t}\n\t}\n\tdouble qz(double x)\n\t{\n\t\treturn a*x*x+b*x;\n\t}\n};\n\nstruct sq\n{\n\tdouble xu,xl,yu,yl;\n\tsq(double a=0,double b=0,double c=0,double d=0):xl(a),yl(b),xu(c),yu(d){}\n};\n\nvector<double> sol(double a,double b,double c)\n{\n\tvector<double> tep;\n\tdouble sqt=b*b-4*a*c;\n\tif(dcmp(a)==0||dcmp(sqt)<0) return tep;\n\ttep.push_back(-b/2/a+sqrt(sqt)/2/a);\n\tif(dcmp(sqt)==0) return tep;\n\ttep.push_back(-b/2/a-sqrt(sqt)/2/a);\n\treturn tep;\n}\n\nbool intersect(para a,sq b)\n{\n\tdouble te=a.qz(b.xl);\n\tif(dcmp(te-b.yl)>0&&dcmp(b.yu-te)>0) return true;\n\tte=a.qz(b.xu);\n\tif(dcmp(te-b.yl)>0&&dcmp(b.yu-te)>0) return true;\n\tvector<double> tet=sol(a.a,a.b,-b.yl);\n\tif((int)tet.size()==2)\n\t{\n\t\tdouble tt1=tet[1],tt2=tet[0];\n\t\tif(dcmp(tt1-tt2)>0) swap(tt1,tt2);\n\t\tif(dcmp(tt1-b.xl)>=0&&dcmp(tt1-b.xu)<0) return true;\n\t\tif(dcmp(tt2-b.xl)>0&&dcmp(tt2-b.xu)<=0) return true;\n\t}\n\ttet=sol(a.a,a.b,-b.yu);\n\tif((int)tet.size()==1)\n\t{\n\t\tdouble ttt=tet[0];\n\t\tif(dcmp(ttt-b.xl)>=0&&dcmp(ttt-b.xu)<=0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\ndouble x,y;\nsq s[205];\n\nvoid solve()\n{\n\tint i,j;\n\tpara te(x,y,1);\n\tfor(j=0;j<n;j++) if(intersect(te,s[j])) break;\n\tif(j==n)\n\t{\n\t\tdouble qt=te.qz(x);\n\t\tif(dcmp(qt-y)>=0)\n\t\t{\t\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t}\n\tte=para(x,y,-1);\n\tfor(j=0;j<n;j++) if(intersect(te,s[j])) break;\n\tif(j==n)\n\t{\n\t\tdouble qt=te.qz(x);\n\t\tif(dcmp(qt-y)>=0)\n\t\t{\t\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t}\n\tif(n==0) {printf(\"Yes\\n\");return;}\n\tpara tet;\n\tfor(i=0;i<n;i++)\n\t{\n\t\ttet=para(s[i].xl,s[i].yl,1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xl,s[i].yl,-1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xu,s[i].yl,1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xu,s[i].yl,-1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xl,s[i].yu,1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xl,s[i].yu,-1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xu,s[i].yu,1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t\ttet=para(s[i].xu,s[i].yu,-1);\n\t\tfor(j=0;j<n;j++) if(intersect(tet,s[j])) break;\n\t\tif(j==n)\n\t\t{\n\t\t\tdouble qt=tet.qz(x);\n\t\t\tif(dcmp(qt-y)<0) continue;\n\t\t\tfor(j=0;j<n;j++) if(dcmp(s[j].xl-x)<=0&&dcmp(s[j].xu-x)>=0&&(dcmp(s[j].yl-y)>=0||dcmp(s[j].yu-y)>=0)&&dcmp(qt-s[j].yl)>=0) break;\n\t\t\tif(j==n) {printf(\"Yes\\n\");return;}\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\n\nint main()\n{\n\tint i,j,k;\n\tscanf(\"%d %lf %lf %lf\",&n,&v,&x,&y);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tdouble a,b,c,d;\n\t\tscanf(\"%lf %lf %lf %lf\",&a,&b,&c,&d);\n\t\ts[i]=sq(a,b,c,d);\n\t}\n\tsolve();\n//\tscanf(\"%d\",&i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n\ntypedef long long ll;\ndouble EPS = 1e-6;\nconst double g = 9.8;\nconst int N = 50;\nint n, v, X, Y;\nint L[N], R[N], T[N], B[N];\n\n//速度vyで上に打ち出した際のt秒後の位置を計算\ndouble calc(double vy, double t) {\n\treturn vy*t - g*t*t*0.5;\n}\n\n//aのlb,ubに対する相対位置関係(lbより下:-1, lb以上ub以下:0, ubより上:1)\nint relPos(double lb, double ub, double a) {\n\treturn a < lb+EPS ? -1 : (a > ub-EPS ? 1 : 0);\n}\n\n//点(x,y)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool success(double x, double y) {\n\tdouble a = g*g*0.25, b = g*y-v*v, c = x*x+y*y;\n\tdouble D = b*b - a*c*4.0;\n\n\tif (D<0.0 && D>-EPS) D = 0.0;\n\tif (D<0.0) return false;\n\n\tfor (int d=-1; d<=1; d+=2) {\n\t\tdouble t2 = (-b + d*sqrt(D)) / (a*2.0);\n\t\tif (t2<=0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t, vy = (y + g*t*t*0.5) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y-EPS) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (L[i]>=X) continue;\n\n\t\t\tif (L[i]<=X && X==R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n//\t\t\tif (X==R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n\n\t\t\tint yL = relPos(B[i], T[i], calc(vy, L[i]/vx));\n\t\t\tint yR = relPos(B[i], T[i], calc(vy, R[i]/vx));\n\t\t\tint xH = relPos(L[i], R[i], vx*(vy/g));\n\t\t\tint yH = relPos(B[i], T[i], calc(vy, vy/g));\n\n\t\t\tif (xH==0 && yH>=0 && yL<0) ok = false;\n\t\t\tif (yL*yR<=0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\n\tscanf(\"%d%d%d%d \", &n, &v, &X, &Y);\n\tfor (int i=0; i<n; i++)\n\t\tscanf(\"%d%d%d%d \", L+i, B+i, R+i, T+i);\n\n\t//爆撃成功後に障害物に当っても成功とみなすために\n\t//Xより右にある障害物を消す\n\tfor (int i=0; i<n; i++)\n\t\tR[i] = min(R[i], X);\n\n\tbool ok = success(X, Y);\n\n\tfor (int i=0; i<n; i++) {\n\t\tok |= success(L[i], T[i]);\n\t\tok |= success(R[i], T[i]);\n\t}\n\n\tputs(ok ? \"Yes\" : \"No\");\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-6;\nconst double EPSB = 1e-10;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nbool is_up(double rad, double x){\n  return x < calc_x_y0(rad) / 2.0 - EPS;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPSB){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  //if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPSB){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n\n  //printf(\"%.10f\\n\", calc_y(res2, real(target)));\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPSB){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    double y[2] = {imag(rv[i].ll), imag(rv[i].ur)};\n    if(x[0] > real(target) + EPS) continue;\n    if(calc_y(rad, x[0]) < y[0] - EPS && calc_y(rad, x[1]) > y[0] + EPS || calc_y(rad, x[0]) > y[1] + EPS && calc_y(rad, x[1]) < y[1] - EPS) return true;\n    if(calc_y(rad, x[0]) > y[0] + EPS && calc_y(rad, x[0]) < y[1] - EPS) return true;\n    if(equal(calc_y(rad, x[0]), y[0]) && is_up(rad, x[0]) || equal(calc_y(rad, x[1]), y[1]) && !is_up(rad, x[1])) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) {\n      //cout << calc_res[i] * 180.0 / M_PI << endl;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\n\nint N;\ndouble V,X,Y;\ndouble Max,Min;\nvector<double> L,B,R,T;\n\npair<double,double> calc(double X,double Y){\n\tdouble a=1.0/2.0*g*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*g*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || a-eps<0)\n\t\treturn make_pair(-1.0,-1.0);\n\tdouble ans1=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n\tdouble ans2=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n\treturn make_pair(ans1,ans2);\n}\n\nvoid solve()\n{\n\tvector<double> VT;\n\tL.resize(N);B.resize(N);R.resize(N);T.resize(N);\n\tfor(int i=0;i<N;i++)\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\tpair<double,double>p1=calc(X,Y);\n\tif(p1.first<0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tMax=p1.second;\n\tMin=p1.first;\n\tVT.push_back(Min);\n\tfor(int i=0;i<N;i++){\n\t\tpair<double,double>tp=calc(L[i],T[i]);\n\t\tif(tp.first>0 && tp.first<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.first);\n\t\ttp=calc(R[i],T[i]);\n\t\tif(tp.second>0 && tp.second<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.second);\t\n\t}\n\tfor(int i=0;i<VT.size();i++){\n\t\tbool ok=true;\n\t\tdouble center=VT[i]*V*V/g/(1.0+VT[i]*VT[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*VT[i]-1.0/2.0*g*L[j]*L[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tMy=R[j]*VT[i]-1.0/2.0*g*R[j]*R[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center<R[j]-eps)\n\t\t\t\tMy=center*VT[i]-1.0/2.0*g*center*center/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>B[j] || My<T[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <complex>\nusing namespace std;\nconst double eps  = 1e-9;\ntypedef complex<double> Point;\ntypedef Point Vector;\n\nint dcmp(double d)\n{\n    if(fabs(d) < eps) return 0;\n    return d < 0 ? -1 : 1;\n}\n\nbool operator<(const Point &a, const Point &b)\n{\n    return dcmp(real(a)-real(b)) < 0 || dcmp(real(a)-real(b)) == 0 && dcmp(imag(a)-imag(b)) < 0;\n}\nbool cmp(const Point &a, const Point &b)\n{\n    return a<b;\n}\n\nint n,v,X,Y;\nPoint p1[110],p2[110];\nPoint pig;\nconst double g = 9.8;\n\ndouble geth(double v, double t)\n{\n    return v*t-g/2*t*t;\n}\n\nint cmp(double a, double b, double c)\n{\n    if(dcmp(c-a) < 0) return -1;\n    if(dcmp(c-b) > 0) return 1;\n    return 0;\n}\n\nbool check1(double tt, double x, double y)\n{\n    double t = sqrt(tt);\n    double vx = x/t, vy = (y+g*tt/2)/t;//求x方向和y方向的速度\n    // bool flag = true;\n    //判断抛物?是否在目?点的上方，如果在下方?肯定不可能\n    double ttt = X/vx;\n    double yy = geth(vy, ttt);\n    if(dcmp(yy-Y) < 0) return false;\n    for(int i = 0; i < n; i++)\n    {\n        double lx = real(p1[i]), ly = imag(p1[i]);\n        double rx = real(p2[i]), ry = imag(p2[i]);\n        double tl = lx/vx, tr = rx/vx;\n        if(dcmp(lx-X) >= 0) continue;//在X右?的障碍物不会有影?\n        if(dcmp(rx-X) == 0 && dcmp(Y-ry) <= 0 && dcmp(yy-ly) >= 0)//障碍物?住了下落的路\n            return false;\n        //判断障碍物是否在猪之前阻碍了??路?`\n        int yL = cmp(ly, ry, geth(vy, tl));\n        int yR = cmp(ly, ry, geth(vy, tr));\n        int xH = cmp(lx, rx, vx*(vy/g));\n        int yH = cmp(ly, ry, geth(vy, vy/g));\n        if(xH == 0 && yH >= 0 && yL < 0) return false;\n       // cout<<1<<endl;\n        if(yL*yR <= 0) return false;\n\n    }\n    return true;\n}\nbool check(Point p)\n{\n    double x = real(p), y = imag(p);\n    double a = g*g/4, b = g*y-v*v, c = x*x+y*y;\n    double delta = b*b-4*a*c;\n    double t1,t2;\n    if(dcmp(delta) < 0)\n        return false;\n    t1 = (-b+sqrt(delta))/(2*a);\n    t2 = (-b-sqrt(delta))/(2*a);\n    double vx = x/sqrt(t1), vy = (y+g*t1/2)/sqrt(t1);\n    //cout<<vx<<endl;\n    //cout<<vy<<endl;\n    if(t1 >= 0 && check1(t1,x,y)) return true;\n\n    if(t2 >= 0 && check1(t2,x,y)) return true;\n    //cout<<\"\\t\"<<1<<endl;\n    return false;\n}\n\nint main()\n{\n   // freopen(\"in.txt\", \"r\", stdin);\n    while(scanf(\"%d%d%d%d\", &n, &v, &X, &Y) == 4)\n    {\n        pig  = Point(X,Y);\n        //cout<<pig<<endl;\n        for(int i = 0; i < n; i++)\n        {\n            double x1,y1,x2,y2;\n            scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n            x2 = min(x2, (double)X);\n            p1[i] = Point(x1,y1);\n            p2[i] = Point(x2,y2);\n        }\n        bool flag = check(pig);\n       // cout<<flag<<endl;\n        for(int i = 0; (!flag) && i < n; i++)\n        {\n            flag |= check(Point(real(p2[i]), imag(p1[i])));\n            flag |= check(p2[i]);\n        }\n        printf(\"%s\\n\", flag?\"Yes\":\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n    \n    int comp(double lb, double ub, double x){\n        if(x < lb + EPS) return -1;\n        if(x > ub - EPS) return 1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            // テ」ツδ禿」ツつーテ」ツ?ォテ・ツ債オテ」ツ?古・ツスツ禿」ツ?淌」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                if(x1[i] < gx && gx < x2[i] && fh > y1[i] && y1[i] >= gy) {\n                    ok = false;\n                }\n            }\n            // テ」ツδ氾」ツつーテ」ツ?ョテ、ツクツ甘ァツゥツコテ」ツ?セテ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                int yl = comp(y1[i], y2[i], calc_y(vx, vy, x1[i]));\n                int yr = comp(y1[i], y2[i], calc_y(vx, vy, x2[i]));\n                int xh = comp(x1[i], x2[i], vx * vy / g);\n                int yh = comp(y1[i], y2[i], calc_y(vx, vy, vx * vy / g));\n                if(xh == 0 && yh >= 0 && yl <= 0) ok = false;\n                if(yl * yr <= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\n\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\ndouble Max,Min;\nvector<double> Tan;\n\n\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<eps || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/1);\n};\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=max(OB,B[i]);\n\t}\n\tadd(X,Y);\n\tif(Tan.size()==0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\tif(N==0){\n\t\tcout<<\"Yes\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<OB)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center+eps<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1+Tan[i]*Tan[i]);\n\t\t\tif(!(My+eps<B[j] || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-8;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPS){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << \"fir \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << res2 * 180.0 / M_PI << endl;\n  //cout << \"sec \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    if(x[0] > real(target) + EPS) continue;\n    for(int j=0;j<2;j++){\n      if(calc_y(rad, x[j]) < imag(rv[i].ur) - EPS){\n        return true;\n      }\n    }\n    if(calc_x_y0(rad) >= x[0] + EPS && calc_x_y0(rad) <= x[1] - EPS){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  if(calc_x_y0(M_PI/4.0) < imag(target) - EPS) return false;\n\n  for(int i=0;i<n;i++){\n    for(int j=2;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) return true;\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int maxn=55;\n\n//input\nint N;\ndouble L[maxn],B[maxn],T[maxn],R[maxn];\ndouble V,X,Y;\nconst double g=9.8;\n//\nconst double EPS=1e-8;\nint sgn(double x)\n{\n    if(fabs(x)<EPS) return 0;\n    if(x<0) return -1;else return 1;\n}\n\nint cmp(double lb,double ub,double a)\n{\n    return a<lb+EPS? -1:a>ub-EPS? 1:0;//恰好在?上会返回-1或1\n}\n\ndouble calc(double vy,double t)\n{\n    return vy*t-g*t*t/2.0;\n}\n\nbool check(double qx,double qy)\n{\n    double a=g*g/4.0,b=g*qy-V*V,c=qx*qx+qy*qy;\n\n    double D=b*b-4.0*a*c;\n    if(sgn(D)==-1) return false;\n\n    for(int d=-1;d<=1;d+=2)\n    {\n        double t2=(-b+d*sqrt(D))/(2.0*a);\n        if(sgn(t2)==-1) continue;\n        double t=sqrt(t2);\n\n        double vx=qx/t,vy=(qy+g*t*t/2)/t;\n\n        //判断是否通?猪的上方\n        double yt=calc(vy,X/vx);\n        if(yt<Y-EPS)//if(sgn(yt-Y)==-1)\n           continue;\n\n        bool ok=true;\n        rep(i,N)\n        {\n            if(L[i]>=X) continue;\n            //判断炸?与猪中?是否有障碍物\n            if(cmp(L[i],R[i],X)==0&&sgn(yt-T[i])==1) ok=false;\n           // if(sgn(X-R[i])==0&&Y<=T[i]&&yt>=B[i]) ok=false;\n\n            int yL,yR,yH,xH;\n            yL=cmp(B[i],T[i],calc(vy,L[i]/vx));\n            yR=cmp(B[i],T[i],calc(vy,R[i]/vx));\n            yH=cmp(B[i],T[i],calc(vy,vy/g));\n            xH=cmp(L[i],R[i],(vy/g)*vx);\n            if(xH==0&&yH>=0&&yL<0) ok=false;\n            if(yL*yR<=0) ok=false;\n        }\n\n        if(ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    rep(i,N) R[i]=min(R[i],X);\n    bool OK=check(X,Y);\n//    bool OK =false;\n    rep(i,N)\n    {\n        OK!=check(L[i],T[i]);\n        OK!=check(R[i],T[i]);\n    }\n\n    puts(OK? \"Yes\":\"No\");\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    cin>>N>>V>>X>>Y;\n\n    rep(i,N) cin>>L[i]>>B[i]>>R[i]>>T[i];\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\nconst double eps = 1e-9;\nconst int MAXN = 55;\nconst double g = 9.8;\n\nint sgn(double x)\n{\n\treturn x < -eps ? -1 : x > eps;\t\n}\n\nint N, V, X, Y;\ndouble Time, Vx, Vy;\n\nstruct rect\n{\n\tdouble l, d, r, u;\t\n\t\n\tvoid input()\n\t{\n\t\tscanf(\"%lf %lf %lf %lf\", &l, &d, &r, &u);\t\n\t}\n\t\n}rec[MAXN];\n\nbool inter(rect a)\n{\n\tdouble tl = a.l / Vx;\n\tdouble tr = min(Time, a.r / Vx);\n\t\n\tif(sgn(tl - Time) >= 0)\n\t{\n\t\treturn 0;\t\n\t}\n\t\n\tdouble hd = - g * tl * tl / 2 + Vy * tl;\n\tdouble hu = - g * tr * tr / 2 + Vy * tr;\n\tif(hd > hu)\tswap(hd, hu);\n\t\n\tdouble t0 = Vy / g;\n\tif(sgn(t0 - tl) > 0 && sgn(t0 - tr) < 0)\n\t{\n\t\thu = - g * t0 * t0 / 2 + Vy * t0;\t\n\t}\t\n\t\n//\tcout << tl << \"  \" << tr << \"  \" << hd << \"  \" << hu << endl; \n\t\n\treturn ! (sgn(hd - a.u) > 0 || sgn(hu - a.d) < 0);\n}\n\nbool solve()\n{\n\tVx = X / Time;\n\tVy = sqrt(V * V - Vx * Vx);\n\t\n//\tcout << Time << \"  \" << Vx << \"  \" << Vy << \"  \" << Vx * Time << \"  \" << -g*Time*Time/2 + Vy*Time << endl;\n\t\n\tfor(int i = 0; i < N; ++ i)\n\t{\n\t\tif(inter(rec[i]))\n\t\t{\n\t\t\treturn 0;\t\n\t\t}\t\n\t}\t\n\treturn 1;\n}\n\nint main()\n{\n\twhile(cin >> N >> V >> X >> Y)\n\t{\n\t\tfor(int i = 0; i < N; ++ i)\n\t\t{\n\t\t\trec[i].input();\t\n\t\t}\t\n\t\t\n\t\tdouble a = g * g / 4;\n\t\tdouble b = g * Y - V * V;\n\t\tdouble c = X * X + Y * Y;\n\t\tdouble delta = b * b - 4 * a * c;\n\t\t\n\t\tif(sgn(delta) < 0)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\tcontinue;\t\n\t\t}\n\t\t\n\t\tdouble t2 = (-b + sqrt(delta)) / (2 * a);\n\t\tif(sgn(t2) <= 0)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\tcontinue;\t\n\t\t}\n\t\n\t\tTime = sqrt(t2);\n\t\tif(solve())\n\t\t{\n\t\t\tputs(\"Yes\");\n\t\t\tcontinue;\t\n\t\t}\n\t\t\n\t\tt2 = (-b - sqrt(delta)) / (2 * a);\n\t\tif(sgn(t2) <= 0)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\tcontinue;\t\n\t\t}\n\t\n\t\tTime = sqrt(t2);\n\t\tif(solve())\n\t\t{\n\t\t\tputs(\"Yes\");\n\t\t\tcontinue;\t\n\t\t}\n\t\t\n\t\tputs(\"No\");\n\t}\n\t\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nvector<ld> sq_eq(ld a, ld b, ld c) {\n  ld D = b*b - 4.0*a*c;\n  if (D < eps) return vector<ld>();\n  vector<ld> res;\n  if (b < 0) {\n    res.push_back((-b + sqrt(D)) / (2.0 * a));\n    res.push_back((2.0 * c) / (b - sqrt(D)));\n  } else {\n    res.push_back(- (2.0 * c) / (b + sqrt(D)));\n    res.push_back((-b - sqrt(D)) / (2.0 * a));\n  }\n  return res;\n}\n\nvector<ld> p2tan(ld x, ld y, ld v) {\n  if (x == 0) return vector<ld>(1,-1);\n  ld b = -v*v/(4.9*x);\n  ld c = 1-b*y/x;\n  return sq_eq(1.0,b,c);\n}\n\nvector<ld> l2tan(ld y, ld v) {\n  ld a = -v*v/4.9;\n  ld zsq = 1.0/(1.0/(a*a*4.0)+y/a);\n  ld z1 = sqrt(zsq);\n  ld z2 = -z1;\n  vector<ld> res;\n  res.push_back(-z1/(2.0*a));\n  res.push_back(-z2/(2.0*a));\n  return res;\n}\n\nint main() {\n  int n,v;\n  ld x,y;\n  cin>>n>>v>>x>>y;\n  vector<ld> tanl = p2tan(x,y,v);\n  vector<tuple<ld,ld,ld>> lx;\n  vector<tuple<ld,ld,ld>> ly;\n  ld mn_oby_atx = 1000;\n  REP(i,n){\n    ld l,b,r,t;\n    cin>>l>>b>>r>>t;\n    if (l <= x && x <= r && b >= y)\n      mn_oby_atx = min(mn_oby_atx, b);\n    if (l >= x) continue;\n    r=min(r,x);\n    lx.emplace_back(t,l,r);\n    lx.emplace_back(b,l,r);\n    ly.emplace_back(l,b,t);\n    ly.emplace_back(r,b,t);\n    vector<vector<ld>> s(6);\n    s[0] = p2tan(l,t,v);\n    s[1] = p2tan(r,t,v);\n    s[2] = p2tan(l,b,v);\n    s[3] = p2tan(r,b,v);\n    s[4] = l2tan(t,v);\n    s[5] = l2tan(b,v);\n    REP(j,6)\n      tanl.insert(end(tanl),begin(s[j]),end(s[j]));\n  }\n  if (v == 0) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  auto itr = remove_if(begin(tanl),end(tanl),[](ld val){return val < 0.0;});\n  tanl.erase(itr, end(tanl));\n  bool ok = false;\n  for (ld t : tanl) {\n    ld a = (-4.9/(v*v))*(1+t*t);\n    ld b = t;\n    bool reachable = true;\n    for (auto p : lx) {\n      ld py, mnx, mxx;\n      tie(py,mnx,mxx) = p;\n      auto res = sq_eq(a,b,-py);\n      for (ld ans:res) {\n        if (mnx + eps< ans && ans + eps < mxx) {\n          reachable = false;\n          break;\n        }\n      }\n    }\n    for (auto p : ly) {\n      ld px, mny, mxy;\n      tie(px, mny, mxy) = p;\n      ld cy = a*px*px+b*px;\n      if (mny + eps < cy && cy + eps < mxy) {\n        reachable = false;\n        break;\n      }\n    }\n    if (reachable) {\n      ld cy = a*x*x+b*x;\n      if (y < cy + eps && cy < mn_oby_atx + eps) {\n        ok = true;\n        break;\n      }\n    }\n  }\n  if (ok)\n    cout << \"Yes\" << endl;\n  else\n    cout << \"No\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,double> P;\n\nconst double g=9.8;\n\nint solve(double a, double b, double c, double& r0, double& r1)\n{\n\tdouble D=b*b-4*a*c;\n\tif(D<0){\n\t\treturn 0;\n\t}\n\n\tdouble d=sqrt(D);\n\tr0=(-b+d)/(2*a);\n\tr1=(-b-d)/(2*a);\n\tif(r0>r1){\n\t\tswap(r0,r1);\n\t}\n\treturn D==0?1:2;\n}\n\nint solve2(double X, double Y, double V, double& t0, double& t1)\n{\n\treturn solve(g*X*X/(2*V*V),-X,Y+g*X*X/(2*V*V), t0, t1);\n}\n\nbool intersection(P a, P b, P& r)\n{\n\tr.first = max(a.first, b.first);\n\tr.second = min(a.second, b.second);\n\tif(r.first >= r.second){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid sum(P a, P b, vector<P> r)\n{\n\tP d;\n\tif (intersection(a,b,d)){\n\t\tP p=P(min(a.first,b.first), max(a.second, b.second));\n\t\tr.push_back(p);\n\t}\n\telse\n\t{\n\t\tr.push_back(a);\n\t\tr.push_back(b);\n\t}\n}\n\nvoid intersection(vector<P>& a, vector<P>& b, vector<P>& res)\n{\n\tres.clear();\n\tfor(int i=0;i<a.size();i++){\n\t\tP p=a[i];\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tP q=b[j];\n\t\t\tP r;\n\t\t\tif(intersection(p,q,r)){\n\t\t\t\tres.push_back(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid debug(vector<P>& p){\n\t/*\n\tfor(int i=0;i<p.size();i++){\n\t\tcout << p[i].first << \", \" << p[i].second << \": \";\n\t}\n\tcout << endl;*/\n}\nint main() {\n\tint N;\n\tdouble V,X,Y;\n\tcin >> N >> V >> X >> Y;\n\tif(V==0){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\n\tvector<P> res;\n\tdouble t0,t1;\n\tif(solve2(X,Y,V,t0,t1)==2){\n\t\tres.push_back(P(t0,t1));\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tdebug(res);\n\t\tdouble L,B,R,T;\n\t\tcin >> L >> B >> R >> T;\n\t\tif (X<=L){\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> lt, rt, lb, rb, t, b, tb;\n\n\t\tif (L==0){\n\t\t\tL=1e-10;\n\t\t}\n\t\tif(R==0){\n\t\t\tR=1e-10;\n\t\t}\n\n\t\t// top\n\t\tif (solve2(L,T,V,t0,t1)==2){\n\t\t\tlt.push_back(P(t0,t1));\n\t\t}\n\n\t\tif (X<=R){\n\t\t\tif(T<Y){\n\t\t\t\tt=lt;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(solve2(R,T,V,t0,t1)==2){\n\t\t\t\trt.push_back(P(t0,t1));\n\t\t\t}\n\t\t\tintersection(lt, rt, t);\n\t\t}\n\n\t\tb=t;\n\t\t// bottom\n\t\tif (solve2(L,B,V,t0,t1)==2){\n\t\t\t//cout << \"aaa \" << t0 << \", \" << t1 << endl;\n\t\t\tb.push_back(P(t1,DBL_MAX));\n\t\t\tif (B>0){\n\t\t\t\tdouble mx0=t0/(1+t0*t0)*V*V/g;\n\t\t\t\t//cout << \"mx0 \" << mx0 << endl;\n\t\t\t\tif(mx0<L){\n\t\t\t\t\tb.push_back(P(-DBL_MAX,t0));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//double mt=sqrt(g*B/(g*B-V*V/2));\n\t\t\t\t\tdouble mt=sqrt(2*g*B/(V*V-2*g*B));\n\t\t\t\t\tdouble mxt=mt/(1+mt*mt)*V*V/g;\n\t\t\t\t\tdouble RR=min(R,X);\n\t\t\t\t\t//cout << \"mt \" << mt << \", \" << mxt << endl;\n\t\t\t\t\tif(mxt<RR){\n\t\t\t\t\t\tb.push_back(P(-DBL_MAX,mt));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(solve2(RR,B,V,t0,t1)==2){\n\t\t\t\t\t\t\tb.push_back(P(-DBL_MAX, t0));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.push_back(P(-DBL_MAX,t0));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb.push_back(P(-DBL_MAX,DBL_MAX));\n\t\t}\n\t\t//cout << \"obs \";\n\t\tdebug(b);\n\t\tvector<P> merged;\n\t\tintersection(res, b, merged);\n\t\tres.swap(merged);\n \t}\n\n\tdebug(res);\n\tif(res.size()){\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=v,mid = (l+r)/2;\n     double t,vx,vy,len;\n     vy=v;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           vy=mid;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           len = vx*2*t;\n           if ( len<xx )\n              r=mid;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          memset(p,0,sizeof(p));\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define EPS 1e-6\nconst double g=9.8;\n\nint N,V,X,Y;\nint L[51],B[51],R[51],T[51];\n\ndouble calc(double vy,double t){\n\treturn vy*t-g*t*t/2.0;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a<lb+EPS? -1 : a>ub-EPS ? 1 : 0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(D<0 && D>-EPS)D=0;\n\tif(D<0)return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/(2*a);\n\t\tif(t2<=0)continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g*t*t/2)/t;\n\t\tdouble yt=calc(vy,X/vx);\n\t\tif(yt<Y-EPS)continue;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X)continue;\n\t\t\tif(R[i]==X && Y<=T[i] && B[i]<=yt)ok=false;\n\t\t\tint yL=cmp(B[i],T[i],calc(vy,L[i]/vx));\n\t\t\tint yR=cmp(B[i],T[i],calc(vy,R[i]/vx));\n\t\t\tint xH=cmp(L[i],R[i],vx*(vy/g));\n\t\t\tint yH=cmp(B[i],T[i],calc(vy,vy/g));\n\t\t\tif(xH==0 && yH>=0 && yL<0)ok=false;\n\t\t\tif(yL*yR<=0)ok=false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tfor(int i=0;i<N;i++){\n\t\tR[i]=min(R[i],X);\n\t}\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n}\n\nint main(void){\n\tscanf(\"%d %d %d %d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 110;\nconst double eps = 1e-9, pi = acos(-1), g = 9.8;\n\nint N, V, X, Y;\nint X1[NMAX], X2[NMAX], Y1[NMAX], Y2[NMAX];\ndouble v0x, v0y, rAngle, birdTime;\n\nint getSign(double value) {\n\tif (value < -eps)\n\t\treturn -1;\n\tif (value > eps)\n\t\treturn 1;\n\treturn 0;\n}\n\nbool trajectoryIntersect() {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = X1[i]; j <= X2[i]; ++j) {\n\t\t\tdouble time = j / v0x;\n\t\t\tif (getSign(time - birdTime) > 0)\n\t\t\t\tbreak;\n\t\t\tdouble y = v0y * time - 0.5 * g * time * time;\n\t\t\tif (getSign(y - Y1[i]) >= 0 && getSign(y - Y2[i]) <= 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool projectileIntersect(double y) {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (X >= X1[i] && X <= X2[i] && y >= Y1[i] && y <= Y2[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tcin >> N >> V >> X >> Y;\n\tfor (i = 1; i <= N; ++i)\n\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\n\tfor (i = 0; i < 90; ++i) {\n\t\trAngle = pi * i / 180;\n\t\tv0x = V * cos(rAngle);\n\t\tv0y = V * sin(rAngle);\n\t\tbirdTime = X / v0x;\n\t\tdouble birdY = v0y * birdTime - 0.5 * g * birdTime * birdTime;\n\t\tif (birdY < Y)\n\t\t\tcontinue;\n\t\tif (trajectoryIntersect())\n\t\t\tcontinue;\n\t\tif (projectileIntersect(birdY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (i == 90)\n\t\tcout << \"No\\n\";\n\telse\n\t\tcout << \"Yes\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g*y-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    const double tt = vy/g, tx = vx*tt, ty = yof(vy, tt);\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS) {\n            if(L[i]-EPS<tx && tx<R[i]+EPS && ty>B[i]-EPS) return false;\n        }\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i] && T[i]>=Y) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst int N=100;\nconst int MAXN=1000000;\nconst double pi=acos(-1);\nconst double gg=9.8;\nint n;\ndouble v,x,y,l[N],b[N],r[N],t[N],B,A,rr[N];\nint work(double x,double y)\n{\n\tdouble yy=A * x * x + B * x;\n\t//if (fabs(yy-y) < eps) return 0;\n\tif (y > yy) return 1;\n\treturn -1;\n}\nbool check(double thi)\n{\n\tA=-gg/(2 * v * v * cos(thi) * cos(thi));\n\tB=tan(thi);\n\tdouble MAX_top=-B*B/(4 *A);\n\tfor(int i=1;i<=n;i++)\n\tif (l[i] < x+eps)\n\t{\n\t\trr[i]=min(r[i],x);\n\t\tif (work(l[i],t[i]) * work(rr[i],t[i]) <0) return 0;\n\t\tif (work(l[i],b[i]) * work(rr[i],b[i]) <0) return 0;\n\t\tif (work(l[i],t[i]) * work(l[i],b[i]) <0) return 0;\n\t\tif (r[i]<x+ eps && work(r[i],t[i]) * work(r[i],b[i]) <0) return 0;\n\t\tif (work(l[i],b[i])>0 && work(rr[i],b[i])>0 && MAX_top > b[i]-eps) return 0;\n\t}\n\tif (work(x,y) > 0) return 0;\n\tdouble tmp=A * x * x + B * x;\n\tfor(int i=1;i<=n;i++)\n\t\tif (l[i]< x-eps && r[i]> x+eps)\n\t\t{\n\t\t\tif (t[i] < tmp-eps && t[i]>y+eps) return 0;\n\t\t\tif (b[i] < tmp-eps && b[i]>y+eps) return 0;\n\t\t}\n\treturn 1;\n}\nint main()\n{\n\tcin>>n>>v>>x>>y;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n\tfor(int i=1;i<MAXN;i++)\n\t{\n\t\tdouble thi=pi / 2 * i / MAXN;\n\t\tif (check(thi))\n\t\t{\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 I : White Bird\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ndouble calc(double X, double Y, double V, double vy){\n\treturn 2*vy*sqrt(V*V-vy*vy)*X-9.8*X*X-2*Y*(V*V-vy*vy);\n}\n\nvoid getVy(vector<double> &vd, double X, double Y, double V){\n\tdouble L = 0, R = V;\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble midA = (2*L+R)/3;\n\t\tdouble midB = (L+2*R)/3;\n\t\tif(calc(X, Y, V, midA) < calc(X, Y, V, midB)) L = midA;\n\t\telse                                          R = midB;\n\t}\n\tif(calc(X, Y, V, 0.5*(L+R)) < EPS) return ;\n\tdouble vl = 0, vr = 0.5*(L+R);\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble mid = 0.5*(vl+vr);\n\t\tif(calc(X, Y, V, mid) < 0) vl = mid;\n\t\telse                       vr = mid;\n\t}\n\tvd.push_back(0.5*(vl+vr));\n\tvl = 0.5*(L+R), vr = V;\n\tfor(int cnt=0;cnt<200;cnt++){\n\t\tdouble mid = 0.5*(vl+vr);\n\t\tif(calc(X, Y, V, mid) > 0) vl = mid;\n\t\telse                       vr = mid;\n\t}\n\tvd.push_back(0.5*(vl+vr));\n}\n\nint main(){\n\tint N, V, X, Y;\n\tint L[50], B[50], R[50], T[50];\n\twhile(cin >> N >> V >> X >> Y){\n\t\tvector<double> vd;\n\t\tgetVy(vd, X, Y, V);\n\t\tint low = Y, high = 1000000007;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> L[i] >> B[i] >> R[i] >> T[i];\n\t\t\tL[i] = min(L[i], X);\n\t\t\tR[i] = min(R[i], X);\n\t\t\tgetVy(vd, L[i], B[i], V);\n\t\t\tgetVy(vd, R[i], B[i], V);\n\t\t\tgetVy(vd, L[i], T[i], V);\n\t\t\tgetVy(vd, R[i], T[i], V);\n\t\t\tif(L[i]<=X&&X<=R[i]&&B[i]>=high) high = min(high, B[i]);\n\t\t}\n\t\tbool clear = false;\n\t\tfor(int i=0;i<vd.size();i++){\n\t\t\tdouble vx = sqrt(V*V-vd[i]*vd[i]);\n\t\t\tdouble vy = vd[i];\n\t\t\tbool ok = true;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdouble my = vy*(L[j]/vx) - 4.9*(L[j]/vx)*(L[j]/vx);\n\t\t\t\tdouble My = vy*(R[j]/vx) - 4.9*(R[j]/vx)*(R[j]/vx);\n\t\t\t\tif(my > My) swap(my, My);\n\t\t\t\tif(L[j]+EPS < vx*vy/9.8 && vx*vy/9.8 < R[j]-EPS)\n\t\t\t\t\tMy = vy*(vy/9.8) - 4.9*(vy/9.8)*(vy/9.8);\n\t\t\t\tif(min(My, (double)T[j]) - max(my, (double)B[j]) > EPS) ok = false;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tdouble y = vy*(X/vx) - 4.9*(X/vx)*(X/vx);\n\t\t\tif(low-EPS < y && y < high+EPS) clear = true;\t\t\t\n\t\t}\n\t\tcout << (clear ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=v,mid = (l+r)/2;\n     double t,vx,vy,len;\n     vy=v;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           //cout<<l<<\" \"<<r<<endl;\n           vy=mid;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           len = vx*2*t;\n           if ( len<xx )\n              r=mid;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l>xx ) continue;\n             p[++top].x=rec[i].l,p[top].y=rec[i].t;\n             p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          /*for ( i=1;i<=top;i++ )\n              cout<<p[i].x<<\" \"<<p[i].y<<endl;*/\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 55;\nconst double g = 9.8;   //重力加速度\nconst int EPS = 1e-10;\nint N, V, X, Y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\n\n//&#35745;算以vy的速度&#31446;直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相&#23545;lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//判断当射出路径&#32463;&#36807;点(qx, qy)&#26102;，卵是否能&#20987;中猪\nbool check(double qx, double qy)\n{\n    //&#35774;初速度在x方向和y方向的分量分&#21035;&#20026;vx和vy，&#35774;通&#36807;(qx, qy)的&#26102;&#38388;&#20026;t\n    //&#35774;解&#32852;立方程式vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //&#39564;&#35777;&#32852;立方程式上的&#20004;个解的循&#29615;\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //判断是否通&#36807;猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //判断在猪正上方的&#40479;和猪之&#38388;是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //判断在&#39134;到猪的正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //左&#20391;的相&#23545;位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //右&#20391;的相&#23545;位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //最高点的相&#23545;位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    //截掉猪以右的障碍物\n    for (int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);      //直接撞上猪的情况\n    for (int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);     //&#32463;&#36807;左上角的情况\n        ok |= check(R[i], T[i]);     //&#32463;&#36807;右上角的情况\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while (scanf(\"%d%d%d%d\", &N, &V, &X, &Y) != EOF){\n        for (int i = 0; i < N; i++){\n            scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-6)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    if(yof(vy, X/vx) < Y-EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS && yof(vy, vy/g)>B[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb+eps ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) delta=0.0;\n  else if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\n\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\ndouble Max,Min;\nvector<double> Tan;\n\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<eps || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=min(OB,B[i]);\n\t}\n\tadd(X,Y);\n\tif(Tan.size()==0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center+eps<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\n\t\t\tif(!(My+eps<B[j] || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P; \n#define MAX_N 55\n#define EPS 1e-10\nconst double g=9.8;\nint N,V,X,Y;\nint L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calc(double vy,double t)\n{\n\treturn vy*t-g*t*t/2;\n}\n\ndouble cmp(double lb,double ub,double a)\n{\n\treturn a<lb+EPS?-1:a>ub-EPS?1:0;\n}\n\nbool check(double qx,double qy)\n{\n\tdouble a=g*g/4,b=g*qy-V*V,c=qx*qx+qy+qy;\n\tdouble D=b*b-4*a*c;\n\tif(D<0&&D>-EPS)D=0;\n\tif(D<0)return false;\n\tfor(int d=-1;d<=1;d+=2)\n\t{\n\t\tdouble t2=(-b+d*sqrt(D))/(2*a);\n\t\tif(t2<=0)continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g*t*t/2)/t;\n\n\t\tdouble yt=calc(vy,X/vx);\n\t\tif(yt<Y-EPS)continue;\n\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(L[i]>=X)continue;\n\t\t\tif(R[i]==X&&Y<T[i]&&B[i]<=yt)ok=false;\n\t\t\tint yL=cmp(B[i],T[i],calc(vy,L[i]/vx));\n\t\t\tint yR=cmp(B[i],T[i],calc(vy,R[i]/vx));\n\t\t\tint xH=cmp(L[i],R[i],vx*(vy/g));\n\t\t\tint yH=cmp(B[i],T[i],calc(vy,vy/g));\n\t\t\tif(yL*yR<=0)ok=false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(R[i],X);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n}\n\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tsolve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-5;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int i = -1; i <= 1; i += 2)\n\t{\n\t\tdouble t2 = (-b + i * sqrt(D)) / (2 * a);\n\t\tif (t2 > -EPS && t2 < 0) t2 = 0;\n\t\tif (t2 < 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, calc(vx, vy / g));\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].b);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-10;\nconst double g = 9.8;\nconst int MAXN = 55;\ndouble L[MAXN],R[MAXN],B[MAXN],T[MAXN];\ndouble N,V,X,Y;\n// 计算以Vy的速度竖直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n// a相对于l和r的位置\nint cmp(double l, double r, double a)// 注意判断大小的时候的误差处理\n{\n    if(a < l + eps) return -1;//if(a <= l)\n    if(a > r - eps) return 1;//if(a >= r)\n    return 0;\n}\n// 判断当射出路径经过点（qx,qy）时，卵是否能击中猪\n//设初速度在x方向和y方向的分量为vx和vy，设通过（qx，qy）的时间为t\n//求解联立方程式vx^2 + vy^2 = V^2 , vx * t = qx, vy * t - g * t^2 * 1/2 = qy\nbool check(double qx, double qy)\n{\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -eps) D = 0; //误差处理\n    if(D < 0) return false;\n    for(int d=-1;d<=1;d+=2)\n    {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);//解出来的是t^2\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t,vy = (qy + g * t * t / 2) / t;\n        //判断是否通过猪的正上方\n        double yt = calc(vy, X / vx);\n        if(yt < Y - eps) continue; //yt < Y\n        bool flag = 1;\n        for(int i=0;i<N;i++)\n        {\n            if(L[i] >= X) continue;\n            //判断在猪正上方的鸟和猪之间是否有障碍物\n            if(R[i] == X && Y <= T[i] && B[i] <= yt)// 由于预处理，这里已经保证了L[i] <= X <= R[i]\n            flag = false;\n            //判断在飞到猪正上方之前是否会撞到障碍物\n            int yl = cmp(B[i], T[i], calc(vy, L[i] / vx));//在障碍物左边缘时的相对位置\n            int yr = cmp(B[i], T[i], calc(vy, R[i] / vx));//在障碍物右边缘时的相对位置\n            int xh = cmp(L[i], R[i], vx * vy / g);//最高点的相对位置\n            int yh = cmp(B[i], T[i], calc(vy, vy / g));\n            if(xh == 0 && yh >= 0 && yl < 0) flag = false;\n            if(yl * yr <= 0) flag = false;\n        }\n        if(flag) return 1;\n    }\n    return 0;\n}\nint main()\n{\n    cin >> N >> V >> X >> Y;\n    for(int i=0;i<N;i++)\n    cin >> L[i] >> B[i] >> R[i] >> T[i], R[i] = min(R[i], X);//预处理，截掉猪以右的障碍物\n    bool flag = check(X, Y);//直接撞上猪的情况\n    for(int i=0;i<N;i++)\n    {\n        flag |= check(L[i], T[i]);//经过障碍物左上角的情况\n        flag |= check(R[i], T[i]);//经过障碍物右上角的情况\n    }\n    puts(flag ? \"Yes\" : \"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb+eps ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    //cout <<\"vx=\" <<vx <<endl;\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(T[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Yzcstc\n * Created Time:  2014/9/29 10:12:41\n * File Name: aoj2308.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define M0(x)  memset(x, 0, sizeof(x))\n#define Inf  0x7fffffff\n#define MP make_pair\n#define PB push_back\n#define eps 1e-12\n#define g 9.8\n#define N 500000\n#define pi acos(-1.0)\ntypedef long long LL;\nusing namespace std;\ninline int sgn(const double &x){\n    return (x > eps) - (x < -eps);\n}\nstruct point{\n    double x, y;\n    point(){}\n    point(double _x, double _y):x(_x), y(_y){}\n    void input(){\n         scanf(\"%lf%lf\", &x, &y);\n    }\n    point operator-(const point& p) const{\n          return point(x - p.x, y - p.y);      \n    }\n} p[550][2];\nint n;\ndouble v, x, y, vx, vy, top, topy;\n\nvoid init(){\n     for (int i = 0; i < n; ++i)\n         p[i][0].input(), p[i][1].input();\n}\n\nint gao(int i){\n     point p2 = point(p[i][0].x, p[i][1].y);\n     point p4 = point(p[i][1].x, p[i][0].y);\n     double x1, y1, x2, t;\n     if (sgn(p2.x - x) <= 0){\n            double t = p2.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) < 0 && sgn(y1 - p4.y) > 0) return 0;\n     }\n     if (sgn(p4.x - x) <= 0){\n            double t = p4.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) < 0 && sgn(y1 - p4.y) > 0) return 0;\n     }\n     double d;\n     if (sgn(p2.y - top) <= 0){\n           d = vy * vy - 2 * g * p2.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) >= 0 && sgn(x1 - x) <= 0){\n                  if (sgn(x1 - p2.x) > 0 && sgn(x1 - p4.x) < 0) return 0;\n           }\n           if (sgn(x2) >= 0 && sgn(x2 - x) <= 0){\n                  if (sgn(x2 - p2.x) > 0 && sgn(x2 - p4.x) < 0) return 0;\n           }\n     }\n     if (sgn(p4.y - top) <= 0){\n           d = vy * vy - 2 * g * p4.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) >= 0 && sgn(x1 - x) <= 0){\n                  if (sgn(x1 - p2.x) > 0 && sgn(x1 - p4.x) < 0) return 0;\n           }\n           if (sgn(x2) >= 0 && sgn(x2 - x) <= 0){\n                  if (sgn(x2 - p2.x) > 0 && sgn(x2 - p4.x) < 0) return 0;\n           }\n     }\n     return 1;\n}\n\nint check(double ang){\n     vx = v * cos(ang), vy = v * sin(ang);\n     if (sgn(vx) == 0) return 0;\n     double t = x / vx;\n     double hy = vy * t - .5 * g * t * t;\n     top = vy * vy / 2 / g;\n     if (sgn(hy - y) < 0 || sgn(hy - topy) >= 0) return 0;\n     for (int i = 0; i < n; ++i){\n             if (!gao(i)) return 0;\n     } \n     return 1;\n}\n\nint solve(){\n     if (sgn(v) <= 0) return 0;\n     double EPS = 1e-6;\n     double ang = 0;\n     topy = 1e50;\n     for (int i = 0; i < n; ++i) if (sgn(p[i][0].x - x) <= 0 && sgn(p[i][1].x - x) >= 0) {\n              if (sgn(p[i][0].y - y) >= 0)\n                      topy = min(topy, p[i][0].y);                  \n              if (sgn(p[i][1].y - y) >= 0)\n                      topy = min(topy, p[i][1].y); \n     }\n     for (int i = 0;; ++i){\n           if (check(ang)) return 1;\n           ang += EPS;\n           if (ang > pi/2) break;\n     }\n     return 0;\n}\n\nint main(){\n//    freopen(\"a.in\", \"r\", stdin);\n//    freopen(\"a.out\", \"w\", stdout);\n    while (scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y) != EOF){\n            init();\n            solve() ? puts(\"Yes\") : puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble lx[100];\ndouble ly[100];\ndouble rx[100];\ndouble ry[100];\ndouble EPS=1e-9;\nvector<pair<double,double> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a;\n\tdouble b,c,d;\n\tscanf(\"%d%lf%lf%lf\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf%lf\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\trx[i]=min(rx[i],c);\n\t\t//v.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\t//v.push_back(make_pair(min(rx[i],c),ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-9.8*9.8*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\tdouble hg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=c-EPS)continue;\n\t\t\tif(ABS(rx[j]-c)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(q+EPS<ry[j]&&ry[j]+EPS<p)ok=false;\n\t\t\tif(p+EPS<ly[j]&&ly[j]+EPS<q)ok=false;\n\t\t\t\n\t\t\tif(p+EPS<ry[j]&&ry[j]+EPS<q)ok=false;\n\t\t\tif(q+EPS<ly[j]&&ly[j]+EPS<p)ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t//\tif(th-EPS>ly[j]){\n\t\t\t\tif(EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j]&&th>ly[j]+EPS&&ly[j]+EPS>calc(vy,lx[j]/vx)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t//\t}\n\t\t\t\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\t//printf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\thg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=c-EPS)continue;\n\t\t\tif(ABS(rx[j]-c)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(q+EPS<ry[j]&&ry[j]+EPS<p)ok=false;\n\t\t\tif(p+EPS<ly[j]&&ly[j]+EPS<q)ok=false;\n\t\t\t\n\t\t\tif(p+EPS<ry[j]&&ry[j]+EPS<q)ok=false;\n\t\t\tif(q+EPS<ly[j]&&ly[j]+EPS<p)ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t//\tif(th-EPS>ly[j]){\n\t\t\t\tif(EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j]&&th>ly[j]+EPS&&ly[j]+EPS>calc(vy,lx[j]/vx)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t//\t}\n\t\t\t\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\t//printf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nstruct Rect {\n  double l, b, r, t;\n};\nint n;\ndouble v, X, Y;\nconst double g = 9.8;\nvector<Rect> rect;\nbool hanbetu(double a, double b, double c) {\n  return b * b - 4 * a * c + eps > 0;\n}\npair<double, double> get_vx(double a, double b, double c) {\n  double tmp1 = - b / (2 * a);\n  double tmp2 = sqrt(b * b - 4 * a * c + eps) / (2 * a);\n  return make_pair(tmp1 + tmp2, tmp1 - tmp2);\n}\ndouble get_val(double vx, double nowx) {\n  double vy = sqrt(v * v - vx * vx);\n  return -(g / (2 * vx * vx)) * (nowx - vx * vy / g) * (nowx - vx * vy / g) + vy * vy / (g * 2);\n}\nbool seihu(int i, double vx) {\n  vector<double> px = {rect[i].l, rect[i].l, rect[i].r, rect[i].r};\n  vector<double> py = {rect[i].b, rect[i].t, rect[i].b, rect[i].t};\n  int sign = -1;\n  bool res = true;\n  for(int j=0;j<(4);++j) {\n    if(X < px[j]) continue;\n    double val = get_val(vx, px[j]) - py[j];\n    if(sign == -1 && abs(val) > eps) {\n      sign = val > 0;\n    } else if(abs(val) > eps) {\n      res &= (val > 0) == sign;\n    }\n  }\n  double vy = sqrt(v * v - vx * vx);\n  double jiku = vx * vy / g;\n  double jikuy = vy * vy / (2 * g);\n  res &= jiku < rect[i].l || rect[i].r < jiku || jikuy < rect[i].b || rect[i].t < jikuy;\n  if(rect[i].r < X) {\n    return res;\n  } else {\n    res = true;\n    double vall = get_val(vx, rect[i].l);\n    double valx = get_val(vx, X);\n    if(vall > rect[i].t) {\n      return valx > rect[i].t;\n    } else if(vall < rect[i].b) {\n      return valx < rect[i].b && (X < jiku || jikuy < rect[i].b);\n    } else {\n      return false;\n    }\n  }\n}\nbool pig(int i, double vx) {\n  double val1 = get_val(vx, X);\n  return Y > rect[i].t || val1 < rect[i].b;\n}\nbool check(double x, double y) {\n  if(x == 0) return false;\n  double a = 1 + y * y / (x * x);\n  double b = g * y - v * v;\n  double c = g * g * x * x / 4;\n  if(!hanbetu(a, b, c)) return false;\n  auto p_vx = get_vx(a, b, c);\n  bool res_fi = true;\n  if(p_vx.first < -eps || v * v - p_vx.first < -eps) res_fi = false;\n  else p_vx.first = sqrt(p_vx.first);\n  for(int i=0;i<(n);++i) {\n    if(!res_fi) break;\n    if(rect[i].l < X) res_fi &= seihu(i, p_vx.first);\n    if(rect[i].l < X && X < rect[i].r) res_fi &= pig(i, p_vx.first);\n  }\n  res_fi &= Y < get_val(p_vx.first, X) + eps;\n  bool res_se = true;\n  if(p_vx.second < -eps || v * v - p_vx.second < -eps) res_se = false;\n  else p_vx.second = sqrt(p_vx.second);\n  for(int i=0;i<(n);++i) {\n    if(!res_se) break;\n    if(rect[i].l < X) res_se &= seihu(i, p_vx.second);\n    if(rect[i].l < X && X < rect[i].r) res_se &= pig(i, p_vx.second);\n  }\n  res_se &= Y < get_val(p_vx.second, X) + eps;\n  return res_fi || res_se;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  cin >> n >> v >> X >> Y;\n  for(int i=0;i<(n);++i) {\n    double l, b, r, t; cin >> l >> b >> r >> t;\n    rect.push_back({l, b, r, t});\n  }\n  bool ans = false;\n  for(int i=0;i<(n);++i) {\n    ans |= check(rect[i].l, rect[i].t);\n    ans |= check(rect[i].r, rect[i].t);\n  }\n  ans |= check(X, Y);\n  cout << (ans ? \"Yes\" : \"No\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-6;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\n// a<lb?±????-1 lb<=a<=ub?±????0 ub<a?±????1\n//?±????????????°??? \nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}\n/*????´???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(eps)?1:0);\n}*/ \n\n/*????¶???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}*/ \n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-6;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0; rad <= M_PI / 2.0; rad += 0.0000001){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(y < gy){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(y1 < 0 || y2 < 0){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y1\n             || (double)obstacles[i].top_y < y1)){\n          isok = false;\n          break;\n        }\n        if(!((double)obstacles[i].bottom_y > y2\n             || (double)obstacles[i].top_y < y2)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\nint v0,X,Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %d %d %d\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%d %d %d %d\",L+i,B+i,R+i,T+i);\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(eps)?1:0);\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double eps = 1e-4;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble getY(double x, double vx, double vy) {\n  return -g/(2*vx*vx) * x*x + vy/vx * x;\n}\n\nbool isHit(int i, double vx, double vy) {\n  vector<double> v;\n  vector<double> u;\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  {\n    double y = getY(L[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(L[i]);\n    }\n  }\n  {\n    double y = getY(R[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(R[i]);\n    }\n  }\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end(), equals), v.end());\n  if(v.size() > 2) {\n    return true;\n  }\n  if(v.size() == 2) {\n    double mx = (v[0] + v[1]) / 2.0;\n    double my = getY(mx, vx, vy);\n    if(L[i]+eps < mx && mx < R[i]-eps && \n       B[i]+eps < my && my < T[i]-eps) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int i = 0; i < u.size(); ++i) {\n        if(u[i] <= 0) continue;\n        vxs.push_back(sqrt(u[i]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        const double vx = vxs[k];\n        const double vy = sqrt(V*V - vx*vx);\n\n        {\n          bool flag = true;\n          for(int i = 0; i < N; ++i) {\n            if(X < L[i]) continue;\n            if(isHit(i, vx, vy)) {\n              flag = false;\n              break;\n            }\n          }\n          if(!flag) continue;\n        }\n\n        {\n          double py = getY(X, vx, vy);\n          if(equals(Y, py)) throw 0;\n          if(py < Y) continue;\n          bool ok = true;\n          for(int i = 0; i < N; ++i) {\n            if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n              ok = false;\n              break;\n            }\n          }\n          if(ok) throw 0;\n        }\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 110;\nconst double eps = 1e-6, pi = acos(-1), g = 9.8;\n\nint N, V, X, Y;\nint X1[NMAX], X2[NMAX], Y1[NMAX], Y2[NMAX];\ndouble v0x, v0y, rAngle, birdTime;\n\nint getSign(double value) {\n\tif (value < -eps)\n\t\treturn -1;\n\tif (value > eps)\n\t\treturn 1;\n\treturn 0;\n}\n\nbool trajectoryIntersect() {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = X1[i]; j <= X2[i]; ++j) {\n\t\t\tdouble time = j / v0x;\n\t\t\tif (getSign(time - birdTime) > 0)\n\t\t\t\tbreak;\n\t\t\tdouble y = v0y * time - 0.5 * g * time * time;\n\t\t\tif (getSign(y - Y1[i]) >= 0 && getSign(y - Y2[i]) <= 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool projectileIntersect(double y) {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (getSign(X - X1[i]) >= 0 && getSign(X - X2[i]) <= 0 && getSign(y - Y1[i]) >= 0 && getSign(y - Y2[i]) <= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tcin >> N >> V >> X >> Y;\n\tfor (i = 1; i <= N; ++i)\n\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\n\tfor (i = 0; i < 90; ++i) {\n\t\trAngle = pi * i / 180;\n\t\tv0x = V * cos(rAngle);\n\t\tv0y = V * sin(rAngle);\n\t\tbirdTime = X / v0x;\n\t\tdouble birdY = v0y * birdTime - 0.5 * g * birdTime * birdTime;\n\t\tif (getSign(Y - birdY) > 0)\n\t\t\tcontinue;\n\t\tif (trajectoryIntersect())\n\t\t\tcontinue;\n\t\tif (projectileIntersect(birdY))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (i == 90)\n\t\tcout << \"No\\n\";\n\telse\n\t\tcout << \"Yes\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define maxn 55\n#define eps 1e-8\nconst double g=9.8;\nusing namespace std;\nint n;\ndouble v,x,y;\ndouble l[maxn],b[maxn],r[maxn],t[maxn];\ndouble cal(double t,double vy)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double lowb,double upb,double a)\n{\n    if(a<lowb+eps)\n        return -1;\n    if(a>upb-eps)\n        return 1;\n    return 0;\n}\nbool judge(int qx,int qy)//通??个点的??是tt\n{\n    double a=g*g/4,bb=g*qy-v*v,c=qx*qx+qy*qy;\n    double d=bb*bb-4*a*c;\n    if(d<0&&d>-eps)\n        d=0;\n    if(d<0)\n        return false;\n    for(int cnt=-1;cnt<=1;cnt+=2)\n    {\n        double t_sq=(-bb+cnt*sqrt(d))/(2*a);\n        if(t_sq<=0)\n            continue;\n        double tt=sqrt(t_sq);\n        double vx=qx/tt,vy=(qy+g*tt*tt/2)/tt;\n        double yt=cal(x/vx,vy);//猪的正上方坐?\n        if(yt<y-eps)\n            continue;\n        bool ans=true;\n        for(int i=0;i<n;i++)\n        {\n            if(l[i]>=x)\n                continue;\n            if(r[i]==x&&b[i]<=yt&&t[i]>=y)\n                ans=false;\n            int yl=cmp(b[i],t[i],cal(l[i]/vx,vy));\n            int yr=cmp(b[i],t[i],cal(r[i]/vx,vy));\n            int xh=cmp(l[i],r[i],vx*vy/g);\n            int yh=cmp(b[i],t[i],cal(vy/g,vy));\n            if(yl*yr<=0)\n                ans=false;\n            if(xh==0&&yh>=0&&yl<0)\n                ans=false;\n        }\n        if(ans)\n            return true;\n    }\n    return false;\n}\nint main()\n{\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n            scanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n        for(int i=0;i<n;i++)\n            r[i]=min(r[i],x);\n        bool flag=judge(x,y);\n        for(int i=0;i<n;i++)\n        {\n            flag=flag|judge(l[i],t[i]);\n            flag=flag|judge(r[i],t[i]);\n        }\n        if(flag)\n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define RREP(i,s,e) for (i = s; i >= e; i--)\n#define rrep(i,n) RREP(i,n,0)\n#define REP(i,s,e) for (i = s; i < e; i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 100000000\n\ntypedef long long ll;\n\nint n, v, x, y;\nint l[50], b[50], r[50], t[50];\ndouble g = 9.8;\n\ndouble cmp(double l, double u, double a) {\n    return a < l ? -1 : a > u ? 1 : 0;\n}\n\ndouble height(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n\nbool solve(int bx, int by) {\n    int i, j;\n    if (v*v-2*g*by < 0)\n        return false;\n    for (int i = -1; i <= 1; i+=2) {\n        double t2 = (-2*(g*by-v*v)+i*v*sqrt(v*v-2*g*by))/(g*g);\n        if (t2 < 0)\n            continue;\n        double t1 = sqrt(t2);\n        double vx = bx / t1;\n        double vy = y/t1 + g*t1/2;\n        if (height(vy,x/vx) < y-1e-9) continue;\n        bool ok = true;\n        rep (j,n) {\n            if (l[j] >= x) continue;\n            if (r[j] == x && height(vy,x/vx) >= b[j] && y <= t[j]) ok = false;\n            int yL = cmp(b[j],t[j],height(vy,l[j]/vx));\n            int yR = cmp(b[j],t[j],height(vy,r[j]/vy));\n            int xH = cmp(l[j],r[j],vx*vy/g);\n            int yH = cmp(b[j],t[j],height(vy,vy/g));\n            if (yL*yR <= 0) ok = false;\n            if (yR < 0 && xH == 0 && yH >= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    int i;\n    bool ans;\n    cin >> n >> v >> x >> y;\n    rep (i,n) cin >> l[i] >> b[i] >> r[i] >> t[i];\n    rep (i,n) r[i] = min(r[i],x);\n    ans = solve(x,y);\n    rep (i,n) {\n        ans |= solve(l[i],t[i]);\n        ans |= solve(r[i],t[i]);\n    }\n    if (ans)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-5;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(r.top(), y_left) >= 0) {\n            if(cmp(r.top(), y_right) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(r.bottom(), y_left) <= 0) {\n            if(cmp(r.bottom(), y_right) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tif (L <= Y)continue;\n\t\tR = max(R, X);\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < bs.size(); ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < bs.size(); ++i) {\n\t\t\t\tauto b = bs[i];\n\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n\ntypedef long long ll;\ndouble EPS = 1e-6;\nconst double g = 9.8;\nconst int N = 50;\nint n, v, X, Y;\nint L[N], R[N], T[N], B[N];\n\n//速度vyで上に打ち出した際のt秒後の位置を計算\ndouble calc(double vy, double t) {\n\treturn vy*t - g*t*t*0.5;\n}\n\n//aのlb,ubに対する相対位置関係(lbより下:-1, lb以上ub以下:0, ubより上:1)\nint relPos(double lb, double ub, double a) {\n\treturn a < lb+EPS ? -1 : (a > ub-EPS ? 1 : 0);\n}\n\n//点(x,y)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool success(double x, double y) {\n\tdouble a = g*g*0.25, b = g*y-v*v, c = x*x+y*y;\n\tdouble D = b*b - a*c*4.0;\n\n\tif (D<0.0 && D>-EPS) D = 0.0;\n\tif (D<0.0) return false;\n\n\tfor (int d=-1; d<=1; d+=2) {\n\t\tdouble t2 = (-b + d*sqrt(D)) / (a*2.0);\n\t\tif (t2<=0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t, vy = (y + g*t*t*0.5) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y-EPS) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (L[i]>=X) continue;\n\n//\t\t\tif (L[i]<=X && X<=R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n\t\t\tif (X==R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n\n\t\t\tint yL = relPos(B[i], T[i], calc(vy, L[i]/vx));\n\t\t\tint yR = relPos(B[i], T[i], calc(vy, R[i]/vx));\n\t\t\tint xH = relPos(L[i], R[i], vx*(vy/g));\n\t\t\tint yH = relPos(B[i], T[i], calc(vy, vy/g));\n\n\t\t\tif (xH==0 && yH>=0 && yL<0) ok = false;\n\t\t\tif (yL*yR<=0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\n\tscanf(\"%d%d%d%d \", &n, &v, &X, &Y);\n\tfor (int i=0; i<n; i++)\n\t\tscanf(\"%d%d%d%d \", L+i, B+i, R+i, T+i);\n\n//\n\tfor (int i=0; i<n; i++)\n\t\tR[i] = min(R[i], X);\n\n\n\n\tbool ok = success(X, Y);\n\n\tfor (int i=0; i<n; i++) {\n\t\tok |= success(L[i], T[i]);\n\t\tok |= success(R[i], T[i]);\n\t}\n\n\tputs(ok ? \"Yes\" : \"No\");\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\nvector<int> L(N),B(N),R(N),T(N);\nld calcv(ld vy,ld t){\n  return vy*t+G*t*t/2;\n}\n\nld cmp(ld lb,ld ub,ld a){\n  return a< lb+eps ? -1 :a>ub-eps ? 1 :0;\n}\nbool check(ld qX,ld qY){\n  //solve g^2/4*t^4 + (g*qY-V)*t^2 + (qX^2+qY^2) = 0;\n  ld a = G*G/4; ld b = G+qY-V; ld c = qX*qX+qY*qY;\n  ld D = b*b-4*a*c;\n  if((D<0)&&(D>-eps)) D=0;\n  if(D<0) return false;\n  for(int k=-1;k<=1;k+=2){\n    //find t\n    ld t = sqrt((-1*b+k*sqrt(D))/2);\n    if(t<=0) continue;\n    ld vx = qX/t; ld vy = sqrt(V*V-vx*vx);\n\n    //can reach Y?\n    double reachy = calcv(qY,t);\n    if(reachy<Y-eps) return false;\n\n    bool ok = true;\n    //find colision\n    REP(i,N){\n      if(L[i] >= X) continue;//ignore\n      if(R[i]==X && Y<=T[i] && B[i]<=reachy) ok = false;\n      int yL = cmp(B[i],T[i],calcv(vy,L[i]/vx));\n      int yR = cmp(B[i],T[i],calcv(vy,R[i]/vx));\n      int xH = cmp(L[i],R[i],vx*(vy/G));\n      int yH = cmp(B[i],T[i],calcv(vy,vy/G));\n      if(xH==0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  } \n  return false;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    R[i] = min(R[i],X);\n  }\n  bool ok = check(X,Y);\n  REP(i,N){\n    ok |= check(L[i],T[i]);\n    ok |= check(R[i],T[i]);\n  }\n  cout << (ok ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 55;\nconst double eps = 1e-8, inf = 1e10, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\nV Vec;\ndouble MaxAc;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n}\n\nvoid cal(double a, double b, double c, V &vec)\n{\n\tdouble delta = b*b - 4*a*c;\n\tif (dcmp(delta) <= 0)\n\t{\n\t\tif (dcmp(a) > 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, 1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\n\tdelta = sqrt(delta);\n\tdouble t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n\tif (dcmp(a) > 0)\n\t{\n\t\twhile (t1 < -inf);\n\t\twhile (t2 > inf);\n\t\tvec.push_back(make_pair(-inf, 1));\n\t\tvec.push_back(make_pair(t1, -1));\n\t\tvec.push_back(make_pair(t2, 1));\n\t\tvec.push_back(make_pair(inf, -1));\n\t}\n\telse\n\t{\n\t\tvec.push_back(make_pair(t1, 1));\n\t\tvec.push_back(make_pair(t2, -1));\n\t}\n}\n\nvoid add(double x1, double y1, double x2, double y2, int sign)\n{\n\tdouble a1 = -g*x1*x1/(2*v*v), b1 = x1, c1 = -g*x1*x1/(2*v*v) - y1;\n\tdouble a2 = -g*x2*x2/(2*v*v), b2 = x2, c2 = -g*x2*x2/(2*v*v) - y2;\n\n\tif (sign) a1 = -a1, a2 = -a2, b1 = -b1, b2 = -b2, c1 = -c1, c2 = -c2;\n\n\tV vec;\n\tcal(a1, b1, c1, vec);\n\tcal(a2, b2, c2, vec);\n\tsort(vec.begin(), vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\ttmp += vec[i].second;\n\t\tif (tmp == 2)\n\t\t{\n\t\t\tdouble t = vec[i].first;\n\t\t\tVec.push_back(make_pair(vec[i].first, 1));\n\t\t\tVec.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n}\n\nbool judge(double l, double r)\n{\n\tdouble a = -g*X*X/(2*v*v), b = X, c = -g*X*X/(2*v*v);\n\tdouble fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n\tdouble t = -b/(2*a);\n\tdouble Min = min(fl, fr);\n\tdouble Max = max(fl, fr);\n\tif (dcmp(t-l) >= 0 && dcmp(t-r) <= 0)\n\t\tMax = a*t*t + b*t + c;\n\n\treturn dcmp(Y-Min) >= 0 && dcmp(Y-Max) <= 0 || dcmp(MaxAc-Min) >= 0 && dcmp(MaxAc-Max) <= 0;\n}\n\nbool solve()\n{\n\tif (!dcmp(v))\n\t\treturn false;\n\n\tVec.clear();\n\tMaxAc = inf;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp(x[i][0]-X) < 0)\n\t\t{\n\t\t\tx[i][1] = min(X, x[i][1]);\n\t\t\tadd(x[i][0], y[i][0], x[i][1], y[i][0], 1);\n\t\t\tadd(x[i][0], y[i][1], x[i][1], y[i][1], 0);\n\t\t}\n\t\tif (dcmp(X-x[i][0]) > 0 && dcmp(X-x[i][1]) < 0)\n\t\t{\n\t\t\tif (dcmp(y[i][0]-Y) >= 0)\n\t\t\t\tMaxAc = min(MaxAc, y[i][0]);\n\t\t}\n\t}\n\n\tVec.push_back(make_pair(-inf, 0));\n\tVec.push_back(make_pair(inf, 0));\n\tsort(Vec.begin(), Vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < Vec.size(); i++)\n\t{\n\t\ttmp += Vec[i].second;\n\t\tif (tmp == n)\n\t\t{\n\t\t\tfor (;;);\n\t\t\tif (tmp == n && judge(Vec[i].first, Vec[i+1].first))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n\t{\n\t\tinit();\n\t\tputs(solve()? \"Yes\": \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-8\nconst int maxn=800;\nconst int INF=199999999;\nconst double pi=asin(1.0);\nint dcmp(double x)\n{\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\nstruct ju\n{\n    double l,b,r,t;\n}p[maxn];\nbool ok(double l,double r,double x)\n{\n    if(dcmp(x-r)<=0&&dcmp(x-l)>=0)  return 1;\n    return 0;\n}\nint main()\n{\n    int n;\n    double v,X,Y;\n    scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p[i].l,&p[i].b,&p[i].r,&p[i].t);\n    }\n    double g=9.8;\n    for(int k=0;k<=999999;k++)\n    {\n        double jiao=pi*k/1000000.0;\n        bool sign=0;\n        for(int i=0;i<n;i++)\n        {\n            double x=p[i].l;\n            double y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            x=p[i].r;\n            y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            double a=-g/2.0/(v*v*cos(jiao)*cos(jiao));\n            double b=tan(jiao);\n            double c=-p[i].b;\n            if(b*b-4.0*a*c>0)\n            {\n                double x1=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n                double x2=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n                if(ok(p[i].l,p[i].r,x1))    sign=1;\n                if(ok(p[i].l,p[i].r,x2))    sign=1;\n            }\n            if(sign)    break;\n        }\n        if(sign) continue;\n        double y=tan(jiao)*X-g/2.0*X*X/(v*v*cos(jiao)*cos(jiao));\n        if(dcmp(y-Y)<0) continue;\n        for(int j=0;j<n;j++)\n        {\n            if(p[j].l<X&&p[j].r>X)\n            {\n                if(dcmp(y-p[j].b)<=0)   continue;\n                if(dcmp(Y-p[j].t)>=0)   continue;\n                sign=1;\n                break;\n            }\n        }\n        if(!sign)\n        {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "# include <cstdio>\n# include <cmath>\n# include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double g = 9.8;\nconst int MAX_N = 50;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ninline double calc(double vy , double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\n\ninline int cmp(double lb , double ub , double a)\n{\n\treturn a < lb + EPS  ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check(double qx , double qy)\n{\n\tdouble a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n\tdouble D = b * b - 4 * a * c;\n\t\n\tif(D < 0 && D > -EPS)\n\t\tD = 0;\n\t\n\tif(D < 0)\n\t\treturn 0;\n\t\n\tint d, i;\n\tfor(d = -1 ; d <= 1 ; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\t\n\t\tif(t2 <= 0)\n\t\t\tcontinue;\n\t\t\t\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\t\t\n\t\tdouble yt = calc(vy , X / vx);\n\t\tif(yt < Y - EPS)\n\t\t\tcontinue;\n\t\t\t\n\t\tbool ok = 1;\n\t\tfor(i = 0 ; i < N ; i++)\n\t\t{\n\t\t\tif(L[i] >= X)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tif(R[i] == X && Y <= T[i] && B[i] <= yt)\n\t\t\t\tok = 0;\n\t\t\t\t\n\t\t\tint yL = cmp(B[i] , T[i] , calc(vy , L[i] / vx));\n\t\t\tint yR = cmp(B[i] , T[i] , calc(vy , R[i] / vx));\n\t\t\tint xH = cmp(L[i] , R[i] , vx * (vy / g));\n\t\t\tint yH = cmp(B[i] , T[i] , calc(vy , vy / g));\n\t\t\t\n\t\t\tif(xH == 0 && yH >= 0 && yL < 0 && yL < 0)\n\t\t\t\tok = 0;\n\t\t\t\t\n\t\t\tif(yL * yR <= 0)\n\t\t\t\tok = 0;\n\t\t}\n\t\tif(ok)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid solve()\n{\n\tint i;\n\tfor(i = 0 ; i < N ; i++)\n\t{\n\t\tR[i] = min(R[i] , X);\n\t}\n\t\n\tbool ok = check(X , Y);\n\t\n\tfor(i = 0 ; i < N ; i++)\n\t{\n\t\tok |= check(L[i] , T[i]);\n\t\tok |= check(R[i] , T[i]);\n\t}\n\t\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d %d %d\", &N, &V, &X, &Y))\n\t{\n\t\tint i;\n\t\tfor(i = 0 ; i < N ; i++)\\\n\t\t\tscanf(\"%d %d %d %d\", &L[i], &B[i], &R[i], &T[i]); \n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] && b.ys[1] < y_min + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tup = min(up, bs[i].ys[0]);\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst double g=9.8;\nconst double eps= 1e-8;\n\nint N; double V,X,Y;\n\ndouble L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\ndouble Calcy(double vy,double t){return vy*t-0.5*g*t*t;}\ndouble Calcx(double vx,double t){return vx*t;}\n\nint cmp(double lb,double ub,double a)\n{\n  return a<lb ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(double x,double y) // ????????????(x,y) \n{\n  double a=0.25*g*g; double b=g*y-V*V; double c=x*x+y*y;\n  double delta= b*b-4*a*c;\n  if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    double vx=x/t; double vy=(y+0.5*g*t*t)/t; //?????????\n    double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y);\n  for(int i=1;i<=N;i++) scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble lx[100];\ndouble ly[100];\ndouble rx[100];\ndouble ry[100];\ndouble EPS=1e-9;\nvector<pair<double,double> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a;\n\tdouble b,c,d;\n\tscanf(\"%d%lf%lf%lf\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf%lf\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\trx[i]=min(rx[i],c);\n\t\t//v.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\t//v.push_back(make_pair(min(rx[i],c),ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-9.8*9.8*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\tdouble hg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=c-EPS)continue;\n\t\t\tif(ABS(rx[j]-c)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(p+EPS<ry[j]&&ry[j]+EPS<q)ok=false;\n\t\t\tif(q+EPS<ly[j]&&ly[j]+EPS<p)ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t//\tif(th-EPS>ly[j]){\n\t\t\t\tif(EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j]&&th>ly[j]+EPS&&ly[j]+EPS>calc(vy,lx[j]/vx)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t//\t}\n\t\t\t\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\thg=calc(vy,(double)c/vx);\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(lx[j]>=c-EPS)continue;\n\t\t\tif(ABS(rx[j]-c)<EPS&&d<=ry[j]&&ly[j]<=hg)ok=false;\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(p+EPS<ry[j]&&ry[j]+EPS<q)ok=false;\n\t\t\tif(q+EPS<ly[j]&&ly[j]+EPS<p)ok=false;\n\t\t\tdouble th=calc(vy,vy/9.8);\n\t\t//\tif(th-EPS>ly[j]){\n\t\t\t\tif(EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j]&&th>ly[j]+EPS&&ly[j]+EPS>calc(vy,lx[j]/vx)){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t//\t}\n\t\t\t\n\t\t}\n\t\tif(hg<(double)d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define sqr(x) ((x)*(x))\ntypedef pair<double,double> point;\n\nconst double g=9.8;\nconst double eps=1e-8;\ndouble v;\n\nstruct para\n{\n\tdouble a,b;\n\tpara(){a=b=0;}\n\tpara(double te){b=te;a=-g*(b*b+1)/2/v/v;}\n\tdouble qz(double x) {return a*x*x+b*x;}\n};\n\nvector<para> init(double x,double y)\n{\n\tvector<para> res;\n\tdouble at=g*x*x/2/v/v,bt=-x,ct=y+g/2/v/v*x*x;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(para(pbt));return res;}\n\tres.push_back(para(pbt+sqrt(pbs)/2/at));\n\tres.push_back(para(pbt-sqrt(pbs)/2/at));\n\treturn res;\n}\nvector<double> sol(double at,double bt,double ct)\n{\n\tvector<double> res;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(pbt);return res;}\n\tres.push_back(pbt+sqrt(pbs)/2/at);\n\tres.push_back(pbt-sqrt(pbs)/2/at);\n\treturn res;\n}\n\nstruct rect\n{\n\tdouble xl,xu,yl,yu;\n\trect(double xt=0,double yt=0,double xtt=0,double ytt=0):xl(xt),xu(xtt),yl(yt),yu(ytt){}\n};\n\nbool intersect(rect r,para p)\n{\n\tdouble t1=p.qz(r.xl),t2=p.qz(r.xu);\n\tif(t1>r.yl+eps&&t1<r.yu-eps) return true;\n\tif(t2>r.yl+eps&&t2<r.yu-eps) return true;\n\tif(fabs(t1-r.yl)<eps&&fabs(t2-r.yu)<eps) return true;\n\tif(fabs(t2-r.yl)<eps&&fabs(t1-r.yu)<eps) return true;\n\tvector<double> r1=sol(p.a,p.b,-r.yl);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\tr1=sol(p.a,p.b,-r.yu);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\treturn false;\n}\n\nint n;\nint v12,x12,y12;\ndouble x,y;\nvector<point> po;\nvector<rect> ret;\n\nvoid solve()\n{\n\tint i,j,k,l;\n\tv=v12;x=x12;y=y12;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tint xt[5];\n\t\tfor(j=0;j<4;j++) scanf(\"%d\",xt+j);\n\t//\tif(xt[0]>xt[2]||xt[1]>xt[3]) continue;\n\t\tfor(j=0;j<4;j+=2) for(k=1;k<4;k+=2) if(xt[j]&&xt[k]) po.push_back(point(xt[j],xt[k]));\n\t       \tret.push_back(rect(xt[0],xt[1],xt[2],xt[3]));\n\t}\n\tpo.push_back(point(x,y));\n\tn=ret.size();\n\tfor(i=0;i<po.size();i++)\n\t{\n\t\tvector<para> tet=init(po[i].first,po[i].second);\n\t\tif(tet.empty()) continue;\n\t\tfor(l=0;l<tet.size();l++)\n\t\t{\n\t\t\tif(tet[l].qz(x)<y-eps) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(intersect(ret[j],tet[l])) break;\n\t\t\t}\n\t\t\tif(j<n) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tif(x>ret[j].xl+eps&&x<ret[j].xu-eps&&tet[l].qz(x)>ret[j].yu+eps&&y<ret[j].yu+eps) break;\n\t\t\tif(j<n) continue;\n\t\t\tprintf(\"Yes\\n\");return;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\nint main()\n{\n\twhile(scanf(\"%d %d %d %d\",&n,&v12,&x12,&y12)!=EOF)\n\t{solve();}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst double g = 9.8;\nconst double eps = 1e-10;\nconst int maxn = 500;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ndouble cal(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool check(double qx, double qy)\n{\n    double a = g * g / 4, B = g * qy - v * v, c = qx * qx + qy * qy;\n    double d = B * B - 4 * a * c;\n    if(d < 0 && d > -eps) d = 0;\n    if(d < 0) return false;\n    for(int d = -1; d <= 1; d += 2)\n    {\n        double t2 = (-B + d * sqrt(d)) / (2 * a);\n        if(t2 <= 0) continue;\n        double T = sqrt(t2);\n        double vx = qx / T, vy = (qy + g * T * T / 2) / T;\n        double yt = cal(vy, x / vx);\n        if(yt < y - eps) continue;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++)\n        {\n            if(l[i] >= x) continue;\n            if(r[i] == x && y <= t[i] && b[i] <= yt)\n                ok = false;\n            int yl = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy, l[i]/ vx));\n            int yr = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy, r[i]/ vx));\n            int xh = cmp(1.0 * l[i], 1.0 * r[i], 1.0 * vx * (vy / g));\n            int yh = cmp(1.0 * b[i], 1.0 * t[i], 1.0 * cal(vy , vy / g));\n            if(xh == 0 && yh >= 0 && yl < 0) ok = false;\n            if(yl * yr <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    for(int i = 0; i < n; i++)\n    {\n        r[i] = min(r[i], x);\n    }\n    bool ok = check(x, y);\n    for(int i = 0; i < n; i++)\n    {\n        ok |= check(l[i], t[i]);\n        ok |= check(r[i], t[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d%d\", &n, &v, &x, &y))\n    {\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-7;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n\n  if( vy < eps ) return false;\n  \n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = vy / g;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt ,vy);\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n\n    if( ft<= zt && zt <= st ){\n      if( check( B[i], T[i], fh, zh ) )return false;\n      if( check( B[i], T[i], zh, sh ) )return false;\n    }\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < 0 )return false;\n  if( abs(A) < eps ) return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n\n  if( V < eps ){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  \n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n  }\n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n    if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-8\nconst int maxn=800;\nconst int INF=199999999;\nconst double pi=asin(1.0)*2.0;\nint dcmp(double x)\n{\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\nstruct ju\n{\n    double l,b,r,t;\n}p[maxn];\nbool ok(double l,double r,double x)\n{\n    if(dcmp(x-r)<=0&&dcmp(x-l)>=0)  return 1;\n    return 0;\n}\nint main()\n{\n    int n;\n    double v,X,Y;\n    scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p[i].l,&p[i].b,&p[i].r,&p[i].t);\n    }\n    double g=9.8;\n    for(int k=0;k<=999999;k++)\n    {\n        double jiao=pi*k/2000000.0;\n\n        bool sign=0;\n        for(int i=0;i<n;i++)\n        {\n            double x=p[i].l;\n            double y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            x=p[i].r;\n            y=tan(jiao)*x-g/2.0*x*x/(v*v*cos(jiao)*cos(jiao));\n            if(ok(p[i].b,p[i].t,y)) sign=1;\n            double a=-g/2.0/(v*v*cos(jiao)*cos(jiao));\n            double b=tan(jiao);\n            double c=-p[i].b;\n            if(b*b-4.0*a*c>0)\n            {\n                double x1=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n                double x2=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n                if(ok(p[i].l,p[i].r,x1))    sign=1;\n                if(ok(p[i].l,p[i].r,x2))    sign=1;\n            }\n            if(sign)    break;\n        }\n        if(sign) continue;\n        double y=tan(jiao)*X-g/2.0*X*X/(v*v*cos(jiao)*cos(jiao));\n        if(dcmp(y-Y)<0) continue;\n        for(int j=0;j<n;j++)\n        {\n            if(p[j].l<=X&&p[j].r>=X)\n            {\n                if(dcmp(y-p[j].b)<=0)   continue;\n                if(dcmp(Y-p[j].t)>=0)   continue;\n                sign=1;\n                break;\n            }\n        }\n        if(!sign)\n        {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int maxn = 55;\nconst double eps = 1e-8, inf = 1e5, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\ndouble MaxAc;\nV all;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init(int T)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n    if (T == 766)\n    {\n        freopen(\"in\", \"w\", stdout);\n        printf(\"%d %lf %lf %lf\\n\", n, v, X, Y);\n        for (int i = 0; i < n; i++)\n            printf(\"%lf %lf %lf %lf\\n\", x[i][0], y[i][0], x[i][1], y[i][1]);\n    }\n}\n\n// sign == 0: >= 0\n// sign == 1: <= 0\nvoid cal(double a, double b, double c, int sign, V &vec)\n{\n    if (sign)\n        a = -a, b = -b, c = -c;\n    vec.clear();\n    if (!dcmp(a))\n    {\n        if (!dcmp(b))\n        {\n            if (dcmp(c) >= 0)\n            {\n                vec.push_back(make_pair(-inf, +1));\n                vec.push_back(make_pair(+inf, -1));\n            }\n            return;\n        }\n        double d = -c/b;\n        if (dcmp(b) < 0)\n        {\n            vec.push_back(make_pair(-inf, +1));\n            vec.push_back(make_pair(d, -1));\n        }\n        else\n        {\n            vec.push_back(make_pair(d, +1));\n            vec.push_back(make_pair(inf, -1));\n        }\n        return;\n    }\n    double delta = b*b - 4*a*c;\n    if (dcmp(delta) <= 0)\n    {\n        if (dcmp(a) > 0)\n        {\n            vec.push_back(make_pair(-inf, 1));\n            vec.push_back(make_pair(inf, -1));\n        }\n        return;\n    }\n\n    delta = sqrt(delta);\n    double t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n    if (dcmp(t1-t2) > 0) swap(t1, t2);\n    double f1 = a*t1*t1 + b*t1 + c;\n    double f2 = a*t2*t2 + b*t2 + c;\n    if (dcmp(a) > 0)\n    {\n        vec.push_back(make_pair(-inf, +1));\n        vec.push_back(make_pair(t1, -1));\n        vec.push_back(make_pair(t2, +1));\n        vec.push_back(make_pair(inf, -1));\n    }\n    else\n    {\n        vec.push_back(make_pair(t1, +1));\n        vec.push_back(make_pair(t2, -1));\n    }\n}\n\nvoid Bing(V vecs[], int n, V &vec)\n{\n    vec.clear();\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < vecs[i].size(); j++)\n        {\n            vec.push_back(vecs[i][j]);\n            if (vecs[i][j].second > 0)\n                vec.back().second = +(i+1);\n            else\n                vec.back().second = -(i+1);\n        }\n    }\n}\n\nV And(V vecs[], int n)\n{\n    V vec, ret;\n    Bing(vecs, n, vec);\n    static int cnt[maxn];\n    for (int i = 1; i <= n; i++)\n        cnt[i] = 0;\n    sort(vec.begin(), vec.end());\n\n    LL need = (1LL<<n) - 1;\n    need <<= 1;\n    for (int i = 0; i+1 < vec.size(); i++)\n    {\n        if (vec[i].second > 0)\n            cnt[+vec[i].second]++;\n        if (vec[i].second < 0)\n            cnt[-vec[i].second]--;\n\n        LL mask = 0;\n        for (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\n        if (mask == need)\n        {\n            ret.push_back(make_pair(vec[i+0].first, +1));\n            ret.push_back(make_pair(vec[i+1].first, -1));\n        }\n    }\n    return ret;\n}\n\nV Or(V vecs[], int n)\n{\n    V vec, ret;\n    Bing(vecs, n, vec);\n    static int cnt[maxn];\n    for (int i = 1; i <= n; i++)\n        cnt[i] = 0;\n    sort(vec.begin(), vec.end());\n\n    for (int i = 0; i+1 < vec.size(); i++)\n    {\n        if (vec[i].second > 0)\n            cnt[+vec[i].second]++;\n        if (vec[i].second < 0)\n            cnt[-vec[i].second]--;\n\n        LL mask = 0;\n        for (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n        if (mask)\n        {\n            ret.push_back(make_pair(vec[i+0].first, +1));\n            ret.push_back(make_pair(vec[i+1].first, -1));\n        }\n    }\n    return ret;\n}\n\nV Exclusive(V vecs[], int n)\n{\n    V vec, ret;\n    Bing(vecs, n, vec);\n    static int cnt[maxn];\n    for (int i = 1; i <= n; i++)\n        cnt[i] = 0;\n    sort(vec.begin(), vec.end());\n\n    for (int i = 0; i+1 < vec.size(); i++)\n    {\n        if (vec[i].second > 0)\n            cnt[+vec[i].second]++;\n        if (vec[i].second < 0)\n            cnt[-vec[i].second]--;\n\n        LL mask = 0;\n        for (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n        if (mask == 2)\n        {\n            ret.push_back(make_pair(vec[i+0].first, +1));\n            ret.push_back(make_pair(vec[i+1].first, -1));\n        }\n    }\n    return ret;\n}\n\nvoid show(V &v)\n{\n    for (int i = 0; i < v.size(); i += 2)\n        printf(\"%lf ~ %lf\\n\", v[i].first, v[i+1].first);\n}\n\nvoid add(double x1, double x2, double y, int sign, V &vec)\n{\n    //printf(\"%lf %lf\\n\", x1, x2);\n    vec.clear();\n\n    double p = g / (2 * v * v);\n    double a, b, c;\n    static V tmp[3], tmp2[2];\n    static V mid[2];\n\n    cal(2*p*x1, -1, 2*p*x1, 1, tmp[0]);\n    cal(2*p*x2, -1, 2*p*x2, 0, tmp[1]);\n\n    mid[0] = all;\n    mid[1] = And(tmp, 2);\n\n    //show(mid[1]);\n\n    V &Mid = mid[1];\n    V Other = Exclusive(mid, 2);\n\n    tmp[0] = Mid;\n    a = 1-4*p*y, b = 0, c = -4*p*y;\n    cal(a, b, c, sign, tmp[1]);\n    tmp2[0] = And(tmp, 2);\n\n    //puts(\"0\");\n    //show(tmp2[0]);\n\n    tmp[0] = Other;\n    cal(-p*x1*x1, x1, -p*x1*x1-y, sign, tmp[1]);\n    cal(-p*x2*x2, x2, -p*x2*x2-y, sign, tmp[2]);\n    tmp2[1] = And(tmp, 3);\n\n    //puts(\"2\");\n    //show(tmp2[1]);\n\n    vec = Or(tmp2, 2);\n}\n\nbool judge(double l, double r)\n{\n    double p = g / (2*v*v);\n    double a = -p*X*X, b = X, c = -p*X*X;\n    double fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n    double t = -b / (2*a);\n    double Min = min(fl, fr);\n    double Max = max(fl, fr);\n    double ft = a*t*t + b*t + c;\n    if (dcmp(t-l) >= 0 && dcmp(t-r) <= 0)\n        Max = ft;\n\n//    printf(\"f(%lf) = %lf\\n\", t, ft);\n//    printf(\"%lf -- %lf\\n\", l, r);\n//    printf(\"%lf %lf\\n\", Min, Max);\n//    printf(\"%lf %lf\\n\", Y, MaxAc);\n\n    return dcmp(Y-Min) >= 0 && dcmp(Y-Max) <= 0 || dcmp(MaxAc-Min) >= 0 && dcmp(MaxAc-Max) <= 0;\n}\n\nbool solve()\n{\n    if (!dcmp(v))\n        return false;\n\n    static V res[maxn];\n\n    int m = 0;\n    MaxAc = inf;\n    for (int i = 0; i < n; i++)\n    {\n        if (dcmp(x[i][0]-X) < 0)\n        {\n            x[i][1] = min(X, x[i][1]);\n            static V vec[2];\n            add(x[i][0], x[i][1], y[i][0], 1, vec[0]);\n            add(x[i][0], x[i][1], y[i][1], 0, vec[1]);\n            res[m] = Or(vec, 2);\n            m++;\n        }\n        if (dcmp(X-x[i][0]) > 0 && dcmp(X-x[i][1]) < 0)\n        {\n            if (dcmp(y[i][0]-Y) >= 0)\n                MaxAc = min(MaxAc, y[i][0]);\n        }\n    }\n    res[m++] = all;\n\n    V suf = And(res, m);\n    for (int i = 0; i < suf.size(); i += 2)\n        if (judge(suf[i].first, suf[i+1].first))\n            return true;\n\n    return false;\n}\n\nint main()\n{\n    all.push_back(make_pair(-inf, +1));\n    all.push_back(make_pair(+inf, -1));\n    //freopen(\"out1\", \"w\", stdout);\n    int T = 0;\n    while (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n    {\n        init(++T);\n        puts(solve()? \"Yes\": \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:ub<a+eps?1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]-EPS && yof(vy, vy/g)>B[i]-EPS) return false;\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i]) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstatic const double EPS = 1e-10;\nstatic const int MAX_N = 50;\nstatic const double G = 9.8;\n\nint N;\ndouble V, X, Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t) {\n  return vy * t - 0.5 * G * t * t;\n}\n\nint cmp(double a, double b, double x) {\n  if (x < a + EPS) return -1;\n  if (x > b - EPS) return 1;\n  return 0;\n}\n\nbool check(double tx, double ty) {\n  double a = (1.0 / 4.0) * G * G;\n  double b = G * ty - V * V;\n  double c = tx * tx + ty * ty;\n\n  double D = b * b - 4.0 * a * c;\n  if (fabs(D) <= EPS) D = 0.0;\n  if (D < 0) return false;\n  for (int d = -1; d <= 1; d+=2) {\n    double t_squared = (-b + d * sqrt(D)) / (2.0 * a);\n    if (t_squared <= 0) continue;\n\n    // calc initial velocity to hit (tx, ty)\n    double t = sqrt(t_squared);\n    double vx = tx / t;\n    double vy = (ty + 0.5 * G * t * t) / t;\n\n    // check if the course is beyond pig\n    double py = calc(vy, X / vx);\n    if (py < Y - EPS) continue;\n\n    // check if the course is clear\n    bool isClear = true;\n    for (int i = 0; i < N; i++) {\n      if (L[i] >= X) continue;\n      if (R[i] >= X && T[i] >= Y && B[i] <= py) {\n        isClear = false;\n        break;\n      }\n      double ly = calc(vy, L[i] / vx);\n      double ry = calc(vy, R[i] / vx);\n      int posL = cmp(B[i], T[i], ly);\n      int posR = cmp(B[i], T[i], ry);\n      if (posL * posR <= 0) {\n        isClear = false;\n        break;\n      }\n\n      double ht = vy / G;\n      int posX_high = cmp(L[i], R[i], vx * ht);\n      double hy = calc(vy, ht);\n      int posH = cmp(B[i], T[i], hy);\n      if (posX_high == 0 && posH >= 0 && posL < 0) {\n        isClear = false;\n        break;\n      }\n    }\n    if (isClear) return true;\n  }\n  return false;\n}\n\nbool solve() {\n  for (int i = 0; i < N; i++) {\n    R[i] = min(R[i], X);\n  }\n  if (check(X, Y)) return true;\n  for (int i = 0; i < N; i++) {\n    if (check(L[i], T[i]) || check(R[i], T[i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> V >> X >> Y;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n\n  bool isOK = solve();\n  cout << (isOK ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB eps = 1e-8;\nconst int N = 150007;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\n\nconst double PI = acos(-1);\nconst double gg = 9.8;\n\n//double CalcMaxCeta(double X) {\n//    double l = 0.0, r = PI / 2;\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid1 = l + (r - l) / 3.0;\n//        double mid2 = r - (r - l) / 3.0;\n//        if (CalcHeight(mid1, X) > CalcHeight(mid2, X)) {\n//            l = mid2;\n//        } else {\n//            r = mid1;\n//        }\n//    }\n//    return l;\n//}\n//\n//double BinarySearch(bool op, double l, double r, double X, double Y) {\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid = (l + r) / 2.0;\n//        double height = CalcHeight(mid, X);\n//        if (op == 0) { // ascending\n//            if (height > Y) r = mid; else l = mid;\n//        } else { // descending\n//            if (height > Y) l = mid; else r = mid;\n//        }\n//    }\n//}\n\n\ndouble V;\nint low;\n\nint sgn(double x){\n    return x < -eps ? -1 : x > eps;\n}\n\n\ninline double CalcHeight(double ceta, double X) {\n    double t = X / (V * cos(ceta));\n    double y = (V * sin(ceta)) * t - 0.5 * gg * t * t;\n    return y;\n}\n\ninline double GetM(double ceta) {\n    double t = V * sin(ceta) / gg;\n    return V * cos(ceta) * t;\n}\n\n\nint n, X, Y, l[N], b[N], r[N], t[N];\n\nbool Gao(double ceta) {\n    double hh = CalcHeight(ceta, X);\n//    cout << ceta << ' ' << X << ' ' << hh << ' ' << Y << ' ' << low << endl;\n    if (sgn(hh - Y ) < 0  || sgn(hh-low) > 0 )  {\n        return false;\n    }\n//    cout << \"~\";\n\n    double mx = GetM(ceta);\n    double my = CalcHeight(ceta, mx);\n\n\n    for (int i = 1; i <= n; i ++) {\n        if (l[i] > X) continue;\n\n        DB h1 = CalcHeight(ceta, l[i]);\n        DB h2 = CalcHeight(ceta, r[i]);\n\n\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (! (h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (! (h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n\n\n\n        /*double delta = (r[i] - l[i]) / 100.0;\n        int sum1 = 0, sum2 = 0;\n        for (int j = 0; j < 100; j ++) {\n            double ss = delta * j + l[i];\n            double h3 = CalcHeight(ceta, ss);\n            sum1 += sgn(h3 - b[i]);\n            sum2 += sgn(h3 - t[i]);\n        }\n        if (sum1 == -100 || sum2 == 100) {\n        } else {\n            return false;\n        }*/\n    }\n    return true;\n}\n\nbool Check() {\n//    double maxCeta = CalcMaxCeta(X);\n//    double maxHeight = CalcHeight(maxCeta, X);\n//    if (maxHeight < Y) {\n//        return false;\n//    }\n//    if (Gao(PI / 4.0)) return true;\n    if (X == 0 && Y == 0) {\n        return true;\n    }\n    else if (X == 0){\n        double hhh = CalcHeight(PI / 2, 0);\n        if (sgn(hhh - Y) < 0) return false;\n        for (int i = 1; i <= n; i ++) {\n            if (l[i] == 0 && b[i] <= Y)\n                return false;\n        }\n        return true;\n    }\n    for (int i = 1; i <= n; i ++){\n        if (l[i] == 0 && b[i] == 0) {\n            return false;\n        }\n\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n\n    }\n    for (double i = 0, delta = PI / 2 / 15000.0; i <= PI / 2; i += delta) {\n        if (Gao(i)) return true;\n    }\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (scanf(\"%d%lf%d%d\", &n, &V, &X, &Y) == 4) {\n        low = INF;\n        for (int i = 1; i <= n; i ++) {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] <= X && X <= r[i]) {\n                if (Y >= t[i]) continue;\n                low = min(low, (int)b[i]);\n            }\n        }\n//        cout << low << endl;\n        if (Check()) puts(\"Yes\");\n        else puts(\"No\");\n//        break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        if(l > X) continue;\n        if(r > X) r = X;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAX_N = 55;\nconst double EPS=1e-7;\nconst double g=9.8;\nint N,V,X,Y;\nint L[MAX_N],B[MAX_N],T[MAX_N],R[MAX_N];\ndouble height(double vy, double t) {\n    return vy*t-g*t*t/2;\n}\nint cmp(double lb,double ub,double a) {\n    return a<lb+EPS?-1:a>ub-EPS?1:0;\n}\nbool check(double x,double y) {\n    // ??????\n    double a=g*g/4,b=y*g-V*V,c=x*x+y*y,vx,vy,t,t2,yt;\n    double det=b*b-4*a*c;\n    if(det>-EPS&&det<0) det=0;\n    if(det<0) return false;\n    for(int d=-1;d<=1;d+=2) {\n        t2=(-b+d*sqrt(det))/(2*a);\n        if(t2<=0) continue;\n        t=sqrt(t2);\n        vx=x/t;vy=(y+g*t*t/2)/t;\n        yt=height(vy,X/vx);\n        if(yt<Y-EPS) continue;\n\n        bool ok=true;\n        for(int i=0;i<N;i++) {\n            if(L[i]>=X) continue;\n            if(R[i]>=X&&Y<=T[i]&&yt>=B[i]) ok=false;\n            int yL=cmp(B[i],T[i],height(vy,L[i]/vx));\n            int yR=cmp(B[i],T[i],height(vy,R[i]/vx));\n            int xH=cmp(L[i],R[i],vx*(vy/g));\n            int yH=cmp(B[i],T[i],height(vy,vy/g));\n            if(xH==0&&yH>=0&&yL<0) ok=false;\n            if(yL*yR<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main() {\n    scanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d%d%d%d\",L+i,B+i,R+i,T+i);\n    }\n    bool ok=check(X,Y);\n    for(int i=0;i<N;i++) {\n        ok|=check(L[i],T[i]);\n        ok|=check(R[i],T[i]);\n    }\n    printf(\"%s\\n\",ok?\"Yes\":\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\n\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<eps || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=min(OB,B[i]);\n\t}\n\tadd(X,Y);\n\tif(Tan.size()==0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center+eps<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\n\t\t\tif(!(My+eps<B[j] || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100;\nconst double eps = 1e-8;\n\ndouble L[MAXN],B[MAXN],R[MAXN],T[MAXN];\nint N;\ndouble V,X,Y;\ndouble vx,vy,vv,hei;\n\ndouble getvx1(double X,double Y)\n{\n\tdouble maxx = vv,minx = 0;\n\twhile(maxx - minx > eps)\n\t{\n\t\tdouble midx = (maxx + minx) / 2.0;\n\t\tdouble vvy = sqrt(V*V - midx*midx);\n\t\tdouble t = X/midx;\n\t\tdouble y = vvy * t - 0.5*9.8 * t*t;\n\t\tif (y > 0) maxx = midx; else minx = midx;\n\t}\n\treturn maxx;\n}\n\ndouble getvx2(double X,double Y)\n{\n\tdouble maxx = V,minx = vv;\n\twhile(maxx - minx > eps)\n\t{\n\t\tdouble midx = (maxx + minx) / 2.0;\n\t\tdouble vvy = sqrt(V*V - midx*midx);\n\t\tdouble t = X/midx;\n\t\tdouble y = vvy * t - 0.5*9.8 * t*t;\n\t\tif (y < 0) maxx = midx; else minx = midx;\n\t}\n\treturn maxx;\n}\n\nbool check(int k,double vx)\n{\n\tdouble vy = sqrt(V*V - vx*vx);\n\tdouble t = L[k]/vx;\n\tdouble y = vy*t - 0.5*9.8 * t*t;\n\t//printf(\"%lf %lf\\n\",X,y);\n\tif (y > B[k]+eps && y < T[k]-eps) return false;\n\tdouble yy1 = y;\n\t\n\tt = R[k]/vx;\n\ty = vy*t - 0.5*9.8 * t*t;\n\tif (y > B[k]+eps && y < T[k]-eps) return false;\n\tdouble yy2 = y;\n\t\n\tif ((yy1 > T[k]+eps && yy2 < B[k]-eps)||(yy2 > T[k]+eps && yy1 < B[k]-eps)) return false;\n\t\n\tt = vy / (0.5*9.8);\n\tdouble x = t * vx;\n\ty = vy*t - 0.5*9.8 * t*t;\n\tif (y > B[k]+eps && y < T[k]-eps && x > L[k]+eps && x < R[k]-eps) return false;\n\t\n\t\n\t\n\treturn true;\n}\n\nbool gaogao(double vx)\n{\n\t\t\tvy = sqrt(V*V-vx*vx);\n\t\t\tdouble t = X/vx;\n\t\t\tdouble y = vy*t - 0.5*9.8 * t*t;\n\t\t\t//printf(\"%lf\\n\",y);\n\t\t\tif (y > Y+eps && y < hei-eps)\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < N;i++) if (!check(i,vx)) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n}\n\nbool gao()\n{\n\t/*if (gaogao(getvx1(X,Y))) return true;\n\tif (gaogao(getvx2(X,Y))) return true;\n\tfor(int i = 0;i < N;i++)\n\t\t{\n\t\t\tif (gaogao(getvx1(L[i],T[i]))) return true;\n\t\t\tif (gaogao(getvx2(L[i],T[i]))) return true;\n\t\t}\n\tif (gaogao(vv)) return true;*/\n\tdouble dv = 0.0005;\n\tfor(double vx = 1e-6;vx < V;vx += dv-eps) if (gaogao(vx)) return true;\n\treturn false;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y) == 4)\n\t{\n\t\thei = 1e20;\n\t\tfor(int i = 0;i < N;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf%lf%lf\",L+i,B+i,R+i,T+i);\n\t\t\t//if (L[i] +eps < X && R[i]-eps > X && T[i]+eps > Y) hei = min(hei,B[i]);\n\t\t}\n\t\t\n\t\tvv = sqrt(V*V/2.0);\n\t\t\n\t\tif (gao()) puts(\"Yes\"); else puts(\"No\"); \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// written at 13:52 on 8 Feb 2017 \n#include <cctype>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <complex>\n#include <deque>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector> \n#include <utility>\n#include <bitset>\n\n#define IOS std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);\n// #define __DEBUG__\n#ifdef __DEBUG__\n\t#define DEBUG(...) printf(__VA_ARGS__)\n#else\n\t#define DEBUG(...)\n#endif\n#define filename \"\"\n#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".ans\", \"w\", stdout);\n#define resetfile() freopen(\"/dev/tty\", \"r\", stdin); freopen(\"/dev/tty\", \"w\", stdout); system(\"more \" filename\".ans\");\n#define rep(i, j, k) for (int i = j; i < k; ++i)\n#define irep(i, j, k) for (int i = j - 1; i >= k; --i)\n\nusing namespace std;\n\ntemplate <typename T>\ninline T sqr(T a) { return a * a;};\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int > Pii;\n\nconst double pi = acos(-1.0);\nconst int INF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = 1e2;\nconst double g = 9.8;\nconst double EPS = 1e-10;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t) {\n\treturn vy * t - g * sqr(t) / 2;\n}\nint cmp(double lb, double ub, double a) {\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check(double qx, double qy) {\n\tdouble a = sqr(g) / 4, b = g * qy - sqr(V), c = sqr(qx) + sqr(qy);\n\tdouble D = sqr(b) - 4 * a * c;\n\tif (D < 0 && D > -EPS) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2) {\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx / t, vy = (qy + g * sqr(t) / 2) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y - EPS) continue;\n\n\t\tbool ok = true;\n\t\trep(i, 0, N) {\n\t\t\tif (L[i] >= X) continue;\n\t\t\tif (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n\t\t\tint yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n\t\t\tint yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n\t\t\tint xH = cmp(L[i], R[i], vx * (vy / g));\n\t\t\tint yH = cmp(B[i], T[i], calc(vy, vy / g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0) ok = false;\n\t\t\tif (yL * yR <= 0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\trep(i, 0, N) R[i] = min(R[i], X);\n\tbool ok = check(X, Y);\n\trep(i, 0, N) {\n\t\tok |= check(L[i], T[i]);\n\t\tok |= check(R[i], T[i]);\n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n\trep(i, 0, N) scanf(\"%d%d%d%d\", L + i, B + i, R + i, T + i);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 50;\nconst double g = 9.8;\nconst double EPS = 1e-8;\n\nint N, V, X, Y, L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t){\n  return vy * t - g * t * t / 2.0;\n}\n\nint cmp(double lb, double ub, double a){\n  return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check(double qx, double qy){\n  double a = g * g / 4.0, b = g * qy - V * V, c = qx * qx + qy * qy;\n  double D = b * b - 4 * a * c;\n  if(D < 0 && D > -EPS) D = 0;\n  if(D < 0) return false;\n  for(int d = -1;d<=1;d += 2){\n    double t2 = (-b + d * sqrt(D)) / (2.0 * a);\n    if(t2 <= 0) continue;\n    double t = sqrt(t2);\n    double vx = qx / t, vy = (qy + g * t * t / 2.0) / t;\n    double yt = calc(vy, X / vx);\n    if(yt < Y - EPS) continue;\n\n    bool ok = true;\n    for(int i=0;i<N;i++){\n      if(L[i] >= X) continue;\n      if(R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n      int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n      int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n      int xH = cmp(L[i], R[i], vx * (vy / g));\n      int yH = cmp(B[i], T[i], calc(vy, vy / g));\n      if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n      if(yL * yR <= 0) ok = false;\n    }\n    if(ok) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++){\n    R[i] = min(R[i], X);\n  }\n  bool ok = check(X, Y);\n  for(int i=0;i<N;i++){\n    ok |= check(L[i], T[i]);\n    ok |= check(R[i], T[i]);\n  }\n  return ok;\n}\n\nmain(){\n  cin >> N >> V >> X >> Y;\n  for(int i=0;i<N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  cout << (solve() ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define RREP(i,s,e) for (i = s; i >= e; i--)\n#define rrep(i,n) RREP(i,n,0)\n#define REP(i,s,e) for (i = s; i < e; i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 100000000\n\ntypedef long long ll;\n\nint n;\ndouble v, x, y;\ndouble l[50], b[50], r[50], t[50];\ndouble g = 9.8;\n\ndouble cmp(double l, double u, double a) {\n    return a-1e-9 < l ? -1 : a+1e-9 > u ? 1 : 0;\n}\n\ndouble height(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n\nbool solve(int bx, int by) {\n    int i, j;\n    double a = g*g/4, bb = by*g-v*v, c = bx*bx+by*by;\n    double d = bb*bb - 4 * a * c;\n    if (d < 0)\n        return false;\n    for (int i = -1; i <= 1; i+=2) {\n        double t2 = (-bb+i*sqrt(d))/(2*a);\n        if (t2 <= 0)\n            continue;\n        double t1 = sqrt(t2);\n        double vx = bx / t1;\n        double vy = by/t1 + g*t1/2;\n        if (height(vy,x/vx) < y-1e-9) continue;\n        bool ok = true;\n        rep (j,n) {\n            if (l[j] >= x) continue;\n            if (r[j] == x && height(vy,x/vx) >= b[j] && y <= t[j]) ok = false;\n            int yL = cmp(b[j],t[j],height(vy,l[j]/vx));\n            int yR = cmp(b[j],t[j],height(vy,r[j]/vx));\n            int xH = cmp(l[j],r[j],vx*vy/g);\n            int yH = cmp(b[j],t[j],height(vy,vy/g));\n            if (yL*yR <= 0) ok = false;\n            if (yR < 0 && xH == 0 && yH >= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    int i;\n    bool ans;\n    cin >> n >> v >> x >> y;\n    rep (i,n) cin >> l[i] >> b[i] >> r[i] >> t[i];\n    rep (i,n) r[i] = min(r[i],x);\n    ans = solve(x,y);\n    rep (i,n) {\n        ans |= solve(l[i],t[i]);\n        ans |= solve(r[i],t[i]);\n    }\n    if (ans)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h)\n{\n        if (sgn(h - y) < 0) return false;\n        REP(i,n) if (inside(x, l[i], r[i])) {\n                if (inside(b[i], y, h)) return false;\n                if (inside(t[i], y, h)) return false;\n        }\n        return true;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(d) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        double h = f(x);\n        if (!hit(h)) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-6;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tif (L <= Y)continue;\n\t\tR = max(R, X);\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < bs.size(); ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < bs.size(); ++i) {\n\t\t\t\tauto b = bs[i];\n\t\t\t\t\n\t\t\t\tif (b.xs[0] == 42 && b.ys[0] == 43)continue;\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tauto b(bs.back());\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-4;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        if(cmp(r.top(), y_left) * cmp(r.top(), y_right) < 0) return false;\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) && cmp(top_y, r.bottom()) > 0) return false;\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = (-b + sqrt(D)) / (2*a);\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\n\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\ndouble Max,Min;\nvector<double> Tan;\n\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<eps || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=max(OB,B[i]);\n\t}\n\tadd(X,Y);\n\tif(Tan.size()==0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center+eps<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1+Tan[i]*Tan[i]);\n\n\t\t\tif(!(My+eps<B[j] || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int maxn = 55;\nconst double eps = 1e-8, inf = 1e5, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\ndouble MaxAc;\nV all;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init(int T)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n\tif (T == 2339)\n\t{\n\t\tfreopen(\"in\", \"w\", stdout);\n\t\tprintf(\"%d %lf %lf %lf\\n\", n, v, X, Y);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%lf %lf %lf %lf\\n\", x[i][0], y[i][0], x[i][1], y[i][1]);\n\t\texit(0);\n\t}\n}\n\n// sign == 0: >= 0\n// sign == 1: <= 0\nvoid cal(double a, double b, double c, int sign, V &vec)\n{\n\tif (sign)\n\t\ta = -a, b = -b, c = -c;\n\tvec.clear();\n\tif (!dcmp(a))\n\t{\n\t\tif (!dcmp(b))\n\t\t{\n\t\t\tif (dcmp(c) >= 0)\n\t\t\t{\n\t\t\t\tvec.push_back(make_pair(-inf, +1));\n\t\t\t\tvec.push_back(make_pair(+inf, -1));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tdouble d = -c/b;\n\t\tif (dcmp(b) < 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, +1));\n\t\t\tvec.push_back(make_pair(d, -1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvec.push_back(make_pair(d, +1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\tdouble delta = b*b - 4*a*c;\n\tif (dcmp(delta) <= 0)\n\t{\n\t\tif (dcmp(a) > 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, 1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\n\tdelta = sqrt(delta);\n\tdouble t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n\tif (dcmp(t1-t2) > 0) swap(t1, t2);\n\tdouble f1 = a*t1*t1 + b*t1 + c;\n\tdouble f2 = a*t2*t2 + b*t2 + c;\n\tif (dcmp(a) > 0)\n\t{\n\t\tvec.push_back(make_pair(-inf, +1));\n\t\tvec.push_back(make_pair(t1, -1));\n\t\tvec.push_back(make_pair(t2, +1));\n\t\tvec.push_back(make_pair(inf, -1));\n\t}\n\telse\n\t{\n\t\tvec.push_back(make_pair(t1, +1));\n\t\tvec.push_back(make_pair(t2, -1));\n\t}\n}\n\nvoid Bing(V vecs[], int n, V &vec)\n{\n\tvec.clear();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < vecs[i].size(); j++)\n\t\t{\n\t\t\tvec.push_back(vecs[i][j]);\n\t\t\tif (vecs[i][j].second > 0)\n\t\t\t\tvec.back().second = +(i+1);\n\t\t\telse\n\t\t\t\tvec.back().second = -(i+1);\n\t\t}\n\t}\n}\n\nV And(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tLL need = (1LL<<n) - 1;\n\tneed <<= 1;\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\n\t\tif (mask == need)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nV Or(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\t\tif (mask)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nV Exclusive(V vecs[], int n)\n{\n\tV vec, ret;\n\tBing(vecs, n, vec);\n\tstatic int cnt[maxn];\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tsort(vec.begin(), vec.end());\n\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\tif (vec[i].second > 0)\n\t\t\tcnt[+vec[i].second]++;\n\t\tif (vec[i].second < 0)\n\t\t\tcnt[-vec[i].second]--;\n\n\t\tLL mask = 0;\n\t\tfor (int j = 1; j <= n; j++) if (cnt[j]) mask |= 1LL<<j;\n\t\tif (mask == 2)\n\t\t{\n\t\t\tret.push_back(make_pair(vec[i+0].first, +1));\n\t\t\tret.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid show(V &v)\n{\n\tfor (int i = 0; i < v.size(); i += 2)\n\t\tprintf(\"%lf ~ %lf\\n\", v[i].first, v[i+1].first);\n}\n\nvoid add(double x1, double x2, double y, int sign, V &vec)\n{\n\t//printf(\"%lf %lf\\n\", x1, x2);\n\tvec.clear();\n\n\tdouble p = g / (2 * v * v);\n\tstatic V tmp[3], tmp2[2];\n\tstatic V mid[2];\n\n\tcal(2*p*x1, -1, 2*p*x1, 1, tmp[0]);\n\tcal(2*p*x2, -1, 2*p*x2, 0, tmp[1]);\n\n\tmid[0] = all;\n\tmid[1] = And(tmp, 2);\n\n\t//show(mid[1]);\n\n\tV &Mid = mid[1];\n\tV Other = Exclusive(mid, 2);\n\n\ttmp[0] = Mid;\n\tcal(1-4*p*y, 0, -4*p*y, sign, tmp[1]);\n\ttmp2[0] = And(tmp, 2);\n\n\t//puts(\"0\");\n\t//show(tmp2[0]);\n\n\ttmp[0] = Other;\n\tcal(-p*x1*x1, x1, -p*x1*x1-y, sign, tmp[1]);\n\tcal(-p*x2*x2, x2, -p*x2*x2-y, sign, tmp[2]);\n\ttmp2[1] = And(tmp, 3);\n\n\t//puts(\"2\");\n\t//show(tmp2[1]);\n\n\tvec = Or(tmp2, 2);\n}\n\nbool judge(double l, double r)\n{\n\tdouble p = g / (2*v*v);\n\tdouble a = -p*X*X, b = X, c = -p*X*X;\n\tdouble fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n\tdouble t = -b / (2*a);\n\tdouble Min = min(fl, fr);\n\tdouble Max = max(fl, fr);\n\tdouble ft = a*t*t + b*t + c;\n\tif (dcmp(t-l) >= 0 && dcmp(t-r) <= 0)\n\t\tMax = ft;\n\n\t//printf(\"f(%lf) = %lf\\n\", t, ft);\n\t//printf(\"%lf ~~ %lf\\n\", l, r);\n\t//printf(\"%lf %lf\\n\", Min, Max);\n\t//printf(\"%lf %lf\\n\", Y, MaxAc);\n\t//puts(\"\");\n\n\treturn dcmp(Y-Min) >= 0 && dcmp(Y-Max) <= 0 || dcmp(MaxAc-Min) >= 0 && dcmp(MaxAc-Max) <= 0;\n}\n\nbool solve()\n{\n\tif (!dcmp(v))\n\t\treturn false;\n\n\tstatic V res[maxn];\n\n\tint m = 0;\n\tMaxAc = inf;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp(x[i][0]-X) < 0)\n\t\t{\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\tx[i][1] = min(X, x[i][1]);\n\t\t\tstatic V vec[2];\n\t\t\tadd(x[i][0], x[i][1], y[i][0], 1, vec[0]);\n\t\t\tadd(x[i][0], x[i][1], y[i][1], 0, vec[1]);\n\t\t\tres[m] = Or(vec, 2);\n\t\t\tm++;\n\t\t}\n\t\tif (dcmp(X-x[i][0]) > 0 && dcmp(X-x[i][1]) < 0)\n\t\t{\n\t\t\tif (dcmp(y[i][0]-Y) >= 0)\n\t\t\t\tMaxAc = min(MaxAc, y[i][0]);\n\t\t}\n\t}\n\tres[m++] = all;\n\n\tV suf = And(res, m);\n\tfor (int i = 0; i < suf.size(); i += 2)\n\t\tif (judge(suf[i].first, suf[i+1].first))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main()\n{\n\tall.push_back(make_pair(-inf, +1));\n\tall.push_back(make_pair(+inf, -1));\n//\tfreopen(\"out1\", \"w\", stdout);\n\tint T = 0;\n\twhile (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n\t{\n\t\tinit(++T);\n\t\tputs(solve()? \"Yes\": \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\nconst int N = 60;\nint n, v, x, y, L[N], B[N], R[N], T[N];\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\nbool check(double qx, double qy) {\n    double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n    double d = b * b - 4 * a * c;\n    if (d < 0 && d > -eps) d = 0;\n    if (d < 0) return false;\n    for (int co = -1; co <= 1; co += 2) {\n        double t2 = (-b + co * sqrt(d)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        double yt = calc(vy, x / vx);\n        if (yt < y - eps) continue;\n        bool ok = true;\n        for (int i = 0; i < n; i++) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y <= T[i] && B[i] <= yt) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        R[i] = min(R[i], x);\n    }\n    bool ok = check(x,y);\n    for (int i = 0; i < n; i++) {\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d%d%d\", L + i, B + i, R + i, T + i);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-6;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        // Crash into left wall\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        // Crash into right wall\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        // Crash into top wall\n        if(cmp(y_left, r.top()) >= 0) {\n            if(cmp(y_right, r.top()) < 0) return false;\n        }\n        // Crash into bottom wall\n        if(cmp(y_left, r.bottom()) <= 0) {\n            if(cmp(y_right, r.bottom()) > 0) return false;\n        }\n        // Crash into bottom wall(2)\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        if(l > X) continue;\n        if(r > X) r = X;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<cstring>\n#include<map>\n#include<set>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<time.h>\nusing namespace std;\nconst int INF=1<<30;\ntypedef long long ll;\nconst double eps=1e-8;\n\n\nconst double g=9.8;\n\nint n,m;\ndouble v,x,y;\n\nstruct point{\n    double x,y;\n};\n\nstruct Matrix{\n    point a,b,c,d;\n}e[100];\n\ndouble gety(double vy,double t){\n    return vy*t-0.5*g*t*t;\n}\n\nint cmp(double l,double r,double a){\n    return a<l+eps?-1:a>r-eps?1:0;\n}\n\nbool juge(point Q){\n    int i,j,k;\n    double a=0.25*g*g,b=g*Q.y-v*v,c=Q.x*Q.x+Q.y*Q.y;\n    double D=(b*b-4.0*a*c);\n    if(D<0&&D>-eps)D=0;\n    if(D<0)return false;\n    for(i=-1;i<=1;i+=2){\n        double t=(i*sqrt(D)-b)/(2.0*a);\n        if(t<=0)continue;\n        double t1=sqrt(t);\n        double vx=Q.x/t1,vy=(0.5*g*t+Q.y)/t1;\n        double yt=gety(vy,x/vx);\n        if(yt<y-eps)continue;\n\n        bool ok=true;\n        for(j=0;j<n;j++){\n            if(e[j].a.x>=x)continue;\n            if(yt>=e[j].a.y&&y<=e[j].c.y&&e[j].d.x==x)ok=false;\n\n            int yL=cmp(e[j].c.y,e[j].a.y,gety(vy,e[j].a.x/vx));\n            int yR=cmp(e[j].d.y,e[j].b.y,gety(vy,e[j].b.x/vx));\n            int xH=cmp(e[j].a.x,e[j].b.x,vx*(vy/g));\n            int yH=cmp(e[j].c.y,e[j].a.y,gety(vy,(vy/g)));\n            if(xH==0&&yH>=0&&yL<0)ok=false;\n            if(yL*yR<=0)ok=false;\n        }\n        if(ok)return true;\n    }\n    return false;\n}\n\nint main()\n{\n    int i,j;\n    cin>>n>>v>>x>>y;\n    int cnt=0;\n    for(i=0;i<n;i++){\n        double x1,y1,x2,y2;\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n        if(x1>=x)continue;\n        if(x2>x)x2=x;\n        point a,b,c,d;\n        a.x=x1,a.y=y2;\n        b.x=x2,b.y=y2;\n        c.x=x1,c.y=y1;\n        d.x=x2,d.y=y1;\n        e[cnt].a=a,e[cnt].b=b,e[cnt].c=c,e[cnt++].d=d;\n    }\n    n=cnt;\n    int ok=0;\n    point W;W.x=x,W.y=y;\n    if(juge(W))ok=1;\n    if(ok){\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    for(i=0;i<n;i++){\n        if(juge(e[i].a)||juge(e[i].b))ok=1;\n    }\n    if(ok)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int i = -1; i <= 1; i += 2)\n\t{\n\t\tdouble t2 = (-b + i * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X <= bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, calc(vx, vy / g));\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].b);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-8;\nconst double g=9.8;\nconst int maxn=8000;\n\n#define Equ(a,b) ((fabs((a)-(b)))<(eps))\n#define Less(a,b) (((a)-(b))<(-(eps)))\n#define LessEqu(a,b) (((a)-(b))<(eps))\n#define More(a,b) (((a)-(b))>(eps))\n#define MoreEqu(a,b) (((a)-(b))>(-(eps)))\n\nint main()\n{\n    //freopen(\"12381.txt\",\"r\",stdin);\n\n    int n;\n    double v,X,Y,x,y,t,vx,vy,t1,t2,x1,x2;\n    double L[60],B[60],R[60],T[60];\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        }\n        if(Equ(v,0.0))\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n\n        bool flag=0;\n\n        for(int k=1;k<maxn;k++)\n        {\n            vx=v*k/maxn;\n            vy=sqrt(v*v-vx*vx);\n            t=X/vx;\n            y=vy*t-0.5*g*t*t;\n            if(Less(y,Y)) continue;\n\n            for(int i=0;i<n;i++)\n            {\n\n                if(MoreEqu(X,L[i]))\n                {\n                    t=L[i]/vx;\n                    y=vy*t-0.5*g*t*t;\n                    if(MoreEqu(y,B[i])&&LessEqu(y,T[i]))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*B[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*B[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*B[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*T[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*T[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*T[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                flag=1;\n            }\n\n            if(n==0) flag=1;\n\n            if(flag==1) break;\n        }\n\n        if(flag==1) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\ndouble K;\ndouble v;\n\nvoid kouhoth(int x, int y, vector<double> &TH)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\tif(d<0) return;\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\tif(kai1+EPS>0) TH.push_back(atan(kai1+EPS));\n\tif(kai1-EPS>0) TH.push_back(atan(kai1-EPS));\n\tif(kai2+EPS>0) TH.push_back(atan(kai2+EPS));\n\tif(kai2-EPS>0) TH.push_back(atan(kai2-EPS));\n}\n\ndouble f(double th, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble naka = 1.0*x - K*si*co;\n\treturn alpha * naka*naka + beta;\n}\n\nint main(){\n\tint n;\n\tint x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> L, B, R, T;\n\t\tvector<double> TH;\n\t\tK = 1.0*v*v/g;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\tif(x<l) continue;\n\t\t\tif(x<r) r = x;\n\t\t\tL.push_back(l);\n\t\t\tB.push_back(b);\n\t\t\tR.push_back(r);\n\t\t\tT.push_back(t);\n\t\t\tkouhoth(l,b,TH);\n\t\t\tkouhoth(r,b,TH);\n\t\t\tkouhoth(l,t,TH);\n\t\t\tkouhoth(r,t,TH);\n\t\t}\n\t\tkouhoth(x,y,TH);\n\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<TH.size(); i++){\n\t\t\tdouble th = TH[i];\n\t\t\tdouble mauey = f(th,x);\n\t\t\tif(mauey < y) continue;\n\t\t\tbool dameflg = false;\n\n\t\t\t// ツ津環嘉淞チツェツッツク\n\t\t\tfor(int j=0; j<L.size(); j++){\n\t\t\t\tif(\n\t\t\t\t\t(f(th,L[j])<B[j]&&f(th,R[j])<B[j]) ||\n\t\t\t\t\t(f(th,L[j])>T[j]&&f(th,R[j])>T[j]) ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ツ猟篠可コツ湘。ツ害ツ閉ィツ確ツ認\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<L.size(); j++){\n\t\t\t\t\tif(R[j]==x){\n\t\t\t\t\t\tif(y<T[j] && T[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n//#include <bits/stdc++.h>\n\n#include <cmath>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n//#define x first\n//#define y second\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst double eps = 1e-10;\ndouble add(double a, double b)\n{\n    if(fabs(a+b) < eps*(fabs(a) + fabs(b))) return 0;\n    return a+b;\n}\n\nstruct P{\n    double x, y;\n    P() {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator + (P p) { return P(add(x, p.x), add(y, p.y)); }\n    P operator - (P p) { return P(add(x, -p.x), add(y, -p.y)); }\n    P operator * (double d) { return P(x*d, y*d); }\n    double dot(P p) { return  add(x*p.x, y*p.y); }\n    double det(P p) { return  add(x*p.y, -y*p.x); }\n};\n\n//determine whether q on Seg_p1p2\nbool on_seg(P p1, P p2, P q)\n{\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\nP intersection(P p1, P p2, P q1, P q2)\n{\n    return p1+(p2-p1)*((q2-q1).det(q1-p1) / (q2-q1).det(p2-p1));\n}\n\nint n, v, x, y;\nconst int MAX_N = 55;\nconst double g = 9.8;\nint l[MAX_N], bo[MAX_N], r[MAX_N], to[MAX_N];\n\ndouble calc(double vy, double t)\n{\n    return vy*t - g*t*t/2.0;\n}\n\nint cmp(double lb, double ub, double a)\n{\n    return a<lb+eps ? -1 : (a>ub-eps ? 1 : 0);\n}\n\nbool check(double qx, double qy)\n{\n    double a = g*g/4.0, b = g*qy - v*v, c = qx*qx + qy*qy;\n    double D = b*b - 4.0*a*c;\n    if(D<0 && D>-eps) D = 0;\n    if(D < 0 ) return false;\n    for(int d=-1; d<=1; d+=2) {\n        double t2 = (-b+d*sqrt(D)) / (2.0*a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g*t*t/2.0) /  t;\n\n        double yt = calc(vy, x / vx);\n        if(yt < y-eps) continue;\n\n        bool ok = true;\n        REP(i, 0, n) {\n            if(l[i] >= x) continue;\n            if(r[i]==x && y<=to[i] && bo[i]<=yt) ok = false;\n\n            int yl = cmp(bo[i], to[i], calc(vy, l[i]/vx));\n            int yr = cmp(bo[i], to[i], calc(vy, r[i]/vx));\n            int xh = cmp(l[i], r[i], vx*(vy/g));\n            int yh = cmp(bo[i], to[i], calc(vy, vy/g));\n            if(xh==0 && yh>=0 && yl<0) ok = false;\n            if(yl*yr <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main()\n{\n#ifdef ANONYM\n    freopen(\"input\", \"r\", stdin);\n    freopen(\"output\", \"w\", stdout);\n#endif\n\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    REP(i, 0, n) {\n        scanf(\"%d%d%d%d\", &l[i], &bo[i], &r[i], &to[i]);\n        r[i] = min(r[i], x);\n    }\n    bool ok = check(x, y);\n    REP(i, 0, n) {\n        ok |= check(l[i], to[i]);\n        ok |= check(r[i], to[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        if(cmp(r.top(), y_left) * cmp(r.top(), y_right) < 0) return false;\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) && cmp(top_y, r.bottom()) > 0) return false;\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = (-b + sqrt(D)) / (2*a);\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nint lx[100];\nint ly[100];\nint rx[100];\nint ry[100];\ndouble EPS=1e-9;\nvector<pair<int,int> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(rx[i],ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-4.9*4.9*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx>b)ok=false;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vx>b)ok=false;\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\n\nconst long double EPS = 1e-9;\nconst int MAX_N = 55;\nconst long double g = 9.8;\n\n\nstruct Para\n{\n\tint t;\n\tlong double a[2];\n\tlong double b[2];\n};\n\n// a 与 b 近似为相反数时返回 0.0 , 否则返回 a + b\nlong double add(long double a, long double b);\n\nstruct P\n{\n\tlong double x;\n\tlong double y;\n\n\t//定义构造函数之前, 需要先定义一个空的构造函数\n\tP() { x = 0; y = 0; }\n\n\t//构造函数\n\tP(long double x, long double y) :x(x), y(y) {}\n\n\t//加法\n\tP operator + (P p)\n\t{\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\n\t//加法\n\tP operator - (P p)\n\t{\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\n\t//数乘\n\tP operator * (long double d)\n\t{\n\t\treturn P(x * d, y * d);\n\t}\n\n\t//点积\n\tdouble dot(P p)\n\t{\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\n\t//叉乘\n\tdouble det(P p)\n\t{\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n\nbool on_seg(P p1, P p2, P q);\nP intersection(P p1, P p2, P q1, P q2);\n\n\nP rectp[MAX_N][4];\n\nint N, V, X, Y, am;\n\nPara getpara(P p, int v);\n\nbool check(Para q);\n\nint cmp(long double lb, long double rb, long double a);\n\nint main()\n{\n\tint L, B, R, T;\n\n\tcin >> N >> V >> X >> Y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> L >> B >> R >> T;\n\n\t\tif (L >= X)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\n\t\trectp[am][0].x = L;\n\t\trectp[am][1].x = R;\n\t\trectp[am][2].x = L;\n\t\trectp[am][3].x = R;\n\n\t\trectp[am][0].y = T;\n\t\trectp[am][1].y = T;\n\t\trectp[am][2].y = B;\n\t\trectp[am][3].y = B;\n\n\t\tam++;\n\t\t\n\t}\n\n\tP t;\n\tt.x = X;\n\tt.y = Y;\n\n\tbool ans = check(getpara(t, V));\n\n\tif (!ans)\n\t{\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tans = check(getpara(rectp[i][0], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tans = check(getpara(rectp[i][1], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ans)\n\t{\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t{\n\t\tcout << \"No\\n\";\n\t}\n\n\treturn 0;\n}\n\nlong double add(long double a, long double b)\n{\n\tif (fabs(a + b) > EPS * (fabs(a) + fabs(b)))\n\t{\n\t\treturn a + b;\n\t}\n\treturn 0.0;\n}\n\nPara getpara(P p, int v)\n{\n\tPara res;\n\n\tif (p.x < EPS)\n\t{\n\t\tres.t = 0;\n\t\treturn res;\n\t}\n\n\tlong double D = (long double)v * v * ((long double)v * v - 2 * g * p.y) - g * g * p.x * p.x;\n\n\tif (D >= EPS)\n\t{\n\t\tres.t = 2;\n\n\t\tD = sqrt(D);\n\t\tres.b[0] = ((long double)v * v + D) / (g * p.x);\n\t\tres.b[1] = ((long double)v * v - D) / (g * p.x);\n\n\t\tres.a[0] = ((long double)p.y - res.b[0] * p.x) / (p.x * p.x);\n\t\tres.a[1] = ((long double)p.y - res.b[1] * p.x) / (p.x * p.x);\n\t}\n\telse\n\t{\n\t\tres.t = 0;\n\t}\n\n\treturn res;\n}\n\nbool check(Para q)\n{\n\tbool ok;\n\tP cross;\n\n\tif (q.t == 0)\n\t{\n\t\treturn false;\n\t}\n\n\tfor (int p = 0; p < q.t; p++)\n\t{\n\t\tok = true;\n\n\t\tlong double tar = q.a[p] * X * X + q.b[p] * X;\n\n\t\tif (tar < Y - EPS)\n\t\t{\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tif (rectp[i][0].x >= X)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcross.x = rectp[i][0].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X - EPS && cross.y > rectp[i][2].y + EPS && cross.y < rectp[i][0].y - EPS)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcross.x = rectp[i][1].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X - EPS && cross.y > rectp[i][3].y + EPS && cross.y < rectp[i][1].y - EPS)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlong double D = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][0].y;\n\t\t\tif (D >= EPS)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][0].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tD = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][2].y;\n\t\t\tif (D >= EPS)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][2].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectp[i][0].x <= X && rectp[i][1].x >= X && tar >= rectp[i][2].y + EPS)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok)\n\t\t{\n\t\t\treturn ok;\n\t\t}\n\t}\n\treturn false;\n}\n\nint cmp(long double lb, long double rb, long double a)\n{\n\tif (lb > rb)\n\t{\n\t\tlong double m = lb;\n\t\tlb = rb;\n\t\trb = m;\n\t}\n\tif (a < lb + EPS)\n\t{\n\t\treturn -1;\n\t}\n\telse if (a > rb - EPS)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nbool on_seg(P p1, P p2, P q)\n{\n\treturn ((p1 - q).det(p2 - q) == 0.0) && ((p1 - q).dot(p2 - q) <= 0);\n}\n\nP intersection(P p1, P p2, P q1, P q2)\n{\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=400000;i++ )\n     {\n           vy=double(i)/400000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst long double g=9.8;\nconst long double eps= 1e-8;\n\nint N; long double V,X,Y;\n\nlong double L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\nlong double Calcy(long double vy,long double t){return vy*t-0.5*g*t*t;}\nlong double Calcx(long double vx,long double t){return vx*t;}\n\nint cmp(long double lb,long double ub,long double a)\n{\n  return a<lb ? -1 : a>ub ? 1 : 0;\n}\n\nbool Check(long double x,long double y) // ????????????(x,y) \n{\n  long double a=0.25*g*g; long double b=g*y-V*V; long double c=x*x+y*y;\n  long double delta= b*b-4*a*c;\n  if(delta < 0 && delta > -eps) delta=0.0;\n  else if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    long double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    long double vx=x/t; long double vy=(y+0.5*g*t*t)/t; //?????????\n    long double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0 && yL<=0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  cin >> N >> V >> X >> Y;\n  for(int i=1;i<=N;i++) cin >> L[i] >> B[i] >> R[i] >> T[i];\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 4.9;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * (1+tanv * tanv);\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\tdouble hy = 1e9;\n\tvector<double> uxtmp;\n\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) and b.p1.y() > Y ){\n\t\t\thy = min(hy,b.p1.y());\n\t\t}\n\t}\n\tfor( auto b : box ){\n\t\tdouble x = b.p1.x();\n\t\tuxtmp.push_back(x);\n\t\tdouble y = f(x);\n\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble x = b.p2.x();\n\t\tdouble y = f(x);\n\t\tuxtmp.push_back(x);\n\t\tif( inner(b.p2.y(),y,b.p3.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble y = b.p1.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\t\tdouble y = b.p3.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\t\t\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) ){\n\t\t\tif( inner(b.p1.y(),Y,b.p4.y()) ){\n\t\t\t\thx = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << f(1) << endl;\n\t//cout << hy << endl;\n\t//cout << V << \" \" << tanv << \" \" << a << \" \" << b << \" \" << X << \" \" << f(X)  << endl;\n\tif( hx - EPS > X ){\n\t\t//cout << f(X) << \" \" << Y - EPS << endl;\n\t\tif( f(X) > Y - EPS and f(X) < hy - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t//cout << atan(tanv) << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\tps.push_back(a);\n\t\tps.push_back(b);\n\t\tps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < 3000 ; i++){\n\t\ttrying(0.001*i);\n\t}\n\tif(true){\n\t\tdouble x = X;\n\t\tdouble y = Y;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\t\t//cout << a << \" \" << b << \" \" << c << \" ( \" << g << \" \" << V << \" \" << x << endl;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\t\n\t\t}else{\n\t\t\tD = max(0.0,D);\n\t\t\tD = sqrt(D);\n\t\t\tdouble t1 = (-b+D)/(2*a);\n\t\t\tdouble t2 = (-b-D)/(2*a);\n\t\t\ttrying(t1);\n\t\t\ttrying(t2);\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double eps = 1e-10;\nconst int MAX_N = 50;\nconst double g = 9.8;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble position(double vy, double t) {\n\treturn vy*t-g*t*t/2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n\treturn a < lb + eps?-1:a>ub-eps?1:0;\n}\n\n// 射出路径经过(qx,qy)时，能否击中猪\nbool check(double qx, double qy) {\n\tdouble a = g*g/4.0, b=g*qy-V*V, c=qx*qx+qy*qy;\n\tdouble D = b*b-4*a*c;\n\tif (D < 0 && D > -eps) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2) { // 验证解的循环\n\t\tdouble t2 = (-b + d*sqrt(D))/(2*a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx/t, vy=(qy+g*t*t/2.0)/t;\n\t\t// 是否通过猪的正上方？\n\t\tdouble yt = position(vy, X/vx);\n\t\tif (yt < Y-eps) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (L[i] >= X) continue;\n\t\t\tif (R[i] == X &&  Y <= T[i] && B[i] <= yt) ok = false;\n\t\t\tint yL = cmp(B[i], T[i], position(vy, L[i]/vx)); // 左侧相对位置\n\t\t\tint yR = cmp(B[i], T[i], position(vy, R[i]/vx)); // 右侧相对位置\n\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g)); // 最高点相对位置\n\t\t\tint yH = cmp(B[i], T[i], position(vy, vy/g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0) ok = false;\n\t\t\tif (yL * yR <= 0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tok |= check(L[i], T[i]);\n\t\tok |= check(R[i], T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(1){\n\t\t\tallTH.clear();\n\t\t\tint N = 10000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tallTH.push_back(89.999999/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<=x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double g = 9.8;\t//??????????????? \nconst int MAX_N = 55; \n\n//?????\\ \nint N;\ndouble V, X, Y;\ndouble L[MAX_N], R[MAX_N], B[MAX_N], T[MAX_N];\n\n//????????\\vy??????????????´???????°????t?§????????????? \ndouble calc(double vy, double t){\n\treturn vy * t - g * t * t / 2;\n}\n\n//a??????lb???ub????????? \nint cmp(double lb, double ub, double a){\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n \n//??????????°???????????????????(qx, qy)??¶,????????????????????? \nbool check(double qx, double qy){\n \t/*  ??????????????¨x?????????y????????????????????????vx???vy,?????????(qx, qy)?????¶??´???t \n \t\t?±??§£??????????¨????vx^2 + vy^2 = V^2, vy * t = qx, vy * t - 1/2 g t^2 = qy\n \t\t\n\t\tVx^2 + Vy^2 = V^2;\n\t\tVx*t = Qx;\n\t\tVy*t - 1/2*g*t^2 = Qy;\n\t\t\n\t\t???x = t^2\n\t\t1/4*g^2*x^2 + (g*Qy - V^2)*x + Qx^2 + Qy^2 = 0;\n\t\ta = 1/4*g^2   b = g*Qy - V^2   c = Qx^2 + Qy^2\n\t\t\n\t*/\n \tdouble a = g * g / 4,  b = g * qy - V * V, c = qx * qx + qy * qy;\n \tdouble D = b * b - 4 * a * c;\n \tif(D < 0 && D > -EPS) D = 0;\t\t\t\t\t\t\t\t\t\n \tif(D < 0) return false;\t\t\t\t\t\t\t\t\t\t\t//????§£ \n \tfor(int d = -1; d <= 1; d += 2){\t\t\t\t\t\t\t\t//????????????????¨??????????????§£????????? \n \t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\t\t\t\t\t\n \t\tif(t2 <= 0) continue;\n \t\tdouble t = sqrt(t2);\n \t\tdouble vx = qx / t, vy = (qy + g * t * t / 2) / t;\n \t\t\n \t\t//??????????????????????????£?????? \n \t\tdouble yt = calc(vy, X / vx);\n \t\tif(yt < Y - EPS) continue;\t\n \t\t\n \t\tbool ok = true;\n \t\tfor(int i = 0; i < N; i++){\n \t\t\tif(L[i] >= X) continue;\n \t\t\t//???????????£???????????????????????´?????????????¢???? \n \t\t\tif(R[i] == X && Y <= T[i] && B[i] <= yt) ok = false; \n \t\t\t//????????¨?£???°?????£??????????????????????????°????¢???? \n \t\t\tint yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\t\t\t//?????§??????????????? \n \t\t\tint yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\t\t\t//?????§??????????????? \n \t\t\tint xH = cmp(L[i], T[i], vx * (vy / g));\t\t\t\t//???????????????????????? \n \t\t\tint yH = cmp(B[i], T[i], calc(vy, vy / g));\n \t\t\tif(xH == 0 && yH >= 0 && yL < 0) ok = false;\t\t\t//?????????????????´??¨L[i]???R[i]?????´\n \t\t\tif(yL * yR <= 0) ok = false;\t\t\t\t\t\t\t//?????????????????´??¨L[i]?????§???R[i]?????§ \n\t\t }\n\t\t if(ok) return true;\n\t}\n \treturn false;\n}\n \nvoid solve(){\n\t//???????????\\??????????¢???? \n \tfor(int i = 0; i < N; i++){\n \t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\t\t\t//??´??\\?????????????????? \n\tfor(int i = 0; i < N; i++){\n\t \tok |= check(L[i], T[i]);\t//?????????????§?????????? \n\t \tok |= check(R[i], T[i]);\t//?????????????§?????????? \n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\n \nint main(){\n \twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n \t\tfor(int i = 0; i < N; i++)\n \t\t\tscanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\t\n\t\tsolve();\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\n\nconst double EPS = 1e-10;\nconst int MAX_N = 55;\nconst double g = 9.8;\n\n\nstruct Para\n{\n\tint t;\n\tdouble a[2];\n\tdouble b[2];\n};\n\n// a 与 b 近似为相反数时返回 0.0 , 否则返回 a + b\ndouble add(double a, double b);\n\nstruct P\n{\n\tdouble x;\n\tdouble y;\n\n\t//定义构造函数之前, 需要先定义一个空的构造函数\n\tP() { x = 0; y = 0; }\n\n\t//构造函数\n\tP(double x, double y) :x(x), y(y) {}\n\n\t//加法\n\tP operator + (P p)\n\t{\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\n\t//加法\n\tP operator - (P p)\n\t{\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\n\t//数乘\n\tP operator * (double d)\n\t{\n\t\treturn P(x * d, y * d);\n\t}\n\n\t//点积\n\tdouble dot(P p)\n\t{\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\n\t//叉乘\n\tdouble det(P p)\n\t{\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n\nbool on_seg(P p1, P p2, P q);\nP intersection(P p1, P p2, P q1, P q2);\n\n\nP rectp[MAX_N][4];\n\nint N, V, X, Y, am;\n\nPara getpara(P p, int v);\n\nbool check(Para q);\n\nint cmp(double lb, double rb, double a);\n\nint main()\n{\n\tint L, B, R, T;\n\n\tcin >> N >> V >> X >> Y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> L >> B >> R >> T;\n\n\t\tif (L <= X)\n\t\t{\n\t\t\trectp[am][0].x = L;\n\t\t\trectp[am][1].x = R;\n\t\t\trectp[am][2].x = L;\n\t\t\trectp[am][3].x = R;\n\n\t\t\trectp[am][0].y = T;\n\t\t\trectp[am][1].y = T;\n\t\t\trectp[am][2].y = B;\n\t\t\trectp[am][3].y = B;\n\n\t\t\tam++;\n\t\t}\n\t}\n\n\tP t;\n\tt.x = X;\n\tt.y = Y;\n\n\tbool ans = check(getpara(t, V));\n\n\tif (!ans)\n\t{\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tans = check(getpara(rectp[i][0], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tans = check(getpara(rectp[i][1], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ans)\n\t{\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t{\n\t\tcout << \"No\\n\";\n\t}\n\n\treturn 0;\n}\n\ndouble add(double a, double b)\n{\n\tif (fabs(a + b) > EPS * (fabs(a) + fabs(b)))\n\t{\n\t\treturn a + b;\n\t}\n\treturn 0.0;\n}\n\nPara getpara(P p, int v)\n{\n\tPara res;\n\n\tdouble D = (double)v * v * ((double)v * v - 2 * g * p.y) - g * g * p.x * p.x;\n\n\tif (D >= EPS)\n\t{\n\t\tres.t = 2;\n\n\t\tD = sqrt(D);\n\t\tres.b[0] = ((double)v * v + D) / (g * p.x);\n\t\tres.b[1] = ((double)v * v - D) / (g * p.x);\n\n\t\tres.a[0] = ((double)p.y - res.b[0] * p.x) / (p.x * p.x);\n\t\tres.a[1] = ((double)p.y - res.b[1] * p.x) / (p.x * p.x);\n\t}\n\telse\n\t{\n\t\tres.t = 0;\n\t}\n\n\treturn res;\n}\n\nbool check(Para q)\n{\n\tbool ok;\n\tP cross;\n\n\tfor (int p = 0; p < q.t; p++)\n\t{\n\t\tok = true;\n\n\t\tdouble tar = q.a[p] * X * X + q.b[p] * X;\n\n\t\tif (tar < Y - EPS)\n\t\t{\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tcross.x = rectp[i][0].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X - EPS && cmp(rectp[i][2].y, rectp[i][0].y, cross.y) == 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcross.x = rectp[i][1].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X - EPS && cmp(rectp[i][3].y, rectp[i][1].y, cross.y) == 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdouble D = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][0].y;\n\t\t\tif (D >= EPS)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][0].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tD = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][2].y;\n\t\t\tif (D >= EPS)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][2].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X - EPS && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectp[i][0].x <= X && rectp[i][1].x >= X && tar >= rectp[i][2].y + EPS)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok)\n\t\t{\n\t\t\treturn ok;\n\t\t}\n\t}\n\treturn false;\n}\n\nint cmp(double lb, double rb, double a)\n{\n\tif (a < lb + EPS)\n\t{\n\t\treturn -1;\n\t}\n\telse if (a > rb - EPS)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nbool on_seg(P p1, P p2, P q)\n{\n\treturn ((p1 - q).det(p2 - q) == 0.0) && ((p1 - q).dot(p2 - q) <= 0);\n}\n\nP intersection(P p1, P p2, P q1, P q2)\n{\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\n\nint N;\ndouble V,X,Y;\ndouble Max,Min;\ndouble OB;\nvector<double> L,B,R,T;\n\npair<double,double> calc(double X,double Y){\n\tdouble a=1.0/2.0*g*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*g*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || a-eps<0)\n\t\treturn make_pair(-1.0,-1.0);\n\tdouble ans1=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n\tdouble ans2=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n\treturn make_pair(ans1,ans2);\n}\n\nvoid solve()\n{\n\tvector<double> VT;\n\tOB=301.0;\n\tL.resize(N);B.resize(N);R.resize(N);T.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=B[i];\n\t}\n\tpair<double,double>p1=calc(X,Y);\n\tif(p1.first<0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tMax=p1.second;\n\tMin=p1.first;\n\tVT.push_back(Min);\n\tfor(int i=0;i<N;i++){\n\t\tpair<double,double>tp=calc(L[i],T[i]);\n\t\tif(tp.first>0 && tp.first<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.first);\n\t\ttp=calc(R[i],T[i]);\n\t\tif(tp.second>0 && tp.second<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.second);\n\t}\n\tfor(int i=0;i<VT.size();i++){\n\t\tbool ok=true;\n\t\tdouble center=VT[i]*V*V/g/(1.0+VT[i]*VT[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*VT[i]-1.0/2.0*g*L[j]*L[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tMy=R[j]*VT[i]-1.0/2.0*g*R[j]*R[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center<R[j]-eps)\n\t\t\t\tMy=center*VT[i]-1.0/2.0*g*center*center/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>B[j] || My<T[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tif(X*VT[i]-1.0/2.0*X*X/V/V*(1.0+VT[i]*VT[i])+eps<OB){\n\t\t\t\tcout<<\"Yes\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tok=false;\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst double g = 9.8;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size()-1; i++){\n\t\t\tdouble ta = (allTAN[i] + allTAN[i+1])/2;\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÖWÌ³¢ubN\n\t\t\t\tif(allL[j]>x) continue;\n\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allL[j]<x && x<allR[j]){\n\t\t\t\t\t\t\tif(y<allB[j] && allT[j]<thoy){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-7;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  //cout << vx <<endl;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n   // cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    //R[i] = min(R[i],X);\n  }\n  int flag = 1;\n  /*REP(i,N){\n    if((L[i]<X)&&(X<R[i])&&(B[i]>Y)) {\n      flag = -1;\n    }\n  }*/\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t/*\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(1){\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(i==0) continue;\n\t\t\t\tallTH.push_back(90.0/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 9.8/2;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * (1+tanv * tanv);\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tD = sqrt(D);\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\tdouble hy = 1e9;\n\tvector<double> uxtmp;\n\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) and b.p1.y() > Y ){\n\t\t\thy = min(hy,b.p1.y());\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tuxtmp.push_back(b.p1.x());\n\t\tuxtmp.push_back(b.p2.x());\n\t}\n\t\n\tfor( auto b : box ){\n\t\tfor( double x : g(b.p1.y()) ){\n\t\t\tuxtmp.push_back(x);\n\t\t}\n\t\tfor( double x : g(b.p3.y()) ){\n\t\t\tuxtmp.push_back(x);\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\n\t}\n\tuxtmp.push_back(0);\n\tuxtmp.push_back(X);\n\t\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\t\t\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) ){\n\t\t\tif( inner(b.p1.y(),Y,b.p4.y()) ){\n\t\t\t\thx = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif( hx + EPS > X ){\n\t\tif( f(X) > Y - EPS and f(X) < hy - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\tps.push_back(a);\n\t\tps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(b);\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < 3000 ; i++){\n\t\ttrying(0.001*i);\n\t}\n\tps.push_back({X,Y});\n\t\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\t\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X <= bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, vx* vy / g);\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 55;\nconst double g = 9.8;   //???????????????\nconst double EPS = 1e-10;\nint N;\ndouble V, X, Y;\ndouble L[maxn], B[maxn], R[maxn], T[maxn];\n\n//????????\\vy??????????????´???????°????t?§?????????????\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a??????lb???ub?????????\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//??????????°???????????????????(qx, qy)??¶????????????????????????\nbool check(double qx, double qy)\n{\n    //??????????????¨x?????????y????????????????????????vx???vy????????????(qx, qy)?????¶??´???t\n    //????§£??????????¨????vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //????????????????¨?????????????????§£?????????\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //??????????????????????????£??????\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //????????¨?????£???????????????????????´?????????????¢????\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //????????¨?£???°????????£??????????????????????????°????¢????\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //?????§???????????????\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //?????§???????????????\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //????????????????????????\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    //???????????\\??????????¢????\n    for (int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);      //??´??\\??????????????????\n    for (int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);     //?????????????§??????????\n        ok |= check(R[i], T[i]);     //?????????????§??????????\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\nint main(){\n \twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n \t\tfor(int i = 0; i < N; i++)\n \t\t\tscanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\t\n\t\tsolve();\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\nbool ok[50]={};\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nbool comp(double lb,double ub,double x){\n\tif(x<lb+eps) return -1;\n\tif(ub<x+eps) return 1;\n\treturn 0;\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<l[i]||r[i]<x) continue;\n\t\t\tif(y<=u[i]&&d[i]<=ry) ok=false;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble ly=comp(d[i],u[i],calcy(vy,l[i]/vx));\n\t\t\tdouble ry=comp(d[i],u[i],calcy(vy,r[i]/vx));\n\t\t\tdouble hx=comp(l[i],r[i],vy/g*vx);\n\t\t\tdouble hy=comp(l[i],r[i],calcy(vy,vy/g));\n\t\t\tif(hx==0&&hy>=0&&ly<0) ok=false;\n\t\t\tif(ly*ry<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Rect {\n  double x1, y1, x2, y2;\n  Rect() {;}\n  Rect(double x1, double y1, double x2, double y2) :\n    x1(x1), y1(y1), x2(x2), y2(y2) {;}\n};\n\nconst double G = 9.8;\nint n;\nRect rect[400];\ndouble v, ex, ey;\n\n// y = -G / 2 * t^2 + v * sinA * t\n// x = v * cosA * t\n// t = X / (v * cosA)\n\ndouble Y(double theta, double x) {\n  double t = x / (v * cos(theta));\n  //cout << t << \" \" << -G * t * t + v * sin(theta) * t << endl;\n  return -G / 2.0 * t * t + v * sin(theta) * t;\n}\n\nbool calc(double theta) {\n  //cout << theta << endl;\n  //cout << Y(theta, ex) << endl;\n  //cout << \"test2\" << endl;\n  if (Y(theta, ex) - ey < -EPS) { return false; }\n  double mx, my;\n  {\n    double left = 0.0;\n    double right = 500;\n    REP(iter, 100) {\n      double midl = (left * 2.0 + right) / 3.0;\n      double midr = (left + right * 2.0) / 3.0;\n      double yl = Y(theta, midl);\n      double yr = Y(theta, midr);\n      if (yl > yr) {\n        right = midr;\n      } else {\n        left = midl;\n      }\n    }\n    mx = left;\n    my = Y(theta, mx);\n  }\n  REP(i, n) {\n    double ly = Y(theta, rect[i].x1);\n    double ry = Y(theta, rect[i].x2);\n    if (ly >= rect[i].y2 && ry >= rect[i].y2) { continue; }\n    if ((-EPS >= rect[i].y1 -ly && EPS <= rect[i].y2 - ry) ||\n        (EPS <= rect[i].y2 - ly && -EPS >= rect[i].y1 - ry) ||\n        (rect[i].y1 - ly < -EPS && EPS < rect[i].y2 - ly) ||\n        (rect[i].y1 - ry < -EPS && EPS < rect[i].y2 - ry)) { return false; }\n    if (ly < rect[i].y2 && ry < rect[i].y2 && rect[i].x1 <= mx && mx <= rect[i].x2 && rect[i].y1 - mx <= -EPS) { return false; }\n  }\n  return true;\n}\n\ndouble CalcTheta(double left, double right, double tx, double ty, int dir) {\n  REP(iter, 100) {\n    double mid = (left + right) / 2.0;\n    if (Y(mid, tx) < ty) {\n      if (dir == 1) {\n        right = mid;\n      } else {\n        left = mid;\n      }\n    } else {\n      if (dir == 1) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n  }\n  return left;\n}\n\nbool OK(double tx, double ty) {\n  double left = 0;\n  double right = PI / 2 - EPS;\n  //cout << Y(0.684, 3) << endl;\n  //cout << Y(0.694, 3) << endl;\n  //cout << Y(0.704, 3) << endl;\n  //return false;\n  REP(iter, 200) {\n    double midl = (left * 2.0 + right) / 3.0;\n    double midr = (left + right * 2.0) / 3.0;\n    double yl = Y(midl, tx);\n    double yr = Y(midr, tx);\n    if (yl > yr) {\n      right = midr;\n    } else {\n      left = midl;\n    }\n  }\n  if (Y(left, tx) - ty < -EPS) { return false; }\n  bool ret = false;\n  ret |= calc(CalcTheta(0, left, tx, ty, -1));\n  ret |= calc(CalcTheta(left, PI / 2 - EPS, tx, ty, 1));\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %lf %lf %lf\", &n, &v, &ex, &ey) > 0) {\n    REP(i, n) {\n      double x1, x2, y1, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      if (x1 <= ex && ex <= x2) {\n        y2 = 1e+10;\n      }\n      if (ex < x1) {\n        x1 = 1e+20;\n        x2 = 2e+20;\n        y1 = 1e+20;\n        y2 = 2e+20;\n      }\n      rect[i] = Rect(x1, y1, x2, y2);\n    }\n    bool ok = false;\n    ok |= OK(ex, ey);\n    REP(i, n) {\n      if (ok) { break; }\n      ok |= OK(rect[i].x1, rect[i].y2);\n      ok |= OK(rect[i].x2, rect[i].y2);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Yzcstc\n * Created Time:  2014/9/29 10:12:41\n * File Name: aoj2308.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define M0(x)  memset(x, 0, sizeof(x))\n#define Inf  0x7fffffff\n#define MP make_pair\n#define PB push_back\n#define eps 1e-12\n#define g 9.8\n#define N 100000\n#define pi acos(-1.0)\ntypedef long long LL;\nusing namespace std;\ninline int sgn(const double &x){\n    return (x > eps) - (x < -eps);\n}\nstruct point{\n    double x, y;\n    point(){}\n    point(double _x, double _y):x(_x), y(_y){}\n    void input(){\n         scanf(\"%lf%lf\", &x, &y);\n    }\n    point operator-(const point& p) const{\n          return point(x - p.x, y - p.y);      \n    }\n    double operator*(const point &p) const{\n          return x * p.y - y * p.x;\n    }\n    double operator^(const point &p) const{\n          return x * p.x + y * p.y;\n    }\n} p[550][2];\nint n;\ndouble v, x, y, vx, vy, top, topy;\nbool insegment(const point& p, const point& p1, const point &p2){\n     return sgn((p1 - p) * (p2 - p)) == 0 && sgn((p1 - p) ^ (p2 - p)) < 0;\n}\n\nvoid init(){\n     for (int i = 0; i < n; ++i)\n         p[i][0].input(), p[i][1].input();\n}\n\nint gao(int i){\n     point p2 = point(p[i][0].x, p[i][1].y);\n     point p4 = point(p[i][1].x, p[i][0].y);\n     double x1, y1, x2, t;\n     if (sgn(p2.x - x) < 0){\n            double t = p2.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) < 0 && sgn(y1 - p4.y) > 0) return 0;\n     }\n     if (sgn(p4.x - x) < 0){\n            double t = p4.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) < 0 && sgn(y1 - p4.y) > 0) return 0;\n     }\n     double d;\n     if (sgn(p2.y - top) <= 0){\n           d = vy * vy - 2 * g * p2.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) > 0 && sgn(x1 - x) < 0){\n                  if (sgn(x1 - p2.x) > 0 && sgn(x1 - p4.x) < 0) return 0;\n           }\n           if (sgn(x2) > 0 && sgn(x2 - x) < 0){\n                  if (sgn(x2 - p2.x) > 0 && sgn(x2 - p4.x) < 0) return 0;\n           }\n     }\n     if (sgn(p4.y - top) <= 0){\n           d = vy * vy - 2 * g * p4.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) > 0 && sgn(x1 - x) < 0){\n                  if (sgn(x1 - p2.x) > 0 && sgn(x1 - p4.x) < 0) return 0;\n           }\n           if (sgn(x2) > 0 && sgn(x2 - x) < 0){\n                  if (sgn(x2 - p2.x) > 0 && sgn(x2 - p4.x) < 0) return 0;\n           }\n     }\n     return 1;\n}\n\nint check(double ang){\n     vx = v * cos(ang), vy = v * sin(ang);\n     double t = x / vx;\n     double hy = vy * t - .5 * g * t * t;\n     top = vy * vy / 2 / g;\n     if (sgn(hy - y) < 0 || sgn(hy - topy) > 0) return 0;\n     for (int i = 0; i < n; ++i){\n             if (!gao(i)) return 0;\n     } \n     return 1;\n}\n\nint solve(){\n     double EPS = 1e-6;\n     double ang = 0;\n     topy = 1e50;\n     for (int i = 0; i < n; ++i) if (sgn(p[i][0].x - x) <= 0 && sgn(p[i][1].x - x) >= 0) {\n              if (sgn(p[i][0].y - y) > 0)\n                      topy = min(topy, p[i][0].y);                  \n              if (sgn(p[i][1].y - y) > 0)\n                      topy = min(topy, p[i][1].y); \n     }\n     for (int i = 0;; ++i){\n           if (check(ang)) return 1;\n           ang += EPS;\n           if (ang > pi/2) break;\n     }\n     return 0;\n}\n\nint main(){\n//    freopen(\"a.in\", \"r\", stdin);\n//    freopen(\"a.out\", \"w\", stdout);\n    while (scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y) != EOF){\n            init();\n            solve() ? puts(\"Yes\") : puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    R[i] = min(R[i],X)\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(B[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nint comp(double lb,double ub,double x){\n\tif(x<lb+eps) return -1;\n\tif(ub<x+eps) return 1;\n\treturn 0;\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<=l[i]) continue;\n\t\t\tif(r[i]>=x&&y<=u[i]&&d[i]<=ry) ok=false;\n\t\t\tint ly=comp(d[i],u[i],calcy(vy,l[i]/vx));\n\t\t\tint ry=comp(d[i],u[i],calcy(vy,r[i]/vx));\n\t\t\tint hx=comp(l[i],r[i],vy/g*vx);\n\t\t\tint hy=comp(d[i],u[i],calcy(vy,vy/g));\n\t\t\tif(hx==0&&hy>=0&&ly<0) ok=false;\n\t\t\tif(ly*ry<=0) ok=false;\n\t\t}\n\t\t// if(ok){\n\t\t// \tshow(qx);\n\t\t// \tshow(qy);\n\t\t// \tshow(vx);\n\t\t// \tshow(vy);\n\t\t// }\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nint lx[100];\nint ly[100];\nint rx[100];\nint ry[100];\ndouble EPS=1e-9;\nvector<pair<int,int> > v;\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(rx[i],ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-4.0*4.9*4.9*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))/2/4.9/4.9;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))/2/4.9/4.9;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\nusing namespace std;\nconst double PI = acos(-1);\nconst double G = 9.8;\nstruct Node {\n    double lx, ly, rx, ry;\n};\nNode a[55];\ndouble f(double A,double B,double x,double y)\n{\n    return y - A * x * x - B * x;\n}\ndouble X, Y;\ndouble v;\nint n;\nint judge(double x)\n{\n    double B = tan(x);\n    double v1 = v * sin(x);\n    double v2 = v * cos(x);\n    double t = 2.0 * v1 / G;\n    double xx = v2 * t;\n    double A = (- B / xx);\n\n    for(int i = 1; i <= n; i++)\n    {\n        if(a[i].lx > X) continue;\n        if(f(A,B,a[i].lx,a[i].ly) * f(A,B,a[i].lx,a[i].ry) <= 0)return 0;\n        if(f(A,B,a[i].rx,a[i].ry) * f(A,B,a[i].lx,a[i].ry) <= 0 && a[i].ry > Y)return 0;\n        double del = B * B - 4 * A * (-a[i].ly);\n        if(del < 0) continue;\n        double x1 = (-B + sqrt(del)) / A / 2;\n        double x2 = (-B - sqrt(del)) / A / 2;\n        if(x1 >= a[i].lx && x1 <= a[i].rx) return 0;\n        if(x2 >= a[i].lx && x2 <= a[i].rx) return 0;\n      //  printf(\"%f %f\\n\", x1, x2);\n    }\n    for(int i = 1; i <= n; i++) {\n        if(a[i].lx <= X && a[i].rx >= X) {\n            double yx = A * X * X + B * X;\n            if(a[i].ly >= Y && a[i].ly <= yx) return 0;\n            if(a[i].ry >= Y && a[i].ry <= yx) return 0;\n        }\n\n    }\n    if(A * X * X + B * X < Y) return 0;\n//    printf(\"%f\\n\", x);\n//    printf(\"%f\\n\", A + B);\n//    printf(\"%f\\n\", A * 4 + 2 * B);\\\n//    printf(\"%f %f %f\\n\", v, v1, v2);\n//    printf(\"%f\\n\", xx);\n    return 1;\n}\nint main()\n{\n\n    //freopen(\"in.txt\", \"r\", stdin);\n    double x,y;\n    while(scanf(\"%d %lf %lf %lf\",&n,&v,&x,&y) != EOF)\n    {\n        X = x; Y = y;\n        for(int i = 1; i <= n; i++)\n        {\n            scanf(\"%lf %lf %lf %lf\",&a[i].lx,&a[i].ly,&a[i].rx,&a[i].ry);\n            if(a[i].lx <= X && a[i].rx >= X) a[i].rx = X;\n        }\n        if(abs(X) < 1e-8) {\n            double h = v * v / G / 2;\n            if(h < Y) {\n                printf(\"No\\n\");\n                continue;\n            }\n            int flag = 1;\n            for(int i = 1; i <= n; i++) {\n                if(abs(a[i].lx) < 1e-8) {\n                    if(a[i].ly <= Y) flag = 0;\n                    if(a[i].ry <= Y) flag = 0;\n                }\n            }\n            printf(\"%s\\n\", flag ? \"Yes\" : \"No\");\n            continue;\n        }\n        double m = PI / 2;\n        int flag = 0;\n        for(double i = m / 1000000; i < m; i += m / 1000000)\n        {\n            if(judge(i)){flag = 1; break;}\n        }\n        if(flag)printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-8;\nconst double g=9.8;\nconst int maxn=1000;\n\n#define Equ(a,b) ((fabs((a)-(b)))<(eps))\n#define Less(a,b) (((a)-(b))<(-(eps)))\n#define LessEqu(a,b) (((a)-(b))<(eps))\n#define More(a,b) (((a)-(b))>(eps))\n#define MoreEqu(a,b) (((a)-(b))>(-(eps)))\n\nint main()\n{\n    //freopen(\"12381.txt\",\"r\",stdin);\n\n    int n;\n    double v,X,Y,x,y,t,vx,vy,t1,t2,x1,x2;\n    double L[60],B[60],R[60],T[60];\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        }\n        if(Equ(v,0.0))\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n\n        bool flag=0;\n\n        for(int k=1;k<maxn;k++)\n        {\n            vx=v*k/maxn;\n            vy=sqrt(v*v-vx*vx);\n            t=X/vx;\n            y=vy*t-0.5*g*t*t;\n            if(Less(y,Y)) continue;\n\n            for(int i=0;i<n;i++)\n            {\n\n                if(MoreEqu(X,L[i]))\n                {\n                    t=L[i]/vx;\n                    y=vy*t-0.5*g*t*t;\n                    if(MoreEqu(y,B[i])&&LessEqu(y,T[i]))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*B[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*B[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*B[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*T[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*T[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*T[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                flag=1;\n            }\n\n            if(n==0) flag=1;\n\n            if(flag==1) break;\n        }\n\n        if(flag==1) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef complex<double> Point;\nconst double G = 9.8, EPS = 1.0e-11;\nint N;\ndouble V;\nPoint aim;\nvector<Point> L, R;\n\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1: a > ub - EPS ? 1: 0;\n}\nbool check(Point q) {\n    double qx = q.real(), qy = q.imag();\n    double a = G * G / 4, b = G * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0.0 && D > -EPS) D = 0.0;\n    if(D < 0.0) return false;\n    for(int d = -1; d <= 1; d += 2) {\n        double t2 = (-b + d * sqrt(D)) / (2.0 * a);\n        if(t2 <= 0.0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2.0) / t;\n\n        double yt = calc(vy, aim.real() / vx);\n        if(yt < aim.imag() - EPS) continue;\n\n        bool ok = true;\n        rep(i, N) {\n            if(L[i].real() >= aim.real()) continue;\n            if(R[i].real() == aim.real() && aim.imag() <= R[i].imag() && L[i].imag() <= yt) ok = false;\n            int yL = cmp(L[i].imag(), R[i].imag(), calc(vy, L[i].real() / vx));\n            int yR = cmp(L[i].imag(), R[i].imag(), calc(vy, R[i].real() / vx));\n            int xH = cmp(L[i].real(), R[i].real(), vx * (vy / G));\n            int yH = cmp(L[i].imag(), R[i].imag(), calc(vy, vy / G));\n            if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if(yL * yR <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> V >> aim.real() >> aim.imag();\n    L.resize(N); R.resize(N);\n    double a, b, c, d;\n    rep(i, N) {\n        cin >> a >> b >> c >> d;\n        L[i] = Point(a, b);\n        R[i] = Point(min(c, aim.real()), d);\n    }\n    bool ok = check(aim);\n    rep(i, N) {\n        ok |= check(L[i]);\n        ok |= check(R[i]);\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\ndouble calc(double vy, double t){\n    return vy * t - 0.5 * g * t * t;\n}\nconst int N = 60;\nint n;\ndouble v,x,y, fy;\ndouble L[N],B[N],R[N],T[N];\n\nbool cmp(int i, double vx, double vy) {\n    if (L[i] > x || L[i] > R[i]) return true;\n   // if (R[i] > x && fy >= T[i] && y <= T[i]) return false;\n    double yl = calc(vy, L[i] / vx), yr = calc(vy, R[i] / vx);\n    if (yl > T[i] && yr > T[i]) return true;\n    if (yl < B[i] && yr < B[i]) {\n        double tx = vx * vy / g;\n        if (tx > R[i] || tx < L[i]) return true;\n        return calc(vy, vy / g) < B[i];\n    }\n    return false;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\nbool check(double qx, double qy) {\n    double A = g * g, b = 4 * qy * g - 4 * v * v, C = 4 * (qx *qx + qy * qy);\n    double delta = b * b - 4 * A * C;\n    if (delta < 0) return false;\n    for (int co = -1; co <= 1; co+=2) {\n        double t2 = (-b+co * sqrt(delta)) / (2 * A);\n        if (t2 < 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = sqrt(v*v - vx * vx);\n        fy = calc(vy, x / vx);\n        if (fy + eps < y) continue;\n        bool ok = true;\n        for (int i = 0; i < n;i++) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y <= T[i] && B[i] <= fy) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\n\nint main() {\n    scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf%lf%lf%lf\", L + i, B + i, R + i, T + i);\n        R[i] = min(x,R[i]);\n    }\n    bool ok = false;\n    ok |= check(x,y);\n    for (int i = 0; i < n && !ok; i++) {\n        ok |= check(L[i],B[i]);\n        ok |= check(L[i],T[i]);\n        ok |= check(R[i],B[i]);\n        ok |= check(R[i],T[i]);\n    }\n    if (ok) {\n        puts(\"Yes\");\n    }\n    else {\n        puts(\"No\");\n    }\n    \n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * tanv * tanv;\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\t\n\tvector<double> uxtmp;\n\tfor( auto b : box ){\n\t\tdouble x = b.p1.x();\n\t\tuxtmp.push_back(x);\n\t\tdouble y = f(x);\n\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble x = b.p2.x();\n\t\tdouble y = f(x);\n\t\tuxtmp.push_back(x);\n\t\tif( inner(b.p2.y(),y,b.p3.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble y = b.p1.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\t\tdouble y = b.p3.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif( hx - EPS > X ){\n\t\t//cout << f(X) << \" \" << Y - EPS << endl;\n\t\tif( f(X) > Y - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\tif(true){\n\t\tdouble x = X;\n\t\tdouble y = Y;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D > -EPS ){\n\t\t\tD = max(0.0,D);\n\t\t}\n\t\tD = sqrt(D);\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\tps.push_back(a);\n\t\tps.push_back(b);\n\t\tps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define rep( i, a ) for( int i = 0; i != (a); ++i )\n\nconst double g = 9.8, EPS = 1e-10;\n\nint N, V, X, Y;\nint L[50], B[50], R[50], T[50];\n\ndouble calc( double vy, double t )\n{\n\treturn vy * t - g * t * t / 2;\n}\n\nint cmp( double lb, double ub, double a )\n{\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\nbool check( double qx, double qy )\n{\n\tdouble a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n\tdouble D = b * b - 4 * a * c;\n\tif( D < 0 && D > -EPS )\n\t\tD = 0;\n\tif( D < 0 )\n\t\treturn false;\n\n\tfor( int d = -1; d != 1; d += 2 )\n\t{\n\t\tdouble t2 = ( -b + d * sqrt( D ) ) / ( 2 * a );\n\t\tif( t2 <= 0 )\n\t\t\tcontinue;\n\t\tdouble t = sqrt( t2 );\n\t\tdouble vx = qx / t, vy = ( qy + g * t * t / 2 ) / t;\n\n\t\tdouble yt = calc( vy, X / vx );\n\t\tif( yt < Y - EPS )\n\t\t\tcontinue;\n\n\t\tbool fl = true;\n\t\trep( i, N )\n\t\t{\n\t\t\tif( L[i] >= X )\n\t\t\t\tcontinue;\n\t\t\tif( R[i] == X && Y <= T[i] && B[i] <= yt )\n\t\t\t\tfl = false;\n\t\t\tint yL = cmp( B[i], T[i], calc( vy, L[i] / vx ) );\n\t\t\tint yR = cmp( B[i], T[i], calc( vy, R[i] / vx ) );\n\t\t\tint xH = cmp( L[i], R[i], vx * ( vy / g ) );\n\t\t\tint yH = cmp( B[i], T[i], calc( vy, vy / g ) );\n\t\t\tif( xH == 0 && yH >= 0 && yL < 0 )\n\t\t\t\tfl = false;\n\t\t\tif( yL * yR <= 0 )\n\t\t\t\tfl = false;\n\t\t}\n\n\t\tif( fl )\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tscanf( \"%d %d %d %d\", &N, &V, &X, &Y );\n\trep( i, N )\n\t{\n\t\tscanf( \"%d %d %d %d\", L + i, B + i, R + i, T + i );\n\t\tR[i] = std::min( R[i], X );\n\t}\n\n\tbool fl = check( X, Y );\n\trep( i, N )\n\t{\n\t\tfl |= check( L[i], T[i] );\n\t\tfl |= check( R[i], T[i] );\n\t}\n\n\tputs( fl ? \"Yes\" : \"No\" );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double g = 9.8, EPS = 1e-10;\nint N, V, X, Y;\nconst int maxn = 55;\nint L[maxn], B[maxn], R[maxn], T[maxn];\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a)\n{\n    if(a - lb < EPS){\n        return -1;\n    }\n    else{\n        if(a - ub > -EPS){\n            return 1;\n        }\n        else{\n            return 0;\n        }\n    }\n}\nbool check(double qx, double qy)\n{\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D > -EPS && D < 0) D = 0;\n    if(D < 0) return false;\n    for(int d = -1; d <= 1; d += 2){\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        double yt = calc(vy, X / vx);\n        if(yt < Y - EPS) continue;\n        bool ok = true;\n        for(int i = 0; i < N; i++){\n            if(L[i] >= X) continue;\n            if(R[i] >= X && Y <= T[i] && B[i] <= yt) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if(yL * yR <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nvoid solve()\n{\n    for(int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);\n    for(int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\nint main()\n{\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    for(int i = 0; i < N; i++){\n        scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int N = 66;\n\n#define db double\n\nint n;\n\ndb v, X, Y, L[N], R[N], B[N], T[N], vx, vy;\n\ninline db get_y(db x)\n{\n    db t = x / vx;\n    return vy * t - 0.5 * 9.8 * t * t;\n}\n\ninline bool check()\n{\n    db bx = X, by = get_y(X);\n    if (by < Y) return false;\n    for (int i = 0; i < n; ++i)\n    {\n        if (L[i] < X)\n        {\n            db l = L[i], r = min(X, R[i]);\n            db y1 = get_y(l), y2 = get_y(r);\n            if ( y1 >= B[i] && y1 <= T[i] ||\n                 y2 >= B[i] && y2 <= T[i] ||\n                 y1 <= B[i] && y2 >= B[i] ||\n                 y1 >= B[i] && y2 <= B[i] ||\n                 y1 <= T[i] && y2 >= T[i] ||\n                 y1 >= T[i] && y2 <= T[i]\n                )  return false;\n        }\n        if ( L[i] <= bx && R[i] >= bx )\n            if (B[i] <= Y && T[i] >= Y || B[i] >= Y && B[i] <= by )\n                return false;\n         return true;\n    }\n    return true;\n}\n\nint main()\n{\n//    freopen(\"std.in\",\"r\",stdin);\n    while(scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y)!=-1)\n    {\n        for(int i = 0; i < n; ++i)\n        {\n            scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n            if (L[i] > R[i]) swap(L[i], R[i]);\n            if (B[i] > T[i]) swap(B[i], T[i]);\n        }\n        db step = 1e-3;\n        int tag = 1;\n        for (vx = step; tag && vx <= v; vx += step)\n        {\n            vy = sqrt(v * v - vx * vx);\n            if (check())  tag = 0;\n        }\n        printf(tag ? \"No\\n\" : \"Yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2308\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\n// throw from origin to (x,y) with verocity v (x>0)\n// g: gravity\ntemplate<typename D>\nvector< pair<D, D> > projectile_motion(D v,D g,D x,D y){\n  D a=x*x+y*y;\n  D b=g*x*x*y-v*v*x*x;\n  D c=g*g*x*x*x*x/4;\n  if(b*b<4*a*c) return {};\n  vector< pair<D, D> > res;\n  {\n    D p=(-b+sqrt(b*b-4*a*c))/(2*a);\n    if(0<p&&p<v*v) res.emplace_back(sqrt(p),sqrt(v*v-p));\n  }\n  {\n    D p=(-b-sqrt(b*b-4*a*c))/(2*a);\n    if(0<p&&p<v*v) res.emplace_back(sqrt(p),sqrt(v*v-p));\n  }\n  return res;\n}\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nusing D = double;\nstruct Point{\n  D x,y;\n  Point(){}\n  Point(D x,D y):x(x),y(y){}\n};\n\nistream &operator>>(istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nsigned main(){\n  int n;\n  D v;\n  cin>>n>>v;\n  Point t;\n  cin>>t;\n  vector<Point> ps(n),qs(n);\n  for(int i=0;i<n;i++) cin>>ps[i]>>qs[i];\n  for(int i=0;i<n;i++) chmin(qs[i].x,t.x);\n\n  D g=9.8;\n\n  if(t.x==0){\n    D ti=v/g;\n    D y=v*ti-g/2*ti*ti;\n    if(y>=t.y) drop(\"Yes\");\n    drop(\"No\");\n  }\n\n  const D EPS = 1e-10;\n  vector<D> cand;\n  auto push=\n    [&](Point s){\n      for(auto pq:projectile_motion(v,g,s.x,s.y)){\n        D d=pq.first;\n        cand.emplace_back(d);\n        cand.emplace_back(d+EPS);\n        cand.emplace_back(d-EPS);\n      }\n    };\n\n  for(int i=0;i<n;i++){\n    if(ps[i].x>=t.x) continue;\n    push(ps[i]);\n    push(qs[i]);\n    push(Point(ps[i].x,qs[i].y));\n    push(Point(qs[i].x,ps[i].y));\n  }\n  push(t);\n\n  auto getY=\n    [&](D p,D q,D x){\n      D ti=x/p;\n      return q*ti-g/2*ti*ti;\n    };\n\n  auto in=\n    [&](int k,D p,D q)->int{\n      if(ps[k].x>=t.x) return 0;\n\n      if(ps[k].y<getY(p,q,ps[k].x) && getY(p,q,ps[k].x)<qs[k].y) return 1;\n      if(ps[k].y<getY(p,q,qs[k].x) && getY(p,q,qs[k].x)<qs[k].y) return 1;\n\n      if(ps[k].y<getY(p,q,ps[k].x) && getY(p,q,qs[k].x)<ps[k].y) return 1;\n      if(ps[k].y<getY(p,q,qs[k].x) && getY(p,q,ps[k].x)<ps[k].y) return 1;\n\n      if(qs[k].y<getY(p,q,ps[k].x) && getY(p,q,qs[k].x)<qs[k].y) return 1;\n      if(qs[k].y<getY(p,q,qs[k].x) && getY(p,q,ps[k].x)<qs[k].y) return 1;\n\n      D ti=q/g;\n      Point top(p*ti,getY(p,q,p*ti));\n      if(ps[k].x<top.x && top.x<qs[k].x &&\n         ps[k].y<top.y && top.y<qs[k].y) return 1;\n\n      return 0;\n    };\n\n\n  for(D p:cand){\n    D q=sqrt(v*v-p*p);\n\n    if(getY(p,q,t.x)<t.y) continue;\n\n    int flg=1;\n    for(int i=0;i<n;i++)\n      if(in(i,p,q)) flg=0;\n\n    if(flg) drop(\"Yes\");\n  }\n\n  cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB eps = 1e-8;\nconst int N = 150007;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\n\nconst double PI = acos(-1);\nconst double gg = 9.8;\n\n//double CalcMaxCeta(double X) {\n//    double l = 0.0, r = PI / 2;\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid1 = l + (r - l) / 3.0;\n//        double mid2 = r - (r - l) / 3.0;\n//        if (CalcHeight(mid1, X) > CalcHeight(mid2, X)) {\n//            l = mid2;\n//        } else {\n//            r = mid1;\n//        }\n//    }\n//    return l;\n//}\n//\n//double BinarySearch(bool op, double l, double r, double X, double Y) {\n//    for (int i = 1; i <= 40; i ++) {\n//        double mid = (l + r) / 2.0;\n//        double height = CalcHeight(mid, X);\n//        if (op == 0) { // ascending\n//            if (height > Y) r = mid; else l = mid;\n//        } else { // descending\n//            if (height > Y) l = mid; else r = mid;\n//        }\n//    }\n//}\n\n\ndouble V;\nint low;\n\nint sgn(double x){\n    return x < -eps ? -1 : x > eps;\n}\n\n\ninline double CalcHeight(double ceta, double X) {\n    double t = X / (V * cos(ceta));\n    double y = (V * sin(ceta)) * t - 0.5 * gg * t * t;\n    return y;\n}\n\ninline double GetM(double ceta) {\n    double t = V * sin(ceta) / gg;\n    return V * cos(ceta) * t;\n}\n\n\nint n, X, Y, l[N], b[N], r[N], t[N];\n\nbool Gao(double ceta) {\n    double hh = CalcHeight(ceta, X);\n//    cout << ceta << ' ' << X << ' ' << hh << ' ' << Y << ' ' << low << endl;\n    if (sgn(hh - Y ) < 0  || sgn(hh-low) > 0 )  {\n        return false;\n    }\n//    cout << \"~\";\n\n    double mx = GetM(ceta);\n    double my = CalcHeight(ceta, mx);\n\n\n    for (int i = 1; i <= n; i ++) {\n        if (l[i] > X) continue;\n\n        DB h1 = CalcHeight(ceta, l[i]);\n        DB h2 = CalcHeight(ceta, r[i]);\n\n\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (! (h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (! (h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n\n\n\n        /*double delta = (r[i] - l[i]) / 100.0;\n        int sum1 = 0, sum2 = 0;\n        for (int j = 0; j < 100; j ++) {\n            double ss = delta * j + l[i];\n            double h3 = CalcHeight(ceta, ss);\n            sum1 += sgn(h3 - b[i]);\n            sum2 += sgn(h3 - t[i]);\n        }\n        if (sum1 == -100 || sum2 == 100) {\n        } else {\n            return false;\n        }*/\n    }\n    return true;\n}\n\nbool Check() {\n//    double maxCeta = CalcMaxCeta(X);\n//    double maxHeight = CalcHeight(maxCeta, X);\n//    if (maxHeight < Y) {\n//        return false;\n//    }\n//    if (Gao(PI / 4.0)) return true;\n    if (X == 0 && Y == 0) {\n        return true;\n    }\n    else if (X == 0){\n        double hhh = CalcHeight(PI / 2, 0);\n        if (sgn(hhh - Y) < 0) return false;\n        for (int i = 1; i <= n; i ++) {\n            if (l[i] == 0 && b[i] <= Y)\n                return false;\n        }\n        return true;\n    }\n    for (int i = 1; i <= n; i ++){\n        if (l[i] == 0 && b[i] == 0) {\n            return false;\n        }\n\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n\n    }\n    for (double i = delta, delta = PI / 2 / 15000.0; i <= PI / 2; i += delta) {\n        if (Gao(i)) return true;\n    }\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (scanf(\"%d%lf%d%d\", &n, &V, &X, &Y) == 4) {\n        low = INF;\n        for (int i = 1; i <= n; i ++) {\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] <= X && X <= r[i]) {\n                if (Y >= t[i]) continue;\n                low = min(low, (int)b[i]);\n            }\n        }\n//        cout << low << endl;\n        if (Check()) puts(\"Yes\");\n        else puts(\"No\");\n//        break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LTE(h,lb)?-1:(GTE(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      double rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      double rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      //cout << \"getY = \" <<vy << \" \" << R[j] << endl;\n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      if( layer_top_x == 0 && layer_top_y >= 0 ) failed = true;\n      //if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  rep(i,N) R[i] = min(R[i],X);\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n\n  cin >> N >> v0 >> X >> Y;\n  rep(i,N) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2014 All rights reserved.\n*   \n*   filename: 2308.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2014-10-01\n*   last modified: 2014-10-01 10:56:18\n*/\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 55;\nconst double eps = 1e-8, inf = 1e20, g = 9.8;\nint n;\ndouble v, X, Y;\ndouble x[maxn][2], y[maxn][2];\ntypedef pair<double, int> pdi;\ntypedef vector<pdi> V;\nV Vec;\ndouble MaxAc;\n\nint dcmp(double x)\n{ return (x > -eps) - (x < eps); }\n\nvoid init()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lf%lf%lf%lf\", &x[i][0], &y[i][0], &x[i][1], &y[i][1]);\n}\n\nvoid cal(double a, double b, double c, V &vec)\n{\n\tdouble delta = b*b - 4*a*c;\n\tif (dcmp(delta) <= 0)\n\t{\n\t\tif (dcmp(a) > 0)\n\t\t{\n\t\t\tvec.push_back(make_pair(-inf, 1));\n\t\t\tvec.push_back(make_pair(inf, -1));\n\t\t}\n\t\treturn;\n\t}\n\n\tdelta = sqrt(delta);\n\tdouble t1 = (-b - delta) / (2 * a), t2 = (-b + delta) / (2 * a);\n\tif (dcmp(a) > 0)\n\t{\n\t\tvec.push_back(make_pair(-inf, 1));\n\t\tvec.push_back(make_pair(t1, -1));\n\t\tvec.push_back(make_pair(t2, 1));\n\t\tvec.push_back(make_pair(inf, -1));\n\t}\n\telse\n\t{\n\t\tvec.push_back(make_pair(t1, 1));\n\t\tvec.push_back(make_pair(t2, -1));\n\t}\n}\n\nvoid add(double x1, double y1, double x2, double y2, int sign)\n{\n\tdouble a1 = -g*x1*x1/2/v/v, b1 = x1, c1 = -g*x1*x1/2/v/v - y1;\n\tdouble a2 = -g*x2*x2/2/v/v, b2 = x2, c2 = -g*x2*x2/2/v/v - y2;\n\n\tif (sign) a1 = -a1, a2 = -a2, b1 = -b1, b2 = -b2, c1 = -c1, c2 = -c2;\n\n\tV vec;\n\tcal(a1, b1, c1, vec);\n\tcal(a2, b2, c2, vec);\n\tsort(vec.begin(), vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < vec.size(); i++)\n\t{\n\t\ttmp += vec[i].second;\n\t\tif (tmp == 2)\n\t\t{\n\t\t\tdouble t = vec[i].first;\n\t\t\tVec.push_back(make_pair(vec[i].first, 1));\n\t\t\tVec.push_back(make_pair(vec[i+1].first, -1));\n\t\t}\n\t}\n}\n\nbool judge(double l1, double r1, double l2, double r2)\n{\n\tdouble l = max(l1, l2), r = min(r1, r2);\n\tif (dcmp(l - r) > 0)\n\t\treturn false;\n\n\treturn dcmp(r-Y) >= 0;\n}\n\nbool judge(double l, double r)\n{\n\tdouble a = -g*X*X/2/v/v, b = X, c = -g*X*X/2/v/v;\n\tdouble fl = a*l*l + b*l + c, fr = a*r*r + b*r + c;\n\tdouble Min = min(fl, fr);\n\twhile (dcmp(l-r) < 0)\n\t{\n\t\tdouble m1 = l + (r-l) / 3, m2 = r - (r-l) / 3;\n\t\tdouble f1 = a*m1*m1 + b*m1 + c, f2 = a*m2*m2 + b*m2 + c;\n\t\tif (dcmp(f1-f2) < 0) l = m1; else r = m2;\n\t}\n\tdouble Max = a*l*l + b*l + c;\n\n\treturn dcmp(Min-MaxAc) <= 0 && dcmp(Max-Y) >= 0;\n}\n\nbool solve()\n{\n\tVec.clear();\n\tdouble a = -g*X*X/2/v/v, b = X, c = -g*X*X/2/v/v - Y;\n\tMaxAc = inf;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tadd(x[i][0], y[i][0], x[i][1], y[i][0], 1);\n\t\tadd(x[i][0], y[i][1], x[i][1], y[i][1], 0);\n\t\tif (dcmp(x[i][0]-X) <= 0 && dcmp(x[i][1]-X) >= 0)\n\t\t{\n\t\t\tif (dcmp(y[i][0]-Y) <= 0 && dcmp(y[i][1]-Y) >= 0)\n\t\t\t\treturn false;\n\t\t\tif (dcmp(y[i][0]-Y) >= 0)\n\t\t\t\tMaxAc = min(MaxAc, y[i][0]);\n\t\t}\n\t}\n\n\tVec.push_back(make_pair(-inf, 0));\n\tVec.push_back(make_pair(inf, 0));\n\tsort(Vec.begin(), Vec.end());\n\n\tint tmp = 0;\n\tfor (int i = 0; i+1 < Vec.size(); i++)\n\t{\n\t\ttmp += Vec[i].second;\n\t\tif (tmp == n && judge(Vec[i].first, Vec[i+1].first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lf%lf%lf\", &n, &v, &X, &Y))\n\t{\n\t\tinit();\n\t\tputs(solve()? \"Yes\": \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=2*v,mid = (l+r)/2;\n     double h,t,vx,vy,len;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           //cout<<l<<\" \"<<r<<endl;\n           vy=mid;\n           if ( vy-v>eps )\n              break;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps )\n              r=mid;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               //cout<<a<<\" *** \"<<len<<\" \"<<h<<endl;\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double g = 9.8;\nint N, V, X, Y, xa[55], ya[55], xb[55], yb[55];\npair<double, double> calc(double x, double y) {\n\t// The target position is (x, y)\n\tdouble e = 1.0 * V * V * V * V - 2.0 * g * y * V * V - g * g * x * x;\n\tif (e < 0.0) return make_pair(-1.0, -1.0);\n\tdouble d = sqrt(e);\n\tdouble b = 1.0 * V * V - g * y;\n\tdouble al = sqrt((b - d) * 2 / (g * g));\n\tdouble ar = sqrt((b + d) * 2 / (g * g));\n\treturn make_pair(x / V / ar, x / V / al);\n}\nint main() {\n\tcin >> N >> V >> X >> Y;\n\tbool flag = true;\n\tint lower = 1 << 30;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> xa[i] >> ya[i] >> xb[i] >> yb[i];\n\t\tif (xa[i] > X) {\n\t\t\t--N, --i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xb[i] > X) xb[i] = X;\n\t\tif (xa[i] <= X && X <= xb[i] && ya[i] <= Y && Y <= yb[i]) {\n\t\t\tflag = false;\n\t\t}\n\t\tif (xa[i] <= X && X <= xb[i] && ya[i] > Y) {\n\t\t\tlower = min(lower, ya[i]);\n\t\t}\n\t}\n\tvector<pair<double, double> > rngs;\n\tvector<double> cps = { 0.0, 1.0e+99 };\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<double, double> pa = calc(xa[i], ya[i]);\n\t\tpair<double, double> pb = calc(xb[i], yb[i]);\n\t\tpair<double, double> pc = calc(xa[i], yb[i]);\n\t\tpair<double, double> pd = calc(xb[i], ya[i]);\n\t\tvector<double> va = { pa.first, pa.second, pb.first, pb.second };\n\t\tvector<double> vb = { pc.first, pc.second, pd.first, pd.second };\n\t\tsort(va.begin(), va.end());\n\t\tsort(vb.begin(), vb.end());\n\t\trngs.push_back(make_pair(va[0], va[1]));\n\t\trngs.push_back(make_pair(va[2], va[3]));\n\t\trngs.push_back(make_pair(vb[0], vb[1]));\n\t\trngs.push_back(make_pair(vb[2], vb[3]));\n\t\tcps.insert(cps.end(), va.begin(), va.end());\n\t\tcps.insert(cps.end(), vb.begin(), vb.end());\n\t}\n\tpair<double, double> pe = calc(X, Y);\n\tpair<double, double> pf = calc(X, lower);\n\tvector<double> vc = { pe.first, pe.second, pf.first, pf.second };\n\tsort(vc.begin(), vc.end());\n\tcps.insert(cps.end(), vc.begin(), vc.end());\n\tsort(cps.begin(), cps.end());\n\tcps.erase(unique(cps.begin(), cps.end()), cps.end());\n\tvector<int> ps(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tps[i] = lower_bound(cps.begin(), cps.end(), vc[i]) - cps.begin();\n\t}\n\tvector<bool> cant(cps.size());\n\tfor (pair<double, double> x : rngs) {\n\t\tint l = lower_bound(cps.begin(), cps.end(), x.first) - cps.begin();\n\t\tint r = lower_bound(cps.begin(), cps.end(), x.second) - cps.begin();\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tcant[i] = true;\n\t\t}\n\t}\n\tbool ans = false;\n\tfor (int i = 1; i < cps.size(); ++i) {\n\t\tif (cps[i] > 0.0 && cps[i] - cps[i - 1] > 1.0e-9 && !cant[i - 1] && ((ps[0] < i && i <= ps[1]) || (ps[2] < i && i <= ps[3]))) {\n\t\t\tans = true;\n\t\t}\n\t}\n\tcout << (ans && flag ? \"Yes\\n\" : \"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,V,X,Y;\nconst int MAX_N = 50;\nconst double G = 9.8;\nint L [MAX_N],B [MAX_N],R [MAX_N],T [MAX_N];\nconst double EPS = 1e-10;\n\ndouble calc(double t,double v)\n{\n\treturn v * t - G * t * t / 2;\n}\n\nint cmp(double lb,double ub,double a)\n{\n\tif(a < lb + EPS) return -1;\n\tif(a < ub - EPS) return 0;\n\treturn 1;\n}\n\nbool check(double px,double py)\n{\n\tdouble a = G * G / 4,b = py * G - V * V,c = px * px + py * py;\n\tdouble D = b * b - 4 * a * c;\n\tif(D < 0.0 && D > -EPS) D = 0;\n\tif(D < 0.0) return false;\n\tfor(int d = -1;d <= 1;d += 2){\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif(t2 < 0.0 && t2 > -EPS) t2 = 0.0;\n\t\tif(t2 < 0.0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = px / t,vy = sqrt(V * V - vx * vx);\n\t\tif(abs(vx) < EPS || abs(vy) < EPS) continue;\n\t\tdouble yt = calc(X / vx,vy);\n\t\tif(yt < Y - EPS) continue;\n\n\t\tbool ok = true;\n\t\tFOR(i,0,N){\n\t\t\tif(L [i] >= X) continue;\n\t\t\tif(R [i] == X && Y <= T [i] && B [i] <= yt + EPS) ok = false;\n\t\t\tint yL = cmp(B [i],T [i],calc(L [i] / vx,vy));\n\t\t\tint yR = cmp(B [i],T [i],calc(R [i] / vx,vy));\n\t\t\tint xH = cmp(L [i],R [i],vx * (vy / G));\n\t\t\tint yH = cmp(B [i],T [i],calc(vy / G,vy));\n\t\t\tif(xH == 0 && yH >= 0 && yL < 0) ok = false;\n\t\t\tif(yL * yR <= 0) ok = false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tFOR(i,0,N){\n\t\tscanf(\"%d%d%d%d\",&L [i],&B [i],&R [i],&T [i]);\n\t\tchmin(R [i],X);\n\t}\n\n\tbool ans = check(X,Y);\n\tFOR(i,0,N){\n\t\tans |= check(L [i],T [i]) || check(R [i],T [i]);\n\t}\n\tputs(ans ? \"Yes\" : \"No\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) //pig 在一个矩形的下面 \n         {\n              if ( h1<=rec[i].b && h2<=rec[i].b && hh-yy>eps )//抛物&#32447;从pig上方&#39134;&#36807; \n                 return true;\n              return false;//抛物&#32447;撞上了障碍物 \n         }\n         \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n         {\n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n              else continue;\n         }\n         \n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 \n          \n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 \n         if ( rec[i].r>xx )  continue;//障碍物的右&#36793;界在pig的右&#36793; \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-2;\nconst double g = 9.8;\nint n,tp;\ndouble v,x,y,L[50],B[50],R[50],T[50],px[500],py[500];\n\nint cmp(double a,double b)\n{\n    if (fabs(a-b) < eps)    return 0;\n    if (a < b)  return -1;\n    return 1;\n}\n\nbool Gao(double a,double b)\n{\n    //y = a*x^2+b*x\n    double ty = a*x*x+b*x;\n    if (cmp(ty,y) < 0)  return false;\n    double tyl,tyr;\n    for (int i = 0; i < n; i++)\n    {\n        tyl = a*L[i]*L[i]+b*L[i];\n        tyr = a*R[i]*R[i]+b*R[i];\n        if (cmp(B[i],tyl) < 0 && cmp(tyl,T[i]) < 0)   return false;\n        if (cmp(B[i],tyr) < 0 && cmp(tyr,T[i]) < 0)   return false;\n        if (cmp(tyl,B[i]) <= 0 && cmp(tyr,B[i]) > 0)    return false;\n        if (cmp(tyl,T[i]) >= 0 && cmp(tyr,T[i]) < 0)    return false;\n    }\n    return true;\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y) != EOF)\n    {\n        tp = 0;\n        px[tp] = x;\n        py[tp++] = y;\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n            px[tp] = L[i];\n            py[tp++] = B[i];\n            px[tp] = L[i];\n            py[tp++] = T[i];\n            px[tp] = R[i];\n            py[tp++] = B[i];\n            px[tp] = R[i];\n            py[tp++] = T[i];\n        }\n        bool res = false;\n        for (int i = 0; i < tp; i++)\n        {\n            if (px[i] == 0)\n            {\n                if (cmp(x,0) != 0)  continue;\n                if (cmp(v*v/(2*g),y) >= 0)  res |= true;\n                continue;\n            }\n            double ta,tb;\n            tb = (px[i]*v*v+sqrt(px[i]*px[i]*v*v*v*v-px[i]*px[i]*px[i]*px[i]*g*g-2*px[i]*px[i]*py[i]*v*v*g))/(px[i]*px[i]*g);\n            ta = (py[i]-tb*px[i])/(px[i]*px[i]);\n            double tx,ty1,ty2;\n            tx = -tb/(2*ta);\n            ty1 = v*v/(2*g)-g*tx*tx/(2*v*v);\n            ty2 = ta*tx*tx+tb*tx;\n            //cout << ty1 << ' ' << ty2 << endl;\n            res |= Gao(ta,tb);\n            tb = (px[i]*v*v-sqrt(px[i]*px[i]*v*v*v*v-px[i]*px[i]*px[i]*px[i]*g*g-2*px[i]*px[i]*py[i]*v*v*g))/(px[i]*px[i]*g);\n            ta = (py[i]-tb*px[i])/(px[i]*px[i]);\n            res |= Gao(ta,tb);\n        }\n        if (res == true)    puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size()-1; i++){\n\t\t\tdouble ta = (allTAN[i] + allTAN[i+1])/2;\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÖWÌ³¢ubN\n\t\t\t\tif(allL[j]>x) continue;\n\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,x)<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,x)>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,x)>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allL[j]<x && x<allR[j]){\n\t\t\t\t\t\t\tif(y<allB[j] && allT[j]<thoy){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\nint v0,X,Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %lf %lf %lf\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%lf %lf %lf %lf\",L+i,B+i,R+i,T+i);\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\n//ÀWiX,Y)ðÊéæ¤ÈtanÌlðßApush·é\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\t//OBæèàá­È¯êÎ^ãÉáQ¨ª é\n\t\tif(L[i]<X && X<R[i])\n\t\t\tOB=min(OB,B[i]);\n\t}\n\t//^[QbgðÊéæ¤ÈtanÌlðßé\n\tadd(X,Y);\n\n\t//áQ¨Ì¶ãAEãðÊéæ¤ÈtanÌlßé\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\t//^[QbgÌ^ãÉ½Æ«OBæèà¢A»à»àÍ©È¢ÍO\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\t//eáQ¨ÆÕË»èð·é\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\t//XÀWªáQ¨ÌÍÍàÌÆ«ÌÅåÌ³AÅáÌá³ðßé\n\t\t\t//XÀWªáQ¨Ì¶[ÆE[ÌÆ«Ì³ðßé\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\t//¸_ªÜÜêéÆ«ÍA¸_ªÅåÌ³\n\t\t\tif(L[j]<center && center<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t\n\t\t\t//àµÔÂ©éÈçÌtanð·\n\t\t\tif(!(My<B[j] || T[j]<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//àµ`FbNðNAµ½tanª¶Ýµ½çYesðoÍµÄIíè\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   //0<慮<180 // counter clockwise\n  if (cross(b, c) < -eps) return -1; //180<慮<360 clockwise\n  if (dot(b, c) < 0) return 2;       //慮=180// c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * px / sqrt(px*px+px*px);\n  ld vy = V * py / sqrt(px*px+py*py);\n  ld t1 = (double)l/vx;\n  ld  t2 = (double)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  bool ok = true;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) ok = false;\n  }\n  REP(i,N){\n    REP(j,N){\n      if(check(L[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(L[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n    }\n    if(ok == false) break;\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(T[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        //if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\n\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\ndouble Max,Min;\nvector<double> Tan;\n\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<eps || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=max(OB,B[i]);\n\t}\n\tadd(X,Y);\n\tif(Tan.size()==0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center+eps<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\n\t\t\tif(!(My+eps<B[j] || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld t1 = (ld)l/vx;\n  ld t2 = (ld)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) flag = -1;\n  }\n  if(flag == 1){\n    flag = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n      }\n    }\n    if((N==0)||(flag)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LTE(h,lb)?-1:(GTE(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      double rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n      double rect_R_t = R[j] / vx;\n      double rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n      /*\n      cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n      */\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n\n  cin >> N >> v0 >> X >> Y;\n  rep(i,N) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ndouble fen,jiao,v,wei,ma,x,y,pai,ca,cb,l[110],r[110],b[110],t[110];\nint n,i,j;\ndouble qiu(double a)\n{\n return(a*a*ca+cb*a);\n}\nbool can(int a)\n{\n  double bt,x1,x2,y1,y2;\n  y1=qiu(l[a]);\n  if (l[a]<=x && (t[a]-y1)*(b[a]-y1)<=0) return(false);\n  y2=qiu(r[a]);\n  if (r[a]<=x && (t[a]-y2)*(b[a]-y2)<=0) return(false); \n  bt=cb*cb+4*ca*t[a];\n  if (bt>0)\n  {\n    x1=(-cb+sqrt(bt))/2/ca;\n\tx2=(-cb-sqrt(bt))/2/ca;\n\tif (x1<=x && l[a]<=x1 && r[a]>=x1) return(false);\n\tif (x2<=x && l[a]<=x2 && r[a]>=x2) return(false); \n  }\n  if (bt==0)\n  {\n    if (wei<=x && l[a]<=wei && r[a]>=wei) return(false);  \n  }\n  bt=cb*cb+4*ca*b[a];\n  if (bt>0)\n  {\n    x1=(-cb+sqrt(bt))/2/ca;\n\tx2=(-cb-sqrt(bt))/2/ca;\n\tif (x1<=x && l[a]<=x1 && r[a]>=x1) return(false);\n\tif (x2<=x && l[a]<=x2 && r[a]>=x2) return(false); \n  }\n  if (bt==0)\n  {\n    if (wei<=x && l[a]<=wei && r[a]>=wei) return(false);  \n  }\n  if (x>=l[a] && x<=r[a] && ma>t[a] && y<t[a]) return(false);\n  if (x>=l[a] && x<=r[a] && ma>b[a] && y<b[a]) return(false);\n  return(true);\n}\nint main()\n{\n  scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y);\n  for (i=1;i<=n;i++) scanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n  pai=3.1415926535898/2;\n  fen=pai/50000;\n  for (i=1;i<50000;i++)\n  {\n    jiao=i*fen;\n    ca=-9.8/(2*cos(jiao)*cos(jiao)*v*v);\n    cb=sin(jiao)/cos(jiao);\n\tif (qiu(x)<=y) continue;\n\twei=-cb/ca/2;\n\tma=qiu(x);\n    for (j=1;j<=n;j++) if (!can(j)) break;\n    if (j>n) break;\n  }\n  if (i<50000) printf(\"Yes\\n\"); else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tvector<ld>tans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\n\t\tR = min(R, X);\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p, (x + y) % 2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t\t//if (L >= X)continue;\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < bs.size(); ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < bs.size(); ++i) {\n\t\t\t\tauto b = bs[i];\n\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nint lx[100];\nint ly[100];\nint rx[100];\nint ry[100];\ndouble EPS=1e-9;\nvector<pair<int,int> > v;\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(rx[i],ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-4.9*4.9*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))/2/4.9/4.9;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))/2/4.9/4.9;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double g = 9.8;\t//??????????????? \nconst int MAX_N = 55; \n\n//?????\\ \nint N;\ndouble V, X, Y;\ndouble L[MAX_N], R[MAX_N], B[MAX_N], T[MAX_N];\n\n//????????\\vy??????????????´???????°????t?§????????????? \ndouble calc(double vy, double t){\n\treturn vy * t - g * t * t / 2;\n}\n\n//a??????lb???ub????????? \nint cmp(double lb, double ub, double a){\n\treturn a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//??????????°???????????????????(qx, qy)??¶????????????????????????\nbool check(double qx, double qy)\n{\n    //??????????????¨x?????????y????????????????????????vx???vy????????????(qx, qy)?????¶??´???t\n    //????§£??????????¨????vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //????????????????¨?????????????????§£?????????\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //??????????????????????????£??????\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //????????¨?????£???????????????????????´?????????????¢????\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //????????¨?£???°????????£??????????????????????????°????¢????\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //?????§???????????????\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //?????§???????????????\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //????????????????????????\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve(){\n\t//???????????\\??????????¢???? \n \tfor(int i = 0; i < N; i++){\n \t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\t\t\t//??´??\\?????????????????? \n\tfor(int i = 0; i < N; i++){\n\t \tok |= check(L[i], T[i]);\t//?????????????§?????????? \n\t \tok |= check(R[i], T[i]);\t//?????????????§?????????? \n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}\nint main(){\n \twhile(scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y)!=EOF){\n \t\tfor(int i = 0; i < N; i++)\n \t\t\tscanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\t\n\t\tsolve();\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB EPS = 1e-8;\nconst DB PI = acos(-1);\nconst DB gg = 9.8;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\n\n\ninline void checkMin(int &a, int b){\n    if (b < a) a = b;\n}\n\ninline int sgn(double x){\n    return x < -EPS ? -1 : x > EPS;\n}\n\nconst int N = int(1e2) + 9;\nint n, l[N], b[N], r[N], t[N];\nint X, Y; DB V; int low;\n\ninline DB y(DB a, DB x) {\n    DB t = x/(V*cos(a));\n    return V*sin(a)*t - 0.5*gg*t*t;\n}\n\ninline DB getM(DB a){\n    DB t = V*sin(a)/gg;\n    return V*cos(a)*t;\n}\n\nbool ck(DB a) {\n\n    DB h = y(a, X); if (sgn(h-Y) < 0 || sgn(h-low) > 0 ) return false;\n    DB mx = getM(a), my = y(a, mx);\n\n    REP(i, n){\n\n        DB h1 = y(a, l[i]), h2 = y(a, r[i]);\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (!(h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (!(h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n    }\n    return true;\n}\n\nbool ck() {\n\n    REP(i, n){\n        if (l[i] == 0 && b[i] == 0) return false;\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n    }\n\n    DB d = PI/2/10000;\n    for (DB a=d;a<=PI/2;a+=d) if (ck(a)) return true;\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (~scanf(\"%d%lf%d%d\", &n, &V, &X, &Y)) {\n        low = INF; REP(i, n){\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] > X){\n                --i; --n;\n                continue;\n            }\n            if (r[i] >= X){\n                if (b[i] >= Y) checkMin(low, b[i]);\n                r[i] = X;\n            }\n        }\n        puts(ck() ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %lf %lf %lf\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%lf %lf %lf %lf\",L+i,B+i,R+i,T+i);\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 55;\nconst double g = 9.8;   //重力加速度\nconst double EPS = 1e-10;\nint N;\ndouble V, X, Y;\ndouble L[maxn], B[maxn], R[maxn], T[maxn];\n\n//&#35745;算以vy的速度&#31446;直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相&#23545;lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\n\n//判断当射出路径&#32463;&#36807;点(qx, qy)&#26102;，卵是否能&#20987;中猪\nbool check(double qx, double qy)\n{\n    //&#35774;初速度在x方向和y方向的分量分&#21035;&#20026;vx和vy，&#35774;通&#36807;(qx, qy)的&#26102;&#38388;&#20026;t\n    //&#35774;解&#32852;立方程式vx^2 + vy ^2 = V^2, vx * t = 1x, vy * t - 1/2 g t^2 = qy\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -EPS)\n        D = 0;\n    if (D < 0)\n        return false;\n    for (int d = -1; d <= 1; d += 2){       //&#39564;&#35777;&#32852;立方程式上的&#20004;个解的循&#29615;\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0)\n            continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n\n        //判断是否通&#36807;猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - EPS)\n            continue;\n\n        bool ok = true;\n        for (int i = 0; i < N; i++){\n            if (L[i] >= X)\n                continue;\n            //判断在猪正上方的&#40479;和猪之&#38388;是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt)\n                ok = false;\n            //判断在&#39134;到猪的正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));   //左&#20391;的相&#23545;位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));   //右&#20391;的相&#23545;位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));      //最高点的相&#23545;位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0)\n                ok = false;\n            if (yL * yR <= 0)\n                ok = false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    //截掉猪以右的障碍物\n    for (int i = 0; i < N; i++){\n        R[i] = min(R[i], X);\n    }\n    bool ok = check(X, Y);      //直接撞上猪的情况\n    for (int i = 0; i < N; i++){\n        ok |= check(L[i], T[i]);     //&#32463;&#36807;左上角的情况\n        ok |= check(R[i], T[i]);     //&#32463;&#36807;右上角的情况\n    }\n    puts(ok ? \"Yes\" : \"No\");\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\", &N, &V, &X, &Y) != EOF){\n        for (int i = 0; i < N; i++){\n            scanf(\"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;\n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );\n         double h2 = a*rec[i].r*(rec[i].r-len );\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) \n         {\n              if ( h1<=rec[i].b && h2<=rec[i].b && hh-yy>eps )\n                 return true;\n              return false;\n         }\n         if ( h1<rec[i].b && h2<rec[i].b ) continue;\n         if ( rec[i].l>xx ) continue;\n         if ( len/2<rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;\n         if ( h1-rec[i].b>eps && h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;\n         \n         if ( rec[i].r>xx )  continue;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define eps 1e-8\nusing namespace std;\ndouble L[100],R[100],B[100],T[100];\ndouble X,Y,v,g=9.8;\nint n;\nint sgn(double x)\n{\n\treturn x<-eps?-1:x>eps;\n}\nint ck(double a,double b,double c)\n{\n\tif(sgn(a-c)*sgn(b-c)<0) return 1;\n\treturn 0;\n}\nint ck(double h)\n{\n\t//printf(\"%f\\n\",h);\n\tfor(int i=0;i<n;i++){\n\t\tif(sgn(L[i]-X)<=0) {\n\t\t\tdouble x=L[i];\n\t\t\tdouble y1=h*x-g/2/v/v*x*x*(1+h*h);\n\t\t\tif(sgn(y1-T[i])<0&&sgn(y1-B[i])>0) return 0;\n\t\t\tif(sgn(R[i]-X)>=0) x=X;\n\t\t\telse x=R[i];\n\t\t\tdouble y2=h*x-g/2/v/v*x*x*(1+h*h);\n\t\t\tif(ck(y1,y2,B[i])||ck(y1,y2,T[i])||ck(y1,y2,(B[i]+T[i])/2)) return 0;\n\t\t}\n\t\tif(sgn(R[i]-X)<=0){\n\t\t\tdouble x=R[i];\n\t\t\tdouble y=h*x-g/2/v/v*x*x*(1+h*h);\n\t\t\tif(sgn(y-T[i])<0&&sgn(y-B[i])>0) return 0;\n\t\t}\n\t}\n\tdouble y=h*X-g/2/v/v*X*X*(1+h*h);\n\t//printf(\"%f\\n\",y);\n\tif(sgn(y-Y)>=0) return 1;\n\treturn 0;\n}\nint ck(double x,double y)\n{\n\tif(sgn(x)==0) return 0;\n\tdouble a=-g/2/v/v*x*x;\n\tdouble b=x;\n\tdouble c=-g/2/v/v*x*x-y;\n\tdouble w=b*b-4*a*c;\n\tif(sgn(w)<0) return 0;\n\tw=sqrt(w);\n\tdouble h1=(-b+w)/(2*a);\n\tif(ck(h1)) return 1;\n\th1=(-b-w)/(2*a);\n\treturn ck(h1);\n}\nint main()\n{\n\tscanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%lf%lf%lf%lf\",L+i,B+i,R+i,T+i);\n\tint flag=0;\n\tif(sgn(v)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ck(L[i],B[i])||ck(R[i],B[i])||ck(L[i],T[i])||ck(R[i],T[i])) {\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(ck(X,Y)) flag=1;\n\tif(flag) puts(\"Yes\");\n\telse puts(\"No\");\n}\n/***\n0 7 3 1\n0.466667\n2.866667\nNo\n***/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) //pig 在一个矩形的下面 \n         {\n              if ( h1<=rec[i].b && h2<=rec[i].b && hh-yy>eps )//抛物&#32447;从pig上方&#39134;&#36807; \n                 return true;\n              return false;//抛物&#32447;撞上了障碍物 \n         }\n         if ( h1<rec[i].b && h2<rec[i].b ) continue;//抛物&#32447;从矩形下方&#39134;&#36807; \n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // \n         if ( len/2>rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;//抛物&#32447;最高点在矩形中 \n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 \n         if ( rec[i].r>xx )  continue;//障碍物的右&#36793;界在pig的右&#36793; \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * tanv * tanv;\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\t\n\tvector<double> uxtmp;\n\tfor( auto b : box ){\n\t\tdouble x = b.p1.x();\n\t\tuxtmp.push_back(x);\n\t\tdouble y = f(x);\n\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble x = b.p2.x();\n\t\tdouble y = f(x);\n\t\tuxtmp.push_back(x);\n\t\tif( inner(b.p2.y(),y,b.p3.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble y = b.p1.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\t\tdouble y = b.p3.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << hx << endl;\n\tif( hx - EPS > X ){\n\t\tif( f(X) > Y - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\tif(true){\n\t\tdouble x = X;\n\t\tdouble y = Y;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D > -EPS ){\n\t\t\tD = max(0.0,D);\n\t\t}\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\tps.push_back(a);\n\t\tps.push_back(b);\n\t\tps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  //cout << vx <<endl;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n   // cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    //R[i] = min(R[i],X);\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<X)&&(X<R[i])&&(B[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  if(l<=X){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n    //cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;return -1;}\n  else {//cout << rs1 << \" \" <<rs2<<endl; return rs1 * rs2;}\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])&&(T[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\nbool ok[50]={};\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nbool comp(double lb,double ub,double x){\n\tif(lb<x+eps) return -1;\n\tif(x<ub+eps) return 1;\n\treturn 0;\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<l[i]||r[i]<x) continue;\n\t\t\tif(y<=u[i]&&d[i]<=ry) ok=false;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble ly=comp(d[i],u[i],calcy(vy,l[i]/vx));\n\t\t\tdouble ry=comp(d[i],u[i],calcy(vy,r[i]/vx));\n\t\t\tdouble hx=comp(l[i],r[i],vy/g*vx);\n\t\t\tdouble hy=comp(l[i],r[i],calcy(vy,vy/g));\n\t\t\tif(hx==0&&hy>=0&&ly<0) ok=false;\n\t\t\tif(ly*ry<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<cstring>\n#include<map>\n#include<set>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<time.h>\nusing namespace std;\nconst int INF=1<<30;\ntypedef long long ll;\nconst double eps=1e-6;\n\n\nconst double g=9.8;\n\nint n,m;\ndouble v,x,y;\n\nstruct point{\n    double x,y;\n};\n\nstruct Matrix{\n    point a,b,c,d;\n}e[100];\n\ndouble gety(double vy,double t){\n    return vy*t-g*t*t/2;\n}\n\nint cmp(int l,int r,int a){\n    return a<l+eps?-1:a>r-eps?1:0;\n}\n\nbool juge(point Q){\n    int i,j,k;\n    double a=0.25*g*g,b=g*Q.y-v*v,c=Q.x*Q.x+Q.y*Q.y;\n    double D=(b*b-4.0*a*c);\n    if(D<0&&D>-eps)D=0;\n    if(D<0)return false;\n    for(i=-1;i<=1;i+=2){\n        double t=(i*sqrt(D)-b)/(2.0*a);\n        if(t<=0)continue;\n        double t1=sqrt(t);\n        double vx=Q.x/t1,vy=(0.5*g*t+Q.y)/t1;\n        double yt=gety(vy,x/vx);\n        if(yt<y-eps)continue;\n\n        bool ok=true;\n        for(j=0;j<n;j++){\n            if(e[j].a.x>=x)continue;\n            if(yt>=e[j].a.y&&y<=e[j].c.y&&e[j].d.x==x)ok=false;\n\n            int yL=cmp(e[j].c.y,e[j].a.y,gety(vy,e[j].a.x/vx));\n            int yR=cmp(e[j].d.y,e[j].b.y,gety(vy,e[j].b.x/vx));\n            int xH=cmp(e[j].a.x,e[j].b.x,vx*(vy/g));\n            int yH=cmp(e[j].c.y,e[j].a.y,gety(vy,(vy/g)));\n            if(xH==0&&yH>=0&&yL<0)ok=false;\n            if(yL*yR<=0)ok=false;\n        }\n        if(ok)return true;\n    }\n    return false;\n}\n\nint main()\n{\n    int i,j;\n    cin>>n>>v>>x>>y;\n    int cnt=0;\n    for(i=0;i<n;i++){\n        double x1,y1,x2,y2;\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n        if(x1>=x)continue;\n        if(x2>x)x2=x;\n        point a,b,c,d;\n        a.x=x1,a.y=y2;\n        b.x=x2,b.y=y2;\n        c.x=x1,c.y=y1;\n        d.x=x2,d.y=y1;\n        e[cnt].a=a,e[cnt].b=b,e[cnt].c=c,e[cnt++].d=d;\n    }\n    n=cnt;\n    int ok=0;\n    point W;W.x=x,W.y=y;\n    if(juge(W))ok=1;\n    if(ok){\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    for(i=0;i<n;i++){\n        if(juge(e[i].a)||juge(e[i].b))ok=1;\n    }\n    if(ok)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        if(cmp(r.bottom(), y_left) < 0 && cmp(y_left, r.top()) < 0) return false;\n        if(cmp(r.bottom(), y_right) < 0 && cmp(y_right, r.top()) < 0) return false;\n        if(cmp(r.top(), y_left) * cmp(r.top(), y_right) < 0) return false;\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) && cmp(top_y, r.bottom()) > 0) return false;\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\n\nint N;\ndouble V,X,Y;\ndouble Max,Min;\ndouble OB;\nvector<double> L,B,R,T;\n\npair<double,double> calc(double X,double Y){\n\tdouble a=1.0/2.0*g*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*g*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || a-eps<0)\n\t\treturn make_pair(-1.0,-1.0);\n\tdouble ans1=(-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n\tdouble ans2=(-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n\treturn make_pair(ans1,ans2);\n}\n\nvoid solve()\n{\n\tvector<double> VT;\n\tOB=301.0;\n\tL.resize(N);B.resize(N);R.resize(N);T.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]+eps<X && X+eps<R[i])\n\t\t\tOB=B[i];\n\t}\n\tpair<double,double>p1=calc(X,Y);\n\tif(p1.first<0){\n\t\tcout<<\"No\\n\";\n\t\treturn;\n\t}\n\tMax=p1.second;\n\tMin=p1.first;\n\tVT.push_back(Min);\n\tfor(int i=0;i<N;i++){\n\t\tpair<double,double>tp=calc(L[i],T[i]);\n\t\tif(tp.first>0 && tp.first<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.first);\n\t\ttp=calc(R[i],T[i]);\n\t\tif(tp.second>0 && tp.second<Max && tp.second>Min)\n\t\t\tVT.push_back(tp.second);\n\t}\n\tfor(int i=0;i<VT.size();i++){\n\t\tbool ok=true;\n\t\tdouble center=VT[i]*V*V/g/(1.0+VT[i]*VT[i]);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\tmy=L[j]*VT[i]-1.0/2.0*g*L[j]*L[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tMy=R[j]*VT[i]-1.0/2.0*g*R[j]*R[j]/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>My) swap(my,My);\n\t\t\tif(L[j]+eps<center && center<R[j]-eps)\n\t\t\t\tMy=center*VT[i]-1.0/2.0*g*center*center/V/V*(1+VT[i]*VT[i]);\n\t\t\tif(my>B[j] || My<T[j]){\n\t\t\t\tif(X*VT[i]-1.0/2.0*X*X/V/V*(1.0+VT[i]*VT[i])+eps<OB){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-7;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\t// áQ¨ª½à³¢ÍÈP\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\tbool okflg = false;\n\n\t\t// STõ\n\t\tif(1){\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(i==0) continue;\n\t\t\t\tallTH.push_back(90.0/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<=x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld t1 = (ld)l/vx;\n  ld t2 = (ld)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) flag = -1;\n  }\n  if(flag == 1){\n    flag = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n      }\n    }\n    if(flag) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]-EPS && r>B[i]+EPS) return false;\n        if(l<T[i]-EPS && r>T[i]+EPS) return false;\n        if(l<B[i]-EPS && r<B[i]-EPS && yof(vy, vy/g)>B[i]+EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i]) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\nstruct node1\n{\nint x1;\nint y1;\nint x2,y2;\n}node[55];\nint main()\n{\t\n\t\n\tint N,V,X,Y;\n\tint a,b,c,d;\n\tdouble x1,x2;\n\tint i;\n\twhile(scanf(\"%d%d%d%d\",&N,&V,&X,&Y)!=EOF)\n\t\t{\n\t\tmemset(node,0,sizeof(node));\n\t\tfor(i=0;i<N;i++)\n\t\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tnode[i].x1=a;node[i].y1=d;\n\t\t\tnode[i].x2=c;node[i].y2=d;\n\t\t\tdouble m=(d*9.8-V*V)*(d*9.8-V*V)-9.8*9.8*(d*d+a*a);\n\t\t\tif(m<0)  {printf(\"No\\n\");  break;}\n\t\t\tif(V*V-d*9.8+sqrt(m)>=0)\n\t\t\t{x1=(V*V-d*9.8+sqrt(m))/(0.5*9.8*9.8);}\n\t\t\tif(V*V-d*9.8-sqrt(m)>=0)\n\t\t\t{x2=(V*V-d*9.8-sqrt(m))/(0.5*9.8*9.8);}\n\t\t\tif(sqrt(V*V*x2-c*c)-0.5*9.8*x2<d&&sqrt(V*V*x1-c*c)-0.5*9.8*x1<d)\n\t\t\t\t{\n\t\t\t\tprintf(\"No\\n\");break;\n\t\t\t\t}\n\t\t\tif(sqrt(V*V*x1-c*c)-0.5*9.8*x1>=d)//||sqrt(V*V*x2-c*c)-0.5*9.8*x2>=d)\n\t\t\t\t{\n\t\t\t\tif(sqrt(V*V*x1-X*X)-0.5*9.8*x1>=Y)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif(sqrt(V*V*x2-c*c)-0.5*9.8*x2>=d)\n\t\t\t\t{\n\t\t\t\tif(sqrt(V*V*x2-X*X)-0.5*9.8*x2>=Y)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\tif(i==N)\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB EPS = 1e-8;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1);\nconst double gg = 9.8;\n\ninline void checkMin(int &a, int b){\n    if (b < a) a = b;\n}\n\ninline int sgn(double x){\n    return x < -EPS ? -1 : x > EPS;\n}\n\nconst int N = int(1e2) + 9;\nint n, l[N], b[N], r[N], t[N];\nint X, Y; DB V; int low;\n\ninline DB y(DB a, DB x) {\n    DB t = X/(V*cos(a));\n    return V*sin(a)*t - 0.5*gg*t*t;\n}\n\ninline DB getM(DB a){\n    DB t = V*sin(a)/gg;\n    return V*cos(a)*t;\n}\n\nbool ck(DB a) {\n    DB h = y(a, X); if (sgn(h-Y) < 0 || sgn(h-low) > 0 ) return false;\n    DB mx = getM(a), my = y(a, mx);\n\n    REP(i, n){\n        DB h1 = y(a, l[i]), h2 = y(a, r[i]);\n        if (l[i] <= mx && mx <= r[i]){\n            if (!(h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (!(h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n    }\n    return true;\n}\n\nbool ck() {\n\n    REP(i, n){\n        if (l[i] == 0 && b[i] == 0) return false;\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n    }\n\n    DB d = PI/2/15000;\n    for (DB a=d;a<=PI/2;a+=d) if (ck(a)) return true;\n    return false;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    while (~scanf(\"%d%lf%d%d\", &n, &V, &X, &Y)) {\n        low = INF; REP(i, n){\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] > X){\n                --i; --n;\n                continue;\n            }\n            if (r[i] >= X){\n                if (b[i] >= Y) checkMin(low, b[i]);\n                r[i] = X;\n            }\n        }\n        puts(ck() ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tup = min(up, bs[i].ys[0]);\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-10)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = (g*y-v*v), c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\nbool yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS < l && l < T[i]-EPS) return false;\n        if(B[i]+EPS < r && r < T[i]-EPS) return false;\n        if(l<B[i]+EPS && r>B[i]-EPS) return false;\n        if(l<T[i]+EPS && r>T[i]-EPS) return false;\n        if(l<B[i]+EPS && r<B[i]+EPS && yof(vy, vy/g)>B[i]-EPS) return false;\n        const double m = yof(vy, (L[i]+R[i])/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i] && T[i]>=Y) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <math.h>\nusing namespace std;\n#define pi acos(-1)\n\n\nstruct node\n{\n    double x1,y1,x2,y2;\n};\nnode p[100];\nint n;\ndouble v,x,y;\ndouble g = 9.8;\n\ndouble get(double xx,double k)\n{\n    double t = xx/(v*cos(k));\n    double yt = v*sin(k)*t - 0.5 * g * t * t;\n    return yt;\n}\n\n\nint check(double k)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(p[i].x1>x)\n            continue;\n        node t = p[i];\n\n        t.x1 = min(x,t.x1);\n        t.x2 = min(x,t.x2);\n        double h = get(t.x1,k);\n        if(h<=t.y2&&h>=t.y1)\n            return 0;\n\n        h = get(t.x2,k);\n        if(h<=t.y2&&h>=t.y1)\n            return 0;\n\n\n\n        double a = -0.5 * g;\n\n        double b = v*sin(k);\n\n        double c = -t.y1;\n\n        if(b*b-4*a*c>=0)\n        {\n            double kkk = b*b-4*a*c;\n            double x1 = (-b+(sqrt(kkk)))/(2*a);\n            double x2 = (-b-(sqrt(kkk)))/(2*a);\n            x1 = x1/(v*(cos(k)));\n            x2 = x2/(v*(cos(k)));\n            if(x1<=t.x2&&x1>=t.x1)\n                return 0;\n            if(x2<=t.x2&&x2>=t.x1)\n                return 0;\n        }\n\n        c = -t.y2;\n\n        if(b*b-4*a*c>=0)\n        {\n            double kkk = b*b-4*a*c;\n            double x1 = (-b+(sqrt(kkk)))/(2*a);\n            double x2 = (-b-(sqrt(kkk)))/(2*a);\n            x1 = x1/(v*(cos(k)));\n            x2 = x2/(v*(cos(k)));\n            if(x1<=t.x2&&x1>=t.x1)\n                return 0;\n            if(x2<=t.x2&&x1>=t.x1)\n                return 0;\n        }\n    }\n\n    double h = get(x,k);\n    if(h<y)return 0;\n    for(int i=1;i<=n;i++)\n    {\n        if(p[i].x1<=x&&p[i].x2>=x)\n        {\n            if(p[i].y1<=h&&p[i].y1>=y)\n                return 0;\n            if(p[i].y2<=h&&p[i].y2>=y)\n                return 0;\n        }\n    }\n\n    return 1;\n}\nint main()\n{\n\n    scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p[i].x1,&p[i].y1,&p[i].x2,&p[i].y2);\n        if(p[i].x1>p[i].x2)swap(p[i].x1,p[i].x2);\n        if(p[i].y1>p[i].y2)swap(p[i].y1,p[i].y2);\n    }\n\n    for(double i=0;i<=pi/2;i+=pi/1000)\n    {\n        if(check(i))\n        {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\n\npair<double, double> tanth(int x, int y, int v)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\n\tif(d<0) return make_pair<double, double>(-1, -1);\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha * kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³ÊÈª»\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\t/*\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\t*/\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\t/*\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\t*/\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\t/*\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\t*/\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\t/*\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\t*/\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\t/*\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\t*/\n\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<bitset>\nusing namespace std;\n#define eps 1e-8\n#define ll __int64\nconst double g=9.8;\nint n;\ndouble v,x,y;\ndouble L[330],B[330],R[330],T[330];\nint sig(double x){return (x>eps)-(x<-eps);}\ndouble cal(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nint judge(double l,double r,double x)\n{\n    if(sig(x-l)<=0) return -1;\n    else if(sig(x-r)>=0) return 1;\n    else return 0;\n}\nint ok(double qx,double qy)\n{\n    double a=g*g/4, b=g*qy-v*v, c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if(sig(d)==0) d=0;\n    if(sig(d)<0) return 0;\n    for(int dd=-1;dd<=1;dd+=2){\n        double t=(-b+dd*sqrt(d))/(2*a);\n        if(t<=0) continue;\n        t=sqrt(t);\n        double vx=qx/t, vy=(qy+g*t*t/2)/t;\n        double yt=cal(vy,x/vx);\n        if(sig(yt-y)<0) continue;\n        int flag=1;\n        for(int i=0;i<n;i++)\n        {\n            int xl=judge(B[i],T[i],cal(vy,L[i]/vx));\n            int xr=judge(B[i],T[i],cal(vy,R[i]/vx));\n            int xh=judge(L[i],R[i],vx*vy/g);\n            int yh=judge(B[i],T[i],cal(vy,vy/g));\n            if(xh==0&&yh>=0&&xl<0) flag=0;\n            if(xl*xr<=0) flag=0;\n        }\n        if(flag) return 1;\n    }\n    return 0;\n}\nint main()\n{\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n            R[i]=min(R[i],x);\n        }\n        int flag=ok(x,y);\n        for(int i=0;i<n;i++)\n        {\n            flag|=ok(L[i],T[i]);\n            flag|=ok(R[i],T[i]);\n            if(flag) break;\n        }\n        if(flag) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LTE(h,lb)?-1:(GTE(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      double rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      double rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      //cout << \"getY = \" <<vy << \" \" << R[j] << endl;\n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n\n      //cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      //cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n\n      //if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  rep(i,N) R[i] = min(R[i],X);\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n\n  cin >> N >> v0 >> X >> Y;\n  rep(i,N) cin >> L[i] >> B[i] >> R[i] >> T[i];\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\n//ÀWiX,Y)ðÊéæ¤ÈtanÌlðßApush·é\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\tif(L[i]<=X && X<=R[i])\n\t\t\tOB=min(OB,B[i]);\n\t\tL[i]=min(L[i],X);\n\t\tR[i]=min(R[i],X);\n\t}\n\t//^[QbgðÊéæ¤ÈtanÌlðßé\n\tadd(X,Y);\n\n\t//e¸_ðÆ¨éæ¤Ètanðßé\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t\tadd(L[i],B[i]);\n\t\tadd(R[i],B[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\t//^[QbgÌ^ãÉ½Æ«OBæèà¢A»à»àÍ©È¢ÍÌtanð·\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y-eps)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\t//eáQ¨ÆÕË»èð·é\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\t//XÀWªáQ¨ÌÍÍàÌÆ«ÌÅåÌ³AÅáÌá³ðßé\n\t\t\t//XÀWªáQ¨Ì¶[ÆE[ÌÆ«Ì³ðßé\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t//å«¢ûªMy\n\t\t\tif(my>My) swap(my,My);\n\t\t\t//¸_ªÜÜêéÆ«ÍA¸_ªÅåÌ³\n\t\t\tif(L[j]<center && center<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0*9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t\n\t\t\t//àµÔÂ©éÈçÌtanð·\n\t\t\tif(!(My<B[j]+eps || T[j]+eps<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//àµ`FbNðNAµ½tanª¶Ýµ½çYesðoÍµÄIíè\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-6;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\n// a<lb?±????-1 lb<=a<=ub?±????0 ub<a?±????1\n//?±????????????°??? \nint cmp(double lb,double ub,double a){\n\treturn dcmp(lb-a)?-1:dcmp(ub-a)<0?1:0;\n}\n/*????´???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(eps)?1:0);\n}*/ \n\n/*????¶???\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:(ub-a<(-eps)?1:0);\n}*/ \n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;\n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );\n         double h2 = a*rec[i].r*(rec[i].r-len );\n         if ( len/2<rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;\n         if ( rec[i].l>xx ) continue;\n         if ( h1-rec[i].b>eps && h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) return false;\n         if ( rec[i].r>xx )  continue;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");          \n}\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld t1 = (ld)l/vx;\n  ld t2 = (ld)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) flag = -1;\n  }\n  if(flag == 1){\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        else flag = 0;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        else flag = 0;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        else flag = 0;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        else flag = 0;\n      }\n    }\n    if(flag) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define MAX_N 55\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double g = 9.8;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t){\n  return vy * t - g * t * t /2;\n}\n\ndouble cmp(double lb, double ub, double a){\n  if(a < lb + EPS) return -1;\n  if(a > ub - EPS) return +1;\n  return 0;\n}\n\nbool calc_qq(double a, double b, double c, double ans[]){\n  double D =  b * b - 4 * a * c;\n  if(D < 0 && D > -EPS) D = 0;\n  if(D < 0) return false;\n  ans[0] = (-b + sqrt(D)) / (2 * a);\n  ans[1] = (-b - sqrt(D)) / (2 * a);\n  return true;\n}\n\nbool check(double qx, double qy){\n  double eq_ans[2];\n  int a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n  int exist_ans = calc_qq(a, b, c, eq_ans);\n  \n  if(!exist_ans) return false;\n  for(int k = 0; k < 2; k++){\n\n    if(eq_ans[k] <= 0) continue;\n    \n    double t = sqrt(eq_ans[k]);\n    double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n    \n    double yt = calc(vy, X / vx);\n    if(yt < Y - EPS) continue;\n\n    bool ok = true;\n    for(int i = 0; i < N; i++){\n      //豚より右にある障害物はスキップ\n      if(L[i] >= X) continue;\n      //豚と鳥の間に障害物がある場合は駄目\n      if(cmp(L[i], R[i], X) == 0 && Y <= T[i] && yt >= B[i])\n        ok = false;\n      //障害物の左右の辺を横断する場合は駄目\n      int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n      int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n      if(yL == 0 || yR == 0) ok = false;\n      //障害物の上下の辺を横断する場合は駄目\n      if(abs(yL) == 1 && yL == -yR) ok = false;\n      //障害物の底辺から入って底辺から出る場合は駄目\n      if(yL < 0 && yR < 0){\n        int xH = cmp(L[i], R[i], vx * (vy / g));\n        int yH = cmp(B[i], T[i], calc(vy, vy / g));\n        if(xH == 0 && yH >= 0) ok = false;\n      }\n    }\n    if(ok) return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d %d %d %d\", &N, &V, &X, &Y);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d %d %d\", &L[i], &B[i], &R[i], &T[i]);\n  }\n\n  for(int i = 0 ; i < N; i++){\n    R[i] = min(R[i], X);\n  }\n\n  bool ok = check(X, Y);\n  for(int i = 0; i < N; i++){\n    ok |= check(L[i], T[i]);\n    ok |= check(R[i], T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-4;\nconst double g = 9.8;\nint n,tp;\ndouble v,x,y,L[50],B[50],R[50],T[50],px[500],py[500];\n\nint cmp(double a,double b)\n{\n    if (fabs(a-b) < eps)    return 0;\n    if (a < b)  return -1;\n    return 1;\n}\n\nbool Gao(double a,double b)\n{\n    //y = a*x^2+b*x\n    double ty = a*x*x+b*x;\n    if (cmp(ty,y) < 0)  return false;\n    double tyl,tyr,xa,xb;\n    for (int i = 0; i < n; i++)\n    {\n        tyl = a*L[i]*L[i]+b*L[i];\n        tyr = a*R[i]*R[i]+b*R[i];\n        if (cmp(B[i],tyl) < 0 && cmp(tyl,T[i]) < 0)   return false;\n        if (cmp(B[i],tyr) < 0 && cmp(tyr,T[i]) < 0)   return false;\n        //if (cmp(tyl,B[i]) <= 0 && cmp(tyr,B[i]) > 0)    return false;\n        //if (cmp(tyl,T[i]) >= 0 && cmp(tyr,T[i]) < 0)    return false;\n        xa = (-b+sqrt(b*b+4*a*T[i]))/(2*a);\n        xb = (-b-sqrt(b*b+4*a*T[i]))/(2*b);\n        if (cmp(L[i],xa) < 0 && cmp(xa,R[i]) < 0)   return false;\n        if (cmp(L[i],xb) < 0 && cmp(xb,R[i]) < 0)   return false;\n        xa = (-b+sqrt(b*b+4*a*B[i]))/(2*a);\n        xb = (-b-sqrt(b*b+4*a*B[i]))/(2*b);\n        if (cmp(L[i],xa) < 0 && cmp(xa,R[i]) < 0)   return false;\n        if (cmp(L[i],xb) < 0 && cmp(xb,R[i]) < 0)   return false;\n    }\n    return true;\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y) != EOF)\n    {\n        tp = 0;\n        px[tp] = x;\n        py[tp++] = y;\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n            px[tp] = L[i];\n            py[tp++] = B[i];\n            px[tp] = L[i];\n            py[tp++] = T[i];\n            px[tp] = R[i];\n            py[tp++] = B[i];\n            px[tp] = R[i];\n            py[tp++] = T[i];\n        }\n        bool res = false;\n        for (int i = 0; i < tp; i++)\n        {\n            if (px[i] == 0)\n            {\n                if (cmp(x,0) != 0)  continue;\n                if (cmp(v*v/(2*g),y) >= 0)  res |= true;\n                continue;\n            }\n            double ta,tb;\n            tb = (px[i]*v*v+sqrt(px[i]*px[i]*v*v*v*v-px[i]*px[i]*px[i]*px[i]*g*g-2*px[i]*px[i]*py[i]*v*v*g))/(px[i]*px[i]*g);\n            ta = (py[i]-tb*px[i])/(px[i]*px[i]);\n            double tx,ty1,ty2;\n            tx = -tb/(2*ta);\n            ty1 = v*v/(2*g)-g*tx*tx/(2*v*v);\n            ty2 = ta*tx*tx+tb*tx;\n            //cout << ty1 << ' ' << ty2 << endl;\n            res |= Gao(ta,tb);\n            tb = (px[i]*v*v-sqrt(px[i]*px[i]*v*v*v*v-px[i]*px[i]*px[i]*px[i]*g*g-2*px[i]*px[i]*py[i]*v*v*g))/(px[i]*px[i]*g);\n            ta = (py[i]-tb*px[i])/(px[i]*px[i]);\n            res |= Gao(ta,tb);\n        }\n        if (res == true)    puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\nconst double eps=1e-8;\nconst double g=9.8;\nconst int NUM=60;\nint L[NUM],B[NUM],R[NUM],T[NUM];\nint n,v,x,y;\n/////////////////////////////////////////////\nint cmp(double l,double r,double now);\ndouble cal(double vy,double t);\nbool check(double qx,double qy);\n/////////////////////////////////////////////\n\nint main()\n{\n    scanf(\"%d %d %d %d\",&n,&v,&x,&y);\n    for (int i=0; i<n; i++)\n    {\n        scanf(\"%d %d %d %d\",&L[i],&B[i],&R[i],&T[i]);\n        R[i]=min(R[i],x);\n    }\n    bool ans=check(x,y);\n    for (int i=0; i<n; i++)\n    {\n        ans|=check(L[i],T[i]);\n        ans|=check(R[i],T[i]);\n    }\n    if (ans)\n        printf(\"Yes\\n\");\n    else\n        printf(\"No\\n\");\n    return 0;\n}\nint cmp(double l,double r,double now)\n{\n    return (now<l+eps)?-1:(now>r-eps)?1:0;\n}\ndouble cal(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nbool check(double qx,double qy)\n{\n    double a=g*g/4;\n    double b=g*qy-v*v;\n    double c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if (d<0&&d+eps>0)//=\n        d=0;\n    else if (d<0)\n        return false;\n    for (int i=-1; i<=1; i+=2)\n    {\n        double t=(-b+i*sqrt(d))/(2*a);\n        if (t-eps<0) continue;\n        t=sqrt(t);\n        double vy=(qy+g*t*t/2)/t;\n        double vx=qx/t;\n        double yt=cal(vy,x/vx);//能不能经过猪的上方\n        if (eps<y-yt) continue;\n        bool ok=true;\n        for (int j=0; j<n&&ok; j++)\n        {\n            if (L[j]>=x)\n                continue;\n            if (R[j]==x&&y<=T[j]&&B[j]<=yt)\n                ok=false;\n            int yl=cmp(B[j],T[j],cal(vy,L[j]/vx));\n            int yr=cmp(B[j],T[j],cal(vy,R[j]/vx));\n            int xh=cmp(L[i],R[i],vx*(vy/g));\n            int yh=cmp(B[i],T[i],cal(vy,vy/g));\n            if (xh==0&&yh>=0&&yl<0) ok=false;\n            if (yl*yr<=0)\n                ok=false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-6;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nbool is_up(double rad, double x){\n  return x < calc_x_y0(rad) / 2.0 - EPS;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPS){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  //if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << calc_y(res2, real(target)) << endl;\n  //cout << \"fir \" << equal(calc_y(res2, x), y) << endl;\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << calc_y(res2, real(target)) << endl;\n  //cout << res2 * 180.0 / M_PI << endl;\n  //cout << \"sec \" << equal(calc_y(res2, x), y) << endl;\n  if(/*equal(calc_y(res2, x), y) &&*/ calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    double y[2] = {imag(rv[i].ll), imag(rv[i].ur)};\n    if(x[0] > real(target) + EPS) continue;\n    if(calc_y(rad, x[0]) < y[0] - EPS && calc_y(rad, x[1]) > y[0] + EPS || calc_y(rad, x[0]) > y[1] + EPS && calc_y(rad, x[1]) < y[1] - EPS) return true;\n    if(calc_y(rad, x[0]) > y[0] + EPS && calc_y(rad, x[0]) < y[1] - EPS) return true;\n    if(equal(calc_y(rad, x[0]), y[0]) && is_up(rad, x[0]) || equal(calc_y(rad, x[1]), y[1]) && !is_up(rad, x[1])) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) {\n      //cout << calc_res[i] * 180.0 / M_PI << endl;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nint comp(double lb,double ub,double x){\n\tif(x<lb+eps) return -1;\n\tif(ub<x+eps) return 1;\n\treturn 0;\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<=l[i]) continue;\n\t\t\tif(r[i]>=x&&y<=u[i]&&d[i]<=ry) ok=false;\n\t\t\tint ly=comp(d[i],u[i],calcy(vy,l[i]/vx));\n\t\t\tint ry=comp(d[i],u[i],calcy(vy,r[i]/vx));\n\t\t\tint hx=comp(l[i],r[i],vy/g*vx);\n\t\t\tint hy=comp(d[i],u[i],calcy(vy,vy/g));\n\t\t\tif(hx==0&&hy>=0&&ly<0) ok=false;\n\t\t\tif(ly*ry<=0) ok=false;\n\t\t}\n\t\t// if(ok){\n\t\t// \tshow(qx);\n\t\t// \tshow(qy);\n\t\t// \tshow(vx);\n\t\t// \tshow(vy);\n\t\t// }\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\trep(i,n) r[i]=min(r[i],x);\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double inf = 1e8;\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int i = 0; i < u.size(); ++i) {\n        if(u[i] <= 0) continue;\n        vxs.push_back(sqrt(u[i]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        double vx = vxs[k];\n        double vy = sqrt(V*V - vx*vx);\n        bool flag = true;\n        for(int i = 0; i < N; ++i) {\n          if(X <= L[i]) continue;\n          vector<double> v;\n          vector<double> u;\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          {\n            double y = -g/(2*vx*vx) * L[i]*L[i] + vy/vx * L[i];\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(L[i]);\n            }\n          }\n          {\n            double y = -g/(2*vx*vx) * R[i]*R[i] + vy/vx * R[i];\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(R[i]);\n            }\n          }\n          sort(v.begin(), v.end());\n          v.erase(unique(v.begin(), v.end(), equals), v.end());\n          if(v.size() == 2) {\n            double mx = (v[0] + v[1]) / 2.0;\n            double my = -g/(2*vx*vx) * mx*mx + vy/vx * mx;\n            if(L[i]-eps < mx && mx < R[i]+eps && \n               B[i]-eps < my && my < T[i]+eps) {\n              flag = false;\n              break;\n            }\n          }\n        }\n        if(!flag) continue;\n        double py = -g/(2*vx*vx) * X*X + vy/vx * X;\n        if(equals(Y, py)) throw 0;\n        if(py < Y) continue;\n        bool ok = true;\n        for(int i = 0; i < N; ++i) {\n          if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n            ok = false;\n            break;\n          }\n        }\n        if(ok) throw 0;\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double eps = 1e-6;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble getY(double x, double vx, double vy) {\n  return -g/(2*vx*vx) * x*x + vy/vx * x;\n}\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int i = 0; i < u.size(); ++i) {\n        if(u[i] <= 0) continue;\n        vxs.push_back(sqrt(u[i]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        double vx = vxs[k];\n        double vy = sqrt(V*V - vx*vx);\n        bool flag = true;\n        for(int i = 0; i < N; ++i) {\n          if(X <= L[i]) continue;\n          vector<double> v;\n          vector<double> u;\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n          for(int j = 0; j < u.size(); ++j) {\n            if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n              v.push_back(u[j]);\n            }\n          }\n          {\n            double y = getY(L[i], vx, vy);\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(L[i]);\n            }\n          }\n          {\n            double y = getY(R[i], vx, vy);\n            if(B[i]-eps < y && y < T[i]+eps) {\n              v.push_back(R[i]);\n            }\n          }\n          sort(v.begin(), v.end());\n          v.erase(unique(v.begin(), v.end(), equals), v.end());\n          if(v.size() > 2) {\n            flag = false;\n            break;\n          }\n          if(v.size() == 2) {\n            double mx = (v[0] + v[1]) / 2.0;\n            double my = getY(mx, vx, vy);\n            if(L[i]+eps < mx && mx < R[i]-eps && \n               B[i]+eps < my && my < T[i]-eps) {\n              flag = false;\n              break;\n            }\n          }\n        }\n        if(!flag) continue;\n        double py = getY(X, vx, vy);\n        if(equals(Y, py)) throw 0;\n        if(py < Y) continue;\n        bool ok = true;\n        for(int i = 0; i < N; ++i) {\n          if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n            ok = false;\n            break;\n          }\n        }\n        if(ok) throw 0;\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst double G = 9.8;\nconst double EPS = 1e-6;\nconst int SIZE = 60;\n\nint N;\ndouble V, X, Y, vx, vy;\ndouble L[SIZE], R[SIZE], T[SIZE], B[SIZE] ;\n\ndouble getY( double x )\n{\n    double t = x/vx;\n    return vy*t-0.5*G*t*t;\n}\n\nbool check()\n{\n    double pigx = X, pigy = getY(pigx);\n    if ( pigy < Y ) return false;\n\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( L[i] < X )\n        {\n            double l = L[i], r = R[i];\n            double y1 = getY(l), y2 = getY(r) ;\n            if ( y1 >= B[i] && y1 <= T[i] )\n                return false;\n            if ( y2 >= B[i] && y2 <= T[i] )\n                return false;\n            if ( y1 >= B[i] && y2 <= B[i] )\n                return false;\n            if ( y1 <= B[i] && y2 >= B[i] )\n                return false;\n            if ( y1 >= T[i] && y2 <= T[i] )\n                return false;\n            if ( y1 <= T[i] && y2 >= T[i] )\n                return false;\n        }\n        if ( L[i] <= X && X <= R[i] )\n        {\n            if ( B[i] <= Y && Y <= T[i] )\n                return false;\n            if ( B[i] <= Y && B[i] <= pigy )\n                return false;\n        }\n    }\n    return true;\n}\n\nbool solve( )\n{\n    for ( vx = EPS; vx < V; vx += EPS )\n    {\n        vy = sqrt( V*V-vx*vx );\n        if ( check() ) return true;\n    }\n    return false;\n}\n\nint main()\n{\n//    freopen(\"test.txt\",\"r\", stdin);\n    while ( scanf(\"%d%lf%lf%lf\", &N, &V, &X, &Y) != EOF )\n    {\n        for ( int i = 0; i < N; i ++ )\n            scanf( \"%lf%lf%lf%lf\", &L[i], &B[i], &R[i], &T[i] );\n\n        if ( solve() ) puts(\"Yes\");\n        else puts(\"No\");\n\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<list>\n\n#define MAXN 51\n#define MAXX 301\n#define g 9.8\n\nshort n,v,x,y,i,j,k;\nshort l,B,r,T;\ndouble a,b,c;\ndouble t1,t2;\ndouble vx,vy;\ndouble t;\nstd::list<double>ts;\nstd::list<double>::iterator it;\n\nbool mat[MAXX][MAXX];\n\nint main()\n{\n    scanf(\"%hd %hd %hd %hd\",&n,&v,&x,&y);\n    a=0.25*g*g;\n    b=g*y-v*v;\n    c=x*x+y*y;\n    t1=(-b+sqrt(b*b-4*a*c))/(2*a);\n    t2=(-b-sqrt(b*b-4*a*c))/(2*a);\n    ts.clear();\n    if(t1>=0)\n        ts.push_back(sqrt(t1));\n    if(t1>=0)\n        ts.push_back(sqrt(t2));\n    for(i=0;i<MAXX;++i)\n        std::fill(mat[i],mat[i]+MAXX,false);\n    for(i=0;i<n;++i)\n    {\n        scanf(\"%hd %hd %hd %hd\",&l,&B,&r,&T);\n        for(k=l;k<r;++k)\n            for(j=B;j<T;++j)\n                mat[k][j]=true;\n    }\n    for(it=ts.begin();it!=ts.end();++it)\n    {\n        vx=x/(*it);\n        vy=y/(*it)+0.5*g*(*it);\n        for(t=0;t<=(*it);t+=0.00001)\n            if(mat[(int)(vx*t)][(int)(vy*t-0.5*g*t*t)])\n                break;\n        if(t<=(*it))\n            continue;\n        else\n        {\n            puts(\"Yes\");\n            return 0;\n        }\n    }\n    puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X =< bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, vx* vy / g);\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-8\nusing namespace std;\nconst int maxn = 100;\nint V,n,X,Y;\ndouble vx,vy;\ndouble g=9.8;\nint L[maxn],B[maxn],R[maxn],T[maxn];\ndouble calc(double t)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double l,double h,double x)\n{\n    return x<l+eps?-1:x>h-eps?1:0;\n}\nbool f(double qx,double qy)\n{\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double d=b*b-4*a*c;\n    if(d<0 && d>-eps) d=0;\n    if(d<0) return false;\n    for(int tmp=-1; tmp<=1; tmp+=2)\n    {\n        double t=(-b+tmp*sqrt(d))/(2*a);\n        if(t<=0) continue;\n        t=sqrt(t);\n        vx=qx/t;\n        vy=(qy+g*t*t/2)/t;\n        double qyy=calc(X/vx);\n        if(qyy<Y-eps)\n        {\n            continue;\n        }\n        bool ok=true;\n        for(int i=0; i<n; i++)\n        {\n            if(L[i]>=X) continue;\n            if(R[i]>=X && Y<=T[i] && B[i]<=qyy) ok=false;\n            int yl=cmp(B[i],T[i],calc(L[i]/vx));\n            int yr=cmp(B[i],T[i],calc(R[i]/vx));\n            int xh=cmp(L[i],R[i],vx*vy/g);\n            int yh=cmp(B[i],T[i],calc(vy/g));\n\n            if(xh==0 && yh>=0 && yl<0) ok=false;\n            if(yl*yr<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\nint main()\n{\n    cin>>n>>V>>X>>Y;\n    for(int i=0; i<n; i++) cin>>L[i]>>B[i]>>R[i]>>T[i];\n//    for(int i=0;i<n;i++) R[i]=min(R[i],X);\n    bool ans = f(X,Y);\n\n    for(int i=0; i<n; i++)\n    {\n        ans |=f(L[i],T[i]);\n        ans |=f(R[i],T[i]);\n    }\n    puts(ans?\"Yes\":\"No\");\n    return 0;\n}\n/*\n0 7 3 1\n\n1 7 3 1\n1 1 2 2\n\n1 7 2 2\n0 1 1 2\n1 1 2 2\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstatic const double EPS = 1e-10;\nstatic const int MAX_N = 50;\nstatic const double G = 9.8;\n\nint N;\ndouble V, X, Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nint cmp(double a, double b, double x) {\n  if (x < a + EPS) return -1;\n  if (x > b - EPS) return 1;\n  return 0;\n}\n\nbool check(double tx, double ty) {\n  double a = (1.0 / 4.0) * G * G;\n  double b = G * ty - V * V;\n  double c = tx * tx + ty * ty;\n\n  double D = b * b - 4.0 * a * c;\n  if (abs(D) <= EPS) D = 0.0;\n  if (D < 0) return false;\n  for (int d = -1; d <= 1; d+=2) {\n    double t_squared = (-b + d * sqrt(D)) / (2.0 * a);\n    if (t_squared <= 0) continue;\n\n    // calc initial velocity to hit (tx, ty)\n    double t = sqrt(t_squared);\n    double vx = tx / t;\n    double vy = (ty + 0.5 * G * t * t) / t;\n\n    // check if the course is beyond pig\n    double pt = X / vx;\n    double py = vy * pt - 0.5 * G * pt * pt;\n    if (py < Y) continue;\n\n    // check if the course is clear\n    bool isClear = true;\n    for (int i = 0; i < N; i++) {\n      if (L[i] >= X) continue;\n      if (R[i] >= X && T[i] >= Y && B[i] <= py) {\n        isClear = false;\n        break;\n      }\n      double lt = L[i] / vx;\n      double ly = vy * lt - 0.5 * G * lt * lt;\n      double rt = R[i] / vx;\n      double ry = vy * rt - 0.5 * G * rt * rt;\n      int posL = cmp(B[i], T[i], ly);\n      int posR = cmp(B[i], T[i], ry);\n      if (posL * posR <= 0) {\n        isClear = false;\n        break;\n      }\n\n      double ht = vy / G;\n      int posX_high = cmp(L[i], R[i], vx * ht);\n      double hy = vy * ht - 0.5 * G * ht * ht;\n      int posH = cmp(B[i], T[i], hy);\n      if (posX_high == 0 && posH >= 0 && posL < 0) {\n        isClear = false;\n        break;\n      }\n    }\n    if (isClear) return true;\n  }\n  return false;\n}\n\nbool solve() {\n  if (check(X, Y)) return true;\n  for (int i = 0; i < N; i++) {\n    if (check(L[i], T[i]) || check(R[i], T[i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> V >> X >> Y;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n\n  bool isOK = solve();\n  cout << (isOK ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-6;\n\nclass Obstacle {\npublic:\n  int left_x, bottom_y, right_x, top_y;\n  Obstacle(int left_x, int bottom_y, int right_x, int top_y)\n    : left_x(left_x), bottom_y(bottom_y), right_x(right_x), top_y(top_y) {}\n};\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool is_inside(double lower, double upper,double pos){\n  if(lower > pos) return false;\n  if(upper < pos) return false;\n  return true;\n}\n\nbool can_drop(const vector<Obstacle>& obstacles,double sx, double sy,double gx,double gy){\n  if(sy < gy) return false;\n\n  for(int i = 0; i < obstacles.size(); i++){\n    Line l1(Point(obstacles[i].left_x,obstacles[i].bottom_y),\n            Point(obstacles[i].right_x,obstacles[i].bottom_y));\n    Line l2(Point(sx,sy),Point(gx,gy));\n    if(intersectSS(l1,l2)) return false;\n  }\n  return true;\n}\n\nconst static double g = 9.8;\n\nint main(){\n  int num_of_obstacles;\n  int v;\n  int gx,gy;\n  while(~scanf(\"%d %d %d %d\",&num_of_obstacles,&v,&gx,&gy)){\n    vector<Obstacle> obstacles;\n    for(int i = 0; i < num_of_obstacles; i++){\n      int left_x, bottom_y, right_x, top_y;\n      scanf(\"%d %d %d %d\",&left_x, &bottom_y, &right_x, &top_y);\n      obstacles.push_back(Obstacle(left_x,bottom_y,right_x,top_y));\n    }\n\n    string res = \"No\";\n    for(double rad = 0; rad <= M_PI / 2.0; rad += EPS){\n      bool isok = true;\n      double vx = (double)v * cos(rad);\n      double vy = (double)v * sin(rad);\n\n      double gtime = (double)gx / vx;\n      double y = vy * gtime - g * gtime * gtime * 0.5;\n      if(!can_drop(obstacles,gx,y,gx,gy)){\n        continue;\n      }\n\n      for(int i = 0; i < num_of_obstacles; i++){\n        if(obstacles[i].right_x > gx) continue;\n\n        double t1 = (double)obstacles[i].left_x / vx;\n        double t2 = (double)obstacles[i].right_x / vx;\n\n        double y1 = vy * t1 - g * t1 * t1 * 0.5;\n        double y2 = vy * t2 - g * t2 * t2 * 0.5;\n        if(is_inside(obstacles[i].bottom_y,obstacles[i].top_y,y1)\n           || is_inside(obstacles[i].bottom_y,obstacles[i].top_y,y2)){\n          isok = false;\n          break;\n        }\n      }\n      if(isok){\n        res = \"Yes\";\n        break;\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-10;\nconst double g = 9.8;\nconst int MAXN = 55;\ndouble L[MAXN],R[MAXN],B[MAXN],T[MAXN];\ndouble N,V,X,Y;\n// 计算以Vy的速度竖直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n// a相对于l和r的位置\nint cmp(double l, double r, double a)// 注意判断大小的时候的误差处理\n{\n    if(a < l + eps) return -1;//if(a <= l)\n    if(a > r - eps) return 1;//if(a >= r)\n    return 0;\n}\n// 判断当射出路径经过点（qx,qy）时，卵是否能击中猪\n//设初速度在x方向和y方向的分量为vx和vy，设通过（qx，qy）的时间为t\n//求解联立方程式vx^2 + vy^2 = V^2 , vx * t = qx, vy * t - g * t^2 * 1/2 = qy\nbool check(double qx, double qy)\n{\n    double a = g * g / 4, b = g * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -eps) D = 0; //误差处理\n    if(D < 0) return false;\n    for(int d=-1;d<=1;d+=2)\n    {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);//解出来的是t^2\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t,vy = (qy + g * t * t / 2) / t;\n        //判断是否通过猪的正上方\n        double yt = calc(vy, X / vx);\n        if(yt < Y - eps) continue; //yt < Y\n        bool flag = 1;\n        for(int i=0;i<N;i++)\n        {\n            if(L[i] >= X) continue;\n            //判断在猪正上方的鸟和猪之间是否有障碍物\n            if(R[i] == X && Y <= T[i] && B[i] <= yt)// 由于预处理，这里已经保证了L[i] <= X <= R[i]\n            flag = false;\n            //判断在飞到猪正上方之前是否会撞到障碍物\n            int yl = cmp(B[i], T[i], calc(vy, L[i] / vx));//在障碍物左边缘时的相对位置\n            int yr = cmp(B[i], T[i], calc(vy, R[i] / vx));//在障碍物右边缘时的相对位置\n            int xh = cmp(L[i], R[i], vx * vy / g);//最高点的相对位置\n            int yh = cmp(B[i], T[i], calc(vy, vy / g));\n            if(xh == 0 && yh >= 0 && yl < 0) flag = false;\n            if(yl * yr <= 0) flag = false;\n        }\n        if(flag) return 1;\n    }\n    return 0;\n}\nint main()\n{\n    cin >> N >> V >> X >> Y;\n    for(int i=0;i<N;i++)\n    cin >> L[i] >> B[i] >> R[i] >> T[i], R[i] = min(R[i], X);//预处理，截掉猪以右的障碍物\n    bool flag = check(X, Y);//直接撞上猪的情况\n    for(int i=0;i<N;i++)\n    {\n        flag |= check(L[i], T[i]);//经过障碍物左上角的情况\n        flag |= check(R[i], T[i]);//经过障碍物右上角的情况\n    }\n    puts(flag ? \"Yes\" : \"No\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define EPS 1e-10\nusing namespace std;\nconst double g = 9.8;\nint n, v, x, y;\nint L[55], B[55], R[55], T[55];\ndouble calc(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\nbool check(double qx, double qy) {\n    double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -EPS) D = 0;\n    if (D < 0) return false;\n    for (int d = -1; d <= 1; d += 2) {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        double yt=calc(vy, x / vx);\n        if (yt < y - EPS) continue;\n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y <= T[i] && B[i] <= yt) ok = false;\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\nint main() {\n    scanf(\"%d %d %d %d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", L + i, B + i, R + i, T + i);\n        R[i] = min(R[i], x);\n    }\n    bool ok = check(x, y);\n    for (int i = 0; i < n; ++i) {\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int Maxn=60;\n\nconst double g=9.8;\nconst double eps= 1e-8;\n\nint N; double V,X,Y;\n\ndouble L[Maxn],B[Maxn],R[Maxn],T[Maxn];\n\ndouble Calcy(double vy,double t){return vy*t-0.5*g*t*t;}\ndouble Calcx(double vx,double t){return vx*t;}\n\nint cmp(double lb,double ub,double a)\n{\n  return a<lb ? -1 : a>ub-eps ? 1 : 0;\n}\n\nbool Check(double x,double y) // ????????????(x,y) \n{\n  double a=0.25*g*g; double b=g*y-V*V; double c=x*x+y*y;\n  double delta= b*b-4*a*c;\n  if(delta < 0) return 0;\n  for(int op=-1;op<=1;op+=2)\n  {\n    double t=sqrt((-b+sqrt(delta)*op)/(2.0*a));\n    if(t<=0) continue;\n    double vx=x/t; double vy=(y+0.5*g*t*t)/t; //?????????\n    double yt=Calcy(vy,X/vx); //???????¨?????????????\n   \tif(yt < Y-eps) continue;\n   \tbool ok=1;\n   \tfor(int i=1;i<=N;i++)\n   \t{\n   \t  if(L[i] >= X) continue;\n   \t  if(R[i] == X && yt >= T[i] && B[i] >= Y){ok=0; break;}\n   \t  int yL=cmp(B[i],T[i],Calcy(vy,L[i]/vx));\n   \t  int yR=cmp(B[i],T[i],Calcy(vy,R[i]/vx));\n   \t  int xH=cmp(L[i],R[i],Calcx(vx,vy/g));\n   \t  int yH=cmp(B[i],T[i],Calcy(vy,vy/g));\n   \t  if( xH == 0 && yH >= 0){ok=0; break;}\n   \t  if(yL * yR <=0){ok=0; break;}\n   \t}\n   \tif(ok) return 1;\n  } \n  return 0;\n}\n\nint main()\n{\n\n  scanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y);\n  for(int i=1;i<=N;i++) scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n\n  for(int i=1;i<=N;i++) R[i]=min(R[i],X);\n\n  bool ok=0;\n  ok=Check(X,Y);\n\n  for(int i=1;i<=N;i++)\n  {\n    ok|=Check(L[i],T[i]);\n    ok|=Check(R[i],T[i]);\n  }\n\n  puts(ok ? \"Yes\" : \"No\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\n\nconst double EPS = 1e-10;\nconst int MAX_N = 55;\nconst double g = 9.8;\n\n\nstruct Para\n{\n\tint t;\n\tdouble a[2];\n\tdouble b[2];\n};\n\n// a 与 b 近似为相反数时返回 0.0 , 否则返回 a + b\ndouble add(double a, double b);\n\nstruct P\n{\n\tdouble x;\n\tdouble y;\n\n\t//定义构造函数之前, 需要先定义一个空的构造函数\n\tP() { x = 0; y = 0; }\n\n\t//构造函数\n\tP(double x, double y) :x(x), y(y) {}\n\n\t//加法\n\tP operator + (P p)\n\t{\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\n\t//加法\n\tP operator - (P p)\n\t{\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\n\t//数乘\n\tP operator * (double d)\n\t{\n\t\treturn P(x * d, y * d);\n\t}\n\n\t//点积\n\tdouble dot(P p)\n\t{\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\n\t//叉乘\n\tdouble det(P p)\n\t{\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n\nbool on_seg(P p1, P p2, P q);\nP intersection(P p1, P p2, P q1, P q2);\n\n\nP rectp[MAX_N][4];\n\nint N, V, X, Y, am;\n\nPara getpara(P p, int v);\n\nbool check(Para q);\n\nint cmp(double lb, double rb, double a);\n\nint main()\n{\n\tint L, B, R, T;\n\n\tcin >> N >> V >> X >> Y;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> L >> B >> R >> T;\n\n\t\tif (R <= X && T >= Y)\n\t\t{\n\t\t\trectp[am][0].x = L;\n\t\t\trectp[am][1].x = R;\n\t\t\trectp[am][2].x = L;\n\t\t\trectp[am][3].x = R;\n\n\t\t\trectp[am][0].y = T;\n\t\t\trectp[am][1].y = T;\n\t\t\trectp[am][2].y = B;\n\t\t\trectp[am][3].y = B;\n\n\t\t\tam++;\n\t\t}\n\t}\n\n\tP t;\n\tt.x = X;\n\tt.y = Y;\n\n\tbool ans = check(getpara(t, V));\n\n\tif (!ans)\n\t{\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tans = check(getpara(rectp[i][0], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tans = check(getpara(rectp[i][1], V));\n\t\t\tif (ans)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ans)\n\t{\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t{\n\t\tcout << \"No\\n\";\n\t}\n\n\treturn 0;\n}\n\ndouble add(double a, double b)\n{\n\tif (fabs(a + b) > EPS * (fabs(a) + fabs(b)))\n\t{\n\t\treturn a + b;\n\t}\n\treturn 0.0;\n}\n\nPara getpara(P p, int v)\n{\n\tPara res;\n\n\tdouble D = (double)v * v * ((double)v * v - 2 * g * p.y) - g * g * p.x * p.x;\n\n\tif (D > 0)\n\t{\n\t\tres.t = 2;\n\n\t\tD = sqrt(D);\n\t\tres.b[0] = ((double)v * v + D) / (g * p.x);\n\t\tres.b[1] = ((double)v * v - D) / (g * p.x);\n\n\t\tres.a[0] = ((double)p.y - res.b[0] * p.x) / (p.x * p.x);\n\t\tres.a[1] = ((double)p.y - res.b[1] * p.x) / (p.x * p.x);\n\t}\n\telse\n\t{\n\t\tres.t = 0;\n\t}\n\n\treturn res;\n}\n\nbool check(Para q)\n{\n\tbool ok;\n\tP cross;\n\n\tfor (int p = 0; p < q.t; p++)\n\t{\n\t\tok = true;\n\n\t\tdouble tar = q.a[p] * X * X + q.b[p] * X;\n\n\t\tif (tar < Y - EPS)\n\t\t{\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < am; i++)\n\t\t{\n\t\t\tcross.x = rectp[i][0].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X && cmp(rectp[i][2].y, rectp[i][0].y, cross.y) == 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcross.x = rectp[i][1].x;\n\t\t\tcross.y = q.a[p] * cross.x * cross.x + q.b[p] * cross.x;\n\t\t\tif (cross.x < X && cmp(rectp[i][3].y, rectp[i][1].y, cross.y) == 0)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdouble D = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][0].y;\n\t\t\tif (D >= 0)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][0].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X && cmp(rectp[i][0].x, rectp[i][1].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tD = q.b[p] * q.b[p] + 4 * q.a[p] * rectp[i][2].y;\n\t\t\tif (D >= 0)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tcross.y = rectp[i][2].y;\n\n\t\t\t\tcross.x = -(q.b[p] + D) / (2 * q.a[p]);\n\t\t\t\tif (cross.x < X && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcross.x = cross.x + D / q.a[p];\n\t\t\t\tif (cross.x < X && cmp(rectp[i][2].x, rectp[i][3].x, cross.x) == 0)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectp[i][0].x <= X && rectp[i][1].x >= X && tar >= rectp[i][2].y + EPS)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok)\n\t\t{\n\t\t\treturn ok;\n\t\t}\n\t}\n\treturn false;\n}\n\nint cmp(double lb, double rb, double a)\n{\n\tif (a < lb + EPS)\n\t{\n\t\treturn -1;\n\t}\n\telse if (a > rb - EPS)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nbool on_seg(P p1, P p2, P q)\n{\n\treturn ((p1 - q).det(p2 - q) == 0.0) && ((p1 - q).dot(p2 - q) <= 0);\n}\n\nP intersection(P p1, P p2, P q1, P q2)\n{\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst int N=100;\nconst int MAXN=1000000;\nconst double pi=acos(-1);\nconst double gg=9.8;\nint n;\ndouble v,x,y,l[N],b[N],r[N],t[N],B,A,rr[N];\nint work(double x,double y)\n{\n\tdouble yy=A * x * x + B * x;\n\t//if (fabs(yy-y) < eps) return 0;\n\tif (y > yy) return 1;\n\treturn -1;\n}\nbool check(double thi)\n{\n\tA=-gg/(2 * v * v * cos(thi) * cos(thi));\n\tB=tan(thi);\n\tdouble MAX_top=-B*B/(4 *A);\n\tdouble mid=-B/(2 * A);\n\tfor(int i=1;i<=n;i++)\n\tif (l[i] < x+eps)\n\t{\n\t\t//rr[i]=min(r[i],x);\n\t\trr[i]=r[i];\n\t\tif (work(l[i],t[i]) * work(rr[i],t[i]) <0) return 0;\n\t\tif (work(l[i],b[i]) * work(rr[i],b[i]) <0) return 0;\n\t\tif (work(l[i],t[i]) * work(l[i],b[i]) <0) return 0;\n\t\tif (r[i]<x+ eps && work(r[i],t[i]) * work(r[i],b[i]) <0) return 0;\n\t\tif (work(l[i],b[i])>0 && work(rr[i],b[i])>0 && MAX_top > b[i]-eps && (mid>l[i] && mid<rr[i])) return 0;\n\t}\n\tif (work(x,y) > 0) return 0;\n\tdouble tmp=A * x * x + B * x;\n\tfor(int i=1;i<=n;i++)\n\t\tif (l[i]< x-eps && r[i]> x+eps)\n\t\t{\n\t\t\tif (t[i] < tmp-eps && t[i]>y+eps) return 0;\n\t\t\tif (b[i] < tmp-eps && b[i]>y+eps) return 0;\n\t\t}\n\treturn 1;\n}\nint main()\n{\n\tcin>>n>>v>>x>>y;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n\tfor(int i=1;i<MAXN;i++)\n\t{\n\t\tdouble thi=pi / 2 * i / MAXN;\n\t\tif (check(thi))\n\t\t{\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double eps = 1e-10;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble getY(double x, double vx, double vy) {\n  return -g/(2*vx*vx) * x*x + vy/vx * x;\n}\n\nbool isHit(int i, double vx, double vy) {\n  vector<double> v;\n  vector<double> u;\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  {\n    double y = getY(L[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(L[i]);\n    }\n  }\n  {\n    double y = getY(R[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(R[i]);\n    }\n  }\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end(), equals), v.end());\n  if(v.size() > 2) {\n    return true;\n  }\n  if(v.size() == 2) {\n    double mx = (v[0] + v[1]) / 2.0;\n    double my = getY(mx, vx, vy);\n    if(L[i]+eps < mx && mx < R[i]-eps && \n       B[i]+eps < my && my < T[i]-eps) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int i = 0; i < u.size(); ++i) {\n        if(u[i] <= 0) continue;\n        vxs.push_back(sqrt(u[i]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        const double vx = vxs[k];\n        const double vy = sqrt(V*V - vx*vx);\n\n        {\n          bool flag = true;\n          for(int i = 0; i < N; ++i) {\n            if(X < L[i]) continue;\n            if(isHit(i, vx, vy)) {\n              flag = false;\n              break;\n            }\n          }\n          if(!flag) continue;\n        }\n\n        {\n          double py = getY(X, vx, vy);\n          if(equals(Y, py)) throw 0;\n          if(py < Y) continue;\n          bool ok = true;\n          for(int i = 0; i < N; ++i) {\n            if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n              ok = false;\n              break;\n            }\n          }\n          if(ok) throw 0;\n        }\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-3;\nconst double g=9.8;\nconst int Max=100;\ndouble L[Max],R[Max],B[Max],T[Max];\ndouble N,V,X,Y;\ndouble getHy(double vy,double t)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double l,double r,double a)\n{\n    if(a<l+eps)\n    {\n        return -1;\n    }\n    if(a>r-eps)\n    {\n        return 1;\n    }\n    return 0;\n}\nint check(double qx,double qy)\n{\n    double a=g*g/4;\n    double b=g*qy-V*V;\n    double c=qx*qx+qy*qy;\n    double det=b*b-4*a*c;\n    if(det<0&&det>-eps)\n    {\n        det=0;\n    }\n    if(det<0)\n    {\n        return 0;\n    }\n    for(int d=-1;d<=1;d+=2)\n    {\n        double t2=(-b+d*sqrt(det))/(2.0*a);\n        if(t2<=0)\n        {\n            continue;\n        }\n        double t=sqrt(t2);\n        double vx=qx/t;\n        double vy=(qy+g*t*t/2.0)/t;\n        double yt=getHy(vy,X/vx);\n        if(yt<Y-eps)\n        {\n            continue;\n        }\n        int flag=1;\n        for(int i=1;i<=N;i++)\n        {\n            if(L[i]>=X)\n            {\n                continue;\n            }\n            if(R[i]==X&&Y<=T[i]&&B[i]<=yt)\n            {\n                flag=0;\n            }\n            int yl=cmp(B[i],T[i],getHy(vy,L[i]/vx));\n            int yr=cmp(B[i],T[i],getHy(vy,R[i]/vx));\n            int xh=cmp(L[i],R[i],vx*vy/g);\n            int yh=cmp(B[i],T[i],getHy(vy,vy/g));\n            if(xh==0&&yh>=0&&yl<0)\n            {\n                flag=0;\n            }\n            if(yl*yr<=0)\n            {\n                flag=0;\n            }\n        }\n        if(flag)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}\nint main()\n{\n    scanf(\"%lf%lf%lf%lf\",&N,&V,&X,&Y);\n    for(int i=1;i<=N;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        R[i]=min(R[i],X);\n    }\n    int flag1=check(X,Y);\n    for(int i=1;i<=N;i++)\n    {\n        int flag2;\n        flag2=check(L[i],T[i]);\n        if(flag2==1)\n        {\n            flag1=1;\n        }\n        flag2=check(R[i],T[i]);\n        if(flag2==1)\n        {\n            flag1=1;\n        }\n    }\n    if(flag1==1)\n    {\n        printf(\"Yes\\n\");\n    }\n    else\n    {\n        printf(\"No\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Yzcstc\n * Created Time:  2014/9/29 10:12:41\n * File Name: aoj2308.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define M0(x)  memset(x, 0, sizeof(x))\n#define Inf  0x7fffffff\n#define MP make_pair\n#define PB push_back\n#define eps 1e-12\n#define g 9.8\n#define N 100000\n#define pi acos(-1.0)\ntypedef long long LL;\nusing namespace std;\ninline int sgn(const double &x){\n    return (x > eps) - (x < -eps);\n}\nstruct point{\n    double x, y;\n    point(){}\n    point(double _x, double _y):x(_x), y(_y){}\n    void input(){\n         scanf(\"%lf%lf\", &x, &y);\n    }\n    point operator-(const point& p) const{\n          return point(x - p.x, y - p.y);      \n    }\n} p[550][2];\nint n;\ndouble v, x, y, vx, vy, top, topy;\n\nvoid init(){\n     for (int i = 0; i < n; ++i)\n         p[i][0].input(), p[i][1].input();\n}\n\nint gao(int i){\n     point p2 = point(p[i][0].x, p[i][1].y);\n     point p4 = point(p[i][1].x, p[i][0].y);\n     double x1, y1, x2, t;\n     if (sgn(p2.x - x) <= 0){\n            double t = p2.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) <= 0 && sgn(y1 - p4.y) >= 0) return 0;\n     }\n     if (sgn(p4.x - x) <= 0){\n            double t = p4.x / vx;\n            y1 = vy * t - .5 * g * t * t;\n            if (sgn(y1 - p2.y) <= 0 && sgn(y1 - p4.y) >= 0) return 0;\n     }\n     double d;\n     if (sgn(p2.y - top) <= 0){\n           d = vy * vy - 2 * g * p2.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) > 0 && sgn(x1 - x) < 0){\n                  if (sgn(x1 - p2.x) >= 0 && sgn(x1 - p4.x) <= 0) return 0;\n           }\n           if (sgn(x2) > 0 && sgn(x2 - x) < 0){\n                  if (sgn(x2 - p2.x) >= 0 && sgn(x2 - p4.x) <= 0) return 0;\n           }\n     }\n     if (sgn(p4.y - top) <= 0){\n           d = vy * vy - 2 * g * p4.y;\n           x1 = (-vy - sqrt(d)) / (-g), x2 = (-vy + sqrt(d)) / (-g);\n           if (sgn(x1) >= 0 && sgn(x1 - x) <= 0){\n                  if (sgn(x1 - p2.x) >= 0 && sgn(x1 - p4.x) <= 0) return 0;\n           }\n           if (sgn(x2) >= 0 && sgn(x2 - x) <= 0){\n                  if (sgn(x2 - p2.x) >= 0 && sgn(x2 - p4.x) <= 0) return 0;\n           }\n     }\n     return 1;\n}\n\nint check(double ang){\n     vx = v * cos(ang), vy = v * sin(ang);\n     double t = x / vx;\n     double hy = vy * t - .5 * g * t * t;\n     top = vy * vy / 2 / g;\n     if (sgn(hy - y) < 0 || sgn(hy - topy) >= 0) return 0;\n     for (int i = 0; i < n; ++i){\n             if (!gao(i)) return 0;\n     } \n     return 1;\n}\n\nint solve(){\n     double EPS = 1e-6;\n     double ang = 0;\n     topy = 1e50;\n     for (int i = 0; i < n; ++i) if (sgn(p[i][0].x - x) <= 0 && sgn(p[i][1].x - x) >= 0) {\n              if (sgn(p[i][0].y - y) >= 0)\n                      topy = min(topy, p[i][0].y);                  \n              if (sgn(p[i][1].y - y) >= 0)\n                      topy = min(topy, p[i][1].y); \n     }\n     for (int i = 0;; ++i){\n           if (check(ang)) return 1;\n           ang += EPS;\n           if (ang > pi/2) break;\n     }\n     return 0;\n}\n\nint main(){\n//    freopen(\"a.in\", \"r\", stdin);\n//    freopen(\"a.out\", \"w\", stdout);\n    while (scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y) != EOF){\n            init();\n            solve() ? puts(\"Yes\") : puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-10\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double g = 9.8; // Gravity\nconst double EPS = 1e-8;\nconst double INF = 1e+9;\n\nstruct Rect{\n  P ll, ur; // low_left, up_right\n  P p[4];\n  Rect(P ll=P(), P ur=P()):ll(ll),ur(ur){\n    p[0] = ll;\n    p[1] = P(real(ll), imag(ur));\n    p[2] = ur;\n    p[3] = P(real(ur), imag(ll));\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\n\nint n;\ndouble v;\nP target;\nvector<Rect> rv;\n\ndouble calc_y(double rad, double x){\n  return -g / (2.0 * v*v * cos(rad)*cos(rad)) * x*x + tan(rad) * x;\n}\n\n// if y == 0, calc x\ndouble calc_x_y0(double rad){\n  double a = -g / (2.0 * v*v * cos(rad)*cos(rad));\n  double b = tan(rad);\n  return -b / a;\n}\n\nbool is_up(double rad, double x){\n  return x < calc_x_y0(rad) / 2.0 - EPS;\n}\n\nvector<double> calc_rad(double x, double y){\n  vector<double> res;\n  double le = 0, mid1, mid2, ri = M_PI / 2.0 - EPS, res1, res2;\n\n  while(ri - le > EPS){\n    mid1 = (le * 2.0 + ri) / 3.0;\n    mid2 = (le + ri * 2.0) / 3.0;\n    if(calc_y(le, x) < calc_y(mid1, x) && calc_y(mid1, x) < calc_y(mid2, x)) le = mid1;\n    else ri = mid2;\n  }\n  res1 = (ri + le) / 2.0;\n\n  //cout << res1*180.0/M_PI << ' ' << calc_y(res1, x) << \", \" << y << endl;\n  if(calc_y(res1, x) < y - EPS) return res;\n\n  le = 0, ri = res1;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) ri = mid1;\n    else le = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << \"fir \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  le = res1, ri = M_PI / 2.0 - EPS;\n  while(ri - le > EPS){\n    mid1 = (le + ri) / 2.0;\n    if(calc_y(mid1, x) > y) le = mid1;\n    else ri = mid1;\n  }\n  res2 = (ri + le) / 2.0;\n  //cout << res2 * 180.0 / M_PI << endl;\n  //cout << \"sec \" << equal(calc_y(res2, x), y) << endl;\n  if(equal(calc_y(res2, x), y) && calc_y(res2, real(target)) >= imag(target) - EPS) res.push_back(res2);\n\n  return res;\n}\n\nbool hit_rect(double rad){\n  for(int i=0;i<n;i++){\n    double x[2] = {real(rv[i].ll), min(real(target), real(rv[i].ur))};\n    double y[2] = {imag(rv[i].ll), imag(rv[i].ur)};\n    if(x[0] > real(target) + EPS) continue;\n    if(calc_y(rad, x[0]) < y[0] - EPS && calc_y(rad, x[1]) > y[0] + EPS || calc_y(rad, x[0]) > y[1] + EPS && calc_y(rad, x[1]) < y[1] - EPS) return true;\n    if(calc_y(rad, x[0]) > y[0] + EPS && calc_y(rad, x[0]) < y[1] - EPS) return true;\n    if(equal(calc_y(rad, x[0]), y[0]) && is_up(rad, x[0]) || equal(calc_y(rad, x[1]), y[1]) && !is_up(rad, x[1])) return true;\n  }\n  return false;\n}\n\nbool solve(){\n  vector<double> calc_res;\n\n  //if(calc_x_y0(M_PI/4.0) < imag(target) - EPS) return false;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=3;j++){\n      vector<double> cr = calc_rad(real(rv[i].p[j]), imag(rv[i].p[j]));\n      for(int k=0;k<cr.size();k++){\n        calc_res.push_back(cr[k]);\n      }\n    }\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n  vector<double> cr = calc_rad(real(target), imag(target));\n  for(int i=0;i<cr.size();i++){\n    calc_res.push_back(cr[i]);\n  }\n  //cout << \"calc_res.size = \" << calc_res.size() << endl;\n\n  for(int i=0;i<calc_res.size();i++){\n    if(!hit_rect(calc_res[i])) {\n      //cout << calc_res[i] * 180.0 / M_PI << endl;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  double x, y, x2, y2;\n  while(cin >> n >> v >> x >> y){\n    rv.clear();\n    target = P(x, y);\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> x2 >> y2;\n      rv.push_back(Rect(P(x, y), P(x2, y2)));\n    }\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int MAXN=57;\nconst double EPS=1e-7;\nconst double g=9.8;\n\ndouble cmp(double a,double b)\n{\n\tif (abs(a-b)<EPS)\n\t{\n\t\treturn 0;\n\t}\n\treturn a-b;\n}\n\ndouble add(double a,double b)//用在向量叉?点?上的?数加法，修正0的偏差\n{\n\tif (abs(a+b)<EPS*(abs(a)+abs(b)))\n\t{\n\t\treturn 0;\n\t}\n\treturn a+b;\n}\n\nstruct Point//??是向量,不?也可以当点用\n{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint(const Point &p):x(p.x),y(p.y){}\n\tPoint operator +(Point p)\n\t{\n\t\treturn Point(add(x,p.x),add(y,p.y));\n\t}\n\tPoint operator -(Point p)\n\t{\n\t\treturn Point(add(x,-p.x),add(y,-p.y));\n\t}\n\tPoint operator *(double d)\n\t{\n\t\treturn Point(x*d,y*d);\n\t}\n\tdouble dot(Point p) // 内? 点乘\n\t{\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(Point p) // 外? 叉乘\n\t{\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble distance(Point p)\n\t{\n\t\treturn sqrt(add((x-p.x)*(x-p.x),(y-p.y)*(y-p.y)));\n\t}\n\tfriend ostream& operator <<(ostream &os, const Point &p)\n\t{\n\t\tos<<p.x<<\" \"<<p.y;\n\t\treturn os;\n\t}\n\tfriend istream& operator >>(istream &is, Point &p)\n\t{\n\t\tis>>p.x>>p.y;\n\t\treturn is;\n\t}\n};\n\nstruct Rectangle\n{\n\tPoint s,t;//s:left bottom t:right top\n\tRectangle(){}\n\tRectangle(double sx,double sy,double tx,double ty):s(sx,sy),t(tx,ty){}\n\tRectangle(Point &s,Point &t):s(s),t(t){}\n\tRectangle(const Rectangle &p):s(p.s),t(p.t){}\n\tdouble left()\n\t{\n\t\treturn s.x;\n\t}\n\tdouble right()\n\t{\n\t\treturn t.x;\n\t}\n\tdouble bottom()\n\t{\n\t\treturn s.y;\n\t}\n\tdouble top()\n\t{\n\t\treturn t.y;\n\t}\n\tPoint leftBottom()\n\t{\n\t\treturn s;\n\t}\n\tPoint leftTop()\n\t{\n\t\treturn Point(s.x,t.y);\n\t}\n\tPoint rightBottom()\n\t{\n\t\treturn Point(t.x,s.y);\n\t}\n\tPoint rightTop()\n\t{\n\t\treturn t;\n\t}\n\tfriend ostream& operator <<(ostream &os, const Rectangle &p)\n\t{\n\t\tos<<p.s<<\" \"<<p.t;\n\t\treturn os;\n\t}\n\tfriend istream& operator >>(istream &is, Rectangle &p)\n\t{\n\t\tis>>p.s>>p.t;\n\t\treturn is;\n\t}\n};\n\n\nint i,j,k,n,m;\ndouble x,y,v,vx,vy,t,tt;\nbool f;\nPoint pig;\nRectangle obs[MAXN];\n\nbool nonAbove(const Point &p)\n{\n\tint i;\n\tdouble t,ty;\n\tt=p.x/vx;\n\tty=vy*t-g*t*t/2;\n\tif (cmp(ty,p.y)>=0)\n\t{\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tif (cmp(obs[i].left(),p.x)<=0 && cmp(obs[i].right(),p.x)>=0 && (cmp(obs[i].top(),p.y)>=0 && cmp(obs[i].top(),ty)<=0 || cmp(obs[i].bottom(),p.y)>=0 && cmp(obs[i].bottom(),ty)<=0))\n\t\t\t{\n\t\t\t\t// cout<<\"here obs[\"<<i<<\"]\"<<endl;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// cout<<ty<<\"<\"<<p.y<<endl;\n\t\treturn false;\n\t}\n\t// cout<<\"nonAbove!\"<<endl;\n\treturn true;\n}\n\nbool nonBetween(const Point &p)\n{\n\tint i;\n\tdouble tl,tr,tyl,tyr,tx,ty;\n\ttx=vx*vy/g;\n\tty=vy*vy/g/2;\n\tfor (i=0;i<n;i++)\n\t{\n\t\tif (cmp(obs[i].left(),p.x)>0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\ttl=obs[i].left()/vx;\n\t\ttyl=vy*tl-g*tl*tl/2;\n\t\ttr=obs[i].right()/vx;\n\t\ttyr=vy*tr-g*tr*tr/2;\n\t\tif (cmp(obs[i].top(),tyl)<0 && cmp(obs[i].top(),tyr)<0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (cmp(obs[i].bottom(),tyl)>0 && cmp(obs[i].bottom(),tyr)>0 && (cmp(obs[i].left(),tx)>0 || cmp(obs[i].right(),tx)<0) || cmp(obs[i].bottom(),ty)>0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\t// cout<<\"nonBetween!\"<<endl;\n\treturn true;\n}\n\nbool checkOK(const Point &p)\n{\n\tdouble a,b,c,dt,sdt;\n\ta=g*g/4;\n\tb=p.y*g-v*v;\n\tc=p.x*p.x+p.y*p.y;\n\tdt=b*b-4*a*c;\n\t// cout<<\"p=\"<<p<<\" v=\"<<v<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<dt<<endl;\n\tif (dt<0)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tsdt=sqrt(dt);\n\n\t\ttt=(-b+sdt)/a/2;\n\t\tif (tt>0)\n\t\t{\n\t\t\tt=sqrt(tt);\n\t\t\tvx=p.x/t;\n\t\t\tvy=(p.y+g*tt/2)/t;\n\t\t\t// cout<<p<<\" \"<<vx<<\" \"<<vy<<endl;\n\t\t\tif (nonAbove(pig) && nonBetween(pig))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\ttt=(-b-sdt)/a/2;\n\t\tif (tt>0)\n\t\t{\n\t\t\tt=sqrt(tt);\n\t\t\tvx=p.x/t;\n\t\t\tvy=(y+g*tt/2)/t;\n\t\t\t// cout<<p<<\" \"<<vx<<\" \"<<vy<<endl;\n\t\t\tif (nonAbove(pig) && nonBetween(pig))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin>>n>>v>>pig)\n\t{\n\t\tf=false;\n\t\tmemset(obs,0,sizeof(obs));\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>obs[i];\n\t\t}\n\n\t\tif (checkOK(pig))\n\t\t{\n\t\t\tf=true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif (checkOK(obs[i].leftTop()))\n\t\t\t\t{\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (f)\n\t\t{\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define EPS 1e-10\nusing namespace std;\nconst double g = 9.8;\nint n, v, x, y;\nint L[55], B[55], R[55], T[55];\ndouble calcu(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\nbool cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1 : a > ub - EPS ? 1 : 0;\n}\nbool check(double qx, double qy) {\n    double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -EPS) D = 0;\n    if (D < 0) return false;\n    for (int d = -1; d <= 1; d += 2) {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        if (calcu(vy, x / vx) < y - EPS) continue;\n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            if (L[i] >= x) continue;\n            if (R[i] == x && y == T[i] && B[i] == calcu(vy, x / vx)) ok = false;\n            int yL = cmp(B[i], T[i], calcu(vy, L[i] / vx));\n            int yR = cmp(B[i], T[i], calcu(vy, R[i] / vx));\n            int xH = cmp(L[i], R[i], vx * (vy / g));\n            int yH = cmp(B[i], T[i], calcu(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\nint main() {\n    scanf(\"%d %d %d %d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", L + i, B + i, R + i, T + i);\n        R[i] = min(R[i], x);\n    }\n    bool ok = check(x, y);\n    for (int i = 0; i < n; ++i) {\n        ok |= check(L[i], T[i]);\n        ok |= check(R[i], T[i]);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && yy-rec[i].b>eps && rec[i].t-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && hh-rec[i].b>eps && rec[i].t-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n         {\n              if ( rec[i].b-hi>eps ) return true;//抛物&#32447;没有&#30896;到矩形 \n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;从矩形上方&#39134;&#36807; \n              if ( rec[i].b-h1>eps && hh-rec[i].b>eps ) return false;//pig的&#23545;&#24212;点高于矩形的下&#36793;界\n              if ( len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps ) return false; //矩形最高点高于矩形下&#36793;界\n              \n              return true; \n         } \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tif (L >= X)continue;\n\t\tR = max(R, X);\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < bs.size(); ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < bs.size(); ++i) {\n\t\t\t\tauto b = bs[i];\n\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-5;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second>0) allTAN.push_back(buf.second-EPS);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tdouble ta = allTAN[i];\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\t// Oñð\n\t\t\tif(f(th,v,x) < y){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\t\tif(y<=allB[j] && allT[j]<f(th,v,x)){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            // テ」ツδ禿」ツつーテ」ツ?ォテ・ツ債オテ」ツ?古・ツスツ禿」ツ?淌」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                if(x1[i] < gx && gx < x2[i] && fh > y1[i] && y1[i] >= gy) {\n                    ok = false;\n                }\n            }\n            // テ」ツδ氾」ツつーテ」ツ?ョテ、ツクツ甘ァツゥツコテ」ツ?セテ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                double h1 = calc_y(vx, vy, x1[i]);\n                double h2 = calc_y(vx, vy, x2[i]);\n                if(sign(h1 - y1[i]) > 0 && sign(y2[i] - h1) > 0) ok = false;\n                if(sign(h2 - y1[i]) > 0 && sign(y2[i] - h2) > 0) ok = false;\n                if(sign(y1[i] - h1) >= 0 && sign(h2 - y2[i]) >= 0) ok = false;\n                if(sign(y1[i] - h2) >= 0 && sign(h1 - y2[i]) >= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-9;\ndouble g=9.8;\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\nbool check(double a,double b,double c,double d){\n  if(a>b)swap(a,b);\n  if(c>d)swap(c,d);\n  if( b-eps < c )return false;\n  if( d-eps < a )return false;\n  return true;\n}\n\n#define MAX_N 50\nint N;\ndouble V,X,Y;\ndouble L[MAX_N],B[MAX_N],R[MAX_N],T[MAX_N];\n\ndouble calcpy(double t,double vy){\n  return (vy+vy-g*t)*t*0.5;\n}\n\nbool check(double t,double px,double py){\n  double vx = px/t;\n  double vy = Sqrt(V*V-vx*vx);\n\n  if( vy < eps ) return false;\n  \n  /*\n  cout<<\"!!!\"<<endl;\n  cout<<\"t = \"<<t<<endl;\n  cout<<\"vx = \"<<vx<<endl;\n  cout<<\"vy = \"<<vy<<endl;  \n  */\n  for(int i=0;i<N;i++){\n    if( X <= L[i] )continue;\n\n    double ft = L[i] / vx;\n    double st = R[i] / vx;\n    double zt = (ft+st)*0.5;\n    \n    double fh = calcpy(ft,vy);\n    double sh = calcpy(st,vy);\n    double zh = calcpy(zt ,vy);\n    //    cout<<\"fh = \"<<fh<<endl;\n    //    cout<<\"sh = \"<<sh<<endl;\n    \n    if( check( B[i], T[i], fh, sh ) )return false;\n    if( check( B[i], T[i], fh, zh ) )return false;\n    if( check( B[i], T[i], zh, sh ) )return false;\n    \n  }\n\n\n  double lastT=X/vx;\n  double lastY=calcpy(lastT,vy);\n\n  //  cout<<\"lastY = \"<<lastY<<endl;\n  if( lastY < Y - eps )return false;\n  \n  for(int i=0;i<N;i++){\n    if( X < L[i]+eps ) continue;\n    if( R[i]-eps < X ) continue;\n    if( check(B[i],T[i],Y,lastY) )return false;\n  }\n\n  //  cout<<\"??????\"<<endl;\n  return true;\n}\n\nbool solve(double px,double py){\n  double R=2*py;\n  double A=g*g;\n  double B=2*R*g-4.0*V*V;\n  double C=R*R+4.0*px*px;\n  if( B*B - 4.0*A*C < 0 )return false;\n  if( abs(A) < eps ) return false;\n  \n  double t0 = (-B+Sqrt(B*B-4.0*A*C))/(2.0*A);\n  double t1 = (-B-Sqrt(B*B-4.0*A*C))/(2.0*A);\n\n  t0=Sqrt(t0);\n  t1=Sqrt(t1);\n  \n  if(t0>eps && check(t0,px,py) )return true;\n  if(t1>eps && check(t1,px,py) )return true;\n\n  return false;\n}\n\nint main(){\n  cin>>N>>V>>X>>Y;\n  for(int i=0;i<N;i++){\n    cin>>L[i]>>B[i]>>R[i]>>T[i];\n  }\n  bool ans= solve(X,Y) ;\n  for(int i=0;i<N;i++){\n    if( solve(L[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(L[i],T[i]) )ans=true;\n    if(ans)break;\n    \n    if( solve(R[i],B[i]) )ans=true;\n    if(ans)break;\n    if( solve(R[i],T[i]) )ans=true;\n    if(ans)break;\n  }\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\n\npair<double, double> tanth(int x, int y, int v)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\n\tif(d<0) return make_pair<double, double>(-1, -1);\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble kakkononaka = 1.0*x - K*si*co;\n\treturn alpha*kakkononaka*kakkononaka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³Ê\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(buf.first+EPS>0) allTAN.push_back(buf.first+EPS);\n\t\tif(buf.first-EPS>0) allTAN.push_back(buf.first-EPS);\n\t\tif(buf.second+EPS>0) allTAN.push_back(buf.second+EPS);\n\t\tif(buf.second-EPS>0) allTAN.push_back(buf.second-EPS);\n\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<allTAN.size(); i++){\n\t\t\tallTH.push_back(atan(allTAN[i]));\n\t\t}\n\n\t\tif(0){\n\t\t// STõVer\n\t\t\tallTH.clear();\n\t\t\tint N = 1000000;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(i==0) continue;\n\t\t\t\tallTH.push_back(90.0/N*i);\n\t\t\t}\n\t\t}\n\n\t\t// áQ¨ª éÆ«\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\t// Oñð\n\t\t\tif(mauey < y){\n\t\t\t\t// »à»àÍ¢ÄÈ¢\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÅÌÉ¨¢Ä MAX(allR[j]) == x ÆÈÁÄ¢éÌÅA\n\t\t\t\t// êª¯ªsvÉÈÁ½\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t// Êß\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// êSÊß·éÁÛ¢Æ«\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <math.h>\n#include <ctime>\nusing namespace std;\n#define pi acos(-1)\n\n\nstruct node\n{\n    double x1,y1,x2,y2;\n};\nnode p[100];\nint n;\ndouble v,x,y;\ndouble g = 9.8;\n\ndouble get(double xx,double k)\n{\n    double t = xx/(v*cos(k));\n    double yt = v*sin(k)*t - 0.5 * g * t * t;\n    return yt;\n}\n\ndouble getx1(double a,double b,double c)\n{\n    double x1 = -b+(sqrt(b*b-4*a*c));\n    x1 = x1/(2.0*a);\n    return x1;\n}\ndouble getx2(double a,double b,double c)\n{\n    double x1 = -b-(sqrt(b*b-4*a*c));\n    x1 = x1/(2.0*a);\n    return x1;\n}\nint check(double k)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(p[i].x1>x)\n            continue;\n        node t = p[i];\n\n        t.x1 = min(x,t.x1);\n        t.x2 = min(x,t.x2);\n        double h = get(t.x1,k);\n        if(h<=t.y2&&h>=t.y1)\n            return 0;\n\n        h = get(t.x2,k);\n        if(h<=t.y2&&h>=t.y1)\n            return 0;\n\n        double a = -0.5 * g;\n\n        double b = v*sin(k);\n\n        double c = -t.y1;\n\n        if(b*b-4*a*c>=0)\n        {\n            double kkk = b*b-4*a*c;\n            double x1 = getx1(a,b,c);\n            double x2 = getx2(a,b,c);\n            x1 = x1/(v*(cos(k)));\n            x2 = x2/(v*(cos(k)));\n            if(x1<=t.x2&&x1>=t.x1)\n                return 0;\n            if(x2<=t.x2&&x2>=t.x1)\n                return 0;\n        }\n\n        c = -t.y2;\n\n        if(b*b-4*a*c>=0)\n        {\n            double kkk = b*b-4*a*c;\n            double x1 = getx1(a,b,c);\n            double x2 = getx2(a,b,c);\n            x1 = x1/(v*(cos(k)));\n            x2 = x2/(v*(cos(k)));\n            if(x1<=t.x2&&x1>=t.x1)\n                return 0;\n            if(x2<=t.x2&&x1>=t.x1)\n                return 0;\n        }\n    }\n\n    double h = get(x,k);\n    if(h<y)return 0;\n    for(int i=1;i<=n;i++)\n    {\n        if(p[i].x1<=x&&p[i].x2>=x)\n        {\n            if(p[i].y1<=h&&p[i].y1>=y)\n                return 0;\n            if(p[i].y2<=h&&p[i].y2>=y)\n                return 0;\n        }\n    }\n\n    return 1;\n}\nint main()\n{\n    srand(time(NULL));\n    scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lf%lf%lf%lf\",&p[i].x1,&p[i].y1,&p[i].x2,&p[i].y2);\n        if(p[i].x1>p[i].x2)swap(p[i].x1,p[i].x2);\n        if(p[i].y1>p[i].y2)swap(p[i].y1,p[i].y2);\n    }\n    if(rand()%2)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    return 0;\n    for(double i=0;i<=pi/2;i+=pi/1000)\n    {\n        if(check(i))\n        {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\n\nstruct point\n{\n       double x,y;\n}p[201];\n\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     for ( i=1;i<=top;i++ )\n         if ( p[i].y-a*p[i].x*(p[i].x-len)>eps )\n            return false;\n     return true;\n}\n\n\nvoid bs()\n{\n     double l=0,r=v,mid = (l+r)/2;\n     double t,vx,vy,len;\n     vy=v;\n     while ( r-l>eps )\n     {\n           mid = (l+r)/2;\n           vy=mid;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           len = vx*2*t;\n           if ( len<xx )\n              r=mid;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n               else\n                   l=mid;\n           }\n     }\n     printf(\"No\\n\");\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          for ( i=1;i<=n;i++ )\n          {\n              if( rec[i].l-xx>eps ) continue;\n              p[++top].x=rec[i].l,p[top].y=rec[i].t;\n              if ( rec[i].r-xx>eps ) continue;\n              p[++top].x=rec[i].r,p[top].y=rec[i].t;\n          }\n          p[++top].x=xx;\n          p[top].y=yy;\n          bs();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double eps = 1e-10;\nconst int MAX_N = 50;\nconst double g = 9.8;\n\nint N, V, X, Y;\nint L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble position(double vy, double t) {\n\treturn vy*t-g*t*t/2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n\treturn a < lb + eps?-1:a>ub-eps?1:0;\n}\n\n// 射出路径经过(qx,qy)时，能否击中猪\nbool check(double qx, double qy) {\n\tdouble a = g*g/4.0, b=g*qy-V*V, c=qx*qx+qy*qy;\n\tdouble D = b*b-4*a*c;\n\tif (D < 0 && D > -eps) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2) { // 验证解的循环\n\t\tdouble t2 = (-b + d*sqrt(D))/(2*a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = qx/t, vy=(qy+g*t*t/2.0)/t;\n\t\t// 是否通过猪的正上方？\n\t\tdouble yt = position(vy, X/vx);\n\t\tif (yt < Y-eps) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (L[i] >= X) continue;\n\t\t\tif (R[i] == X &&  Y <= T[i] && B[i] <= yt) ok = false;\n\t\t\tint yL = cmp(B[i], T[i], position(vy, L[i]/vx)); // 左侧相对位置\n\t\t\tint yR = cmp(B[i], T[i], position(vy, R[i]/vx)); // 右侧相对位置\n\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g)); // 最高点相对位置\n\t\t\tint yH = cmp(B[i], T[i], position(vy, vy/g));\n\t\t\tif (xH == 0 && yH >= 0 && yL < 0) ok = false;\n\t\t\tif (yL * yR <= 0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tR[i] = min(R[i], X);\n\t}\n\tbool ok = check(X, Y);\n\tfor (int i = 0; i < N; ++i) {\n\t\tok |= check(L[i], T[i]);\n\t\tok |= check(R[i], T[i]);\n\t}\n\tputs(ok?\"Yes\":\"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\ndouble calc(double vy, double t){\n    return vy * t - 0.5 * g * t * t;\n}\nconst int N = 60;\nint n;\nint v,x,y;double fy;\nint L[N],B[N],R[N],T[N];\n\nbool cmp(int i, double vx, double vy) {\n    if (L[i] > x) return true;\n    if (R[i] == x && fy >= B[i] && y <= T[i]) return false;\n    double yl = calc(vy, L[i] / vx), yr = calc(vy, R[i] / vx);\n    if (yl > T[i] && yr > T[i]) return true;\n    if (yl < B[i] && yr < B[i]) {\n        double tx = vx * vy / g;\n        if (tx > R[i] || tx < L[i]) return true;\n        return calc(vy, vy / g) < B[i];\n    }\n    return false;\n}\n\n\nbool check(double qx, double qy) {\n    double A = g * g, B = 4 * qy * g - 4 * v * v, C = 4 * (qx *qx + qy * qy);\n    double delta = B * B - 4 * A * C;\n    if (delta < 0 && delta > -eps) delta = 0;\n    if (delta < 0) return false;\n    for (int co = -1; co <= 1; co+=2) {\n        double t2 = (-B+co * sqrt(delta)) / (2 * A);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + g * t * t / 2) / t;\n        fy = calc(vy, x / vx);\n        if (fy + eps < y) continue;\n        bool ok = true;\n        for (int i = 0; i < n;i++) {\n            if (!cmp(i,vx,vy)) {\n                ok = false;\n                break;\n            }   \n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d%d%d\", L + i, B + i, R + i, T + i);\n        R[i] = min(x,R[i]);\n    }\n    bool ok = false;\n    ok |= check(x,y);\n    for (int i = 0; i < n && !ok; i++) {\n        ok |= check(L[i],T[i]);\n\n        ok |= check(R[i],T[i]);\n    }\n    if (ok) {\n        puts(\"Yes\");\n    }\n    else {\n        puts(\"No\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define _USE_MATH_DEFINES\n\nconst int NMax = 150;\nconst double eps = 1e-8;\nconst double eps1 = 1e-6;\nconst double gravity = 9.8;\nconst double PI = 3.14159265;\n\nint N, V, X, Y;\nint L[NMax], B[NMax], R[NMax], T[NMax];\n\nint main()\n{\n\tcin >>N >>V >>X >>Y;\n\n\tfor (int i = 1; i <= N; ++i)\n\t\tcin >>L[i] >>B[i] >>R[i] >>T[i];\n\n\tfor (double alpha = -eps1; alpha <= PI/2; alpha += eps1)\n\t{\n\t\tdouble V_0x = V * cos(alpha);\n\t\tdouble V_0y = V * sin(alpha);\n\t\tdouble Time = X / V_0x;\n\t\tdouble LandY = V_0y * Time - 0.5*gravity*(Time*Time);\n\n\t\tif (Y - LandY <= eps)\n\t\t{\n            bool intersect = 0;\n\n            for (int i = 1; i <= N; ++i)\n                if (X - L[i] >= eps && X - R[i] <= eps &&\n\t\t\t\t\tLandY - B[i] >= eps && LandY - T[i] <= eps)\n\t\t\t\t\tintersect = 1;\n\n            for (int i = 1; i <= N; ++i)\n\t\t\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t\t{\n\t\t\t\t\tdouble TimeToJ = j / V_0x;\n\t\t\t\t\tif (Time - TimeToJ >= eps)\n\t\t\t\t\t{\n                        double newY = V_0y * TimeToJ - 0.5*gravity*(TimeToJ*TimeToJ);\n                        if (newY - B[i] - eps >= 0 &&\n\t\t\t\t\t\t\tnewY - T[i] - eps <= 0)\n\t\t\t\t\t\t\t\tintersect = 1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\tif (!intersect)\n\t\t\t{\n                cout <<\"Yes\" <<'\\n';\n                return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout <<\"No\" <<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\n\npair<double, double> tanth(int a, int b, int v)\n{\n\tdouble d = a*a*v*v*v*v - g*a*(g*a-2*v*v*b);\n\n\tif(d<0) return make_pair<double, double>(-1,-1);\n\tdouble kai1 = (a*v*v + sqrt(d)) / g*a;\n\tdouble kai2 = (a*v*v - sqrt(d)) / g*a;\n\treturn make_pair<double, double>(kai1, kai2);\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble naka = 1.0*x - v*v*si*co/g;\n\tdouble hidari = -1*g/(v*v*co*co)*naka*naka;\n\treturn hidari + v*v*si*si/g/2;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL;\n\t\tvector<int> allB;\n\t\tvector<int> allR;\n\t\tvector<int> allT;\n\t\tvector<double> allTAN;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tbuf = tanth(l, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, b, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(l, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t\tbuf = tanth(r, t, v);\n\t\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\t}\n\t\tbuf = tanth(x, y, v);\n\t\tif(buf.first>0) allTAN.push_back(buf.first);\n\t\tif(buf.second>0) allTAN.push_back(buf.second);\n\t\tif(n==0){\n\t\t\tif(buf.first<0 && buf.second<0){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t} \n\t\tsort(allTAN.begin(), allTAN.end());\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTAN.size()-1; i++){\n\t\t\tdouble ta = (allTAN[i] + allTAN[i+1])/2;\n\t\t\tdouble th = atan(ta);\n\t\t\tdouble si = sin(th);\n\t\t\tdouble co = cos(th);\n\t\t\tdouble thox = v*v*si*co/g;\n\t\t\tdouble thoy = v*v*si*si/g/2;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t// ÖWÌ³¢ubN\n\t\t\t\tif(allL[j]>x) continue;\n\n\t\t\t\t// ÈPÈá\n\t\t\t\tif(allR[j]<x){\n\t\t\t\t\tif(\n\t\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\t\t// Êß\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdameflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ßñÇ¢á\n\t\t\t\tif(thoy < allB[j]){\n\t\t\t\t\t// ¸_ªubNÌº\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]){\n\t\t\t\t\t// ubNÌã\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dameflg){\n\t\t\t\tif(f(th,v,x)>y){\n\t\t\t\t\tbool butukaruflg = false;\n\t\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\t\tif(allL[j]<x && x<allR[j]){\n\t\t\t\t\t\t\tif(y<allB[j] && allT[j]<thoy){\n\t\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!butukaruflg){\n\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t} else {\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nint lx[100];\nint ly[100];\nint rx[100];\nint ry[100];\ndouble EPS=1e-9;\nvector<pair<int,int> > v;\ndouble ABS(double a){return max(a,-a);}\ndouble calc(double a,double b){\n\treturn -4.9*b*b+a*b;\n}\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(rx[i],ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-9.8*9.8*(x*x+y*y);\n\t\tif(D>-EPS)D=max(D,0.0);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)+sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tif(vx-EPS>b)ok=false;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)-sqrt(D))*2/9.8/9.8;\n\t\tif(t2>-EPS)t2=max(t2,0.0);\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=calc(vy,(double)lx[j]/vx);\n\t\t\tdouble q=calc(vy,(double)rx[j]/vx);\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy/19.6-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy/19.6-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy/9.8&&vx*vy/9.8+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vx-EPS>b)ok=false;\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%f %f\\n\",vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 110;\nconst double eps = 1e-6, pi = acos(-1), g = 9.8;\n\nint N, V, X, Y;\nint X1[NMAX], X2[NMAX], Y1[NMAX], Y2[NMAX];\ndouble v0x, v0y, rAngle, birdTime;\n\nint getSign(double value) {\n\tif (value < -eps)\n\t\treturn -1;\n\tif (value > eps)\n\t\treturn 1;\n\treturn 0;\n}\n\nbool trajectoryIntersect() {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = X1[i]; j <= X2[i]; ++j) {\n\t\t\tdouble time = j / v0x;\n\t\t\tif (getSign(time - birdTime) > 0)\n\t\t\t\tbreak;\n\t\t\tdouble y = v0y * time - 0.5 * g * time * time;\n\t\t\tif (getSign(y - Y1[i]) >= 0 && getSign(y - Y2[i]) <= 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool projectileIntersect(double y) {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (getSign(X - X1[i]) >= 0 && getSign(X - X2[i]) <= 0 && getSign(y - Y1[i]) >= 0 && getSign(y - Y2[i]) <= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tcin >> N >> V >> X >> Y;\n\tfor (i = 1; i <= N; ++i)\n\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\n\trAngle = -pi / 100000;\n\twhile (rAngle + pi / 100000 <= pi / 2) {\n\t\trAngle += pi / 100000;\n\t\tv0x = V * cos(rAngle);\n\t\tv0y = V * sin(rAngle);\n\t\tbirdTime = X / v0x;\n\t\tdouble birdY = v0y * birdTime - 0.5 * g * birdTime * birdTime;\n\t\tif (getSign(Y - birdY) > 0)\n\t\t\tcontinue;\n\t\tif (trajectoryIntersect())\n\t\t\tcontinue;\n\t\tif (projectileIntersect(birdY))\n\t\t\tcontinue;\n\t\tcout << \"Yes\\n\";\n\t\treturn 0;\n\t}\n\n\tcout << \"No\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-8;\nconst double g=9.8;\nconst int maxn=10000;\n\n#define Equ(a,b) ((fabs((a)-(b)))<(eps))\n#define Less(a,b) (((a)-(b))<(-(eps)))\n#define LessEqu(a,b) (((a)-(b))<(eps))\n#define More(a,b) (((a)-(b))>(eps))\n#define MoreEqu(a,b) (((a)-(b))>(-(eps)))\n\nint main()\n{\n    //freopen(\"12381.txt\",\"r\",stdin);\n\n    int n;\n    double v,X,Y,x,y,t,vx,vy,t1,t2,x1,x2;\n    double L[60],B[60],R[60],T[60];\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        }\n        if(Equ(v,0.0))\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n\n        bool flag=0;\n\n        for(int k=1;k<maxn;k++)\n        {\n            vx=v*k/maxn;\n            vy=sqrt(v*v-vx*vx);\n            t=X/vx;\n            y=vy*t-0.5*g*t*t;\n            if(Less(y,Y)) continue;\n\n            for(int i=0;i<n;i++)\n            {\n\n                if(MoreEqu(X,L[i]))\n                {\n                    t=L[i]/vx;\n                    y=vy*t-0.5*g*t*t;\n                    if(MoreEqu(y,B[i])&&LessEqu(y,T[i]))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*B[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*B[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*B[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*T[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*T[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*T[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                flag=1;\n            }\n\n            if(n==0) flag=1;\n\n            if(flag==1) break;\n        }\n\n        if(flag==1) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst double eps=1e-8;\nint N;\ndouble V,X,Y;\nvector<double> L,R,B,T;\ndouble OB;\nvector<double> Tan;\n\n//ÀWiX,Y)ðÊéæ¤ÈtanÌlðßApush·é\nvoid add(double X,double Y){\n\tdouble a=1.0/2.0*9.8*X*X/V/V;\n\tdouble b=-X;\n\tdouble c=1.0/2.0*9.8*X*X/V/V+Y;\n\tif(b*b-4.0*a*c<0 || abs(a)<eps)\n\t\treturn;\n\tTan.push_back((-b-sqrt(b*b-4.0*a*c))/2.0/a);\n\tTan.push_back((-b+sqrt(b*b-4.0*a*c))/2.0/a);\n}\n\nvoid solve(){\n\tTan.clear();\n\tOB=300.1;\n\tL.resize(N);B.resize(N);T.resize(N);R.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>L[i]>>B[i]>>R[i]>>T[i];\n\t\t//OBæèàá­È¯êÎ^ãÉáQ¨ª é\n\t\tif(R[i]>X)\n\t\t\tR[i]=X-eps;\n\t\tif(L[i]<X && X<R[i])\n\t\t\tOB=min(OB,B[i]);\n\t}\n\t//^[QbgðÊéæ¤ÈtanÌlðßé\n\tadd(X,Y);\n\n\t//e¸_ðÆ¨éæ¤Ètanðßé\n\tfor(int i=0;i<N;i++){\n\t\tadd(L[i],T[i]);\n\t\tadd(R[i],T[i]);\n\t\tadd(L[i],B[i]);\n\t\tadd(R[i],B[i]);\n\t}\n\n\tfor(int i=0;i<Tan.size();i++){\n\t\tbool clear=true;\n\t\t//^[QbgÌ^ãÉ½Æ«OBæèà¢A»à»àÍ©È¢ÍÌtanð·\n\t\tif(X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])>OB\n\t\t|| X*Tan[i]-1.0/2.0*9.8*X*X/V/V*(1.0+Tan[i]*Tan[i])<Y)\n\t\t\tcontinue;\n\t\tdouble center=Tan[i]*V*V/9.8/(1.0+Tan[i]*Tan[i]);\n\t\t//eáQ¨ÆÕË»èð·é\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdouble my,My;\n\t\t\t//XÀWªáQ¨ÌÍÍàÌÆ«ÌÅåÌ³AÅáÌá³ðßé\n\t\t\t//XÀWªáQ¨Ì¶[ÆE[ÌÆ«Ì³ðßé\n\t\t\tmy=L[j]*Tan[i]-1.0/2.0*9.8*L[j]*L[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\tMy=R[j]*Tan[i]-1.0/2.0*9.8*R[j]*R[j]/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t//å«¢ûªMy\n\t\t\tif(my>My) swap(my,My);\n\t\t\t//¸_ªÜÜêéÆ«ÍA¸_ªÅåÌ³\n\t\t\tif(L[j]<center && center<R[j])\n\t\t\t\tMy=center*Tan[i]-1.0/2.0/9.8*center*center/V/V*(1.0+Tan[i]*Tan[i]);\n\t\t\t\n\t\t\t//àµÔÂ©éÈçÌtanð·\n\t\t\tif(!(My<B[j] || T[j]<my)){\n\t\t\t\tclear=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//àµ`FbNðNAµ½tanª¶Ýµ½çYesðoÍµÄIíè\n\t\tif(clear){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n}\n\nint main()\n{\n\twhile(cin>>N>>V>>X>>Y)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double g = 9.8;\nconst double eps = 1e-10;\ndouble calc(double vy, double t){\n    return vy * t - 0.5 * g * t * t;\n}\nconst int N = 60;\nint n;\ndouble v,x,y, fy;\ndouble L[N],B[N],R[N],T[N],sR[i];\n\nbool cmp(int i, double vx, double vy) {\n    if (L[i] > x || L[i] > R[i]) return true;\n    if (sR[i] > x && fy > T[i] && y < T[i]) return false;\n    double yl = calc(vy, L[i] / vx), yr = calc(vy, R[i] / vx);\n    if (yl > T[i] && yr > T[i]) return true;\n    if (yl < B[i] && yr < B[i]) {\n        double tx = vx * vy / g;\n        if (tx > R[i] || tx < L[i]) return true;\n        return calc(vy, vy / g) < B[i];\n    }\n    return false;\n}\n\n\nbool check(double qx, double qy) {\n    double A = g * g, B = 4 * qy * g - 4 * v * v, C = 4 * (qx *qx + qy * qy);\n    double delta = B * B - 4 * A * C;\n    if (delta < 0) return false;\n    for (int co = -1; co <= 1; co+=2) {\n        double t2 = (-B+co * sqrt(delta)) / (2 * A);\n        if (t2 < 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = sqrt(v*v - vx * vx);\n        fy = calc(vy, x / vx);\n        if (fy + eps < y) continue;\n        bool ok = true;\n        for (int i = 0; i < n;i++) {\n            if (!cmp(i,vx,vy)) {\n                ok = false;\n                break;\n            }   \n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\n\nint main() {\n    scanf(\"%d%lf%lf%lf\", &n, &v, &x, &y);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf%lf%lf%lf\", L + i, B + i, R + i, T + i);\n        sR[i] = R[i];\n        R[i] = min(x,R[i]);\n    }\n    bool ok = false;\n    ok |= check(x,y);\n    for (int i = 0; i < n && !ok; i++) {\n        ok |= check(L[i],B[i]);\n        ok |= check(L[i],T[i]);\n        ok |= check(R[i],B[i]);\n        ok |= check(R[i],T[i]);\n    }\n    if (ok) {\n        puts(\"Yes\");\n    }\n    else {\n        puts(\"No\");\n    }\n    \n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n;\nbool ok[50]={};\ndouble v,x,y,l[50],r[50],d[50],u[50],g=9.8,eps=1e-9;\nbool comp(double lb,double ub,double x){\n\tif(x<lb+eps) return -1;\n\tif(ub<x+eps) return 1;\n\treturn 0;\n}\nvoid fix(double x){\n\tif(x<0&&x>-eps) x=0;\n\tif(x>0&&x<eps) x=0;\n}\ndouble calcy(double vy,double t){\n\treturn -g/2*t*t+vy*t;\n}\nbool check(double qx,double qy){\n\tdouble a=g*g/4,b=g*qy-v*v,c=qx*qx+qy*qy,D=b*b-4*a*c;\n\tfix(D);\n\tif(D<0) return false;\n\tdouble s=-1;\n\trep(ssign,2){\n\t\tbool ok=true;\n\t\ts*=-1;\n\t\tdouble t2=(-b+s*sqrt(D))/(2*a);\n\t\tfix(t2);\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\tdouble vx=qx/t,vy=(qy+g/2*t*t)/t;\n\t\tif(vx<=0) continue;\n\t\tdouble t2t=x/vx,ry=calcy(vy,t2t);\n\t\tif(ry+eps<y) continue;\n\t\t//show(qx);\n\t\t//show(qy);\n\t\t//show(vx);\n\t\t//show(vy);\n\t\trep(i,n){\n\t\t\tif(x<l[i]||r[i]<x) continue;\n\t\t\tif(y<=u[i]&&d[i]<=ry) ok=false;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble ly=comp(d[i],u[i],calcy(vy,l[i]/vx));\n\t\t\tdouble ry=comp(d[i],u[i],calcy(vy,r[i]/vx));\n\t\t\tdouble hx=comp(l[i],r[i],vy/g*vx);\n\t\t\tdouble hy=comp(d[i],u[i],calcy(vy,vy/g));\n\t\t\tif(hx==0&&hy>=0&&ly<0) ok=false;\n\t\t\tif(ly*ry<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>n>>v>>x>>y;\n\trep(i,n) cin>>l[i]>>d[i]>>r[i]>>u[i];\n\tbool can=false;\n\tcan|=check(x,y);\n//\tif(can) cout << \"d\";\n\trep(i,n){\n\t\tcan|=check(l[i],u[i]);\n\t\tcan|=check(r[i],u[i]);\n\t}\n\tcout << (can ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define pow2(a) ((a)*(a))\n\nusing namespace std;\n\nconst int MAX_N = 70;\nconst double g = 9.8;\nint N;\ndouble v0,X,Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\nbool  LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return  equals(a,b) || a < b; }\nbool  GT(double a,double b) { return !equals(a,b) && a > b; }\nbool GTE(double a,double b) { return  equals(a,b) || a > b; }\n\ninline double getY(double vy,double t){ return vy * t - ( g * pow2(t) ) / 2.0; }\n\nint getLayer(double lb,double ub,double h){ return (LT(h,lb)?-1:(GT(h,ub)?1:0)); }\n\nbool exec(double x,double y){\n  double a = pow2(g), b = 4 * ( g*y - pow2(v0) ), c = 4 * ( pow2(x) + pow2(y) );\n  double D = b * b - 4 * a * c;\n  vector<double> ts;\n  if( LT(D,0.0) ) return false;\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return false;\n    if( LT(-c/b,0.0) ) return false;\n    ts.push_back(sqrt(-c/b));\n  } else {\n    if( equals(D,0.0) ) D = 0;\n    double tmp_t = ( -b - sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << \" ?+ \";\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n    tmp_t = ( -b + sqrt(D) ) / ( 2 * a );\n    //cout << sqrt(tmp_t) << endl;\n    if( GTE(tmp_t,0.0) ) ts.push_back(sqrt(tmp_t));\n  }\n\n  rep(i,ts.size()){ \n    //cout << \"ts[ \" << i << \"] = \" << ts[i] << endl;\n    double vx = x / ts[i], vy = y / ts[i] + ( g * ts[i] ) / 2.0;\n    //cout << vx << \" \" << vy << endl;\n    bool failed = false;\n    for( int j=0 ; !failed && j < N ; j++ ){\n      if( GT(L[j],X) ) continue;\n\n      double pig_t = X / vx;\n      double pig_y = getY(vy,pig_t);\n      //cout << vx << \",\" << vy << \" -> \" << pig_y << endl;\n      if( LT(pig_y,Y) ) { failed = true; break; }\n\n      double rect_L_t = L[j] / vx;\n      int rect_L_y = getY(vy,rect_L_t);\n      int layer_L = getLayer(B[j],T[j],rect_L_y);\n\n      double rect_R_t = R[j] / vx;\n      int rect_R_y = getY(vy,rect_R_t);\n      int layer_R = getLayer(B[j],T[j],rect_R_y);\n      \n      if( layer_L * layer_R <= 0 ) failed = true;\n      \n      double top_t = vy / g;\n      double top_x = vx * top_t;\n      int layer_top_x = getLayer(L[j],R[j],top_x);\n      \n\n      double top_y = getY(vy,top_t);\n      int layer_top_y = getLayer(B[j],T[j],top_y);\n      /*\n      cout << \"sine \" << vy << \",\" << top_t << \" = \" << getY(vy,top_t) << endl;\n      cout << rect_L_y << \" ! \" << rect_R_y << \" ! \" << top_x << \" ! \" << top_y << endl;\n      cout << layer_L << \",\" << layer_R << \",\" << layer_top_x << \",\" << layer_top_y << endl;\n      */\n      if( layer_top_x == 0 && layer_top_y >= 1 ) failed = true;\n      //if( layer_top_x == 0 && layer_top_y >= 0 && layer_L < 0 ) failed = true;\n      //cout << \"rect_L_y = \" << rect_L_y << endl;\n    }\n    if( !failed ) {\n      //cout << \"ok!! \" << ts[i] << endl;\n      return true;\n    }\n  }\n\n  return false;\n}\n\ninline void compute(){\n  bool success = false;\n  for(int i=0; !success && ( i <= N ) ; i++ ) {\n    success |= exec(L[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n    success |= exec(R[i],T[i]);\n    //cout << endl << \" success \" << success << endl << endl;\n  }\n  cout << (success?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  scanf(\"%d %lf %lf %lf\",&N,&v0,&X,&Y);\n  rep(i,N) scanf(\"%lf %lf %lf %lf\",L+i,B+i,R+i,T+i);\n  L[N] = R[N] = X, B[N] = T[N] = Y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && yy-rec[i].b>eps && rec[i].t-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && hh-rec[i].b>eps && rec[i].t-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n         {\n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;从矩形上方&#39134;&#36807; \n              if ( rec[i].b-h1>eps && hh-rec[i].b>eps ) return false;//pig的&#23545;&#24212;点高于矩形的下&#36793;界\n              if ( len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps ) return false; //矩形最高点高于矩形下&#36793;界\n              return true; \n         } \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    const double diff = a-b;\n    if(fabs(diff) < EPS) return 0;\n    return diff < 0 ? -1 : 1;\n}\n\nstruct Rect {\n    P lb, rt;\n\n    Rect() {}\n    Rect(const P &lb, const P &rt) : lb(lb), rt(rt) {}\n\n    double top() const { return rt.imag(); }\n    double bottom() const { return lb.imag(); }\n    double left() const { return lb.real(); }\n    double right() const { return rt.real(); }\n};\n\ndouble calc(double t, double vy) {\n    return -4.9*t*t + vy*t;\n}\n\nbool shoot(double vx, double vy, const vector<Rect> &rects, double X, double Y) {\n    if(cmp(vx, 0) == 0) {\n        return cmp(Y, 0) == 0;\n    }\n    // Xテ・ツ慊ーテァツつケテ」ツ?ァYテ、ツクツ甘ァツゥツコテ」ツ?ォテ」ツ??」ツつ嘉」ツつ古」ツ?ェテ」ツ??\n    if(cmp(calc(X / vx, vy), Y) < 0) return false;\n\n    const double top_t = vy / 9.8;\n    const double top_x = vx * top_t;\n    const double top_y = calc(top_t, vy);\n    for(const Rect &r : rects) {\n        const double y_left = calc(r.left()/vx, vy);\n        const double y_right = calc(r.right()/vx, vy);\n        if(cmp(r.bottom(), y_left) <= 0 && cmp(y_left, r.top()) < 0) return false;\n        if(cmp(r.bottom(), y_right) <= 0 && cmp(y_right, r.top()) < 0) return false;\n        if(cmp(r.top(), y_left) * cmp(r.top(), y_right) < 0) return false;\n        if(cmp(r.bottom(), y_left) * cmp(r.bottom(), y_right) < 0) return false;\n        if(cmp(r.left(), top_x) < 0 && cmp(top_x, r.right()) < 0) {\n            if(cmp(y_left, r.bottom()) <= 0\n                && cmp(y_right, r.bottom()) <= 0\n                && cmp(top_y, r.bottom()) > 0) return false;\n        }\n    }\n    return true;\n\n}\nbool check(const P &aim, const vector<Rect> &rects, double V, double X, double Y) {\n    const double a = norm(aim);\n    const double b = 9.8*aim.imag()*aim.real()*aim.real() - V*V*aim.real()*aim.real();\n    const double c = 4.9*4.9*pow(aim.real(), 4);\n    const double D = b*b - 4*a*c;\n    //cout << D << endl;\n    if(D < 0) return false;\n    const double vx_1 = 4*a*c / (2*a*(-b-sqrt(D)));\n    if(vx_1 >= 0) {\n        const double vx = sqrt(vx_1);\n        const double vy = sqrt(V*V - vx_1);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    const double vx_2 = (-b - sqrt(D)) / (2*a);\n    if(vx_2 >= 0) {\n        const double vx = sqrt(vx_2);\n        const double vy = sqrt(V*V - vx_2);\n        if(shoot(vx, vy, rects, X, Y)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N, V, X, Y;\n    if(!(cin >> N >> V >> X >> Y)) return false;\n\n    vector<Rect> rects;\n    for(int i = 0; i < N; ++i) {\n        double l, b, r, t;\n        cin >> l >> b >> r >> t;\n        rects.push_back(Rect(P(l, b), P(r, t)));\n    }\n    if(check(P(X, Y), rects, V, X, Y)) {\n        cout << \"Yes\" << endl;\n        return true;\n    }\n\n    for(const Rect &r : rects) {\n        if(check(P(r.left(), r.top()), rects, V, X, Y)\n            || check(r.rt, rects, V, X, Y))\n        {\n            cout << \"Yes\" << endl;\n            return true;\n        }\n    }\n    cout << \"No\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- 1e-7 < b.ys[0] || b.ys[1] < y_min + 1e-7) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\t//tans = ntans;\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n#define EPS (1e-9)\ntypedef complex<double> P;\n\nconst double g = 9.8;\n\nint N, V, X, Y, L[60], B[60], R[60], T[60];\ndouble f;\n\nvoid calc_push(vector<P>& vs, double v, double x, double y) {\n    if(x==0) return ;\n    const double a = g*g/4, b = g*y-v*v, c = x*x+y*y;\n    const double k[2] = {(-b+sqrt(b*b-4*a*c))/2/a, (-b-sqrt(b*b-4*a*c))/2/a};\n    rep(i, 2) if(k[i]>0) {\n        const double t = sqrt(k[i]);\n        vs.push_back(P(x/t, y/t+g*t/2));\n    }\n}\n\ndouble yof(double vy, double t) { return vy*t-g*t*t/2; }\n\nbool can(double vx, double vy) {\n    const double gy = yof(vy, X/vx);\n    if(gy < Y-EPS || gy > f+EPS) return false;\n    const double tt = vy/g, tx = vx*tt, ty = yof(vy, tt);\n    rep(i, N) {\n        double l = yof(vy, L[i]/vx), r = yof(vy, R[i]/vx);\n        if(l>r) swap(l, r);\n        if(B[i]+EPS<l && l<T[i]-EPS) return false;\n        if(B[i]+EPS<r && r<T[i]-EPS) return false;\n        if(l<B[i]-EPS && r>B[i]+EPS) return false;\n        if(l<T[i]-EPS && r>T[i]+EPS) return false;\n        if(l<B[i]-EPS && r<B[i]-EPS) {\n            if(L[i]+EPS<tx && tx<R[i]-EPS && ty>B[i]+EPS) return false;\n        }\n        const double m = yof(vy, (L[i]+R[i])/2/vx);\n        if(B[i]+EPS < m && m < T[i]-EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    const double pi = atan2(0.0, -1.0);\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    rep(i, N) scanf(\"%d%d%d%d\", L+i, B+i, R+i, T+i);\n    int k = 0;\n    rep(i, N) if(L[i]<=X) {\n        L[k] = L[i]; B[k] = B[i]; T[k] = T[i]; R[k] = min(R[i], X);\n        k++;\n    }\n    N = k;\n    f = 1e100;\n    rep(i, N) if(L[i]<=X && X<=R[i] && T[i]>=Y) f = min(f, (double)B[i]);\n    vector<P> vs;\n    calc_push(vs, V, X, Y);\n    rep(i, N) {\n        calc_push(vs, V, L[i], T[i]);\n        calc_push(vs, V, R[i], T[i]);\n    }\n    bool ans = false;\n    rep(k, vs.size()) {\n        if(can(real(vs[k]), imag(vs[k]))) ans = true;\n    }\n    puts(ans ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        if (sgn(f(x) - y) < 0) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-6;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<algorithm>\n//#include<cmath>\n#define maxn 55\nconst double eps =1e-10;\nconst double g =9.8;\nusing namespace std;\n\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\nint dcmp(double d){\n\tif(d<-eps) return -1;\n\telse if(d>eps) return 1;\n\telse return 0;\n}\n\ndouble cal(double vy,double t){\n\treturn vy*t-0.5*g*t*t;\n}\n\nint cmp(double lb,double ub,double a){\n\treturn a-lb<-eps?-1:ub-a<-eps?1:0;\n}\n\nbool check(double qx,double qy){\n\tdouble a=0.25*g*g,b=g*qy-V*V,c=1.0*qx*qx+qy*qy;\n\tdouble D=b*b-4*a*c;\n\tif(dcmp(D)==0) D=0;\n\tif(D<0) return false;\n\tfor(int d=-1;d<=1;d+=2){\n\t\tdouble t2=(-b+d*sqrt(D))/2/a;\n\t\tif(t2<=0) continue;\n\t\tdouble t=sqrt(t2);\n\t\t\n\t\tdouble vx=qx/t,vy=(qy+0.5*g*t*t)/t;\n\t\tdouble yt=cal(vy,X/vx);\n\t\tif(dcmp(yt-Y)<0) continue;\n\t\t\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(L[i]>=X) continue;\n\t\t\tif(R[i]==X&&Y<=T[i]&&B[i]<=yt) ok=false;\n\t\t\t\n\t\t\tint yL=cmp(B[i],T[i],cal(vy,L[i]/vx)),\n\t\t     \tyR=cmp(B[i],T[i],cal(vy,R[i]/vx)),\n\t\t     \txH=cmp(L[i],R[i],vx*(vy/g)),\n\t\t     \tyH=cmp(B[i],T[i],cal(vy,vy/g));\n\t\t    if(xH==0&&yH>=0&&yL<0) ok=false;\n\t\t    if(yL*yR<=0) ok=false;\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid slove(){\n\tfor(int i=0;i<N;i++)\n\t\tR[i]=min(X,R[i]);\n\tbool ok=check(X,Y);\n\tfor(int i=0;i<N;i++){\n\t\tok|=check(L[i],T[i]);\n\t\tok|=check(R[i],T[i]);\n\t}\n\tprintf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nvoid MAIN()\n{\n\tscanf(\"%d%d%d%d\",&N,&V,&X,&Y);\n\tfor(int i=0;i<N;i++) scanf(\"%d%d%d%d\",&L[i],&B[i],&R[i],&T[i]);\n\tslove();\n}\n\nint main()\n{\n//\tfreopen(\"in#pro.txt\",\"r\",stdin);\n//\tfreopen(\"out#pro.txt\",\"w\",stdout);\n\tMAIN();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         rec[i].r = min(xx,rec[i].r);\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && yy-rec[i].b>eps && rec[i].t-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && hh-rec[i].b>eps && rec[i].t-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n         {\n              if ( rec[i].b-hi>eps ) return true;//抛物&#32447;没有&#30896;到矩形 \n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;从矩形上方&#39134;&#36807; \n              if ( rec[i].b-h1>eps && hh-rec[i].b>eps ) return false;//pig的&#23545;&#24212;点高于矩形的下&#36793;界\n              if ( len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps ) return false; //矩形最高点高于矩形下&#36793;界\n              \n              return true; \n         }\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-8;\n\nint cmp(double a,double b)\n{\n    if (fabs(a-b) < eps)    return 0;\n    if (a < b)  return -1;\n    return 1;\n}\n\nconst double g = 9.8;\nint n;\ndouble v,x,y,L[50],B[50],R[50],T[50],a,b,vx,vy,dv;\nbool res;\n\nbool Gao(double a,double b)\n{\n    //y = a*x^2+b*x\n    double ty = a*x*x+b*x;\n    if (cmp(ty,y) < 0)  return false;\n    double tyl,tyr,xa,xb;\n    for (int i = 0; i < n; i++)\n    {\n        if (cmp(L[i],x) < 0 && cmp(x,R[i]) < 0 && cmp(T[i],ty) < 0) return false;\n        tyl = a*L[i]*L[i]+b*L[i];\n        tyr = a*R[i]*R[i]+b*R[i];\n        if (cmp(B[i],tyl) < 0 && cmp(tyl,T[i]) < 0)   return false;\n        if (cmp(B[i],tyr) < 0 && cmp(tyr,T[i]) < 0)   return false;\n        xa = (-b+sqrt(b*b+4*a*T[i]))/(2*a);\n        xb = (-b-sqrt(b*b+4*a*T[i]))/(2*a);\n        if (cmp(L[i],xa) < 0 && cmp(xa,R[i]) < 0)   return false;\n        if (cmp(L[i],xb) < 0 && cmp(xb,R[i]) < 0)   return false;\n        xa = (-b+sqrt(b*b+4*a*B[i]))/(2*a);\n        xb = (-b-sqrt(b*b+4*a*B[i]))/(2*a);\n        if (cmp(L[i],xa) < 0 && cmp(xa,R[i]) < 0)   return false;\n        if (cmp(L[i],xb) < 0 && cmp(xb,R[i]) < 0)   return false;\n    }\n    return true;\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y) != EOF)\n    {\n        for (int i = 0;i < n;i++)\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        dv = v/500000.0;\n        res = false;\n        for (int i = 1;i <= 500000;i++)\n        {\n            vx = i*dv;\n            vy = sqrt(v*v-vx*vx);\n            a = -g/(2*vx*vx);\n            b = vy/vx;\n            res |= Gao(a,b);\n            if (res == true)\n            {\n                //cout << ' ' << vx << ' ' << vy << ' ' << a << ' ' << b << endl;\n                break;\n            }\n        }\n        if (res == true)    puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst int N = 55;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\nconst double g = 9.8;\nstruct Rect{\n\tdouble lft,dwn,rgt,upp;\n\tvoid input(){\n\t\tscanf(\"%lf%lf%lf%lf\",&lft,&dwn,&rgt,&upp);\n\t}\n}rect[N];\nint n;\ndouble vmax,x,y;\ndouble calcy(double ang, double dx, double v) {\n\treturn dx/tan(ang)-dx*dx*g/2/v/v/sin(ang)/sin(ang);\n}\nbool solve(double ang) {\n\tif(x/tan(ang)-y <= 0) return false;\n\tdouble v = x/sin(ang)*sqrt(g/2/(x/tan(ang)-y));\n\tif(v > vmax) return false;\n\tdouble y1, y2;\n\tint f1, f2;\n\tfor(int i = 0; i < n; ++ i) {\n\t\ty1 = calcy(ang, rect[i].lft, v);\n\t\tif(y1 > rect[i].upp) f1 = 1;\n\t\telse if (y1 < rect[i].dwn) f1 = -1;\n\t\telse f1 = 0;\n\t\tif (f1 == 0) return false;\n\t\ty2 = calcy(ang, rect[i].rgt, v);\n\t\tif (y2 > rect[i].upp) f2 = 1;\n\t\telse if (y2 < rect[i].dwn) f2 = -1;\n\t\telse f2 = 0;\n\t\tif (f1 != f2) return false;\n\t}\n\treturn true;\n}\nbool solve() {\n\tdouble ang = eps;\n\twhile(ang < PI/2) {\n\t\tif(solve(ang)) return true;\n\t\tang += eps;\n\t}\n\treturn false;\n}\nint main() {\n\twhile(scanf(\"%d%lf%lf%lf\",&n,&vmax,&x,&y)!=EOF){\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\trect[i].input();\n\t\t}\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 4.9;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n\n//  = -(gx2/v2)tan2 + xtan - y\n\nstruct Box{\n\tP p1,p2,p3,p4;\n};\nvector<Box> box;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nbool inner(double a,double b,double c){\n\treturn a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n\tdouble a = - g / V / V * (1+tanv * tanv);\n\tdouble b = tanv;\n\tauto f = [a,b](double x){\n\t\treturn a * x * x + b * x;\n\t};\n\tauto g = [a,b](double y){\t\n\t\tvector<double> ps;\n\t\tdouble c = -y;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\treturn ps;\n\t\t}\n\t\tif( D < EPS ) D = 0;\n\t\tdouble x1 = (-b+D)/(2*a);\n\t\tdouble x2 = (-b-D)/(2*a);\n\t\tps = {x1,x2};\n\t\treturn ps;\n\t};\n\t\n\t\n\tdouble hx = 1e9;\n\tdouble hy = 1e9;\n\tvector<double> uxtmp;\n\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) and b.p1.y() > Y ){\n\t\t\thy = min(hy,b.p1.y());\n\t\t}\n\t}\n\tfor( auto b : box ){\n\t\tdouble x = b.p1.x();\n\t\tuxtmp.push_back(x);\n\t\tdouble y = f(x);\n\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble x = b.p2.x();\n\t\tdouble y = f(x);\n\t\tuxtmp.push_back(x);\n\t\tif( inner(b.p2.y(),y,b.p3.y()) ){\n\t\t\thx = min(x,hx);\n\t\t}\n\t}\n\t\n\tfor( auto b : box ){\n\t\tdouble y = b.p1.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( auto b : box ){\n\t\tdouble y = b.p3.y();\n\t\tfor( double x : g(y) ){\n\t\t\tuxtmp.push_back(x);\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\thx = min(x,hx);\n\t\t\t}\n\t\t}\n\t}\n\tsort(uxtmp.begin(),uxtmp.end());\n\tvector<double> ux;\n\tfor(int i = 0 ; i < uxtmp.size() ; i++)\n\t\tif( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n\t\t\tux.push_back(uxtmp[i]);\n\t\t\t\n\tfor( auto b : box ){\n\t\tif( inner(b.p1.x(),X,b.p2.x()) ){\n\t\t\tif( inner(b.p1.y(),Y,b.p4.y()) ){\n\t\t\t\thx = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\n\t\tdouble x = (ux[i] + ux[i+1] ) / 2;\n\t\tdouble y = f(x);\n\n\t\tfor( auto b : box ){\n\t\t\tif( inner(b.p1.x(),x,b.p2.x()) ){\n\t\t\t\tif( inner(b.p1.y(),y,b.p4.y()) ){\n\t\t\t\t\thx = min(ux[i],hx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << f(1) << endl;\n\t//cout << hy << endl;\n\t//cout << V << \" \" << tanv << \" \" << a << \" \" << b << \" \" << X << \" \" << f(X)  << endl;\n\tif( hx - EPS > X ){\n\t\t//cout << f(X) << \" \" << Y - EPS << endl;\n\t\tif( f(X) > Y - EPS and f(X) < hy - EPS ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t//cout << atan(tanv) << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\t\t\n\t\n\t\n\t\n\t\n}\n\n\nint main(){\n\n\tcin >> N;\n\tcin >> V >> X >> Y;\n\n\t\n\tvector<P> ps;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP a,b;\n\t\ta = in();\n\t\tb = in();\n\t\t//ps.push_back(a);\n\t\t//ps.push_back(P(b.x(),a.y()));\n\t\tps.push_back(b);\n\t\tps.push_back(P(a.x(),b.y()));\n\t\tbox.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});\t\t\n\t\t\n\t}\n\tfor(int i = 0 ; i < 3000 ; i++){\n\t\ttrying(0.001*i);\n\t}\n\tif(true){\n\t\tdouble x = X;\n\t\tdouble y = Y;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\t\t//cout << a << \" \" << b << \" \" << c << \" ( \" << g << \" \" << V << \" \" << x << endl;\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\t\n\t\t}else{\n\t\t\tD = max(0.0,D);\n\t\t\tD = sqrt(D);\n\t\t\tdouble t1 = (-b+D)/(2*a);\n\t\t\tdouble t2 = (-b-D)/(2*a);\n\t\t\ttrying(t1);\n\t\t\ttrying(t2);\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tdouble x = ps[i].x();\n\t\tdouble y = ps[i].y();\n\t\tif( x == 0 ) continue;\n\t\tdouble a = -g/V/V*x*x;\n\t\tdouble b = x;\n\t\tdouble c = -y-g/V/V*x*x;\n\n\n\t\tdouble D = b*b-4*a*c;\n\t\tif( D < -EPS ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t//printf(\"%.20lf\\n\",D);\t\t\n\t\tif( D < EPS ) D = 0;\n\n\t\t\n\t\tdouble t1 = (-b+D)/(2*a);\n\t\tdouble t2 = (-b-D)/(2*a);\n\t\ttrying(t1);\n\t\ttrying(t2);\n\t}\n\t\n\tcout << \"No\" << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x() real()\n#define y() imag()\n#define x1 jfwekljfwklj\n#define x2 jfwekljwefkjklf\ntypedef complex<double> P;\nconst double g = 4.9;\nconst double EPS = 1e-8;\nint N;\ndouble V,X,Y;\n \n//  = -(gx2/v2)tan2 + xtan - y\n \nstruct Box{\n    P p1,p2,p3,p4;\n};\nvector<Box> box;\n \nP in(){\n    double x,y;\n    cin >> x >> y;\n    return P(x,y);\n}\n \nbool inner(double a,double b,double c){\n    return a + EPS < b and b < c - EPS;\n}\nvoid trying(double tanv){\n    double a = - g / V / V * (1+tanv * tanv);\n    double b = tanv;\n    auto f = [a,b](double x){\n        return a * x * x + b * x;\n    };\n    auto g = [a,b](double y){   \n        vector<double> ps;\n        double c = -y;\n        double D = b*b-4*a*c;\n        if( D < -EPS ){\n            return ps;\n        }\n        if( D < EPS ) D = 0;\n        D = sqrt(D);\n        double x1 = (-b+D)/(2*a);\n        double x2 = (-b-D)/(2*a);\n        ps = {x1,x2};\n        return ps;\n    };\n     \n     \n    double hx = 1e9;\n    double hy = 1e9;\n    vector<double> uxtmp;\n     \n    for( auto b : box ){\n        if( inner(b.p1.x(),X,b.p2.x()) and b.p1.y() > Y ){\n            hy = min(hy,b.p1.y());\n        }\n    }\n    for( auto b : box ){\n        double x = b.p1.x();\n        uxtmp.push_back(x);\n        double y = f(x);\n        if( inner(b.p1.y(),y,b.p4.y()) ){\n            hx = min(x,hx);\n        }\n    }\n     \n    for( auto b : box ){\n        double x = b.p2.x();\n        double y = f(x);\n        uxtmp.push_back(x);\n        if( inner(b.p2.y(),y,b.p3.y()) ){\n            hx = min(x,hx);\n        }\n    }\n     \n    for( auto b : box ){\n        double y = b.p1.y();\n        for( double x : g(y) ){\n            uxtmp.push_back(x);\n            if( inner(b.p1.x(),x,b.p2.x()) ){\n                hx = min(x,hx);\n            }\n        }\n    }\n \n    for( auto b : box ){\n        double y = b.p3.y();\n        for( double x : g(y) ){\n            uxtmp.push_back(x);\n            if( inner(b.p1.x(),x,b.p2.x()) ){\n                hx = min(x,hx);\n            }\n        }\n    }\n    sort(uxtmp.begin(),uxtmp.end());\n    vector<double> ux;\n    for(int i = 0 ; i < uxtmp.size() ; i++)\n        if( !i or uxtmp[i] - uxtmp[i-1] > EPS )\n            ux.push_back(uxtmp[i]);\n             \n    for( auto b : box ){\n        if( inner(b.p1.x(),X,b.p2.x()) ){\n            if( inner(b.p1.y(),Y,b.p4.y()) ){\n                hx = -1e9;\n            }\n        }\n    }\n    for(int i = 0 ; i+1 < ux.size() ; i++){\n \n        double x = (ux[i] + ux[i+1] ) / 2;\n        double y = f(x);\n        for( auto b : box ){\n            if( inner(b.p1.x(),x,b.p2.x()) ){\n                if( inner(b.p1.y(),y,b.p4.y()) ){\n                    hx = min(ux[i],hx);\n                }\n            }\n        }\n    }\n    //cout << f(1) << endl;\n    //cout << hy << endl;\n    //cout << V << \" \" << tanv << \" \" << a << \" \" << b << \" \" << X << \" \" << f(X)  << endl;\n    if( hx + EPS > X ){\n        //cout << f(X) << \" \" << Y - EPS << endl;\n        if( f(X) > Y - EPS and f(X) < hy - EPS ){\n            cout << \"Yes\" << endl;\n            //cout << atan(tanv) << endl;\n            exit(0);\n        }\n    }\n     \n         \n     \n     \n     \n     \n}\n \n \nint main(){\n \n    cin >> N;\n    cin >> V >> X >> Y;\n \n     \n    vector<P> ps;\n    for(int i = 0 ; i < N ; i++){\n        P a,b;\n        a = in();\n        b = in();\n        ps.push_back(a);\n        ps.push_back(P(b.x(),a.y()));\n        ps.push_back(b);\n        ps.push_back(P(a.x(),b.y()));\n        box.push_back({P(a.x(),a.y()),P(b.x(),a.y()),P(b.x(),b.y()),P(a.x(),b.y())});       \n         \n    }\n    for(int i = 0 ; i < 3000 ; i++){\n        trying(0.001*i);\n    }\n    if(true){\n        double x = X;\n        double y = Y;\n        double a = -g/V/V*x*x;\n        double b = x;\n        double c = -y-g/V/V*x*x;\n        //cout << a << \" \" << b << \" \" << c << \" ( \" << g << \" \" << V << \" \" << x << endl;\n        double D = b*b-4*a*c;\n        if( D < -EPS ){\n             \n        }else{\n            D = max(0.0,D);\n            D = sqrt(D);\n            double t1 = (-b+D)/(2*a);\n            double t2 = (-b-D)/(2*a);\n            trying(t1);\n            trying(t2);\n        }\n    }\n     \n    for(int i = 0 ; i < ps.size() ; i++){\n        double x = ps[i].x();\n        double y = ps[i].y();\n        if( x == 0 ) continue;\n        double a = -g/V/V*x*x;\n        double b = x;\n        double c = -y-g/V/V*x*x;\n \n \n        double D = b*b-4*a*c;\n        if( D < -EPS ){\n            continue;\n        }\n         \n        //printf(\"%.20lf\\n\",D);     \n        if( D < EPS ) D = 0;\n \n         \n        double t1 = (-b+D)/(2*a);\n        double t2 = (-b-D)/(2*a);\n        trying(t1);\n        trying(t2);\n    }\n     \n    cout << \"No\" << endl;\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define maxn 55\nconst double g=9.8;\ndouble EPS=1e-6;\nint N, V, X ,Y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\ndouble calc(double vy, double t) {\n    return vy*t-g*t*t/2;\n}\nint cmp(double lb, double ub, double a) {\n    return a<lb+EPS?-1:a>ub-EPS?1:0;\n}\nbool check(double qx, double qy) {\n    double a=g*g/4, b=g*qy-V*V, c=qx*qx+qy*qy;\n    double D=b*b-4*a*c;\n    if (D<0&&D>-EPS)\n        D=0;\n    if (D<0)\n        return false;\n    for (int d=-1; d<=1; d+=2) {\n        double t2=(-b+d*sqrt(D))/(2*a);\n        if (t2<=0)\n            continue;\n        double t=sqrt(t2);\n        double vx=qx/t, vy=(qy+g*t*t/2)/t;\n        double yt=calc(vy, X/vx);\n        if (yt<Y-EPS)\n            continue;\n        bool ok=true;\n        for (int i=0; i<N; i++) {\n            if (L[i]>=X)\n                continue;\n            if (R[i]==X&&Y<=T[i]&&B[i]<=yt)\n                ok=false;\n            int yL=cmp(B[i], T[i], calc(vy, L[i]/vx));\n            int yR=cmp(B[i], T[i], calc(vy, R[i]/vx));\n            int xH=cmp(L[i], R[i], vx*(vy/g));\n            int yH=cmp(B[i], T[i], calc(vy, vy/g));\n            if (xH==0&&yH>=0&&yL<0)\n                ok=false;\n            if (yL*yR<=0)\n                ok=false;\n        }\n        if (ok)\n            return true;\n    }\n    return false;\n}\nvoid solve() {\n    for (int i=0; i<N; i++)\n        R[i]=min(R[i], X);\n    bool ok=check(X, Y);\n    for (int i=0; i<N; i++) {\n        ok|=check(L[i], T[i]);\n        ok|=check(R[i], T[i]);\n    }\n    puts(ok?\"Yes\":\"No\");\n}\nint main()\n{\n    scanf(\"%d%d%d%d\", &N, &V, &X, &Y);\n    for (int i=0; i<N; i++)\n        scanf(\"%d%d%d%d\", &L[i], &B[i], &R[i], &T[i]);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\ndouble K;\ndouble v;\n\nvoid kouhoth(int x, int y, vector<double> &TH)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\tif(d<0) return;\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\tif(kai1+EPS>0) TH.push_back(atan(kai1+EPS));\n\tif(kai1-EPS>0) TH.push_back(atan(kai1-EPS));\n\tif(kai2+EPS>0) TH.push_back(atan(kai2+EPS));\n\tif(kai2-EPS>0) TH.push_back(atan(kai2-EPS));\n}\n\ndouble f(double th, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble naka = 1.0*x - K*si*co;\n\treturn alpha * naka*naka + beta;\n}\n\nint main(){\n\tint n;\n\tint x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> L, B, R, T;\n\t\tvector<double> TH;\n\t\tK = 1.0*v*v/g;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\tif(x<l) continue;\n\t\t\tif(x<r) r = x;\n\t\t\tL.push_back(l);\n\t\t\tB.push_back(b);\n\t\t\tR.push_back(r);\n\t\t\tT.push_back(t);\n\t\t\tkouhoth(l,b,TH);\n\t\t\tkouhoth(r,b,TH);\n\t\t\tkouhoth(l,t,TH);\n\t\t\tkouhoth(r,t,TH);\n\t\t}\n\t\tkouhoth(x,y,TH);\n\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<TH.size(); i++){\n\t\t\tdouble th = TH[i];\n\t\t\tdouble mauey = f(th,x);\n\t\t\tif(mauey < y) continue;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<L.size(); j++){\n\t\t\t\tif(\n\t\t\t\t\t(f(th,L[j])<B[j]&&f(th,R[j])<B[j]) ||\n\t\t\t\t\t(f(th,L[j])>T[j]&&f(th,R[j])>T[j]) ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<L.size(); j++){\n\t\t\t\t\tif(R[j]==x){\n\t\t\t\t\t\tif(y<T[j] && T[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define MP make_pair\n#define PB push_back\n\ntypedef double DB;\ntypedef long long LL;\n\nconst DB EPS = 1e-8;\nconst DB PI = acos(-1);\nconst DB gg = 9.8;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\n\n\ninline void checkMin(int &a, int b){\n    if (b < a) a = b;\n}\n\ninline int sgn(double x){\n    return x < -EPS ? -1 : x > EPS;\n}\n\nconst int N = int(1e2) + 9;\nint n, l[N], b[N], r[N], t[N];\nint X, Y; DB V; int low;\n\ninline DB y(DB a, DB x) {\n    DB t = x/(V*cos(a));\n    return V*sin(a)*t - 0.5*gg*t*t;\n}\n\ninline DB getM(DB a){\n    DB t = V*sin(a)/gg;\n    return V*cos(a)*t;\n}\n\nbool ck(DB a) {\n\n    DB h = y(a, X); if (sgn(h-Y) < 0 || sgn(h-low) > 0 ) return false;\n    DB mx = getM(a), my = y(a, mx);\n\n    REP(i, n){\n\n        DB h1 = y(a, l[i]), h2 = y(a, r[i]);\n\n        if (l[i] <= mx && mx <= r[i]){\n            if (!(h1 <= b[i] && h2 <= b[i] && my <= b[i] || h1 >= t[i] && h2 >= t[i] && my >= t[i])) return false;\n        }\n        else{\n            if (!(h1 <= b[i] && h2 <= b[i] || h1 >= t[i] && h2 >= t[i])) return false;\n        }\n    }\n    return true;\n}\n\nbool ck() {\n\n    REP(i, n){\n        if (l[i] == 0 && b[i] == 0) return false;\n        if (l[i] <= X && X <= r[i]  && b[i] <= Y && Y <= t[i]) return false;\n    }\n\n    DB d = PI/2/15000;\n    for (DB a=d;a<=PI/2;a+=d) if (ck(a)) return true;\n    return false;\n}\n\nint main() {\n    freopen(\"in.txt\", \"r\", stdin);\n    while (~scanf(\"%d%lf%d%d\", &n, &V, &X, &Y)) {\n        low = INF; REP(i, n){\n            scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n            if (l[i] > X){\n                --i; --n;\n                continue;\n            }\n            if (r[i] >= X){\n                if (b[i] >= Y) checkMin(low, b[i]);\n                r[i] = X;\n            }\n        }\n        puts(ck() ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && yy-rec[i].b>eps && rec[i].t-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-rec[i].l>eps && rec[i].r-xx>eps && hh-rec[i].b>eps && rec[i].t-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n         {\n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;从矩形上方&#39134;&#36807; \n              if ( rec[i].b-h1>eps && hh-rec[i].b>eps ) return false;//pig的&#23545;&#24212;点高于矩形的下&#36793;界\n              if ( len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps ) return false; //矩形最高点高于矩形下&#36793;界\n              //return true; \n         } \n         if ( rec[i].r-xx>eps )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld t1 = (ld)l/vx;\n  ld t2 = (ld)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  bool ok = true;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) ok = false;\n  }\n  REP(i,N){\n    REP(j,N){\n      if(check(L[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(L[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n    }\n    if(ok == false) break;\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-8;\n\nint cmp(double a,double b)\n{\n    if (fabs(a-b) < eps)    return 0;\n    if (a < b)  return -1;\n    return 1;\n}\n\nconst double g = 9.8;\nint n;\ndouble v,x,y,L[50],B[50],R[50],T[50],a,b,vx,vy,dv;\nbool res;\n\nbool Gao(double a,double b)\n{\n    //y = a*x^2+b*x\n    double ty,tx;\n    ty = a*x*x+b*x;\n    if (cmp(ty,y) < 0)  return false;\n    double tyl,tyr;\n    for (int i = 0;i < n;i++)\n    {\n        if (cmp(L[i],x) < 0 && cmp(x,R[i]) < 0 && cmp(T[i],ty) <= 0) return false;\n        tyl = a*L[i]*L[i]+b*L[i];\n        if (cmp(B[i],tyl) < 0 && cmp(tyl,T[i]) < 0)   return false;\n        tyr = a*R[i]*R[i]+b*R[i];\n        if (cmp(B[i],tyr) < 0 && cmp(tyr,T[i]) < 0)   return false;\n        if (cmp(T[i],tyl) >= 0 && cmp(tyr,T[i]) < 0)    return false;\n        if (cmp(B[i],tyl) <= 0 && cmp(tyr,B[i]) > 0)    return false;\n        tx = (-b+sqrt(b*b+4*a*B[i]))/(2*a);\n        if (cmp(L[i],tx) < 0 && cmp(tx,R[i]) < 0)   return false;\n        tx = (-b-sqrt(b*b+4*a*B[i]))/(2*a);\n        if (cmp(L[i],tx) < 0 && cmp(tx,R[i]) < 0)   return false;\n        tx = (-b+sqrt(b*b+4*a*T[i]))/(2*a);\n        if (cmp(L[i],tx) < 0 && cmp(tx,R[i]) < 0)   return false;\n        tx = (-b-sqrt(b*b+4*a*T[i]))/(2*a);\n        if (cmp(L[i],tx) < 0 && cmp(tx,R[i]) < 0)   return false;\n    }\n    return true;\n}\n\nint main()\n{\n    while (scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y) != EOF)\n    {\n        res = true;\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n            if (cmp(L[i],R[i]) > 0) swap(L[i],R[i]);\n            if (cmp(B[i],T[i]) > 0) swap(B[i],T[i]);\n            if (cmp(L[i],x) < 0 && cmp(x,R[i]) < 0 && cmp(B[i],y) < 0 && cmp(y,T[i]) < 0)\n                res = false;\n        }\n        if (cmp(x,0) == 0)\n        {\n            if (cmp(v*v/(2*g),y) < 0)   res = false;\n            for (int i = 0; i < n; i++)\n                if (cmp(L[i],x) < 0 && cmp(x,R[i]) < 0 && cmp(T[i],y) <= 0)\n                {\n                    res = false;\n                    break;\n                }\n        }\n        if (res == true)\n        {\n            res = false;\n            dv = v/500000.0;\n            for (int i = 1; i <= 500000; i++)\n            {\n                vx = i*dv;\n                vy = sqrt(v*v-vx*vx);\n                a = -g/(2*vx*vx);\n                b = vy/vx;\n                res |= Gao(a,b);\n                if (res == true)    break;\n            }\n        }\n        if (res == true)    puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst double eps = 1e-10;\nconst int MAX_N = 40000;\nint N;\ndouble x[MAX_N], y[MAX_N], r[MAX_N];\n\nbool inside(int i, int j) {\n\tdouble dx = x[i]-x[j], dy = y[i]-y[j];\n\treturn (dx*dx + dy*dy < r[j]*r[j] + eps);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%lf%lf%lf\", r+i, x+i, y+i);\n\n\tvector<pair<double,int> > events;\n\tfor (int i = 0; i < N; ++i) {\n\t\tevents.push_back(make_pair(x[i]-r[i], i));\n\t\tevents.push_back(make_pair(x[i]+r[i], i+N));\n\t}\n\tsort(events.begin(), events.end());\n\n\tset<pair<double,int> > outers;\n\tvector<int> res;\n\tfor (int i = 0; i < events.size(); ++i) {\n\t\tint id = events[i].second % N;\n\t\tif (events[i].second < N) {\n\t\t\tset<pair<double,int> >::iterator it = outers.lower_bound(make_pair(y[id], id));\n\t\t\tif (it != outers.end() && inside(id, it->second)) continue;\n\t\t\tif (it != outers.begin() && inside(id, (--it)->second)) continue;\n\t\t\tres.push_back(id);\n\t\t\touters.insert(make_pair(y[id], id));\n\t\t}\n\t\telse {\n\t\t\touters.erase(make_pair(y[id], id));\n\t\t}\n\t}\n\n\tsort(res.begin(), res.end());\n\tprintf(\"%d\\n\", res.size());\n\tfor (int i = 0; i < res.size(); ++i) {\n\t\tprintf(\"%d%c\", 1+res[i], i==res.size()-1?'\\n': ' ');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef complex<double> Point;\nconst double G = 9.8, EPS = 1.0e-11;\nint N;\ndouble V;\nPoint aim;\nvector<Point> L, R;\n\ndouble calc(double vy, double t) {\n    return vy * t - G * t * t / 2.0;\n}\n\nint cmp(double lb, double ub, double a) {\n    return a < lb + EPS ? -1: a > ub - EPS ? 1: 0;\n}\nbool check(Point q) {\n    double qx = q.real(), qy = q.imag();\n    double a = G * G / 4, b = G * qy - V * V, c = qx * qx + qy * qy;\n    double D = b * b - 4 * a * c;\n    if(D < 0 && D > -EPS) D = 0.0;\n    if(D < 0) return false;\n    for(int d = -1; d <= 1; d += 2) {\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if(t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = qx / t, vy = (qy + G * t * t / 2.0) / t;\n\n        double yt = calc(vy, aim.real() / vx);\n        if(yt < aim.imag() - EPS) continue;\n\n        bool ok = true;\n        rep(i, N) {\n            if(L[i].real() >= aim.real()) continue;\n            if(R[i].real() == aim.real() && aim.imag() <= R[i].imag() && L[i].imag() <= yt) ok = false;\n            int yL = cmp(L[i].imag(), R[i].imag(), calc(vy, L[i].real() / vx));\n            int yR = cmp(L[i].imag(), R[i].imag(), calc(vy, R[i].real() / vx));\n            int xH = cmp(L[i].real(), R[i].real(), vx * (vy / G));\n            int yH = cmp(L[i].imag(), R[i].imag(), calc(vy, vy / G));\n            if(xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if(yL * yR <= 0) ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N >> V >> aim.real() >> aim.imag();\n    L.resize(N); R.resize(N);\n    double a, b, c, d;\n    rep(i, N) {\n        cin >> a >> b >> c >> d;\n        L[i] = Point(a, b);\n        R[i] = Point(min(c, aim.real()), d);\n    }\n    bool ok = check(aim);\n    rep(i, N) {\n        ok |= check(L[i]);\n        ok |= check(R[i]);\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define N 60\nusing namespace std;\n\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst double g=9.8;\n\ninline int dlcmp(double x) {return x<-eps?-1:x>eps;}\ninline double sqr(double x) {return x*x;}\n\ndouble A,B;\n\nstruct Point\n{\n\tdouble x,y;\n\n\tPoint (){}\n\tPoint (double a,double b):x(a),y(b){}\n\n\tvoid input() {scanf(\"%lf%lf\",&x,&y);}\n};\n\nstruct Rectange\n{\n\tdouble x1,x2,y1,y2;\n\n\tRectange (){}\n\tRectange (double a,double b,double c,double d):x1(a),x2(b),y1(c),y2(d){}\n\n\tvoid input() {scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);}\n\n\tbool inRectange(Point o)\n\t{\n\t\tif (dlcmp(o.x-x1)>0&&dlcmp(o.x-x2)<0&&\n\t\t\tdlcmp(o.y-y1)>0&&dlcmp(o.y-y2)<0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tbool isIntersect()\n\t{\n\t\tPoint o(-B/(2*A),-sqr(B)/(4*A));\n\t\tif (inRectange(o))\n\t\t\treturn true;\n\n\t\tdouble yL=A*sqr(x1)+B*x1;\n\t\tdouble yR=A*sqr(x2)+B*x2;\n\t\tif (dlcmp(yL-y2)>=0&&dlcmp(yR-y2)>=0||\n\t\t\tdlcmp(yL-y1)<=0&&dlcmp(yR-y1)<=0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\n};\n\nRectange rec[N];\nPoint target;\ndouble topY;\nint n;\n\nbool check()\n{\n\tdouble curY=A*sqr(target.x)+B*target.x;\n\n\tif (dlcmp(curY-topY)>=0||dlcmp(curY-target.y)<0)\n\t\treturn false;\n\n\tfor (int i=0;i<n;i++)\n\t\tif (rec[i].isIntersect())\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tint i,ans,flag;\n\tdouble V,vx,vy;\n\n\twhile (scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tscanf(\"%lf\",&V);\n\t\ttarget.input();\n\n\t\tfor (i=0;i<n;i++)\n\t\t\trec[i].input();\n\n\n\t\ttopY=100000.0;\n\t\tflag=0;\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tif (rec[i].inRectange(target))\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dlcmp(rec[i].x1-target.x)<=0&&dlcmp(rec[i].x2-target.x)>=0&&\n\t\t\t\tdlcmp(rec[i].y1-target.y)>=0)\n\t\t\t\ttopY=min(topY,rec[i].y2);\n\t\t}\n\n\t\tif (flag)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tans=0;\n\t\t//printf(\"topY %.3f\\n\",topY);\n\n\t\tdouble delta=0.5*PI/1000000;\n\t\tdouble ang=0;\n\n\t\twhile (dlcmp(ang-0.5*PI)<0)\n\t\t{\n\t\t\tvx=V*cos(ang);\n\t\t\tvy=V*sin(ang);\n\t\t\tA=-0.5*g/sqr(vx);\n\t\t\tB=vy/vx;\n\t\t\tif (check())\n\t\t\t{\n\t\t\t\tans=1;\n\t\t\t\t//printf(\"y %.3f %.3f %.3f %.3f\\n\",vx,vy,A,B);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tang+=delta;\n\t\t}\n\n\t\tif (ans)\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstatic const double EPS = 1e-10;\nstatic const int MAX_N = 50;\nstatic const double G = 9.8;\n\nint N;\ndouble V, X, Y;\ndouble L[MAX_N], B[MAX_N], R[MAX_N], T[MAX_N];\n\ndouble calc(double vy, double t) {\n  return vy * t - 0.5 * G * t * t;\n}\n\nint cmp(double a, double b, double x) {\n  if (x < a + EPS) return -1;\n  if (x > b - EPS) return 1;\n  return 0;\n}\n\nbool check(double tx, double ty) {\n  double a = (1.0 / 4.0) * G * G;\n  double b = G * ty - V * V;\n  double c = tx * tx + ty * ty;\n\n  double D = b * b - 4.0 * a * c;\n  if (fabs(D) <= EPS) D = 0.0;\n  if (D < 0) return false;\n  for (int d = -1; d <= 1; d+=2) {\n    double t_squared = (-b + d * sqrt(D)) / (2.0 * a);\n    if (t_squared <= 0) continue;\n\n    // calc initial velocity to hit (tx, ty)\n    double t = sqrt(t_squared);\n    double vx = tx / t;\n    double vy = (ty + 0.5 * G * t * t) / t;\n\n    // check if the course is beyond pig\n    double py = calc(vy, X / vx);\n    if (py < Y - EPS) continue;\n\n    // check if the course is clear\n    bool isClear = true;\n    for (int i = 0; i < N; i++) {\n      if (L[i] >= X) continue;\n      if (R[i] >= X && T[i] >= Y && B[i] <= py) {\n        isClear = false;\n        break;\n      }\n      double ly = calc(vy, L[i] / vx);\n      double ry = calc(vy, R[i] / vx);\n      int posL = cmp(B[i], T[i], ly);\n      int posR = cmp(B[i], T[i], ry);\n      if (posL * posR <= 0) {\n        isClear = false;\n        break;\n      }\n\n      double ht = vy / G;\n      int posX_high = cmp(L[i], R[i], vx * ht);\n      double hy = calc(vy, ht);\n      int posH = cmp(B[i], T[i], hy);\n      if (posX_high == 0 && posH >= 0 && posL < 0) {\n        isClear = false;\n        break;\n      }\n    }\n    if (isClear) return true;\n  }\n  return false;\n}\n\nbool solve() {\n  for (int i = 0; i < N; i++) {\n    R[i] = min(R[i], X);\n  }\n  if (check(X, Y)) return true;\n  for (int i = 0; i < N; i++) {\n    if (check(L[i], T[i]) || check(R[i], T[i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> V >> X >> Y;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n\n  bool isOK = solve();\n  cout << (isOK ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nconst double g = 9.8, eps = 1e-10;\nconst int maxn = 50;\n\nint N, V, X, Y;\nint L[maxn], B[maxn], R[maxn], T[maxn];\n\n//计算以vy的速度竖直向上射出t秒后的位置\ndouble calc(double vy, double t)\n{\n    return vy * t - g * t * t / 2;\n}\n\n//a相对于lb和ub的位置\nint cmp(double lb, double ub, double a)\n{\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\n\n//判断当射出路线经过点（gx，gy）时，卵是否能击中猪\nbool check(double gx, double gy)\n{\n    //设初速度在x方向和y方向的分量分别为vx和vy，设通过(gx, gy)的时间为t\n    //求解联立方程式vx^2 + vy^2 = V^2，vx * t = gx，vy * t - 1/2 g t^2 = gy\n    double a = g * g / 4, b = g * gy - V * V, c = gx * gx + gy * gy;\n    double D = b * b - 4 * a * c;\n    if (D < 0 && D > -eps) D = 0;\n    if (D < 0) return false;\n    for (int d=-1; d<=1; d+=2)\n    {//验证联立方程式的两个解的循环\n        double t2 = (-b + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double t = sqrt(t2);\n        double vx = gx / t, vy = (gy + g * t * t / 2) / t;\n        \n        //判断是否通过猪的正上方\n        double yt = calc(vy, X / vx);\n        if (yt < Y - eps) continue;\n        \n        bool ok = true;\n        for (int i=0; i<N; ++i)\n        {\n            if (L[i] >= X) continue;\n            //判断在猪正上方的鸟和猪之间是否有障碍物\n            if (R[i] == X && Y <= T[i] && B[i] <= yt) ok = false;\n            //判断在飞到猪正上方之前是否会撞到障碍物\n            int yL = cmp(B[i], T[i], calc(vy, L[i] / vx));//左侧的相对位置\n            int yR = cmp(B[i], T[i], calc(vy, R[i] / vx));//右侧的相对位置\n            int xH = cmp(L[i], R[i], vx * (vy / g));//最高点的相对位置\n            int yH = cmp(B[i], T[i], calc(vy, vy / g));\n            if (xH == 0 && yH >= 0 && yL < 0) ok = false;\n            if (yL * yR <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{//裁掉猪以右的障碍物\n    for (int i=0; i<N; ++i) R[i] = min(R[i], X);\n    bool ok = check(X, Y);//直接撞上猪的情况\n    for (int i=0; i<N; ++i)\n    {\n        ok |= check(L[i], T[i]);//经过左上角的情况\n        ok |= check(R[i], T[i]);//经过右上角的情况\n    }\n    puts(ok ? \"YES\" : \"NO\");\n    return;\n}\n\nint main()\n{\n    while (~scanf(\"%d %d %d %d\", &N, &V, &X, &Y))\n    {\n        for (int i=0; i<N; ++i)\n        {\n            scanf(\"%d %d %d %d\", &L[i], &B[i], &R[i], &T[i]);\n        }\n        solve();\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && yy-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-yy>eps )//pig在矩形中 \n             return false;\n         if ( xx-min(rec[i].l,rec[i].r)>eps && max(rec[i].r,rec[i].l)-xx>eps \n          && hh-min(rec[i].b,rec[i].t)>eps && max(rec[i].t,rec[i].b)-hh>eps )//抛物&#32447;上&#23545;&#24212;pig得点在矩形中 \n             return false;\n         double h1 = a*rec[i].l*(rec[i].l-len );//\n         double h2 = a*rec[i].r*(rec[i].r-len );//\n         if ( rec[i].l>xx ) continue;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         if ( h1<rec[i].b && h2>rec[i].b ) return false; // 撞上了障碍物 下&#36793;界 \n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;//撞上障碍物 左&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n         {\n              if (  hi-rec[i].b>eps ) return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n              else continue;\n         }\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) //pig 在一个矩形的下面 \n              if ( h1-rec[i].b>eps ) return false;//抛物&#32447;撞上了障碍物 \n         if ( rec[i].r>xx )  continue;//障碍物的右&#36793;界在pig的右&#36793;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;//撞上了障碍物 上&#36793;界 \n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst int N=100;\nconst int MAXN=1000000;\nconst double pi=acos(-1);\nconst double gg=9.8;\nint n;\ndouble v,x,y,l[N],b[N],r[N],t[N],B,A,rr[N];\nint work(double x,double y)\n{\n\tdouble yy=A * x * x + B * x;\n\t//if (fabs(yy-y) < eps) return 0;\n\tif (y > yy) return 1;\n\treturn -1;\n}\nbool check(double thi)\n{\n\tA=-gg/(2 * v * v * cos(thi) * cos(thi));\n\tB=tan(thi);\n\tdouble MAX_top=-B*B/(4 *A);\n\tfor(int i=1;i<=n;i++)\n\tif (l[i] < x+eps)\n\t{\n\t\trr[i]=min(r[i],x);\n\t\tif (work(l[i],t[i]) * work(rr[i],t[i]) <0) return 0;\n\t\tif (work(l[i],b[i]) * work(rr[i],b[i]) <0) return 0;\n\t\tif (work(l[i],t[i]) * work(l[i],b[i]) <0) return 0;\n\t\tif (r[i]<x+ eps && work(r[i],t[i]) * work(r[i],b[i]) <0) return 0;\n\t\tif (work(l[i],b[i])>0 && work(r[i],b[i])>0 && MAX_top > b[i]-eps) return 0;\n\t}\n\tif (work(x,y) > 0) return 0;\n\tdouble tmp=A * x * x + B * x;\n\tfor(int i=1;i<=n;i++)\n\t\tif (l[i]< x-eps && r[i]> x+eps)\n\t\t{\n\t\t\tif (t[i] < tmp-eps && t[i]>y+eps) return 0;\n\t\t\tif (b[i] < tmp-eps && b[i]>y+eps) return 0;\n\t\t}\n\treturn 1;\n}\nint main()\n{\n\tcin>>n>>v>>x>>y;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n\tfor(int i=1;i<MAXN;i++)\n\t{\n\t\tdouble thi=pi / 2 * i / MAXN;\n\t\tif (check(thi))\n\t\t{\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll, ll>\n#define f first\n#define s second\n#define MOD 1000000007\n#define mkp make_pair\n#define M_PI 3.14159265358979323846\n#define FOR(i,l,r) for (int i=l;i<=r;i++)\n#define FORD(i,r,l) for (int i=r;i>=l;i--)\n#define INF 2147483647\ntypedef long long ll;\n\nconst double g = 9.8;\nconst double eps = 1e-8;\n\n#define MAXN 60\nint N,V,X,Y;\nint L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble calc(double vy, double t) //given velocity in y, where is it after t sec\n{\n    return vy*t - g*t*t/2;\n}\n\nint cmp(double lb, double ub, double a)\n{\n    return a < lb+eps ? -1 : a > ub-eps ? 1 : 0;\n}\n\nbool check(double qx, double qy)//if bird passes qx, qy, will it hit pig?\n{\n    //solve for t\n    double a=g*g/4, b=g*qy-V*V, c=qx*qx+qy*qy;\n    double D = b*b - 4*a*c;\n    if(D<0 && D>-eps) D = 0;\n    if(D<0)return false;\n\n    for(int d=-1; d<=1; d+=2)//test for two solutions for t^2\n    {\n        double t2 = (-b+d*sqrt(D))/(2*a);\n        if(t2<=0)continue;\n        double t = sqrt(t2);\n        double vx=qx/t, vy=(qy+g*t*t/2)/t;\n\n        double yt = calc(vy, X/vx);\n        if(yt < Y-eps)continue;\n\n        bool ok = true;\n        for(int i = 0; i < N; i++)\n        {\n            if(L[i] >= X)continue;\n            if(R[i] >= X && Y <= T[i] && B[i] <= yt) ok = false;//?\n\n            //use int?\n            int yL = cmp(B[i], T[i], calc(vy, L[i]/vx));\n            int yR = cmp(B[i], T[i], calc(vy, R[i]/vx));\n            int xH = cmp(L[i], R[i], vx*(vy/g));\n            int yH = cmp(B[i], T[i], calc(vy, vy/g));\n\n            if(xH==0 && yH>=0 && yL<0)ok = false;\n            if(yL*yR <= 0)ok = false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nvoid solve()\n{\n    for(int i = 0; i < N; i++)R[i] = min(R[i], X); //why tho\n    bool ok = check(X, Y);\n    for(int i = 0; i < N; i++)\n    {\n        ok |= check(L[i],T[i]);\n        ok |= check(R[i],T[i]);\n    }\n    if(ok)cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> V >> X >> Y;\n    FOR(i,0,N-1)cin >> L[i] >> B[i] >> R[i] >> T[i];\n    solve();\n\n    return 0;\n}\n\n/*\nTESTCASES:\n1 7 3 1\n1 1 2 2\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 51;\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvector<double> quadraticFormula(double a, double b, double c) {\n  vector<double> x;\n  if(a == 0.0) {\n    if(b != 0.0) x.push_back(-c/b);\n  } else {\n    double d = b*b - 4.0*a*c;\n    if(d == 0.0) {\n      x.push_back(-b/(2*a));\n    } else if(d > 0.0) {\n      x.push_back((-b-sqrt(d))/(2*a));\n      x.push_back((-b+sqrt(d))/(2*a));\n    }\n  }\n  return x;\n}\n\nconst double g = 9.8;\nint N;\ndouble V, X, Y;\ndouble L[MAXN], B[MAXN], R[MAXN], T[MAXN];\n\ndouble getY(double x, double vx, double vy) {\n  return -g/(2*vx*vx) * x*x + vy/vx * x;\n}\n\nbool isHit(int i, double vx, double vy) {\n  vector<double> v;\n  vector<double> u;\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -B[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  u = quadraticFormula(-g/(2*vx*vx), vy/vx, -T[i]);\n  for(int j = 0; j < u.size(); ++j) {\n    if(L[i]-eps < u[j] && u[j] < R[i]+eps) {\n      v.push_back(u[j]);\n    }\n  }\n  {\n    double y = getY(L[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(L[i]);\n    }\n  }\n  {\n    double y = getY(R[i], vx, vy);\n    if(B[i]-eps < y && y < T[i]+eps) {\n      v.push_back(R[i]);\n    }\n  }\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end(), equals), v.end());\n  if(v.size() > 2) {\n    return true;\n  }\n  if(v.size() == 2) {\n    double mx = (v[0] + v[1]) / 2.0;\n    double my = getY(mx, vx, vy);\n    if(L[i]+eps < mx && mx < R[i]-eps && \n       B[i]+eps < my && my < T[i]-eps) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> N >> V >> X >> Y) {\n    vector<double> xs(1, X), ys(1, Y);\n    for(int i = 0; i < N; ++i) {\n      cin >> L[i] >> B[i] >> R[i] >> T[i];\n      xs.push_back(L[i]);\n      ys.push_back(B[i]);\n\n      xs.push_back(L[i]);\n      ys.push_back(T[i]);\n\n      xs.push_back(R[i]);\n      ys.push_back(B[i]);\n\n      xs.push_back(R[i]);\n      ys.push_back(T[i]);\n    }\n\n    vector<double> vxs;\n    for(int i = 0; i < xs.size(); ++i) {\n      double x = xs[i];\n      double y = ys[i];\n      vector<double> u\n        = quadraticFormula(x*x+y*y,\n                           (g*y-V*V)*x*x,\n                           g*g*x*x*x*x/4.0);\n      for(int j = 0; j < u.size(); ++j) {\n        if(u[j] <= 0) continue;\n        vxs.push_back(sqrt(u[j]));\n      }\n    }\n\n    try {\n      for(int k = 0; k < vxs.size(); ++k) {\n        const double vx = vxs[k];\n        if(V*V - vx*vx < eps) continue;\n        const double vy = sqrt(V*V - vx*vx);\n\n        {\n          bool flag = true;\n          for(int i = 0; i < N; ++i) {\n            if(X < L[i]) continue;\n            if(isHit(i, vx, vy)) {\n              flag = false;\n              break;\n            }\n          }\n          if(!flag) continue;\n        }\n\n        {\n          double py = getY(X, vx, vy);\n          if(equals(Y, py)) throw 0;\n          if(py < Y) continue;\n          bool ok = true;\n          for(int i = 0; i < N; ++i) {\n            if(L[i] < X && X < R[i] && Y < T[i] && T[i] < py+eps) {\n              ok = false;\n              break;\n            }\n          }\n          if(ok) throw 0;\n        }\n      }\n      cout << \"No\" << endl;\n    } catch(...) {\n      cout << \"Yes\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\nstruct L { P a, b; };\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   //0<θ<180 // counter clockwise\n  if (cross(b, c) < -eps) return -1; //180<θ<360 clockwise\n  if (dot(b, c) < 0) return 2;       //θ=180// c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  double vx = V * px / sqrt(px*px+px*px);\n  double vy = V * py / sqrt(px*px+py*py);\n  double t1 = (double)l/vx;\n  double t2 = (double)r/vx;\n  double wY1 = vy*t1 + G*t1*t1/2;\n  double wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  bool ok = true;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) ok = false;\n  }\n  REP(i,N){\n    REP(j,N){\n      if(check(L[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(L[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],T[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n      if(check(R[i],B[i],L[j],R[j],B[j],T[j])<=0) ok = false;\n    }\n    if(ok == false) break;\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nconst int MAX_N = 50;\ndouble V,X,Y;\nconst double G = 9.8;\ndouble L [MAX_N],B [MAX_N],R [MAX_N],T [MAX_N];\nconst double EPS = 1e-10;\n\ndouble calc(double t,double v)\n{\n\treturn v * t - G * t * t / 2;\n}\n\nbool check(double px,double py)\n{\n\tdouble a = G * G / 4,b = py * G - V * V,c = px * px + py * py;\n\tdouble D = b * b - 4 * a * c;\n\tif(abs(D) < EPS) D = 0;\n\tif(D < 0.0) return false;\n\tfor(int d = -1;d <= 1;d += 2){\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif(abs(t2) < EPS) t2 = 0.0;\n\t\tif(t2 < 0.0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = px / t,vy = sqrt(V * V - vx * vx);\n\t\tbool ok = calc(X / vx,vy) >= Y - EPS;\n\t\tFOR(i,0,N){\n\t\t\tbool b = calc(L [i] / vx,vy) >= T [i] - EPS;\n\t\t\tb &= calc(R [i] / vx,vy) >= T [i] - EPS;\n\t\t\tif(b){\n\t\t\t\tif(L [i] < X + EPS && X - EPS < R [i]){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb = calc(L [i] / vx,vy) <= B [i] + EPS;\n\t\t\t\tb = calc(R [i] / vx,vy) <= B [i] + EPS;\n\t\t\t\tif(b == false){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf%lf\",&N,&V,&X,&Y);\n\tFOR(i,0,N){\n\t\tscanf(\"%lf%lf%lf%lf\",&L [i],&B [i],&R [i],&T [i]);\n\t}\n\n\tbool ans = check(X,Y);\n\tFOR(i,0,N){\n\t\tans |= check(L [i],T [i]) || check(R [i],T [i]);\n\t}\n\tputs(ans ? \"Yes\" : \"No\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-8\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;\n     if ( yy-hh>eps ) return false;\n     for ( i=1;i<=n;i++ )\n     {\n         double h1 = a*rec[i].l*(rec[i].l-len );\n         double h2 = a*rec[i].r*(rec[i].r-len );\n         if ( len/2<rec[i].l && len/2<rec[i].r && hi<rec[i].t && hi>rec[i].b ) return false;\n         if ( rec[i].l>xx ) continue;\n         if ( h1-rec[i].b>eps && rec[i].t-h1>eps ) return false;\n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].t>yy ) return false;\n         if ( rec[i].r>xx )  continue;\n         if ( h2-rec[i].b>eps && rec[i].t-h2>eps ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=100000;i++ )\n     {\n           vy=double(i)/100000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               if ( len<eps )\n               {\n                    if ( h-yy>eps ) printf(\"Yes\\n\");\n                    else printf(\"No\\n\");\n                    return ;\n               }\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                   // cout<<i<<\" &&&&&&&&&&&&&&&&  \"<<endl;\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");          \n}\n\nint main()\n{\n    int i,flag;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          top=0;\n          flag=true;\n          for ( i=1;i<=n;i++ )\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n          /*for ( i=1;i<=n;i++ )\n              cout<<rec[i].l<<\" \"<<rec[i].b<<\" \"<<rec[i].r<<\" \"<<rec[i].t<<endl;*/\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define g 9.80\n#define eps 1e-10\nint top;\n\nint n;\ndouble v,xx,yy;\nstruct rectangle\n{\n       double l,r,b,t;\n}rec[101];\n\nbool judge(double a,double len )\n{\n     int i;\n     double hh = a*xx*(xx-len);\n     double hi = -a*len*len/4.0;//抛物&#32447;最高点的y坐&#26631; \n     if ( yy-hh>eps || yy-hi>eps ) return false;//抛物&#32447;&#39134;&#36807;pig下方 \n     for ( i=1;i<=n;i++ )\n     {\n         if ( rec[i].l>xx ) break;//障碍物的左&#36793;界大于pig的x坐&#26631; \n         double h1 = a*rec[i].l*(rec[i].l-len );//左&#36793;界&#23545;&#24212;的高度 \n         double h2 = a*rec[i].r*(rec[i].r-len );//右&#36793;界&#23545;&#24212;的高度 \n         if ( h1>=rec[i].b && h1<=rec[i].t ) return false;\n         if ( h2>=rec[i].b && h2<=rec[i].t ) return false;//撞上&#36793;界 \n         if ( h1<rec[i].b && h2<rec[i].b ) //抛物&#32447;从矩形下方&#39134;&#36807; \n              if (  len/2-rec[i].l>eps && rec[i].r-len/2>eps && hi-rec[i].b>eps  ) \n                 return false;//抛物&#32447;最高点在矩形中或者高于矩形 \n         if ( rec[i].l<=xx && rec[i].r>=xx  && rec[i].b>yy ) //pig 在一个矩形的下面 \n             if ( hh>rec[i].t ) return false;\n     }\n     return true;\n}\n\n\nvoid solve()\n{\n     int i;\n     double h,t,vx,vy,len;\n     for ( i=1;i<=1000000;i++ )\n     {\n           vy=double(i)/1000000*v;\n           vx=sqrt(v*v-vy*vy);\n           t=vy/g;\n           h = g*t*t/2;\n           len = vx*2*t;\n           if ( xx-len>eps ) continue;\n           else\n           {\n               double a = (-2*vy*vy)/(g*len*len);\n               if ( judge(a,len) )\n               {\n                    printf(\"Yes\\n\");\n                    return ;\n               }\n           }\n     }\n     printf(\"No\\n\");\n}\n\nbool cmp(rectangle a,rectangle b)\n{\n     return a.l<b.l;\n}\n\nint main()\n{\n    int i;\n    while ( scanf(\"%d %lf %lf %lf\",&n,&v,&xx,&yy)!=EOF )\n    {\n          for ( i=1;i<=n;i++ )\n          {\n              scanf(\"%lf %lf %lf %lf\",&rec[i].l,&rec[i].b,&rec[i].r,&rec[i].t);\n              rec[i].r = min(xx,rec[i].r);\n          }\n          sort(rec+1,rec+n+1,cmp);\n          solve();\n    }\n    return 0;\n}\n          \n          \n          \n          "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<list>\n\n#define MAXN 51\n#define MAXX 301\n#define g 9.8\n\nshort n,v,x,y,i,j,k;\nshort l,B,r,T;\ndouble a,b,c;\ndouble t1,t2;\ndouble vx,vy;\ndouble t;\nstd::list<double>ts;\nstd::list<double>::iterator it;\n\nbool mat[MAXX][MAXX];\n\nint main()\n{\n    scanf(\"%hd %hd %hd %hd\",&n,&v,&x,&y);\n    a=0.25*g*g;\n    b=g*y-v*v;\n    c=x*x+y*y;\n    t1=(-b+sqrt(b*b-4*a*c))/(2*a);\n    t2=(-b-sqrt(b*b-4*a*c))/(2*a);\n    ts.clear();\n    if(t1>=0)\n        ts.push_back(sqrt(t1));\n    if(t1>=0)\n        ts.push_back(sqrt(t2));\n    for(i=0;i<MAXX;++i)\n        std::fill(mat[i],mat[i]+MAXX,false);\n    for(i=0;i<n;++i)\n    {\n        scanf(\"%hd %hd %hd %hd\",&l,&B,&r,&T);\n        for(k=l;k<r;++k)\n            for(j=B;j<T;++j)\n                mat[k][j]=true;\n    }\n    for(it=ts.begin();it!=ts.end();++it)\n    {\n        vx=x/(*it);\n        vy=y/(*it)+0.5*g*(*it);\n        for(t=0;t<=(*it);t+=0.000001)\n            if(mat[(int)floor(vx*t)][(int)floor(vy*t-0.5*g*t*t)])\n                break;\n        if(t<=(*it))\n            continue;\n        else\n        {\n            puts(\"Yes\");\n            return 0;\n        }\n    }\n    puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld t1 = (ld)l/vx;\n  ld t2 = (ld)r/vx;\n  ld wY1 = vy*t1 + G*t1*t1/2;\n  ld wY2 = vy*t2 + G*t1*t1/2;\n  int rs1,rs2;\n  if(wY1>t) rs1 = 1;\n  else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n  else if(wY1 < b) rs1 = -1;\n  if(wY2>t) rs2 = 1;\n  else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n  else if(wY2 < b) rs2 = -1;\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n  if(wY3<Y) return -1;\n  else return rs1 * rs2;\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n  }\n  int flag = 0;\n  REP(i,N){\n    if((L[i]<=X)&&(X<=R[i])) flag = -1;\n  }\n  if(flag == 0){\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(L[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n        if(check(R[i],B[i],L[j],R[j],B[j],T[j])>0) flag = 1;\n      }\n    }\n    if(flag) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_min - eps < b.ys[0] && b.ys[1] < y_max + eps) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = theta;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = theta;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tup = min(up, bs[i].ys[0]);\n\t\t}\n\t}\n\tvector<ld>tans;\n\tfor (auto b : bs) {\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p,(x+y)%2);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down <= ay&&ay <= up) {\n\t\t\tbool ok = true;\n\t\t\tfor (auto b : bs) {\n\t\t\t\tif (!check(theta, b))ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define MAXN 55\n#define EPS 1e-6\n#define g 9.8\n#define PI acos(-1)\n\nstruct Obstacle\n{\n    int l;\n    int r;\n    int t;\n    int b;\n} ob[MAXN];\n\nint n,v,tx,ty;\ndouble a,b,c;\n\nvoid getabc(double angle)\n{\n    double vx = v * cos(angle); //x?方向速度\n    double vy = v * sin(angle); //y?方向速度\n    a = -0.5 * g / (vx * vx);\n    b = vy / vx;\n    c = 0;\n}\n\nbool check1(double x, double up, double down)    //是否会撞到障碍物的左（右）?端或者左（右）底端\n{\n    if(x >= tx)   //如果障碍物的x坐?在猪的x坐?的右?，?就算会撞到也不要?（?炸??死猪不受?障碍物影?）\n        return false;\n    double y = a * x * x + b * x + c;   //求出相?的y坐?\n    if(up <= y && y <= down)    //会撞到\n        return true;\n    return false;\n}\n\nbool check2(double y, double left, double right)\n{\n    double delta = b * b - 4 * a * y;\n    if(delta < 0)   //抛物?与障碍物上（下）的左端和右端形成的?段没有交点，?不会相撞\n        return false;\n    delta = sqrt(delta);\n    double x1 = (-b + delta) / (2 * a);\n    double x2 = (-b - delta) / (2 * a);\n    if(x1 < tx && left <= x1 && x1 <= right)    //如果抛物?与障碍物上（下）的左端点有交点且交点的x坐?在猪的左?，?无法?死猪\n        return true;\n    if(x2 < tx && left <= x2 && x2 <= right)    //如果抛物?与障碍物上（下）的右端点有交点且交点的x坐?在猪的左?，?无法?死猪\n        return true;\n    return false;\n}\n\nbool check3(double x, double y, double h, double t, double l, double r)\n{\n    if(l <= x && x <= r && y <= t && t <= h)    //如果障碍正好?在白??行的抛物??迹和猪的中?，?炸蛋无法?中猪\n        return true;\n    return false;\n}\n\nbool check(double angle)\n{\n    getabc(angle);\n    double h = a * tx * tx + b * tx + c;\n    if(h < ty)    //?不到猪的上方，?不可能?死猪\n        return false;\n    for(int i=0; i<n; i++)\n    {\n        if(check1(ob[i].l,ob[i].b,ob[i].t))\n            return false;\n        if(check1(ob[i].r,ob[i].b,ob[i].t))\n            return false;\n        if(check2(ob[i].b,ob[i].l,ob[i].r))\n            return false;\n        if(check2(ob[i].t,ob[i].l,ob[i].r))\n            return false;\n        if(check3(tx,ty,h,ob[i].b,ob[i].l,ob[i].r))\n            return false;\n        //if(check3(tx,ty,h,ob[i].t,ob[i].l,ob[i].r))\n        //    return false;\n    }\n    return true;\n}\n\nbool solve()\n{\n    for(double i=0; i<0.5*PI; i+=0.000001)\n    {\n        if(check(i))\n            return true;\n    }\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\",&n,&v,&tx,&ty);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d%d%d\",&ob[i].l,&ob[i].b,&ob[i].r,&ob[i].t);\n    if(solve())\n        puts(\"Yes\");\n    else\n        puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h)\n{\n        if (sgn(h - y) < 0) return false;\n        REP(i,n) if (inside(x, l[i], r[i])) {\n                if (inside(b[i], y, h)) return false;\n                if (inside(t[i], y, h)) return false;\n        }\n        return true;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(d) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        double h = f(x);\n        if (!hit(h)) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nconst double deta = 1e-2;\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = deta; a < pi / 2; a += deta) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-8;\nconst double g=9.8;\nconst int maxn=5000;\n\n#define Equ(a,b) ((fabs((a)-(b)))<(eps))\n#define Less(a,b) (((a)-(b))<(-(eps)))\n#define LessEqu(a,b) (((a)-(b))<(eps))\n#define More(a,b) (((a)-(b))>(eps))\n#define MoreEqu(a,b) (((a)-(b))>(-(eps)))\n\nint main()\n{\n    //freopen(\"12381.txt\",\"r\",stdin);\n\n    int n;\n    double v,X,Y,x,y,t,vx,vy,t1,t2,x1,x2;\n    double L[60],B[60],R[60],T[60];\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&X,&Y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&L[i],&B[i],&R[i],&T[i]);\n        }\n        if(Equ(v,0.0))\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n\n        bool flag=0;\n\n        for(int k=1;k<maxn;k++)\n        {\n            vx=v*k/maxn;\n            vy=sqrt(v*v-vx*vx);\n            t=X/vx;\n            y=vy*t-0.5*g*t*t;\n            if(Less(y,Y)) continue;\n\n            for(int i=0;i<n;i++)\n            {\n\n                if(MoreEqu(X,L[i]))\n                {\n                    t=L[i]/vx;\n                    y=vy*t-0.5*g*t*t;\n                    if(MoreEqu(y,B[i])&&LessEqu(y,T[i]))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*B[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*B[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*B[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                if(MoreEqu(vy*vy,2.0*g*T[i]))\n                {\n                    t1=(vy-sqrt(vy*vy-2.0*g*T[i]))/g;\n                    t2=(vy+sqrt(vy*vy-2.0*g*T[i]))/g;\n                    x1=vx*t1;\n                    x2=vx*t2;\n                    if((MoreEqu(X,x1)&&MoreEqu(x1,L[i])&&LessEqu(x1,R[i]))||(MoreEqu(X,x2)&&MoreEqu(x2,L[i])&&LessEqu(x2,R[i])))\n                    {\n                        flag=0;\n                        break;\n                    }\n                }\n\n                flag=1;\n            }\n\n            if(n==0) flag=1;\n\n            if(flag==1) break;\n        }\n\n        if(flag==1) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\nconst ld G= 9.8;\n\nstruct box {\n\tvector<ld>xs;\n\tvector<ld>ys;\n};\n\n\nint N, V, X, Y;\nbool check(const ld theta, const box& b) {\n\n\tconst ld vx = V*cos(theta);\n\tconst ld vy = V*sin(theta);\n\n\tld y_max = -1e18;\n\tld y_min = 1e18;\n\n\t//?????????????¢????\n\t{\n\t\tconst ld toptime = vy / G;\n\t\tconst ld top_x = toptime*vx;\n\t\tconst ld top_y = vy*toptime - toptime*toptime*G / 2;\n\t\tif (b.xs[0] < top_x&&top_x < b.xs[1]) {\n\t\t\ty_max = max(y_max, top_y);\n\t\t}\n\t}\n\t//???????????????????¢????\n\t{\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tconst ld time = b.xs[x]/vx;\n\t\t\tconst ld ay = vy*time - time*time*G / 2;\n\t\t\ty_max = max(y_max, ay);\n\t\t\ty_min = min(y_min, ay);\n\t\t}\n\t}\n\tif (y_max- eps < b.ys[0] || b.ys[1] < y_min + eps) {\n\t\t\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid gettan(vector<ld>&tans,const Point& p,int leftup) {\n\tif (p.real() < eps)return;\n\tbool ok = true;\n\tld amin, amax;\n\n\t//?????????????¨????\n\t{\n\t\tconst ld tan = V*V / G / p.real();\n\t\tconst ld theta = atan(tan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld max_y = vy*time - G*time*time / 2;\n\t\tif (max_y < p.imag()) {\n\t\t\tok = false;\n\t\t}\n\t\tif (leftup) {\n\t\t\tamax = tan;\n\t\t\tamin = 0;\n\t\t}\n\t\telse {\n\t\t\tamax = 1e18;\n\t\t\tamin = tan;\n\t\t}\n\t}\n\tif (ok) {\n\t\tint rep = 1000;\n\t\twhile (rep--) {\n\t\t\tconst ld amidtan = (amin + amax) / 2;\n\t\t\tconst ld theta = atan(amidtan);\n\t\t\tconst ld vx = V*cos(theta);\n\t\t\tconst ld vy = V*sin(theta);\n\t\t\tconst ld time = p.real() / vx;\n\t\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\t\tif (ay > p.imag()) {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (leftup) {\n\t\t\t\t\tamin = amidtan;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amidtan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst ld amidtan = (amin + amax) / 2;\n\t\tconst ld theta = atan(amidtan);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = p.real() / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\ttans.push_back(amin);\n\t}\n}\n\nint main() { cin >> N >> V >> X >> Y;\n\tvector<box>bs;\n\tvector<ld>tans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint L, B, R, T; cin >> L >> B >> R >> T;\n\n\t\tR = min(R, X);\n\t\tbox b;\n\t\tb.xs.push_back(L);\n\t\tb.xs.push_back(R);\n\t\tb.ys.push_back(B);\n\t\tb.ys.push_back(T);\n\t\tfor (int x = 0; x < 2; ++x) {\n\t\t\tfor (int y = 0; y < 2; ++y) {\n\t\t\t\tPoint p(b.xs[x], b.ys[y]);\n\t\t\t\tgettan(tans, p, (x + y) % 2);\n\t\t\t\t//gettan(tans, p, (x + y+1) % 2);\n\t\t\t}\n\t\t}\n\t\tif (L >= X)continue;\n\t\tbs.push_back(b);\n\t}\n\tconst ld down = Y;\n\tld up = 1e18;\n\tfor (int i = 0; i < bs.size(); ++i) {\n\t\tif (bs[i].xs[0] < X&&X < bs[i].xs[1]) {\n\t\t\tif (bs[i].ys[0] > Y) {\n\n\t\t\t\tup = min(up, bs[i].ys[0]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\n\t\tPoint p(X,Y);\n\t\tgettan(tans, p,true);\n\t}\n\t{\n\t\tfor (int y = 1; y <= 300; ++y) {\n\t\t\tif (V*V / 2 >= y) {\n\t\t\t\tld vy = sqrt(2 * y);\n\t\t\t\tif (vy > V)break;\n\t\t\t\tld vx = sqrt(V*V - vy*vy);\n\t\t\t\tld tan = vy / vx;\n\t\t\t\ttans.push_back(tan);\n\t\t\t}\n\t\t}\n\t}\n\tsort(tans.begin(), tans.end());\n\t{\n\t\tvector<ld>ntans;\n\t\tfor (int i = 0; i < tans.size(); ++i) {\n\t\t\tntans.push_back(tans[i]);\n\t\t\tif (i != tans.size() - 1) {\n\t\t\t\tntans.push_back((tans[i] + tans[i + 1]) / 2);\n\t\t\t}\n\t\t}\n\t\ttans = ntans;\n\t}\n\tstring ans = \"No\";\n\tfor (auto t : tans) {\n\t\tconst ld theta = atan(t);\n\t\tconst ld vx = V*cos(theta);\n\t\tconst ld vy = V*sin(theta);\n\t\tconst ld time = X / vx;\n\t\tconst ld ay = vy*time - G*time*time / 2;\n\t\tif (down-eps <= ay&&ay <= up+eps) {\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < bs.size(); ++i) {\n\t\t\t\tauto b = bs[i];\n\n\t\t\t\tif (!check(theta, b)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok) {\n\n\t\t\t\tconst ld vx = V*cos(theta);\n\t\t\t\tconst ld vy = V*sin(theta);\n\t\t\t\t//cout << \"vx:\" << vx << \" vy:\" << vy << endl;\n\t\t\t\tfor (int x = 0; x <=100; ++x) {\n\t\t\t\t\tconst ld t = x / vx;\n\t\t\t\t\t//cout << \"x:\" << x << endl;\n\t\t\t\t\t//cout << \"y:\" << vy*t - G*t*t / 2 << endl;\n\t\t\t\t}\t\n\t\t\t\tans = \"Yes\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nint lx[100];\nint ly[100];\nint rx[100];\nint ry[100];\ndouble EPS=1e-9;\nvector<pair<int,int> > v;\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a,b,c,d;\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",lx+i,ly+i,rx+i,ry+i);\n\tv.push_back(make_pair(c,d));\n\tfor(int i=0;i<a;i++){\n\t\tv.push_back(make_pair(lx[i],ly[i]));\n\t\tv.push_back(make_pair(lx[i],ry[i]));\n\t\tv.push_back(make_pair(rx[i],ly[i]));\n\t\tv.push_back(make_pair(rx[i],ry[i]));\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i].first;\n\t\tint y=v[i].second;\n\t\tdouble D=(9.8*y-b*b)*(9.8*y-b*b)-4.0*4.9*4.9*(x*x+y*y);\n\t\tif(D<0)continue;\n\t\tdouble t,t2,vx,vy;\n\t\tbool ok;\n\t\tt2=(((double)b*b-9.8*y)/8+sqrt(D))/2/4.9/4.9;\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy*4.9-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy&&vx*vy+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy*4.9-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy&&vx*vy+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%d %d %f %f\\n\",v[i].first,v[i].second,vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t\tt2=(((double)b*b-9.8*y)/8-sqrt(D))/2/4.9/4.9;\n\t\tif(t2<0)continue;\n\t\tt=sqrt(t2);\n\t\tvx=(double)x/t;\n\t\tvy=sqrt((double)b*b-vx*vx);\n\t\tok=true;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble p=-4.9/vx/vx*lx[j]*lx[j]+vy/vx*lx[j];\n\t\t\tdouble q=-4.9/vx/vx*rx[j]*rx[j]+vy/vx*rx[j];\n\t\t\tif(ly[j]<p-EPS&&p+EPS<ry[j])ok=false;\n\t\t\tif(ly[j]<q-EPS&&q+EPS<ry[j])ok=false;\n\t\t\tif(vy*vy*4.9-EPS>ly[j]){\n\t\t\t\tif((p-ly[j])*(q-ly[j])<-EPS||(p+EPS<ly[j]&&q+EPS<ly[j]&&EPS+lx[j]<vx*vy&&vx*vy+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(vy*vy*4.9-EPS>ry[j]){\n\t\t\t\tif((p-ry[j])*(q-ry[j])<-EPS||(p+EPS<ry[j]&&q+EPS<ry[j]&&EPS+lx[j]<vx*vy&&vx*vy+EPS<rx[j])){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(-4.9/vx/vx*c*c+vy/vx*c<d-EPS)ok=false;\n\t\tif(ok&&ABS(vx)>EPS){\n\t\t//\tprintf(\"%d %d %f %f\\n\",v[i].first,v[i].second,vx,vy);\n\t\t\tprintf(\"Yes\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#define LL long long\n#define PII pair<int,int>\n#define pi acos(-1.0)\n#define eps 1e-6\n#define lowbit(x) x&(-x)\nusing namespace std;\n\nconst int maxn=50;\nconst double g=9.8;\nint N,V,X,Y;\nint L[maxn],B[maxn],R[maxn],T[maxn];\n\ndouble cal(double vy,double t){\n    return vy*t-g*t*t/2;\n}\n\nint cmp(double lb,double ub,double a){\n    return a<lb+eps?-1:a>ub-eps?1:0;\n}\n\nbool check(double qx,double qy){\n    double a=g*g/4,b=g*qy-V*V,c=qx*qx+qy*qy;\n    double D=b*b-4*a*c;\n    if(D<0 && D>-eps) D=0;\n    if(D<0) return false;\n    for(int d=-1;d<=1;d+=2){\n        double t2=(-b+d*sqrt(D))/(2*a);\n        if(t2<=0) continue;\n        double t=sqrt(t2);\n        double vx=qx/t,vy=(qy+g*t*t/2)/t;\n        double yt=cal(vy,X/vx);\n        if(yt<Y-eps) continue;\n        bool ok=true;\n        for(int i=0;i<N;i++){\n            if(L[i]>=X) continue;\n            if(X>=L[i] && X<=R[i] && Y<=T[i] && B[i]<=yt) ok=false;\n            int yL=cmp(B[i],T[i],cal(vy,L[i]/vx));\n            int yR=cmp(B[i],T[i],cal(vy,R[i]/vx));\n            int xH=cmp(L[i],R[i],vx*(vy/g));\n            int yH=cmp(B[i],T[i],cal(vy,vy/g));\n            if(xH==0 && yH>=0 && yL<0) ok=false;\n            if(yL*yR<=0) ok=false;\n        }\n        if(ok) return true;\n    }\n    return false;\n}\n\nvoid solve(){\n    for(int i=0;i<N;i++){\n        R[i]=min(X,R[i]);\n    }\n    bool ok=check(X,Y);\n    for(int i=0;i<N;i++){\n        ok|=check(L[i],T[i]);\n        ok|=check(R[i],T[i]);\n    }\n    printf(\"%s\\n\",ok?\"Yes\":\"No\");\n}\n\nint main(void){\n    scanf(\"%d %d %d %d\",&N,&V,&X,&Y);\n    for(int i=0;i<N;i++){\n        scanf(\"%d %d %d %d\",&L[i],&B[i],&R[i],&T[i]);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double g = 9.8;\nconst double EPS = 1e-8;\nnamespace solver{\n    int n;\n    double v, gx, gy;\n    double x1[50], x2[50], y1[50], y2[50];\n\n    double calc_y(double vx, double vy, double x){\n        double t = x / vx;\n        return vy * t - g * t * t / 2;\n    }\n\n    int sign(double x){\n        if(x > EPS) return 1;\n        if(x < -EPS) return -1;\n        return 0;\n    }\n\n    bool check(double bx, double by){\n        double a = g * g / 4.0;\n        double b = g * by - v * v;\n        double c = bx * bx + by * by;\n        double D = b * b - 4 * a * c;\n        //printf(\"D:%f\\n\", D);\n        if(D < 0) return false;\n        for(int s = -1; s <= 1; s += 2){\n            double tt = (-b + s * sqrt(D)) / (2 * a);\n            //printf(\"tt:%f\\n\", tt);\n            if(tt < 0) continue;\n            double t = sqrt(tt);\n            double vx = bx / t;\n            double vy = (by + g * t * t / 2) / t;\n            assert(sign(vx * vx + vy * vy - v * v) == 0);\n            double fh = calc_y(vx, vy, gx);\n            if(sign(fh - gy) < 0) continue;\n            bool ok = true;\n            // テ」ツδ禿」ツつーテ」ツ?ォテ・ツ債オテ」ツ?古・ツスツ禿」ツ?淌」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                if(x1[i] < gx && gx < x2[i] && fh > y1[i] && y1[i] >= gy) {\n                    ok = false;\n                }\n            }\n            // テ」ツδ氾」ツつーテ」ツ?ョテ、ツクツ甘ァツゥツコテ」ツ?セテ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n            for(int i = 0; i < n; i++){\n                double h1 = calc_y(vx, vy, x1[i]);\n                double h2 = calc_y(vx, vy, x2[i]);\n                double h_min = min(h1, h2);\n                double h_max = max(h1, h2);\n                if(x1[i] < vx * vy / g && vx * vy / g < x2[i]) h_max = max(h_max, calc_y(vx, vy, vx * vy / g));\n                if(sign(y1[i] - h_min) >= 0 && sign(h_max - y1[i]) >= 0) ok = false;\n                if(sign(y2[i] - h_min) >= 0 && sign(h_max - y2[i]) >= 0) ok = false;\n            }\n            if(ok) return true;\n        }\n        return false;\n    }\n    bool solve(){\n        cin >> n;\n        cin >> v >> gx >> gy;\n        REP(i, n) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n        bool ans = false;\n        ans |= check(gx, gy);\n        REP(i, n){\n            ans |= check(x1[i], y2[i]);\n            ans |= check(x2[i], y2[i]);\n        }\n        return ans;\n    }\n}\n\nint main(){\n    cout << (solver::solve() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define sqr(x) ((x)*(x))\ntypedef pair<double,double> point;\n\nconst double g=9.8;\nconst double eps=1e-8;\ndouble v;\n\nstruct para\n{\n\tdouble a,b;\n\tpara(){a=b=0;}\n\tpara(double te){b=te;a=-g*(b*b+1)/2/v/v;}\n\tdouble qz(double x) {return a*x*x+b*x;}\n};\n\nvector<para> init(double x,double y)\n{\n\tvector<para> res;\n\tdouble at=g*x*x/2/v/v,bt=-x,ct=y+g/2/v/v*x*x;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(para(pbt));return res;}\n\tres.push_back(para(pbt+sqrt(pbs)/2/at));\n\tres.push_back(para(pbt-sqrt(pbs)/2/at));\n\treturn res;\n}\nvector<double> sol(double at,double bt,double ct)\n{\n\tvector<double> res;\n\tdouble pbs=sqr(bt)-4*at*ct,pbt=-bt/2/at;\n\tif(pbs<-eps||fabs(at)<eps) return res;\n\tif(pbs<eps) {res.push_back(pbt);return res;}\n\tres.push_back(pbt+sqrt(pbs)/2/at);\n\tres.push_back(pbt-sqrt(pbs)/2/at);\n\treturn res;\n}\n\nstruct rect\n{\n\tdouble xl,xu,yl,yu;\n\trect(double xt=0,double yt=0,double xtt=0,double ytt=0):xl(xt),xu(xtt),yl(yt),yu(ytt){}\n};\n\nbool intersect(rect r,para p)\n{\n\tdouble t1=p.qz(r.xl),t2=p.qz(r.xu);\n\tif(t1>r.yl+eps&&t1<r.yu-eps) return true;\n\tif(t2>r.yl+eps&&t2<r.yu-eps) return true;\n\tif(fabs(t1-r.yu)<eps&&fabs(t2-r.yl)<eps) return true;\n\tif(fabs(t1-r.yl)<eps&&fabs(t2-r.yl)<eps) return true;\n\tif(fabs(t1-r.yl)<eps&&fabs(t2-r.yu)<eps) return true;\n\tvector<double> r1=sol(p.a,p.b,-r.yl);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\tr1=sol(p.a,p.b,-r.yu);\n\tfor(int i=0;i<r1.size();i++)\n\t\tif(r1[i]>r.xl+eps&&r1[i]<r.xu-eps) return true;\n\treturn false;\n}\n\nint n;\ndouble x,y;\nvector<point> po;\nvector<rect> ret;\n\nvoid solve()\n{\n\tint i,j,k,l;\n\tscanf(\"%d %lf %lf %lf\",&n,&v,&x,&y);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tdouble xt[5];\n\t\tfor(j=0;j<4;j++) scanf(\"%lf\",xt+j);\n\t\tfor(j=0;j<4;j+=2) for(k=1;k<4;k+=2) if(fabs(xt[j])>eps&&fabs(xt[k])>eps) po.push_back(point(xt[j],xt[k]));\n\t\tif(xt[0]>x-eps||xt[3]<y+eps) continue;\n\t       \tret.push_back(rect(xt[0],xt[1],xt[2],xt[3]));\n\t}\n\tpo.push_back(point(x,y));\n\tn=ret.size();\n\tfor(i=0;i<po.size();i++)\n\t{\n\t\tvector<para> tet=init(po[i].first,po[i].second);\n\t\tif(tet.empty()) continue;\n\t\tfor(l=0;l<tet.size();l++)\n\t\t{\n\t\t\tif(tet[l].qz(x)<y-eps) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(intersect(ret[j],tet[l])) break;\n\t\t\t}\n\t\t\tif(j<n) continue;\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tif(x>tet[l].xl-eps&&x<tet[l].xu+eps&&tet[l].qz(x)>ret[j].yl+eps&&y<ret[j].yl+eps) break;\n\t\t\tif(j<n) continue;\n\t\t\t{printf(\"Yes\\n\");return;}\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\nint main()\n{\n\tsolve();\n\tscanf(\"%d\",&n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\n#define int_ int64_t\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=55;\nconst db G=9.8;\nconst db eps=1e-10;\n\nint n,v,x,y;\nint l[N],b[N],r[N],t[N];\n\ndb calc(db vy,db t) {\n    return vy*t-0.5*G*t*t;\n}\n\nint cmp(db lb,db rb,db val) {\n    return val<lb+eps?-1:val>rb-eps?1:0;\n}\n\nbool ok(int qx,int qy) {\n    db a=0.25*G*G,b_=G*qy-v*v,c=qx*qx+qy*qy;\n    db Delta=b_*b_-4*a*c;\n    if (Delta<0) return false;\n    for (int i=-1;i<=1;i+=2) {\n        db t2=(-b_+i*sqrt(Delta))/(2*a);\n        if (t2<0) continue;\n        db t1=sqrt(t2);\n        db vx=qx/t1;\n        db vy=qy/t1+0.5*G*t1;\n        db yt=calc(vy,x/vx);\n        if (yt<y-eps) continue;\n        bool ok=true;\n        for (int i=1;i<=n;i++) {\n            if (l[i]>=x) continue;\n            if (r[i]>=x&&y<=t[i]&&yt>=b[i]) ok=false;\n            int yL=cmp(b[i],t[i],calc(vy,l[i]/vx));\n            int yR=cmp(b[i],t[i],calc(vy,r[i]/vx));\n            int xT=cmp(l[i],r[i],vx*(vy/G));\n            int yT=cmp(b[i],t[i],calc(vy,vy/G));\n            if (xT==0&&yT>=0&&yL<0) ok=false;\n            if (yL*yR<=0) ok=false;\n        }\n        if (ok) { return true; }\n    }\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d%d%d%d\",&n,&v,&x,&y);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%d%d%d%d\",l+i,b+i,r+i,t+i);\n    }\n    bool ans=ok(x,y);\n    for (int i=1;i<=n;i++) {\n        if (ok(l[i],t[i])||ok(r[i],t[i])) {\n            ans=true;\n            break;\n        }\n    }\n    if (ans) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Copyright (c) 2014 Authors. All rights reserved.\n * \n * FileName: A.cpp\n * Author: Beiyu Li <sysulby@gmail.com>\n * Date: 2014-09-15\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOR(i,s,t) for (int i = (s); i <= (t); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int inf = 0x3f3f3f3f;\nconst LL infLL = 0x3f3f3f3f3f3f3f3fLL;\n\nconst double g = 9.8;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nconst int maxn = 50 + 5;\n\nint n, v, x, y;\nint l[maxn], b[maxn], r[maxn], t[maxn];\n\ninline int sgn(double x)\n{\n        return x < -eps? -1: x > eps;\n}\n\ninline bool inside(double x, double l, double r)\n{\n        return sgn(l - x) <= 0 &&  sgn(x - r) <= 0;\n}\n\ndouble A, B;\ninline double f(double x)\n{\n        return A * x * x + B * x;\n}\n\nbool hit(double h)\n{\n        if (sgn(h - y) < 0) return false;\n        REP(i,n) if (inside(x, l[i], r[i])) {\n                if (inside(b[i], y, h)) return false;\n                if (inside(t[i], y, h)) return false;\n        }\n        return true;\n}\n\nbool hit(double h, int l, int r)\n{\n        double d = B * B + 4 * A * h;\n        if (sgn(h) < 0) return false;\n        d = sqrt(d);\n        double p = (-B - d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        p = (-B + d) / 2 / A;\n        if (inside(p, l, r) && sgn(p - x) <= 0) return true;\n        return false;\n}\n\nbool check(double a)\n{\n        double T = v * sin(a) / g;\n        double D = v * cos(a) * T, H = 0.5 * g * T * T;\n        A = -H / D / D; B = 2 * H / D;\n        double h = f(x);\n        if (!hit(h)) return false;\n        REP(i,n) {\n                if (inside(f(l[i]), b[i], t[i])\n                                && sgn(l[i] - x) <= 0) return false;\n                if (inside(f(r[i]), b[i], t[i])\n                                && sgn(r[i] - x) <= 0) return false;\n                if (hit(b[i], l[i], r[i])) return false;\n                if (hit(t[i], l[i], r[i])) return false;\n        }\n        return true;\n}\n\nint main()\n{\n        while (scanf(\"%d%d%d%d\", &n, &v, &x, &y) != EOF) {\n                REP(i,n) scanf(\"%d%d%d%d\", &l[i], &b[i], &r[i], &t[i]);\n                bool found = false;\n                for (double a = eps; a < pi / 2; a += eps) {\n                        if (check(a)) {\n                                found = true;\n                                break;\n                        }\n                }\n                puts(found? \"Yes\": \"No\");\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define RREP(i,s,e) for (i = s; i >= e; i--)\n#define rrep(i,n) RREP(i,n,0)\n#define REP(i,s,e) for (i = s; i < e; i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 100000000\n\ntypedef long long ll;\n\nint n, v, x, y;\nint l[50], b[50], r[50], t[50];\ndouble g = 9.8;\n\ndouble cmp(double l, double u, double a) {\n    return a < l ? -1 : a > u ? 1 : 0;\n}\n\ndouble height(double vy, double t) {\n    return vy * t - g * t * t / 2;\n}\n\nbool solve(int bx, int by) {\n    int i, j;\n    if (v*v-2*g*by < 0)\n        return false;\n    for (int i = -1; i <= 1; i+=2) {\n        double t2 = (-2*(g*by-v*v)+i*v*sqrt(v*v-2*g*by))/(g*g);\n        if (t2 < 0)\n            continue;\n        double t1 = sqrt(t2);\n        double vx = bx / t1;\n        double vy = y/t1 + g*t1/2;\n        if (height(vy,x/vx) < y-1e-9) continue;\n        bool ok = true;\n        rep (j,n) {\n            if (l[j] >= x) continue;\n            if (r[j] == x && height(vy,x/vx) >= b[j] && y <= t[j]) ok = false;\n            int yL = cmp(b[j],t[j],height(vy,l[j]/vx));\n            int yR = cmp(b[j],t[j],height(vy,r[j]/vy));\n            int xH = cmp(l[j],r[j],vx*vy/g);\n            int yH = cmp(b[j],t[j],height(vy,vy/g));\n            if (yL*yR <= 0) ok = false;\n            if (yR < 0 && xH == 0 && yH >= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    int i;\n    bool ans;\n    cin >> n >> v >> x >> y;\n    rep (i,n) cin >> l[i] >> b[i] >> r[i] >> t[i];\n    rep (i,n) r[i] = min(r[i],x);\n    ans = solve(x,y);\n    rep (i,n) {\n        ans |= solve(l[i],t[i]);\n        ans |= solve(r[i],t[i]);\n    }\n    if (ans)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double g = 9.8;\nconst double EPS = 1.0e-6;\n\nvoid kouhoth(int x, int y, int v, vector<double> &allTH)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble d = K*K*x*x - x*x*(x*x+2*K*y);\n\tif(d<0) return;\n\tdouble kai1 = (K*x + sqrt(d)) / x / x;\n\tdouble kai2 = (K*x - sqrt(d)) / x / x;\n\tif(kai1+EPS>0) allTH.push_back(atan(kai1+EPS));\n\tif(kai1-EPS>0) allTH.push_back(atan(kai1-EPS));\n\tif(kai2+EPS>0) allTH.push_back(atan(kai2+EPS));\n\tif(kai2-EPS>0) allTH.push_back(atan(kai2-EPS));\n}\n\ndouble f(double th, int v, int x)\n{\n\tdouble K = 1.0*v*v/g;\n\tdouble si = sin(th);\n\tdouble co = cos(th);\n\tdouble ta = tan(th);\n\tdouble alpha = -0.5*(1.0+ta*ta)/K;\n\tdouble beta = 0.5*K*si*si;\n\tdouble naka = 1.0*x - K*si*co;\n\treturn alpha * naka*naka + beta;\n}\n\nint main(){\n\tint n;\n\tint v, x, y;\n\tpair<double, double> buf;\n\twhile(cin>>n>>v>>x>>y){\n\t\tvector<int> allL, allB, allR, allT;\n\t\tvector<double> allTH;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint l, b, r, t;\n\t\t\tcin>>l>>b>>r>>t;\n\t\t\t// ³Ê\n\t\t\tif(x<l) continue;\n\t\t\t// ³ÊÈª»\n\t\t\tif(x<r) r = x;\n\t\t\tallL.push_back(l);\n\t\t\tallB.push_back(b);\n\t\t\tallR.push_back(r);\n\t\t\tallT.push_back(t);\n\t\t\tkouhoth(l, b, v, allTH);\n\t\t\tkouhoth(r, b, v, allTH);\n\t\t\tkouhoth(l, t, v, allTH);\n\t\t\tkouhoth(r, t, v, allTH);\n\t\t}\n\t\tkouhoth(x, y, v, allTH);\n\n\t\tbool okflg = false;\n\t\tfor(int i=0; i<allTH.size(); i++){\n\t\t\tdouble th = allTH[i];\n\t\t\tdouble mauey = f(th,v,x);\n\t\t\tif(mauey < y) continue;\n\t\t\tbool dameflg = false;\n\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\tif(\n\t\t\t\t\t(f(th,v,allL[j])<allB[j]&&f(th,v,allR[j])<allB[j]) ||\n\t\t\t\t\t(f(th,v,allL[j])>allT[j]&&f(th,v,allR[j])>allT[j]) ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdameflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!dameflg){\n\t\t\t\tbool butukaruflg = false;\n\t\t\t\tfor(int j=0; j<allL.size(); j++){\n\t\t\t\t\tif(allR[j]==x){\n\t\t\t\t\t\tif(y<allT[j] && allT[j]<mauey){\n\t\t\t\t\t\t\tbutukaruflg = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!butukaruflg){\n\t\t\t\t\tokflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(okflg) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nconst double G = -9.8;\nint N,V,X,Y;\n\nint check(int px,int py,int l,int r,int b,int t){\n  int rs1=1;\n  int rs2=1;\n  ld vx = V * (ld)px / sqrt(px*px+py*py);\n  ld vy = V * (ld)py / sqrt(px*px+py*py);\n  ld wY1,wY2;\n  cout << vx <<endl;\n  if (vx == 0) return -1;\n  if((l<=X)&&(vx!=0)){\n    ld t1 = (ld)l/vx;\n    ld t2 = (ld)r/vx;\n    wY1 = vy*t1 + G*t1*t1/2;\n    wY2 = vy*t2 + G*t1*t1/2;\n\n    if(wY1>t) rs1 = 1;\n    else if ((b<=wY1)&&(wY1<=t)) rs1 = 0;\n    else if(wY1 < b) rs1 = -1;\n    if(wY2>t) rs2 = 1;\n    else if ((b<=wY2)&&(wY2<=t)) rs2 = 0;\n    else if(wY2 < b) rs2 = -1;\n  }\n\n  ld t3 = X/vx;\n  ld wY3 = vy*t3 + G*t3*t3/2;\n   // cout << wY1 << \"  \" << wY2 << \"  \" << wY3;// <<endl;\n  if(wY3<Y) {//cout <<\"todokanai\"<<endl;\n    return -1;\n  }\n  else {//cout << rs1 << \" \" <<rs2<<endl; \n    return rs1 * rs2;\n  }\n}\nint main(){\n  cin >> N >> V >> X >> Y;\n  vector<int> L(N),B(N),R(N),T(N);\n  REP(i,N){\n    cin >> L[i] >> B[i] >> R[i] >> T[i];\n    //R[i] = min(R[i],X);\n  }\n  int flag = 1;\n  REP(i,N){\n    if((L[i]<X)&&(X<R[i])&&(B[i]>Y)) {\n      flag = -1;\n    }\n  }\n  if(flag == 1){\n    int flag2 = 0;\n    REP(i,N){\n      REP(j,N){\n        if(check(L[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n        if(check(R[i],T[i],L[j],R[j],B[j],T[j])>0) flag2 = 1;\n      }\n    }\n    if(flag2==0) flag = -1;\n    //cout << flag2 <<endl;\n    if((N==0)||(flag==1)) cout << \"Yes\" <<endl;\n    else cout << \"No\" <<endl;\n  }else{\n    cout << \"No\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int i = -1; i <= 1; i += 2)\n\t{\n\t\tdouble t2 = (-b + i * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = (y + g * t * t / 2) / t;//sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l >= X) continue;\n\t\t\tif( X <= bl[i].r && loc >= bl[i].b  && bl[i].t  >= Y) res = false;\n\t\t\t//if (!(bl[i].l <= X && X <= bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y)) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, calc(vx, vy / g));\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <double, double> P;\nconst int INF = 1000000000; const double EPS = 10e-9;\nconst double g = 9.8;\nint n, v, X, Y;\nstruct block {\n\tint l, b, r, t;\n\tblock(int L, int B, int R, int T)\n\t{\n\t\tl = L; b = B; r = R; t = T;\n\t}\n\tblock() {};\n};\nblock bl[50];\ndouble calc(double vy, double t)\n{\n\treturn vy * t - g * t * t / 2;\n}\nint comp(double lb, double rb, double a)\n{\n\treturn lb + EPS > a ? -1 : rb - EPS < a ? 1 : 0;\n}\nbool check(int x, int y)\n{\n\tdouble a = g * g / 4, b = g * y - v * v, c = x * x + y * y;\n\tdouble D = b * b - 4 * a * c;\n\tif (D > -EPS && D < 0) D = 0;\n\tif (D < 0) return false;\n\tfor (int d = -1; d <= 1; d += 2)\n\t{\n\t\tdouble t2 = (-b + d * sqrt(D)) / (2 * a);\n\t\tif (t2 <= 0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t;\n\t\tdouble vy = sqrt(v * v - vx * vx);\n\t\tdouble loc = calc(vy, X / vx);\n\t\tif (loc < Y - EPS) continue;\n\t\tbool res = true;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (bl[i].l > X) continue;\n\t\t\tif (X == bl[i].r && loc >= bl[i].b - EPS && bl[i].t + EPS >= Y) res = false;\n\t\t\tint lh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].l / vx));\n\t\t\tint rh = comp(bl[i].b, bl[i].t, calc(vy, bl[i].r / vx));\n\t\t\tint mw = comp(bl[i].l, bl[i].r, vx* vy / g);\n\t\t\tint mh = comp(bl[i].b, bl[i].t, calc(vy, vy / g));\n\t\t\tif (lh * rh <= 0) res = false;\n\t\t\tif (mw == 0 && lh < 0 && mh >= 0) res = false;\n\t\t}\n\t\tif (res) return res;\n\t}\n\treturn false;\n}\nint main() \n{\n\tcin >> n >> v >> X >> Y;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint l, b, r, t; cin >> l >> b >> r >> t;\n\t\tr = min(r, X);\n\t\tbl[i] = block(l, b, r, t);\n\t}\n\tbool res = check(X, Y);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tres |= check(bl[i].l, bl[i].t);\n\t\tres |= check(bl[i].r, bl[i].t);\n\t}\n\tputs(res ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n\ntypedef long long ll;\ndouble EPS = 1e-6;\nconst double g = 9.8;\nconst int N = 50;\nint n, v, X, Y;\nint L[N], R[N], T[N], B[N];\n\n//速度vyで上に打ち出した際のt秒後の位置を計算\ndouble calc(double vy, double t) {\n\treturn vy*t - g*t*t*0.5;\n}\n\n//aのlb,ubに対する相対位置関係(lbより下:-1, lb以上ub以下:0, ubより上:1)\nint relPos(double lb, double ub, double a) {\n\treturn a < lb+EPS ? -1 : (a > ub-EPS ? 1 : 0);\n}\n\n//点(x,y)を通るように打ち出したときに豚に卵をぶつけられるか判定\nbool success(double x, double y) {\n\tdouble a = g*g*0.25, b = g*y-v*v, c = x*x+y*y;\n\tdouble D = b*b - a*c*4.0;\n\n\tif (D<0.0 && D>-EPS) D = 0.0;\n\tif (D<0.0) return false;\n\n\tfor (int d=-1; d<=1; d+=2) {\n\t\tdouble t2 = (-b + d*sqrt(D)) / (a*2.0);\n\t\tif (t2<=0) continue;\n\t\tdouble t = sqrt(t2);\n\t\tdouble vx = x / t, vy = (y + g*t*t*0.5) / t;\n\n\t\tdouble yt = calc(vy, X / vx);\n\t\tif (yt < Y-EPS) continue;\n\n\t\tbool ok = true;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (L[i]>=X) continue;\n\n\t\t\tif (L[i]<=X && X<=R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n//\t\t\tif (X==R[i] && Y<=T[i] && B[i]<=yt) ok = false;\n\n\t\t\tint yL = relPos(B[i], T[i], calc(vy, L[i]/vx));\n\t\t\tint yR = relPos(B[i], T[i], calc(vy, R[i]/vx));\n\t\t\tint xH = relPos(L[i], R[i], vx*(vy/g));\n\t\t\tint yH = relPos(B[i], T[i], calc(vy, vy/g));\n\n\t\t\tif (xH==0 && yH>=0 && yL<0) ok = false;\n\t\t\tif (yL*yR<=0) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\n\tscanf(\"%d%d%d%d \", &n, &v, &X, &Y);\n\tfor (int i=0; i<n; i++)\n\t\tscanf(\"%d%d%d%d \", L+i, B+i, R+i, T+i);\n\n/*\n\tfor (int i=0; i<n; i++)\n\t\tR[i] = min(R[i], X);\n*/\n\n\n\tbool ok = success(X, Y);\n\n\tfor (int i=0; i<n; i++) {\n\t\tok |= success(L[i], T[i]);\n\t\tok |= success(R[i], T[i]);\n\t}\n\n\tputs(ok ? \"Yes\" : \"No\");\n    \n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <string>\n#include <map>\n#include <set>\n#define pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define inf 0x3f3f3f3f\n#define INF 1e18\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define mem0(a) memset(a, 0, sizeof(a))\n#define memi(a) memset(a, inf, sizeof(a))\n#define mem1(a) memset(a, -1, sizeof(a))\nusing namespace std;\ntypedef pair<int, int> P;\nconst double eps = 1e-10;\nconst int maxn = 1e5 + 5;\nconst int mod = 1e8;\n\nint n;\ndouble v, x, y;\nconst double g = 9.8;\ndouble l[maxn], r[maxn], t[maxn], b[maxn];\nbool ok;\n\ndouble calc(double vy, double t){\n    return vy * t - g * t * t / 2;\n}\nint cmp(double lb, double ub, double a){\n    return a < lb + eps ? -1 : a > ub - eps ? 1 : 0;\n}\nbool check(int qx, int qy){\n    double a = g * g / 4, B = g * qy - v * v, c = qx * qx + qy * qy;\n    double D = B * B - 4 * a * c;\n    if (D < 0 && D > -eps) D = 0;\n    if (D < 0) return false;\n    for (int d = -1; d <= 1; d += 2){\n        double t2 = (-B + d * sqrt(D)) / (2 * a);\n        if (t2 <= 0) continue;\n        double T = sqrt(t2);\n        double vx = qx / T, vy = (qy + g * T * T / 2) / T;\n\n        double yt = calc(vy, x / vx);\n        if (yt < y - eps) continue;\n        bool ok = true;\n        for (int i = 0; i < n; i++){\n            if (l[i] >= x) continue;\n            if (r[i] == x && y <= t[i] && b[i] <= yt) ok = false;\n            int yl = cmp(b[i], t[i], calc(vy, l[i] / vx));\n            int yr = cmp(b[i], t[i], calc(vy, r[i] / vx));\n            int xh = cmp(l[i], r[i], vx * (vy / g));\n            int yh = cmp(b[i], t[i], calc(vy, vy / g));\n            if (xh == 0 && yh >= 0 && yl < 0) ok = false;\n            if (yl * yr <= 0) ok = false;\n        }\n        if (ok) return true;\n    }\n    return false;\n}\nint main(void)\n{\n//\tfreopen(\"C:\\\\Users\\\\wave\\\\Desktop\\\\NULL.exe\\\\NULL\\\\in.txt\",\"r\", stdin);\n    while (~scanf(\"%d %lf %lf %lf\", &n, &v, &x, &y)){\n        for (int i = 0; i < n; i++)\n            scanf(\"%lf %lf %lf %lf\", &l[i], &b[i], &r[i], &t[i]);\n        for (int i = 0; i < n; i++)\n            r[i] = min(r[i], x);\n        ok = check(x, y);\n        for (int i = 0; i < n; i++){\n            ok |= check(l[i], t[i]);\n            ok |= check(r[i], t[i]);\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define NMAX 300\n#define EPS 1e-10\nconst double g = 9.8;\n\nint n, v, x, y;\nint left[NMAX], bot[NMAX], right[NMAX], top[NMAX];\nint cmpi(double lb, double ub, double c);\nint check(double qx, double qy);\n\nint main(void)\n{\n  int i, hit;\n  scanf(\"%d %d %d %d\", &n, &v, &x, &y);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d %d %d\", &left[i], &bot[i], &right[i], &top[i]);\n    if (right[i]> x) right[i] = x;\n  }\n  hit = check(x, y);\n  for (i = 0; i < n; i++) {\n    hit |= check(left[i], top[i]);\n    hit |= check(right[i], top[i]);\n  }\n  printf(\"%s\\n\", hit ? \"Yes\" : \"No\");\n}\n\nint cmpi(double lb, double ub, double c)\n{\n  return c < lb + EPS ? -1 : c > ub - EPS ? 1 : 0;\n}\n\nint check(double qx, double qy)\n{\n  int i, d, hit = 1;\n  double a = g * g / 4, b = g * qy - v * v, c = qx * qx + qy * qy;\n  double D = b * b - 4 * a * c;\n  if (D < 0 && D > -EPS) D = 0;\n  if  (D < 0) return 0;\n  for (d = -1; d <= 1; d += 2) {\n    double t, vx, vy, yt, t2 = (-b + d * sqrt(D)) / (2 * a);\n    if (t2 <= 0) continue;\n    t = sqrt(t2);\n    vx = qx / t;\n    vy = qy / t + g * t / 2;\n    yt = vy * x / vx - g * pow(x / vx, 2) / 2;\n    if (yt < y - EPS) continue;\n    for (i = 0; i < n; i++) {\n      int yl, yr, xh, yh;\n      if (left[i] >= x) continue;\n      if (right[i] == x && y <= top[i] && bot[i] <= yt) {\n        hit = 0;\n        break;\n      }\n      yl = cmpi(bot[i], top[i], vy * left[i] / vx - g * pow(left[i] / vx, 2) / 2);\n      yr = cmpi(bot[i], top[i], vy * right[i] / vx - g * pow(right[i] / vx, 2) / 2);\n      xh = cmpi(left[i], right[i], vx * (vy / g));\n      yh = cmpi(bot[i], top[i], vy * vy / g - g * pow(vy / g, 2) / 2);\n      if ((xh ==0 && yh >= 0 && yl < 0) || (yl * yr <= 0)) {\n        hit = 0;\n        break;\n      }\n    }\n    if (hit) return 1;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define maxn 55\n#define eps 1e-8\nconst double g=9.8;\nusing namespace std;\nint n;\ndouble v,x,y;\ndouble l[maxn],b[maxn],r[maxn],t[maxn];\ndouble cal(double t,double vy)\n{\n    return vy*t-g*t*t/2;\n}\nint cmp(double lowb,double upb,double a)\n{\n    if(a<lowb-eps)\n        return -1;\n    if(a>upb+eps)\n        return 1;\n    return 0;\n}\nbool judge(int qx,int qy)//通??个点的??是t\n{\n    double a=g*g/4,bb=g*qy-v*v,c=qx*qx+qy*qy;\n    double d=bb*bb-4*a*c;\n    if(d<0&&d>-eps)\n        d=0;\n    if(d<0)\n        return false;\n    for(int cnt=-1;cnt<=1;cnt+=2)\n    {\n        double t_sq=(-bb+cnt*sqrt(d))/(2*a);\n        if(t_sq<0)\n            continue;\n        double tt=sqrt(t_sq);\n        double vx=qx/tt,vy=(qy+g*tt*tt/2)/tt;\n        double yt=cal(x/vx,vy);//猪的正上方坐?\n        if(yt<y-eps)\n            continue;\n        bool ans=true;\n        for(int i=0;i<n;i++)\n        {\n            if(l[i]>=x)\n                continue;\n            if(r[i]==x&&b[i]<=yt&&t[i]>=y)\n                ans=false;\n            int yl=cmp(b[i],t[i],cal(l[i]/vx,vy));\n            int yr=cmp(b[i],t[i],cal(r[i]/vx,vy));\n            int xh=cmp(l[i],r[i],vx*vy/g);\n            int yh=cmp(b[i],t[i],cal(vy/g,vy));\n            if(yl*yr<=0)\n                ans=false;\n            if(xh==0&&yh>=0&&yl<=0)\n                ans=false;\n        }\n        if(ans)\n            return true;\n    }\n    return false;\n}\nint main()\n{\n    while(scanf(\"%d%lf%lf%lf\",&n,&v,&x,&y)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n            scanf(\"%lf%lf%lf%lf\",&l[i],&b[i],&r[i],&t[i]);\n        for(int i=0;i<n;i++)\n            r[i]=min(r[i],x);\n        bool flag=judge(x,y);\n        for(int i=0;i<n;i++)\n        {\n            flag=flag|judge(l[i],t[i]);\n            flag=flag|judge(r[i],t[i]);\n        }\n        if(flag)\n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.math.*;\n\npublic class Main {\n static class node\n{\n      static double l=0.0;\n      static double r=0.0;\n      static double b=0.0;\n      static double t=0.0;\n}; \nstatic node[] p =new node[55];\nstatic final double end = 0.0001;\nstatic int n=0;\n\npublic static int solove( double x0,double y0,double t0,double v)\n{\n\n           double x,y;\n           double g=9.8;\n           double t;\n           double vx=x0/t0;\n           double vy=Math.sqrt(v*v-vx*vx);\n                \n           double h=vy*t0-g*t0*t0/2;\n               \n                if(h-y0<=-end)\n                   {\n\t\t     return 2;\n\t\t   }\n        \n           int  flag=0;\n\n           for(int i=0;i<n;i++)\n           {\n\t\t\t\t\n\t\t if(p[i].l-x0>=end)\n\t\t     continue ;\n\t\t\t\t\n\t\tif(p[i].l-x0 <= -end && p[i].r-x0 >=end && p[i].b-h<=-end && p[i].t-y0>=end)\n                     return 1;\n                \n                if(x0-p[i].l>=end)\n\t           {  \n                         x=p[i].l;\n                        t=x/vx;\n                        y=vy*t-g*t*t/2;\n                        if(p[i].b - y <= -end && p[i].t - y >= end)\n                                return 1;\n\t\t    }\n\t\t\t    \n                if(x0-p[i].r>=end)\n\t            {\n\t\t       x=p[i].r;\n\t               t=x/vx;\n\t               y=vy*t-g*t*t/2;\n\t               if(p[i].b - y <= -end&& p[i].t - y >= end)\n\t                     return 1;\n\t\t   }\n\t\t\t\t\n               y=p[i].b;\n               double w=vy*vy - 2*g*y;\n               if(w>=end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                             x=vx*t;\n                         if(x-x0<=end && p[i].l - x <= -end&& p[i].r - x >= end)\n                             return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end &&p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n               }\n               \n               y=p[i].t;\n               w=vy*vy - 2*g*y;\n\n               if(w>end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                                x=vx*t;\n                                if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                        return 1;\n                       }\n               }\n              \n           }\n\n    return flag;\n}\n\n    public static void main(String[] args)\n    {\n       \n           Scanner cin=new Scanner(System.in);\n           double v,x0,y0;\n          \n           while(cin.hasNext())\n           {\n                    n=cin.nextInt(); v=cin.nextDouble();\n                    x0=cin.nextDouble();y0=cin.nextDouble();\n                 \n                    for(int i=0;i<n;i++)\n                        {\n                            p[i].l =cin.nextDouble();p[i].b =cin.nextDouble();\n                            p[i].r =cin.nextDouble();p[i].t =cin.nextDouble();\n                        }\n                 \n                    double g=9.8;\n                    double f=(v*v - y0*g)*(v*v - y0*g) - g*g*(x0*x0 + y0*y0) ;\n\n                    if(f< -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n                 \n                    double u=(  (v*v - y0*g)+Math.sqrt( f  )  )/(g*g)*2;\n                    if(u<= -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n\n\t\t          \n                          double t0;\n                            t0=Math.sqrt(u);\n                            double t2;\n                            double t1=0.0;\n                              t2=1.0;\n                    int  flag=1;  \n\t\t\t  \n                    double u1=(  (v*v - y0*g)-Math.sqrt( f  )  )/(g*g)*2;\n                    if(u1>=end)\n                            t1=Math.sqrt(u1);\n\t\t       \n                    for( t2=t0;t2>=t1;t2=t2-end )\n                            {\n                                        flag=solove(x0,y0,t2,v);\n                                        if(flag==0 || flag==2)\n                                            break;\n                            }\n                         \n                    if(flag!=0)\n                        System.out.println(\"No\");\n                    else\n                        System.out.println(\"Yes\");\n     \n            }\n           }\n   }"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\nimport java.math.*;\n\n\npublic class Main {\n\n static    class node\n{\n     static double l;\n     static double r;\n     static double b;\n     static double t;\n} ;\n   static final double end = 0.0001;\n    static int n;\n    static node[] p=new node[55];\n    \n   static int solove( double x0,double y0,double t0,double v)\n{\n\n           double x,y;\n           double g=9.8;\n           double t=0;\n           double vx=x0/t0;\n           double vy=Math.sqrt(v*v-vx*vx);\n                \n            double h=vy*t0-g*t0*t0/2;\n               \n                if(h-y0<=-end)\n                   {\n\t\t\t\t\t\treturn 2;\n\t\t\t\t   }\n        \n           int  flag=0;\n\n           for(int i=0;i<n;i++)\n           {\n\t\t\t\t\n\t\t\t\tif(p[i].l-x0>=end)\n\t\t\t\t    continue ;\n\t\t\t\t\n\t\t\t\tif(p[i].l-x0 <= -end && p[i].r-x0 >=end && p[i].b-h<=-end && p[i].t-y0>=end)\n\t\t\t\t        return 1;\n\t\t\t   if(x0-p[i].l>=end)\n\t            {  \n\t\t\t\t   x=p[i].l;\n\t               t=x/vx;\n\t               y=vy*t-g*t*t/2;\n\t               if(p[i].b - y <= -end&& p[i].t - y >= end)\n\t                    return 1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    if(x0-p[i].r>=end)\n\t            {\n\t\t\t\t   x=p[i].r;\n\t               t=x/vx;\n\t               y=vy*t-g*t*t/2;\n\t               if(p[i].b - y <= -end&& p[i].t - y >= end)\n\t                     return 1;\n\t\t\t\t}\n\t\t\t\t\n               y=p[i].b;\n               double w=vy*vy - 2*g*y;\n               if(w>=end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                       x=vx*t;\n                         if(x-x0<=end && p[i].l - x <= -end&& p[i].r - x >= end)\n                             return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                       x=vx*t;\n                       if(x-x0<=end &&p[i].l - x <= -end&& p[i].r- x >= end)\n                             return 1;\n                       }\n               }\n               \n               y=p[i].t;\n               w=vy*vy - 2*g*y;\n\n               if(w>end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                       x=vx*t;\n                       if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                             return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                       x=vx*t;\n                       if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                            return 1;\n                       }\n               }\n              \n           }\n\n    return flag;\n\n}\n    public static void main(String[] args) \n    {\n        double v,x0,y0;\n         Scanner cin=new Scanner(System.in);\n          while(cin.hasNext())\n           {\n           \n                n=cin.nextInt(); v=cin.nextDouble();\n                x0=cin.nextDouble();y0=cin.nextDouble();\n                \n                for(int i=0;i<n;i++)\n                        {\n                            p[i].l =cin.nextDouble();p[i].b =cin.nextDouble();\n                            p[i].r =cin.nextDouble();p[i].t =cin.nextDouble();\n                        }\n                double g=9.8;\n            double f=(v*v - y0*g)*(v*v - y0*g) - g*g*(x0*x0 + y0*y0) ;\n\n              if(f< -end)\n                   {\n                       System.out.printf(\"No\\n\");\n                           continue ;\n                   }\n                 \n           double u=(  (v*v - y0*g)+Math.sqrt( f  )  )/(g*g)*2;\n              if(u<= -end)\n                   {\n                       System.out.printf(\"No\\n\");\n                           continue ;\n                   }\n                   \n\t\t          \n           double t0=Math.sqrt(u),t=1,t1=0.0; \n\t\t\tint  flag=1;  \n\t\t\t  \n\t\t double u1=(  (v*v - y0*g)-Math.sqrt( f  )  )/(g*g)*2;\n\t\t   if(u1>=end)\n\t\t        t1=Math.sqrt(u1);\n\t\t        \n           for( t=t0;t>=t1;t-=end)\n                {\n\t\t\t\t\tflag=solove(x0,y0,t,v);\n\t\t\t\t\tif(flag==0 || flag==2)\n\t\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t\n           if(flag!=0)\n               System.out.printf(\"No\\n\");\n            else\n               System.out.printf(\"Yes\\n\");\n           }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.math.*;\n\nclass node\n{\n      static double l=0.0;\n      static double r=0.0;\n      static double b=0.0;\n      static double t=0.0;\n}; \n\npublic class Main {\n    \nstatic node[] p =new node[55];\nstatic final double end = 0.0001;\nstatic int n=0;\n\npublic static int solove( double x0,double y0,double t0,double v)\n{\n\n           double x,y;\n           double g=9.8;\n           double t;\n           double vx=x0/t0;\n           double vy=Math.sqrt(v*v-vx*vx);\n                \n           double h=vy*t0-g*t0*t0/2;\n               \n                if(h-y0<=-end)\n                   {\n\t\t     return 2;\n\t\t   }\n        \n           int  flag=0;\n\n           for(int i=0;i<n;i++)\n           {\n\t\t\t\t\n\t\t if(p[i].l-x0>=end)\n\t\t     continue ;\n\t\t\t\t\n\t\tif(p[i].l-x0 <= -end && p[i].r-x0 >=end && p[i].b-h<=-end && p[i].t-y0>=end)\n                     return 1;\n                \n                if(x0-p[i].l>=end)\n\t           {  \n                         x=p[i].l;\n                        t=x/vx;\n                        y=vy*t-g*t*t/2;\n                        if(p[i].b - y <= -end && p[i].t - y >= end)\n                                return 1;\n\t\t    }\n\t\t\t    \n                if(x0-p[i].r>=end)\n\t            {\n\t\t       x=p[i].r;\n\t               t=x/vx;\n\t               y=vy*t-g*t*t/2;\n\t               if(p[i].b - y <= -end&& p[i].t - y >= end)\n\t                     return 1;\n\t\t   }\n\t\t\t\t\n               y=p[i].b;\n               double w=vy*vy - 2*g*y;\n               if(w>=end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                             x=vx*t;\n                         if(x-x0<=end && p[i].l - x <= -end&& p[i].r - x >= end)\n                             return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end &&p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n               }\n               \n               y=p[i].t;\n               w=vy*vy - 2*g*y;\n\n               if(w>end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                                x=vx*t;\n                                if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                        return 1;\n                       }\n               }\n              \n           }\n\n    return flag;\n}\n\n    public static void main(String[] args)\n    {\n       \n           Scanner cin=new Scanner(System.in);\n           double v,x0,y0;\n          \n           while(cin.hasNext())\n           {\n                    n=cin.nextInt(); v=cin.nextDouble();\n                    x0=cin.nextDouble();y0=cin.nextDouble();\n                 \n                    for(int i=0;i<n;i++)\n                        {\n                            p[i].l =cin.nextDouble();p[i].b =cin.nextDouble();\n                            p[i].r =cin.nextDouble();p[i].t =cin.nextDouble();\n                        }\n                 \n                    double g=9.8;\n                    double f=(v*v - y0*g)*(v*v - y0*g) - g*g*(x0*x0 + y0*y0) ;\n\n                    if(f< -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n                 \n                    double u=(  (v*v - y0*g)+Math.sqrt( f  )  )/(g*g)*2;\n                    if(u<= -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n\n\t\t          \n                          double t0;\n                            t0=Math.sqrt(u);\n                            double t2;\n                            double t1=0.0;\n                              t2=1.0;\n                    int  flag=1;  \n\t\t\t  \n                    double u1=(  (v*v - y0*g)-Math.sqrt( f  )  )/(g*g)*2;\n                    if(u1>=end)\n                            t1=Math.sqrt(u1);\n\t\t       \n                    for( t2=t0;t2>=t1;t2=t2-end )\n                            {\n                                        flag=solove(x0,y0,t2,v);\n                                        if(flag==0 || flag==2)\n                                            break;\n                            }\n                         \n                    if(flag!=0)\n                        System.out.println(\"No\");\n                    else\n                        System.out.println(\"Yes\");\n     \n            }\n           }\n   }"
  },
  {
    "language": "Java",
    "code": "\npackage main;\nimport java.util.Scanner;\nimport java.math.*;\n\npublic class Main {\n static class node\n{\n      static double l=0.0;\n      static double r=0.0;\n      static double b=0.0;\n      static double t=0.0;\n}; \nstatic node[] p =new node[55];\nstatic final double end = 0.0001;\nstatic int n=0;\n\npublic static int solove( double x0,double y0,double t0,double v)\n{\n\n           double x,y;\n           double g=9.8;\n           double t;\n           double vx=x0/t0;\n           double vy=Math.sqrt(v*v-vx*vx);\n                \n           double h=vy*t0-g*t0*t0/2;\n               \n                if(h-y0<=-end)\n                   {\n\t\t     return 2;\n\t\t   }\n        \n           int  flag=0;\n\n           for(int i=0;i<n;i++)\n           {\n\t\t\t\t\n\t\t if(p[i].l-x0>=end)\n\t\t     continue ;\n\t\t\t\t\n\t\tif(p[i].l-x0 <= -end && p[i].r-x0 >=end && p[i].b-h<=-end && p[i].t-y0>=end)\n                     return 1;\n                \n                if(x0-p[i].l>=end)\n\t           {  \n                         x=p[i].l;\n                        t=x/vx;\n                        y=vy*t-g*t*t/2;\n                        if(p[i].b - y <= -end && p[i].t - y >= end)\n                                return 1;\n\t\t    }\n\t\t\t    \n                if(x0-p[i].r>=end)\n\t            {\n\t\t       x=p[i].r;\n\t               t=x/vx;\n\t               y=vy*t-g*t*t/2;\n\t               if(p[i].b - y <= -end&& p[i].t - y >= end)\n\t                     return 1;\n\t\t   }\n\t\t\t\t\n               y=p[i].b;\n               double w=vy*vy - 2*g*y;\n               if(w>=end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                             x=vx*t;\n                         if(x-x0<=end && p[i].l - x <= -end&& p[i].r - x >= end)\n                             return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end &&p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n               }\n               \n               y=p[i].t;\n               w=vy*vy - 2*g*y;\n\n               if(w>end)\n               {\n                       t=(vy-Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                            x=vx*t;\n                            if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                    return 1;\n                       }\n\n                       t=(vy+Math.sqrt(w))/g;\n                       if(t>end)\n                       {\n\n                                x=vx*t;\n                                if(x-x0<=end && p[i].l - x <= -end&& p[i].r- x >= end)\n                                        return 1;\n                       }\n               }\n              \n           }\n\n    return flag;\n}\n\n    public static void main(String[] args)\n    {\n       \n           Scanner cin=new Scanner(System.in);\n           double v,x0,y0;\n          \n           while(cin.hasNext())\n           {\n                    n=cin.nextInt(); v=cin.nextDouble();\n                    x0=cin.nextDouble();y0=cin.nextDouble();\n                 \n                    for(int i=0;i<n;i++)\n                        {\n                            p[i].l =cin.nextDouble();p[i].b =cin.nextDouble();\n                            p[i].r =cin.nextDouble();p[i].t =cin.nextDouble();\n                        }\n                 \n                    double g=9.8;\n                    double f=(v*v - y0*g)*(v*v - y0*g) - g*g*(x0*x0 + y0*y0) ;\n\n                    if(f< -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n                 \n                    double u=(  (v*v - y0*g)+Math.sqrt( f  )  )/(g*g)*2;\n                    if(u<= -end)\n                        {\n                                System.out.println(\"No\");\n                                continue ;\n                        }\n\n\t\t          \n                          double t0;\n                            t0=Math.sqrt(u);\n                            double t2;\n                            double t1=0.0;\n                              t2=1.0;\n                    int  flag=1;  \n\t\t\t  \n                    double u1=(  (v*v - y0*g)-Math.sqrt( f  )  )/(g*g)*2;\n                    if(u1>=end)\n                            t1=Math.sqrt(u1);\n\t\t       \n                    for( t2=t0;t2>=t1;t2=t2-end )\n                            {\n                                        flag=solove(x0,y0,t2,v);\n                                        if(flag==0 || flag==2)\n                                            break;\n                            }\n                         \n                    if(flag!=0)\n                        System.out.println(\"No\");\n                    else\n                        System.out.println(\"Yes\");\n     \n            }\n           }\n   }"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main{\n\tstatic int N, V, X, Y;\n\tstatic int[] L, B, R, T;\n\tstatic double g = 9.8;\n\tstatic double EPS = 1e-6;\n\n//\t根据y&#36724;方向的初速度vy和重力g，返回t&#26102;&#38388;点&#26102;的位置y\n\tprivate static double calc(double vy, double t) {\n\t\treturn vy*t - g*t*t/2;\n\t}\n\t\n\tprivate static int cmp(int lb, int ub, double a) {\n\t\treturn a < lb+EPS ? -1 : a > ub-EPS ? 1 : 0;\n\t}\n\t\n\tprivate static boolean check(double qx, double qy){\n\t\tdouble a = g*g/4;\n\t\tdouble b = g*qy - V*V;\n\t\tdouble c = qx*qx + qy*qy;\n\t\tdouble D = b*b - 4*a*c;\n\t\tif(D<0 & D>-EPS) D=0;\n\t\tif(D < 0) return false;\n\t\t\n\t\tfor(int d = -1; d < 2; d=d+2){\n\t\t\tdouble t2 = (-b + d*Math.sqrt(D)) / (2*a);\t\t\t\n\t\t\tif(t2 < 0) continue;\n\t\t\tdouble t = Math.sqrt(t2);\n//\t\t\tSystem.out.println(t);\n\t\t\tdouble vx = qx / t;\n\t\t\tdouble vy = Math.sqrt(V*V - vx*vx);\n\t\t\t\n\t\t\tdouble yt = calc(vy, X/vx);\n\t\t\tif(yt < Y - EPS) continue;\n\t\t\t\n\t\t\tboolean ok = true;\n\t\t\tfor(int i = 0; i < N; i++){\n//\t\t\t\t石&#22836;在pig右&#36793;，直接&#36807;&#28388;\n\t\t\t\tif(L[i] >= X) continue;\n//\t\t\t\t当来到pig正上方&#26102;，与pig之&#38388;有没有障碍物\n\t\t\t\tif(R[i] >= X & T[i] >= Y & yt >= B[i]) ok = false;\t\t\t\t\n//\t\t\t\t中途会不会遇到障碍\n//\t\t\t\t一共要判定4条\n//\t\t\t\t一：与&#27599;个障碍物的左&#36793;界的相&#23545;位置\n\t\t\t\tint yL = cmp(B[i], T[i], calc(vy, L[i]/vx));\n//\t\t\t\t二：与&#27599;个障碍物的右&#36793;界的相&#23545;位置\n\t\t\t\tint yR = cmp(B[i], T[i], calc(vy, R[i]/vx));\n//\t\t\t\t三：bird升到最高点&#26102;与&#27599;个障碍物的上下界的相&#23545;位置\n\t\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g));\n//\t\t\t\t四：bird升到最高点&#26102;与&#27599;个障碍物的左右界的相&#23545;位置（？）\n\t\t\t\tint yH = cmp(B[i], T[i], calc(vy, vy/g));\n\t\t\t\t\n\t\t\t\tif(yL* yR <= 0) ok = false;\n\t\t\t\tif(xH == 0 & yH >= 0 & yL < 0) ok = false;\n\t\t\t}\n\t\t\tif(ok) return true;\n\t\t}\t\t\n\t\treturn false;\n\t}\t\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tN = s.nextInt();\n\t\tV = s.nextInt();\n\t\tX = s.nextInt();\n\t\tY = s.nextInt();\n\t\t\n\t\tL = new int[N];\n\t\tB = new int[N];\n\t\tR = new int[N];\n\t\tT = new int[N];\n\t\t\n\t\tfor(int i = 0; i < N; i ++){\n\t\t\tL[i] = s.nextInt();\n\t\t\tB[i] = s.nextInt();\n\t\t\tR[i] = s.nextInt();\n\t\t\tT[i] = s.nextInt();\n\t\t}\n\t\t\n\t\tboolean ok = check(X,Y);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tok |= check(L[i], T[i]);\n\t\t\tok |= check(R[i], T[i]);\n\t\t}\n\t\t\n\t\tif(ok)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main{\n\tstatic int N, V, X, Y;\n\tstatic int[] L, B, R, T;\n\tstatic double g = 9.8;\n\tstatic double EPS = 1e-6;\n\n//\t根据y&#36724;方向的初速度vy和重力g，返回t&#26102;&#38388;点&#26102;的位置y\n\tprivate static double calc(double vy, double t) {\n\t\treturn vy*t - g*t*t/2;\n\t}\n\t\n\tprivate static int cmp(int lb, int ub, double a) {\n\t\treturn a < lb+EPS ? -1 : a > ub-EPS ? 1 : 0;\n\t}\n\t\n\tprivate static boolean check(double qx, double qy){\n\t\tdouble a = g*g/4;\n\t\tdouble b = g*qy - V*V;\n\t\tdouble c = qx*qx + qy*qy;\n\t\tdouble D = b*b - 4*a*c;\n\t\tif(D<0 & D>-EPS) D=0;\n\t\tif(D < 0) return false;\n\t\t\n\t\tfor(int d = -1; d < 2; d=d+2){\n\t\t\tdouble t2 = (-b + d*Math.sqrt(D)) / (2*a);\t\n\n//\t\t\tSystem.out.println(t2);\n\t\t\tif(t2 < 0) continue;\n\t\t\tdouble t = Math.sqrt(t2);\n\t\t\tdouble vx = qx / t;\n\t\t\tdouble vy = Math.sqrt(V*V - vx*vx);\n\t\t\t\n\t\t\tdouble yt = calc(vy, X/vx);\n\t\t\tif(yt < Y - EPS) continue;\n\t\t\t\n\t\t\tboolean ok = true;\n\t\t\tfor(int i = 0; i < N; i++){\n//\t\t\t\t石&#22836;在pig右&#36793;，直接&#36807;&#28388;\n\t\t\t\tif(L[i] >= X) continue;\n//\t\t\t\t当来到pig正上方&#26102;，与pig之&#38388;有没有障碍物\n\t\t\t\tif(R[i] >= X & T[i] >= Y & yt >= B[i]) ok = false;\t\t\t\t\n//\t\t\t\t中途会不会遇到障碍\n//\t\t\t\t一共要判定4条\n//\t\t\t\t一：与&#27599;个障碍物的左&#36793;界的相&#23545;位置\n\t\t\t\tint yL = cmp(B[i], T[i], calc(vy, L[i]/vx));\n//\t\t\t\t二：与&#27599;个障碍物的右&#36793;界的相&#23545;位置\n\t\t\t\tint yR = cmp(B[i], T[i], calc(vy, R[i]/vx));\n//\t\t\t\t三：bird升到最高点&#26102;与&#27599;个障碍物的左右界的相&#23545;位置\n\t\t\t\tint xH = cmp(L[i], R[i], vx*(vy/g));\n//\t\t\t\t四：bird升到最高点&#26102;与&#27599;个障碍物的上下界的相&#23545;位置（？）\n\t\t\t\tint yH = cmp(B[i], T[i], calc(vy, vy/g));\n\t\t\t\t\n//\t\t\t\tSystem.out.println(yL+\" \"+yR+\" \"+xH+\" \"+yH);\n\t\t\t\tif(yL* yR <= 0) ok = false;\n\t\t\t\tif(xH == 0 & yH >= 0 & yL < 0) ok = false;\n\t\t\t}\n\t\t\tif(ok) return true;\n\t\t}\t\t\n\t\treturn false;\n\t}\t\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tN = s.nextInt();\n\t\tV = s.nextInt();\n\t\tX = s.nextInt();\n\t\tY = s.nextInt();\n\t\t\n\t\tL = new int[N];\n\t\tB = new int[N];\n\t\tR = new int[N];\n\t\tT = new int[N];\n\t\t\n\t\tfor(int i = 0; i < N; i ++){\n\t\t\tL[i] = s.nextInt();\n\t\t\tB[i] = s.nextInt();\n\t\t\tR[i] = s.nextInt();\n\t\t\tT[i] = s.nextInt();\n\t\t\tif(R[i] > X) R[i] = X;\n\t\t}\n\t\t\n\t\tboolean ok = check(X,Y);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tok |= check(L[i], T[i]);\n\t\t\tok |= check(R[i], T[i]);\n\t\t}\n\t\t\n\t\tif(ok)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly double g = 9.8;\n    static readonly double Eps = 1e-9;\n    int N, V, X, Y;\n    int[][] Obstacles;\n\n    public void Solve()\n    {\n        N = Reader.Int(); V = Reader.Int(); X = Reader.Int(); Y = Reader.Int();\n        Obstacles = Reader.IntTable(N); // L, B, R, T\n        bool yes = Can(X, Y) || Obstacles.Any(a => Can(a[0], a[3]) || Can(a[2], a[3]));\n        Console.WriteLine(yes ? \"Yes\" : \"No\");\n    }\n\n    private bool Can(int x, int y)\n    {\n        double a = g * g / 4;\n        double b = g * y - V * V;\n        double c = x * x + y * y;\n        double D = b * b - 4 * a * c;\n        if (D <= 0) return false;\n        for (int sign = -1; sign <= 1; sign += 2)\n        {\n            double t2 = (-b + sign * Math.Sqrt(D)) / (2 * a);\n            if (t2 <= 0) continue;\n            double t = Math.Sqrt(t2);\n            double vx = x / t;\n            double vy = (y + g * t * t / 2) / t;\n            if (AllOK(vx, vy)) return true;\n        }\n        return false;\n    }\n\n    private bool AllOK(double vx, double vy)\n    {\n        Func<double, double> CalcY = time => time * (vy - g * time / 2);\n        double t = X / vx;\n        double ty = CalcY(t);\n        if (ty < Y - Eps) return false;\n\n        foreach (var a in Obstacles)\n        {\n            int L = a[0], Bottom = a[1], R = a[2], Top = a[3];\n            R = Math.Min(R, X);\n            if (L >= X) continue;\n            if (R >= X && Top >= Y && Bottom <= ty) return false;\n            int YL = Compare(CalcY(L / vx), Bottom, Top);\n            int YR = Compare(CalcY(R / vx), Bottom, Top);\n            if (YL * YR <= 0) return false;\n            double topT = vy / g;\n            int XH = Compare(vx * topT, L, R);\n            int YH = Compare(CalcY(topT), Bottom, Top);\n            if (XH == 0 && YL < 0 && YH >= 0) return false;\n        }\n        return true;\n    }\n\n    int Compare(double v, int lb, int ub)\n    {\n        if (v < lb + Eps) return -1;\n        if (v > ub - Eps) return 1;\n        return 0;\n    }\n\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-9;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; ; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly double g = 9.8;\n    static readonly double Eps = 1e-9;\n    int N, V, X, Y;\n    int[][] Obstacles;\n\n    public void Solve()\n    {\n        N = Reader.Int(); V = Reader.Int(); X = Reader.Int(); Y = Reader.Int();\n        Obstacles = Reader.IntTable(N); // L, B, R, T\n        bool yes = Can(X, Y) || Obstacles.Any(a => Can(a[0], a[3]) || Can(a[2], a[3]));\n        Console.WriteLine(yes ? \"Yes\" : \"No\");\n    }\n\n    private bool Can(int x, int y)\n    {\n        double a = g * g / 4;\n        double b = g * y - V * V;\n        double c = x * x + y * y;\n        double D = b * b - 4 * a * c;\n        if (D <= 0) return false;\n        for (int sign = -1; sign <= 1; sign += 2)\n        {\n            double t2 = (-b + sign * Math.Sqrt(D)) / (2 * a);\n            if (t2 <= 0) continue;\n            double t = Math.Sqrt(t2);\n            double vx = x / t;\n            double vy = (y + g * t * t / 2) / t;\n            if (AllOK(vx, vy)) return true;\n        }\n        return false;\n    }\n\n    private bool AllOK(double vx, double vy)\n    {\n        Func<double, double> CalcY = time => time * (vy - g * time / 2);\n        double t = X / vx;\n        double ty = CalcY(t);\n        if (ty < Y - Eps) return false;\n\n        foreach (var a in Obstacles)\n        {\n            int L = a[0], Bottom = a[1], R = a[2], Top = a[3];\n            R = Math.Min(R, X);\n            if (L >= X) continue;\n            if (R >= X && Top >= Y && Bottom <= ty) return false;\n            int YL = Compare(CalcY(L / vx), Bottom, Top);\n            int YR = Compare(CalcY(R / vx), Bottom, Top);\n            if (YL * YR <= 0) return false;\n            double topT = vy / g;\n            int XH = Compare(vx * topT, L, R);\n            int YH = Compare(CalcY(topT), Bottom, Top);\n            if (XH == 0 && YL < 0 && YH >= 0) return false;\n        }\n        return true;\n    }\n\n    int Compare(double v, int lb, int ub)\n    {\n        if (v < lb + Eps) return -1;\n        if (v > ub - Eps) return 1;\n        return 0;\n    }\n\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-9;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; ; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly double g = 9.8;\n    static readonly double Eps = 1e-9;\n    int N, V, X, Y;\n    int[][] Obstacles;\n\n    public void Solve()\n    {\n        N = Reader.Int(); V = Reader.Int(); X = Reader.Int(); Y = Reader.Int();\n        Obstacles = Reader.IntTable(N); // L, B, R, T\n        bool yes = Can(X, Y) || Obstacles.Any(a => Can(a[0], a[3]) || Can(a[2], a[3]));\n        Console.WriteLine(yes ? \"Yes\" : \"No\");\n    }\n\n    private bool Can(int x, int y)\n    {\n        double a = g * g / 4;\n        double b = g * y - V * V;\n        double c = x * x + y * y;\n        double D = b * b - 4 * a * c;\n        if (D <= 0) return false;\n        for (int sign = -1; sign <= 1; sign += 2)\n        {\n            double t2 = (-b + sign * Math.Sqrt(D)) / (2 * a);\n            if (t2 <= 0) continue;\n            double t = Math.Sqrt(t2);\n            double vx = x / t;\n            double vy = (y + g * t * t / 2) / t;\n            if (AllOK(vx, vy)) return true;\n        }\n        return false;\n    }\n\n    private bool AllOK(double vx, double vy)\n    {\n        Func<double, double> CalcY = time => time * (vy - g * time / 2);\n        double t = X / vx;\n        double ty = CalcY(t);\n        if (ty < Y - Eps) return false;\n\n        foreach (var a in Obstacles)\n        {\n            int L = a[0], Bottom = a[1], R = a[2], Top = a[2];\n            R = Math.Min(R, X);\n            if (L >= X) continue;\n            if (R >= X && Top >= Y && Bottom <= ty + Eps) return false;\n            int YL = Compare(CalcY(L / vx), Bottom, Top);\n            int YR = Compare(CalcY(R / vx), Bottom, Top);\n            if (YL * YR <= 0) return false;\n            double topT = vy / g;\n            int XH = Compare(vx * topT, L, R);\n            int YH = Compare(vy * topT, Bottom, Top);\n            if (XH == 0 && YL < 0 && YH >= 0) return false;\n\n        }\n        return true;\n    }\n\n    int Compare(double v, int lb, int ub)\n    {\n        if (v < lb + Eps) return -1;\n        if (v > ub - Eps) return 1;\n        return 0;\n    }\n\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-9;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; ; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "# aoj 2308\nimport sys\ninput = sys.stdin.readline\n\n\ndef calc_y(vy, t):\n    return vy*t - g/2*t*t\n\n\ndef loc(y, b, t):\n    if y < b+eps:\n        return -1\n    if y > t-eps:\n        return 1\n    return 0\n\n\ndef can_hit(x, y):\n    if x == 0:\n        return False\n    a = g*g/4\n    b = g*y-V*V\n    c = x*x+y*y\n    D = b*b-4*a*c\n    if D < -eps:  # cannot reach\n        return False\n    if -eps <= D < 0:\n        D = 0\n    for d in [-1, 1]:\n        t2 = (-b+d*D**.5) / (2*a)\n        if t2 <= 0:\n            continue\n        t = t2**.5\n        vx = x/t\n        vy = y/t + g/2*t\n        if calc_y(vy, X/vx) < Y-eps:  # cannot go above the pig\n            continue\n        maxt = vy/g\n        maxx = vx*maxt\n        maxy = calc_y(vy, maxt)\n        for L, B, R, T in obstacles:\n            left = loc(calc_y(vy, L/vx), B, T)\n            right = loc(calc_y(vy, R/vx), B, T)\n            if left*right <= 0:\n                break\n            if L <= maxx <= R:\n                mid = loc(maxy, B, T)\n                if left*mid <= 0:\n                    break\n        else:\n            return True\n    return False\n\n\ng = 9.8\neps = 1e-10\nN, V, X, Y = map(int, input().split())\nobstacles = []\nfor _ in range(N):\n    L, B, R, T = map(int, input().split())\n    R = min(R, X)\n    if L <= X:\n        obstacles.append((L, B, R, T))\nif X == 0:\n    if V*V/(2*g) < Y-eps:\n        print('No')\n        exit()\n    for L, B, R, T in obstacles:\n        if B < Y:\n            print('No')\n            exit()\n    print('Yes')\n    exit()\n\n# hit directly\nif can_hit(X, Y):\n    print('Yes')\n    exit()\n\nfor L, B, R, T in obstacles:\n    if can_hit(L, T) or can_hit(R, T):\n        print('Yes')\n        exit()\nprint('No')\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ng = 9.8\nESP = 1e-6\n\n\ndef calc(vy, t):\n    return vy * t - g * t * t / 2\n\n\ndef cmp(lb, ub, a):\n    if a < lb + ESP:\n        return -1\n    elif ub - ESP < a:\n        return 1\n    else:\n        return 0\n\n\ndef check(qx, qy):\n    a = (g * g) / 4\n    b = g * qy - V * V\n    c = qx * qx + qy * qy\n    D = b * b - 4 * a * c\n\n    if D < 0 and -ESP < D:\n        D = 0\n\n    if D < 0:\n        return False\n\n    for d in range(-1, 2, 2):\n        t2 = (-b + d * math.sqrt(D)) / (2 * a)\n        if t2 <= 0:\n            continue\n\n        t = math.sqrt(t2)\n        vx = qx / t\n        vy = (qy + g * t * t / 2) / t\n\n        yt = calc(vy, X / vx)\n        if yt < Y - ESP:\n            continue\n        ok = True\n\n        for i in range(0, N):\n            if L[i] >= X:\n                continue\n\n            if R[i] == X and Y <= T[i] and B[i] <= yt:\n                ok = False\n\n            yL = cmp(B[i], T[i], calc(vy, L[i] / vx))\n            yR = cmp(B[i], T[i], calc(vy, R[i] / vx))\n\n            xH = cmp(L[i], R[i], vx * (vy / g))\n            yH = cmp(B[i], T[i], calc(vy, vy / g))\n            if xH == 0 and yH >= 0 and yL < 0:\n                ok = False\n            if yL * yR <= 0:\n                ok = False\n        if ok:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    N, V, X, Y = list(map(int, input().split()))\n    L = []\n    B = []\n    R = []\n    T = []\n    for i in range(N):\n        tmp_L, tmp_B, tmp_R, tmp_T = list(map(int, input().split()))\n        L.append(tmp_L)\n        B.append(tmp_B)\n        R.append(tmp_R)\n        T.append(tmp_T)\n\n    for i in range(0, N):\n        R[i] = min(R[i], X)\n\n    ok = check(X, Y)\n    for i in range(0, N):\n        if L[i] == 0 and T[i] != 0:\n            pass\n        else:\n            ok |= check(L[i], T[i])\n\n        if R[i] == 0 and T[i] != 0:\n            pass\n        else:\n            ok |= check(R[i], T[i])\n\n    print(\"Yes\" if ok else 'No')"
  },
  {
    "language": "Python",
    "code": "import math\n\ng = 9.8\nESP = 1e-6\n\n\ndef calc(vy, t):\n    return vy * t - g * t * t / 2\n\n\ndef cmp(lb, ub, a):\n    if a < lb + ESP:\n        return -1\n    elif ub - ESP < a:\n        return 1\n    else:\n        return 0\n\n\ndef check(qx, qy):\n    a = (g * g) / 4\n    b = g * qy - V * V\n    c = qx * qx + qy * qy\n    D = b * b - 4 * a * c\n\n    if D < 0 and -ESP < D:\n        D = 0\n\n    if D < 0:\n        return False\n\n    for d in range(-1, 2, 2):\n        t2 = (-b + d * math.sqrt(D)) / (2 * a)\n        if t2 <= 0:\n            continue\n\n        t = math.sqrt(t2)\n        vx = qx / t\n        vy = (qy + g * t * t / 2) / t\n\n        yt = calc(vy, X / vx)\n        if yt < Y - ESP:\n            continue\n        ok = True\n\n        for i in range(0, N):\n            if L[i] >= X:\n                continue\n\n            if R[i] == X and Y <= T[i] and B[i] <= yt:\n                ok = False\n\n            yL = cmp(B[i], T[i], calc(vy, L[i] / vx))\n            yR = cmp(B[i], T[i], calc(vy, R[i] / vx))\n\n            xH = cmp(L[i], R[i], vx * (vy / g))\n            yH = cmp(B[i], T[i], calc(vy, vy / g))\n            if xH == 0 and yH >= 0 and yL < 0:\n                ok = False\n            if yL * yR <= 0:\n                ok = False\n        if ok:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    N, V, X, Y = list(map(int, input().split()))\n    L = []\n    B = []\n    R = []\n    T = []\n    for i in range(N):\n        tmp_L, tmp_B, tmp_R, tmp_T = list(map(int, input().split()))\n        L.append(tmp_L)\n        B.append(tmp_B)\n        R.append(tmp_R)\n        T.append(tmp_T)\n\n    for i in range(0, N):\n        R[i] = min(R[i], X)\n\n    ok = check(X, Y)\n    for i in range(0, N):\n        if L[i] == 0 and T[i] != 0:\n            pass\n        else:\n            ok |= check(L[i], T[i])\n\n        if R[i] == 0 and T[i] != 0:\n            pass\n        else:\n            ok |= check(R[i], T[i])\n\n    print(\"Yes\" if ok else 'No')"
  },
  {
    "language": "Python",
    "code": "def calc(vy,t):\n     return vy*t - g/2*t*t\n\ndef cmp(lb,ub,x):\n     if x < lb + eps:\n          return -1\n     elif x > ub - eps:\n          return 1\n     return 0\n\ndef check(qx,qy):\n     if qx == 0:\n          return 0\n     a = g*g/4\n     b = qy*g-V*V\n     c = qx*qx+qy*qy\n     D = b*b-4*a*c\n     if D < -eps:\n          return 0\n     if -eps<=D<0:\n          D = 0\n     for d in (-1,1):\n          tt = (-b+d*D**.5)/(2*a)\n          if tt <= 0:\n               continue\n          t = tt**.5\n          vx = qx/t\n          vy = qy/t+g*t/2\n          if calc(vy,X/vx) < Y - eps:\n               return 0\n          for L,B,R,T in obstacles:\n               l = cmp(B,T,calc(vy,L/vx))\n               r = cmp(B,T,calc(vy,R/vx))\n               xh = cmp(L,R,vx*(vy/g))\n               yh = cmp(B,T,calc(vy,vy/g))\n               if l*r <= 0 or not xh and yh*l <= 0:\n                    break\n          else:\n               return 1\n     return 0\n\ng = 9.8\neps = 1e-10\nN,V,X,Y = map(int,input().split())\nobstacles = []\nfor i in range(N):\n     L,B,R,T = map(int,input().split())\n     if L < X:\n          obstacles.append((L,B,min(R,X),T))\n\nif check(X,Y):\n     print('Yes')\n     exit()\nfor L,B,R,T in obstacles:\n     if not L or not R:\n          continue\n     if check(L,T) or check(R,T):\n          print('Yes')\n          exit()\nprint('No')\n\n"
  }
]