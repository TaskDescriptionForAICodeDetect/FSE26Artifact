[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Obstacle;\n\ntypedef struct {\n    double x, y;\n} Point;\n\nbool isPointInsideObstacle(Point p, Obstacle obs) {\n    return (p.x >= obs.x1 && p.x <= obs.x2 && p.y >= obs.y1 && p.y <= obs.y2);\n}\n\nbool lineIntersectsObstacle(Point p1, Point p2, Obstacle obs) {\n    double x1 = p1.x, y1 = p1.y;\n    double x2 = p2.x, y2 = p2.y;\n    \n    double left = obs.x1, right = obs.x2;\n    double bottom = obs.y1, top = obs.y2;\n    \n    if (x1 < left && x2 < left) return false;\n    if (x1 > right && x2 > right) return false;\n    if (y1 < bottom && y2 < bottom) return false;\n    if (y1 > top && y2 > top) return false;\n    \n    if (isPointInsideObstacle(p1, obs) || isPointInsideObstacle(p2, obs)) return true;\n    \n    double m = (y2 - y1) / (x2 - x1);\n    double y_at_left = y1 + m * (left - x1);\n    if (y_at_left >= bottom && y_at_left <= top && ((x1 <= left && x2 >= left) || (x2 <= left && x1 >= left))) return true;\n    \n    double y_at_right = y1 + m * (right - x1);\n    if (y_at_right >= bottom && y_at_right <= top && ((x1 <= right && x2 >= right) || (x2 <= right && x1 >= right))) return true;\n    \n    double x_at_bottom = x1 + (bottom - y1) / m;\n    if (x_at_bottom >= left && x_at_bottom <= right && ((y1 <= bottom && y2 >= bottom) || (y2 <= bottom && y1 >= bottom))) return true;\n    \n    double x_at_top = x1 + (top - y1) / m;\n    if (x_at_top >= left && x_at_top <= right && ((y1 <= top && y2 >= top) || (y2 <= top && y1 >= top))) return true;\n    \n    return false;\n}\n\nbool canHitPig(double v0, double pigX, double pigY, Obstacle obstacles[], int numObstacles) {\n    double g = 9.8;\n    double t = pigX / v0;\n    double y = -0.5 * g * t * t;\n    \n    if (y > pigY) return false;\n    \n    Point birdStart = {0.0, 0.0};\n    Point birdAtPigX = {pigX, y};\n    \n    for (int i = 0; i < numObstacles; i++) {\n        if (lineIntersectsObstacle(birdStart, birdAtPigX, obstacles[i])) {\n            return false;\n        }\n    }\n    \n    Point bombStart = {pigX, y};\n    Point pigPos = {pigX, pigY};\n    \n    for (int i = 0; i < numObstacles; i++) {\n        if (lineIntersectsObstacle(bombStart, pigPos, obstacles[i])) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int numObstacles;\n    double v0, pigX, pigY;\n    scanf(\"%d %lf %lf %lf\", &numObstacles, &v0, &pigX, &pigY);\n    \n    Obstacle obstacles[numObstacles];\n    for (int i = 0; i < numObstacles; i++) {\n        scanf(\"%lf %lf %lf %lf\", &obstacles[i].x1, &obstacles[i].y1, &obstacles[i].x2, &obstacles[i].y2);\n    }\n    \n    if (canHitPig(v0, pigX, pigY, obstacles, numObstacles)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nstruct Rectangle {\n    Point bottomLeft, topRight;\n};\n\nbool isPointInsideRectangle(const Point& p, const Rectangle& rect) {\n    return p.x >= rect.bottomLeft.x && p.x <= rect.topRight.x &&\n           p.y >= rect.bottomLeft.y && p.y <= rect.topRight.y;\n}\n\nbool doesSegmentIntersectRectangle(const Point& p1, const Point& p2, const Rectangle& rect) {\n    if (isPointInsideRectangle(p1, rect) || isPointInsideRectangle(p2, rect)) {\n        return true;\n    }\n\n    double x1 = p1.x, y1 = p1.y;\n    double x2 = p2.x, y2 = p2.y;\n    double xmin = rect.bottomLeft.x, ymin = rect.bottomLeft.y;\n    double xmax = rect.topRight.x, ymax = rect.topRight.y;\n\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n\n    double t0 = 0.0, t1 = 1.0;\n\n    if (!clipTest(-dx, x1 - xmin, t0, t1)) return false;\n    if (!clipTest(dx, xmax - x1, t0, t1)) return false;\n    if (!clipTest(-dy, y1 - ymin, t0, t1)) return false;\n    if (!clipTest(dy, ymax - y1, t0, t1)) return false;\n\n    return true;\n}\n\nbool clipTest(double p, double q, double& t0, double& t1) {\n    if (p == 0) {\n        if (q < 0) return false;\n    } else {\n        double r = q / p;\n        if (p < 0) {\n            if (r > t1) return false;\n            if (r > t0) t0 = r;\n        } else {\n            if (r < t0) return false;\n            if (r < t1) t1 = r;\n        }\n    }\n    return true;\n}\n\nbool canHitPig(double v0, double X, double Y, const vector<Rectangle>& obstacles) {\n    double g = 9.8;\n    double a = -g / (2 * v0 * v0);\n    double b = 1.0;\n    double c = a * X * X - Y;\n\n    double discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) return false;\n\n    double sqrt_discriminant = sqrt(discriminant);\n    double t1 = (-b + sqrt_discriminant) / (2 * a);\n    double t2 = (-b - sqrt_discriminant) / (2 * a);\n\n    double theta1 = atan(t1);\n    double theta2 = atan(t2);\n\n    for (double theta : {theta1, theta2}) {\n        double vx = v0 * cos(theta);\n        double vy = v0 * sin(theta);\n\n        double t_hit = X / vx;\n        if (t_hit <= 0) continue;\n\n        double y_hit = vy * t_hit - 0.5 * g * t_hit * t_hit;\n        if (abs(y_hit - Y) > 1e-6) continue;\n\n        Point start = {0.0, 0.0};\n        Point end = {X, Y};\n        bool collision = false;\n        for (const auto& rect : obstacles) {\n            if (doesSegmentIntersectRectangle(start, end, rect)) {\n                collision = true;\n                break;\n            }\n        }\n        if (!collision) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int N;\n    double v0, X, Y;\n    cin >> N >> v0 >> X >> Y;\n\n    vector<Rectangle> obstacles(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> obstacles[i].bottomLeft.x >> obstacles[i].bottomLeft.y;\n        cin >> obstacles[i].topRight.x >> obstacles[i].topRight.y;\n    }\n\n    if (canHitPig(v0, X, Y, obstacles)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WhiteBird {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        double V = scanner.nextDouble();\n        double X = scanner.nextDouble();\n        double Y = scanner.nextDouble();\n        \n        List<Rectangle> obstacles = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            double x1 = scanner.nextDouble();\n            double y1 = scanner.nextDouble();\n            double x2 = scanner.nextDouble();\n            double y2 = scanner.nextDouble();\n            obstacles.add(new Rectangle(x1, y1, x2, y2));\n        }\n        \n        boolean canHit = canHitPig(V, X, Y, obstacles);\n        System.out.println(canHit ? \"Yes\" : \"No\");\n    }\n    \n    private static boolean canHitPig(double V, double X, double Y, List<Rectangle> obstacles) {\n        double g = 9.8;\n        double bestT = -1;\n        double minT = 0;\n        double maxT = 2 * V * Math.sin(Math.PI / 4) / g;\n        \n        for (int i = 0; i < 1000; i++) {\n            double mid1 = minT + (maxT - minT) / 3;\n            double mid2 = maxT - (maxT - minT) / 3;\n            \n            double y1 = V * mid1 * Math.sin(Math.PI / 4) - 0.5 * g * mid1 * mid1;\n            double y2 = V * mid2 * Math.sin(Math.PI / 4) - 0.5 * g * mid2 * mid2;\n            \n            if (y1 > y2) {\n                maxT = mid2;\n            } else {\n                minT = mid1;\n            }\n        }\n        \n        bestT = (minT + maxT) / 2;\n        double bestY = V * bestT * Math.sin(Math.PI / 4) - 0.5 * g * bestT * bestT;\n        \n        if (bestY < Y) {\n            return false;\n        }\n        \n        double t = (X) / (V * Math.cos(Math.PI / 4));\n        if (t < 0) {\n            return false;\n        }\n        \n        double birdY = V * t * Math.sin(Math.PI / 4) - 0.5 * g * t * t;\n        if (birdY < Y) {\n            return false;\n        }\n        \n        for (Rectangle rect : obstacles) {\n            if (rect.x1 <= X && X <= rect.x2) {\n                double obstacleTop = rect.y2;\n                if (obstacleTop >= Y && obstacleTop <= birdY) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    static class Rectangle {\n        double x1, y1, x2, y2;\n        \n        Rectangle(double x1, double y1, double x2, double y2) {\n            this.x1 = Math.min(x1, x2);\n            this.y1 = Math.min(y1, y2);\n            this.x2 = Math.max(x1, x2);\n            this.y2 = Math.max(y1, y2);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:23:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WhiteBirdEggBombStrategy {\n    public static String canDropEggBomb(int numObstacles, double initialSpeed, int pigX, int pigY, int[][] obstacles) {\n        // Calculate trajectory parameters\n        double gravity = 9.8;\n        double timeToReachPig = Math.sqrt((2 * pigY) / gravity);\n        double horizontalDistance = initialSpeed * timeToReachPig;\n\n        // Check for obstacle collisions\n        for (int[] obstacle : obstacles) {\n            int left = obstacle[0];\n            int right = obstacle[2];\n            int top = obstacle[3];\n            int bottom = obstacle[1];\n\n            // Calculate time when white bird passes obstacle's horizontal range\n            double timeAtObstacleX = (left + right) / (2.0 * initialSpeed);\n\n            // Calculate height at obstacle's horizontal range\n            double heightAtObstacleX = initialSpeed * timeAtObstacleX - 0.5 * gravity * timeAtObstacleX * timeAtObstacleX;\n\n            // Check if trajectory intersects obstacle\n            if (timeAtObstacleX >= 0 && timeAtObstacleX <= timeToReachPig) {\n                if (heightAtObstacleX >= bottom && heightAtObstacleX <= top) {\n                    return \"No\";\n                }\n            }\n        }\n\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int numObstacles = scanner.nextInt();\n        double initialSpeed = scanner.nextDouble();\n        int pigX = scanner.nextInt();\n        int pigY = scanner.nextInt();\n        \n        int[][] obstacles = new int[numObstacles][4];\n        for (int i = 0; i < numObstacles; i++) {\n            obstacles[i][0] = scanner.nextInt(); // left\n            obstacles[i][1] = scanner.nextInt(); // bottom\n            obstacles[i][2] = scanner.nextInt(); // right\n            obstacles[i][3] = scanner.nextInt(); // top\n        }\n        \n        String result = canDropEggBomb(numObstacles, initialSpeed, pigX, pigY, obstacles);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:23:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_OBSTACLES 100\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Obstacle;\n\nbool line_intersect(double x1, double y1, double x2, double y2, \n                    double x3, double y3, double x4, double y4) {\n    double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / \n                ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n    double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / \n                ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n    return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);\n}\n\nbool check_trajectory(double speed, double pig_x, double pig_y, \n                      Obstacle obstacles[], int num_obstacles) {\n    double max_height = (speed * speed) / (2 * 9.8);\n    \n    for (int i = 0; i < num_obstacles; i++) {\n        Obstacle obs = obstacles[i];\n        \n        if (line_intersect(0, 0, pig_x, pig_y, \n                           obs.x1, obs.y1, obs.x1, obs.y2) ||\n            line_intersect(0, 0, pig_x, pig_y, \n                           obs.x1, obs.y1, obs.x2, obs.y1) ||\n            line_intersect(0, 0, pig_x, pig_y, \n                           obs.x2, obs.y2, obs.x1, obs.y2) ||\n            line_intersect(0, 0, pig_x, pig_y, \n                           obs.x2, obs.y2, obs.x2, obs.y1)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int num_obstacles;\n    double speed, pig_x, pig_y;\n    Obstacle obstacles[MAX_OBSTACLES];\n    \n    scanf(\"%d %lf %lf %lf\", &num_obstacles, &speed, &pig_x, &pig_y);\n    \n    for (int i = 0; i < num_obstacles; i++) {\n        scanf(\"%lf %lf %lf %lf\", &obstacles[i].x1, &obstacles[i].y1, \n                                 &obstacles[i].x2, &obstacles[i].y2);\n    }\n    \n    if (check_trajectory(speed, pig_x, pig_y, obstacles, num_obstacles)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Obstacle {\n    double x1, y1, x2, y2;\n};\n\nbool intersect(double x, double y, double px, double py, vector<Obstacle>& obstacles) {\n    for (auto& obs : obstacles) {\n        // Check if the trajectory line intersects the obstacle\n        if (x >= min(obs.x1, obs.x2) && x <= max(obs.x1, obs.x2) &&\n            y >= min(obs.y1, obs.y2) && y <= max(obs.y1, obs.y2)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, v, px, py;\n    cin >> n >> v >> px >> py;\n    \n    vector<Obstacle> obstacles(n);\n    for (int i = 0; i < n; i++) {\n        cin >> obstacles[i].x1 >> obstacles[i].y1 >> obstacles[i].x2 >> obstacles[i].y2;\n    }\n    \n    // Gravity constant\n    const double g = 9.8;\n    \n    // Check if trajectory is possible\n    double t = sqrt(2 * py / g);\n    double x = v * t;\n    \n    if (x >= px && !intersect(px, py, 0, 0, obstacles)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef can_hit_pig(num_obstacles, speed, pig_x, pig_y, obstacles):\n    g = 9.8  # acceleration due to gravity\n\n    # Calculate the time to reach pig's x position\n    time_to_reach_pig_x = pig_x / speed\n\n    # Calculate y position at the time when the bird is over the pig\n    reached_y_at_pig_x = (speed * time_to_reach_pig_x) - (0.5 * g * time_to_reach_pig_x ** 2)\n\n    # Check if the y position is close enough to the pig's y position\n    if reached_y_at_pig_x < pig_y:\n        return \"No\"\n\n    # Check for collisions with obstacles\n    for (x1, y1, x2, y2) in obstacles:\n        # The obstacle is invalid if bird's path passes through (x1, y1) to (x2, y2) at given time\n        if 0 <= x1 <= pig_x or 0 <= x2 <= pig_x:\n            time_to_reach_x1 = x1 / speed\n            y_at_x1 = (speed * time_to_reach_x1) - (0.5 * g * time_to_reach_x1 ** 2)\n\n            if y1 <= y_at_x1 <= y2:\n                return \"No\"\n\n            if x2 != 0:\n                time_to_reach_x2 = x2 / speed\n                y_at_x2 = (speed * time_to_reach_x2) - (0.5 * g * time_to_reach_x2 ** 2)\n\n                if y1 <= y_at_x2 <= y2:\n                    return \"No\"\n\n    return \"Yes\"\n\n\n# Example usage:\nnum_obstacles = 2\nspeed = 10\npig_x = 15\npig_y = 10\nobstacles = [(5, 3, 5, 7), (12, 8, 14, 12)]\n\n# Should output \"No\" or \"Yes\" based on whether the path is clear\nprint(can_hit_pig(num_obstacles, speed, pig_x, pig_y, obstacles))",
    "timestamp": "2025-08-13 06:14:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class WhiteBirdStrategy {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int numObstacles = scanner.nextInt();\n        double initialSpeed = scanner.nextDouble();\n        double pigX = scanner.nextDouble();\n        double pigY = scanner.nextDouble();\n\n        double g = 9.8; // gravitational constant\n        double theta = Math.atan((2 * pigY) / pigX);\n        double timeToPig = pigX / (initialSpeed * Math.cos(theta));\n        double yPositionAtPigX = initialSpeed * timeToPig * Math.sin(theta) - 0.5 * g * timeToPig * timeToPig;\n\n        boolean canDropEgg = true;\n\n        for (int i = 0; i < numObstacles; i++) {\n            double obstacleX1 = scanner.nextDouble();\n            double obstacleY1 = scanner.nextDouble();\n            double obstacleX2 = scanner.nextDouble();\n            double obstacleY2 = scanner.nextDouble();\n\n            if (obstacleX1 < pigX && obstacleX2 > pigX) {\n                // The obstacle spans the vertical drop line of the egg bomb at pigX\n                if (obstacleY1 < yPositionAtPigX && obstacleY2 > yPositionAtPigX) {\n                    canDropEgg = false;\n                    break;\n                }\n            }\n        }\n\n        scanner.close();\n\n        if (canDropEgg) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:15:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define EPSILON 1e-9\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Obstacle;\n\nbool doesIntersect(Obstacle obs, double x, double y_min, double y_max) {\n    if (x < obs.x1 || x > obs.x2) return false;\n    if (y_max < obs.y1 || y_min > obs.y2) return false;\n    return true;\n}\n\nbool canDropBomb(int numObstacles, double v, double targetX, double targetY, Obstacle obstacles[]) {\n    double g = 9.8; // acceleration due to gravity\n    double time = targetX / v;\n    double heightAtTargetX = 0.5 * g * time * time; // y = 0.5 * g * t^2 \n\n    if (heightAtTargetX <= targetY + EPSILON) {\n        for (int i = 0; i < numObstacles; ++i) {\n            double yMin = fmin(obstacles[i].y1, obstacles[i].y2);\n            double yMax = fmax(obstacles[i].y1, obstacles[i].y2);\n            if (doesIntersect(obstacles[i], targetX, yMin, yMax)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    int numObstacles;\n    scanf(\"%d\", &numObstacles);\n    \n    double initialSpeed, targetX, targetY;\n    scanf(\"%lf %lf %lf\", &initialSpeed, &targetX, &targetY);\n    \n    Obstacle obstacles[numObstacles];\n    for (int i = 0; i < numObstacles; ++i) {\n        scanf(\"%lf %lf %lf %lf\", &obstacles[i].x1, &obstacles[i].y1, &obstacles[i].x2, &obstacles[i].y2);\n    }\n\n    if (canDropBomb(numObstacles, initialSpeed, targetX, targetY, obstacles)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:15:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_hit_pig(speed, pig_x, pig_y, obstacles):\n    def trajectory(x, v0):\n        return (x * x) / (2 * v0 * v0)\n\n    def intersects_obstacle(x, y, obstacle):\n        ox1, oy1, ox2, oy2 = obstacle\n        return (ox1 <= x <= ox2) and (oy1 <= y <= oy2)\n\n    def check_path(v0):\n        bird_y = trajectory(pig_x, v0)\n        \n        if bird_y > pig_y:\n            return False\n        \n        for obstacle in obstacles:\n            if intersects_obstacle(pig_x, bird_y, obstacle):\n                return False\n        \n        return True\n\n    left, right = 0, 1000\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if check_path(mid):\n            right = mid\n        else:\n            left = mid\n\n    return 'Yes' if check_path(left) else 'No'\n\ndef main():\n    n = int(input())\n    v0 = float(input())\n    pig_x, pig_y = map(float, input().split())\n    \n    obstacles = []\n    for _ in range(n):\n        ox1, oy1, ox2, oy2 = map(float, input().split())\n        obstacles.append((ox1, oy1, ox2, oy2))\n    \n    print(can_hit_pig(v0, pig_x, pig_y, obstacles))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:15:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef can_hit_pig():\n    N = int(input())\n    V = float(input())\n    X_pig, Y_pig = map(float, input().split())\n    obstacles = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(float, input().split())\n        obstacles.append((min(x1, x2), max(x1, x2), min(y1, y2), max(y1, y2)))\n    \n    g = 9.8\n    found = False\n    \n    # The bird's trajectory is x = Vx * t, y = Vy * t - 0.5 * g * t^2\n    # The bomb is dropped at some t_drop, then it falls vertically: x remains x_drop, y = y_drop - 0.5 * g * (t - t_drop)^2\n    \n    # The bomb must hit the pig: x_drop = X_pig, and y_drop - 0.5 * g * t_fall^2 = Y_pig\n    # So t_fall = sqrt(2*(y_drop - Y_pig)/g)\n    # The bomb must be dropped at t_drop such that x_drop = Vx * t_drop = X_pig => t_drop = X_pig / Vx\n    # And y_drop = Vy * t_drop - 0.5 * g * t_drop^2\n    \n    # The initial velocity components must satisfy Vx^2 + Vy^2 = V^2\n    # Let Vx = V * cos(theta), Vy = V * sin(theta)\n    \n    # Iterate over possible theta in small steps to check for a valid trajectory\n    for theta_deg in range(0, 9000, 1):\n        theta = theta_deg * math.pi / 18000  # Convert to radians with small steps\n        Vx = V * math.cos(theta)\n        Vy = V * math.sin(theta)\n        \n        if abs(Vx) < 1e-6:\n            continue  # Avoid division by zero\n        \n        t_drop = X_pig / Vx\n        if t_drop < 0:\n            continue  # Time can't be negative\n        \n        y_drop = Vy * t_drop - 0.5 * g * t_drop ** 2\n        if y_drop < Y_pig:\n            continue  # Bomb can't hit the pig if dropped below\n        \n        t_fall = math.sqrt(2 * (y_drop - Y_pig) / g)\n        t_total = t_drop + t_fall\n        \n        # Check if the bird's path before t_drop is clear\n        collision = False\n        steps = 100\n        for i in range(steps + 1):\n            t = t_drop * i / steps\n            x = Vx * t\n            y = Vy * t - 0.5 * g * t ** 2\n            if y < 0:\n                collision = True\n                break\n            for (x1, x2, y1, y2) in obstacles:\n                if x1 <= x <= x2 and y1 <= y <= y2:\n                    collision = True\n                    break\n            if collision:\n                break\n        \n        if not collision:\n            # Check the bomb's vertical path\n            bomb_collision = False\n            for (x1, x2, y1, y2) in obstacles:\n                if x1 <= X_pig <= x2:\n                    # The bomb passes through this obstacle's x range\n                    # The bomb's y during fall: starts at y_drop, falls to Y_pig\n                    # The obstacle's y range is [y1, y2]\n                    # The bomb's y at t_fall is y_drop - 0.5 * g * t_fall^2 = Y_pig\n                    # At any t in [0, t_fall], y = y_drop - 0.5 * g * t^2\n                    # The obstacle's y must be in [Y_pig, y_drop]\n                    if Y_pig <= y2 and y_drop >= y1:\n                        # There is an overlap in y\n                        bomb_collision = True\n                        break\n            if not bomb_collision:\n                found = True\n                break\n    \n    print(\"Yes\" if found else \"No\")\n\ncan_hit_pig()",
    "timestamp": "2025-08-13 06:15:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nstruct Obstacle {\n    double x1, y1, x2, y2;\n};\n\nbool canDropBomb(double speed, double X, double Y, const std::vector<Obstacle>& obstacles) {\n    const double g = 9.8;\n    double t = X / speed;\n    double birdY = speed * t - 0.5 * g * t * t;\n\n    if (birdY < Y) return false;\n\n    for (const auto& obs : obstacles) {\n        if (obs.x1 <= X && X <= obs.x2) {\n            double obstacleTopY = obs.y2;\n            double obstacleBottomY = obs.y1;\n\n            if (obstacleBottomY <= birdY) return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n;\n    double v, X, Y;\n    \n    std::cin >> n >> v >> X >> Y;\n    \n    std::vector<Obstacle> obstacles(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> obstacles[i].x1 >> obstacles[i].y1 >> obstacles[i].x2 >> obstacles[i].y2;\n        if (obstacles[i].x1 > obstacles[i].x2) std::swap(obstacles[i].x1, obstacles[i].x2);\n        if (obstacles[i].y1 > obstacles[i].y2) std::swap(obstacles[i].y1, obstacles[i].y2);\n    }\n    \n    if (canDropBomb(v, X, Y, obstacles)) {\n        std::cout << \"Yes\\n\";\n    } else {\n        std::cout << \"No\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:53"
  }
]