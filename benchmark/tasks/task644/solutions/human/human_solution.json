[
  {
    "language": "Cython",
    "code": "code = r\"\"\"\n# distutils: language=c++\n\n# distutils: include_dirs=[/home/contestant/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]\n\nfrom libcpp cimport bool\n\nfrom libcpp.vector cimport vector\n\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\" nogil:\n\n    cdef cppclass two_sat:\n\n        two_sat(int n)\n\n        void add_clause(int i, bool f, int j, bool g)\n\n        bool satisfiable()\n\n        vector[bool] answer()\n\nfrom libcpp.pair cimport pair\n\nfrom libc.stdlib cimport abs\n\nfrom libc.stdio cimport getchar, printf\n\ncdef int read() nogil:\n\n    cdef int b, c = 0\n\n    while 1:\n\n        b = getchar() - 48\n\n        if b < 0: return c\n\n        c = c * 10 + b\n\ncdef int n = read(), d = read(), i, j\n\ncdef two_sat *ts = new two_sat(n)\n\ncdef vector[pair[int, int]] z = vector[pair[int, int]](n)\n\ncdef vector[bool] res\n\nfor i in range(n):\n\n    z[i].first = read()\n\n    z[i].second = read()\n\nfor i in range(n):\n\n    for j in range(i + 1, n):\n\n        if abs(z[i].first - z[j].first) < d: ts.add_clause(i, True, j, True)\n\n        if abs(z[i].first - z[j].second) < d: ts.add_clause(i, True, j, False)\n\n        if abs(z[i].second - z[j].first) < d: ts.add_clause(i, False, j, True)\n\n        if abs(z[i].second - z[j].second) < d: ts.add_clause(i, False, j, False)\n\nif ts.satisfiable():\n\n    printf('Yes\\n')\n\n    res = ts.answer()\n\n    for i in range(n):\n\n        if res[i]: printf('%d\\n', z[i].second)\n\n        else: printf('%d\\n', z[i].first)\n\nelse:\n\n    printf('No\\n')\n\n\"\"\"\nimport zlib, base64\nopen(\"C.cpython-38-x86_64-linux-gnu.so\", \"wb\").write(zlib.decompress(base64.b85decode(\"c%1CL3s_WD*EoLmoVmdP22l|&C?YD}5EK<ulu?i~Iw*>G%|-+i5`kb)th^**o~BW(EUhfFEW5ten`OP0;0>)eQ@dz)vfGfBcJWr~{MOq0oHJ)e`QGpQp8x-Oe*fp+@XV~eu6ymZ*S?)I%vq6XAEzUPQ(inbibE`Y7{k+L`ix++DwEEoZ~}bx;(Ah9J=glHIMyF>;S8Xj0Sk#TJpg8o@`qYIT3>}s4}g2j{!puD#C9x`+vE0!yNwK*1N3yVUWKez;r55;i9b}-_40d%j^TkYhVzGkdWU7XKp4mQLnZdP-#ZKcH}&PndV4Av9tdCK{Gn3cWYCjC_TPHR;pC>s^|jUyfqpBQsh4eF&SXu@!+vQ%8n5BElX2t^Ir+d-n-_HNyD2&C)X9Nu-!7<_7m0GwSQp3o)dcSb14$oj=HgF3!*Tb=2=ScEpV>+~X2E+lyl;W`9C+WV;W=(1KUaqN@Gg+ch43zt%k$y=<J(J?{5o{RN0aWqUUN^^w$0lIoh<C;89VREA?wc`8FzHagv)E6xVQH30V(>#JJ;?h*w7T)w%L_4`<dp{^=Ga817_~Ocwt^g+=O0g@b!uI^$7%}%}wYXOgEQ*ycK#LcXRrk#+%b4Tk(gqB0sd1djHu<d*5iqA4zv}`Gc+4d5GNH&hA$HS<?#r-d5T>4&Jdhp*QJoE}!0tosU|P4{s%&UClS|_oLj+<*&Cw|FRYOm{#H(-%5OLZ-p+l694a8X;*VAaS&T+Z(%ETwzfk5jk`HLs}=t@v_fy&O1oY%-rUb!t@L|+D}Huwh5lwM@i}6;d4J7r#eWxfbNNfH%qNak;@`KGI3%}{KbftJ)7n<-Y-`2N3$4UqMJsWxYQ_H0R_LF#VrOeBap=>E{H9j?{G%25*{#q`t@LAkEB>5pCC=}*V*d`q&E<!-l83`v>6c5b)Vr@0`QTRk-`t9yFSZhg!L8Uq*_fNq|JjN^OIop$-%6gm(uzE3rQZIn&`-Bw|Ib$PXRZ#{oiJ|eB!&--lI3N3Lovh4<qcU6p3xI;WB5qf&ix#t&$TnWqfGylV0^;3hf^7@_)w*1@+%iHe3wjbATm9`&LX+q3c21g*`I7WPj=$cA7r?)Pt9pX{$82hypZAZWO{qqpB&kr0kWO>t+eZR+0U&q{V#dn`fMxypOoX-ynx|f$aK!(Sg@$P%u(gcuXH*boWnLX+fi6lS+t;}%2`x7HG6Dnd0Ela{CTBCjCXU6qo5|=F~6iNzqI6zA}(j?q<Oa$6*wJPMNX^JS;;wOP0V!;T@0l1N?Wcoxgx)$(pFNEnVWCRO>$&rW(>+)3_^vaIg9_ZY!b)@){yJ0EGb*SIdYadCW2RhRu?!yDx(Bsa*LccXVD^!Oh!?DX=!-@2xQh2IM6`JylQ7rW@Tl0B@!zu9l$86aF&#pW#>B!ii@gb^4QX%d=!~lTv?P~nCr}U7NHM7v6VqoDk_WMQzhFn<SJ~7D#|OJTKnLX>`>0q?DE3u(jv#iq9v?VJ`&i#Cin+s9)x0^8nl}*ScGh4B~Hg!)mBE)d<T+1W!A)D(5Q0g=9Cij8oDjDs-VEJpfbOrco>#S3ac^~XHJ}uS31>ElIbWYwdD?m*e}i<<R}3HWlI)ui;5O4DqjqJKP%TcDAD0?7FU)pag-L7EpQe)im;_Q6AIA3|5jbpOwusL%)I<U2kjzYU~U#HbQBaXbj;5$Ddik_WlKuR3LR65s;U=Z?k%XPaa0slR+VG=IhQ&XCu*x5=3G+lsLFRHCBa8Y)%+67*uco$B+v45Gp9^|Rx`n*!HzLZ7JREJvav`56-Nv86uP{X{unz5EhRZ_&P=))Q}yS+ie7S2;ew(}>hKV77@~*6lRD!lDXS`~blS#KPUhl?sSu{JY8a+98050@%0>C5juNn#kJaUXSne<!Tose1{y*W$prS<;rTGO#5UhfQsu!yD8~P?OzpxOpEWf&{D6?c<$vk=3OsOt&mMl`o<)mCkRapfL8s~h#aBxh6Zig`{kE!YTm1UVVI6A8<*m#2Sn5E95D#y6Wa(M!<mKEl*Nh+_b1iiQ^j}2IdwXl$l9^Z_U>o?>0tkCga=Ch??WfURsnGo}<in)qvXO%KTF;BIV6;4yyIVP_RCZU3bMTI!oIJDCrYUSV@3lSNYUs|P1eh%4S7BlFWP*%RAjMl7bPb{Zmj;WQ^zA4kcnKuoS9PUX41=W?6MTPRr4L&<6mex2Hv8k)1%CRWFq>Ro$ax}pec`hpP&CXeVvoq`WiTR8CCgX9KuTHMYSy)oWEhuspU{y2^a9WU;pLwt{l{pG<x|S(08RKjs8_h0SR9?B1nPvPUm_?X8lbE`+!dETe)ACEJ{Rp;6epp#yQH_=`X>n2I{L=CzTAH=8#96$k$XQaLP_^-t8<w+lEK*n+fS-<RWqm?qin>~jtAxPFVpA(&e2u}GQH14MZV{wP4V~hr+F%H$l$2M|>1r5GoYj>@V}{@akd#RUU{XuOdDaQ7E-6$<NtO9!3yRnTuFwV*mea2ECze+`9p&>KR9+z_m&+mWmmN|Kp}GluXi3>(n6qK7uUr6gd6`pYq@Z5~`Be&@s;&nLp-5Stxzdt(kQW90`XyAACk#b&0nAEOh$SIb;iSU|@kGQ6m|WJ_v5vt&89QT!b&SoClrT6URfBL@cH0<0K_*#SP8gKLP{$yJ0i{6+L)0=Vu<LxvHA3ZudqV?f^uyW95C8+qT3KerK=}rGEz#VH7ORV0*)_tSL6r!SwUrn74}VPJxY>6O$?3IJKs#5=iUmElPv+;qd+G6i2zaHF1Tor&|5#|iE81Z)?(B2F89nGI<F{XaSceho8Kl_bxpQXUe!X2uNhr27S(dNvR1$>k8l~9lh`5d$FY7DUb=B+5@_u-30G*q_Kyd&)T$XR%;7?a@df?E|x61o}a{#?UzMdT)K;I<GCkD`W%JMk@^m<u-Mqs_Nd`$p-tt`JXfL<%hZw;WYl;w8>)~opcfIt21+Zjv`pwE@<hynDKGQKu|J~)NJO#$?0<@4Iy^$aSRth|af^dJqrLPHPM&}%gGwi^0M4ZWj=zE(r;q@mYq=+PSbCJjACL*J^Q_tMaJXy|=3^qm@dKMj4ihCWb3Z_v<3Yv_kH^f4OxF%3OaLqDaV&(+YIHS|dux<^BwqM@JH(5GtXmo@Y}4SlEF?>NV3=gZw1dXk3TprKFD&<|_qQ5yO&4Sk}9eo8~vUiWU+&<APg9u0l6hJIc{AFH8X*3i>5bnZbPJy%0EYv|)O^r(6UO`PwZ6ux3Kbe)DCuc2$#f<z5nd;cs&LpN#Y=^DCreGxTuK|{~c&_guz85(-1hCWwA57W?#HFS%HUZJ6DuOroH=-TU7D>ZcO^|7@YdOHohUPEuMp>NXABQ^A`8hQr}eTRnLSwr8cp?A^HcWdZfHS`7zy_<%9SVQlwp&!%GduZsVH1s$Py;(!=siAu`^xhi!c?~^YL%*z{_tnt34L*8*4cV-r575xVHS`1xJxW7Q)X-xz^uZc>yoR2vp(kqSLp1ah4SlGFp01$})6hi?Jw-#$(a=*h^cfoZa1DK~hCV_=FV@gUYUmXj`X~*(Mng~6&{t~cRt<fvhMu9J*K6qGH1tgxdX|R1RYMmw^c@<yO+(+Qq1!d|-5PqfhTfo|=V<7MHS}p3`Y{cCI`{YM@7Le2zh8g9{(k-a`up|w>+jd!ufJb^zy5D|{ch>{r&xQ|EV>NeIN%6b*WlE7kBPMh%=;<dJLEKwfAjYI7J#K2m8V|?`mN;~uh&~oaYFIqDz2k=ql)tse?`Uh6n|314HVy?;zo+!t>Pw%->%|jis!3%5XC2}creASDlSkwNyS4b-d)8*Dc(lK!zfNv+(PkRuPb;sYrl%OVeMD(2-bcTZ_C=R;_X=bRlGfGzluk)_N#aY)_xU_V(nM)j;#GE-ifte#XGb1t9TdIeie^q?N{-xto<t9jkW)pg2%A-t9W<Teie^p?N{+0to<q;$J(#rJz4uzyccV~iuY#iSMhk(eiiS-+OOh$S^HJIA8Wsg_h;=_@d2#;DxSdFui^t)`>!f^B5S{jC$aXc_#oDP6(7vnuj0w9{VG0$wO_@Dvi7U^FxGwrhtc@<Y#falZ2SVAeTzSy8Gxq+;6noN0Rec=06aPXZy$h%2H=JO{91s&7Xt8~1Mu$y@Gk@Kj|1@c1Mq_ZcwoGC1>i3Q;M)W6Edlt(0Nfpb*9G9q0`Tepd{F>i6oAhO!1Dt8KLF1Rz|#WoAp!V+0K8`a9vy(U55PkMa6<roZB{`42jD*k;NJ(}Uk2bG2jK4q;0FWnw*&B90r*P+`1SyNO8~x6!L8DH_&aX(9<E8Z6&w>APwP|d9n5!SBsC;mw7!WeVMgkqWxX<_hCb&vTQ6N9=S82`a)VWBIP=xANOuJ}b26zx!&;{EHtZK&S+FwGdnjyWZf+R?vw(G)O*(4Lvq=|3=@aYJyxa_Fzh@pWP-uua!tl&=P>>E*n=_NXTlp<<wh^VD?9xTMbk1`I^`!%%H=C>OBLZPOOmk<t!TP@xl&rP?_KL0)PaY7#mf7<n6u`*r45@jJ^%m<K>#h4S1lDO-{WYk2vL^`E3DH#(?rA^|T<tf^gvx9G^j3$7l3_I>-Ues%nI2;5F=tn(=XP|?J!BQkYFO1<tcI3r&`7(h=YE(uvg^Kc2HCv&xE2pbWv8S74}4wzm)C2P4q-F@ElN$EQJ`z{hS8?lrAwaWGzLFA|A7s=TNSpfUI%upy9u=x8kB<3IRpkpcY6~co)@lTb88l=BA16@g%_E~AAoq)G7(V~`CcpX9f}k&k)D~*k?zn_TK-4K&t!aqO*(rf0z1G`$HN{2eLV=i&a(T*Sahe|3ejs>3XMcOPn5p5PRG8#Zq2h!%@yxHi~kK%D7y4LaYYoR%)?N#%dip#pV(Bl6RN|V8WeZ?iVaE;V%QJjE~Z|#te#=SzA*eFk49S@%6cXSQw0*DB^B6q_e+;S)w&xuUr7yb@-zzVBcWmM;C>Ff=L2YkXFPm}?k!g_E2Kus!+5m+4XsLFd!7gWy>-Y=sY8p^VfWTur`VtH>9pG2+c_`x+^2S_C8@#gHnbl`t0G|Fox`-MA3cR&<t;*yACkPDkFQ{8Eo<)v5}-d^!O9KOXVG?AR^Nf-ixALVV8avtC*>w7+){=6FmgMwab#It1Z11n2zh0fhV%zv&p>82N>R)unB3r7S`=zFT&C<_XUgmhm90belZ^c?vR!GPD^dxvl&k&jnKb<0!FIs&5%_4`V}ii{3tNe8v+0m+7(Wf%lA3I;Zerc%mem&_z}9=SVywYg-EFQFX6I1r$`!Gk)8si0^_>}Mb7h6wT+^dOscr{$iMs+?cfuKzbi`8+b)4z!=>wrW(+=e*lgW8_+E(7?GC?Ycb>8Z5>z*LRotC!=-lDt&A~3dpuuGT4+J<=Ws-?(_et&FG1RsP?>z+?ld^N>CQ*kH7KUeWWiW9Y>sTAi`JcHr}6;CEKnrSn@pK#dct%ivHVa7nE?SpNW=ik^2mmzuvX7Ki7&@#v#Xs6jzIe<$23uYrvFD$$26m}CW;V1!D=*TiW2x6|fQ$TK_pU9L9Yo=4ZW(;f-1soHvrs5td?oq`TF!A$D{Jc+m8anYLY)f6y_ds#P7VHAc`d8rK<GGin&3>9IW!N&;kfv$0(e-qe-{(1e5vOz*`MlD}-owy!nV=zEG0ACWG-GSpnB>5TwP`c({+wlXUmeB9FzgC;>`AQBl@>$oGmCXz%j!)u*6A~Vww2ELjO9w73zSWMlwzRNYbZ_WGuZr-K39hH5b3#gkq$PyD{bs#OzT6=Oh`AoYru<nbVhm!L26c%W%WHAZTeYCpBCkL>JlAItMgFppv`53S|P~|cLL$e9FW{cCDUd@tURw>R@aT5xNfWg<!tF%T|>1A>YAH_13j#|KQ197z@szKp4ZSZ*N|n*NaQq}X#Vs(egT-l*|5TVo1J>C+5q$CnfCS(1G<6*X9!M#{V(A}RQ-b*3O5T?%?!J%0^%gj020Q^?ka{LiE{y^fs({x2(mL+^jfM7o?TE;cHKp1DEdX0wx=lNXJ?oVS8g-bReu5d{i{q^EsdGd57tXxfvdUbF&OHc;c7n`${Esc8PX@7so<A2b)RMZKiS~enS|dRx`1Ihi1|_X7EP_R3|V~`_#rkKlH~6QRrmJ9V%uXpF4kk!k<dHOPNEZ5MG{*t&R?J_IV96H{K}El^56mMr7uL++dGvEnhPg$j}63HrUlE_9;E$eqCo_s<aweG8hRT8_YU4{_DsBhu~YP&22UswU=hiq-D8LZ2WnF|XDrN~@8;43`4<IgcYz0<bHB4yp#w}Wo-u!5W1Hw;!2dP|$M+;+f;V|C{l>OV(XjuhV*353(xt_7huqxhXZk`Ny{1yV)rrUif2sYYN346=sT0yubQ5HlIuS)qgK%sjjZRX7=h*K!H+ED-Yp!A%q;&_;%%qDp*J#f=aHQ6gxHKd~8nQf>lFxLsE<74c4qK%|XTAVlO<NU5jaxwDjAt)K3v|YTjwc8jYA+ZtD%Ur9Ya7fNQt{<%>6d`9+muefRMeCnE)UBnhQ`P!{fY^u-GFR&(P&%aS);A-J02I{r+%l|jaF>rfL+Ru7bUB?$;u2d^KYipas_0oN8Bu4x+1#uFbGd9HH)?T(#2YjS+)SGQPSiX5i&kXbXmdFCD=R2zQXRI&#%8fFWbx{7c-=aMDQ&|_Ay<CqCA-<O#x6~7&XP${@q^ovWTgaus8~az!f;=d(QsKHdl~`E!Ef5z}Ve!2bEotfX#jFH#!U3$QPn?O01<h$~ikV(b0kNZA!mNi(cBGGfLXqrR}?E1GmUngPO}$H0j<&liQtE0P~+Gp(iW>hSig?=fAVN2TX(#3qnTfb_C0(*<6{>(>-SZC+YKv?&N07f@$Yj-b9K8?MLB63PM(?YtrX-ck;0_AqzhbCi~BPLIH~Rmc@UuO1J85-UDZzbQvtvpxr&>vmB+)5nJ%n;(iQfPbvBbpnLacxYE9dg1z8dtMn!20*sXgAY`UqTlRs?1r8YA&cR$9@M;d-WxMqI#`M$2ZcaMZ=hz6tb|5Zm%l6P2QVZR|c`nDJ$EdoBnl>!Sp<}REV<BUo-YzxDRvc(06t>w+f48bXhUpJu`th<p=z<ITeEQv}KJy~!gr`Q;*D?J|lc>IDl1AUpfv<qGEEpUB?ctzp^&Yg<9x%6@gLtVEKg}cQv}AaZnls!@%^ejRe=)*1ID9Y5{0~oy(s7tt1|zpF<Tq!OD@PC0h8cDPd#QsBo({i2Mzwdr{%pvv{d{EZ7hLLTbuC9O(JcA|*q&3+y)6eWv2ASKZGW;UbKW_i&XJKkM1ICKVNaMkA9*Mqq2i|~Zc(-jEr%~DW2MQ{4(j%-IL{`>zMecNF@Io&b#dODa0nc<d5DcI4Ie{&o(dFNcpi;rVI_E(v!%*sRIL3;2M5Ps%RMUzJz_o44@a_ogGdgK@-}<6{(OUdgKWPV?4Nnuv;0PhZ$&1Ni!ELXbAV^&jY898p#&6~ibBaZ3MI)xK`1m3g)BD;jg*DHgIKf#qtH)hZxFha#f0{v(D%6V9lTLUCtG?1g>csJY`szFf^4Z8g&swrJ8u*^CJW`D&|(ytcB9ZgWubm3gqM;%NoVOw_DB|8^S1P1d;vTD85F|n$=GvehSSev`k6pK<LPHC{p><NBk5;2{S2m`dU@LQ%%s_^U=t8CDOeg-^e3kBCb6+uFOtg{sTF2R-SA7ebjHwY1nVJLa1YcyL;41eiC@H1e?O0B=gzcGq2Or`Z8;MH*a5^IKI_{GyiPZ@hW>V(a~qP5Bwe(-LL&j2lH^S~VV#@{NAA2Fe0g%t;8J=Z2X|mL=>Xe=31|!UY-ZdLTt9=GwC^mdU#0t#v_linwTqV3XXskutsb!#zdi5y;f#F7{1EAM7E71U850n+ubY7LBQBh*jW6JQ=}Ie`AaCfdduo5iRo;`CdTx2Ft>B<0I@J-lg_dG)C%M?O5UM&;o-rbADCk!Aveq`G+X^m;jX&r;%`GeoV2zsyRd=Mu)50du<&&q5>_fZKack=P%i37NGfd~bM=WjhCRn<|&-`R-{9f<fXD8>R_8*T&-6h~}Z}b=Dv){+7d%2_|xRbhH4Z2g1W|ZP2a;^nq7ZQiT`_a?*69x}<iPg9*g>$ERn6XJFOP%8aPN!baBOul?1x4r;6p@n8d1{e7g6<bH4;PAq*)<VZX8U5S-9@J|q~_V|>WbAdXTPP}YPxjOM8o@E?zG8t(rN$hIGR5n;>^-yI4pm85{d_X#eH(ov*;%}?c%RK0C}Mz;cmYgtTY+sse~c9%-#%{(qx$CGncCraSiDNCg&$8{(<olk)HeKAxORKY!BJmD}!xKg1pU^ZYxo4zYIY>mC6qpgrLuLQ92JR&S<gmGB1)t;_>Uwc3|MzSZ2WNZJtlBV=DR>kCkZ#+)GvW%Y&`_l(951zjuZ}KEIp^ZC?5#%m9TjwH-2i33CI%VEXB|EWxdo4;NjdamN$VGO0zS@4p#;;LZ7X(aV}=FZjhe6*fFC(JiTTHcynU<wDoRi>~S6qH6{0CFexBbZ(JI!J?~!=*s5CNP5^dwqYRGERM(xXV-!<q`t5N)r%4kUDYvGcSansL&j|qU6FS8$U3ZIjH}D@Bf6}zxKjx`a*74}#e#OLtS)_h?PV_>RI`EJ#!h}q)mbL$B%SCo*6t@`QoE$A_&{`#v92yV0NG(#{V?m>_}O!m1XS}+l%~d+rBA%C#ccxYe+)$Tp17@;h#%2C2Rbx0PK3JBMOV^z_sF3xQ>y+U%S8P{*iOkLx|W%tq4ZuU?RUE?4|d#h;_a?%ICjrTw7JH>=G>!K{VOnMxOkhysG@6FhNNGY?c%MjB&(FXHY4?$>Mv>!5v!DRLjzepf=_f?q~LGLTk&pomtgPnt|%R|NhcvYbz<sa%W4lNU#|EF3bx%>nd}PDoea5u-m(Te-!3)TC3{@BUCM|vdpiG!D*=@3E}+4w!A2U!NpYzY-BVNbFrBQ3&aOLBoh3>FZ9DY1T^bwSVxTUigR!Hc^Z}gh?a&cXXfhm)n?3)ecI{{vX%N;ZFm6X#MNp)Icl>~YNJBvpRnBafug0(LVs$KCSX$=e{bcKIydc_=;-&M(tXSx}lJB9MdQ`NGJ8F09>HojAL@E74$H!Yr%#=&O%Jtt<n3~et>GXuL3lAEFqN|I1HF(b9q|aSl-D3%)b?Pz8JwHa`WK);pWtW}ch(q%{=?D;Kc-0HUbG^O`#KUl2eiQw3ZA9zi-61hBE$7gy)^3zk4?ue8zv^E_iORt#ik*7gXxQh!-Bk>soQvl{d!J@HC!uH2%(G(Ev*bG2nF^m@H9o&At9ONB9$fN7`+T#(>?Tngc4-$1!xkKCx4Y&+AKn(u<~g6gw$wv`{(@o!)jut|cCkh_Wv8BX_VmriF4&>&GuJjiP;2#Th%NQw>a)-Ts9pE@@&tD-*xEu(y2rsb{;r42tX@~nRT9p^)KvW&90yr^-WB@*at!m|viekrc6{J?xaa3~*pnwcL%vhnL-%bgyo!_W(wIVQ(OT-Smesw2Ag_M?PHn(AyUSfnL$Zanv)MPk!(A16Jiv<XkcY*BHW}_QBtwD$oxH)8da(Ly#Z`J_UH7f8Z`Dq1syi%S$!x0ox9>)SatT!|K<t!{p<X7%uD`V%rK#6K-CdNfzwFcCv|T?XoTK*<V$m0OyC@~z61%P{ZA59YV6Z6t3hR<KKled@?^eUBbiqcfNK8Fsx#!!qw6<`s>dP+Kfhb=Z#;Cr)w(ctn^W~w_fxd*(j@cNa@rBNRP3WEXzw`$yqyF?|{v_V$Pm0f<bge(-vOmTf{7Gc~q~GYze~eFx;!jZot{3zox_r@_4PqTm&8vn7p^JGdfrX7v`W#fvI4q8=h;Nyrlkb<p0?96gKsKX&7e!J#TGrt&K-mk<OmvT=EBttOyOi4D-s+<+_hEXubUUVy`*tGjLLArljo9I1q>$(BBetVAmenr@;T_p7ac~%i(>l|*lR#B;oD^J=*ri1GNE*m-uDIu5?5?DjSK?k-J{9(>I7(~<e~1OiZzy8YuKQ>p=ru}_G{H=Z7jRv}YOh0;F6!&Z;i<zc6NgE|zy#W})*c{WGj+v_V_YGy3kZ4MQWwnTq*JstZrUO4$yen#*rfMpe8hr5R@Vp{ObN9=>7|i7U2o%%vPvUgN&Tw&bS)iV#4gFhm<}uY#Ugcn+Qp)^3pp9?aWIzY@T8uh+fwpd_7S^SxJCz|0=CXpdq{7U7GH%K@D!U_P&UJr{0ig45-%29R3ZYgn2YQY$*)-4KhX=va^NnC1tTGF$#2uZy}gz#Of@ucFg?Frfq@%Ui<NJq+p1kGsGp>cvP>Lhg=(ZxV2oN%O-^0$jNP@727A<)5hLp@s}~tD+R4MIxHPK8eO+EB!BPr~F9y~{<0MMI+hBR`^BxQdvC*reQ)6d6{T`dEjab{LzjT5eldM-|@zkT$9x#BbsYJvktC<Zk`I2Unm0lawjF8kO%RO`C5%=I%%FL{B!|q~BGx-ZnQq+}qZIUC(Cc$Ra-K7J-aJuW+#nUT8p3z@pA~?cvW$W=3z4T4z5jyuqFv59tGA4|0OeLKEk`jtlm9H5gM<pEnGT?k<scQ+Nmusn?a7yw!BH_CA_F<YxS!yCd|LnqUlt#WPvNRKweA<io#5x`FNm_nYRMUxe{7A^AwJe(?dNPEZvdgm?<a8p=1S4OutospDs$dtpj>g*KmsWO`Rx{MJ%JHSuzv!lurkveHO)A+XjjE*wO2SU1V^T+UT(KGQtHPIGbqnbw;I~h)nXjG>GAfO>yf`A{=AF~em-CKpAnXMeoAf7=T@hoXc57W5F{8#x?Od6uA5?#)j9XSS=+x6X?b1d%fG=EC_s2Jnch1e@?J%N({bupbQQ~b^;$5%AyPX{GjWIwO0r7U9^bKJMI}_B-e<F)_Jk62h6bN{VFW{ZnIG#a+L~UvVUe5wv&jQ|N#U==3juP-qmb%H;wE-_?0k8K9xLpqT|0>?>CL}fNi}x4T)Of@0$Wr&!MId&%1n2Jh|2+Qdyq3C4_#FpnW|T5;q#5Daxc*Lnj%*nPAHMy+n~hj$*-9v~UBR-oP&~}2^-w&<ikqOw_H)a&LP*%^yKDzg+2XxyCluMdwruy!^CVu$lZ`A-HnKb^H)EdAUW8MxbO+=K6L4)r4Oj98*GA;l?t|5}n0EgO=>3iITpxwwGI@h#-4iC-)htgoGQoBaxsvO_UO4LGg7`em2f8*xD^h4aob;`ZXsoubn5G4-3#a+#p|?|5;-W(~@*ymOBS!AD)NS({kSQ!bidnA7`9a&|UUJnxKa4i%SF!dNmLDtC{8*I<`)^Htu#9ud(Lno9b4&kgv<s;{rEb4jfNcpN{r(&IcvP(qgxO628hzKOmZU4bdbZGwfxAB&oqfKg8@gyC`)19MQ*;Z&wq8`*CLOZ(IW5+mu&htf(XUKd>TnCC9A(Jw+2jH&=PbFHap@(@2bZ~J>P4kqZ}o0yBJR_qPrTJTz12Is)my#Qo4nQa-s-j9>Xn{5exY@;{;Z?DL@zJw3a4=o(YZ*f{#DCF{i`r&*xpaxaJ7V9SI1eBw`Jb%aQ@9qy4ZquIhFANI~D4odYZ`Y^9LMH*sk)JWp$WY-u92hw!P!KAP@qX$?l!O3c4mvPrC|nPtZxa!P-fK)L<ixW2G)J6WsO~JqBt0t29~{Ep?yZhEuAOx3g?$Dv5BOr3Hqo<*f_a@vQDxTJmASsF%Mr;`86u=a78i(vDZ&<Ywe5U&FYM+@u-xN;Af@W+3hv^9gMR`*J`dG{aSgNjK4*k)$6Z>65Sx>(}AVLB1Plse6U)Bix!6$y-GK7Af5mc@arJ;BMpKC-j>yo|irb`kU8${iC$ccPyptV_uyH-)TZ9mv2Iiax=^D2K$@7X0}7W=!5~$So0cdCgPsiAJb+QtId>$p{veL$3sRNy`*mgdA_0$8d}d9x|;hRHT3Ld-}NW<y*PRi<~^KSnrK@nzKYF2tZg5FMK;|~-#kzG{Itu%Kx&lx3Pj_XD5Eot{Ew(8<+vD!>C^vAP_K{4TNSzufwWR~BH#Q0g128%#woq%b=odn1nVrhXo7n}K30=mxf?Gv*zxu`{o;vTk*2No9R1L%d?m#$-=K6+PRs9C+4Zm+@>x{#ne}(E+TW1Y&+~GB8?dm~Kds+Z)A|*iFRd4T7?9S=>Rh+hzrQW(ClPIOmy`cdpRc`u4N`U{I9^xLJEBJ{b)9*<*K;H@siEbYzm)TX@7zx>h^fbXzr%l`_r`O#?=;?W?L1AO9ZCZI1|HTh*J#@vzP3Z$Yt$T)yQqSRGCI?UK0!q*SclcH_93UG-Bs2;=`);C|G1)_gJ>{XUbrkbwylmfHt9&qp1=IPt1H&HcHo58wc<e6X81;e;@Ya?RFv)e7)N$(8tbCKd1Id_$%c=~`vrC0c$&z0gh&4y=8Y(2-iW7L3%Z5y^q|!<o{~r5G>^o9dE+j~p<<RpkF`E;(5z9W{BJMH(ffiZ(Zg><V^-GbRnnBd==>3-%pdp<N!s}&i0)n3h@k-wXHlg7=lcAID2A&6XPr{VF;PZm8f}hIQH}*XoOz9$mOiZFVx{7(f6Bf}oZ{<ODDF;c5%BvKM=_qqMa#J3qFXQT@~GP_E3Vv(MQ4aDm#Kwk(ZcI!L30q^Ct9+OX%y%z*Xd8HuoxBU{(}N-2L3~m=Y{vFmK(JuftKeHMwozvQAcUH2bKr1atAE;V&&dg?!?NSu^h(A7A)(~So8;!a2>yg_UrqthGEiQ>bHW<1Sy5SerN02qh9~BbtMv{uRU);6=%LzlsYMe!62Nd3THBH-|0S?5qzin9*p2S-A6Ej;z6y49F@P(pj5F}DLm-AUQO?xP0h;{rN2aXRiapXHc|71@r=0mqy`bz{f$4u$l>XIl)8rHl^HM^l1?NYvA&77rq7Ji+>dmPHQS{3Y>j7(6Wv`-*`>oaS3mK?W}9?CymZVKbXM%{NxfvV*bmh1)7d0mbX$on^<8H-%<h7HR@cat?lDB%WOXI4OubaS6Td+j1oIgCqHQ+bl7yws(-Zp!yopz@R8)t+wlfiL;?A+&vfnfHeYRdH|BPUrYLl))GgGfSD@9kCS#)(3U88NTsd3>p>1SJ?FU3B8+NBn;@lRfCyuyppVd(lLGf}`i(H$~Sls=(1OMj(Yy!8Gm_2=j1UD<UI!Ii5QYn#ks?S8W~>9REast8?B{bM%X1e&e+>ONbqVN!+(#2Kso>RF@Zo;NtQpD+41-r^n^hr4*`H!<~$v#WfcV6ba~9_zr{3{vG~Y5Y|&^~-7x%YiUZo8%5j$d;1hu;Or9`<a#6`^EafaB^54EAKBdT)eAFbv#4Lx-2aL&s#|K_hPEYvO3Mn;^<0riR?Cjrrv|q9$G<57cb5~@5=vwMw5x%v+e7-^F5q<#?mu#(^z&yZsHjxAE3v^Ae_D5zrWc1Tj_VP$;8C6<gX5n4To|JD-UhTVn+I$Z_0{d4JwGDH;x*cjW%+?Quhch*(dN0o0J)aUq6-d!d(mDXg)g}zpB^gyqNks{sYVh^cvg&&u8z^saE=Fyj$O$B{;13btkGr&y1O0U)xB;+MfvC`TD@_;=~Vs6s7BUw7c|4cF;b1_d{ac2%9DIH&IHgy)wG`80)GAGnfFi>Lbb>Q04w-w!1WLbhh-1t??J5t?>sQH`~SU(z{h~8o@7{OPO4@#dcO~^p2)C7^`E%#&g4)GFiJ_gKdr1jN{$yJT|v}WNq_kvCn0T6oHdKZ9_WLX>KvdQveP@NUd4d*;angdw4yAP6^5)Y*FqV=HZQV2vND&?iwcI&A9XIW*n@=F?65xI}9g#pNn)+J`axA_Fh&O<&pS31k0L6n#*2#2U~=M^wb~0L7N<h_n^)ArEJn9y3=7OM%bjOLpVG1!(bSLknr03X|75==A2mDXqK#(rQ0FzK7@RiPJvT4cZR`?qoWt>b09kN>p|KzT$NwS<bMMBKA(x?7=C3sobG=0ah`7uqdR&SDE(oa!OWH|-4z!Ovq+TYHZ^`Jrz`!Rmdqq?X420s6X}59tb3706JJdI0M>{PY|;m|#vl2XAbR0G?FsxI&&y5P?`kOdEy9R)EisEDmV`Syh<L~F5Cmx4Wl>sUR`Q~y;5x0x_x*+pcmE*kRJ(gYN}jv_(A*67GLj+f$A0pgu+2#gR?F)R8N{>tgmb11k8eLh12d#+a5w<I-h)d*?eB#C@6nG^X`J5j`g<9qMGA@Y-0Ef1s@XTKCIkdT_Kz9PkVeKSW@AD3%(I@)o9Jd&{oaiFpW=VN{=fLrJS`!npcsEbI;Iei0%uWS%zzkYaY<DS`yKI^g8Z_W^0LyUG4qOIO3U*LL7=3}Sq`+Km=cYZ3Vc_V7Zg=hCBXd0lzWfu9aEfN6_a0zzX6RlippY2=&z9%6(+<?DH>2xR^lwlFD=1`1C#@=DyFR58B<kVA<M}A7L+flC@C$%U!#v%%zkt}re{@5`FzFA-aQkN5)-R>#}t+qF&m5Um&Ic$*-zMOl(@2d`q%>6m`aC(V+EkhhZ+DcuPj+mQieZqo?oyqe*uyz@+;}DV*|-q40u)bJo#tVtBUd~3yK}|0R&*bitAaJ(6f+(YUWj!lsZd*Qn1unTwdmoJpm&M2MnPv;Co(grR9Z1^GnK#3b~m@XeyYSSk8@2s90J9p9K{a9EK}qESQgp?^!jxXJH>MuWTXyvV4s17rEJk1BMU3;c)~Q$NVy^r2rVtqL?aY;qc*1Jf<|iashOq6OsW!SL3KExuYn)k7}&42rMjC9$&`^A9=kC;q8X^tMEPv@2l|c{;}6P4&DplT@UYFAG0%ZK`FEf+;BMYXVdYi1RVR}a{1+OIE$+A0Vpbtk<sGx7tkqAI`boTa_o0P3*Yv7{|)eu2Cw%Ifci$SHw0F))d#%ZIDn@CrU1MGa4x_l2fg0M0DgYR>pctb48XZCrDvS-dhr=cPk)NnP&w`ZK>U`?cL4DRUcdXo>wOwv+y$?<8K53citS*#<GkecP6hZHzzTqIaFBWp;Dc}o!moTD0N76N`>j)Q#}tm#gp<x8CUZSuzX^&z%TT`u;)UC%u<&tVQR6Mb67x!Kbf@8c2glK$$3=boy~xXZy<Y9_uOc0vNq8RUD>XmhOMjCa-ZS=ly|-#;YvH{OXdN^(JRRpi`<35c#(%KD_-+8X<wzJ47QRlG85ZT{#ju$B^wzNWH3n-~Vy#g(FDyPIEM`nt6o`z$YqqF+7TzC%F8)s+Hx6~jpl+sCmmg08RjDs{)c@|J&ljYP1lo@WeC=L|{sQd_kfYDtfjZV>9qafpVKHufW?1}v276fI8e>LSO06j)Y_9J4;II^^6>1-&snaG*3@gqGtH=tg$qHLZvclHFyB^+~;Jua10>$c^DvE;g8?xk%96Rk%)1$k(a$IMnUoj5Yw<(`_z4%Ney%&g+!ot_+#)cYm*7NK1Zo_@XS`$CR91JSs1fCcZ(si%ke1|_XkqGS?`J2~EpA!V_yH95gi(125!(wXn6T)(IdxFDaGQy&))E%opf2*_*bUdI_?jQFt821ccpVb8WM?MRGCI$D{nBP%<c)j#@Pcy^9YjulhzocV+VLt#5pQEJTNN%uC`!$2wKLPfwe!&7={9>sd^0OGm4}IoRj(?wx!9KHMpIKR-<>;>5H1yC``WyFP>pmER%5T`B{X(Ga0NO6@#+(?3_A}L-z!1)BrEBT$);5EWwfnr@$!);zH&{Gq-(_ImO_DpW#FCJcm%#CF5a>fX7Cqp@(;s@h4^gMW!gUf2A?NjyTUQYS$33ny)DGm<=na1+aGQ;W#(~^+li}$^ZkO4xdm#6$<>{_3C35EnAp7coU?{s2P+@aI8z{e$fI@F4fSn@=sQXz0>b^42Kx+_cb%v8Vu0_XwdD{EvM}({)&RroNhjQz~fVeB{F9PKaZ46&VaHk>$NFB)!ZGX`NX=6vrR~<X-?P%B(%^m4z0Ll}c439^1jhzfnM{_@PGCUv6xjGwmMsqtm8(xp*KJIMT6V3hE*|0B~d!mcsa5Q(Ii{WTA?3@iBMRQWL;dC^&F4}NDn%mp;M;^=(E@YXoEO=SaGV?OiGUGDCGW{}snGPQZ>+B5u3Ge>!PKS3gyu;z00q+=ihsg8{?GHNt{rda$_v`Q1|79=bIVZ})5tQecD9;YqXZFXB2jE`^;OAsq{Y`)QN7$9$@=qyaP}wgj&s|ZbN@dTaJVQfy&Wf^sQJyVu;kvgR;d%LC2FkMw*2)zr&n!4B?=h8UdrXrb{-HdJKza6qx)qgwpI&)JLb_~N*$*qvJW%$d@zMVDxl#Up9+n?MqC9g%sqea%`M*;(<dt#7kMlDAmHZHaD>ANq7RmpgUdnUq17C@9ex=JWM}~7{SRuoeGOU;3RvGS;VS@~h$*@_5=aq*D$PX0>mtl+y6J?k#!yFmTm0^VpSIV$nhFfL0Q-%#PJSM|t8J<@jW+FdaBwU6uGE9_Vx(st<I9G-hGF&OcdKqq&;Z7Mg$ncm9n`L-jd8mo}(1dUq#>g;HhUqfQk>Ok!R>*Lr4C`gMRr?SI&i9-o`3kU?3wSBdOH!VXbi+6xYz9)ElcYQsDX0}W<@rck|AU<JTqNZ=NXAy=l;<JU{|9^j+t+_rTY1h>;7fVVlJZ=o|84!s^OuzQ@!8ayN&mn9${IU%cuaiWyy`M%bxdl);Dp2hNr}}I9n^;r=sBGE$!6np`N15@^@Yb}T$#%QpP9Q$<}a6VrR{}sFan>M8~DuNz-R3SKC?LR*}8$xE)INVap1Fo1D^>T_$=VSXB8`bHCcJ^jlAYR#NGV0<N=-h3@!6JWaJ(=SmxO{?qvvH{Y-z!h+UHj7kRt`{vc$Q+0+PFD3<q<4gVxuRC^9@Jk%0F#EW3`CPXbc{(*w%Ysp<+L~!jj*OH${Do8k&r8gZyYbe)1%vr=-0Z|LZEY8xIe!d2EKi8RX9eTFM`=D9GSPAS18*C>!^y+|85&i3d-MiCqs$odGm2eS%EC5n`mnV?D?;8;9)9wP4L%)NMMxr;AlsUOjq(o%GQMyClNUS~L)3H$Q-x0q@oMkqQ+zDP`IikKB&<AwJ_C^fc0_Eh0XRv(Ry->@Lwr|q%qfj2&7JsWFqF);*4{LV{%NNdpd`eraIN~Yj&JL;VbZGOD$xt5NHVn(JuL1cH?RsJPBP@#%wBE)^P`0spy_-OO6ZI`(<P<1x?o7+CLhL#;(sH=@BSIsz6a$Fmh%Z|}@+j4sW{wIYWA5R&VUVo*h(4+f-vvrb@*aadOGH}?z>>+(>rrikQGzp`*ajVIF=3QAW7NaIX=lJ6WzutFXgwfgL)UmNA_L4uwde8jWsioZ2^ZcmIQ&lF8^?VFgC`^u|FxYnel(hJ9YZasXojFZ4_FwVi;pYsb~o$?4ILpHxgL9~2zRP;lDQKkrt$n{*f<WBefWA6;W`fuIts?j#-A$z8Ag$C<A=LJEQKOb#^+!VbWWv6jPc{0fDETdym8SsKt@m`(HH@Bb{<KQ6yu+;E9;y_k#yr>6icUwXq?puh?OEa#zN?#&SNMt!#EKZxXu}o$>8T)WB--F8P{$&AjQUz!GMU=>k6aM4v38+PUGbo&>1h_H<N3Oz0U)Z9f3)@(%3f|#3ouW$5$DvU^ebN$(#<>YK<=~17xx#2avVKccDW&&!hpZH-^UoXLg6#z}aM+i>7bsI3JL$#v&LPo##+@b{L~e0J${?huco$!DK)j!T7_pyNwqdfXt=7H5eaW2gp2gDPAMyBKAW!bTQE`*-vs_hKl-yRXlkBvuvOqKaoQd0UfikCnbfOdjV1r3Vwx~r(tnU4N~*<vg}=oY+Imy4unvo93c1^@fxIZbavZ)n7Ft7%5l-t+F=rfZU$!9vYEh?!d|C!V{U}S2Lt6^N(sAi7nEJBd>De)wNnT-YRoDioQ3yl!iAlh!*N|ZcWOqNCY0$)Wx`G(y&I*6oAI|FL&FVN;Y%FXZ9o|IbyyzE%iR)a`5>us7Q*CJ1GD9NQUosdY)7nh1V2ZEo*`z15ZR1yr7)htHNqtdB_Z+~g!c(a6uN~h3fBp@Qn+5Irf`Gs1ceU@dnkNJ_>jWQ!Z`{b5roqS9~IIl+#=jc;Z|WKg-;0&Qn+2%M&UEUE()I&KA~`jaFN32gvf6Zz90;s@I@h)!t;@J)ZYt{C-xw`7+FT?mm}|`@Ji%26#g0cB!z!PHd1&s@+!dT`SYr{?hE)WBRKBF*BpocCq=LzbMp90z{!I7@E+t~LFP>2CE)xBqE8~{N1x6F{sG{83WR?l=Tjdii(dhpW*~fwoMs;<jTc~%Sq?2Zha4=(oD}|N(7`D&2+ni_3*7X=lEqxiEBvQ$s>NQ5S2&EF6x&BHeD(tt`s#(FP#Bo?EXT#p=G`#V(bK6W#bw5s&Tj$^dRk^uTpsxFc*4b&@&A~|bk_QGDCai*t$9pmn@^_#me<(3`O(iYojpDs%2~#be~#&V;?wya27K&;e2<ANoEH=wS&_2q`L8Fjn6@*^igI8J%B#58J$&Uqn0A6$?F`D<&ENG8rYI_k+^njSGA{Nd!bg71lnPWO#(IwMF<&#S<vuNEKCpfuytzMX+-9E^Wt}E`M1R)0*Ho>6`~Cs#{(!%88>{N5s>C?&@oToRnmnpbaNl@nas%OCt6@rfkfOv`dkDX`hG}&TQnjK>fpvxOqkm>vsXi^rx<L5xKQpbVs@C+PnhJ28-$7WT%2XxB`HFv)ur{sr)zl4kaIuMmpAye%+My_sK`ko3KjGhdlvQ_FQI+{=D}X<i@UBv(?@{&X(#iOv3E!uj>6?QUeafFzTE2jboksXc!OZC%!D>%X))d0e3}#-B3Rb<Y{t~Q~5dLT})0(MjF;)@bKPzThPM_9a+o6~4B79OK^YuYRi+Ed9ehuM&8ZCFd>TBpv=uk!Z5-xTv;WsU0`X8zK%wfu34g6Bp)<0BzR{wW!YKZ-i@VMnc4g5}~>@{V5K=`h!nQC7_&AO9qf%P1Zw*gT$Lsep&?R;=2rgN)LXD;mYVlVKC@;I#V=}^wE{D_H6=YCZu_#_PHSTo^kw=<=eeBM!(p786p%SqtV>h>70Ium|u8@c}lznCz72gv`na{q_;$Ak+9eh(dA3OilQh#n!TDrI%m@v~&ss1RkMWvq@me!0w=8KN58f<tk*j_>ksj=SRw{wAerkg|sA_)wX(-e-`q2I=^IGV6Jt!6w+Q#pdbwW6g|p&}Wdca&-IwnbqtwNLiwe|3YT{<uh0v0(DjB_`e*4vLZu$$&0LoI{uu@N(xmCQdWVEH_c@%d#Gx#9(GKzYjiw5qXAh9d<H3Nm5yHeL)I#vLCRXL<GaeNEk1+Gy8vqoXmw_F?e-a@tj#+9w@!@pq0b;?ZPf8$veqv?gY#h56Z=mcpDEWB7UrKNl>ZMMKk}bUH6cv4Dx0SK7j*nd9n+r}=AT8Irb4ve*YWqKGJaWreab(g<MF4Ok-sj$KII?O@wbj({FejlZ?{7IKkE3cw=@3H0Q;2xt&U$?&iKCs*r)ujb^NI+x&0P@`>DO4e!}z5%JE6C_}i!aYdZcGIX)9D{`M*VijH5v%k2-a|K>|LN_l?7B&NSEz&_=7;Q25+<G&nWpYq%Ce9y^@e>A}U`Axtd!t)DG$n6iXPx(na|I0DC{o(%hDSrUZxA{nJf4IN>MjW2|^!#Bfn`La_s%gr4N6&v`WfM$cxT@6$7ub*Vd}Mp3wZf-GS;zEzY<s5lh)=5vF0eo7`IWUyYnM-pvQF#y`)ZliF`w45rQpV8J>TI7(>mkRqO3olt|Ls#*hbYl2IsNZU;}^8eQX`;)y6+=ly5ZfHEy;djcel<msv%X^I?iK@M|_O{d`4VW_2>~^&6P#UA|f$ECj2G27dlz=Ig_%7Gw1{@V8H9zP{?yS}`6PKgPg+x|Y@TzE6v?Mj80;*0Q=hKCMSz1lCjof8esb|A|nwC@aUnAG<8?e<D<^Hg5rIzJXu)EURl&gnwKpf1ZK=eFv-X)(HQ&%wLqx#ol4yXWYj0YyI@)2vMQM2EJooR{st^BTB5gKuzlm{Qd*X|HA>EQ2xCJ{(6(V_4D^6xZ(i_=r#lYmYI2CZtJg4`Hvg;0(p}Y-_~FM)grL}x`FSuiRp_0`jr2wf#0&3=@$p+e}QL$ccHKQ5xP>=wpCRr>yUx3lv$6rRkaFxfLC7{_}$xBt#A6YDC<)Le{dVC@FSmA(jhQ-&cKt$<@1kEi?Yrb_%N9j+)mXpKZ$dnk=Gq(te)*uEy}uP;KOBBx=(8Wps{U@d~Gc2m)Slo%CZ>w^|7o=7W=d^gTVP-Mt<*nrnSMRMOm>%{@wXZ>qVc|ml&uNBR~8Nrq$%rqO4?aK9)t}v`=dgHhH{}KMoTVp5?Cjv?yzwk^fR=MYUJ8g0RWA82Nom*-3G5dsU0FW*GSoWY$EV)|3bFd}rkE>cKoL@o7=kZASjS9;{ufeOeDc4+d8n`Oz=4UVgg0e{NC!T}HmwPS&^s?fr9WXatyk(8znQvRc0j(5L)*BcGYY^!1U7z8t)#!TvKwe#=m%9~bGbPx;%7d`${-JtNY;eu8_;w~YM$-Eyn_^yLEz6?)ys?~t=$ou3g|XfSrjQ6oP`-Y`EGsX9Sf?;81HdB=PpQmsE2JEYmj4_wdU_q9)pvc53#Bi6H~|LM~zd>9=1&Bz}d&9pjoP#mTwe#ZaB$Um0OREKv^d}aKlU@BH`;@8e%zRpth*@=ttITQchZ07JCsy^eto&o$w6W{45)8E)Z^_sFGOnmR7Om$}m)$3njg^G<g@v&*l>-T(Gloe;<6VjN&Kd4%U9_hkoaNscXa0^E%TrcR_A*>fVQn*1FO5y#&bP693swjL=SWn?b;ROmG5)M=Nu+T!`CV^{@aI+9b;UmHj3Lh0_Q}~!rL*W+TX$l_~8YtW<oTPA@aD~FBgietNpB9Ev_>3@z!smol6uv0zpzvkkeF}F9Efl^g1a(08PoXb`uL+qH?h@uw__}Z>g>MKCQMg-pg~B(5FDZOW_?^Ok3GJc~?h%qHd|Q}G;XA@g3ik?+QrIZGLE(PkLkbTFzf*WnXx9<pAz=uGO+p@phlNrKj|grG-xXe>@IB#u3jZzqOyT>2p%cQRLU$RaQ}}`4kl}I)j|p33xQD{y!sjyllfn~1$Ic9<0Zi&4kjQ*m2qBTnXd#qDK28grNf@>zsYh25hQUti(Vc|tpoKUR)<O&MB#f!|Az@6tF9}2S9`z?7xq@Z~-wKD`CkSFew}wqI5spj;3ct5Aj*-w5C?6teFbIR@bxHw%;%f-^4B_IELubR9JxT{<bKE2$8xZ49kW_J#L+KYZnh3Jua>Hjl1tS3T{)L7Qf?-1W34el%ad{!BS2*qiV12BxxdaD{pSWou8<IJ$1*qp#&e-+!pfe-1<0|$o5L0Jx65jlK$n8ffoNF5L0@M);<oM2tB4f=n?Eo#324qoTk>fsok*Rqd@aF)pSmob=-)mv~5>wL*pezI4T9tni^?N=N2QDu*Jqt_Qmq>jQ_%Hg`!DQ|*orldol{pCfWBzvf)wh9q?lygbetr+U^9rA*vrfN!<gYf(!!w})JPYrl=%Y#QFzE{$r?~p?p<l5R0O<<?iCvTs9U(8l9y4yU>G&%g_bsZ8Q+ZtI-4JL)oGrWnn{0?n?SzDP$z#1iCDZ)f954wSf>bVMX&N+1N20H`C0yF3N>INCm_4q44-&mnL(I_}x0Q5y7&hZ02HXvvM34bc9ytKL8v9{?D35A09nNzvfYt}_{umu;p}owb*4Qq6;S`G8pW*$x$_;W%t)NYNk~kcTX$k7yfOVgIfz`eGzpVQuBf+|};SAXu1Si0IGQ9b7+Pa^+#JDB!E?2oXshe=2p}>#mPzzQk4nRNXt=68`JK=4T(2c;{MvlWG(`$cF=r+Q4!{bSCXpbkSfO5D!xH%d}AY$S6egzfKC7)t_!Ch#Vyana=$U<1b!zT?vQNsP3^o6yU^qv{q!_y55j^K!{95?z8`aP!}lh-1xAh;LOt~1(8usW083xbCu4TU-GDKc^`jF3U0DW(U28JtZ*+JS4qdN^7JPbRuaaQ0XN$KkbIvDr2oR}_zhNj6F)h_Meux!~JGLe-Y167DQ)g!d|Hh)^{w5dRM@_+t;NE!@pffs2Y7UQza`A;vza+K7VJSax$G9?q0YrWDvUVVgNapMk=LW`v2t77CMu=O`Q`?4mGP81MtaAwnvJLxoHVhY6D@Ocmb$9^r7|Qwm22-%~hJ_?5y@!e%NrS{O%htFVQ_F~V~cjum!Mm?1P$I8K;D<+Fqm3PqusLYr_mg%gBpRL(90Q9N5{PvJzNJB2yIb_yp8ZiIb@2m>HH41I?RRnZ8C3F`nxG!KWg^LD}QO=w6A<l#5nAtxsc!2C4yn<wB+H$%SyVKaqA!jq`nZ@%yvg$smtDJ&Mgp|C`_OyO-pSXYD#g`O0a3KJ+?BrK%xcELqqrSJ-cPT>;@tA$GxE*7G@A*>OSDO@T{pm4b`lfqh|l)}}*Dhlg_Efn4(?4)q5aF{}u@C$`*;W~xug?2H7d!M-AP}Bd>PVM5l<NdtVh;8ZAu8!cR1!x=;flZ)zlsKjh;s#{3dz!#U0#H66GhsyKK`E`a6v8$h6$}Yegppv|kdP}RQaF`uyAo~@CQ`geD50=eSWRJx@Cd*jbyHzH@VAG=$KsFsErv<EI;eOB$GrnqO&M@Z@BSGGs2`m8=ldMW9DImyrxlriAtD~<sGT}Htgo@M%=BKkP%9tYG4e+mHPn<%m;i3aiTVLEKoqRnB-9bI7)%Tt4GU3dK~OlH`jNd5&7Oc<u^!+w>WHxqYGcG}iSm-d^*9elCldNo$opum8Cn?nOHkEPrnfIvW5krXoa1mFq%$WjVazKek*B)jSpI64Vm8HoA38Ze7cw3WS;4~~q@hW=Ajdnb!J$1gtyc}RFwnc#!QB9$M%pY^`{*7wbH(R@w({-7q{pvNn8umsf?CZF+X<J>^_T_P;U+QonK=9o#b3Z5-)1NNU$b#cDR?o#@&Yi-2`FaDHmtgz;~oX=7vRmm4q^ml3CeIxCdcsbX^z_q{DX=NH;;014O?;Z@fnc6SJfMlKNi<?(=@}fJK0skYsdzZd=us3w!$>au(^tGCxFly&|Yzh0XjD_kwQc68jgyL0@N1gUq_EOL8RC)G@aFv5A0H<4q2ogt&|#G-@;<H8qoFrBJ)qcX24WosDb_26G{cpCm7L)Dc@ozbi}~-sH(yRX>rJP5Q+%B1J>GQop9b#XK{6<T@W{d9qt#5Od#ATu(#l4*x!AHhI>3vNuYPu1y{lvH2MvUGV7xaavvSWe!o8g`_-I)!lnle?w3KfC&x{KH~*d5NAxRC2?m%~O`8nw-_3Caz%Nl`xP&)SfV0g|R>*P7fLiP0gsle7i-yD%gnJmM+f=(a2g`wd%V0RqqV^WB52DC96uICF>^p|<rZJH(f$a$pNxu(74jQ)KEiZS_V4;`4$kS-$h+&s}ZMz4s69PnXV0&tM-%z%bSs4fH$^Ih8$s=!p%yGkWvzg3%e?AwAUDhKa4~NAU!E@trlR?uPNv6|=(McTlIOsf$dVkRXQO<XUvI&IS4b;O5M-%vnw80?L9F3cavAtmCG<ghNpC(lHEWCe19V5;c5e^(IUqxd|jlGHk{H$RH?C4M;5;m$`dMlD+FFpp`^M<oFj%x#iWZ(?%t$4+_mkf7{%%ds5nWJ#o5r6EICqTq&m|npQR0I1?)xaRiH4;N`1+(xVu%7U@FenbjiYbg3dfm-T><0dRRptN&Zcz8FAk&^0UVV<qd;$C)17wWYw_S+gOf`!M2XPnT<(A4aIOt71h~eAEnM@q;2L{MwUj&)H#9$0&5fg!*>n{`WG#oihUq{oS8;Tv0vi~LQ?Lj1XO<$$Edm+t~N(_@=lfDitJcw30VB8sN1TmZ&!*S06`AvnT>2M}AiWr8CB-~LD_*4~&MI(b~5{w}RA(-t$e*-=~-HDG!cFf2B2K6B%7E^Q(O@nd7aPNIgrfVN)eIHf!Fjh5;#Nu{!5bgHy#Bg*D;RXYHJjmtrQG93Y$;6NeY&1~<Z>PeRJC%0)Okx-yF%xd!Kj1S#*>j2Et+mX=i|~FUzy!^UVq$oHGc$1v_@ApXn!G57J`drj%pbt_2FTF7SWFCGTxKnff)47@S8lmBFP0HQWi0b&B=EBWWN2QjCWhndSp??-f1$rj3>|pMEaWjXNrsZxRBUo6Ms}1(2U#+3ps>6joH%hj4;<PF*~GX94i*E4M{L6HtR)UD2V_VTo{NaFb2T6%+P>NsC+MQ*2sdz4n>B=R%|JMh^^ZmaSR$`dZS2c|!<gNERAEe;Zm$D70&0!wCu?v$lQQs&Jf_nnghNG=1gv4m&ZO)Q=Yi$~)B2698j=I7X)1eZ5lr&~Cz)bjliB6{@EIlwJIImACgD&QhI{xQxRyN-@=iZxEqiPTMvM-m-dl#?_@c8`@5hJWm@_r?VJQu}vZaJBgID_9Z0R#8OP>jsJ{*rGT>5b4<3>FI<0D)s5f&%F5f-cF$UUS(E=&uzx1q*${f0mv2(_jOOQ4b@IB*YxH$NF$@C>0m$&@%A^s<3IL*WrDaf!xnfWMf|$AlSLZ(52MB<}!rohm#Xtrg<-LU^EKTR6<kK`MCy1fKU7>iKRF;e@A5=d)R5WIucyL74(%Ct`qvrGs`rOGr-~(84RGBs~)$=iuXlPZk3!)FeJeW&6W05#BbX?PemRGaU814^U)#;(!+ZZR+>A?Avf)r4LX7!PuuvS7AGjoj_&+t59LH!P*lCwD7&@keM(O%Ya|&GeOzEn(hKNHSrj*o((X8<5akA3M-bYX#oCvijxFOTq359uw+<0^36Cw2xemH6eU;s8^~N!tx^p$j%=YFF+G02Y_<a=Lu`VdSu;)}LRVs%lqp*p2?ALO{+4k33w?=cg;|bxJ_wZhTk_>?C|1^EZ#2vM*As4@_ceWed5?1m)yJ8F>oKo@ZU25v_|JKdL!IV59de`gRkFM<gMG#XtXh-z)VP}WRil8{XCTZ2@a9YW@;+05R%HS`N8u4Hsd-PYY$$o(aV#K}z+R>bmuvI>+l4SY(7b;b1h)ALDS7|p6Ra}wFZgIgnLD+4zcoRV_x;~uBIHN-_}M2b=lz2Tn!JC>!9++~IG%M(RAiOB{}d)V>f0b-r6ekWQ1bp47&X`lWHPXBQP}=@|K~c{L^bg5^qG+J-VAJN;z3|N5nw{j`!3;fHM@boUvZM`Pt@f7+5~Ohuh}A3`V+`pP_0r8HScd7CY!ZDGIUDvGppu(LtD9bl0g7>r&>!&-nVfO7V()NQ0Q;Tm$#u<*{H*?ttVj>f_@NWVEet8f&E?_!f|2un!a8LN{@m1HZ<`ZhKaG<rfHKw?hPRCQ&{9RHHpIRk2sqJX9Jo<Ux2`m{z3~&@cYl3O<6f$<g&tJmxQ^{Dj=lX24jZk*OHL3!SeE~uP32+)D2z%V@dxnV(Jc?gbv_z#vq)5(D*d`*RhxbaFW%#2(=T6%otpw^-mCb@sg<@A*Q>t2vuL}r%u*V8=JAh%_Q_(Gi)dyg^{ZNn3&#y^Ze_oH0rV%gP&doCa(}v90(%iII<35OM}085?DH&>8~8-=vkE&gBNl2ZbJX<BW4#2RQ=1uj85l%18J;3M|AIJLcj;(RFWrOZJ;&N>le9SM}p<kL^o^z;R>}v_82&zOa)3dy&~b$VOJ<jy<<5JtKoWl0EdMr-Q<weVR*jELu5u+k7PJ$&U%b+x>>>T_(KoIH(|EY&8CRi_~rzdlWw6%cmnF^Zq;25C)|Fh@Cdy5Q&<V(6zKk%1?NAYdK3=%ma@Z3fPI^;0#5K(@u-xnuv?Hlzs(Y0SL)uK0$rrC&UL2;wmS#QbFyw)&?}ALc$+8D@nvB;$js5SVWUxoOF)Khr7mecod3bf0<?62R!=!~x>?g<1_0_Bg+sVlm3^P?*%2J~2(Y%RY@?4|uNweSdlOg(RCb7u{h;m<2<|C-(7GR+nOIB0LC9_(+(m^eXMe;k`Jg?u{b^`fD7I+OHu%uBA*Q?Fpb-Je{gDW7J_;={c6(x~!2kLI$^^hCBfAH(>0r=>kw`iikUq$^3KTjL(~&kz@Gf|-QWeH8`3u<5#MCwpoZSTU$JM%eQC=)DExDU;{{-?o3X3H8_`Qi~VGqK62)wUUK8`$@-=CPizru09BX6jd&x|k!l8EV*?Lf!ND{-n+vagmQ#Pruwu$lrdL*<9~_$kEn)GETw1YU`szSh-D7_vniw;Tl44b?V9u4yp}jVGqg5UQs@;AKUKb=Ks+q9M4GNxNhmCWG#RiA6V+n8N14c@`)igLLyy{|Ib?8A3Okn6lOr?gH=(!xTPhFrf||ATM-<#1wKXz|J7iYnY!E_2Q#%D2L)SIeXT00wZA+5gvdgJ_!qZhRTIzrSP&+z#O85wo0J@3KP%}rwe{h4|TstOfNjab}CPU3nUt^05R4sVtO-<vGyWMLdWiigq2?RCNYicz*uo~oIXbS(AEWS=n9(qi0L34ppFg08?r#fg63m5Hj`EqLx;k{WFQWMP?Ti`VD2t~$e{GZ)(lX0f_Gj614oIe^kF7m(~3BE%L*eH{*IWMhU1d89^^K{n@>mPM9TbynBIaDA$bAluPZz<0R`gdAbXZ{!mc2p$YnZz5z~4&*psh;a!%F3lB|delWsfdMAJVM86BviNoQJzN0q2ljvJ8br#RVHEiNFsM@a{|GK8WW)9$4+%`o8N1eAPLd%CZosX9}`7a%}tfLp6d%s~leVx-PA5Bid92Ig~qCRp9QsMI)}DWoGz10e9BpA{;^dXY(v*O`9EBb*1MuH8hEb{DJp7M*F@0wA>=j%U#uL}jTmohj!u_?HS2HdSiVSS7L@mZQ{DI@5j_A;bX^w<%I=?9#i}A%_fi!%n^cb!&mYZn$5t%qXMVr!y`5NEX@w0{`@LN)|e)Gi~T23%w5lr~G{4I&2yTLO<zDkHL<Z`~uAD!*A$SS*inX3i}jD?O^rkHp0(L9A1XdZ6#^CeYm;AQ@<{rH@zOkBuN&0WGgCM99~?|Z6hXn(}PJT@uv18nGmUlk2_Ji1f?_ZB7tr=Z_@9Qt!;#lM^$T#KbAMGSM+zm$G=qlI6PhGo+gR)8CcuE2&m1@o9?Y=LgZWcXz}?r5T&0YLpJ)P^LSHDTSA3M8>pniNX53fCvHb><xQ{U%GQ#AH*BP0jqw-oCbE-NLM8)mx=;VR5UA~T-Zc6jvhTM8Z;6k85hwCHcvBY(Vf+oid)UWMK>uoa)2DaI{=EXcH+=j!tp7gVWV6Zq<G?%V<KyKU-2=R7N#XzD?7IW2D7v?2?#;a$l1&9dS0IK22!u{32@ps^lU}8SUZnTl1!>Z&Nbeo#*bor`5k={WA_9s^5fuSJ{hl+kGrJq&`@X;LkGr!o&vVYq&YqoeX6`N*4FSIo?4ga*0MfI>Ya9!d4F!)#!u2O9JXhzXz&Ch}wwN995=c)>a+;4tc*|?NKx-}y0Jcxc!oDt|-}QXyH73$@aWEJolXMk&G3NAK_ZlaBRuL8edtDbH&~pm-ZLd*aq_xDf7uZ`GFaG*PJWnaU`gm0MXGs3iUBVY=V(3}H%e;GpZa7U;JmCRGo?Md2J(%5wB)dh(De76tE1tAP3I`ZpqIDo9FONg@WUByHJv5;XqIiIDwjjb506V$~wK@)Fo*DthspeL`BY{tL=PNi(1C0LVtc+IRu-UCAaB5{5`34xPF((j;j)HJ9Sy!jPdj=Raw_8fC<M3m$uFhsFfDaBZ_CK%+;;n{`y_%L6__zS0$WO9fcr>u0)wF!K;lN)DFiK3bmN#nxt7FRxd~SfT0k?|&KFT`->#5~)(Zlaq6=0mipoNb^`gA30*@__S3NXIIu#>L>xK$Gd3&O+>sN#<TjE=YhegxogoqJ607Mz(AeKmiwnv!n;{i5Z?6DD#AB%&wCXY855B{QfxroPo(%)vG@pU)`#o29cHShd_t(MU>WIiC?d*3#J?tU+$3{ZIs!iKA!JXH<FHQv4dIOI&n|w8LlcjTUJ)2p_n03T7_a(d0SiGg8+f{Sp}0HLJ6zx60|%U-*m<U|#$&z<(5h<ywKEqo;!3_~JDv$yoz6StE<bcqR?`tNV>y8^EdpMp_MbYtRA%1Cw*#y~8wD1K3*=#7IM`=|VT@FYfES18OFMu~@U7ch^y_a~O-8ojtxmuR-B<&<?tD3_ORH#oX!fElZXIKhGB+T&iK4^K>X^#(kmVW&L@61?EY~;y%yB!{9mVH|DLDch8d_toW>$=g|pzF8hs2A+p8tq=D5U#rd3y|8cYS1LA0O=Qo0iSj=H5%sCEgzna?LJAPxthZbQz5k`t@?@4pfzx>A70|+-GeXlMI4Io(zElQbNec^9dmv$QXr4(mXTAYKvPP?p&x=;FRx~f|ci_D=RKn}xLS(CG<nzVPzH3X7FDnWYQFs>eBtO^MA+$1@g`m!~ud<!>PBj)K3#`v0+Z-64wH{i&Aty~JQW)|J;nME=#GCBHhxfn8|mc1AvniaJevcBfOEruMf=~xW;eG6lEkU(Eq_ZFb74s^y3*K{m~2)$}C<hL4BK;#-z%aYKGAw@AwB0-*vcrAjX1#B&bOdr8THoP66&Kg#WAs_aYrQo9hP1G<ghKK=T2sI{2-?!x~X-5MLMK4XlWrUwG_oSk}JJMTuz5WfDbBA9DmT!Ytwt}<pi@_UFqXBitH>3LE5p_DF_}@VLkCekVG^h5(&@5LFO7Vz%Xy^GqwdkJ)itrB+%FwVfd?Ys>qJ#Mz$<e?|YEJfUOmQZ2<G@lTIO)KfXifrgicotLzKI+8PvEWs8>n%TU`5`+j3>Mzj|@YjG6&eIRN+c0&6bl>LJ;YU`(*7jD=n%ACuJC2DhqiXg-`x9l?x|g9av_)@gF&zh!@ek@oUif1LYhX<8UIjqkn=tO{LXN3*u2R4kuz&Jc{`#l@|gb-c3?Y#0Hn3BuQb)iFgoN6Hk=4oQQkU9Zp2LChbH_@MBU0;c58s!lZmzn$w9$dO`@y+KKqh8YzC-CC*Q${i_pkOAKRAG@E2)j@pTMZ!w15NQpw3d0dRsiP+()ENE#BX(uAx1?@znLN}edhzlp;3^YCc(=GoX(PYk43#{ph-Ap(Uzx8sq*+~)&#ZsiaNHK?uG*97qpln$5$FFkXMC@44;Y93F+jb)MsqJtgQbaouDWaW-AM62wgi!pvm17)E#5bPOpJp)=RtQgxaX1m9(dX0vRA0mOVjNDykU-AbYN&CHa3a2+ZaWe4pL948i`8MQnz*oP#L-T~oan7LK+87L)H255L}ZA(kJM8N;hk)Frf1aGj9mrvlZJcP@ElLMFEJMcl&y|}`^v&gC*s>pIm_dMq`3AIzKFtyP@%P-FkczQ27}WKi7%1p$QY-eFxN=VsDOh2jUae(jMGmj?48oJpK#ndNnD5D7A>Itgd1s@;eDikr1R2#!UWjuS4jR|L41yl$8y69*(bpKbrtUR6H-Hx4_I**E|q9MVS_P9ssToQ&01vVQl1;PF=OcnthdJd+IS+S$FFlX0oYuZytAmO+z73Q`wznYy3R|na#DW6GU$&_fp9^QGWiKd)OPv_2Nz<Do`Ao=4y@;{0p%wgfycW5uo4<4iA;XNI1DB{HNj}$)*^aydVKAtHH2EiHticS=_mZDrRDm&QP(=5f{2p~DurxFoK#UKGjLLm6gm8adm6}r-zW8+@e{WDOwJg8sP~MYu=vJIenN3|+D}-q6l0GdRlYt_>BMn(Bjy=DAw32m#MOSnsDWH482WDt+<wC4YbAZvztC+z;j%o`D;)suUHrUjVw`@$tCawrMfx`i<J)7LenPqx=!fb%{DkyIB5u5hyZWM%p)*U+?I$Ea`w6=(KvH$2G<OT`v9ncvLecn#G=I_ICp?ca0w0T%X<GV_eW8^+#zxY`SK+u-GY-c%{e&6x_mm?5KX<8+d22u6&uFW^2jPiJiy&q46MnW00}_n5Vj4Wlbo&YCZa~@Sl@;}#rP_YN{g@&1j$jPXta~k0&1yg4k2L6f6^wa`<@OWi@5R|MlHCe?e*;%#X+PnKT1=A8fbf;8P`01YSZHZ_00L|1ER*dg%n?n)9Dqd{K66)XKVgCIkyI6obhjGqC+u_5=_fo>n+qoIhr<vhV*3fVopSmK=_3$C;>&SZOYBoIPCwx~ugsUfi^EZ^P5TMwHL~Qt#^Jh_*M7p^TRQ!Of8t3c5)W>~SVSXTHsvRLY_pqtjkMBSka#5=sx?x&wVyD(pQWueunetD`w8zIk(uxjIE=I9m7j3(8CgMmDX^6`uKa}a3R~B92-sm8SAN1*&sq8}<8al+m7j3+9SeVq!#_5z{DgIea?ud*JdH7_Y^-tRCyZ@i;gx_@)428%E^7``XpZy_jh*IW`w8EF8A(F{PHCKleJMX-jxVU;17l5NU4_a|Sf{R4gm-{_U>8yO37f`Se!?rjzSFq!6TU^u8xN7}Y2qrO_7ldPbovPgZRdi?i{Vf{lZf&Yma|0)2N*BTl}z3ahaOF=0$BB+{Dh-lLO2%SG&e!{3Afd-@?C?&c6YwYPxuS!RAlrK4xhXAXg}ef+*0&24)>er>QsKh<t;2F!A)TrO?7oDKVjV#vZ{D-V5OUCdF3Y@I>3^z2duFzul$6ctm8}!-+KWYV9P5%;TXo*pM=i<Hdo7QKjDrrU>lLXTgh6sqWpxpY2(TXfM+$~LX6W-SP9P#{}JFloxAcAM*d|rC4ra~=WeFt#S<oS(SE{V?^?_<V5PX37i?xepON>h#cT^!Z#PpklG;zWXNtv~0@gA&(|#zlpRm9hs}<b`>iaIb?I)c4sipHv5Pov&6in?WTncmL3=^H;=8APJ#_1<KwHbs$0Am%w_7f&_K$wK|7n^7C7%M;F@G{7%GZ=lFyITY0C;XHe*;fEA&;&8kkZP2l@N;@rwt#V1v(nvlr2T{s@sNAYgZ8aEN9`xP@tbTNJb!|~TG-}n`3Vo-mi6b!3#?d+Ebg=N6Ru5?x5HBltY%p;m7nnCFgd#N^aX2d3+Hp1$xm3es>NK{f;q=w+E3`~CL2G`+eEk$<Mb0oqL=l2j`S<KFf@SFe!}>?)}=iF&RROFQu_(Bsmsp;yr_#KiP}$CdkJI7AT-dV!}gF$`3XZ~8S4zfAU8>lrWRtJM}ER`LqT2w#-^6m^q(Sf`tQhIO#h3|MNOG~jJIA!$|s;*R5G7rk`Z)05$SGEM7p6)lA2=JpA;O<SyI4cOv0;`;;dl!8MA6@jOmiP{i~0ST#|v>$F`yx@=0lheDU*^C#Pc3B2FJ$BFe=(1MI5_2}PVfwtN_uS4YaLz~^bsJ(rK|E*e+jYz4kwbAr1&eQfE`nEwI0pmCC5MGh?n-kh6bx?;8mETpx=$A*(KV&Pay2xpsEDHt^l<*!$PvFAW9+S*bnhox>u9MuO4`5RT=W_N%!wQJkenyr04);f8hPL8UR^fA^+oH`kflX|O0xu$kQ=F3Ui#@5eF?XF~(&<CxbncC&I-pQq>b}x-~P3>aPQ$Q;GC8W}c<M3DPGgG@<W9T)gFFB@m1-f#fpz*&ca8K>%{SJhU`WL!Awe!<Rlg|Th34UI0oO5b7=x=~KkbX#EJX@S|YUdqEb1Xvj)GqNgu)ageuUdxAEJ4@QPS5IUKS3<24W6_%E}1YpM>VUXo6kdtr)PDg(WCHYNXgLBIpdtOy4D-%8ixX%pc(n%oU^*J^k$I705`f+$h`HeF6|a$?||^RON$_7n$<lXfcYO-PqJXTXLa#QkQC9Du|jR1q1v;$%d3!75sY-rYC29;s-D%o{~L|}!04e^?pa-nqMQ{X*$KdBwslpOp4DAj#UyD12yeOyWzXtrHnT{lK)B#4lRc{w|A4v;@M+s;?y5bjYdH`}k?j~O(9Wes&+5EqowK^_p<FO|Dh~COh&`(dwAq-|<-03Md=L&Jh#ec}oYj?^C-dd=aagLg=~-Rj-j@6x91dxDJ*%rX-Z`slmCgl;U&G-CyKHJ!*T`mLR(I~4B=NBJjOA>vbn98&{Q@#eo&c<Td!<d!>V|%0$u|Vn+?H3fx{q&KW$y=Uh>fdRUBd}n;<JG*v~e}7I|ZK5zZ2L#8&|Ws>giVgp8-2><7!sdX&x7C0KW(9fsLzK-KX<p8^OaeaQzty*Rwhw%E5~xy+Vf5eC%1>1X^vX53p@U7WSoPb?=}_<O9JNo}sHy&FTuxwTdtg*b-d?J*yj8K{oh&H?V^mSF^gAc>tY8@+Ef(^{no_FPyWwt2ZQ*GmK+{JGe#EtnOo51hcyKy(N>E#UZ(aRRF6V)U2-8D)O)b%y1LbtnNxFE8pS3C%N-gv${p2tc>2kVWV4*p4BZpVJSKS!toBeI@PRh&qhnhH5`8EpsQ2O>elVI<T?5|qobBrv$`W^E%`#gVmoSiHLI(DK2<E?)&Q1n%d1)4fhf+zVt7Yj-L<@))#aoAQjJ0SR3&TKikj6;%!Q;C05@wwi8$x1E}XpYhXEebxvN>-yXjWL^bMf9T3$S1A{RZYtCQPe24Y^5yOWDq!e(Mtmow06p2~og;%16QQqSsgt+AMG!5ZLZ+7E@E)qNCX6=4Rbi(GVjR`+oii?j=b_uV=LQ_t#l(hj~0U|iFzLUGPnojH{J9{~SS1bbH3=3|7}J7YlHIg7_w&FWTCR+Yf0)!E$|s9D{|v_0e{fG=x;7-UE_YF78=ceK6*#zM_1;I1P*s~eXAg<C<}@6J)r>V`hHW_4#kxX{@)XKPkB>kWBNJih>AU9z~(YF5|j2aA~(tYTR))vT^U2id54YJt_Pi}N|nG^?8%U@?buVa_3#p4B~!kd2>bE)mMcIcIg=Y&5<@`fgnq8awJ)9ZDk$d<yu5F3zgdv%1QkSe$#n|8a37QP1i=f0eNu7{Jr+bjJ|LJ*!)f!Am6&>bObM^wJNF48@F#2Bj>d2FjZ}bR{U^@0Dbj+;r;wEe7Bp_<k9Ov`Nr1jWpe%8C$1b1ReFwq{e3jk~b?z4xpsyhrS+FA^IM$lM3g*k^CGk=1s>U|LM-zW2Afs{EnL=W<YWd(_C#Ppp6xY0kq$(NN}K82!$*-4->B<W?(L{Zz6HwEH1GmCnjc@$p<RPYrEpOwyHUhmVtz>_<4hiIIgWc&iP0rPgaoo+WOJF@^xVA70x4yIIrz?FV1oy<vrjh-5mF|$@v+TIB`)w>)QTumS4<Q6L(d%usq!zn3$?2Z=@Z+q5Xrm0IK)%Y3S1%EVj+1`7hFI<L4bgbhW`^ZEqU?BDsfx_$!2~4Hoa=&QGUQJ`sf1+$6QZV&DL>0fngz7F5Q>f{U5lV6nf4V}k{~!bESdc(9eRcftJ$KR$<)KczXd-e5s`LI})ygGJdXT!@$K;S}c-{g(|E7cp~btJx$gbJQCwMq~O*DZ_}gh^|y`u=o;HNoAR*A-%zZ>{D;BphAm9RXSnO-FnF_5EFVkwm|giX>Wn(-;>!}ASj}@Ku|<)fjC;4vtT4d;OE^$*{dxOAI{+{2C1bK!uJT++5#~>8@d6UHq`JTg4Gs?51Vn8p`pVBv5=!Z>@5(5&N#L})P0$;YU0AG5l3%<X!|3Y0chDtnvRL=tt}A0U=VN=sh=u@pRwVY9@Gx|4$vJ9U$Egho~^r)f;`Qa6@0~p7kC<aa2H;d-=?x*sY3pbssQd<vO+WckE+QTdJWRcj{OlwAn_fDgONCrq;3gcklG)y{3ph!^z#8NCHOaC25NtVFjq>~`y(c=ki-x1`&bL;{Sn{yKw-Z{`u937y+0xy!?Pzy_V=<N{@BK2xiJH>`G6JCxO;!ZPK>&%0ITQ1r4qeAVnrH_|G?<2S^wC%l;_5TTAWP)HdEtQY&?;}&N*8R>`j-vv#6=uh%y-a2!so+OR;iN`y+<J=6?p^4@JtfKVmdJCVGEFvyPn6<3XRci0kdH0kuD(Pfo^?fW4@3lE}0_Vp2}>e}mE2twnT_^jzDIatJkKZN?q5oM@|uTYj;C-pW&^PUsrM3E7Z1X`@cIzD)n+?%{Hx)vhQfPPcnM<3y`xy|l^b^NbVCKRna^2yu1Vi8i<|+8szWC&}FIgYQ`<8a)Of#MMr;cK4W2u;||uxSePNPfGgx|3bH&XmMkxQ@IG>>ps*m#yXv7qg&Dt0O@}#j7P;fooI9`cnG1|i8hbkBpBP5v5I|_44qkmSv%31&_uNjSpD5H`RyE)6OF8ZhY(LY(Oz$jq@_q%r=<(q*I3D8d`BZ0{x;B$G$St7=|nq>HicgSc-y5y=B=G*f6=?aaRE{NoLU4alN0TahMW}#t9lkpw-YUR0+L#Q*6mrU?L-?%FIgB3#!SuHFkDrtcA{NskEAtVY*#F|6D<nEgpwrt5%ACZxhhLL(Sn|{NI!${hpSMw6YXNMMGEiFSib(wGCBT2RToL60oLgM%w4seXhX&#o!)fR$*o2^(FUGzI?=v{<q?xl$6<~Vv7KncY<6j{(I$lp5<iH;d&Djm>vW>k*dX)emvHz-Ytv4&ccWz{{1Fa+YkBQNTQS1vM5B#nMB+s-5Q`t6%ch)YYi)LOudydsl6W&5UK*fuYbRRn*)mH$m_AyewP`2XVT3|{0S>R*^2&*}rlWQ3dx5=W<I0IPwVHKp=YV}_<I0IP$YbgM9fv<{TshJ9EVRm>V<2OB2Wnh7(Kb$(Z2&I^tg?+OCtAMuEW8=8mo%=OXsu|ymA>gZYM|46Y$w{#*+`lTaP`0}>`OV(+S2Zg17N&6P*<UHqP_Q)RfLPczP5{~oM?4tSWdKu!2Z&>-WowKFpV69j&G2wgxZN#;*8UY_Iy*x<f%9`$|RzkXq9Y{!U0C*E?hAAa2zHLvI=0;gL0yM6ASWEfa}}@<wR>$+RFD`98S3NRZg@myR3|^;c(lnM?2B3B156bKN#0PSXZZVqD{?fDJcRhez2}i<wUz*!IDn{R^OIaPP8SHWWDfiz<S&A%88c$W9to+Q-IC1<&_id=yQw>B76g|ZCYMC(f*<V)(1#Gtz<1*QBJfDw19ja;9X6q9P4zV)u8Xf1Pnn>J4EHKoM<!8TTMwcpt1_);t3PEXeZj=t*j>OMX=hrnU!s3KA-U**wQ%+tXJJk(MW11+TAA>b2V7|-AwzT&`z{}JQn>7s9(A0wiE5G4puoIfZ!YI(kYnQiB|FulJX6u0i<G;jCDHEs(%DRRe&jqU^~%1eTc9X(t8Ze;xSfEv~r&!91F&@q3+f|Injc*p)4x_?$iV^$dGE36YUW-ZpXm*QnNa_>qtA%UZ@Z1FQ7ef=ct`%xocW~p~{KLTfSkoIa^M&@iSy4d&&b#9hSv?R!+3XmhE^l!0MM3Q#sK-s4H76&or=>4s$-InVe{s@^i_2YnZw|F<Q`0w7bPD!UZB!k99iHK0QedAR-TSVQB2AooHt^Sp^QKZ-)+dR;6~Ll}?l9<0%KcmWv~a+KJW%v)<Mq^wgv{dq}06Xwj&nu^`NHlcxRK{9p>k@5u|BaPe=br6cTrLx~nb{TpfzJw;jm8|w6M$G@TGuZ0;5rxzw6^JxiCKxh24khcB}CG@I)Lw!pdK1+a8R!Qi8L*;{gksz-Rs0qQd1#JBr>P82d4ey1+01c~uL(MsD!P9Y=qhb0tlyuBdyO6XZH)lzK=*6PLF=FGfyUpt()XTE=7Z>kn7B9;>P@MjfDqog$usH2#5HB4P@2!c>UJ0V5x|!sZ{K9%mZK)pSaQdPzdAg?2D;Pri2QL6#Z}b_br)v%^4aXzB41V6pu?|mHCEA~sj^ri^;xl3$p0486IGanUyf+BL+$81c3ZNR8sxam0qJkz~uW5O@Xmf=2bkW+2_H=!;m$8lDo}(=Qi%I$SBb}Zu(i1{p)}F4aqojE5QBHAA(SPxD`CjHMO|wZ>=BPbg?{Lm2r6ZA+$2vV-`wq#1j@FR&bdk4Gd%CF5hV~&x4;?Ar7}Q{#!_(D#wC(AlT^`!gMG@`kqKNi%r4Qlk0kVFApLb`h!_)QREY89}%{$sc_`X<&r)$<EOc4N8((v1{4o_E8j1KE)=t!*abZsAHd%AXi;qY|Pu99lv!m1HRd%9jhEzgIRrKIV2ti#jw>M~4&ka|!d{Im_v^t8f5{t2Lq8a`{ob3FSouKgL%9~!<a3okug)#Ewyk8wg$TsyO_qwpbAXzk3piQ9A)oEk`^-8|l#u}){!A4Sn9Af*GKZUp}v>vU!bi==ez%(_)W66fN#SPN)p)-d|S!gi$Z(RpcS*1f5moj~$g1@Zef9?OmVki7-$H;ucUS(j0@fn#xF#yWASL_4z@52rx@7?m{Zp`A;4Zp?&XH2~IH<CkqbksE(K&skq!V_ovjqNZ}A7;J4m2y4eWFU879IkT=CFar>dDpDqAR=3ekXI3n_HhKbn0{g*OcMT|KR-HW59KiI)DO~KCayzrOqYd<w0;9?}mlnO^V?V7S)K(?ud0+l@H*LJ#S&21a)me2I_ivrm$Z?L&>KzP|HzDC5<y(nXn&^y=9Ovk)gkIHI<*kFrmw>-j61uZGn+;<el75WCKLl5cb97caQ@O~7=SG>I8?Rv1S<OBoOTjAwO42ZOR&u3<R)Uk7gj0|86>8w-J-K!gHUT|K$XREPa^@RE#zMs_q^510qescP1<+C?uTv239_Q#$CZY50L#g~d5Kg*D#jPG?69WDXupbpJt)y4cb5OF_lR<wi@}gYEfcx@w?o!FoIMH%7hg72Y-Yj)Jp%Wcl54}2EcRj=YWUMf>G{lb&A_W~MIJ+Lw6GC9tUC;gsQhdHkoX?-|uU*gY^wvksCRv%I?s|SfUr#Al2pSRR?0QD~WI-QlNcT2$g~EQRz$}?6iEi8pB-hJ0@4Ru<X&PS<=}Gu`4?1sLv&AS<6C}4&kgQI1<C4(BoD?^17zh*HBz5B!y^fT{z}6_-x^ZMoxN-AnXW2Uwts6(<b*ZGgym53PiJyIF-MF_VId0sXILD3q7{jWszzqb0e?|)OPIBHj(i1{p);DhE`%=8VOPtrA^shIr(Q%Ykvq@IwsBc^b#_p7|kVxlUH;!IBLuJ{eA#ty$j4bgIn)f(k2RA>Sf>_5l>6_*IdFbF*Xp1Js2F5`yU*y}E1_#C=84GVrqXXkD9!|u9MMw_A7SC7Z7|V&2eE504qO2rzgnI^-;;a;st0;(nFYv#!(Yr0Vrvhrd5wJFH{4B52o8AP^J*7U!gRAwjg6(hvjlI0=D;KHYaa8b2Jhaqgj0(i1RXafyRD=-Y3J>@J56doy?<W<vWzh(_#sj+L;p`NWFDQsVB)qP`zvrIsF~Z`v0Y21(zlcy~&mdIEPuw&17wE==9gfVS@bh}nfwQTc-b<f`q3{cnEjcwdoj|qL37xj_CNEs=JpKO>lrqhxA>|Kl)S8Oh0~H;R*o|a!kUk0j$&GFXXH>#*fF=|Cd{H$#Fn;4vqSc^uF+4E-=0<~8Byksh`?WybchS!nFpxC*%*Q84|3c?gL|}%;SRKvT4@mx1LA;nP8|*Ru*@UD(*iQB-icm@@c!vm~9^-Ko?hLT93YT@zoBCTL(vy>_f_Va|!!>exjI+fVBb)NH1;4x2DLYf@ag974BbFSxV*pN41eQzKQLM+fQkeW-NMGkJQ2W8vkwd)4n2o-S)Op^YqIzk&?Fyl1zRj=|^iVYN1phRLvC?#sGQ~RSu1?me6S_g-BpoO9NS=Abl8DjGlb4k8kce0D1d5x{(_>Uz#u+8>WE^VY=dD2H6YCSkV2?3|hW5M-fQ|&#AW*EQ7$ZH#Lwd>hFr-gZ7_V;=#(9hhn8))a05@p@ok^Bha536?91AYSB#*JV3*CRPuDNCE6;kRYb&ki_aFG0;06kL`wTWH&B_Ir>7CH~m7c`@lt>Sf$k+&~7(g4<V5u6!q@)+suk<<Z<{;rIiteqYs8x1F>fU!uk=w;{@i&jF6k3B|f`h(dvFb*h|v_Y|eVVw3D1FyqANceLQuDGvEl5Ts9b(ppZ(jOr3X|9WtB%jx~eaF(24}>DqoQ0B$97crKh@m1@1z3ODGxcq;ig=C7uaRp6j6QBPVkyMv<S8iLiY^v6jN)G7^D~mk7viu?iO8i8qq8SQyh~cL6THTTN0P*k;&5`BGD5M`VU+b6%hp@kuH*2d)+X_aUZY=}CGW+|E!%V@FP1`#uAWljJ>X(-!>Hml#@>-6UYb?`rt7lNQi##TQ(nA1S+c8njWcLfiNrH-=&E&#r4FN}*LdkGOWQacCTndHPxl&KYFhFuaaeE5(^800-)mHj;Iiz8fgQ7PS_&~5d5smTEc`04n>J2MAx1N=G0c<~!T-U*H$&sJ6k@dU8lxLq`18PGY@7zsMmw)DEm1z5yc)1n8>g<^=;$?4`g4hA0PAYwv`%64@fsuhSok<#lWm;VDU5+$quDrXonj@h^%@uJ5Jr1XA$oJaTvRZIdX45GT#)!_94^gp8l+r@Ffu&3g*quR#%uIkFPWUpWGr~5m4Ory>k!6duW<^qB2OWJ@ooaGF&J~aM!jpYa6A=wqnWOJ1!sZRSeo6+s3-8jnKGhf7h{RnNTsjO(Kk01x|N892xGO^c;_`Mr=1||o2l(Z;Ok+_JFHwj19pC<u1{KsFgAOQ9j{t7bPw1ATVCMXy~e%LmV6j8%K4g-&qWIn#(q3YQ8c?kdg<4ctXN|(4tb5b^d-l1q&HER{8o~1rW+r4jXty%-2>ntO`!ILo#TS>sn?)ga(pf|7NU@JkShVkMXzzBqxBqb1>tS2LYTK`ZY1+>ukjB?&VqR!te@OWyLFOuGr%Z+(NY{Ri?JNDTy)vm(JF}%5nx=ygo_sgqtq;2b+o8pL<Jb@wp&{20&DKlVv(K;Fm|-CNc}(<=gvwn#TuXy6JSiIc4Q$K>t{Jl!KzYP12hr>j1_ap{RGAlU7%dzi&5nQj238n_(i0DZDX`-VN?w;mSG&te?$6X`$B#?4XkB=vHrd+qbK`p40mQfQ%2rL6m&~t`Y20)(RCpPFv+0RneDRKT>tDwIR*w8iGxAN0QmB3w_W&dF=iI?`YO^Y*LZ+4+#2M1#5S+*E9><gp7kJXovp8iR!EG40Y*n!FFb<u&$R+EDv;TT6_P}+?`&>p_yLTkn$<^Jgrq({0MwCQU%m`bBQanqJjX>9EU{!^g!zowYh>f)sR~y8InGB~E?J0G2P2QqxYZ1-PGIzL>0^OnMPZTG*JZG@SkJ2<%*%?j+UuKAz#?q};T?C$1XIo<ntDpmsPhH#i5u-a1;{DR?XQ2?<HOG|?2Dcd!^KO*{PQs4ySR>~|5^Uwks|g>#b%?=<z?q$f;^X|12pK)9?u<rc<hM=nl}TOp$U1(ov;7!xaI{;J~uWT_$1Alww^iu@c71N;g@4?0N<!N>(?{KA0D6Yj=BJLT;n9cO8$5kI&S9u2OZ2EK)>NPK<$VfKs#dTL<nU1C!>7z+C5Zn@{=)g9pDYB8)~EN$^T}WeA7RbD&yzP6YrS(PlyH75Xmnoh`$i;nEabf7%N7pd@u;(+$6OQPzVOW=O|3gwStk5n7e>Ar{6T+F{h_1(R2D%$YLkBSLV?|2PwZh&pD?jJs|{UJ*QuZfj5a4obMFp6#bVu{rKA$w`(@Z${h8a{zfQgl+u$(72=(9`l6M&DCjF1((3?p7qn-F3N2<gbi$%9d*qJSL5m&h0PPmo>j0e=IMx9uqSpZ^qSpcDp*8pmS$mP_tu1WFS_jBj&si>{7FGyvDqw3JAQY`q1wb`4+&Z4y>i`RSa@JTw8S%m?vv0n=4shnOV;!LCLd^2Tg;gVtUI)0m1p_!}SxuU{itMd*fQVGi_969sh4B71Jkzs#5js{tS2aA;hUa(&A(P(#{jK5AHoU+SiK$;Cid1-^6P7CEj@SFBwo(eswBwb3iA$v`(u)M|hhdrrVmBoACaI~UNiPzNGC8BtPX;uD;Q8^~u}C1ymD2Sh!4^!_DPcc;?`Q$NNYE`2h5Z8QmvmlwkzfZN&pSwdq#(Y+#$&nhdqvJdP<go*DcrqCus4IV62OvNxKyGS2{vs-Qd2P6Yt}kDm-5``xCO%?U}H5t+Qt*Pkr>I?d|+!`^3I~Ba$_*sii04WSmeAED<`!`@H3kKuR*w_NSPK1`Yv!T66CDS7(E_gc&g}g&(0c9iv(TpOeX-Vrg4(Uv`CQ82Xb>TI=Honj)<OX`%w;|hOABLLe`f9&a74YTNha;R1k4;OQnzviIW%A$#R_3BSnrKuWc{Oal<#XuIt|Mx}=MQ9uwr=@j7E+rX8>1>hzA+UKr*EEnzHu38lIZTj(;~J6`EA2qCWC@wy662eGIAn*#Ta*J*ntefPi6?H#Z5e;&?H0{9F+@2+_6*zvlU-nM@e>Axt9zfA<a<CSg&4<S_VcpZe16VJ1hv7$?r44qkm?l*!Fptrr|rvJ1zK}vVG;1N4pwe6KmfroV0(nUN*Ct4AigOp`j`nY|el{`iTdJ6>K4fI{jI32H?DYWf%8U1_WEWqn76*6zV?G;Mcqowo$QKuF`%CzmZ5yo_d!K#=A)4lDrDn=*#MbO$kOSQMXCSq8^2Z1q3v(B$oHLJJ1)}u|xOTk#DSnh4Fe+F}QmSo=re&TgkW$A6N&!f*1r0+nu<0_QB?e)i<mL_8vn(<}MGTGZ+uhCLq9Kgh7&)ije+iO@2BsBn|wOfte_A0*Cthc@X{6I4K1RP#fBKEe|4p*3C+iU1UN#Z+k*hlQk@!YZPwQdtGwS9)ed96)vd!5qWlD~(;11+z&y`Emj9NS*IVT?&6Uf>OM)o<vssco-c*zD$Bqj5tnNW2~njo(nZ^|n_w#?sac*Z{3fZ+rc+r6oTDhq<=A+V*<%XRGX6fxT(tYTIk}JzV0afPHS``oH62<wfwHaky{eYTN6m`xYL&oUw@I8duw1U#Tk_0$v<gX&YDDUVmO;;q`zu*0|pG+K29Bccc$o?ld2J+v_j;K$r?}$?`1hOKp1%BoFTnF!nCjRj9VTo?C7e;ZvNPvx}&<y*{dHxs&b!`(5K|+v`<oHL~F{a;$KbP;Yy^a+x`{y}sR6GI>=T(ld#uZLha%k-`DS_>Gdu`{6Khg;fBn9@Ms18WVWt09@uKsBN!BZ(8~8#o@3!U$yP^_jj#~F5z(9tw(Qry|B$v^cN9U>grV6UYl;WloS9Ky;4`F+V=WFXG=Z_SWR1AZF{Xy%aU&gtg|hzw!OamCYK*)9|LTXEw8q{ezO2`Q!4gyU~9F!-uC(;I&*#q=^rXt%U0C3*BSJJ`!50B)Px&?Fwxrf+L`9DPXO{&DtEQ*b$uhNVaf}rn1Z=@!bC25+v~L#EM_gRnz@-bY-T>6u{DRq><iXdH&Zl{dfV%kUoGYmu(rFI_Cuk!y+$d;$3gwVMYp%TUY~9?j<-R0>eeZkdfRJLdVOdlM)?I+E7sX~<v*fruLbE38D#-hQUrV3>zFqYHbi>H>MR~(we9sM%=$b-z!<;U-5RKEuS;S<SOjo`CWw)SRHL@NJ{$yf?||{SX0>+Lk>2(?CkP6E0PR<Ij(Xec>TQ;r$y|d@aE)!w*0$HkI9Y$5cwkl6WO1L>w%3oATg(<<b<2vWw!MyPDqAeic(CTIaXzP+w!Q9OU@_lZ!<^$Vz3nx)E|-MUMEFTuyV~}e^FB3@NWZHKLjy>??X|GiDzE`7j9lxiO1<s1S4U}Mp5nl(xHyuix4piKfkGn?I%v{qdq}0Wy*3PHYzPRG-6S!Z3Vio{kgoYWzuc9BU(Y76-o?+Tg_}fU0*7IVAp#xj$wha2axoku{NyQqxn1_eI(r9_Xj#+_r0?kI%W?<O)3uHrNJoyKEr5>7_<5g}gaSI_PldF#14-yrJCGXCcD1(PbW##}2hvT<Wl4~a0yKeOk8`{1`2#W={yGk;G^}<YO{>Qxd<cib8m1jcQ~@l6+LI)P%1)wJAte7mUwsUJujJ76_CM3p=b><qA^Q)>2a>${XL`X<KsmsDe!T^`|Czp=ob=^@RZ}<*C3*eN^jes<<UmR*;GNwZ_dnC6zl}VPiFwL!`S0_^>mC0-7mmfmXxht7*d8Y)e2R%@PZPG+XI|3SK3~oU${=X>FH0Q!x<&fSNupQ636l5}LG(QINIdpkGjW63RD8s-srZB9^nOaYsrYDddK-Y)R7{C1k&Wh3f4dD1{q$Wvp+6|b15)Sbs1Tk&bD}1B1GCevWI+<!lM~bWStZ@*)I|Hr1WCM^E%EcB7U>fw=`VH7;#(St%{p0Sy6+^>6Cp^VO^;qjUoXHl$8XH~n#rEkHPgKi*BmHBFK%aI4|eyBS?|H7&Ry-n_9#)|b4~o<xK;j{8y!U>m$WFFSQtuNJ(ozkeCC^)^rqvUiI@CE&)Fplar<8i@y!c%A?PlPLWpk<L=RpfZ#Qj?%<9tVJ0R-P*Q!0_l*kfyeQuS%{w7EHX$OcXTE)(!ze;2152<a^zX}pgVIme%KU+kqtb*A{GroXQYPm$SCWb<~G2^1161JBSQpcj@Q0bVGqKGZ!KCmi#OUbT`=4x9k8+hO>C~Yee1*L6hEV0c2nuX``nAJC<!Oi~?XCe7K+4dim>dS9-l+Z{WE4K;C{OF8T`DUNauUC?lU)Rl!{HQG!`4tmS^T=h?0}bNl9m;PL=CMJ;xTn%WxkG>TX2*A6xcC^0IEcq1Xk}B$o^}Jx4NCu+Vv9m;qb*J1Kp3mid9PKnDvMLC*8%JAW3$8~Ijy@Gxy4afYCwfXv6PVb@hOW`(Mj^FD-!KfP(92{gQjs`&vbbW!?!py&z4cAjxd~T84c^muVrPvtP&^DWBuy&MVnkO*Kc9Ay%|v$u8G&|(U<gC&?s0%P%QT?TPgoI_NgL^f031<kB+nyua#)m8<q9D$G5%&XCHmTSm;&|{e~p!TdDtMBBaDUm0w#4x;F^&xw$VnzZ5C6)tQmVqv>}a&<9GqzUydM`)+kSoBC58Mp-;=;+6B_1;FA!UsYj253<V(S<;=0YFVuGi#lpcdy8fD)If(6^pD3^Z31K4a3L4fg%Iq%5Meb!UR;Q13WF-lf&6~%8?-=XlzZDV_lK(1zCYrVh2kI!u%$J+_-)*GbrciKs@trRY9b5zX&?@Ty}p7!$O;<0&C>Wk*7n0(<PG)uMtvb$s3Y5~r=23=2^1$;)TX0K&&0}G=4~bAZmNQ6BCCCZzJylSm%fs-+}o`cFtU2_0@V<tyeO=i+beqst<We$)b$;HoePVvvfW|+JfIS3UDQozJu(E1np5jWPHJV-6f`wM)=`HHc_UVBchvg-a3c$c;qW>4ZH<!m{^Iuk>GtKKm!7`o_1$hLD<c1n|9jQe9>Bx}&c4oA!yTEctrk*V^w`xVP7~sCiE2yAE0;S5?r=0Md{$MWWZw!(f-k+gY+x5Eig1kzEkVij!5};)1JTORUa9wXSoc(HoGMJ4+r-Y+pn&SK8Tw%j7uY{Lo-uRUJtgW%$cnvG;vf|q>MpIPz!RxFdZ#ld$(e>>264h>a-l6<akMfPwBVY2uyb(PO7~YBitw@3R0ADUpd}Y2uDhEH?9H9el$er5iRY+x-9E6OD}}8l>WEZ+-j$Q!6fE`~8ttyxf_q^c6x0}lypT7%zJpVlAV0UuVQ=<_&V?D-hqr|FrRS8Hy%R63H)WTzy^^N3%z*wz9$x^O8hXM9@3Oj2S1VvY{46MM6<Jxny3z!eE3LwiZX~FFJ?Q)ZSy_9=$PvIdyPl~mN*0xs)xaQV@)TMA*BVF#o;RI2NzTD(;1uG%qdv~aSzC@clOmajprZOovhd?diTv+cR<}+n8uI2d#i9YDT`Vz25(lYZ(95#(>$O1^YmKv5qVuCctH_cCZOALhU)GoIq0bbVA~spf2or+a;kh5=+mI-A`F8&=qpqfX=%ZAHJP|#oLB(#zVigxF_r>&dHepZ$#v(fVE-vP5Q7UImc00y7g2#exbd>gRpoz@wmEHekI2F`-t?aCdSCCKfvEBd2r}*SjE;_4vW938n<L+ml(7}adCOQ6)k4mvU|HlW<ze)CpC7Z}6x51ug9=wG0AA|UfZ~G^V?MA}TJ<hQjrHBIyn!83e&--4H&(+&|totN-1*$A@Ld~=I#C4Vr=SXxdA?QnQwUBa8_Bdt#d)M;vQhB4+<dE_u_GTq-i?M_pVZyp@`lSHXo+veSJX-RZz9@M)q!xO7-B!ysVeQ_m8i=fh3Dd=Z>$SepI?ImY?DSs8e;~N{Q^`sFqP~O_48~!dpLOM|2%h*~_BuxWg2xhm%PTJ7)p+^j71{T{OfZ5Ln@kwbtvJc-zVH9o5bYl=E%f>4rGgpzo@t0`2hta+$N4%;=4|IatBORcqYo_Tt=DBi78H?<)i2K$gq~|r5Futi>QX`BNwOd<gQR0A$9}6Iwp%HvZwL&dG+M+RvV5)gXVr?>owmC<k<CC;dL?i`QBTB2^*9^5Kg%|S1+BgyO=JC^Qs;a7vuZ2soOGih<!eV_DupUL*O0UCoTARE?=@VGpe7xcy?UMl|5KZCe2WzOWr%#j8y)yxT8V_6m=a@jbH2Wm8g#(f0&EZue{eJ|dMx+txGNu+BM1KDb88H}&$4=etybXRcv*#qhgy%{!T+@t5b_B*@jwK9<a>BZHd#dvX5D1f{yd+s&fyqEym-*@0CRh4RNE{gIDhtGY=E;E+%a4zj{8W)mAjY3_8-iu5wXkbZcVI0-)JPpkh5;daqMMPXz{@<;oE8&-Cx>Yo2HEYeK5;bgC(?mD!Q`|=+*t5@kAYR_%pb0Y6M+vBOivxO{HmdJCs$6k;z2ugS2y=Pa2c=rZwU@^uM$kwKvd5Hc$CJ!vOrVLyi`~&dqKgWJZS<a*@%a`jY8?>wjq#YL^|)DWi?eF#mrm%V#{(6(tPW!pUq_;Nc=;?C_TJo(c05olNbR6+-jwnT*YQ%V9Q|ntO2&&3)~kyNHWk_B>-BzLlj(Wa<bLj?Wj9j!P&Qy_fWdx183nXdqF{rlMykG=i~dG{=A2;dqnVvJ)C52wRw2g|pdctxG7%S-l>V(4vaSsLBj^(Tx;ET<@?2MA>kb5#=^U0OYwGq$m{OITjM7#14^BL)bz<jE5~!6!MvJ;W$lrGg1`yFz8<v@vuXR^1J?wY(lfnA|v_+CwY9YD2n);Mb}tpNvb;?rb|FlcuhQX-_uzg4DmvKp))^Ps*peFEEP2p67UYr3gHffgwok8JpUoN>8w;qq!p&K9O!^U;^}N%EYJ!#ODIBrpSj>YzMV62C1xOvKcKhn(}7ipLI0E=^W@UCy%oB&<17V5DqYUY&hrKs9>zrR;8Rx_o6Wm6<}4;RuQ8d^aSF8f3Z4j_{4Ir-g8N>l@Otoc5#9)1EyA0@M@0BT@HG+M3Vw>PWtW~qS;6z(AY1^+-=`9d{nk1#U-XmUj`>iC=l~u(Mx6L~@Cux)<wZNf(xQWXzW7jD6Y=><gwi!dd#TqdThZ)=aevj@nA(=DoR3`3RY#-yDO*LJe^Q9CveoiTKtEjdFvg!{tLLV4W85Cudb8+n+mf0t=5A8+u?M2vbK9aXOHuk#N!ea9ea<kP_qNqszDjB~-IQt`|NpA_R;U?EmJc=6-~0bm^Mg=xYa|zS^Xhwc-6T2cCh5P`jTl)*H@_pR_)~|Puehy7oc|{^=Qyc}S}4`zJZ!5e<WN)Szp2SfYLY)JNIt5{!PnnstoUM#>3xliT=X92iqM;cpLYUjl2B8lIl2$t1j+3b#Agb85#g<k2NQq~1U5$Da&@T``Q3fh@`|P`rX+^pzP84x{gTJm;;@4R=8-}=W2MMB@2inlJmaM{t%E>y`Soro-NATi8)t8m^ferAYw6oUnl@?pQu2z{Du#AH`??v0hgjJ~;#v#8ugXtnoc27+RYG5q-1k<Tc0l`v8L6}uSPPtHT0$rxF&0BxWPGm}wc2u_k@vx2(EC<dSn+G<jeUzfo?4Kai{v-nclaTsGBH#rel-eu=6KF-r2ZPD%TA(jLQ$&qVRbE+>BH(Qgp48j47zU~Rwl^v0WwF}xr_{7u)>8_xF2D)Y-MORVLWCmtYh|~f65QDmp=jxdqt<#CW5oDE)kVsNR5tI-H_~yDy@ATQ1^T@zL7)nN<;P_{&K!I6XaH$O8fIbX`g(PpR@3B=%d2==Q~@*!v8>>hYiX%+WIG0ByAiFt6cszt&6NWVy)GLRVkmVjI~x1R=xZu$T^a3Zdi@-G%|_qPyZ7O8y5PA1g2mh6gIrZ<1)@lG4$u=+q~I{vB2Q$-r%YjWcAL0dJ2y6Mu<D$$u;a6qJ_PA2V<<t%cJh9;OA{j@8xJ9up(Y#5Pc=1G1A*AOn9>8KBC~~y=6{|_a#0>p@PeLjj$Gy$zQ=?I*D`=Y`U=Eg5EMm1Ur5eVimncci1(N_--5yYIfisZve02H4dT!>qA+70ql}4oWxVS#@M%MUm)av#o;eqK>07yCM!Wo_ZqwFSW0poWvswatwi7ryhh<4EhQC!r5trDq0LUgO})mVm#ph*3qtp!R!KRX$$zH=Kj%%{Cob*<%!q?qdW}kdTlvlg>2<AFhy?o4vj(^E8jG`YnfYEMA9m{vEJW3m;Wb{~Z)v)W<QthZQ6C-L*=xN2gLN5yBRSiLZcQI!(j45~YpneTmqE$VAQV+3+v}&-W>^U6YBLj0r!b#UA34lNtQy+p6H4Rh!B94m6c#AuG@r3FsGNiJWeVeQrJUvyvB_yZ#db+1KZ?Ui5-C~AX+FM9PV?!2ksOiueH<QYwl<%fm=so`EF+FFmg|@*oHm~?KC)IkN&~B^@J!}2=yyv=3lQ4cN|gEB%4sPX3T#3qCCYrJ?6IzE83-GWStaFkW}DCBjZX97iB`U!f^=Ey6(ZVvJ}EAzR{S?4|LxYR&1d}gmZsde-sq3qnw0spXk=+h0-^RtZcWO38bc%9KHdq09*UI3(jE&TUCDP-x#(&eoUpsv;n2m`Kz0+!pMJs7)qcGh(7Q-Jp&)+g1xHu=kUnSqHLzO>cXzd7bwhQv-zG~Q4}}%v!O#06!E~m(S~22QUG1N?bO+;Il(+~j>(|GjrIv1a+|kw2rU~8E?!-eNvKs@+YsXdj>Fhsrwc!|{@SWfs))GPqiRrGkOL;Cd@=G{;qsqdHPhG^RtG)a+pr=SSPB@k+r82QXR{R8VL08+SI*8>!s^uh#u9i}*?+j|WOdlI$A@u$D=(^ds=xXU($ke57N|RwvEBw+5pCGK(AkER$)}JPqqgEj=9u?#0YO`UA_co={%9LE5QeACead%gH$#i$MkIQjaS39#mb9J>lerK+(wsboE_3WhG)wWHuyV{a5c2`>t=h2(!dmQL$JD;?>+T?U+rP$wsZ*z5u)mCmi<!CF#9kAQVe6-bN71V9O&-*07*;Y>V1A7PQ#}&r?uD0^RMrT{ODMT{)Jscj8i0Nu8Ki=qUD=U2<NxT4_rRa|pTep?%U*s$oJ=#gYYJRK=r`yT_^*IyYzitPthr%<pmE%TQN+yCZ)mEa~${iytC2N3f&!j}PmD3`v>pBj?7pkP3&g{1GJy%;fa=Ml8pVUyCQhJ4mZY%i!CNqB?gkq;$dUacQYnP>|76=V9X;N)v(Ce0_o*)d)q)D}vU%$y2-9A1GgawLZuU?C`l0MtXLP%GeWfLs(`Tn%SeExKsPXii<Uxl)pq;R3je0tG46`vs8|A~e1RS8b>DZIgHKE@)+<Rx(^M<N>%oaPg?!D&AIG2AB-Z;L}G&DQ1<TaGar2J_LtCaMD1=F_DtW8#D8Zvfk<3+OhV%WW(rM?g4kD^ccCt&OGR8nD}$lqmBlyVSZaKk6~!v{h10XSVqSZE%`Tm!4L>l|ZU>TIm%c+I)t1xy-yhl6$)KYV&zI-_kS*$+I$PQsy(Hq@`&SlJ{iNq|7HgKWB9N_-Q1cRU~_pp2K`dSMu5q<gB*oXLeWnl(vM0e9BmM{Jd#J99?ZHdBx+9TvkE6aS=yX+lO|0)dtp7;qI<hxb#$4TLzOo;_(qUyg~w<2&OaL)%Gdk=xPVq(jAP0l^B~#(g$$(Kudq{sk5ss;^=B0^|i9Qg~KCVemeUPUF{Wm?^|BfPO;CFgiu0ax~r{<(Xh}{6QnwyS!J>PnJk1p78L#0O4$k0Tkol}%hp4NA9t5w6)R33&Z)MuyQ35QbSxLIzFq$rv%U+YI>D{Q7<->mr)zJi>I7@{ad(16o4Y%~Z7J?f@LC@Cd~^Cd_k5GS#}g8M#_j~^vp%X5e4~in39i9;bc<qgzS-l9-3hMj;j9$<g}zDVuQ+@k2!otlS&sc~d~O@0m)@wm0(#cr=N%O5FvxvX0Ubi}hYI2&VjTvVo!-`Q8Q2YlyA4u&w@(>l`^}QagOGX7&uQI)6w;YCNa3?p2HCT)(;yo&R+zR#*2bZ!mTvmF!ysE0b{OQDOICIxK$-TrDnFh52ZP*Q5uB~yysagK5)#t}S-+ap$j{;Mr7Da4dP){T@AQqnbwxTr=v$^_c)yL5;a)3@86`t{ziqXpBOL}grX3frx2!<lg%q#vRR+0aCu5B%RlMkz4%#4(=Hf1cY*UB14DzRvZi5`M$vrB|QPypc^xE8z)nC{KNpIg(2DvuYHptC5kFIrB8sy_IY=fLO%2_G)OFNU^-@#eZ4ot<9uicX^<dAc=K?cwV852-x<?-{T#yJdfObtMFk=$HCyiuIPApHSQ_cE{{3U?bMy-`vdWb68p$Cu$is|el}q>#?EL4H%vVUU#yISld=Zpa>zzKp{SEq&vx!yxN9{eCgit?Ytut$EL>^3&OWFvwl>#-6I+)YlS135jWgT$^8N<Xv&-b<Qda)9>V9A@oYn=<AbY3rVk;B*W`FL52xdxXKFYt(VnuOmG-v>C^I^9>*yY@%~3;khw7o_>NM=dqU};4RXj-w?U3>=x!nVj(2<HJa4-VvS6a*NB_J_+E(-Pwr$ayHT9~g^M#r*=cGj)zhGNbep*nP0O?oH)5GetDEj9Ze*?)I6~w1IEoxgX8vg@3u5h<SiG^roQOWxykKe)J5eY0Kn9j6C(TcRTsBLi$i%RGS!UekbI8?Zxr0Gmslvo~C78QQo%C0Ray)UTp)7gKpsK01W{VZ@+XbGW&#I!}#n<+K&130{^%HpW;5Hh0ZQ}4+pj{e_BmJ>TkhPNilu(cJZ*Kt-mJ<(xN|KyWv!+9<;>$Rl1iNhGG9HrW;#>%3a%yRd++eW!9D*y9ti#p%iZBbuaK4R6PeKpasO3jiVj*-2i=dx`&BNFKTqc|Vn=l!a<!*u?lf4p2o@^=d2-xqh7PQWqX4}p0uS-9JD#M-Vhodxs~Bl@F691dkk;32_urcFm|=~Sj8Hn%C$>2r{=>LlF_hXGo8z$J(2h<&umbe=0}Ww#iIjjDW{&i;exbTsI;fOA<(2qh$@P3Kss)X0Cu;gKqfy|B$f$XcQcu9K!i%i+Q|F;9l?SYe6zGNiY@R9ijIVLI1lbFr<Z8U6EBywpaSP6kHf{V3Jm@S;p-=WuspG_j!DbUF`qo6d)c?%`UgE$-ftUM3TA__A$F^iCSpJ64Uid&d-<N55@KpGB@O?G|kAd}pQDZ>wmtwyZVjY;(mi=@k1D>`7-Zy^ymR)V+kC_p)o!IkP3O{zxCCFtNqco^&>L`7A!mFPVHT4x35jC)cDi)#bA&F@Osa{~U*lnyn|DuWsY)0cCj~*h5`7J?T8URqmtW5nnNu|0`8M_oVYSDpn||07BKTv=TMxtWwz8sMP{k$4pApq%&iybzP%CnDUiXQch>~q_dLCXR)!gmG2Ia4r#qYL{B>Z&S71_StNhs)~hF-4_aHA9ueV+Ta%h}My6Pr3V;xI#jQzAIv1p4d_l=6Ak<c*EOxK55YpAAW?O4@>Gf|M<|F=3Wt-2?H=uAnlr1HN2VCYeo;<!gk^Yv#_y;cYiE^1wLX>3k?{J_oulIz@e1cr&^T!NH;^AL27WK7aYx5cD<LoSDSqfN%uT|l+`9y8CHqJEy)<)r(%x7~cOUV!rM%hY~`TUU}ch>QRz*c2aqReONYg}H}TOb@$CFOKxo6p}apT*YdR=#&YdZhIV5p6!FezC3~68ERTH!i)}e2(|CG*tv4<r}vqWj@V1S(@5{&^?nTWj=@7b4It1PXOUnMap77GYcVI(H-d@gyl+`hd_;-(*%8Sne6hbCONK2<g5dce*!vK5(S#!^(}lN8&TiYEH_NQMF0Ax0}Dzi2#K$~zLCSYa3@y0nw1xh@2Jn^fd%C%Bqfr2$hE$nSF>6o<Kr<67Y7!!p&J*aifJmF?qyfAa@Fty^w~u^unW9mGbv)0u)bIMpE6+S1-*AcN)Hbh)}6ETfPfYl=A;J(jEv!wI0Qk9!17hRmoN{CLO0^ySp<`ss@a5{wHny94=bM}A^|M&GC1XveRomD7UAV<djHDDSzRqtD^zTgkTR(v638O|2B&<Qukg1*=0$Hf3OZKHG{`Qt-$<E;A`*zw`6}*0=M({I`9{7LNQ~SHH5GD4!jf5J$vHUBlbsfrB0t3au8=qT4Lbj-CeHI^59M@$#ygEUD|p91?s49*^Ux6<_!W-T=~`&?!1V#h0|Xa&(RIa;V^fbwoKUhPIshiCy2OLJ!9dEl@<dWdl+v0Ke+xtKig`F~qDiMz@wfG&caU1XCl?QGdpr48O76=!RnZWg9RL0r#u9UI>S<SAa~6=(`#0s`1eJF#r`=5Dn|VX&j=e)%u>(%rv!YjF7v)EKLO+G}vv#KChoUN4c*E$1-J@j6T^v}^c8?(Px>sCx@OPGo$dJYN#tf;_01+upP;oaN9#|R)=>fj9vb2K}=S3&tZj@gxwYASeWMH0pWJlhR@svJ?J$r$dc~7e9ex8s8->K``#A{%*SN<3mdI!?CH_IRAA^V8%iYV!AFOr6Y(LFe$bEGpAk}4y<7!u0wilA%$!$pue#D^vU-<y}_4pG;i#fz?u0Uj<dtb`)4_(m9hR+=M<|01PQUR<16HIxVy@zXG%tkhI!>Z@5)U#w_3x-~C(pQDXww3*GZF|FucdQ66J5nFBNxg#FQC!#3zNEStnPe8{|{`B)lfM3fB|BdQuR4DBod+Nejd_7V<HV19w%5}p9`6|bn55J|bcxco$3QLC4J@i#BYetFma%No-Rxq3TsnPM}`B6su_+|L26|T0zx2^EJ72flcd3WqIh?TD`D|*olRcOM;-k`9eSz2VDXr_y>lG$E_mCYd{tZIJojtsLIGF&Orlg)QTSlv7;!kXqi5!Nz;#bu<LNg_-)+l#Qaxj=+<%{3ydXYLbWee;3{Uo`&^VFQ!w#aFqJSwe)3&87$oUd6>%3FbMz#jVcZRS|jK6Gk<e;iX6+840b03a|QtcwR$)Ux@QEvH|*j5Y8*g^C3Q*R}trt^)P5j%ANfXo&SMGJt<EPn%hLCA3%EE93JS2oQGLvQobD2^F`8Yijs@xE<@+NmvNRHpQkRJKfH(Z5_vk&`5TRKUNX-}!I=(D={(7FUILSr<T80%(E0ja;FP7;y|c)JQ;=RR?-V*8xg6(}qjpmnj&%p8YIb_WB7Yc<^dxz1U?!fNEYC*}KRx$+(S8%ZPCk0%BEKhoU3u;&em!|!qAJo~lIIsF->y05k)ERsao#Oz1)cW`;;dTFJg>o4L*D!z2}3bJtTr%*IA^mstG+Odj6L$=IP?LF!l{wS7_uAbK51sY8byT7QrO1|U$w&3R`|9Rp0~n#Rw#_JMyy%ckYO`~@#z>+rj!>wLhB!3!eW0Vp*4S?FwX32$Z#sL7vqkkR1~CF9qc%BfM6Fj*BCN<huHlwKTN44Nc$Y@qUK7$E@oaZWcYyCH+!NaRRrmlVk?ni=4l~P+{_Uu!;%R5bnZ8Zr6dbd)GeD`++?>Xj5lis%CIxB2ledBQmPA5EeAW^EGgI}%&~zoTuSW09l=f!q=6203A3$Wmo)bV%J5T!@gMBOrKStgDhIoyIbE<5%v*sn^k$<LJ`R^!N02^suoKLKf?djdE}IN15u3hfo>EVco;uj2%<l!ewAn114ErMN({*@%mXaYz#eTHerOg~aiXjAIAv6s0)hJ_5%_hT5l+E+|kWDAS@1X?cUPhw4C`8JdC$h=#7KtRmN>jQD<}xiJ8$nRU3z2eWV2})>5%%fbuRBZWA($r}#Vcp-5$y72a*zyLBaEj>M@lb2dgx%6H?N6{p~l}=qk=g&h+>zm*aDJ#vK}|2uMnv4lPVgWf%vUO%=Z(870tatGCW5G?B8z~OPMM7{eH@1h84|bLL|}rJxGRO!N}_dp8S;Ag0%c6o1JLBD%h3GV!<-3MeK{&!ComyryT4`=03r$Y_<=U;c#MiKs%YTMvxvm*p<!ef?dU&7c9f=LN}U|l=XrX`?JliVn)zZqDEEoM6e8R5&L<}TvIj)(n~*Qy40#>H6c>X3^ZjJZH37Q)48W?Bn(N+P-;{+TbnW*Y=yH$Si{_6g~zP$TM?$1PpmL1M24kBSktU;h25=iq6ll5%dPOB6`mDgs(IH6Lqla)QiN${11s!ng|kGMZtk$cPp$B-2y2_6VKOXfg$+bl$Lwo`v#fB32<w`kTH#$Q3=OBSfmzZD>mZCjLTy5GQK5Tp+cn$3TydMihGv&=8IB`%QEC%f3etBDc0=<M!ER)}9xlUu#LiD`LTf<^zhko-nSTm)WAjY741Xr}m=P$+5<yCKup66kcPMOP`Xgjm1Y!J{Ent5rNCWO<GK(f=3n9|fOpB0V#|Ub426kg9Hw0;=BZH>qG{J6Wj*gJwV#;7a7i4f#kWM?;&CCOW-Q3(AA;Z(e9#<EaI#H0GIM~h2n}XfKycHosFDx>C**36;2~yF!HoJwH{Vs(q&F3Ozn2fM!#9LsealvYLH`BGYG;0W%R%ZK18PXrC=kjiSI<l08QfRSDNJ+LbhX~2m=B7v)o}k<o<QL7peDpKt*4o@DWL`3FManQRJ7oILM_tvIGXG?jdC9ykWZIZ<*=1N8Vf^l{$Y;JFmARKmq>Y*D9))eq9@%9$iL$vu!+_j!3fS?UO>b+~74&xIitI8xL^*VcMyb9Rq}dL3J9C6!w>Qsam*G89Uiu>_uPP@8?>Xr0&5eSdVFu-pVGP2efvXwyyn=qmLC-KR2zm#zdJY-3K^R{Gw3Ly8l<yat-NE$zLSaX9Xbu_9C3b2ylzg%v)p4*pnq>vMlesO243880YpRwpf;7y*?qqfp?9S$QIb`@36}${xXJt8I-r%5jHfIZZ7c+NG8J0y@G#g!KbxA+(pm#Cf6ZEcTgPbz#N%STQQ1T+u5(4hq^seR|LGNb1l2eB3h`x9Ww0k8z@qQ*N=w{}>PhofS!<;g_K{6F0k%dpn^wu&zNSW?tBO%kn42Y893kZvTy$<<=OPN)f^XXx}B4m1+wW4I$lVmt`JY}WKWtWT^aP%|}3c;7nSy3|FOoC;phM5!${MF9qW%ItE_cA|>lHpaN2T=_dlk|!XdM~r!uN3w+|BRAh-dvz}S&U*8mh@hVE`1NgX((j+n3Z$M@FkKN0R<^Jq|8b!V~v6On3IG|Uvp$G87@Q^zrPk_ewOW@qf~v(1A^Vp+?7j)rznT}Gf}FNGKZ%QdO!0fVqfyXeOO{mBXIR^jQPVia8@&$A+q<6p3PXzAQ1`hUo3%0u!scuqcKscX^M#Hf3yThh=_#y=d3~`R77(4FRVc%Ohj_~CzeDcTtxEwX;Vhc2oWjh{|i%_nmJ6Wr#OFI%qVN-45Qh2DHaldLZ#4*aX(J#h=1j>(B1hstF<z81Cm0|9L8XLm7F|&)fVZih2JA|FL5?V&KJblAvs?YXQ$v~tZ0q&Na<*a9*LP%cxs=(e!nxe-ug~-YX6|hhz|c@E+WGZLJc48$GM03ld1q7Y~=o(Dk?`W&Qga<_o4p_7+~t?Y_g*M*onw^5iwcla!gZFClw2ZP;~xTR9!v7*COJNL?`QiIh<y3%%5*8XZ~J!T0SHv;b#8pcsv(8?agpX@E`BWS=w&j+=s->wFHqp5mZ;X{jC!b*(-Du^v^=Sl(zRdip2SEWAd4HFuc!WRH^@XDMStlTB3hIS;)K<F#||-e+Se_+S?KDB2wF50t2J8cXBTJhp|Tfk4_@;Ug+;YTKT)7z-b>uy#b_y|JE2NIGTG6B0c<pXv5Mz%(V%T{{DAb0yz=N{zT3BgK&LmCnN5m)Z_g(KSAVUp>3)^8s?vND)LQ4=J+e2ZB6?m@)jaX{O`<0<g*+*ply}^SB%EfzQ|4nu*rXa0c6gJ%iiT5=m&Bs@&(8o^cO^KX<vopeZ<)N{&Seer(KOGgtQa>47$?q#AToH(-)o7ZbsAxa>>69^_%v6WGh6z^%p*X$d7scK&H3+)2<=%QyvbR`^A6gLqvYg(*lu4si%UW?Y6i@jHiYi2XrUwJ-T5$bw38&X?G*LKwmgdJ&uWd+P%pBh~?&~zhKgn_KUnnJhf;cVE02u1B>IS*Xb_(8ny?qQatqxp4_zGLZ%{?$Wy<49?aiE8`6E^saH1udmyf|HnhM})BX^-H{z*3^ab;wh_&LWiS!}IM<UjNr<QvavBx6TgQu27x0m*(i1p{GZ6_i2MA*o1o;ocSTK<ltXJ9;^$6F2t$hbhKB7PAwZ47#H<b6snft<(pjRQS^KQ{!G1CtC7B%_Yp=z)p$_Kw1Ni`@PJ;YZ)Z;78f8e_&`kVZ$ZSmiY&XDhX$i$H4Iq_Vxr6IT*t;|IDb(4{6G^6UXXQR{C)|AdxhL(0Sxj)P?`GsPlsRmEzu0TqzJ)WhFA674<~0_#=x&^=Pv!YDWwj{j<Z0JR)lRBg>&)<&h@T?+n76sB}SikqC4NZEeCs+GjgAXAeQ>t1_FYGZPPc<dZrm()`d_g0(>9v)#qA6#m@~)P<pk1og0@UdpQU4?jlUi^FaR>Q9RL_ais!W(E{42@85mtnkMci=HIOB9}FbEP+SDzcj3rU{z48hMFa`N^0!qpuQ2_Mo>HAIG>ZrSZGO{`j>}~5a>98&UmZ~(|#EWvm)nWfi8b+Ro9z38|nmD<TgBo{*^iDK1YW3!TGANlS1M%Rj^ww2}^kg3{L#3!>H;aC!tsKugOVf6*(yh=WBDC^sEL(;#mCy)Hk&lmSA=Co&I$>O9(>QKdn;L|I=0HqPL73hlzuKz0{i#1F;SAeAFVGZ_G(X7kRD~IGbcShLVMCmgj3LfU_m%0+G$@DjRAFc*{(;cK<q1x8^)7sK*rbvZe~N3f)QyKP^blVd#`g$mlb9-hBnm&xrGk0W)x3$`eITQN{|g*2*#xed!CdC24Wtd!L{c=`^GpODh^I?qREbonB^X#bi_0s(07EEUmbFbp3Ow$B7q_-2TO>Xb?(flimBUnLrXm<OTomkw8iXe=7R=r_=zJj-YHx`JYl-RYpV-{ckS^QdUH&`^R4dQcjehHZEHDI$taXLV0g45F%R?!Fk27FP>19TzX;|!u=<z;>4M_N#TKSk-&57p)fJr`;=0$Jta$|rp#uu$UlDurE<<9f)fAKs^+?yCC<c3j@1@@h~O(;kf&vYSH<Wk@o#EBx<N^o@ROpU%Sl(!RYU^)8!)v`>n0-M{x2~CPU|irx&6Q2M5Kp^6!f>IUZAJwH{<-%YC`7au;mY_w$>*g(n~}V{lDb_t+$9&_op>Mq>t<!{OK5urS%m^BmcK0A=6K&ZsouI29W+D(!sw5Be1jqBGSX(8?AWSKoRNhAKe_ZK_W8T{|lOxw828#c>jmE4QWHfU76}{O5Mj$fz0urqOO0qkXhn?43keAAtI~%U(#J0DI%Nv4;up+B_g~0$MXXjEw1#S{}ARQX=4QPzJFn9M8=B934eh;pp6reGyc_;fs7ZCOa8udflLsQZ~ZYeD3~N7xBNd=MdTF``NiM1IwF%r<WcHhg%Oz|?+;IX4y{+(RB;XH#uI`On=bDVPhChI@C<p2IEzfi9Zs9+Z3H7|(I{<J_($V8J4bhXAoYZ^L#Ur%{wF^`#T@I7-zkL1+(_ym!u?eu5Sb?;xzQm(X1=J%g8u#(d894KN!>)8Kdk{G3k6cjpJzHEi^8eBPxL<=i^vk8y1M^mx<^Zew%RQ61j>^3y0_Nf)a|Cd5ngB>V>zMK&)b2v+$!4!Oia^OSY<0tm$NcE^*ZQ-qal#C%KNQUuqHhFa-5KYZHEA?6&1w%G(<{UCu_?;c`+jEMFa|RLLhB}x6nVd7M`{#d__EC(@DV{8a8dt@ew^?{t_5Yr)|mo@QGMIUj<IuR&S?&=vitZj`RqH2c8qhoFavkMAul#S;6$Ofm8s$KbEoda*<-O&_883XX)i5R^jFc`tPDaORo?iXC>JWB9bU*xuIt-jZjbYB9%``<%{)E+qHwkX>jMi^Af$wM~p66tL|L~v)Uo%1rsV;4WdY>`5nEqwN;mXomuTLYwR74>#rRyZy}T#&?DL)8W73$Vt;_$2DL?M!2>kh3*}yFiu)TFm}C^kWHW6d&pQfmMihFcv`I3OLUMa>@(O^0kI71T#74xg@Z5DOgwdDDU+0{S4zE+${FN@@D2AYQs$~B_Oebz^LZqsQ1QMs3iP<J=)vFY%Q$6y?O}ffnrCFUC;v9_Jb!wT3VE8L1K`=EJskXGF2`%Boscp8^oH`b#C1qRJ;%wnVI<q>7*|z}N!n^ey%IYK;pQ3cba)*MJVo*tk{Y+}p4Jy&FfY&j_t7lN&EQMChNL0-E!esm{70<=~A7$48A62pS=iXg53uLoP8f-eDCM1MT=uLV{=sltLmQaPz5fP+Uv4DtxqSC~IAeN^*D~P=UA}Y^<%6oSC{{NY|cW;XC`@a4C=I%LX&N*{t?vyig@12Qkg-mzt;X1?l;KN?fdnPeDqHZdB=?e0;M|hVTqFY4;FPZ>2T)|Y<&8OfA7&yB{D7ZChWH-Npqv7>*3n(~>Ix8vo-$<)lq=K(>0vx5_X>b&}MJsqWZf&<11xLWZZm|mfJp%N~3T}#yxmy(lPeMP|JyqW7i1#tC>|RaXcJAu&kST9_#Eou-=$;*UFVKhu;O~*4_z$8(?2#$q$oo;zdPY~K*B;pkzJ4!HOlSDuz7HvM6BWJpbR|^hA;2>vJfL3Apg?1^%R?^IAa~Bb@JRrQ(m%t1@n|enxy>X|lr$IkD++hTi=x+O8Y1USg&T3AC=q^p&IOGJMUjCaE$4lWSJ6Iy&i&<-&+i`2GXu2a@GM4)oCo~ROUL2eHb6cO3&4gH&u=Y&d=kOeDr$?!rZ6(+Q<n=-?NL+2i!Rk5nv$!YyXup`tKEzGl#<)u`zsKcX6^tzS8f1XatBuI=r+&=MD&>=M4xa~%&b~5Ze6u*iilfKTzz`Smvi%Wpx5s6RTVbjh~KvY{#wG3jj1g&@^Lho_RYZ9-;xJk_Ao>At)NPJ^n4-uMy8yHIT8KParKR?FX3INQvG5SPxS?muchEu7og9KRPYZN?*~LFxE2QW0nrNnWuy=Twf=ReY6De1A|i25231z@3VLo;RQ_o2zeDx~yfQa65H+}t;_iPCu&z+urT|tIDk2+<gX=1Iev%MF{0e?C3~(C-8|dtZv{mqQcmYG&DR|T;fO{zT=N|y~RPY-pxgot2JhP7>hU92|xH>~}6?|Vd=zUbB9&<p5q2*I<mvwb$MBpeqr@zYSyF1jcYt)@*!4;`%)YeCU#73|`tK!Lk`!KXhWs0PD9&QOFIl$7W&1ou#k;kEMXo~AGz!3+~Fox+&=Apq13n(}dh7PNw;K_pl>syqK;vc4O(X?hl4A-}1Yc$}B3jPhl>4=W13dNvVjL-$q628y~T@Y`fHyF`d>pzaMDne!c(R_?(k!rfbaj$dpgyV7~JcKbW;wyl8I>k-P&=k@nTy4mM$X;GXph}o7ro2p-DyA3F*7EB5lMoT`WIYNbD?)kfJ)u3Xo}5glh==8v74T9)B(>$$cfE@gtF?oV9>{AI7(~qpJn^-)dV|ixWBc;j$Po~uIr;M1y6S<g+PsT!D)YJrzNE~)_E6R%x_TJLi!J?u^ps0|wLNPwEz9er*8MyiF*fJ*j!=tKKSct`2|Nh{+Iqe~gUriKpt3HW#Sa4M6X1+B$CKR|NZ*R|dk1-9nbCgXoTcU?BQzwEhUE2kjR73d39fs-uJMhbIDdqKzuyLWo`RRxHpEEX=4POHN9xwn@vtFA#m3Rnh^z{Lb(cPHnGmDH75yTN8Lfwp+a3cPD`f-Txfnm>RAP<Sa89!$zCvEc=pLa@2O-9)YIx9SewQI;7~=wgd&}$FIj)lK)B0dGH!d=o5mh`v<aJzB)Xj8Obk_tR(Q=+v+p`rN$+#Ga)bo7512M4@$@a{?0;IBR4{bd+{XpU+(#6v+2S|ciRq_nXg@VKi9FGQhe%%BlNg{(iyW_xCRV^@i&K4r3nye5LJcH5x$E8VRif8N+An6jB;d!qBNFAwQmS-Yn!Q(OlBQc$s*YP6^z~eIgU%-M1av90XF7$3gj4v-IrV%UBgczTo3TYAA-uOfXe~eo-LA9BPojxHZdKG*e9o5A03ck_Z5EE5viTq`Y5R)oLyK(nEG4f^=!r`CX(EB__7|(}rpC>n|G$NcebTw-A<fanwdgh>?o}3*VL-)_q0(WI{b6xbY`Cx0Ir@O;G2hvhzuexV}3rK5;)bPAE88U4pTWz^!Jh`JpGCTnyog`Av(`giBx<q~mYqCAuuX=J<iL~{+y$fvJWNCNtj7EMYch`4lNDxRbwe08Ff`&P{x4tQFp_nG;s6{`|b_^qv`^WY{7G`+fm<VKW<w-y`c$Q!eJ$a~P+u^wlqv+(}(wyC%C&z*<PsSYZyn}i*IbW{B9`>AoQIkhWwkJKkFg{EkE!oa^ZeW%*d0{vgg3fyCRYy#b>>AE_qEdh?mNM^qUL6XyrBddiXKW^7mPzC*&sSdqSs{_@o*FL!St<MTUp_S^juDe@mk94<vo^Ss!RR+&%4bI2#6r{>`U{cs9)Rj7|J91DN8eP`{&<COtI_esskcex{Jq-lj%YTMs|R|3!!w+vSx2TWJlk2Cb>ifbhvyxZW}TX{d-Oc!1(KOS5zZ>8JaY67h-SG62fVCb0a>jA-aeA@3zCia9BECdscK~bI-Dsj6kPQ^z%3PgwJUg9EBFkCz$pV2+zyRr${+>rP6E$h1s5F!JVe#*A9`><-I$qZJ&_wQqID_n|4ycUBV3n*&u2Inur?^aKq{JqA*YKTw|~cQ*+mamDVR@n(ZkhFw1h5txO%NM=z0u)996Q59>dq6=6C6<;4bK4yNuUH!!ezzd(t>e%ckmHIDoc4Rr?)rQ-zootKJkG8EJ^=dMG`LwmHM6;P6_8n0Zb0w$mybqM*GRV$Y&27IaW>wPyh9q4({6fIBOA^eMny6ufLaWV<T(^E}YIDY)fc(0eHO7WgIwJr$gYp1q)#f}`I7+*`p*VgctUcop1*f?NgfsR()>1-JhIa6bk2fKOB~K*2jvSqla#_!8Q9!5{_m@om9i1+O^-c!+{WU_>bxs^AZ(bC`m^=nr^=f`=~zoUh<h>i~~b@UHF9KT5&P=Kvn9;BPR(6^v1E1$a{hV->uxA?V{2oCQCzV7!9=xgPKYtrK(ff{6-#3-zmDl7c(01kYpz*TCebV2Xmj9S-_b1*6rAf@uo=@g(4xy4*11C@4@cUo0*tRPZs>pMqHmJ{b=^vo%}@`WyxKX$*L-f**Ml@H_=qd=c<`1$!~96x^!q><;<@ofd|~f`z&qFgYwJQt%(|0$!xx7h6Miv4ZE*&J_v{gL_x7QkMxPW(8~XeOw55t%AoS1HMziN2>x}r{Le-fb4n=^FD4+@Nu|81sfIo^Gd**6g=q`z?-#xw2^`>x}H=6yj9nE41a~%K^%Jtux>l|q8$}#*LDTUcGi!w9Yy-!D9nzIkFUgL#@WZ=*_8v2jfP;Pc0FcS(GK^H_l1}pEU%VVnyx`iTzU1-cjO~L;>)Xtz8U?1B$QVVeLuV(NTMDle;fh@NqSZIPK+0`ll92>9)^h7DcW6m9aV02Rqd{L(Q(dBl}KC9$=yJz>A|o)TFUI|dN6z+UBK)bdN3^C3~Y7eN^-vE74(?1GxT6MZVcEm)dMik9yH(CbtN*-^8@;~+4bazwZzl#4j}bq%<Z1(Q9v5Ym<^scABRl4Xco>6&yV*ZrhTRPKz4gB!eN@-LFVUxr-+%mC5qF`L+E8U%f8l+GLAfgqMhB*l~Rdr4(3j?XUTi=upF2o5>a+@o{l;g$*y}lu5H;Np5=anay3a_<T6#nAXM5pCu820tdHRuF%`3pIj0h4pvRBce^iLMW2G}%?E*Zdz`Qx$xG25UHE*t3>hiq57s$LyoEv!2twh5iyEVCH6gB=xjrSHIevz7CtV0E=GVeC;R9nj`ttFlh5O0qwh@!{D!|&#;R+U8fvZXFg-6N*JrJuLH`U***l89ad3^6}URmlYgVC}&*KPbd}<-xUI1JTn__C($HC<Ox;mu~f?kS>=6K65a<NruL=4RLE+RnjA#N(3A);fuxtF9?yg93{7)wPC!0Nq;cf`tU4m40_}R@0xy+>ygY0Y+Yp{ay-W7g-Z<iy~jXC*0DY~P;6;u;HECPqNEGS!0#V)TqI^53w~4I-mGVw{DMNoRe(pfpp}Yy*h*Df^d*Xa;b8TG)mb}^!qY^B8<=k`SYn3%tG4=L=j##-X=9n6_mo8<#>&qD<3wYAl&9!vM=>-k=xWHv8d+qrzhyCqBKurPN*j&Y$%5L3pAkc2jFR8IDBiSFaE=yK*I%)at3au^N);=fMrJ-#Dcx(UkdQMu>P&l%h53at@k~td!aP_PasN_r?^$sojVDhmOjKp{tF2yY)&=%q4P<qd8GauB<cf>6?u0I|OM{@<bV<!k7)d~<dX=|gic&u?)>+a9Q5fEyzUE6HEO^`uKlQn~Da*=WO`A<qTPR%zVoRB-xGJ267q{RUGyL&~l&aT@nX6TGMd!9~oKp35Y_Vi23~2`iPnqGl?UaJ@m5ZD4V++VWscuL*<Lu9N)V;_Ujb3o!f24ICD_dq#fylTUquYW>@<!)ZcG@K}mSPZDuv|thC=vA;x{!rCq@Hah6fT<&sgtsP9VsrARuf(Og7z*M_g>}F#YGy*pYJkdd~qvyKb5RMS!zVuV9c2phN;FIUB#KO{t#>&W?T!VN}C&1DOSuXz5{ywh0jW{er3p~ZC{Iw{h^BT)+$y}O2}EaDUopp2KNQeN)vZgDW20Kw<Bu4AwTna!j5~pBJWns)rebU$j_QC6pzdJ>LTJks6?xNDsG;V<%f0)4jJ+dsOX?mR(CYpHlXy681nP5#$_;M?8H#HV3jnwf3S=KsEeuOf?HHQoD$ScN2Coy55K@v9m1W#G79#I5h%D?Qr#nE=*_6hI(myFzg|}S&gQr=OC|YRJHGy9+pe$JZ2Ky^%Eg5`PybfrXN4K=*{a$`)lghkK_QIZlgK|(+FDVnqfycKRpuX4%Zqa+E3#^=M)W@t`A4Beam8-2ihiLo|0r}%T(M@5_1Y{%Kb*)v5}qlMwv0YlnST`es6^VIW1_g=Tq6G{^jnFvW%L`B`A4B(eDSpZF$&6mP2?X5t>T?&tMXJlKUd}-B}c}WQRcUyl`mLg$gk{*;)~bfZH#-$kRSKm8(&6EJb4v1o-yRteb1J`5b$Ql@w!xAdnTYl%WFePiPrSB3A}m}d0mmnul2%~>@h@VGtgr!zvv81Swt`7X+&KzzQFZ1<7dqBYiC!?OfbX)M(yTRn)Cd~YE95}=NC2f7Q%_}EPKchMNP}gw^BT>!WAvbmWbEmUyrP|mPo);s~(VBBvQrmHO7>pjuJ`nETV!=<<*N2FH=EhiPZB{q=GII$@Xme5J*>vwDpWdLn`VfkuIM8a3qVmd%3if;~7k(heUEc>#qUnC6PX!AuAx0BayzICYZ<;^^r(FPc6)biuy^Uzh~b*unm>S08eN5%tgZ_GSIVz+VZ?=@oxaNjr6L;zXsGcS|UR{+%UOltVD)-_E6gti45~}pth+J87?yVV2)jMtDM`fOSINtr0;my=;i}wQS7cn-Vm04!MhmK68~-bjwfobS7gjSCq&{qvKx8Drlz?tHAwtfxlWft<kx$H{Hr4W64G($CUktL-Uv;ynfFD5`i1JDYS`ooOQwVTxf#AQLG=$Ettf*KEZqq><GWKrMBS8~{p2L8*O!@7TArB?Ert=1gyJM+O_JqcsqdD>M#v|qVdDtnN_;S^v}C^oEp8*?!W2VldAFDrosY%Mk?BJ!(?8qB##si53V*%LjGE!!7OEUoPPUi`AxHb@cpZgvm3YLIBSoWRyObVeDP2{i)ZHe3Zagtg9s*6WtKhy)U<z~jrX(BIr@VJO2+}4gwk$+7mc!O9l6p^au@WiRiJ5-l3DbAjPNX0g-g;s^!*|v;ST?}4ht`7LNZIsVu{d=LWM|ZD8AjX0!x7(2Q)QR&Tw|ntQdY(26vNWB2R>HfVpV$eQVi!!jLhncUc9FIM04RrLoBWr*CmCO^*ZzNQH~)N-6sVnrr0iH3P<IqjtH^1sq`jS*ikKI)JaA)iX?JZid`<BP}i<Xls;@z1Kx+L^O|2x2;T{iqrDGG0<XT8C4q4PFTbmbme+vyFGgOGW){>Wnb&}q2R-?Im*jj*8+@Ls6hABDcoLMavLrAr;Jpnc=&LOW)zf63D^;&a=XFsX+1pCWuM(b9msi382?xACNXoSOy#635gack4PvBcB74y7_fV}!PNrGHY@ct<?&fWTb2PN6vfaF4{>J|y-$}0~Di1r?OPA+BgEB*Ju-cW+k-fE3_B^>bboNnL0rLKs^94<&`=rtRYg;y9y`6{U_oMue{R!b%K2+2K7D)eQOkK0iA+RDfmvq^5zjMvQ_$jHcOc@0R4kGm)~^kzzyxNMFzt?Of+?5)T>rEfF%o}0IP#UHC-hW#c6n-p(~cLk6u#yr#!w>K}`^#U{unl)W`^L?@@3m-R_tV?chYPlY548apJzeI3du3?Rn9X4enx_bE<Bh_T*CZfw#(=4LytRvjVq{6-~m;r;DR?R7_HGB@I*qc`Ki~k7m*FYiKfv2;r;R~a1^l0JjRjtEfL=DC?pc)?pS<zdJylKKaLOm#Stujuc*?C9R;)WkympEjsS%W#Yw_?0!_}z#IkCi(VdRp~Ev@iO$DHu7g8lwvfgg2tx5WgW#LGkNU-pM+Jz<7$uEcgPGjiGl7@hKv|wiwhlU*$WhjX06oqiDQ2krCdy1R?|FiqKsIQ2epnEqx5nLQ*l6%KdR3b0JV0TQRCE>Sj+xbX0{&sAydgHM&@|Ay1vQA<^Np6mSPCRPd=?OfV%DOYNjO^x12O$f}i3WC+3I(03x{K08(xTx4~-;Bv`aqcR!2t}U|ABWnilLdNR3SjV{kxQ|sS+RF{)177aH?c**k0ZH(EE#pWHc#n1D0Z5WSFyQ4T-M)%7Na)&$HI#&C?`jEelUMEw9__9CPqLrkM&ZqCutF1z_D<-+E8&25K49NKsjEp>HU$zIdegg-g;%6cdG5{<@Qy@H@U4{Gw@L0}QeopB<YP7Q-7h1*=|S@7p1fWgNJd6R%WFVVe6LD_`b(DfQl7=*yR6a~OS0fNCE<p$D5AYD$adaJ(m$40!U6A&4ziDvJS}+^ke78oAg{j0HEEI}aL-#`CrRM;!T~QUn~(eP1SG*XO2+M%>8RAW8?0}>BtJBs2?XW!n!NrjuiSt(+M95W3SZ!kv<GT3a|ENklP5~cC&*<Iz`lP-T>~c3OcEM;yG<esuL17~%6}ydS~`W~2PNYPsjL4~*~L%c{jWtW;nPT7B(Hnsk?}Su#A`rPX2{r4Qk0#PkF71><*69HT&X2neqzmYReYl)fpM@_W{bPt2K1F1kw$yB$g6_ime))2%56`hy^p*_&PNt7X<lLVLP=jBD~W`w70EiWkk`sZvZ@v_cDLl|wO9@tl4rNn5Ew!_JFIB$%R_i=Hk8+4vTi6kuK`V|BV!Y#RNuwCc3Q$KH}v#zJJ4t^_f8GyEBC<k4U=U5QfcuLUVBS;*iy1^<3`_N$-+G{173O-KJH@~kObc@8P`M(fvx0l*h<3OB+>Vzj6A!H<Oq57F6T97Ia$u)>ieiRtISzRSh@m)Z=_87m2#G}g5-LDeXcZ;8?ThFNK-I6jW)c3uEv)v<2Ff=r=_NAJjJky<X~syYbQC9SIHW@fqW!K%WJ^P@yy2#?GdB4agQ0efqCDjK(`t*1n>mDZ~&x`NFDk)-mS(oB5h9bb)MWh&<m`WeAO~{GT-mN*G%A<SSh)aXG*Lgv8uTz8yUnp5la;*|5+l@oasoc`Qn9K>~ckN9lyM5&{jEmisnNf1<xRhoMVxjl04WVcd^JFALOoC7P+lOma9}lEpoO+zVaB79A=U0X>$6j%fLNck<%}5AMp`tZ;tfM+~qS*BSG$<obQTZw$mpz05Z}QO{6_9FQwZrbfwQ_*2cJ^Po%Sq1IBNzz@zsXf^UN4R#}I*-(B*x5Ru!a8`S*aQXi+`)+~;MmvI=p#-A?N1+Zk#n8Ej*|8jY|*Maog_ao}2;upDFxX-e1tMA-$H@8Nd;jT(X>MDo-=5I1Nm%BzJk56=^SS4|avyicFnX&S&1dHrtDUY+rRV;E0$>S|@v_(!Od4fd_SmYJlGi;(ejy0^j%d5%g_}^pwuOmC24@ltNjy~?v7mx(s&oYkGfY-AL1n!U)Ex~}7+duk(l5qDXIrhox$MX8MymH6MXz#01_v74xvP%XV8^LJr@GZO&hBFD+H&*ImO=>6!4ZSV5%7JAoSq@PC_6*uqxE<hT$-P5zACL+=?;s!dZu1?Mk$>$VdG=0T&+R26BctUtASu2Nq(S2)OFytTKgJ@Q<W46~dDrzVx(M&<g}XM{9nbb!-gQQk^V~d(W11@PFO8&3Lriy<L$%lO=_?=Lvc6kZ<o0ZHLo;=y^a@{hz|GIh1V^DeiV@{qhYNIiU!V&$W?AIj7TL}1f@fRg4Vo-9KW=F*Cw%*;`C}d`KgS*Qxa3{#<h^9^Mhf3~@(!RkHrE|>N%GFHl553%7w5Tk^W1F}#!7B4Ki?wnu*k19qDyCyH(2BWdq7@bk#D!ie{`19SWRA{$?f^t-jcd@%Wd9m64H9z9X+EiEz7sq_<G%bi_H|x!`KYpaR;|cwk4Z&BH7#^{bP4L-)JlE5}Mqeed`x>?ec2=US-(wn>+CxDJ?cx4dk7@a+r94*Y_Tf)3$xQ5^gBl#enc}6$0(hNA%C)`+key)mPN-`~8gB{J3!a$!pGRAU@rzM0S9{xCmED7I&|}WoDMPB}znIY7fr3F8N~D`7PjUsNaiwaGqRAnJ-^%e3gg#X0ehB>A3O458s25z&K1;KL+6mNr;e*hWl&!&PoE~0$y&v>H9zuew0m~8@T$eNdn^nULGpq`&|;QNEeyM()f4=NwkcEXF%5_Q4(Uy$yp^G?7EV`xUY<b$A#cJ&7ylFgt#|>P}X=u#BrnEuZ_u%8KV9vA(r4b@0t-nN7V}G&6_tDFS-dWcLS;UsBr=G&jB_v9yQ*FKbd}7h+Co-Ek$w81lV@b&#3FW0WJQQ@%akO?oLY`{4M^*=md{hbXWIuoB9*R-8C>0#_{6TQ9@jVYU8eo#$!f34wK&+t?+mAX8aw~O`8j&!5|@fh?|(0nmZ6>YVo+I9DJtaGp`t7=F1@01F0@~?p+*8(WQ72!E*@Y5g-jiNc0wkc-#*AwB}_|?=$IGaIFP?2SUP-aUqd%r9>j`sBTUG$J2nHl$1st$A<*MM9v_o*X#@GSD;+gg7H%pnxccPZOI_j3%=A4>EDVdJ{jW!zqnlvK11?_%`(HxgCO6+j}^#M4Yj$0T|AP<1W$dCc?K`{w2aN26yk9?Qr3okYQ(;cao)@W+ivi4$FGFk{vjE6DH-NH4;);&dd-mcDb<mPN1Pj^6r1%x{sSDpA;i~R8p=?ZNP&+VcFM@&H_~QHM5W`V*EV_Tm4nZ#_%7Eq{{`wGL=QkPKXW4Q0$BuLp{zA=OlF*2ZuvSHnZzNJ-!|wZ#@XeT??~c9M89t(VIxceg(v>9DyC>`S@`}2Q~U>csATj<XWBy%D;fPlBi&)c$Q9d+Z4Lp+yu`_T#>p(icZR_uIJ={@M4jR`+h{}V>7stQC4`7z;X#<Sxsee%W-{u5r-Z05*NElGZ&BAe7(~(~61G#uH05R$=?8J2D=aahtE524&!gq`K#l8RTq>SoZRW8^!KM#Ezo)TL^1yrQlSf-qmr8QAQ8|?4YNL86$<;<ZnWR4gG3$&-uGxv;yodNe9jZ&8Qx|pjw?b6>(bb9l9o-rXj=_C2Wthb;Pr9LW)FJq#6>1rE<wmr@H^}uQxjbQttN3~BoDC~`Z<r~Ju9BC>R~gJKIaXBJE@Rs8WSc(e7ux~*kC~#z&0xgC+{D>wfi$#26(d0<-hd1>n;4;!$n5jn!Wvdr=d49F-iwLJYF83hNTR~gbpWX&k$<j|NE><7n*ZgELUe*IGY6NMdHw6l+Y6w91msQPAS05P;@6lB7UF+?napk~62WP-@4hBRXjfZ#YN%a=au<`}c5-=}>LM)rNPAU;H_a4At0KJVEW(>+8y*RpUh`?5#O|uZ<y2jsrpqeN_n6Rtrll$u?|O;Kb;77Zs;XQkj2aS=mFt92UzuIy5VXy0sxv1Ucz5a@G7@Ap3brJ}i%s?6@Bgi8q`Cs3s*&nS4&^J=mBp$d{BOP?#9Pqi`nIWVFg<GW`v*vr8y6Qk^eDKHsrJh@)B*N#b7P*aE&;nvFje0HS2bA;m`5NjB*HxU4!SCbD#$@sCM!sK%s#LkcU6%`*#)0tGPARd&>qTm-INS|9%Z;3@vb|wwZY#@L7oWc+LtYJJ5soRHEPzD)h`d#?-==CvG`fpz%)Yyij0P<_c3!{FjaRmS>fx;ZS3W_h2KD=Cr=w-fy@xDZZVtytu|cUsv44vHl6Yi@7W`ePj99h45J`0OH}HXO{Kzr7Vc9vAXocl+K4x}b+w<{hUbtz#G;=fJz9EXL2gg&+TP44V+ZP}k@w1ts@qa9Dz^fVwXSAzN9te;8uPp}Gy4tZ#+irjnFkTfO#*9bb3@fvKDUr{iVrtb4aznAq^kOwYa~cS*4JF4HrZ0Dw?Ir^qs8rTVfu8EHLaf!S*|%tC%A{*`lRMY=(r8LTjzlxcDF7Ot6S#+PKj=v2Yk$f8rQPsx}5g#G>u?Bv-)OpBh<|Pu8E^5gqnECrXWv!4(_J1s20ZGHs13_M5yteH{wH$_q<U{HQtX>p`%+1-8hQ1P1QK+o0)c#1kzG=Awiz(<(l5Ys=OzSlnoXWkgPv=_?4e0ixq*#wW@_KgbA{@evfuvYVm()nWtS<LoM^Pt68XJKI@7JwajN-byU|q25s$ordXk+PVqwZQ0EXjeAGV#Zgds!xKb^~HB=D1ZvZ=umO5YNx1O|*+2q&5*EfIk`1iomPd|lG#k`>q5lna#66;!)Y>9I~>1meT5>4F_e@A5t_NM&tmb%87j+RKJB3Quqx2<^UM|^>(loc!01aD`HXw*tq0wy9W0Rg*3NW^Lp60uqY5xYh3K!#9@sN9NH`gs&Xdw{ONt#nCU&(e3g;!syrd0;~DSsL+_Wds|3X(LFrjgUy0MsQpIkP&w)BX~f=%QWJ=(+J_`&ikK{{&g#7Hx(Rw0QNL#t!o&kh_Z$;p{BB8^{7c=Q(3Qiw3e`}Rz2m>Fk@vG-&@`?;a~JVCTP&*%4@9?xl|`qsY2(r1YPVr_O>=ciIr$e@n+^Xb*#1&uiBCtP7+O>7>{>3!o*HmiTz1>a4W09rPjJ@Wk+VDR&{s~q=?{Ya<yzzYG5y;qlDKO>L}qghB``kjbtm~HQuD^;cXlS*yEf^yV_%5SY$Csbru5=K2<^&80<{8hb%UEh7*PCjBJqo<P36^Yg;NKjFlN7U}t25-8Ca48|<zb8IfIc@r)dy>Y8mG2H1AWwEZ2>cQ-=3t9M&{3s%++-S5y5Pr=L7w6CpW4j{cwyASu>?F!1ySXQ&UU9!tn-Pb*?iqZ>wn!egw_api~SEX<c9YKBq=6b2E!&kKJQ(g9QcG-b;x|)?ehNxQpT{>f><-YHlkpb{L;rrgN1`uC0XzE<1CcE>u2O+!j_xC#^ME`bd5bbmU?U3pk)3Dv`bgScFW9wD+jIK$dYIUPqOIVi1m^hWQ_RRW~c7Hz@<(TzCgHevzMmC^<e0bmARJYgfo&tx7#+7fcjr-1$F#8$uP$l92d4dp?5pPztm>%WGlth^V_{t6NpN-%qlL+$MN>@&MhpV<t`l391dOXOkqV`5;#^D@yW{7gz{mN1FVAAP&uD!0d=JQ6<FWq(B0FosUmIjbE65-HhzF<_jn-Av`W!>PZ(ypuR9m8&F4acy%i|0%GlQE6GL970<GIw5%ZR^=7cJH8XkL;dGc8U_#ouY*Qu2T%o;;ow5!3Z6OBM&;Vo3Y}$hg`39DAkP17^cvSL&FrBacG!AGbU1^8GlOE-#QJjn~6&MuBu?Dc#F=ZJnP54h@g1{vF#blO<GAq+nKKPMCU<IRig^2DnnJ3JtEkMV)xuqDnn%qdB{*`$U}xgLtfb#nhn*)%eNS194}-~%a!f-lk<mL%5<|WP7Y}z_$JM5-SO|o!NOXhaj>vWXdIjsFK@YQTDNHfc|4eFbVo<!tC!)ZeBW`UIaux}n6@!R>r}0%t|KrHu4-oRP_U>L$TN@@@|ZALsT+EG(GSX^;4>X{XPR#NL8AlmFfo7X79n0iwCiF=U8{R3o_WHYRC}=Gd4DTfJEF~Uoixw749k^EHPY`TQxfIV2MQ4jo~j6LO1OXS$lKe8MvU$B_aitupwI|jb_c}M>I$L4T-M3qE~xYAlBoN~Q9^9S|Gi9{obH94m^hDHbDikq=w+Hn5AQT9^4m_M4ErMd$KfzsMx^V{PQ|?wbUkz9LTAJUS1@ngJO5vN15Eluz5yovA>RO#el^<vgW9HaE;-tB(l1B*;MZh$x^!}7jNnKvG=d|!&<Kv?ls}MujHljpE;(p3ImN(Z4_%^*qjJ7k+fg~=mh;x|49W=bn2B8+BfC0vGKs=Jz9mFm{5L~zlha+f3k!KZ2K~-}T%)=acL`)6ht6;e_M)BZx;W;KwP{a<Pos}2fl+{~AC-PaA%;=Dh2=Wg#Rz#0Qv0f^q0vJPjr_*N71LF>WI0sZV>ahZd_T^fGliTE%$Y(?2j)x?vF1#4K7{|*XN9N+#je&}jbf=wcPI6X?e3hU2|K#}SHDA<AdEU8w?P=q$x=mn9>VA*m#1WtiLko9->LcIGBw-HE~K!`W*0os06K1Tb+n$BWcJEo5^8os_7b}lUoVokE_CFzKMOgnL&i?sjFNX@Zd?&}gJogB?PGf!)6L<f81@CjJe{Cr-5hx_?28Cy9_ReO+uyrLg|$L1Qem5ri!>{qJjFU>|E-Aq1iH){mc`ZT$^1{`VRGrUxsaU1#M(?SM7i#U2q3sA;l9eFQiA7MX0^NP1sS(#c93NjWQ%o8?Ov82R(!$Ex7BPAa>%xt?c|od^001yPdH)=pu@GPdnre3jFF-ovBxF~u^aK`35)4fb$8HXudH!SI%SmKH5(H^{J+H<P{4h#J1u>BF4w_&IOgkZYyJ26diTzdXwbvquc-?2y%DE<sToA7tHrxnuL{u?%&u-dw0)6sd43L^xz#-^XYLInKIF{3VPu4yxi^fKA!qJQBj#?oPI0B15ZkHtQA_QT8YP|7X!(RP$OGM6|LS3saYmb3Q~Si#hFa8`+NZ8;d1jlxe{UgvWeTpII)wu=<$eQ%sMM1Sdp#Y_p-TA!Pg3QcvOEfjWXV@iPVRu=pL!x|^yK||@Sj5DK++s<i5t!;=aE&8s<$+SLxTV12yRNa2lr(9VP}On$n;<7>9_@Q$%N#d#7cV58!9o|tBrCS5{;WR<buFm@VwurnxA?aCE4f3ef1LT;%biw?qyZ3*~<tWHf#GMJm1##N92jO+8_B8j&ksI3ijxwd-8wQ4*4VUTwJ*g+Ym&%X7;kiT{Ym$!<{m!UzMZMbt*aC>+fCe!dfAhyRc2j<u1$rs`)sSh4=oyIMWzWL(Vit)Q~fc5mkAz<EbsPcS--5BdTIpLx#b<9saX4*|j)X!c^^A+)R0-kCAtOY18OXO4Fn(ZJ9=@ZJI<Z)0DRB)OOY~O)^-fNw?O|gIC{0y!mZ!UG|@4IclLiaW#nw_$2u+{Fl$cU8aQlv);^G^a-ReG^Z@T*j{GSGhm~RZ7z@wwz<9rs*KfHxBmZZ6JjD1x|ZY=cRiicPM-L=4)Nwbi|LfpZh6#a5*0*F6XFE^pQGKBaBt6%>sqw?`<znVb()zL@~+d&Y-LkBxXgdjrsUjGE^|R@9^kQjOk~c9<%>(g|0bGxCRoi|EdCR=`~00z{iJlCscT4#A^PJ#AHhutcavNucn|#VX@FewECoBI2fK)7pUN%Etu9gA7*9g}wKblo+_b^;=2a@coLj1d?eSy}vV5Ic@buA4lQTl&$qbnT%2&h0s4`em5!@7T|0;9P97S3WG_#W>pKQrT+?gs*JWis_W^|(i@jr_46mU1|!<-(uA35F9$1xsV%lPl((P@^=nLZ_Z1~fCfXFxMkO_B#QyMDB^yWcTV^$ctVku08rtUTU#jMi#8cA46n^!@wiCFhNZkgI>*h!45?=Z#v*)ek-a9k*IK%JAQzBjmqBN63GN4&|QbP{&<;i~GfL75hOM|G;gCKiXH{&#(-$vbvw`K|ces>%G4Ee#E6&OfjZzRwvLEe}Q=O4~yx?+PaLwE*WV*OZT1%o`ARD>xU==HznNP_2pf^AHzZxXl83%!e;)Ux-hBfG{=SUQUj$L#0xP9|D&CZZpyl|`%zUZsG3PttNIxs4ORt`r>!SZ_}o<?cHn<6MJeFEwVzz)#YDw*vY*2xdq)m8UDpfoPmo>TTY5XES;I|%JB4O&)qI8so8_*=PlzBh6y@?KWy1P9hA8wROru$UM>W!OB~^`hG`n4m)Wqp$XzC0BSFWY0Jil1*PkD!XtRc4(`#a`EB8hAVTBCIE&jVZCWa8V8FY?s}dNil{8)Y2vYI`&kvOOAk<f}iUJ=#BQ_`^zTdaA>7`9AyaJeNPSnT5OIyQdC-c!vRw*_L!XNbV_DL`%5+8!FK{<#@<=xc3dY?&VZryN_q8I^0L;?)$I2AjD!Ox@~~<1gw_z@MN^BDi6~Y!B3HK*M|cf3xnsHIu-^cVl50x#9A0^o@y@)R;MR_bAV&|tF2Mf-vJHCRLDj+WZ-|Dz=h5EK{#e|i;S$$#A}h!Iy948Y(%q2<O;S3K1bE}{dd)N4<FKK_3&yYS`L|e1Ug*Yw@{W=QfjFletaV#-a@?jmBsXX)ld&F_}Nbq<+~b&_!a-|K?oFZe>9Mm&TY>gagd{jzBTo~_t3_ZkQg<n)SUh$$DIBpHKz}@;7ak9L5`-SpNp!db!xn$X{m>#QJ8$*4*~PYAjkaF$dywcYFdUG`aJ$$XGX~Bet3}VDda78CKalHNUCxJM^f_s`&;qjyTM2*VX$L{YpiAACsEU1+YFJ3xNHPBIo+{?nN%7}V9a30e9#)BB&^3MHUI5N-VK9|5))hSN?7x%+3-yAULIW5Y`8?Nfg5H&$)+1-Kgp&WW<N<0{#`9F{zIYbx51810$m~K-XWkz4k<=&&{&8R($g(^8tK9K=U`d8A-ZDuM>aez)gOCZh~8u$Y_T7b&mq6SOl>?!<|2!}%jwwdmW~}|9+@S?di>vo;HHFo#t<r)Fb5MfDt^{dP|4~j%(k9dO{ekx)toHE>rCYbizzgt&M@NHK2)X7Fq-@->kqZ1O@zcy_>>54io4(C<#VPR+{yWK)1j7@E1qghN@=;`X&qaO#{Gg^cLa~wd#Iy|iX_TCJr!;s{>M=}nM7gXKq0mOx(IXm<4LUi8F&9N(oj7vqt#SzmNhkP=@KFXAwL2$+wg~t)Xtc}{s_V~gd+whjW0mzsGI=~LjT^2pUAdjCm(*ysLbi<1yJ5ZXxI945Fa=EoOzEfhan1~U61`Bo>0VlK-fuQL-d~EPbl&CK)66+y?r1)sW_88Lc}AqYc>kRrxY>I!!P9#!O8U%olPOyc2Tx87>=^4g{T+6a|*$X1CkjgL@fl9)9>W~<|8CiCZ-W6KLg{rrm+vsL^YUV>9n8<8aF@kRQhrl^dARXx)=Tsf<$;?==%sFo{N+TwuU8L<S>{SL#vh|>aOxaY(sF*=Gtaz`>BdA?-`-qj{JD0B`V^%#33|;OC0W^3g!Y;asA>`sQD1V+|4Bz*cgqFOtv^a>FRD9agjz0G^)B^<x{oyaf#y#AQpom0$pLyGe(M=uWy*{mWFr`sve*Z^b07dIhym5dWX|otPSM4%w#*69B2uD-AL`3hg23I%AAJFYtZrvf;ke%4*<R=(ho>%MVO3`Ou^oKibueF%c$&rl!or%WeYE>aOutWSR}(gj5zlNAnuoVd5V`qxb)^bX=L!d=t^)m%LX}vmt<VbNL<<>t!7qwF`Yo!59~gKIKJMvBy`iL<b*5EU4<_qR^*$FJOUHJ{0od70klI%CSP2mQ6W)7iEe=C0Fcc&xGV){5k*G>IR)S;ggCCuth5t6%<{itxZPZZF^}T%E13RGsTY7W_6fm5H$y*J@_X%6FS6v{GE$$-*Cp>}$;%R-4!Nm5UE*5+Y(hxBXqEWI|E<I?{%<9I@xPS#vq<X+D?M4_)gpvQjL;>1*e-xTw~{4Z045#?DodOvfj)$gOg>rSheLI@Tgei?2F|Myy2NYx(aQX~#E*sQYPXUlJ_<}D{JO;N1#p+&S>my87Z~CVJ5>vc(b3^IjOZ=sVBMF&X8wZ9`w)MZ`u+u^T!3#4fUO87eQ0aBprL@(zvLNF?p4gk9$eBvu8m-B0WuIke}p(L-B}t;v4Qz`*C_AidYt)fPo7Kw&!1A4fE)y{A0hQKE%B{x!HbmD|8n#&!U?J9Cya(B*D>FKiq~j97Z)uqqZGfH=E^d;()bg2e?X9HkAlw!=xZd5a=apJ%|LI+mEOG=ZqgC$;=K(mm<DHXy|`#p$;C?EYBho>_v^Be5L!OIY}Dk6<uL<L1HEJ!{E*M?9~<TH*FpmD*M@a+_-pDx{+%yj_~5O0*)oZXoFa)z9!AFB$N#4YZZe7B2h3sk=u%6aX=YkzsWZ*YR_m9`F|&>Xv#b8-;xlVZC~KM3>v4Y9(A)Tc-0K0;zu;d~KYX+<z^0=^3!;RDzw=7&2n>a@oeD*;D!sp#N0+q*T6(R`UbUo?XRlfoUuz4FqsEG3{{EG>^F~By`SZLHA6ouAZ`9InCQwJmF^<(u+Zg4qzUo-!d{r)U>UF5ccL~uKg0A6X9IIp^_$H<HSXPy>@(HU#E1$3`wDJk7<jSXiJaj)s-A@(M?O(Z9h;yVzjMWxX*ttXp=j~Fts%blQV&>&?adu)r8WBmCv&bvu!Yk}xV(%ca1n6_s9BZwj%EY#U-iY+p#p%cILER^PKyi8{(8rKItvG$kRv{LWew#&?tAYL&$jlbfPmMK-<zb#Mqr;M4x84kp@35P(VdeQ^gYf6=!Tg_MmrIB#7nxZX{wmwx|0CXv9#?9Su%wHuUI(DIP4x{?0|Jft;St5%zw+W4$NRd0OL|;Lwq0Z<WxL37Rn))#JxuMvV-{HHUXsuIDaVsym*ammwNH>bJ;<5sg>hvy1*`UjR{vgY=2&O$i9$UOLDxsl3<^It<o}v<-}vGgpF!t8anu&wy8ua36Y0w^IUdYr-SG~SD<0k~1V0)ONz_zxyCK@(Uw&alZsGqL4E(gp9B#?=k_AbYKJd_|;eQs{`zrR;LU7Y%*IJ9crCd5X2>M;5KTw?h>pCHhl78KybD>LC>ac<Cn!8r(N)4p7L|CcA2Du}r0_l{OH&cWSar@*7n7_svA^xH+?}TD$)LxI#6eL&6363<>s$#x7`M@f*m<Cm2+)>ZS?XvxEp?m8#fiBI2;{D}F5f*0FNvGl@>icCdcS<%y5rUf%?!FUbK`cSFr-Ho`^x7ep5~QY4Tx3*hgOqB6+0`lhpLH_2DeJyRsu~Ad-lhE)En8~HuJ-1;s5(DS2+dlhPX7tyryOU2O(vGg?sBsVvn$^$2a?vks+Fk~W?~PSDJnF6f)J#KA-Ji_9l=XHFSRGi2aXqnn8ZYitVFukE>@i=I^hiJCH}WiZjzLXgWUa;JLHrTNo4sh4Fe$lUm*Mal6^det@D6f*Csk{gL+{&EYXaTOEzea?+Eb=wN{+uSeSHJL-FY-t^~yM6FT=VQoX=P$4}?X=9ZjXGEE}O(IVJ}e}2~ICX?`|VvyzMd*(!o{j^&D1lk^6{jK<4LiRk#-n|2+p8N(la<ZNX6LTy*cH)C|YXY3y!kYNLKpDxEZq0YOsF`lfbGa&*Zq08cV$EwMn>C-6G1femhzQo<a^}#<C09fnO}5Oky_?YD61*F(xM=T2t&950zbM2+NVy6pJ61Z;**`DD(#ia|)S?fp<yaZvS5P8}G6%ZCSH%Bu1UDtzcTA>&huaA8JQcrYDd;3uZoY1fsVC`IiqV7F>{<g;953Zst95&;hF0s;`>(xFI<DSR98d8>E3a=D8KITeH;k5{mDe|onC8-iXV5N(L)tZKN~!fq`<dT+Ez$pxX|2ViR-SHch5nE92a3~w2LDmgpD9ki*%p&n(!ZPH$gfJQiKjZ3zhxr^(jr$%)MzKfAC!oiT1o-~=J#@0{L{wpeh_bVoLVXmB?rv9a&eW~4#mR*#{amfe0t7HIxkJ9vQ!6fg>}tT$AGEV=GB1NT^g7AEZhO6yVpv0m0X6T+-20{<5ShzlABDz{}}4&S+c)nv41Mr$?|A*AwI|d*JM8{*=u92@iQP-{IudLWok5>F|pKW*zgS@(x&l)SWALyT#gQdnl=p=q9^|QPNOG1jVW~*FT_a7&9&qf*9<-HSs~ZS$R4xO5VzxhGes%jo+RZjq7Ll=<od_7;^nU_t=*`UrNdEj7ntJJX^xU}SV~RJxuS&sKbg`6nbJQ|gcYaro#*L}B2-U<N7w#b7AM(%nq`OvU}=Tmrhq$ox_n4hAKf42M_TfaRSo4-u8$^BW+(jA0{j<IlmhO4ln>^!VLmb4v50KHOJw;xq1EJ9<!Z8ilW6E9A^rhD*PGKFcT)s6QDgZTMj5Ndmd4PU^Q+Aq%fwNr^_3y$syf3_>cU^AP>3wjJ6ZJ5GHk$|pq63VHWQ*B;?2o3inl8iWKA<+pll^n@Dlpnh4^1JgN4A$aDEr=kA6*vtxV-UOMzNN9tHX%q(5QNcd3u-xFJGtA|IRGn4uq={Z{%#pf#?x6tq9CdqO7m0_L?QmlVTiI^PEOF9$u2^y<awm5|2<AejSZmMVhZjVht#;opsha(Ot33S!$CVm$umBDg8;Zox~JnN*pHHnNf`*Uxmc5s^gZ=P;h_#y?j*-76*g%^Wm;T6VgaWrYU@!d2!$bb8L8sptI0-P;QEaLVWs>&kJJ;Oik=H^QgI#}rsA$b&)Ziy#uYCNR%lMwnM}0b;&;G1pVLG_W81`zq-*h<WxJL`e~|g{z)igLn<RuT-+vAhsDrnv;v=m5lzbpN#(U+e!3y!53MXpD8H5J|VvYW9~4Jc7-xPF0KOEuZ#)57x$klJ}ysT@mI-I2QsxwsSe}@w_5|VnPf?{rKTh*coN-I7XBL-vfURlf!8_;(ShteE%r*1oh+ZZ4KV`$W60h?vVVL#5AT3It1b4>gX(Y0xIt=NVK%e;CA0ikq0aJ%w9tye2<fJ$qE?@xs<$mwp&1`qqnz;-K5&;1KOz3i1XZ@v?WYaH78<G=Q0iCQhaV6Y(~$6&(_aQ{WTX)NBe^z+vG};bWy$c*qMJhPU!Z=2a0i@mA==D?TVilF8h$yzx$~=0Li{s|%ZQjJ4w`7)_z<M)&gH<dS$y0EuK$4jJA`n)-eWNur9{kITutP=KJu*}q)^k5f>~AyF|&~Zr|bFAupqib3a-*AG;lR`rjW^{28*ejXxm0=&7BLaTyb~_8lOine*(g_#y^N$1=2c(dp8030LU@`^J4fsqYb%W&hIhYj2~0Xp$>CAVo4jd1krg8y=FwE#-c7Em<2gJXAOCX<+?W5;`rf0zHR>DHtG?A*#+cJ!1Mv7`g0@T%IE?S;`qg1zFoEy;3EZ-AMfoz{1yarFp#$Zyg{TVkmxG>YD9>}3$!F3F*KPYTc`<_ziQSbMW6hP`j6w=WXtSiF4C?q%T+V`gM23xtwAum067ZaFp(BO-UILsk-9+s0`Lby9KYgNX5U__@-;MSm^F~A8bKkdA-IG5KEa1eGUH?F1L_8P7lcOq?s1uYuciE2znO?^%|P@tidSmQ4<c~c32bvvXf<h|{0QtC)$mjEt#(NV+Coj=NRwZa_lpxE2f_Rk$OZsw<3e>Qfr}6a?2@n`>seL!)fkg&60bnyEOp!j@;!iWiTns85q@MmLO5T5dc-#15xY9-lF2io%vZqD0le+vS%ZK~i01)zK;8qg4Zs#^;)fEC*d~?K#D!{;pG!Og-lr-2GmuLFJ|prkApQj89--<{Ez1RK{xZ4l_0a^&$a<}1cQFf{gURKucHD}bZxIl=2H<0E5R}P9wBIIJ_AH^$MgKtxaV>2%dgPS|#SoFml-zc4SWqRaT)&CFW~KT9_@7M_#S!s?!NtiWEmzHw`!1&Ztx&ufaqioAnUBjzzT;VvwZex+n0qH*m|V-tVq8Y@YpGIvPa4VYWr%Rk=4ApdwbtK4rLD?f-eM$~>k)AiHvWp>UIxURjZ03F5Zw?4A1p&I<{=RGAa)l*9Jfr!w9Dok3beuiBhq{Z<m-t42BA2@%@i_{F`gz{LWx|Ce%sbzLA9)M`l-_X1u*PSa7}>F7zFb=kUaqIBl0<rvjAR12<Q8~Z`(Dlq%xMI`4?E+DT0S>3iAgbtpKzjas|j30Qm^v{GRS@yEiDM31w{_0n2Xi-c8{LfP4UeM<|)wfrzT;SAfKv2GSfzc2zcsmLavS(rS5EDxieNfOkYyHg)hHsY?Hz`3CYKfVU9_S8r81gE2KgtdlB4jZ}SiuG%Hrwyopt+=}=)srv5N2=C4b07p|Tp~nqAL6`y2@PAixKL^--oR|H)+=WYTzH-fY_Lc5^EZd#D+=)vv>9vjkdfedmkCJVz-`xNO;;zYweH<<~kl1$!k~^j~C>>GR+8{LI$N#=bmMy#6s;-cq^KU`)1_W~zkaGZDvnnWl{<H8yCc)!ytzTGbRr`4}j;q=~8l7_?{-Rk)zR=y!`{9G|f-0QEU3q+=_JS@rK76|%S9V?SM_xd*`Q^e=UJxAe&|)+ka`lQXl?_Zc#4q@l+iy|a{TeSHETqchP4I~kVWt#0-f|U5WUhiHQy>3LDM%(v6_B-#WFJ)Iupl(!+-{J$Ip!)0@o(+K6x1bS++BAu*B1~Kj+wd_A(l(uV|rL+7lL%vf6z=g&Gfj?-5LBH5kxH4&&S)W<4X$dGyT3re772G(;zSj!92nN3cv$IP67D}z*VXXr&X2`(}t`*);wT_nJvK*s3A{J7U3T`l6RHn?_rp7u*(K-lNx%k8wFrQ4L#T$1@LGMJ=jgL&9|U%OOrL&T?6k|HS}N?$&K1;>cOr(fVMUDU}wo2r8L=t-FWbht*HmQ^#JaysRz4f0h~hEVa(LR)@X+sy-f&~fZ2Po<B@`6p@AjX<|6to{Ey>SaO4*L#i(7gD7R{{qjovu$h&+nd@}sYE#ziNxm8;*5vJS;OK!5Pm1JpgOo*59|2o+ZN%l*tg!qW;KQ1mc(b!-n^x+g@yFr1G*HL?TmZWah)9fk2jE#_|l5bE3msu!Rm=|<yBM@S_0KdrY3qp|kg>5t&j)hv2OYtv*{~zoUV=p>{%(8@fH(m;%Yhe2k0@n}{_!h9m=_)1TAJxHp1RR5F3z3TuKH9<VF2(M4nE{h;6F&{!ClTcP#R>er(PAxEN+@Dos>yF1KLh_Kl;PKp{KXbI@)K5Oe%3G5PbTCuiUh9QTWsFa32kqzmhwe>ONZtP;#^y$?Z$Hb$i$QnPty2MA7)f><hf#LGrVSW>@xipwtOF3?xbh2g_miDd?{JP^UZK8IzrTIr?lO_T)!S}@<s79m{5ymIE&t2+KkIa@aQuAGPlWM?**YA2*rv&P*(BFPfbl0dm;E|rjaan_p^8-#fEk&3Awx94sdKs)4TgwJW=9$JGJdztL1ukzf<5jnWneiv-qMFpWb@!GNLc0>8<x{gj?@<(=ln2$7#sj{q}2dL)2^U*xfG^9Cgxl68r7CFL`tl{nEJ)nNGq+n8d9B=B4ZV^smiuJ?un|lyR5czk(%!k8h6H36<oF*jY<G&q3+%G2#)slFgt=n@#hrl_(uP8r*}F??Z?mzBHsKN}M6z2v^FK75vr>Q7?h#MVed;DFkvIz;`7P5xdrrZpG3$f$mzgfsa6w>R<>*2zM<B*$`e@rk<;nSqm&vz&oi9Un>N%3BZOroaX@vKkLYaue64iMyk9UPe9=DI{I#W0^lQRkb5m6<yj8X{bibN@`<jQ0SqDh`Ng3`1Eu-1T}kE#V5tS(8VK%li%VEqskBfVqrSAX7X*4_XiH}SD98v|Dq_Fd7&6seS_`_9TDPG&{s(Lc!yI*{T$y!7K9Ll$&Po_orqYE}TB;&?|4T)T=OgG-cFh(YR6Sg_8s(UbsNKlc4(5~3r7LFg+dNqE3GV4jw$7JIS~A(~X}$^y1d3xK_{V4Rz4av_#QiTI2`uWD?4(O+`9jr+_29oVQ<t=b=#uW20jp-f<|l7AL`)`-ClGlIA)X)Y<lC>no?*VmxT6|?&*X<YKY-_3YW*jW%)01B5#sN12w|p1p;)udQRd|VMBNIWd2)wYe)4ZIx<tw?iqZT6<UL@xr!IXfAfEtu4<U{l`&a^QDIk}CxSvmxEFl^oJZ5wSCd^j2766}ukUCGxTq^!{8gIZBJ9i;S7u`6wM;87+q2lE%UHIPv_%_Q~_*?9(meQaLKe`^jEY^kJ96)xxP&JPm;HU;Jk<U_?>TYOG1$iX+hEs41kb3}ZM@S}1%&nl@0Cp82?skU?k5Z9rR5tGe`GxvIJd0p%1M(+;UlHP#I4X@-T&F<5h%ncI+^&HTtq_VM+kvbEuoNMg{4sk$c^TNr23B_C*|ofBSH=8}(7MGmtK7luG7vSjp%4=h;@G8Fe5T^Fx{-$v|6oIBH}Z*Hqd)n(ZscnSeA!T!Z$u;9*+!xAjpr*UpV)=7L0k3QdNlHP*wLNEr6C0BQ|Kfqd_!dzuptP^6o|PD$_il15aRj8-6wVrlF~`=rIdu_YoKrnU5Y$h4uWw%g4qYi8vwZFcpSIX_{1)DO3I~}Lm->?;qq@V{Y0rvK;jx>;6RAuep;4Pc_qb#nQI`MpWxCCOl=U%b3n!c7=w^Zz8LN{eJ8Lr)We+>Ej<;Ko-Ia_yEn*Ydt8oz=?L{S2J$|DcWphxKrx!Y#RnzzKU&AHvNh$J3+)QPuNQCHC6mvR8S0KaybhV+1|~P{tmo^j$8poMn|9vvt-Muj!zUEH;3lKS(}udtDs15X5OLg4@}`}ae4Q8b7m(*7eryxAP$1@~xU6g{L}62*^eizVkr}Bm3c#J&+`v=22$sf*;yN|<Gm_V@)h>eB4D@EA1VXPMqZwbkD1nIhhfsloc88GCS+12tH@_45o<!6jK4+wq6N&A=%oM4%P-@Bkq_YuGkqYL4?Jn@|pn@qto&|6U!95y?2yf+3W0s|+p}YGs?f_115x)s0w6NK8XzD=2yOk;JM$}a(zKjrecxi~wEp~%1tcOv_Jk5MJ7osLYF$Ajru_TnfTU=D7;Ps(Km=_RrJGfR*%!wp8OChYZ`QJv!0(b?iXPfH+_#VKw&8-3uu|bE5@-}3xT5#2>Gi|5`w&)h<oe|u%C>r+&EV;!lj6fG~4>G*wNs!xts|`W|3*r_#S0P9n_@gS5$zYw>LYIk!*grY^-?V$nn<YCpG@NGZ_3*zHf}30D5$Gg<r&>5ipqqAIT1tx^fi8mo(-yji^t6O<OS^}Zj;ST+F4GX{nAU+vT1)Mi<^t&5(&?C5a^*^EupHAl5SZ0cTX8plyIMNky|s>x+AQ7MqtjlvK|9sYLGam@+V)TE!LyW%<y3zS-Y+fN{jK0Ww{qJ4iJkjW8Z6tJK%h}8ZTm0)Lt2Gwk39x&@eSJ#upsNTdpeavxft;r*p@?XDMIWk3r+E^UAHaBYsvV{lunfS1Z)Su|6nUUgL>Car<Bb57{lqfz7F135u^kAu3ec+^232O>A?O7*6Xb#Db?cPTX}Sq=8*WQrDCJ<pV;I3kF6165iE3V-B{|y!#S=5zIZ77%W&PxY`k2WX|Z}cQN573*leg?NTjw2OE3W8pA!H##odQ^d1|A4)n$ngbotHln~cyKmW~xDN_AX^ri}QMO?rYL{1YKp7pR%-loLs0Nj+$YuK4dwb}|Y7w%g%*k$uJ{hvm+7Q8G`2Te=1ROG>SavPzg#5Nyp=XujA7$_jgB(1N0^oA-)YLspOh;O#?x-hvhO`d=x2zggbo%aWVHyB=Zihd|brSS76W5s2aZM0~BCa!H=BB(s`Xi3blr%WDYkI{fN8377u>yFpvHXVzNVmXaFeS|qp7if@A=;FH;5T<*xhr30{bZMX)xvE&-0@JHPy1hZ_uz1i`;r{h+#$d2za#25Hy-FK54wQ3o>56XpaalD!7kRxx>9w8DD&%+$#bWZqpt$>>c)NEnN{V1ydS-$=ab5Z>FAv>8+V_<haAlF=rJ@hWnZg(~LB3`ujajx@ca-IL4Eqa|_zl<nf@R%!Ay*mg4G*iALdHUBE_f(ZY12H;PD{oO#D-ZNHD&M2t$ed3kb+mlzi0bbzK;dpRMD*6O)VP_1`z2m3Y>~!opm8}guK8AN92qU+s7ClFJugHTK(0Ppi@o0YB<T61PqOHIy;B5t@nxkwTmSwW|23|*p>O=xx|*qP{1;#VdW`Cx+Uh7y;m-v9Wzx?VqZjh<%IhHQ?yagzlPXr*%1brX%O79Wz$_1UX&k~DW4!RDNAUbQ*Tyr8b{e-upsTAR&(?Hpe6nb#QFp2VLYyKz1H#H)AY{bRaEKJGF{VtP3qmzTxCp}Zf-xXuD8iCOYmA9w3PEV52)h?mTX~-lZM}74JMJ*Vf~*)Jrgg<caGN0>MsV%i#=~gl;A%XujpsKJRD3ON72+9SZ&`fCOWSxD&1<;&B->90`39U7;tJ4f7N1y97vv4o4e>iL&vs2#hhutbJcLYV`DBgpoE}XimWbE0g2j=Q%nB3mEN9N^NwzA3^72q}_2XEoDIU}n;ccD7lCAA&a0N)47_!y#WU%<!BvC>34ddn^A#O`B#CjSKHfFaWXtWJfjM$Dwk2v30sBPLG+}^s0jHx{bP%T=!R+cxFuayN&XgKd0lNipMqvFO3nl{|J;cMkhkj%WJWbWS-#Xo%_auG|#eWvqR)dmtyeXXaeHq*AN5p5$+1}V4kz~U`#$vRtjTL#qutYWD#W*qKs-3S^Q-ByUd+VDN08Bsz^dDB2NlIR#o=9=x1A%sk-y}zH;Gag3w?Cq4=9L(lH#7yfT#2^Io9w1{eZ|=?A2Uup)F~b<#i67KLq}DM|YMtWcWnRwl@&PZGc)7;Q4P5&DiAx|>h&x|0M2v|{?}baf3ZY*(kR_FoU&i==yb0I!R2OaGx&D@g*U^f+je^Hs)D|A-3O}r?WnniVx_8qSzKRa}NDt2UtNcGL<U1vi&u9y?dZAnBr7g^l7vjE?+QK|E?C!m_g*;$L{gxz13zt5vE$p2Gw>w8$n3#*+CRbZntFI81`tpsUg#V|78xn>1?ufQ<Fm7L)e%iv_NoZk5w1sQ?bDI-w;fBFh8J<a&7EU~@EgZ`Yg9c~|lLjJkpti6!WFirgDf0ia@LY-zZ|v6=4jO`9W{72BRUwA%*A^BG6=K9tZQ+wcEen^VN(;L_s4W~d3{@TBgh3Ns8?P^t=4A}WkUN|OnEL;{#nps(`W|gw(g=(-BP{a})A=54-gZzoA|&!%-1@_;TO5Ma&)cBpXBg&9zMgv(?3WSDY#`P1P@@q<;$(CI9c-}<B^5MGOt~8h=7Vb(_<1tDxeUn106w%846wy4$a=)<ZQ5k8rJ#I1>R3MCU;!c$`3=JOVOGhGFPU=FCU;TLH3b=jP*y%4#X=+x!0>!4<;)S5KnT(b8aKIMrMv?C%j}dhor0#gUQIHKdo=SQFg{e=%nl<gGdq+{r5Oa>G*g=QHYDGoc~xs_R@NY8?4Nc$vLIVc{n*>B^!+1+_&HyfbJ{3WAOz8f3S#ZzO5s}p^=nIk>4+aVN(-#P*tBZ2u*&CEJE2!gCYcreyOrcG5O`y>*6`L?A<m6uiPC3##}><HlJ$~WJ;0X`5fd>EL<Ez*-1`7tLWt*AI$zr|*ZB&;K6lcQd-=j8qIi(+0R*!jkn;fEB+?GZp8$SEh~rj8U)v=`4gBKU<c32{CkW9P!E6a+1ORR_Zq@;E2Y}n;8)LEbpazYx<SoehnGd_&3HQMox=b%Z;(3H{eoSL=nx$p<ax%ZH`3Ah#5ahQuT<@I}5_5}sHI#bu)FkyjR^&v!mjUDz0H=xY)1_&c3y(rbCVvb+Q}SXSXd=X%1M)F|_lbN0ByI{agb;I$DFNt5<YyrFPT{98K-@6pB7nCM;<-bVWl%Y>yN3GiY1wXi$cUOfRfy>b=G#C%1MmS6ZV**}nh<pmk|`7O9Vjb-EuY5aXH@M%yF@NBlOK61HKk5|qjMBI2d0VQh}uu%4qHmTh4HB;b1bE}pGKqULe!gX@2AmxoZ>5UKMj6t^ubuGl;t}dPa6JKdpHq9)I6wxUn0zLK%NG0d^+E$B^x)0I$~D^3$iAYa&L_*U~&I|OE@<QK4RB_lFV|S4Q}~sX5+GU2K*NUcLtEuQ<_&l2XW8YvCyMTXKQ%HHed#Add^6Ac8_ii$D!iz4BZ-T0JuIww}vLjf1{bYHN0Y5MGbaq7=!rynYuMRFq7W|=+<x*z!h17@%*amGuwjQHPv1p=3ZFP4pGsV_yiElMnL)j$l*+=7JIWeT-E`*qkz={f^poC>oeOHlDG$j`7+3_f$1#uJk6pkL{EX>eq;dGI&tX)tUW>;w{5mmxRi>27;$D8ig5+vmmrwGf#*d4XQ<*^&Ui24@)xk*sDdX<d}cQ~s^C5r<|dF^&JrRU!CVPsA%J-Z?s;wb-3cxyfE}Hsa}%>2lpDaVBcvAT`lS}%`?=?QrEejMke?r2v5W9rO|@;rg}vN)gWnWAflKym+%E+4As}}EScZ_y_x-}T2h~GkE%9|4veqo+-VyI{FRLGL`3_RwP|Xz}Npp}}2JXUaX)r~-T6*sYZoF)^#bpqf2F&421adoo6$q)1X^C&GT4`k|oD;<lY>O<&`pNAhIB|R)TF%VTz2gUV`X%}0_7UtIuYvcgId<<T^hmqP9<=gdxwm<hNe}2@CvGk(-&}j7CG#%Z4cJxEA!uG@uO+w}LOX21!JMT$rP*6)_LyuCE6jr&LL$F|JZCFBS5kG$w6pu5nx95yfjx7c9!AdDrk4~k=ejG6-lvC=f#B~yPZyNMX_l6;hLOeKEt+Q+R5-WBvzXmwCgtXac;@Z6?1$XGl4+GIB~)>YtAYF&)Vdk6bU(DYEGWz>g4PM;AJnCL9_nA6r@et1^M$B}AQGtHOIyL0CCji)f)wrt-kkYbcoTpP^A&@1Rm%^t_(PDEZ&34&2eqqu9wMjaYghGIOz2M`sLGUPi*2YS-P30+tE(<RRlijyJgEq-Ns%Sg$rd_SOL~^ySVB*L=U7oOUvHph4nekwO`Fu%@AUQl4auL1tg?w2ZV6hDE!en;s_%=0sItgPP2G}r?Aeb6*;4gm@7}NNT(*dZ-0IAYUMj>$1mzQcXDbl3Lq6dJ#BW@x1-RGe(G_+r*lQ=Ww`7u8(f$KE$qp;g8?MkA7T%5t+wDU8gpb%_ZEH)PF!xdI6P^IiL$_<6aMWsaORM!L_?#_suD0?C|8YQ%g1><0Kdbd9m~w{@Nq6W`um^xHcj!^@IXk1&V2^^gA%4XjdK7#Vz@a<zDEJ|OckiHxY|JV7mb?X7KRRvo4(i4ny#|ik8r{GwPP4R()tFm?xA~glKB2|z7J)Q}PdEi^qt<Aj@Gk&2)@Yw_^;#houjNijY1$|B-HFC|r}hay1MtzE+9yn02d`wE_6dgq7`RURgnIzovrhYjp96Sro%RVWgUX2|Y04+u_K@}o=dBl_V7>MUF9Y~^z4i$kZ4jdF2F_yBv`=_Du-i6hpRk2pB4^T+PuTq-?GqjY&%+x;aYXrqeQc@gY04*@|B&_xlQ)8AqwNz;{@;AUOxq_+Nmo8$?!($A91S%*6H@ww`vBaxk<Z-IwNE(Tt_l|PUwlG~#Vo~K+$Ws9Nr=KtmQT1+^Ij@B`pVX@$u=M-UHOC;9@eel9;n#4Nw<bi0DQ1Xw}#}+Xuz9wYuIF4MGbaq=!y8Qn{{ir6Ts@tx;4BB;B|Tax%3J5+ZHTIS3Y6vBibkYb2A?UXrHjv79pB#ar%UFffa6HwMf@K;eOi|l5C&waWEa(qJ6@D1NdQ!(<jW@iYdod?GsumTuO!I6HZ0^#I4#Vd<4M3txlitOJJXG)jpx6!Yx(UK4Fb*n2T@IKH*pZBeywy!ux>j+NN_OeZo(GeSnafIZ`RKeZmbz#eBj;b`c&<S3cpFk2rn8s@rkDwriiT5WwW^{E#eN`-DSATH>uW)YYnl#eBl|Aob36?GuLW;CUk2C$uz}B2cHKPuLDjZFXp%a3+AMJGkVdC2XJ2%98X6Gi{$R^Y47ZhoR-*4&6Iu+CE`Pe%mL!0N(REoIar(f@a!-?97sbZ1XC2JgSEve#P<Yj$;1dtv36ur3GKG1Xn|F>CR&Q;ZDt7%s>1IJU{Hz{^4O;;o*|1Tc&;WnD!5=+=b!fE<L0iwzE-EgihP?$MlfW7W}R6(uHPmnx$o|A!P!1$K6%jKeU+LWhNE!4>v$=UCFe{l@co3KYZHevLJ_ln08o~?$c0z{4VVoMC?LZ2+9X~*;ep!$uiXbVJq-9+ogpU0GPi^F-ZS#r@dMog0y^tnhzb;{^4neJh)5yhwtBwQ653LdQaJ6ZR<$?@H5NmVfP5(xko1)+#^KgJ(kcrw$O|^(#;D$qJ?^Z=axOi{KKo7IRx1zHf_@Jh|@nj0m<Wgtg`vmt}Ne{EL`m$egxhR_7wLI$J)t_Ety>X*k>#|$KDT)`*r4?c@XyxLHUP^Yz4dPg#5!^`-QmnpcdHwFkHch?OM>#PN-qYB(tKkj_M=_9D;_2wT5y$Gwq1b{$VRy>|!11AI^MI`-kno)9{G)55tb4c^}auVs7XjWGMgei=%o(JO;iaNA-yK5r7Yl>Jc%FXCNKZBVw+dQEIS9#CC{pb4-tj69J4rrbooB05%?@h-}P(QI@;~SwA{(ImdKkeiIU}AJYxY;xtRkSdIB-@c#Q)asSX_Mq|!!_=jo7aR-iT|L`3E|2(e!!}*V+1Am-PwKBAS7<GbMZ)*SWa{!;6(Eef7C!pmC?H}d=82W_v5BCAs^Mv*fzXb5n6WTwt3@Rs5GL?UL;<)w?7d|P(oF}z^coo3KC$)c={ge<5o}yossr|#X!0vcT`-gSx63Ne0{^8`~+CO{>JdZskiX+NDY;Q|#$W;E}&g0rYZ1J=ZO`o>?!(a56^SAzCob4Z;$yEN~%*VBVxEN{{Jgxo1=K!31nh%pQwSPF#t_l|PU;M*~b{#0mT--lge^Q7$Pg?%rY|VSA<VY-A!!p}|>zT?w{ONJs8lHfPV<&ZM_!+=YCv|IRhJtANjBX9fY^$ijZVlrRKl&Nn8ukO&`;2Z4Ujz73eyuP4!|k>ODRq^9*yIWAA67mkMARwm9}Wc2_mtB=+z9N>Q>+$swSTzXwuL0yKYSBRub$HWq5m`nrPEITuq&{Rr?r1*sc<P3mVdYk@ykzZ|L|o1FPwJzhsLu){CQgYhuiH&M-~6W*muBZQ9SSO-TNkQ0tqRQ1X2hIy#x|SfKUSh(xi7qLa$P!sMLT8(whj<L`4KqL@-G2y#_3(fD{1{R1i==EdOWrX7?`d8@|6kANI}6?lZG{dvkNMcYC`!KCBB&&0QQHP5?1xmoq-x0xo+OAB~I;AAq}ulo-U%1a*A4I(K}yLU&=SidKB++3buDYwpJR+RgFdOc1Z{rZ}`B$A{_qkz*WFc|SA!9a6V<b9|Vv2N(Yyjt|rIv)c6)z2n1Y0qVSm<HPA7rXVHOVF?`{u6D+U(K<eieo}mR09y9#Vec5N<3n$}jt_qY_SPPsXNE$L^)FSFq1~#@>M_q=7~fvL?VJE{Y_Adu)Q=cKD@mbqO2}`Y5RaA6>tJ4`O(bMoScZk_u&9g+vr)WpAIF6m_R|jU$0fDOime<Meh>J!`}kIpp_}h5Lc!XSEqp66_akRNca}n$zB1}oQV!TM`*X*I3hd6aDmyN01G!e-b@}-S<sBC`)hI<d;=+1cxtGU6{iyxi%Q+xU((%dIr=wQT(Yp^hF8mMJ$4a>N0T}xM3n1gdMjaI1rdYmmsl8h{F3f^RzXKc>E<Py4A|%T;dT6nXN-{2dpjw@NNQeUmx#EoDu!Q64u*Yj5MdeeqR;!x4jTH<5e&F$3G2$Bxw<%!@_TT1=5kG<C+T*I9#%aSD=iSj9Bc1^^=XmZIF;Z6->0Mn)<R#V4u_uIhc$^Qk%9lc<AXzbDf>toJk{u&nLwWZvSz!5hLM;A{Kr+O;-(FR*zLE^_y6oi;?>0b}zvB=u`+Ffi{GM-WhHhM|WGlowyq#}q-Ou4ZevWTyQ$b8Q$2YZ&AU-?CH#I}IlQig?+V?2`_8i~TOxo@2Jm1tR&<ehk!PjLsC9f#;k7BSYJNUY63yId})wRM%(^p1amt%l^<$UfCPl4THPO>A!`vkCe&vS^^@q!S~T;LGzI*9Kt(3dgE9O7mDfKl!b9OAXQC`9v%9OBIaG3_FUc*j8;zQ`e7flDybOB~|00ny+Rhj^+%emL<~i1+qR4)Oj2=Fue%@%mpzgm9Tdylo(|FVmZ>6b|u1uHfEzg+sh&b&q7ESRr1EogCuT0;cj6k(;qXyn$M3Xo?l$jory1-cEqFUeO`m(f{ia;Q5}amsg}%Azr&(9O9Wj3i0n14)Gd*p@l!=C5%G6dD;{d^*=(qdD;fN!MQ`c@T<7@TvZ|7a>nKz;;q#U$Vst6yl-~#)ldT}s$S)*VKj(QSNUq#4r1$7z8co*R*?pMHQYe?)vJ6pl({BEiEDf{3;@yZnrs1ucw2P~L}e?)i{HZ`-djM;yT&2jHz3YjbB1`K*J+_5GK<O_;%(J!p)4KZwE(E;bq?`nftYsP8R8uVxBohacuIxKQlUaT|DVA8#35cI5cPj@hIm=v#{R@1-d26lkqRB+?L_(3pE$((7sOvbIYYeaH{b?u@X^Q+Zxpx}krIcoeK|us`ZjC4wn7T@_UVpHu51N*clI~~z0FYd`3(;A^8F0rXZmWYG6#Cgdn)lsOsQZbcc3>IQiFcxKyNvS#XobPr!<&iPG#>v?^}Sr`I!T~fSV{rN_?Ls@(%RQ>lP_W{nLS7eQ3$J$v*PDuHPH41HA#j_PgoxAn>NXkJyy;FQ8JPC42eS6?+TA!JB+1D*w9>Wq(%+R_I&83h#Sgjly3k1-*gq{Cln^iEA``jjv$vKJ^IlE>6A{lo4Y^e!Ewl;WA=;6}X9aRm7;@|7Cc;39MDN@_vpOR|CH4uDUbnmxtaW6vmy{$9JY2;7{IFcc!kY*L`Hvo#`R4f8O<q7#Zx&vno4cEOt+bqW8S&^79dTLd2+1igHAZ!}oLVHir5J_xQX{2JspaM~qrQNAEu5h;bvZpDE#UAile20c6A&tj#Id+psE^y1$<z#uE31@W0OyW7Z!C^k@>Y^`=>i?XD~%#<B;v)ph?w$o2<Uyy|ZuR{pIHyP+0Rl=^xNf!_e7;7j07|IG>>gLotrP~_M|PbhBU-Rx>r*B;;rk!Ai7q7;&hAUl9)_m679MtwafO1B`b>MyDVV}O6<A8x_>Al@YfvDAVuw1O|ZuZy&*cHEi+fs^v95LxZ5b_!)vER_=3^B`9{_g@U1RkeNm4ABe83PFWEle)4Uf>!c3#9UxF+LfW_0bN0I6&ZS-KF*<MXfOy$6ncIG;xLlD*`CodIaRFC^Ql98vz=4`XC6u3Y(E0Ani#s-eg)zTlDyfT(R0yBgTC25M)@NWpqp*+5DdVP<jwXO5Y0m5+6Z)kXXz=VSzc2}DK=bph%fLFka#h~ur9hRJxA3?MqS`bfn6M8<O)3%7$-i}5qh2kY%jHrLeG~&aX&$lp{FMd2LdLZ@G|s#2RTcSWawEb+z{oFWa!x+L~mj!^!yOS`@~S_`7?-X#8Bv&R1oTrWaz0H<R^xvTA^p5BOH2u56o9cGW2Xv$PjgqWa#-8h&hF5ak5knJ#T`$fh0rEDY{42r&^)sk;5E%Mn&NAkMLrw&~v4hx|C{#o(~Rl==nB43nB~^dhYzcLeJa!aZ+fS6?&dJ!lCB{sQHc>K%r+`q#=qR#Y-54p2xH)DC&QNp2xHec!P6?o@-IXnn;5~&$Eoxq33#M=y_E)AS2BRJzF2;tKmziI2FlPL%}G-`%!!~v<J~Pim!&Nx>ck>UkwvcJ}!!{hCLv5MDf+&DvZ%vVY#RWg`PKb3x=jyq35Dw9C}s)s(fL?3O$E_7>Hzto@>B;P?*djjYH2Hx-FEYL(d-px=4B`^ekQk5=eIF*%e%8BpG@t6)sDK3OyI1d_Iy4J<o#pl2qu>Gb|dWg(O4I8~UOn6*}~6hVrM8Wav2^#1teu^gIA=4^sS!G!8xg1NRsyaewZ&&j>klFA6|`=byS8bJDE9v+r?d;8`!m5VetH;5iq>)EK(Tt8(D^t9}FhHB)&%VZ05gUr7xGp7F7`0+D3ksWg}(xvF>I*%6@jv4$0RP66>MQsUj*Z=h8qEyK>+`hlsU)IS||?t+dTvFsmj>*vbecpY~B1njj~!#nKUqwfcMyl+>P3WcBG+tsIWIKgp-b-P+$f>zB}Q~A5=+f{e(`*e-MZIyz{z@IC@3erj%qDo0`1+Kglyr~rQ0Y0-NE7%HRGbxZ^=qMJ;6^8zV;%i7U44tDD&+)FJR@p5lISdUdg)s?|yi3i|hvh9ov0=NDe3wcEzH%u(3kqra%BZ{4bHH{fW#kG&=jZ?_ud3`Yl(qwy<XxAak5JxW=zNWu@7)D;V*fhHz5FrMuP(*Cd=tbCT54T}p)0i53U37*hDMdfEw3~S*9B3#v}I{BteK_5hRmw;30tI;2`z&Gk&>xh$q+SZ&3f^LahOA{##~949Qr!$Wf9Q05Pgp~2(W%ge;Dyqt*`jjfm?~x^+XR`nz($s9{SWGlIV(3`fzTj`o@LxL!rEoDkdAE0#Y<}tAe>COkX@5P~I+CcWEkF$Q2zP?zS{agBTCgSf%ZXu9P6!2v(tdrL9dQttg2rq^0g(gew8%N*=t02JS)06+n+ClOroh4;A3-QoyVOGXcyHq@*gvO>tc-$nb-Lkn$;Cql%6wF`MG&=_-b(TZL{dV7>sc5h;eY;821vDhQf?8<kF<hU7TfFk>iw9szg{DU$YQP+(_$oO9hjD)TgN*dVuVh^1YD70l%$K&#e8s=b0~d4>|UQolUaXOsHHfW^`-6$;_+tNHEH*0vQQ@rrl!@=!-Fk+c`dZGG^HYON|nM_l}p_a!lDhmsblhG>dp(w-%=K+Hgjq3xn?>t4yBE=)2Cojqe%dq$hId-Ns%KSzqAF1)RK<hJ)QPLAAghI`PY9{d3^=To^S72541r+U()p7c+HhBRrWTO9}JFaM(klQuc22tWl1il%+Hqg$z7NG4E4BhcK0>`p+mLo#V!?L{EoN~4?nAX~r`nIzE1C?ey%09=ea(>UJio{p<AomSWJ=Xfu^m1?n~)JhR@X?BYD-i5$Bw5|@teaAo?O6T}5UboR(Sgz4U@n8NLh6t>|abOh?Da245_$-KyNQtFcR;|>f!-#0w87D*6F^3N8AM^w5fwKgXZ<DHAj34@OABa6jL9{V?hVB$aMXJMl%D;sBZL)?L__+gt-$=uRj^v?WLrC2hH8FhTf)|<<+<ThP8pil3eG)(2L+j;%>ueTsr`MyP7eC!6)yM-<)r@pgQ{A7_&xiQw{!Ue2T)r}{c=rz|aG$2FO!wobGn&^Csq`&k9_Aqw@d%mY0U2A<&{i2Yxw!4t42Of`vlmkSb@EVe0u@Ue_gvN&kvFu!v=Y`%J|d2sL@#}odbP?8gwF52cKV23`jmJ>Z66UwJBg@bcV0S^zTxdfVrkQA1@QCLiFV3etVI%SYm%kgx!Ygr`R04x)x@OzO};>1t)cyjX~&ZnYvG1giw5b>+Jd-0dMroO^DHf9O1o&s;^$8QX=Uw5+8aoLU7Aw=$YtLBhBph6+Xltbmhf5nP`w4nkE~T2#pCS8q8k;)KTq{fQ@hGhZ^t;A;_=mt-Y#o-<PA^u$T76z_*C6%t@z-_eP>uZj+?aic=OtZXhbW&({AJ|KrBUyoY%~jG&NOLH5DFt<hRhWrWuWT@bd$N&LhQ97f#h(IMw?YCr38;mV3~o9`vsRt`7I)RNa%_a;hgy>dA`0SExe=9~)TTmh$&)CcJZ0eOjRfepd=azks%G&^?mnVekAJvL^vCmbPaY1Lhmrm;x#KYCT&3vAT!7^Ic>Yt80jGTGZ_^7+TBiD6M@)kf5fp!)^K)6s0y0mfpD?ZKREHSuq;2bqCWNL}R3&{ncz?!$(+p=QDsz2X-n6{{&_uh|h>Q2j(1zvq*{iyu7o1yAVWM-k;NTC@NhwkUaHjK%#MEg^_YIpMj}QZWAe}Ofy^F)RbCeP<raVWF=kjGZ+GcNW(K=mV#JB?sY{y!$(ef>LcWVx8tYuH-sx#GY=ej>RPk`btQ88FICF}LY{h4HL_OvS&E<T&!zd|q^Dj&cl%j%%bkcHs`e|S&a3mlN3206o%%=h98Q|HP8y}pyrT5${gCoe=L~C$__DCflJ%K+0Yv}$G=?K5QK+>#Gl~+nf`R9pK0*OZAE@mk+MPgfdkJ>=@CM!Wz_j|lq%Ba51v+2Afa4+xveA%FkRpBtlkyariB$S7n9`5&6Gxj@DPgy76GH=I&(lK{pe{i0G*VFKF1CoDkBHm`XDA@<zFp)kgm%_aAWvR3jHeoCC#|Us3^A^OR}BHaHPBW*jvA77IBLi*k^`jHjimKDN|GAl{2-a%ff)wkg@$x)Xz#FOtvT7ZSwE2i+D&XD@SinQWAbEul6+*s!pmIX(c%T*&o$)1n_nZ^_>4x2v@cm*Z4h;RD>Z4GvZ}zQ5?-|OD`kpi3{%GX8=c#HD98lnc_i7cep*>SZ?%OYH>-9{2K==~>REZLQ_##yPztSsz{grhB+(XZ<MdHvQh!Gl*m;#6Y@*}`AZhu0lQw4S^E3wbNRi=PY#CEi`jnP26FdF@nPPz50sc265n0Y5<jzZ|cIk`s><F;r#;61-Hnf>7<L4toE51hq@iM~2=aGVF)S*EBK5)6>I}JHjH^tbrsdMl)PMfs15Uu!5LyjEaPd3$qI2;c>lUC?JN456x^uNfDq${J5e>U}EL=26~Ue#T{BEXUwcG)==`{5aQyJvVT*0_Zs>L5kZSnO4O0$%m*OGE)<E;+|#XCRc*g2!bF?(!9!9NF}eb6oZ}Wd3Two%E_cdERol#$}~i8lpr?83k;09H4(*waGDBD}Y<H)MGRS3lNtA9AmUBAYN|CW3-zfF16$_+N=5`NC7oQ+t3QpW-A_}z1tRpnYOe!6d=(wMw_EsQ!LOiE(>gD2%{a3%f^9t1u2@wWpnhIA^|-X+lKOu?bKMTy&>e9Z!{KL2x2}`!djN3yM4j}4hz*jS^PlYwAOw)k1ONgWoNK|TAz7utR3t}(vFX(^%?U~nq(Gz45cRR?|2H0JV7gqMPBJ_3;FvBl{e#`zXG8<fCZy}9zZDQR8w2V<10h{{W@JZ7n;g;{pF}4AkQlHP!$1i10`{$Lppj@5$G#JHz`LIL312c<kwV~qYCqUXZmOXH&2RPPl4%-)R7+2?4_S<`~*#M)EeZYM(#ki36Sx?jwPXws0qvQ6S21`eKHHHLyGNI&sG!ct7b-sIUk5>INmh64NjrhY7Bm2Pt~vm3-}85jxqfZT0IA$E+qJnhP$_Dj2=+U77Xzblv^z|24o_nCXi%J3co7iCunV|Eg9-7Nn0!30%R4WR?;|yp4%J)afF!DVD6I3M~Zj|rZ|RhQAk0}9BRXS)zX5)F9Y%kuxn}THxSGj5IMv=59Sew2hY;}uwW9OGel9Ogo~``kzNQ9AyowKrLAy*zH=S$NHC)S9gGxF49q<cKOvPa3#N2s{3KD(bVXl%Sr83~3QWJofzrEOaS<a$Qy8OQri6J1M@bYMDTrIFw=}(ajRT^-&%?@|_tNAiVR;5YSM)`4$<nm>8V5loyTOrl;~?l&5aYV3AV{>)Jz-OpnyA2Eu5l1_0r+#>R1oB^k&03eoB|3*Ctc@Y!;@(Uzf2B-Qb1J7G<fDkVXdIBccq2H2a^JtdC>v*cBFu2UW^AZHd94Wv29fM$NIKfMp0{lU6UzqD*X`YmeB%=(t&(r0do`(UjzIllJtWLWDBZ)w26}IC-#H?0sjwG5=mR=DyZ96=mRsP4GG<%4S>7Dnvl!~U{ZVF?to;vpsqnrRF5Qr+Lf?t_V;PB+(fAdAbolpf;Om&q&IyE<?+QgH_TobFqrh#Z+CB6VT9lQW%R?v){o!*)uB(->2(ji_)F4<pr~BC2GWbao-`|$UZ>CtK>6ZtCb;ROfnNM2=`Q!yAQvsAmw+4S14Pn5F9YRE!1FXu9x0(R%kY||K`qCdqO#Ul*}H>Vz(sWj#K5ilKgh?@EwZvci$3^q1x&g-mIu5nlDtbQkjn>7%k|P-vOS<}2dOb)Tr$k2LSNM;MJX?Z0bVb9Q&ETBM^Na86iFL3E1)f`n+4;_{24N|E%S%;T{=}3Nn1Ww(a<X1LNKmRN$73BPC?)Vy$JsR%zY4diTMmn3<9Sj^r$fCYH?F5v8i0fbr%pN5J?+=E0oI@592z0lgt^gr;zGVBpQs~8VI64F|;!jJ*8ZT6x0KDQe7W{qH-D6AV78kyPbq5)2k8?SBZHAOd)6sM+&;%#MWf^Xp%-|(kCv!R->m>QDEpvRX1YtgPBbq)zDYiwOLjf+q>gTQCn-S?cL#IY#Rajd@wC%1?!=aer?^OK6n@#jq=X}`aQvEv|n3ys5hL9jYj)!imBDMyV8ku&`na5T9O#HCY@LX;L9NekrV5nTjUKVJChEK;`TOH9r9J#812G};rs?vDBJpu^Ho_EpreQItFqG|jtt>fWn=Uuo|VsfHu?82&R1o%QCa#>epNO`d$uv&*X4EpsOi7>yeb=`U7NQ+Ua!g&CNNL+mws_Z#$&Xr^wDg;D*NsKcvbeA_DhOtt13iCq~3N8&qksXh7aZ8*<uijhVt<2HSMhw<$OpR{hM=mwiiOXhw||3HSM=v^FH3mkw5?H9G=~T%#ESktFP&k?JbvUcovROBy^Y_p1r0|o=-D*cvb`8>QW$xhG(DX-ceLJC7_0CJ%G*}#zVC!An27s5DnEn(Ve0w9hIwL+eKhM8OFo5Vj~dhA<4IDoAhBR%IB?GM_`{C!K1f^Bf*U1w`!Yov%Q7&NNy~!{YLUgZuBTHqj)5j@e*#QNQpaHRz0^J&N}2vwX?d4-T53Z)y6=u=S%!jO*8aTZNbZkEs>(>rP^8DH5jvay-3>z(3Y3^McOqG7m-@hi!{RKet8y8S@I29OL~JQ0lD6qNkB__btcPvUzfF{*JV_e$1Ae5R}7KzimHX)lVuqX87^Or4MyRhSM2Am_?Pq)oNGtjIm!9S6-77u9V%O+<V~RGAw|FFfSD3zUWIGULiTo)ZzW82aU0{ZFmb@_L-tjaUqO<u<2ve#p`-UjG^t<-s+wNM1&uaDJ|y{CP67RVL<&qRVbTpR70}9~^&4je^N7s+Qm?#Ro&%uEXsZKcQ^x2c_x4F}$nX5_d^0#kAH9$J(r*TnPEs)5R#iPm_GZ<Ge?ZTFC~@D#k9iG0Gth`hNalGkHOJtlKZd=#k`54esNsQTrH}49z55yf-zPA+BLxl=89|oIZGG42(NoFyC{R8L^77&_<i!;tNDO5)v+lCzP9@K+%7bOO!(0FNKVGAew+?Nqx_3p8buhE;J3VytSi~4(*+WkS@%mVv%%CJqkrQNj<r(*!Uik=s2auAe8x+_@O(fsg_ny-e2adz&XdL&3!n!3km-lS~4DIpCCZv%5B01RhxKjameVl$EmadO5GuYu}j{tFC9DCWA@fd24=Lcfx`oQJ{J3Q+|ly@A@o^?=`wL66Lto79mPE$Uf^(e4gv)HrFm}rP;6WO!Y*Uj@5)}Hkku-hiGXMKATMirCTvsQZ*J_RYUDa-nJ*6p;oldfVn9Z)`;<)g?R1;IYFfuoagUm8TK_S4*r|2o*BCOtzDX1afZ`)NAC?eNp+HA7TIa@U}oBzn^Hx*`0LqU$uVMO{)fILj#Q9!FkwD9ym_Nza^t?DRT0LzG8ML(Xn+ACdgQ3|ro9$%h$XZWlS>2lP7d7JfENHpItBspO0m+RsAYiL<@3NnY7K#Ss4j98KQ2r?wjc=i#T@0o`hfY8v_J+2E#6(f%6QrO990|B{@SDcp1cx(q$3f97?Snp~`|(j;<p9(}x-1*B6N`X@WL)aeed<0p$94viw!g|<VJvUR)t<&0FnM8l6v;YfAT8@N5c!M<#v?aK;S0otesPG5Ehz?*NdFI#B)vJlG&#Xa!xWeaUz7LvCwTWI?-R@3EyvzHdyzAPk{FZ<^I@MSA(Ulw8=OqWMaU)Fu9A)cMezAOjC@u}>~R@lBQ#PVgG9y)zl=rkDjH1=gHY{L$fUZ=`Kr!Q+Yjn?7g-dJH9aj2Isn*+>@Y1)^quzgvm?aOiiI6h7LvLm)H3w8Li(CKL2boOOEKs-O4ec2J)mxVff*<O?{pU%E);7mjGoyorJjP_+`p5)680J~)-`?6<e8KUzn_GM>u^Sp(%FMA8vX|vdurOw6xZ8rO|k3g(OO8ovwzKo*8d$unNbwr8RAo$&EjuI8)rYKQHhxcqZ7UqZ!-4q?lsBpp@L%cFaMTKF$QDIoFs4&boDhyLmVc7qO3d8dBHm6YWu{o+1M^qT*<7F&2v(R=kVbaYk`75sr$mHT&Zf2qFX2PVaIQy5=%`CLtOjs^AGY4T%>2|7c4#_4JKK(DbSCkZ*3(rrRAuXqG0OuLv0hpv2I2qOSeDTn5T=P%IW;_OLF}+j*Y~egFMzq^V%L)LR4c!r+gDE+mmhuC$o0b>=F&Zh3-XFf9KLS)#IM)@_q|oZe{KjxAZQe8AixEk5c`VinvZ!$_3S|9lSf8YXzX_Xuldq6|AbKIiOB7uu@9S^u6cy`znQW%zJ>TTZ<PwM<-sH>VeO;@!u)a*f78oLA0beHRAgV3k%cL8Ku1JY%yXL-3#<79W=OVjw4eP1JEel@%$FRN@nFrBXq>H{5IRoM(G4!=a&|8KGc+0T98fglm(OWd_C!D_;*`+_8q%8f_$QuB?MpE?E$YBusiIHE8EW{m`82Wl715B-j{Pl=Z<+4<%uSdqCd^D2$dSoYvt;EpRBM(8)jt}xHlB$a^j9A29k?hjnW|AuX70C#c4@Ht+k$etfJu&nZ$!{QT5<_2;RCwDEW!~nalwXq!0M`d8F@L6|_>rDsMBkL?X`rd}jQOzc<xAAd&xOfH%3C46>1}?b{1C*SZ}TJNGK&pSYB7D;RFFR?QMH(wicn^xo-4P6z%z^axw4y{E6eA}3h&aCcD3qx@=K5!xtO0PyXkpyVnN3K>NTx3@m=p*YuOjop-PWaT2IT*C@4Kn@PAH^ql!%~)*grUiVE$h3h&Si_-64#{ScSX#!&C0b<2=U+A8WXh(Cy-&7;~b!BHc{3@mMG1sJhbgB$5!#Jq&s&G9H&1<ZR(Xf{AJ?6^or)#ywMSaSsdlTdUWpeqE7rWqSWbd%;-zzjKEqs&tD5$%CN(>1a{j9yApExXtPE|F8snxgR+X{IR}7lApql$ub^0rZm}n$XMV#i&J2%Sc!TWk{(sEkoh_B~DGncm>77k)kQiP!NxV=;;@yP=0KgGvrdh00~r6E<%>WN|rmOT*%J=6*iwp=Jw@K`^Yu62DsUBBR6A3R!S;JWU|yo({w~up91;*a*nK?dB+e>zr&H0k_;B>t6P!P2E%kjRv!bn`W=p}6u5x6R9(hEGYP9BtGmGc_Kw#<he&L$$g27ZU{>hJN+H8UXu2I)jR#=#3LROcbkqi(?ue|81F?GrM^*#g#ckkSj;vB_6H0ePR>x3&;9b6NRDKT^JW_m4I!~KO(RLJC!*Q=T3DD8^_+C-?eOxo|^Rx*i;FbdV{*Z<8vG4Q!;UI{;@ALh^e<j>5n6&0BN%w~prVgbNR{6}JkWu*vy8~)ir}z$?Vtt8^(8o*V_9Y%e57$TNRt~LU&5kJIGOf3QgV7#Zz+S}A?1&NC>{ryV<`VQGAkB#Q9H8|`(KKCQgtmQ&^O^+_^Or+apvYlWpOPw?`EVa<?s%)pXW_hNJ4DZMs0xxF^ywK6sUIM~qBZMjhQnwOqdsuXaEPAd&>k#B^{j?$AV2%SIjbR_%H`CCyU70qDV3%+jL;@8<#{?o{Z)pjv&uQ0A(f^xjL<eO!90aw9DuK^a!z50rYQ^x94f(j+QMcaKVRjXwh&Fz7DnicM55JHg?m8Wrp4cBszSvN5w6n;>oiqi5Qsh>s^g;h3Om4kffUosp)cIh_oh*_4S9W<rx3i_5P`IoIn7gO459%sG*4kNh^*B-PvL72r&rUb#dBGg{bi@)UlP3wT3{P*O&QdV^q?|&2b8b|u_BT*(*@dwht{;-`|S2(Gwlvc*EM9O^zwRvw&xW!t#^tpf75zly#}CVYxsqA`bY3wAMp$8vmg$AM7J1vVZA_GdQMHpOX?+S5$7Vw&ruiH9=?|K?(i?FhN6g{fH}LCqlnKwHpGV?a}?3`69ffF@yWF~iddlizfJLhswiS61g3xD6Gbf0*O0fQjv}%lwegc&QN%LFdVi8iZ>5*%GodK;k6skI>8-SU8@)`Q3Lo6K0`?oJW!hhQ!)y<Pe{p043gM?I{qng&)ysiw5EpPP=RV<?4a@XN@@WN(<AR5c!*87-T<g@#hLsw+(pw0IQXzm1r3wVfuVX`52x9g+HWbgNh<4VgnGGv-Pps6QigT3FEQ7$3PkCm;O5G(sco<NNKsKOL!0-E%4QSwcL-btF2J|b4TkCmd!y0`EYjpRqHf1~EpW%K)3+IyU)BsWaGoInl4@95O*p}AlGw-cQ+tN&6r;{+*QZ|T<pYcqGA3<D3N?7NxEx|UmPHSG5hfT?u4gni*=i9(D9oFd{^}+K@hh#u2Zs3^?>vV^D!_`cOPJnjU;Iy@M`ViOo*jm|Vg4ouwATxdg+uAy9Yd)=ltu@KVwzeAhRU4G8Wou}59=5h9AKThj5IDJkZLRo5xV(*QYhyvYxKY_!w(gniC)wKH0ROd-Z7o}OjSn8SwlzQ7T7}Qy6+UNMTMy!+&)L=@vkg%wn{92YK7_4LvbCDPrf0LQ^#sv9n{90_h}qd}Yg@HNcx%$Owh7qJv)R^u0C7H>Z7pb%A@U(5?8?K|c4^JKo@8q&kgc?dZEctCQ6D_pT4z8zZem;8r90Fcu54{0pc6JZZEcr6#9cnN7QLka+u9n)e7K2iZI`w+pH{)vvV+*xP6K~xld`pg8hS7fTXP4qtv!aogH3E}X<r~j{eo@nB@jctP_}kZ_sqd3+1h1*FMh$cc2IYX4<5EwssP(s$Ywau&1`F9K)ke>ZS4SveVf_Vj_E@<_9R=o3G9u{Y-{0L;N-Tjt!03yvxRN#n6?OSP1@Fa1KV>8+uBSJ)3>m#ZQDZYHN)0&^02iWtvTmOwsr}!KWt%J%h5gRgJ)X{*a|nem2E9Ycc?d9*;+E76}Ku|o9<|mpQaL7CZJr&Jq2+NmI2iXG98fQoUa^hYdPNLnLnmem}$-V$^v}+R-W^vfF9oifqAwIF|9dYtASs&Rn7T2tD$G}Fwgf%h~|9dK;R^;RZ4Td{s3{07@G4{Y#Tj)Qggn}>driymwD2huMq&hxQ*w0oz=bRgNJz@2sN!aUn_uLOe=`eoUi*J?h-?Dz7n^i3EO$j*Li&i=kqd8n)CHEunlRwPnz>J1jGx((44PjAeL<BIbY|s5qWFUbH4ThyPJe*&eu&4H;AD*Uxjzz=#UaFdzmNA`MRt%U(U-sY0g(|$kyD!bG|O?9`(WVoUh)1_T0g9zAozy^@giCUo!!nzQZ}^>#{z?%f7ZI-C#EG8+Wi9ysS;rr$w-{?P2T&F93gThjN2AH1tLuc9uV!-Jsu2#DqK94VD8@W+%JB_8?mBRBrHw?v)#P*%`UPH2{COlilDA-7P+N*jZ9Rc7tC7e`+VY!LqvyQF<4<!Hyu>?_xLjt3HHZ^RhE?gJXdmy^G!8N)YeuVmEjOM9waDgTHEP@YbZ=-~(X)*u`!zemDHXZgzvufM|x4a5oP(cvow_o0pxD8+;M6LwB<qysLZE2hVPBF`$cfvm3mtJJcJl+~8h7ckfoOS(3;PuG8};GiyoTH?uJNzMBBvKuRLtr(phKPAzGJB_i41h3~=r1Sy7mO}3tUxVx5h-rtV^j(kiFV5;w-)npvAEdBDFW%+p_Q@H7>%QeH&Kd%{<_IH%3(3989O8$;g1d)Tw)^jiwm7o;D@T7C=fre)8Vdpjt#2b6qxorlqX%9QMt-2;f>6atQxm^JE+#YsretU5#?Pcdy1w_hTc5Yks9M7#!n$X$_*baNyxn+SEzn7icIuIZ4r8qD5gjVYwv`%--I`962Z}>KX??GQe!RftpG1EOLTSK$Gh2R_H{pT^jkM{EYr`SG26y3-7A9bqPm#Om+s42Bjnet^%L$cvM_GJo`&-Z+zy>CRaFB<~<3;UEWYoMVG@@VhbNcLq5A+TT{`?BpIw(etJ_9KYP`;;$hpzT;u>V2E`W%>6TB5*(ZvIg3u8tB$D9wzlDihWrX;8XUqFMAe5=l$%<rh=HVpM6;qeF#mwj6wUdb-;eSpMBXkAimnqzRXQ4IUZnN)<m0?w<hh&Xz|L@2iTXj2GQ~W`?3ij#vvuN@R}!0zO04TtSJ2`M)|UpkbUm}`?40gM}6?@%Z>wj^Z@&^7P>>d;mViY2lVa%Jt?0IZGdi*qU`ZQ-AB<peuzCt^KRJK2IyuD$ivwFD9pyz0QmX`m9Y)e&|!HPTZ1BOY=a;$;2;~@ToAJlvaxLjvFV^Pwqd#r!@P}08JiN2#x_j%jSn8i)+d^c?Go@m9Ask)ID~ll5F1-n5UGdQ*hc9?81*D$dluNvhuGL&1u^ju8{20fK0U<7HcEHDw<c|D-vIm7AvU&uLHvD)jjh6A1Q$pNWAZSzF<SE&?+#bS)*7-c53{k2(LL&eXJdN>(3cLgv5nCk>J3-M_Aa3B9CnUX$LK>G<6~=8d&jY@(aMvD4zsN(pucacU~AoD*w%gr{`O&IYm+o|QXaOpK89_r$Pq(C9bsFm1ESUuwzb|MdLB`>Hc9u)q$k;$5|FkwNq3D89=3KSmThe&@Y9d5t!0DQc!X{3M-Z2fu&qtehcM+ywia*{hI*83Eg3|`qik!>gLv*J+u9Uu5#E}#t-T8D#G`C$YeB3z%C`0$h_gruGxD&t8Cvs<C)wJ+kp258+u97>qds`HwNl3nQQ{ce+6>*H-f(4WEdXtP%xP;g^dZjhv9+?N<Js0mL1x4;wzV1B)_ht8TRRcQwzeGjrN@-5&DYTRdDvQPQMR>%5ZHf=ZS59_pO3Mvg&#*OcwE`qeBCqipJZ!FK-$`T-8DXV*jk-<wzV3-S3l0S)&oT5akjNNAZ8tBTU(?LVbPOpEgRU4$Jy2{fH-%YZ7u%^+}uyFtu4|P;jKyAS~9Q|Pq3|Z0@2|F+uCFhubrTG;(6HGGOc;plWc7*WY?TvTU(}k)CbSD_9dXFPq3{m(;ey!SGM*T&_^e7y<5<SxXj1aqH8Cztrb6sBRZ+xEofWwX%%cOy%^hCGvJ$?)bAEFbY&j4_C_(bwc!vLc9Lyv5s0@=vaRg`vE!tEx1f7w<&$jfCxEY=RPPpa*ZAOJYab=3XK<$s5qyemts025Q*3L!LG(PO-Yw`uSo0)Xn+EI~r`XmufLMQuZS4|>A5N)v3)&*QHECP(%fTQbhixqhMEM-HwP!(e&Y^b;dDz-It=VT7plmG*vg32qy9M2&K6tjZ)qt+bQSTOXhkC=6t>plEGKXy~;U2%7&p+1`iTabZx%NcJLIJN8hjR!x{uWNdjoL!UMfYiPUj7{@Zj@+<!ri(J7G|hB_BJhb8nP82nw4jqbb`tdDCnsu!nEnVIZ;lT`v*+#Qd?=Ery!c=0%<c{2>JrT3@+|dg~u#R;spyY6vR|&ZIyHvW`G&j42&pBb^49MAc(%QL~@fZ_cisUh5Y71gdBkunwo6(_O0ZxAuF-;J~paYdP!G}_Ys`oFU@LnlenAaI?GwlB4kR65HzXLT&`4pnm~dCE}MbyjE3a|e^bJrNfm;=f-z4h_+tqt$V*AEMEXL8;QJ)}n}I^m=-u=y!SLTo!9A{@FN9p;y(nP^6u?zQ<M0x6v{G&+&L|Dd&Du(CLT)+2{#O%sJN%^!SPtYx$gHYD(8X$wRB}ZVbIB2Q=m{Yv)2)}}dPupS&<kXf<|ic_z2J}|?5%J^?8M*wC3wDv2$_uTI74zbN;tX$HuJJDXB739r-0ypJ_AQdVsL(L5^$d*`6>a8R*|WuLQRq3+hG3muq3csyP+Z<eSY4p+XxZXGn8l%GGmAk^u)w$U6ShxE1j#2B-^b7Zff{TzSvzy$~CEh(@%0!OFE3kAxGHbm(c<EOG~G^M@hNWxPE9=RI^SgmTQjs$_y3(1%hcagKFE-5N{Qzx}~InD`WO*gFcF{gR7xEEkHD+w+IL=xVV83U1>>K0?DOhN4DgpWQh>%X&Hqf{Y5~*a8fDSkXY3JDTYQ<Lw}kkL`x{hMsibA-L#~un-+Q9Y|xrla;>W^1}%2=1}(%ui(8eZMXl_`tWZqNT|~vSJ`yCUO{Hl`htjl^gS~_UUFI9w!u~<KzE_>Hx}>}Ual+TTi+)3^C|3!%{sGSCTXa4}X+EF#OBnim5-mbrY$!w&ip`o5(>_JeO1x6%)e@{Tw3-n|xnN!)CdrQ$5H3nuuMbA|;csuJw3`&Vi_uRKeqdUAs3}{hDbrO`mL;gBG_6k3B4l1;A>O8@ykDA+sw*8xQ4*P4Ux?4~cPl9+km$MmH0}e-^99i<GrmPu;St2A5($_4Ls{J09(P08EXG8aF-5uixLFyq^X01sP`UI^BvY7}Hsy-t12;ck0m2DU|0~p84rCKt&Ek;gS92V6)CmYSmLs#^#q*M@FxCy1>MCjwQ-i80*fk3!bpuLB<^+}04M->0Vxvd*Uc%@QV3eCm*%<)^|0{<9WA(*g>ID=cz2#0kf^_|WLPLWLI*MVHa1_%s0mv5+NoXUstg1bKKoPt4`~juy+JgeZ?An6@N;zszSG5Oo?X=jnQ6L~>=L6bHjP!<BjOaIzdiZ-!urY(`tc#m7xN=f+;aRfiDN@mB=#b&UIOhqZl1BZBEI?$r`E?+1-jmR*ydm0;g^oreUKlEj-#k$yh8|C@2EcufypVB5gGuRek9C{}b)CmODN>!R^Mt3MUFS)wPBGI+d;?`)c;t!BsAk=W)n*9B(mv(j{0!NgFFf_BIY#@;uilevOR3?sA^yZ|JyTZrg{KQ;PC({MNcFldMdoI!uFJ?chqT0ap?@#REkwDgXE69bL%F>N%iK81U4)!@NTTPzxQ7|DtmYX}<#A;4JkRnpr1NZ@!C9Wx@-VaGP%_(Noe(#S&zQr^ja`z7l1$AU$rO{!Fgl6zJfVNM(bFF2uW@}Ia+Y`k_goVq(ADZqt1D`VSFCK33UoE*Y@CXeXQA$0PnbOOqTi$Gz)kYRxH{{`PV!{P#?EUanYL6{!RUpO=|xQ85j}_=MYQNQ8li|W3L5rm4Wm5uZ4IM5?WitG!zfQLVx)#qo{^R<PC~&;eCW+_mjx3onI$D8Q%bhAXOo)1J>v-{&bUpL(FWAWNs-{dx52cq)WA^woB=k&>bB)<C{fx_CRBinF^2RQK$r%ExrOuhBU0viQwp}F%=TXz;+Ze$bdP{N*Ygw%4mQL#WPE}2z*x_EhgOi0pzEH|KFnx`KkdXKBby5gAxsnxjq&I#<1@dabm~9kl`mU|srJ<GZ;H(GuLy$Fq?-NUmF}UES;ipvMkB%FYL#JuXBlH+feY}s-mR^2UZ<RU{+`_pRn9XTAr<9uJ!DLcr#l0Z?N{<;oCeq2731nHo(se#KMytNJJfarsa_{SePLz3{k0*cBGv0bnVYT5Zr@;Bgj8=3Wp1%DJD)W~N2GeAD08coIUX5fDKm>Qw^^AVAmd%ioJN`3t<2lVI7gXpQsxf7VCsO{-(#$RRPW2yXy;A~8GOzV|4?TC%Csx4UkEw86Uf|wRB!$_5Z}!eoj1e+q-n+-+(QReG)29Ybim>M(m=XjzyJg(;WzHpVmM1_f%Pn=0+=Qht>}IN&20>H?NHyeCDvn5^|^Ti#1}>|D=p4BKT`G0K0)i^JbqOD$Ef-vr0Aa~;cm}pj2~KC5c2`DPow-4EsE%V6~QNne~1YKQ~C!(ltfCX$dV1n#6--rA&^Q}%GNixPWTU%aHm~_qUI23iWI%Yfiopeev*C&*&|T?B4L(KFf_(xVd#_ekCD9;<%^Nx0>;@Gx2DuTb5g-CsOm_d_5;2bDYi==Tg1;tgg!~{2gEOc-uyw%6mQtq7VwBm&81$mEpiK8G(`ACUbgTD!~$h&s6$fJd#u;^+AqPAVv4249pGGZZ;V@N{3EGf#<j|ayYW00Q0;jqnZWtW5aiCdwC!Bn8vUG=tiI8pIj;eS!;IE}uJuDLK$y|S9EaadwmpOyooR%ac#L&CZ<&peY<;)_aRZ})wAPL)zD!o14gq7N${M<8b#06)sKBT$5<0NV02-B!awxDyrM7UU{Xu3?*iVI;+TfnS??XRVGCIesfTBj|&>GaKkp!%#fr@ge9yR@4y_L{O2prZznOZ2*TgdJ2TC9X(E*T=~k`kJ%g(iCo`TM(0DWSFyXiY-fjNb>FB7>SA=wJAS%BF}XX1n2n5x1n^QI>`I6*iB984a0HmuPV{);@|ZcbeTx|6T=?T3JqF_NNU5Q(~!?lSP7u0doi)$IMbNU2~yDLI#(umKUOkOh;S4t)&i0Q9<gE4)}-ffCjS}U>ne^^+<_V8MV_ofq|}f?FC%w55qW@%WW!J={xCP-c<$qS^;(*y1qwxWc*u8nT+*CQB1GlhWJ;vYUndkvO@DzNRB~K{>z5&(CUdVf_Vx=J*1eRo`%R*TeW08ggkdm|6~#>j-uhf3?ZRtFl#}qL5gnP!WJ?tp)zKm*%R64P=1yKx_~Ko#Smdg(YM>dRqI;rkic=nZT^GodMK}p6jX7dsWDEp_0RLA;da*oB=)caXZqr<R5Wh^(FZDf(VC1G9gO>%iM;4uqH6xW{)TlrcB>dl#I&4e*Y6gYEv!?}Fb#du6-Be4X&N2X#`!kRPvSgB&64IGWFJHMA*9HoV@)wzw{f<2YeURp6-n;}!2ExtmDJG_x1eCQ?g<~6Z;b-xBS0zwTLCHdW`7%H`rzr2*FzvW0NU<H=};4A=RSJZs2uu^F=i-kq5T@Fis#UQ|LC9GuPPci9!29JJr>EF0_I~7A0fpY$TGE%pSVQ5@UkoL3XaPCWfuR$wx48!Jetyn^lJh0Wx6Lq-zlnK5E$20+|QBRJtxsg3%cN_$MjW!I!%Gon+}m`v=Z=r;Cq7TPC9O7vE?W^m#>CviPCc327cjHww!$+_FT0sC*~v?bG5e8k=znpRM_LXN?mjwMUR1faFy@;3g<7ffb);TB|>-pv}=Y)xyE<?S3r!s#&`ZLAhMAXA9LFpIG#a@7#hVEs-sTNZmK)RQ{-4Z)Lk7#_aJ$jRCNPW_qri!(kg~+z)S}*g_wq5PJq~Rou&#w!N@_#nb_3Q88He>$Da(*5-H+UFuOox6Eg=)`VF-E1}$NLVOZ%p>P!@Cg?2OuD7&C0+VMJy-Unt0E%o;@828VxIHY)jMa)A^BXG5lBHjVB4Ma9EAA<?I2`_~du?0+D5Z#G62xb?EFOVW>%$2OWKv6CD6dDUX(N9%JGnxYycMDCW#qa8Zc^X7RVk(0f24V;?CBZBM@ivlZ^(88r#~PJw41l(T9h~_Kx&Kx)EIaE3E0u1FhyWB^fTpi+(d0#(=zzMap^8$=?i(vTf%mAPWDhleF+}<=Y!CfG^!<hHVJ?W-NQn`3bK3)b`;l;y8$n~Gw7-~n2t?s@jY^1RN%uUoJ(5O&oph@d)laqRGf!+6I*YRa+k|>Qr-n?V!vb-Rm=R#yzk;CD7fg8&WsxElgJ}bz6)_)zc?rZwVm=466vSerNV<Mz=oZZI?w9c%zqA^BE$sn*7g7-Q<y<YJDD{p+Usu<Gz4|NnW9V;&DDWHiV|5T!krI|T`cYVoQCT*nX4e=KJbp)1W4c28+26P^D|BNN73|%ZNx)|P#*O(H#7C+zUx7G-l=w*=CshPdn?BKPQdB|JrYsB}s6CIM;el$;2HhS-74U9P(c8FD+~)Q)2GQs?w`VAb!AOa_z1m}a+Me(#TUID6D6KMM;=oL(Y0Az1Cg6tBuC8r<S~iBBH=X1XAu`EPGzutLr53#)K+!_fI{!B9K}5b`EpkqQJAo9j8O)y`?jp$ua%W?8h>B7h#u{fmeqpsZf~<H4_ryE&`PwgBFFk*v7LAkv{b-^0#g17CpZ16D={eN8#sO(d>p;~ea)eMrOAneC!0Z9BjhLJ=w6!w^XtW&HJ}{#}j6jMf1>23A$cng6ZWej_kRl8;;F-G!a*!elfcX`~k4Q0e>S{Jo$90JsP&L3We{J>)-R~Kq+dV#I3qZ`g$EWN+5dR=0Hf-X1%B1U21vaHD)TkEVH&|6s;y#qz=PEjYXmy{f_z1*mDsAIc#RS23!EJok!0?e;UL(No&)R&koPywq`)r&F=dUUCoJJexePHjZW)%Gcmih-bqY;P(NQoz!=3$&^MuwGJ7UmdHhXd=6RbZWVi%lgB#qCt_E<M!3uzs^<Fpk<_55g#-PJ7hY);?T`Z`Mx=lDTK<&$EYo^wXMt+R#rYj527a9-Q=N^?6p*V|7BB1tj#!K+jbJY#@%cKOKBIFmpi6LW*brCL6>?Vp@Z_0^(a@o&(eUPeZi*ldqHabUlg+RQ25O1gF>K>qI=jSm95)>-C3*uNkU5-)6uf2BV-PV8tKsi9DxOD@u=e?s%*d*%a8u5BNmB41(4*k|%Nnh~-EL*BthQ>gjRv9nLDn>K;?|<4|w_0{f5>1)u#Eva8$Wn;-&;l?W(SDzyX;FxxP|rnGx-1^6Xr@L}JCvKvSuZ8X=}1sa=VSkL$JK`3zt7g&CyoqYadd5pgdGJ6#)DGzIO4Dh?1!G<6D5O<x2++P!Qo4jT0P!L#J$4K^9HxOMPa(_($@j6oCY%jx?i$};i*KDm{Q5961ItBQ>T94cGF|>T7+O(*tI){oX?%k%-z@AcVdJN)`YE$t?IDbfqo4ndYK0zcD;TuICx={>f$ctdI>+$x!7*4ClA~XO`RQ)o3o<mP$wQ+{%k-^Q<lxinE^D5N<$3`pCHAZV1Aw}-%W6L<DxrbJnv8nYTa~iOrzz=>zPbQ{<>#w2xy@ft7LtZ7J4***PfwvyflwvSDKx`vs2bdcmu8_K*iW6*grl#~HY?}H}3y@lW8KMSK%sEH(E|JmNn(i_GDOCA0iuwW51Ihdk%ytl4iMb2rCWsqI@gx(yyNw}U)NLQyn&){OMRv$zLj==;JXgU~1Cd6|SunjH(_1wd1?`ifq-`qKJdZ1YOat}}5`F+?1Bms++yZk6#1BXbFR`qe?;Uhw2!cSZT2Z=tX`;tpfcX7w2p3Xpp9wa~^u>=WV2%JH3DEKc5AJKjT|RIc^~M0v9?-Ub^F)uBiWp|!si!b2=y_}n|I~rckU61fB7kFPEuvarazGqKN?L%??t^-&B3hz8JgoA-W(b70(ArBM<EP|5I2*Ls&--9r1~C{Z`awTi&@BZ$S!TSu3<llq82p$8@bd`BdnD=yrun~ysE-s$j}~6neWxhpZ#~n@@bwMRXnNFe1o%V$@}q{ix*KeYWkSqiZ#U#e4R?V5?O%S>ppb^IjC#}%^&jpv|M8;+g))8c>QO@-Kx_SHJ!()Ge$?O|wSxBej;!VA8$V4YIS#OYWAt!aS{S}5e)>XPPo&7g?QB7RP3aZ~n1!Bd1i|X<XcsU1#I|m43wV443M@=>cWW=#Z9d!91_t^z37Vs*NxuPRUc=A(XwEy-q@Io@<@0UQ6{E;4YSL)haAg>NE<orU^`>ZS3+DH2+N?x(6z$?&fPQEdHJO4E2iQ`<zU@SHW-=gUfi8&@Ne|W(s(_}{?vS1xMy171Lp?oQ>kWK&!H-H5GQ?MgAF{nelmDn`7o7|}DmesVpVeHdKDfRmXlN?LQN66%Fc8<Osujxg#dFma054~7)taHI+kj|gun!{pE}<(|ls+{$r*5)uY1bumrQSIDXou_?|6&6A*+{o&MHlr9(+q$+Fys5tHpr$JLrsYUlLO)?HK#&9+MzA?iK^2SQBD#H5=>LXBSmg#Yommw)Pm`rUhaaMn?Un!z?uTz0LeT8<{c1kBgHIsC@{nvYFngPz9I>&MA1!PZXk*1b5Gkqm)Olf^V-w&5*wXPOS;?zGYCWvq?l3}wt!m-(4si+k>*qs{SM465^4gbk=qm*ZklcdW+{kyNFuQ|i|5+hRX){grjNOq_X+Cb_Loof;{4DES~Y~8>OBRb9+Lf3ubDn*9}WCeuOIMz{McS*ftW!G_^DoW2Po>Gb=;x;c)?x8d;!@Tf%}XEdx7~D#5YLs1c?}p91q&}4|1a40MkdSNNx)i@kW&S4zkw*vxb%!c?(Pqh?7XsSrcsmm&hW4P`KM!)Fh879+E&VW+9jt!3;%;Cw#>F^tck-0*~5DCWv-+nyH(is5sRdGfmSx1ITGeoT7y`j(~Xt;t!<G7u)%YL|j5<dVnda1z45D6`N-`e3iG?!o6`9-5V>;qkTC0+fc*T!A&dSeotOjaW`<^{75(ZBd?PPodugi=bu2uKG)v{m_AUtR0l|%seg{Qi(#{Er5-bQf+;d_D9_P~A#N~BK`cg!O$D=At5Z~A<^vLA&H6wb0`ve<P)`Tk@PW%$uEPMi3+x@j)AXm!y4^l_di_chqT&K!=}2*D!)>iDN5dFDsbEzKTb=@{G2o4mVn6L+i@1G6==JLkAcg}vERarStiPiUf8RDuDrgo0VmZJ|1C@!%`24*LrBzYtGdhaTzir9!`4LDRLXz>hLOP|nBE;ukJ;U+&@4(-t+GKpbMnl(l3n4x)-h$)vBKb@aMeA}<d|n4cEn+A>?+v0Sk`<pTC8nlweM?92`AmSPBSoHbRPWN1b82?OmK>{R1HX}Kq*(m|h;zhHte!u=DFTs#C`@0c4?$76re;&fo(yb7TH%92_D&!=5JMsRWDu{BCJNb=yy2rshwN*CT|>eYvVRHUG%*yi8$r0$f=SrOvTABJMeG~3W<}-tmX0F!Qjjl!BqMf(GJWwJv9|!UIl(DnS0I-UTt)1o038v;))o_s`U+?dlH3lzMf~GmZUq-e%*cu;SCe3(X^K*Wb~0H6cKIclUm^QFXj~dZjuW{Nmyz>3xLZhRC0K%<qql8kswF2AhjRWj>!CxS>ka#1ky^uXn~{zN<WNn?{s|ALS;UNNhTMfLAJHC6MzASrAVu^5GZ(~kVupbE0mS#jj2%KNRHL7eqMOBI(4_|*q3uz@DtD2Dd7PCRZ$%?i`*Phq83ar5Pnh1CUYNJ%b{urJqhAQ_=po#WEg&|Aa68<zm_jJGqZ)|PNI}$&?YbS?b(G6hQk(YYZc`-98#${T-B~X$WHj)PyoC0-Y2t{SFmhHqId3f8AZWq}4m5kLA+G7-q3tb2VI838J6b6JIDV>ynW9n{O&13fnbyaau&MH_f!3*xX$x%gKJ<zRKg%HbHd16_8yjvqD&?H({!t&bfnYjd?qvML_HJYgxO@aCj2}yTmkyU3sz%a9qcDDXs{fDF)0HEym}}ZU`)J0!j;<Kks{1J`E3fTguJkrU=u@gA6s1-ep^nJk9u@jiM?3=dEIQ$9>c%^?t=E;-wv4GM-P|OjP*^))9|7jRgP%C+J_U363QUf?(blK;6w2*`_v*b^nlPj={&{J4x0O8-w8PQv0N<mgr6#`u<X;@<-*m9Yzyv+p$`%ULRJ;=EV-#`sr`<Vei_VharYMdSRHq?E1iB%L%CCev8VT;kv=MK6{4|F^Qxd9L#}+btgebUnH=ymqJL6|K1cuQH7|(!t8^l7S#0o5P*=tqV=p8t1m9^>>xKwDtZuc={%OCSA{OpE`ok-Cyx3<xyg{FnNzi3V07UAb7fUZ&H%fJ*Uh^8a8OlV|jmJ4<_rSnr8Kk<}Rx+AET-Rdx)vsuV|156c&r69S-)L~%60#MH*s}oZ6!gNE_)xDTQq6ucWxgOb{pnMHdYN@I=#w9KR6M8M$Y=qpOQGBhS3Q_Pc@;Uf`&bk*Ar5-WEdDI>B99lD+oW}tC6fcAuB2q*an3f=#AO%hCZOfWITFgVH>0U-%`X+vsL0}0|=}+mp$!u*)x-_N!nUS8rl#b}t!GIls&_1e-E}hQ$Qt*+9Hd0NxZsH;kA|lz>kAnL72+_K<bp130{wb2Nt|Ji{?`WSV&-RV%1b9`lgCzXC0O5g1L6;iZf&spQw~cW312XsD@UsvC3rOgSqqaa_q2fj%=|N2LAbTLN3n|Xo9r=8PCP&uq#Gb^Yp11{>pOJF)NdCNfM0ymHdLkmy6a^z?EKHt7VT1FkO-@U!3vlg79tn{vSHKY8ir)4d>E!g}3J{tHRC)5q+pTP1xTf?|<S381p)+}F>aBl(?T^OvMJgRm&ewSm1$_@<RAfyE%LADUnb~w8aoZgyG{RvMEc23kEXjNc)HdL^(DD^W!Tbo~GAW291)2I%%hak^!OLzp2}_~iC{yH*GSz{O)KVk8n_AdoCUkKgXd1+-MDc;jv!!HAU+GcS+3E&-S6N*Ujao+PYip!7D;9vg%Mr^|pr=Ifh-IX{tb8iKh-GpY9<gi${<A1GVi~DB&_@U(mJ?lg#PTBq&LO#J#3Dy34GNp0eql9I8L6)ppSG%z%3y#873PtOjq<@`q;mFI9;qw>{;k6F4PYOBo3Iz$?!r7m8LgW<S|2-WQ6rR}fW1Z<XoMn1CSgTP5mJOlCZqK!_12(ACRKq=MRL=~M2<)@!99<ZFo9*9Ba#VP;{@*xRU?wuA^U0(9+6DYX5oY95y_{3eo}--Bnss6fvXY8cYvNPqHiv806ak-oVOIkrPsUS=*XO;87YLnZ-Zb)2k16LW@MR<f&}=2X+6NMY(Ac7Qy9@~K5jA}%WNj-lkX!AvvHHzNOMu8`F(LPmx0uNG8fxS+M}|z(Wciq3C{DJxapkaIu`}<Iv2KQRD~gVodfoaf@5ce2+OnQYd-JvxC#;eKlH|YIvhhBJ3j7!-{<|~hdoaZ5KuG*2mK1IV{#D88W0~+FUXPCUM<zil1lgMhLP8t4m|QYrCcG6yv{)Ecr=f^ipSvo7Q-X2p&$mu@W|^k5Ff_y$V*k=)|478%aPYn&Qzm8I+6>zO*z!2zW(twyYZ29h&4r<SU!>!AeP6fBl*!j{*F?r#wj|IRvr0B{&gP75s2-J<s&H^XNp2`d?c+vw20#)c?HDqI6ji!^;PzJUPtmM_mM=>kv!i(wMkL>L{Ifk4a?-Cx`HY$#qm*v7BxkIqNbMyS6&)Aw^bTyL!f3+)-Vu6f30DjmYe6TVS#_@0;ORQ1m02_4uaUPHLTNe>wGnIKC3j`gTU`fLqa_IK3-`!qvg(cYk1c`wMci?&;kO@<5|O45Tmt*-?ZFsz8bnbt2C^Ez=ul1SrA`q4dHsSY`E97S>qG`)MZM8o0du_#u_SvNG_%{RMK*ld^L2rs5EqgKv$(<CWz@$Lv6?W;Xt3MyT*_HRl|DV!f!T-f2=wB^YvV2MX5)d#x?)QK0SDj{#I1687XlMqu$~fJt^|B&j<EUnv|~9Gl&(XA|2y*|Hy4h=?y5nPD*$G|0q4KCpIfet#o1dd&2YgWTlY_xY&>qzh#vEnqZBskLGz?(E1dm-rX7D9@pTWJpU^Ly6VvS5;WIiFo;3K&|HtVK)gvc{g%g6<d_meO;M|n>f9`H8IAm-_Vs}WsEnd!TvU?lJd64ws-a*9G;TpkXvK)N=#+$k%zRGFP-b@1gw<9JA+(lr)Y!dnFKBCuf(OuakF>3KYCGo8CR%j@?u1u!I+KE~C`d^(MG{iN8K;6@b14`I++8mPi%G#y6wpreeM!Lsr-JaOoeIVS7xi>*1?Nb?t0?#Y!tauT*ry!|s^wBJmpa=^L2Pd*cnbv=A$*P$)N?9$E|-Fpz;*Xh(3KRdK|zt?AdnLJI2BCHrQi$TCVMGZP71c8pe=-3l7i_@1*>u?I7+9{OTk4_a0&%8Av~27tamCnmP^3};Bvea6oa`%TtUGh2-6A?312%E+;J*scL%uju+ttS^g9@%gem?Zp}(9$5shu3gelBOQ%tDGr}zjJDGUFanE1xFhO{(?hSh!e$?;Kjbtcqs=uBAPtRSse4O{YxlFZ~!&qUhyT>JxyANAoWha&AEXVZ5}aedhvthVPk5+;&Ai=q#m>OBFI!kC*--?^`zk(}0w^Z!Kt%SyJVo?<z~QM^zU57Na;x!9a<icNj_n8xVd$l=eGx(p+e;m7y|fK5BBp6P?R(bt-2O#7&$W!PsSO?@*<JyxinnR`m7NPCZqOF>6!zua@s0$Pc*ZCp+(y)^G<@6~dd^J$WE+F5?OO^?}zF^Gicam4Z!?o$i<@qyoYQ}?NB)cSEE?G3))Zh8fdPoi4W4S+u*G*WP&4#d|sf~Jn91vIqFe&@1emTTlF3-0eIOBM;WoZe`p!=Wa;?=-*bJpGQAy%95w_s1H-c-yZ8eZg9#x>eMRBX48rqCuv}4C*E!_2d`4xPYpapzo}E_3lHtJqR)rIa6sdSZkSrwSGpu>-izH*iU|#dy<wYN2>Q|iOh_rOj>HB0#dy?9|_7VOPK?Z(FZ9eYB1{I=2&AeV~JnsIs;7WxokuR%2)AXBMDD4u=0Gm$uLs~OycC~wyj7z5$ej~DWr=TU}#EDAzkhlI(z_6A$^2u9?()Ba{BgREkrYYjraWgjt<~^D=qgCTZ-?k{Xq08#rM`#AXXwJo?&U{7XWf@^(*@G-Aq#Zv7cX?fjph_7zB?X$?2T0=x=QmrCw+1>6~|f{Y^C^nwHln&CRG!pHU(uPEXI>j8Vj-ZQ#Z=Men^d(DBJ?pzCk#l=d>H13<F}+Fs)#=aV=2aG+M3mXE7i4pX`6R4TW6YaQqcvgcq2x(v-olTUI8Ck)C%IMyj#Ft>0khw$@x30HCo7tbY}IMgBRBUsldSk)nzOe=r<>OmZ9d`Z{9G;4VPwQ_*kP{&wGCT?9@)BNg_@%QJYSTf~hGR?0IWv)iXdz3l1z0B-OU&lX0#(m0cmmxF9Q)aa?h;5KEXW{06%;{9^Ok~hEUG?Nj4b!dbF`z7r0jZu`USWoxTpOb!GH8~$j3ggcQx>kMP}T0aeu0}`U~69q{Cj2D%+7$wDa&T|7l?;QiT+;JPG**NvYKsW-@f3r&O&RE_6L{K=lFlW;M4o0Bq4?s_n?cugt~a?p4zigQM7Zo)$c|NbaRb=vp|jXi^{%4D`(u8YoW{a{Sn!t{6Z;PJT{irM{f@Hi=;kUnC^AlOJ_sTTZUTZVeowR{$f5OME_y^A>Y!^S}3G{k<#FvR@~3DT1{QW)f^12n&Jx55;2t&XWYVXX~lgt0%h^c_1t$HzoC3&1u)!RW-SU)(9b3MUrYrR$b~%{uEDR#T)GYQ1GMKXvW6*cOY1aQD3_!-;&zoQ-4etbZn@$@xfEiiGV|S7LNg=Ro|tYiB4ooNA!t1U^SvRw{LiKewEPe0?l@bBjr8J~-Zv9Sglu0R1T9Tqo>uT#5>AkJagV!#zx2e(O&~GJNL(PF9nljeGk7SA46KlA4JyLVebx{~QBFe@`8-PW3ok&!A9t`J5N@=mp+%$KFAo+*VRs_si1wXyR<t|8UuF%|S+VZoK{9K+&MN9I87{Nt>a1e!vV~>VN}ZMHE>~1$eW9~TxJ#ChSx0qNDR=2|GV6lQD&sDZEVJ(Dta9!$RVk~D#a3`9)*@CE3b?$Des9U&KjiO!@;7ih{kBY?--42klfR|qZ;Je_iQkZkB@97dn7b$#lf62iEKbDmp2&X%S(kWSyz}}ppwMH40+uX?_!DWO(Z81nkCtn9O$PrO(lnzL!np;*WvK{{k;`*!L%~L*B>L(&nZH3aMHZ0Zagi5Z<d2SH%j33%BtJTS3Pe35`O$G*mT`&owXF|;JHF`i(Q#w-aifE>{;7|S`$1nHs(?N^o(W<)edFl(=(w&Htm~~peRRA5BJ0cZ^u+TZzAx{bo~YyuUkyAx(WqdG|H||9#PVRuR<Nfh#uafKh)t<y8R2o2Bhj^H@+6vRYKj&lTAJD)N8{5$y7EC@m50X`=}3aKnBgP{jYl#kf!PmYZv}d_Lkfm#vEe=n%1PmSz}{BEX-TH2l0*$px-brwq-E|P*bk3RXgHGk2_-!M%1oj;NnoadcmpXqa=a~LNEtKT^q5J={v72SNT39m^B}$_0a_6+zwR6<kYadDS`yE{B27eu04<VN5kv)~xX_ZefXmT7RxvZS+X#ph2dWd`9V${s(mt6A>6eF0g9{`>duC<<Kc4EOy)##XScMczduJ*se;;|ZdFUBHb4Zr<)BFp>L#jM?iv#kgy>8e@ZgGi9xX~hs)PDxsHRcn=YRgudh0v(xC~rzjx8w&i0>q1z_<g1aCn8+;eYjUWp*cZyUV>N=pq4{qDUw`MKV0{I9wKsy)_s8PL6S?fhU>ofhSTei^K>Y*MC&c!f2NknC0fIE=lckKV1|?*Wm-$LM$p<S$)>eLYYPy~iJ>K0M}c@T+2kc!l@gDyI<-XWCV)Rjl1sFP>)!Xl(-N&zy<FxT`14dFEzw#m#S}$pX%kwawJC_kDJHLf8m>=_k2<yf=}>?Nr|`ag3YFg%&+DHq0`#pE-oH<Qf_&g={nOom?o3gywB%yDvousu>XT7iwA0|~<(a$zq3bDpCTD3|nU%+xT=f#4$?(di2(7Hn<Sc#qeS~l(e|?G1WGx8Ps7x;jhwvi1-NALMtj^#pZ4lng)n{-zz*8&p8JwlBJ|8^J;DeX>3}yqrk*cLLD9_wQa2Jr|;=1#7ljm!TU@dBKT{kV&f+RP6l#A+C1Xlq`E~-0U_nEf_y{K+mU|W+0T2xmqraKPY7^H+HEaO~EcZt@x<VnW#9%NTkVPjG#(-*IHKLGS-6*i_N`h0oAl`;JZ==~~eOlivLoL&I`_lgy<za%5};mIOlyRu|@<}f@BvBlTGWW8YJX0v8vDSfG>V~cXBxRQ`2Ab2QPgo1}1;Ib*F4{{PlBTg=zW{P;E2?LN*hA?x%O{JW^$Vn#5V{rG7k`B?Hb1$gl*xeL19vM-63{Koll=QA@imtSx#}8o6f%uY`ufa5`W{O%!Nwj9BQh=Kd6a<v2dU7<clxfnMnfrj-RgEqIFrMlNtdODyIs{!Jvl)D3bt6IUs$CD|wX0J%rqUXuXI@aJbxt#>-aL-n*8!MFD@V|}p?g4Vt4<H87`t;A0;Vy}6|7zoBC+CNyEIpcuzKRGJ`m9yJrNaA44v<$o{&8dlx~WANN(x@dE`pKEi#(RrhPTWdE_+!uAa_E-U~zzq@aNgK|f8Yf4Uc@0y`yL_rg`(3qzaRy|590&(gUUz6bFQQsP}lFL)hiLfT-5-GxNL?&upov(;EftXpQV2oIAhZi=F0f5(=?>EQ1m>JEat=_5fA(qM`Zqe=QTCH*u-%0&q`zM&x&;O`QGkCyOFuM4q;;2RY@TEYpk8TaM=_)FjJxd|lxHX>iQzPzIk^~^g;=5Co>LmU!lx(p*S+>GhA?ItvaN5P%tU6=0BW`%JqTQm1^$Atgrkr1`<_bHMkv<P__Bj?s6_v|>w(!Qc7L7wi0@DYDsBzS8HpOhv<7Qv^DbF7XmiV|dSRUww(FKw^nCJ<VdJU}`a+Dgehs6>wCZW-a1V?cTqe<^sB8!w5F?iguPkZAtpY?;wj)<?K+(T(|GofJH}3F*Es1zl(d1&d~t@s2hcsZx-@;$I;e;4k@6HzC~=Xri?@Qe|t&d72}}JC<X1w3dV-(hc!C{?hhUa-Utuo+xh6ZbGzgmAQVrW4U98Ea7_%FvK4GrEAblXc6KEQM$}re=4~f7>rko>_)a9MW$J1#1N1P)>!*64urm8F$+&{z-d+G#DbO`lb(Vtg(wREec<9IxSKwL5g{vZMbRfMX7dS-<%i*E!Twubh_3icU%9yJOZZ1kgrF~4%rOd{CE*02)l+BS?>vGJlkk+XLaYGg`bfd!XmRflKjd$w{Jko_qRih?Mu;3z|C19h7cTbHF)Aj?mBC5oPy<6eBn33kBMJ9+vcfl^APjkCT9%K3nnua>#dzgoFx6g@okJRCy=;g^^!XQQBXM^${glokl|Pjhg1-B5y`fYFSt|PrPplEYzl0FwXytZKQ6uy)%?b^92NLv|m+KQHVQ7g0Mlq5QA+Z2$BhUdSNQC?g6*O{nU2s+>LRKQ529sv+L<e3j4DPuaPX|^;9@y0s>$pff0Au>1fYaxfawO`ev8kIzt0H6?6w*hRW+SIUcs;Py^9j)rf4h<(fkcrE=yK8bYF3rsl>S3k`As9DMaZiq5jO(iTCX(Tv@kgCkE4Q$2{D8gmiMfSvbvxp@H+{A*ohY*<&jUrUh|=s9@P703HwmrtZE%9i3g<!5s2|F4U^@V*?mzSv^-Q7s-wZMi>44rh1<2lE`=y65Fyu!3qi96T<sO+glx<d<kN!y^L1a@XNuX4d8X1@I;f%~{z@Sj0RFC;#7`02^jyJBPa4EO#zI{3fuAI-8z#gYiU8<gzp)@rkfNa|sYkh@-}CJes79NGT=WFC@Q|Uzl(QCd?zG4d{y9b=7rnEPD?@`TFBg!0_JSZLovwT-blNCu32k^9u)`3dxdyW6Fc<x6ba)8S{ssxTI-|JSJB<xw6q^E-gT)SG@IpgOjx_{%3;Oq%13hEubF<Mkvr!yd0|7qLCSw^mbFMJg;P2<iS&0;}5zN4v2;Pw*c7QQznc@#(4uN?e%tEAy954-Qn<5=4;yW-ufjCFZWiV6gm|`4K#7!{e>mt~rRYLBAIRRo1QW8C^IM!T66x5RemEzK0<0l+bGvLiK_#s7+`lg7guO5+H)<QOA{R^m6XtYw$5BLW4S;4iZXwnoEB(-_d&|;?8O+v{<KbZzxf0PtzfUcqCDl)-z0?`gBCVU{GW?dE8n)!jdX!7g8rJ`sKFtbRg9hhto8;Pk0<|2p-NYQ_{w>212gZrxCHWND-!mlALnZER|1*RN`GQ^Yz(+)(NhI01pyNJ$*s&&&G6d%W0w|fb-=2O5%L*iwmpy2~;8N*kmrYqT;2FN?WE<<up97t~uqq7FsV3%lRSnACk$UY3%ernw+Fa;XHYayA-!1Mx<*@&i~0UxmsIm^K<ZbWthrsC74D2Ehr0Zcy-y@<I9W+jLf#5@3V9mEx4+-OR<#u(8c#q4NrH^?orXzJufBPw_bs=kb(uYoy@WPSxEp@}Kt=riYIV7h|n+=M<NqelIPoCV<KBSnrFgi+f6qwYNb<G9Mi@tGaXYGv7uZMml5G{-5HEm@XJ)&>_jNOIB7auV6V&25>L25-yGtcsJ^havRhz)_AO>e0?e=*5A93oW!e%HdD~7a$x5$Bz;M2gh;u|Gw|NH+^?!S4w_=0xM5_^UC+WUhEkWN4ALh-T2b`pNpUakDZ6-DUjQJB3+V(ZTAYhh4<n#eLue8SNPVm;MNb|q3^-3t@>0<Z}mJ@xxfkddB}DEk}f$64gcj~F+fbHy6~g&MeoG{J_BxDGX#<({9-vc(cs`|@Ou(IcJX%rO762eu_VUhR~~`OZNG*;7q1v}9*`y2PApdCD!3fm27mr9H1!|wYr7FnuKX;2lE<jD-Sf`Van?oL0pGOSL1Me`ALUDXpU-zd*D$;=%y+;xIOredJ0J}Qe>u!|fM_8`E!aEY#c=<H!+Zz44-W1f<~!iKaPaM6+yR#?fx&;<?g6F+U-%XI$~#_w-+^1|0oX+cusd*aBOI*92;^(?m<tvDOu$(heow*|FMidnPFpc*EB1AHRqXR{`9tu~2e6&<aPklwd<)z8dpL=`3I41;7?YO4@8bKO>NKISCO#`)9BYSZ)Zu;x!(;yoo_R4GJpUkO;lr#D55u1a;Ou^E;_y?PCfcZpMW0bFjlCQ$uQ&w60)u7mhLa>5Y&(QR2~J`s;LkLiRSqE#z)LG$4Oc!3XP<`Om6vfi`U5TDQCdQt^^HRtYFB<_PvjB>Ch{?P`Ch<)ZKzQpUD&Unsh=O>y0GM7SkJ>4qKMC;T4ncP@%l!7)FXC|CU>==T7_yAJrCZx8-s39t@1%Qct89uMzxA)Atsd-rb=l;RSMN5`ZhfDAijmFl=ukr3w~GZ=Wp2gYCiT#XV*AK;=hF-kvGRa50BgcFJCvp(cxd(pY=Z<yH43i=x_v{Jv3sYL-_CLpMYw;3A(xHC4ib@K+tF4z6n2~M#~P0Hk>2&U!rGa;zgVqeIFjbe}q$`&Lc6Y;|NkCY~b>PVh~?d@TK)T#Y;!vnf@dErDu%-MTH+=z=hC<B|z_2EP{j2!?jPs@3Je(vUIK8g=_tt>0S3qY<D9()qgZ5^};W<4NfX>P(CVXYp?xUufKuKmt7DYdj~xKhNHY=m)-)4dW#s%P4;U~fgUEd_IJLRzcdKX+<XgvsRRcFeCe`BV4er;DH!m7b!-0tY(Rlc{Car)wb;Oa!YdEK!FO&E-G0b^?IC{yTl!xjdLZ8#lm1uq;95Aj=2m|L&QY7wz(0uwZiDA<xs^9?7aZJy4P1&tc-S7o!@(X<_umcAzVlYz{cpj+g<F}u2){pOzdq)FeaGrUFX7*Bzbz*HQGEZ^aPrFAV!j5Hum)Zx8u%x8{{Gu|1Aj3Vlb#Mg>DX3)BaxO>xE!z81{Yrhw_gCi%f1YKUTagDwLWGdk-YAMFNIdW15dpd9)Az~h-X=ABO3oJv8lGDhhNHhmJ9Iwzl`xsy4J?bfp-MY^55|6e~sCjbm8r{I<K{beyZ&>qVVU#pLNG#($&X&-%<lFb!L^`HvE=A1RFjG|6b+rU<lniuXzZEa6jBR1WgVd6RUB(J?`u6Zt<zwb?Id<<E!y9c>V>)_-Z^12j4#?taw}O4{h<!^^-59moGXFh~zkb`2ZXY9Vc-5gp9eHu1(7ls&Mc>?zIOZz_$Q-#=Zu(?}BHi;CJjhaPk!X-1YpqYrhK@SGM2c+>z`f5gpWidF-kk*xFKf>`Tzn7clzk1~`db4u5_HXTLa(%E+fWt;m5^NQZtiJhI|xK=9z#_H-nZBk*SjoNa^O6$AVohWHm^Zt?-UL2)FUOxv%B#VJp@2CqH?ew5EhJmnmT|Gat1#a$)%9M5C)9BA^))41VRoH%*PpE(P2h`;{ZVAV)^yzAorSHDx1Ub+~B-e<+1`E#IYKZM^iA1%W)yboR(c(Wwoum3+lrpI6Wr>pyaJ|#)`n_joN|H3TD*zh~PeRcm`zX5I)e#dt#oxH9pOZba_PF^;77{o&SRd&lu`ybsTOZfY%&ZYeuKPpN1d)C&AC-=WwlJIx9LtZ`k)n7^y{tj2<RsH{Yg(Ttc@R?QpANr6a;qSoa)&1{$t}Nj%{+m^^a{H`$Og9(6DBmwje+|D``O4X~8>?nzqfyM{t66<xdB&P36*qTp+gM6JQ_oo46H@<wPD0!8d)k$&`ycz6B;haqyQTeKn2;p=RhBH9y!g$)tio^qK6y?5%V9O~7ysGP{+Ir*B;oJy3sy~zeoB(?cQ_`m?#DU}_^Y10w7+^tmhd;QWqJRJw}JEuzk$Bx{bRtr;P1riFYEtIMw0NC+j?2Q^=e7NpAPf$mIoyXf0cKx?%#fcEa9)~_`+E^KHGMv1cUu!yDZ_a|HFSPN%*UDE_>!4xPZU@AAMbt@K?EL^)v5$u_WQI|G8&C28Z9+<*WNGSULP@t5)|Pe>rBbgjL<Ty8r1QVB#<SlcoKAFb@13U$MIXn~Q-@hTrkkOZ(sYehxU#jrWf)mn8f>^U0U>|Lu86!rwF3t>{m^M3(Ru|F_ls|9TUMobc0@tnQyNflq;7<*KFqzXdKHf7<%hlB`ODU9c5Y4DVj`kv*#b-0@Q18rY6_5x_Db?dZIzb9?7%IEgQkl*R0Huxnc<Y=w<*0h>s4%THcI_tfp3MYz=4nOu|YlHpbdJd?m@7Wkh@uEG1ADz$;%TzHw>({)7t=pJ>cysUk!^O$-Yd}Pr&>gD1-*T<i{CJE19)GgoKmF-&FiR~=8Nb2mw2baDOraQL!o;|D4HspFqlDbq$bO2A6FX6AO=yPUZWk@Hm{Z-!XI|Ez|jV7E%*I=humoB!Ox@DCZ%_V_r_~fPjk9Oj-mxWx#r!Vh@>&3<F^H1uOZ-H*FUFjLx6)!l0mK0pVE8$RPhgWsU%HqyWHX-=()$X@?;gi?cqwMrA<T~#Jh|AaZ5umK+v%qKiI`_k3sju(z^zjDox12BC=)NId-r$`$J{8^GHbe^>{lj2wY;uDG4!4KETV>$g8w60++U7kRPWl3U0GceO7oY6!mJl?Hi^XRoX{+i1!EN>usB8(g<15~-O41JZOvM0@Z`wq=<WgubxhSv^c7njW7!P*Ed<*>KOC`2dpRz(8q%Q9EG|gaskIZlG4bB^zf_-!&5w^hxJXit9`Tjo7hPe4^n7v({3Lvki`d16zAG`v(xDmQI<Oi@9$(`&I!)z3|Vh5fF)2%GVs|Pm{VmK7sm>J%+!?<3~-W%zJQ`|~;@Bb`v%>&NRkxt<4M*V%jM~`+=GkADQr;PvH+9iuwE>d4^v**VHaAS*Hy8=IQOmqP-ynjmBD^H900OaYx@!1pej6NHA{zVuH#%DD5f-`veOEm}ssmplJ#B8Pgi)DW`(=9u%GgOxi!yEPsdY@+x<bs<P2pXd$mqYg^oc3AkMz`etAW%DJpJ5HL5IiDDdG7)v@D$vuBqqFw-gu=x5Be&1@eOr5qh8pnihF|Dt0p5rIBQQ?{pvk*%@XvC&uevog!3v%lOEilB5s&k<e8W0^>B(?e8vw=&TcztqYKqR7k99(6&Lrd5zpP}Kq#Kx<^ED<=c3Mqod}Mn`lRCGn+dI)b|Y}!_rH=E<O9nn_XTgCk#YR&q9DW1mc^GCz&}R@R#LiK-r+*D&y}~!qBr=?^JFh$flKv#**hjldV&0W*!lvkzEDQGhi|{g+cj9t7t<BCEnXtKfz`88FO?VA5P}QzGI_gw{sI}^Ju3&%;R|Ix!S~4S{VRa!<+2Cr02{tSUO_11uVpVTz(KxJT(gnTt7Jw_Ub$xtQq@<>g4BC@{u-H)cmCAh$nO1xGw@m*T0(%?>tr`Z=8N}wnV24U_zkXk0Fg!Rm+<NvW&bYCunjFqZ<75aC=avsW_c6MIs(&MTvI7YZxv^>a&Kd>z<J8QmD}W9ok(6CczC-U+|dH1ze5HBAmO%ur|jMeY$Lo&Ci1E}ZN1ww?UM9&@(Q9F=VUi8BuRfS^9`d4l>Q!>Zw^?*du3#Yab)k68G9*7?-TII@$~zNo#wOq0oP4Q`k;4#*drg3ZR$jf#E0n{*z!jJwgs8`C~ZM3Pu$6QjPtS@T+RDrH>tzNJ}xgH#_SUugggNB577QKi@Sg*U$Xd?RZHb1(8MQQGlI{2N=A-alKxTV1Uw;0_sgq1Xyw!LO4rJMM&3$u`&r!I3DM5yT!Y6w#7NNRL%@rz@B@Ke=U)FWgx*D{{G#v9^W-&bPkzZW`^hzzE<kYovWz(10f4Uvq{MbVzW7fFw;Xl|A^fw9#F@4F)xZF-hHV)CBuQWQ0l6f7L-sQo_}st9L0XUB`lhRIcz!_+vZ|8wpp1SD-;yz?{o9@=?5X$;u5rS>g5O2BSKX}4L#{PuSH8#Ia_y?`dyyIJkblMLOkg)2mT#i{`2(2to8j3X%5Dyqb@fNSYe>@{@$AT6`p%E#AYaAc;NN_A#Py%hS8>p|lm1<14APU=^byqkRP5<RlJqli4ASs_h-2W(eohplZ;fZe{9lFuV4%O?w;8$nCGK-ctm>~^Bnt2TT6Qs2Tw-}tcJpHhiNEoXI-9^e=DM7v8Tzf<=jAPaCwmyV)mR+FrXSeG??b5HtJtkS@F%f4hL`ojyMOe+kB@Nvx1jr~L-+p_0DX4-e>~UmY9F;BW&aN<*Zu@ZMV9}#coF=SWzyqGvPX@Sx#5P5+c%~S%alT{>(iDLu62?&mde(~l$9xE^~wg*%8TQWX1tfCxAklNeH-#du{ynByjXR8Ja42oj%PB#N4AT%BQ&+qnknnv(KL9g{v2fWbalMOENslMLlo^YWeWa;sn90%j8&?1PvCUpd8Sk}txA=YbZ{w^&zCZqRY}1Y*_EO`rP0+CdoKnov(V}(tc|q0QKM+-m0~KdnVC%Y1bn!S+CXhDKAXyqm(nRycY0vJ^C|mv-jtQei2K!|Q8X+gl{Zf6SywNecYK|WvG>X;gWoTdCi(ZQsgjwpM7K;UYm|E7PMjaJ!(_T@<gE=xaTlAkY*x>~9Y7GYeC#1jE2K>;W$7ADL;^45$|bYE&pF>ecwm4Xvl(_>aNlCz?SR7>Q`0MzykT1G8*ozO_cHJtfFPU2td>gi)yWi6)&yS7Ol2lg6+F_XGkV!FN=2<~@d*HEfpyLq<8Zow4TDdYSQfDe8m^5d#tE+yh{0he>jSJVeGTV7uhSuo0FU5RBcs7sjp8_8-Wk)<3pl7!g?AF0#zSXKD;kcNZkNlNt8c80T(y|7*qGRbaz%#)F^YOtE0qP1RttK?@WOz%B?1bZLO$0t6j)=cXs<uq+>pzcQkLgR+SF5(%!K=z?-+UxFbb!v>2cix`~w@SqC21k->P~(1}E(C@=Uo@;hPB;lU?OUDm#L?&YR*@0wt@!z{fHQx@f1M7g#g){#*#J>wpBZ?j4)e%}m98p*%B@GAG2bSa3K=&sZ?_N@~XaG+s2_7p7n+0_c5v0;UBKuls5LCFo+lR2+vkDtfuXp1}*APnJq~_c<++`$DEvDChNQ_oYgzIPUo{%ucD|8HrVem)sW+4m~qvWNM#7$4mYPbbvz-a@0My3#Dw;`$Yt9&p`4i(=)j_!}o&wd?Bt^CRH|}RX(IjDx;@UnG^i!N~+*_-OL*q&xMSh_e?F~0WWOOg8EMuBA6FFP@tzyRP>yeG$5#&`t9tr2z@cjDew2oM&?8wATH-!&a9p>#Wx9inBoplmuY7@&1%`%J@}e<2`OKtS`>qvOy&9b3eNNCyk!*Gnuym3J@Ek{K4n{r4mq7*h)-O{$2W*4<Khaxo2mfi8n?%hH*$JrCL=y3sk+n=dkPPgS3Z1^tg2mIsvh5=st1zlbyBQN?pC|;pQO4B{~1!Rd5fyXb#<Anb{tbLjl+#=y46KPYDavddPQ7T*Co}CA$5_SRF}ki)WsXs<?u{5yt7%o9ByBgR8@S~P*=j4yh;6wxboXmYw5cka78@_{~S}Fgop47d|*s{wH$|Tiu4D{{dZzF@#@kChSUu^;lX2F>T2vByxBqj&hm4ao!`h#cd?Nyg05a4moLDVcD2RT<;o|gp~V$l_<v}44SpN@*pGdmZIji7api;UFf_QaWJ+Ckv%2sM+#bf;YKJm2rpn5~<k@a@JbnfBd$>!zTp5F-<y~-1xk^@VR-SQA-7*IE?oltpXDn!7oDMtURdoZ-<3eb$L+Kb(SI1?%{S%l$WhJ)vY&hcY9HS1u8#=sVId*ng9HcvSiSmv1A)E*G8tOpeieu_pxD!{`C?A?W15d0~zSIs=AKyvuzsED+4jL#vrN))dw##Dr|Nb7fB#8^yvzkZeR5|`~Xop(<1-86g?dXEz51bC2)}r{DtbDayJ{wo|BvoZty%^yku6$ZLAD0uesuKTkTTE?N?wyvEkDZd$nDV1ja@%6KvOsQAmHn``a6cAT7UKjgjw?T2fEP9@udiB(N8yqZR~}p-ciI1~P}O7VChSBK76H1DSf(yIrrr!KoK=-Bb)oXH4hH`)r?IP+(R41OiHKd(1&fdH@?aOiZAUzI{YnH*RZ%`M`AGb^>XmT3!cwn|TdHyoeP+c4bvrxjgR`CRx}scq7A9#~T=|zN?DS>IhZ9M)Q<;SE$E!4bU!CF$ivxh$GJ#0vn7W>tqGvug<z0Lj=trR)T(i#eFgW|c&jcSl4-ei553WA14&sBqp$G2|KKOBX5I;ST=vI|;2pF&FNUT*aLV#azUcCe-0k(Pkjq1{>x*5)v0~lWtA5xb;qArDryACcb1+c)eFN#m8-SBT0wAm4VGAtInoCA>jm&q}>puDH!QCj_uvG{TPQf_uky-xY?q^u79PJP;M)YNa(rzq<lRgXTV79YdTeOP`JH!vLDr>aWFnYJ!~rMH=IVY#|0E}v(R{G)|(+cI^P@{NkDUMXXb5@*}m)%LjZB~@1A@l|;E;Zx@UwB7`e+7<_}RX!(KYMZhzsV-Jtd+J;cjvta`Wx)f=<m|Z8VJTDRl#U0KDRBY-coMpB&na1X|7k=w*kqfmeC8AaNf*N9;21&eKi-94`xKcb7<%_V3uW~pg0Ar{^(sV6xZ)entBc^@HFWF7_!;%$dk{8PK;Oq`H-ENDu&vy;AQ^uZVqt~tyEBtD_FWq;jq<LJvp8|D#gsq~s_hS|i<Gy<2tjo*B&2-()EEHddjRvOu#z3PAHH~s_QUe!uTU>hP7u<CjttQQE93O!->Y5XU=2HXHZ3Lo3+Vm~j&!N4Zp2H+)QxXI45W5!1Zg{-SQej6oQ)?RfH_;O?tl??!_iJ8D~LsV5XC-7V>@RB@JP~)o&kg&=)_^l2u`c`Bk@E<UGQ}EYDC(%B-N{X)B|VLo!Fy;Fq{Fl)e#ieOsR`+N36})V;J7=QZF7>7giW9znEXXoMA=k)9b5jzK@0DIlF&jY_;FqDbs7Oi})Hx#&6-Ty|(^qL%!Gk9boI4cybI@NqO$+9FDY$CiQY$p{LQDAd!fl#ku>fB&#cxJ=AK~N~Ch<;qI<DVCLtal4T2FlYoyXs`9ZaK`@>upI?xqi|4SHbmaq8es2Z-fnKtIRQ3;}G-KV+z=F8)sRazZEf^zQyPS4(;<yUEU)zOy`BK91u%-TYGO<?q#htjpE>iwlk=qm;=G*VI><1(n;Vc$k(bk6N|0$h?-S(Ed0O`b)4(NUimii*vh?m;?uuZ*6`BO|D<5*#vvt`c*w``yCgHHajpH3&1HQAf7hP^q%@a_jY*_<dA%?T}U0{8CSxZ1dnHUm~r?_t3B2;BG!;5B}F7a{^=Bapg$vCYDVduWw^3}_y@@L71G6Y*1GOx-{9D6ad*0RgPQO?$2Kg}V~T+-%!&7|&}g*-Em${5*lFemZ2hE-NpXBJ_HZ4P^h5kh|hZXnP~9m9k34WmCFvw<-S?!}qIzLN45i=wDgHSU_bx8{9=h-PnFA3C%(KbgKhfiz^Gey-$Sp05?61>90Cu->3VOU&XKkQ)BpchlS*442VFl@}PNv7V%vR&$J<FhYLxyH%=TyT=|1!37!JZ?roD-D$hBM_hQOf1Oiy7kDaEwKqi!X6vl|0yUXT8+L06aDPmOR?Ti)xJ?^p|!7qJ9vM)RW{K-3GFoX2fhaC8Vv*#rcVwU5L58N>Zqe2LcD=#~Z5B=R;>?`Y)&nvRJYiJ1ibe;0qJLRD>aP>yzH|?}0|2us_c`wnSxbpROndtV1XJE3H69?I)+;iH3>G`EJ2A>&*&X(w&s=WR*9&{l#2S$|ccByU0)kGW#<FML(AP!sqyApO$c?fB{@`dShxcbV++gZP_KCUhwRIlEtE`Ni1HL(3Rb+b{vZQ34X0{b(FRJk_}pPpsA<r~USBMuJ$zbj$2;b*_wDf6`j+J+B*&a$6IJocE_r5~BPp!^g-XR-1w(|!Ur_va+mAJ+Cu7Rewh+;jdsZ4wK6@om<Ni#>hl<i!2CF<B|&@v@(=z5NL7ZCD>*FqDPzIe7dg<#)17bMr0u{vw#(Zz8`A==3yVfF~oqP~Ls#EVSK$V|fI6v_!pF*(xLDffo|W`B)Avtx-OA*N}x5fOCt%SFLU~wzmLJ^7VwQ+->3b9y{gCS6q3WA}b$sPiJr-Y+-J)*M)AZk(IoRtGp09x!i(lOJMC+n3H(8l5Wx@0hTA^$I#yS)AC%<9`^W)4O)y7fBzN^9L}q7@l%ouMZ;A7s#7MO9U%nxiA8YuBxT`QV0SFwc9GS(0w@vg(|h0x*T$89xC7r@rrh5)L|Dioq2v8`uof37&yle!*DC*es(Xk@f{#haf30i@H9kpsgTmT7cZY@TtyjLpUg=2Ehu`J?a5w+5?0h*+xN-|eqe;S%-7YM;(tD?+PF{zd#P<tBfDPixWo#aoO#u2_3CGHWYbt?jRqx|sk^)Tqa=-)^-H0qAHnlvd_7Q^sH0VA+#?TqyV5VkqZE>oV=izwcH0HSSUx=aOOVyppq`G=&t=f(f=Cet(g69{&dICC6GRXMjNsA`xm~uBT^L-cKCH2@DaWBald@kHt4Gp#*^EC8;tDRr+c8-IbM(ylMs>jcWd%T^OH*V)gb~|ry+Bqxk@pfi|?ZB*!%&Iui$i}rJjvYfz2(bEM<rUTg$i6H8x0A3*N3N}1dBqGa>Mu^p4ABFQ0eEZ&4oi9X6rFeADf=EEH)y9buDo)_g61AOc`k>PQ~A%%9CY9dBsM+A7Ml{pmo14acY_Gh(M5NEUlDh^6WxsJJ|FHb#XjT^At7AeIEJ_wAODg4`1vumA>Xlxaj^eT^=KSkgJXPv6bN_#&puUoFA%`t-#x1CSN<e}fY%AK8DoMLDPO*W_#1e070wybr>DX69V0oThX5_9UYU3jPUpRCV>15_hQ35qk3Xtjp?u?x*g7VbY-EpvEP7R!=R!`shF#cXU%1YH;d*vqL+w|tWfwNv7p`U(w%8Ze`!8I{F7(<L763^GQ5YHG1&Lc{bM}8j>XqBo1>c6bc~#p5*p4q%X1j;f9#rhS8N_YbR`C4V^h)$FFE3d*gy8W@K&gj8PI|g}1BqN6@$cagviwiJ2hoE?a_0NY*m`{NBITbK5@uYQWRi$kQ*-p~g>0$+#`8!}t^wBb=L_X~U|C;wnn__yYgT;)3OGq7#lfoI19Hl8b=~U$`&7F~W`P6RG>d>EVdreL54%UJ%EMgfdJ|wYF6s=!7{}E0v!r!fMH-x))KrJ7iJCH8H*4>e&|b$qgbY#pw;qIroj0Kfwd-lTttx&Gfp$4E+p|L;g>{qEhV9*^F5d{Z24NKpV#h8ypf0&ly=0eqY1SoQ?qmY}XWe5OVjVaGTkjHBHT=S!V>^+1KLZb={A<e5M8p5$i*&!qB+7dNufd+2Ro5ih_={qDBKNmY7FxcC&1hOadQ<uG0y%cgvY0FpEp3-NVt>ga(3Q8SgtLBe=a65RN=D==&J*2yXPeC0Z>RSEO0@q4*8XQs4FTf=3%^{AC0R4)Py3o_SFb@%gf)`@ake8SQWq#27)NrY^5gbL@SgIz=`-q+?o(F|u|EEweTdlGMar9|<w14%th&g3C$5~OHbD}4*%UUkT=@+wVr&Q*{7;>ng^s+37<^&}FP9lr0kNbVmMsCC;R}Iy_YJA*&!{Uo2l%h;FhS~-E8zA@Wfpp~K2BeR8;sLlue^C$7SEogODmPP03W(;NL|T^*7te0FH_zMH<t1)f3JOvuJ$YMm}bn%L+wM!WZME<m=Dab=2s}cJ_V4z2)U`aauPThI+EFyBtNC^;1PC<J%C-KE6_dsHz)ci7=eVkn)KU?l0&F#oXvH2KL7}+Jl1Wg{jpsDXhUj0r>x(_S%8mT8(%Tx@82&^$%#kQMT<Z@UOY4mZ?RWClt?6jt(Mz5IlH@4R`#-Y)+nz!$*1gv9Z9-$x$^r-;*XUVbtH*Ce;%pq5Pji2VuHWkZt;)aJ1xIaU3y&Yn8-cK?)^@Elz*xXNab_j!!hOF1x#dGN{rA)XHXLDf^U32{s0@rv#qmmXBCcenexZZS#{I!S(5l(Vag1AzYsg)7CUAih0CxIApQn{iI4nEAi7vg9{F#O5&nYs`KOQJ`rUU2ZLqPng#baXk>%>}5IonVyh}NoIG<R{-amf_O2V*P{uX9-E$hZN>3a@~{|G5nF2qO<!kK~lol6*-|DHRMH(&ASIauJkJLU7S<!q;|!=1*Xpq2Gp9#KBA2q$@+^6APfsf`o&aodKHCBahpZ^@Q=642F80vfu3!}ZUV?r5SP&N2#+wWU6kJYfxfkEC*=^88cX31mK$yGabh;e<+o$uSxOh=J-&u+N`5Y5Al<Sms5_FG!s3f?HWe)Z*u1C^slCKFOxw0}CySiE0m8ZlR~gEgmbcS|rn3@2YTl`Z?`q5S|FOesZTgpED7=Zdv%~&$>r{hReV(@*UwL{~<^+=hWC6JwwOAd?_9>Wcd8IRNSytes&q2WZ23B@%z~foI~q><oKgQxqIdTxB{)bHU0>D<$E%_cZu?>X*s7ZOR9^I_Zh^;l)sDHZGAJOEg9_{E8-W}^!};+5gSvjRGu@9bpJN>5;@K{{3}43{UvR{i*QqX`4sI~<;|!xQeJeITU7rPj2%`ghp)Znj)=MkoOVmhdydaLVw3AoL^=~&w~S5TweI=*s7$!-{cUXK00(v26S@dD)r$a7?nk2qd;xKg@(cKwE-Rzht0F3a6hK<5?iu4->|UkLg8Z6K;$!wCz8IvIWyjc>ye^(NLzgdBehim8ZelI|fhgLw2XWgkQ|=bH_4n<woU}flrkbtT+ng19DC}eB*~>3h=T%oh-#da(-bK)Qevw5z`)p-ay%>4RHxdc{sM646iJJ*ty-qoJj*OO@lZi35Y&W<8<nNUKhuaq#dv`s=b&s=q*++iVJ~nG94*_4$0BgmSkHEmbH-7_5)I`e-M)ps9WDiWr%9+y${zV4<AB0`}3>e!=_{bN+2l{n;pg*WR(0N|LmIoTXgzk|o#K-PG2_qxe{!?ejGSUV(3Y-kIv;uL`3iZ;Lvkmq7c9MIDgZSa}g|qD0aTzsBm!M)3b<LM3OV0tDRqDng>q3&eGh*?adI{6YElLd24*Fudz^@;kW{me&+LP+FXNG9IeE<-_lSr*J#;r~hjPI0bU$RTTN#yWhI)2F%8L`f?Tiu)~m61EQn45_G=o=Z{VYh#s7*b<&xSVn74}>#U#HpX7{=RT3DHvMI!-rp~{ILCO7`G0h;|h9icG?oJ=G^?c#rX9rQI?>qZ=60O`1c&XtzK&p6aS{^q@^zH7F_(<P_~${?Tlr|mAAqrhY+@W5wYc$CJx(-^x4LY^uM$VMjCxiR?G^9Iq6}T4_Jv=G*jmh6uY>9MC*rZcTR{>-Mk-f6vW}z@LH_S;_$V}ouNJO(^CSfV1O{}bDm-Mv8!kKS|uOhi((5=v-7qnvmuKD!#X*pt{9=U=~mav!8LinwI=p@tmZ&-!JZwsIxDW#7LAtS_UvL`c^J8?B_JMmCAeVKC6*P%vAFV<lX5)Cg}uZ^+I%3&k@&{9ut^?PF(%}p57&yeCF(-ug~0zW1!VDCT9+m2Q<N9S0Iw{?{ycV9x1h!kDb4Uq2yA~-k6mKsA_q^lwJAT5WIwBvBs}++3>fvM$>iA~hV9;Wst(`8E;h$H;X8o)o(;F!l#7RehdM(aey1#xK=}u$K92&O|1ZfSWu0kgNSQ~w^q*b3z~jf!-b#@D8uibr=c;1LvGvOk6{d5D3KPrf;y$#t#H@zsZzvgp|N3Utm1hA9=0ep*;V6*lk=79kTxoIqcdlvt=OTC4!gs7N-4fwJAWjd|r%es;pod&pHOSTF%4>icuBo^vmgSJFZb7n!ygHr)@5Vo2Hxk{b7L4Ou{r`5^9LgnDE=ai?bs(+H!@$&CIV2WR{(rWPu#DfemofKvE@NDI^QmSf+ehO{pIn>V32Jxt38Ho=6`X~~m&%VTN&A2-pNm4j5D6x7v9V=rhkW&}KbIX6RFKblpx+8(;{v>O2;7g^aL+f<BIO-?6MY*u5o*BSA^LWKv&v#0eC6@l2NzuX08#p-aOc7W@wK6O{aEZuzWiTf8Ze6>=~H*qk!TZKu6oF?#fFP3&$^V@XF&wLS~+vdQg`lD+jgi|SJj=>M3TgkQ8}sh$FAyX<JJR9SP$s#o2M;x#W1bI_uH*7t~quM_IsJ~mY96zQEcKziX5ulU&<W0J~{(mfGzU?4paHq%q%JSXTz2JL+YmLSvL5Gs<M0V=O1WQyYHVE((XU_pmpI<ym5c5cJE^r@9|RTagq<lwo_R1I)q1R48gy&7hEGa&kYp9(ty^95Kft!Be>}FNQ40=X~eRB#24mu#EDv~hC?2!G2}$|qmPPFC(a8D>M_fl3pdNa=lDdNCsgvtoi>$aQZ1R>LI`hy*@1onJw6xuL95XR&;B{hd@W#m<Pp5_-k>onafawmP`MW8PIj-lqh%c^d+Hl<6Qmz;^A8)UG}-&ghY-)tReu?^lVjda{ycQXuvee7dsS2KNEG$WNT<dKI{)FcoOq<Q?Qn*m=~<_f50C@s*Ob5tUtr$=fv?pqH}>bW18U)(u^JoT!dQ)Yvys(YW{#WGLafM%Zf-?R%qC```9zZbK;suHFEM4bWUmBhKTj8~qBU5JF*oOd%RPS{pz^#mcAg~eA6I0$`MO18(AZfEqfnHOPdy%b19W4(+V92sIB65kcpC0Ldp54TT=_FnhWxp;JHKitu>sD;I?zdCnYuvgh>1$N%4%%+^1oLX45FviZ_sg!bH{IN8&iIdN>1gwr<f>un@x(YxA8X#q)P;f#^x^rghPE_s(eA}9z$UkkhH``^9`lGgjdTyn^equ(ENkmtgww`^d(s)oQB?ein(i{Gtjr=GFK!oS3B|FVRmX#<Pbdk^OHmL;CoNYj`Ep1zv5w+x|lm4@fRLGb=LjhBL3WRH9;4;*l9d5#odyY@$W150nNO`(Pf_{FGHM$$J*JT)+jFq+2#^H<BySSvrN67T^++%=)R#d>XH@g{&Un^YbNM$E$=c|(wl+p8j7h17(fsKFg_(pEq+!ew*M#Ua%CkaJ0DaL>J|bZeuZo@s&Y55^S#Qwr^n#<Yf_GmlXT3k4-rH0&qR?Is%^@jX3)2AA#d*;>KF<$!%4W;p?vEk3Nzht<=>^VfR^6`fCJB5jSgfB)CAC!LAVlA)(`DO-B246akX2H4|P+^Z$B+VCsuG?^mA?Jg3bxVL)@pL*Ya;BJ>sG8e*%!1MTP#^GZs@`d{P$5i(|67YPGr|ev!KB$>-SoPmjf&s0&heB$T(E9vX`0)KzkvkMRYudV6!Bx?A}fz+GZ+7{;(<4ED?n&^IE{-<OAMJ;_sHs4JkyALo;j3rxzee^M5ytK!Q40J(l3q_->%<ZY*Ar?)tX@04XCa=$z^JLY&mij?chYtXzormosm%ky!J1uuP#f|r~?);8snF*$J`@V5vGYu(<JWzqJ_n0MvRPF)bXte@OjLzlG}zwsH#6H7%b@Z5r|pbg+%)~ZiZ?!Ge#d+^f|hFJYr9#YprAI>D<#z#()N3I=)bv^Y1ZhYc&l3BP{h6j{*&u}ZpW%T|~l^5SBBeTmGwYREx>3MMJ0$qZ|x?dvq*oA;)t{+q{A0j)?^I4o!k{o$wa>9N8`7(>V3dUkBr1m$mus!;BDg4_f0<o3?6Lp$}89hsM0Vn8Q*xu`vug?srm(#btd1{Dt^mS^W@1JgGqQQTi^f>!mNl^rC<Lato7m_gT3zY{?;e#uccgx*FZ~>bA!6`ce;T<w>vTZ?J`GiYT_*7goMY$V2gqIWa1ExT~Jt7AtT~HR~;B>k2xl=5h?Aww|ma-p6Y*VnWRk|_8VKH+6eD0~UcAx`v{*?^r#a%HFi)bnn<Xe}xo4xfjna}T+PvHRtwjJ+^)7rcj!&sEJp5{-yogK6-$J>jS5=Z!;uV3A`8I*sF$!p`vU!8uWe!Sio57)CS9<4WqjPZ0*?c9kGdhJO#{lfH++Br-Q?iosYqxyz;R9`1h0(xO+)(PzkgB=XMS%^a$M)1Ldod6bX@d**p7atlUH2<BL6ZLw=7xfxTFcO1%{^1jR&%aCIT-3b_hRF7gGQvMsXNh-s-+~K%*=6>;5MFS3ch_}kJ@1xb#uD8O^(AGSy?Ij%rLmRDPZSKKxlLV($v>2%B<(2QCMpZ(@43rHo0lWjgcqL&lQ0AbSY2uR>HW=}va79UVMDi!`5Q`lw9e2JwA5|4bcT29?Mz-m$p+Y<u^Kv&A)2b+#pK~*s(NfJ$(5t`!kGNRjdf1QH`bW51|y>W@6VBR4XMkYtj30Ntbe<Z9>?Rr8z8nhf{lGbJ!1=;0Jz^cDUUh4q^O*%EJL{3@Md+v&FbnYb;0)Y$WeB6sr_(y#gKXhDo$ZrFBwv=MT^EV<sNS1c*QA3pF5PFBxH<M+^jrrhWU;E;;tm!cu_|(DQ<9~^Y;`d(KXh#EUx_9BtE_X*sM0?B3Zo_59k|og@1>R;am7G@jqA4m4ozYI(%&heT0smH<QDE>0|T;eo(vw<Ox^^j7V=wy56QYFiMzx3!ZuO3>);~3lRs67yb|*YA{#;v5myGsWPm9G|X4vZ&tDAl`rO_q&flg_VJZK#+0w#j<0Q0emj*IqKqfkD=$jOESCL+caAA9#iSO>an{m%d}Q?JZZg`2VI|6g?Rf7=%DbmA()JSNLi;&!KI<Z&frk@AEUNh&1$%t23*Y_P?TkUyj*nW~46|6O6jJ%D<T=&7r#We4W?(v_9oH+Rea56=8l~a@Wo^U9wj1VnMNe6JMThsa^31e$Ld)chqOKW5&CWR`X?sO7!K7(rckI9nd`Y8d-MAM1?7DGn$i;QL=nFkPhMCt*Q@_0meZ!Af6NU-54vkv<EG6LJs5WSfrUs3H0r)%GqYVsf(++BSC1vUZhqi0lc(JNwrl)(hY8o4qoz!k{1RfvV3~#WH^}-W)Pn)Ww%7Y_?fuq`yVSJ=VW1sBl(I|Z&Wy6E7+I`?17}(c0FezDO&D5=wWmWiFz1pqx7<=u|R-Sfpn@EYc-OOaParov$pPn7pX&l%q=S8DX&hPCTI6T^~QCIsgb>ZL<IKb`<8jaf=7&wew>96Scs#ei+uxiDOK6q3c=)>ex(D*j3(aiR2(MGkZiSJXUMIDAa?_=!KXq+Q6hbi}$gfppOmN0Mcc-P<+Sfovw4<d89Kq|o`=8N0qZ6ta}w?u=eVR(3Siw#n4_=PT2^h~van@G!4pmUj2UeZQp4pJ_@+u)mJ=;~3-gy>y|CYBkyi=W@D7qhT9u<fi;mi?2Hw86t#x|-AA9)7_!l+B)Wo`Y!y$@E$tA01|}GpSc#@$J#V#m(9t!?LdoWNnC;OXp!t3$UmN>;P#dPyWe}2R|lEK^N>^<F#FDcLgp-dky~=3d{BY3}+i`1q_oRK+{ZkFa@12)PYXGAEh#8f8-zNw?EDkQ4Ye>X;`$ark;oQH3X1S(Mka-t-w)v#>vNu7+3&2E{pGj+cK$gDq~nP^RW&D1a-RH6#g05#+%Rwj=<6ud=MClo}1~jGtzzy`_>Nw;Pbx~vB^Qo=(kVLX@h_mB<*n3Dp##R{;@ftG4>tATwApITgwGb13jCvx;-f)qrEsOBQuP07FhOLmY)^6zZcH2vkX6s%<MBV*04Tfiu1iJ1)>Xm1mM^QD%kg4&nnkO{QXAJ)GJm5^v5YGf{Y&lQ&Y`g6JvTHk9l1ujZ)Rb%LU9NYS8k90)HVjt(ovW9FV_rN!mhd`HJq?A(nK<4tq^^?7&66o?{4(G8(@Sz$lGhsf})$Ae~#?q*KeLtQ53$kl_nF8(=sT_z_A-n#%!OBEbX10pJ5-Ew<CN)BM=e1#5ATU&^FR%SHs=CED9dQ(c)bZ5FCPEEF3{Luhf~RtNevYhsA--%)LJw<h_qPtrHzMB3Sm*4}y%u!wI*_Q8%UrnN%Ksu<H+p_;dha(;$pA~jeTV51MkvMyrLC#F1Qn#On$I2;(D)w2~l0pI4iwo^rGFnu7s2{;GFa}QEVQo(Jzp*=c?^jFgQxKZ@?vWW&F?|aVngzx*!_P!TgNHdDJHRJS<0WO=V-efM7H}z22;QH{ZOk&uaH74_UDMPJtkPQRx!r%ZgHex2WT2m#>OaaFRe+)Bcq|$kvG4m-C{y$U9gyS5x<tFsZ2`#S|2MQy@8UEQVn&!#5-Lu(q+GkFs%0LQ{l55lOF0A{ge!GL?@pF$mfn*FDP@QRQZ@D}$UF-$ut5i4)-ommnAFZT{W*)bMfW}r}X<NBe)=(hi*m+7TRkFYsvB9j(0_$T5(p7VFY?(~utNMU{a_SISH&FoM`qY#;aU@mDmI}tn6t2bod}>_sB$FpVOxlg_*b$^9(7m<PGas=KEGYa-0O<ypRyeTQ(AAhp-43sg>%b9|otc3-$N|d=iva8>0ym}*mr7|A2s1^iE^!XqMg!$M>?8lv_2(`cKkl2@$DQ}DNs#$IX9Cgfj0+(dJXe4<6ad@fLSKUjsrVbUdiyH`Yg#Ik0Xfjgr*Eak2eyfKYRzttBN{lmNdt=5uW>$exK?+2HsjK}*S(Qw4~&~;Zx!GidNpTnB6*DpcO=7a)>sQ8GmMOB`zxiBdXe$qz$?IM;fX<T#6uP|mhawd6?f5~wrIrT*F;Y}B=sL^Rxo0+!xq0l$0=lQ${KJ1TrMXBvdCMMkvf-ZE6K1EBW;CLxoi~28?rHx^&di|HZpT`0z~BOC}sY?Sr@`@ANA2zKmiXmQYgUFN7#6>jQHgMd@~I@HLqgHsI?^p!o`H{I?hR_lKE62olOC9*b4(0FI8rwOi9aCbbT^aF*%_;NL2(FdF0B!5+?DVD~pdzxQ8R%3>>LnhZm+*UFYY8L#HJ~g;^*J7zi5Ud=yc3X$?NUR}&&8V>3)3Ht8atvHe)A0RV5L1l?s5H<dA`bCm*4Z@yTvQfUVEh$9<|5+Oqw7%@1$+^vmn7dl+PsFQ9CM!PI11M@}zeH5^EjaJk$rUtTTM$hVE)px@L8R@Fvi$GE+m!|Xzm(Bs8k(nFBQYS8{Jc{6JtBvZ)GX-1UjD>WV0-lvw(QxuosPcn92L8#DDvg1WmeP9sFcU#!4f5ShyyPRvO|{{WX5Zp$36*X*;v~5%XXF7&7?KD~b0J+zXLlIpo|J42aeZVhOK>aqYK2Bbd22<7u1}J7aTK7hR8EcK0)hmA(nC1Kpn+4J6UI3XkPMqjo27i!()pg!jlAnHCl!oh66>q1trk&8)w6^}=B`3)!WOed8{LY8BL}#rXcH`)Rj#_JBMZ8@MDG&>JR$6TbAqLi_i=s!Fj8nXfi7b0o^6^HG&QsW<PxLXlO-byc!Zv;$B+WyEO15eJ{`7wX(oc+>3Tm|=+iWJnXEw?X90CfqncY8U7oQqlG{>79U6%M4@VitN;v93Pp^Hn1&*>tE(e?^(R`|v)j+ySdlh|6aFKP%QzIQyE#LyOWt9qPGZdMSsi4BPJx4@?Lq~>@JWV#*5eDIaedWVPH3^MwWLky!a)bz1KSMab8`mN%`8RO@$@Ep2t;ol^G7uBW0Vab2OEjKG>n?l&Xdyx<^ue6anDDNljsSpG(~GD+(TrTus#J9$4l}Z7)57{tXbczwy_>?Y9$)iT*!VtDi{hBDp)z%H%CNBiR?5hm(Kbh&Zo%Hzlq*xYCL=eK4P4O!S8^PUV1+nld>7jp0KgcSJc{P$BZzS}A<8+ZQRS_0SOeKa%a$DDEI<$dd9QY)5hcr%Dy6E0hWk>*80W_O6Uazp^|CdAE1K5}rk2)orHXFLg&XF;MTBGQsN8@DA&?Z0TqC|Kx%78YMOI>?oIxS9hN*R;0c{ULhk%JAOz^1Rk!JKkJqQ7UhbSO2Ff~T7(R6eGC^$K5fW&L&OO}Zmi;7;>Qx@z#uFWIidzARZ-No!EU{TbI?ZNtOx3St(q!QD1<7e>JJ}mvlu0=Q5)k3u-Uyy*6FOBz<b=NU^n~+!_Pz1C9vd-<*QZ6?FFKMNGmau*(^t+6ep)5YB(rnWQv3R)kJe&csi$yKPK_I{o-Dv;eSd|YpD0>L)F06e;PaDN-lD{-+Z7=GnN_qy@+IOA{9aulN8vwO8TE=|bA3y;4_4d&XlAoL~WNmK;31FF{cV;u<b2e{UQt_pveYDd)s;iO<F@Qy~$TY1rIBa_W)zO~?kT1U7hyOo<@Lv!83Rf3xRJTy3<OMS4&-CswYoYZWx$SU|1>*b|wWn1kwKL;0UA`=HHnh2wUSSd#0z3OEY=4U+*!<k35tlqw$cOk8wS<y`_Pwq3?Rz1NmXP;>r<$mgrX0gj6IxfMacvbrgh-8~0h5FP$E*c#&*Mum3RH%n@LWZoF6)4&PubWPw`I7Dy4hhl=LNvGW;xG9OEO6yepDm!SjueQuH~l8Osbeek0t~4H%$CsMIMoa7E-|U?0uqKQqT}JiX}HgoW1xKNR5W;Dh-g2%T;SCBWbqlN<bfI<K2K3Fd#`0!lV|N1%ES0V!51;5b;HG5u!AbYOKJE#!MOnr*aV(xLV`o@+I^$r2(FrW?mlk8LlX+(5Lx%GSW0OZoDZF#KrC1>K6>izQd=jWg|R5Oii;oStRPRJ${aH&dzzg#79`E$~bor%+7<MbBkUmlhazy=8>5_)f|BGNTrl9`6ohc_5G=$Ii*)zYz^Zw0*IH~LvCD4E(N=Q3qcbyRh0I^Kv74TJE%rZ9~nM0s)eD0qZ&$O1L&b5l#Oh$CGr?RMHXBwvPGLeAt0biL}G3gw24x+f_0|#Vtr0{vj;<yzO&cQ;Iz=M?d7UD!7TiT1EihfkbMX}(AAl&Ux*b*21qn2b_!{U@Elez&sjQJsre#bv2)J)!1-DUWK^h(e6rzJ8=+z!I}q+y-C`f>654ctJ=~;?q?yqpQ>|1qbEc3k%>(ll!XX19-iH52dR<@Dezamt0`j{Rw=U8f6WI~g8FXRLgm+tgCY>2m(ODA2;6rFMp?TTnF$>UClUeeaQX!?C&}U4cx^iCexxod@N71o6>r*ie>~=Yy0-m5^P8c~q?Q2QaE*}`E!GHA$KOCVtwjEaH2Se5HJ@HtfqiL%>(q>aidnZ)Gx!%+sJc3?rTr2N4+Ogu_sIn`hDktC;e2<}ip?HdHGi{lZESE`@G9U7bi*%8+7w}?!{DvTqQv-K7VBt`ap4ZWqG)b$Q-NN~JVC-DNTn(bP%|rB<w!q%D(Z{j3Z}5mgNNM0O#RqNHxHWihsaVvBBR&FBrWN8VCpMq08kC5T=Tg<Yr8(@K6ta1ctTSTRIul9j${5CSko!T;$${x<XUB<-6>Dk38tK6H)goh#1q)a=*jKqcio8x-83;5Wk7X&YjPrU8DA+a+`6`SIH^~5T-F=@E(S}-%Y__iYDHytBM`bkQo?{I7)hUmY;MvP#AzE_`5yYff!H7wATQuL&G8r?3GTCN5B+Nm>?R+?uqZ<wP4B4xV?m?k5RnY;=3Oa{%xBq5sO-?3n19;fda!G%nSQQQ+WJ&|X00;u^>w`sdjtYf6^eh}a43rXDBd}{=6pgSHTT|IAaMz{~8U^id?5)`flf4!VerQ$LjRq?brb1>0?&4J`6)m#5PQh1;x-?bL3&_N|c%f-P2{5Ty1JP<K&&`RxFGh9pT(^$j(&&3;H8TMRS{lP`%yr11yV;X)uEGV5d^vB{tvyvEZyCiyj06SO5@6jHjhL1tl{T~Xk!~O5?4$7}F%S7#+OzF;B4_R8?V}>uXD5vcDHqwbY2RL~>tE9nlTkyf++QP%jq3-2{U%}EZ<r16ZGL1W;<2QPJ`VdDm9wxOFh#Ihqq+r<pWzck`h_aRVIC@3gD{_ZL5JaFJw97uWT((<z+SPM&jTj|Oyfk#oM7&O2Q|IGKs{BR4&@fMWPs<X)VFN~%^nVk<%X`ThtUu2sZfzRf;MlR=he`iCFF|eG*K{S^?cuG%p)^AY}U1+_3>m=w9CPmEFyW(aeNS%yZ*QQaOrnkX~~Hp!<FX^!s=@(NeI)qf^9spHlcnb&K+@0#ODL$WK&eidBmrYqh$7qC~rksi|zJ~LVjk5@ide09dwXkj8_Yu*Ac9RTr8^NIxMUVlibQcGsU&ZwZbvy6z9kHJ9;T+N~Z0xjK?`a#RT^f**`HfU|>F!0kxy0=c9EmEo4Yxe+5V}Paja1KSLc)I+djm$5yZuvssMH97RmG2go}^L4`CBm8r}VBSW)pY$IzI_alnr$`&as24jPS%SD)q-`OX&O34<}y+LH$w*(zoQ~9aXjH%g{<XU8H8$4T_Dpj%oFV=XfP(bek>Lt1h&Y39z$>cDXheoa5O@3z(k~WCXhu*o>P_2p}TQu?I0n&YnXr2LWbRYC$&>Te&j_kGM5dCoe#BiBK4Kj*uBBN*v(OS*&|Bal!4OiHe<Tam5Wv&Q#e5I36ts#jl2(ruoC881#hr^~SXvB&6cS1nPyd`5hR1#pjNiD$>h}RgI(1XS!^bleGVRLq3?MpM&*vO1_%hCPY4x%$0BZ>wW!Znw^48$-?8ZUbk=MjPm1J=Y*Yiq7lnMzf%gGUTfiG}Bx!Pi-$nNSV7qsweU*}}|LuBYoDvw7r1m|pAV1BdtQKA>r4HLVS5d%H8`auk!YpCd#PAG900{Ym_saJZ{*SRhY$%zoK+RrMu2a`SIowdwdSMhsgaKcV97RiiQ^<+L=6{se`alHd$O%t-olxi<nevC}x9JAk7J7W`CeJ}zO=v|71jk|-qIZk8&36H>5eL^W)s@1VJRpHZQQXB>?$Qm?&zC?Pt*0(0U48OR;P%ssGU1sm0jFWwwYrnRgrjzpbnAPl8l(p1`>4vytf`W+;#`gU7XjTBcv4$@n-5NV{qWDtNyU~Cyb966Y*u?q1Jz``Kv5rOd<5QKam>JwX4(0i=so9DqCPe^iWeT}ql0}B$u#0e`^?A3XcP|ns<(P2)SN|~B@JK`wKL{}!bSDfO3sukO}l@4<*6L|xcfJ9RyQIlHFUdsK{9Jf-(<FrBEr#kZrj8-i>TOjON3g1Q%6e;r;C@0n~m$T8l6Z+SrC86KuSs93LCv*ML9wBcV3^nCg(xO&jzh|>K0g!S+vr1adu%bxi&HC^j;kw2;+;WrYw-}MOQ8AwmCXMkleR?IA(VfE@CJ%>UL;+4i*@=gP9Q0TPo76SA)%^gNZVv-tgz+m)+>UrGn&1d}gu2wp$S+dgpgEQmKy;|y<hnoLvDHxwBqQoT<1sS@Ada%3XY?rpBc8;x^Vpc)Eq)=*Hd1=n7fjs<V-{+m+9pat%#kmsR$v*dRza8og=xEO5o{ml<G8MP^2kvw=%5?MW7o?0;p@B|x8>n7{b-hnV}=Mm=<N*?b3JGQdeVzQM|{VVfI<OCsO!>E?d98@0STy<^D1e}PT^N1H{mA@^e)M3Gm(6;Q10$QGm}T{Zed&$W5!0UQki+h+Md(?*w`(?omop+$V~;Kf+cNtW!#hkI=2RpB=A2ba2wk<u=mKoeo7Z&Z#fFWfnCE`#JM@o_ttTq7d}onAxA{MNyeJ;i`AlK6dZj_W6?8Yxbu_f(bgG-g&x`w@Ii#hB8qEeO|dswm}6Jo68O0;2sd`Y^C)6$-}}h&tDVDfu42FKsN`u2F=eq@&?|;O3|fw7To}{`dipiW^#Zb3sR&4~XVZWuKfs?|c7QCJe@xvXqgu5{&N33i=$RSe!RVrZAhaXHVo~(*ILuDZrYIa<fnbs^Hu0&J)&oaVnTfQ0VY7YIXCG~`kNWMSt@hD2`)E4~D_L9vy@G+XPBOi@L|O&3AFW01@sw#mM7Gu>!&(m$<6!Fr{D=UN6b9Us8NS1Eg6KwzXo#}=xTAUPKwh4Xn%u%LUrRnUZr0tPAyyV{Shr)ZwNm<-PmE5VM@iN~V&l5QWb!G@8BbWxYA4rxoR!55w<u%6Y9YQP9qf_{Wn`?zt%;`7zCBJ#l)3T)<Wvt>&P1%i88q};3Ph7d@Ut9fILVGff>xq@1RicTYSx5?Y%q5L*;puA8#5bk0cp?Nm@&1Cwh?$jOkcNgCS|6~3BxGQSQCDJuUXZamg5=8f-K`^62nm1L}oR}Fs3o%6Am}8hcaY#M1vF-Y+N_g*mgl{A|ao}oX&vJJ5VZ}sFt}_vOwklS1yONQA|~4G;9{RWhXT`3;CbQm^ow<=fU@9o0Et~jNavBJnB!Y9|hq1>_HCLk&>7IK+oqXE0>tIfCv(yamVXPE0xU#Vt2tUW&;2TpIw*XzYdHyU#Y;hSNg+doFqqKV1W^Pm}x#$OpWVVX5OluDq4`lK(YZGdk*H*oRBhTuz*$7MVhm@CkbPoumM;Jp*BWXhK8C7zKEtDTk5E(d<`1AfsWAlxd{wExo(#oQO}TH?F^7Nu4RE~wE1ZScy2RttX@G+FN;?Z?hKSQmAg1lKuU8O(kFyaQ!*pBOMVCsLu!t66^L=RG*#Ql(38+~6o$h{njJ(`KhoMA-r~;NP@m1O@3qclH}b1Pk9-iO{Lwl-5HlQCkw!{{!6OE0#q0nBa&4NJDPs&gg%kp@mRu!3qWZW;ssBOs7TEMM{>b*pk1p1R=VD_K55eS*$X#P@GIX@B>&*rLg$W^9`~wU=UmEY#ox|MRsgzwQz`a7ofGbP$$jo630;3Q#vtF4FUt$@Xs#EuYYUT4r*);6T{VaFntp<P$zoH!~A-^*U`^7dcqLUHa<yZhS25GsJX%X-N<wotPQ*p=QREToFv(P@SsLf(77qrYWmu0gqgW<CdQLbMPpcjnrh}pW~vOQZc;THn{B9qL0iTv;z?@hwbBDpN^Hrift%CIQcsAgmvw&BVFk()BI6m4Ut%$F#!Cp>|5QflabYB<n|z8&TP*-t?56h>s=!W+e0$r}$TkpXDlY>4EkT{l1zm;tz6fUZm;(nCJdoWR7tj0m`s`OPtGcTTKmukg0UZ8A8-oUtZZinY4x@fP!sdJ>S@N_4AGM$QR&Y_nX%TuscrGiq(d1fn`m3C1izn|n1&<V>wvu+xR&mM}*eU7vHf_#p63WJ-l{s!})8XsFO&8+{OLCK`G;iR>Nd>4(lkJn_`gpl?R-T@ulADI;I4h}=(EOdMj^<LB8YA|-bSSAN#aYPiMce27VDS)N<s;znjhi2{wnO~OvM6cK#0`wcyxm4HfVnS82hM#x?lF)u}ggc0-Pvt)Y=yVJ|@>~c+EtD0))UQaHHS`ic5+$qM%ikdCeS0Dt#4%a$jaY%j?cWRj?!a93{VVw?i<_rn@%!E1<8TuMYm>WtXARX{DmrQxbaw-A;6EPwqa;#JIunb>PT+%$Ywj^PV+0`X%5oRwX5duD5_gli|BL_>^9*2EAWfZg85txF)6I57(m?cckXH}x3vwb2GmBWS3-D*Z^*`jJW^9Q{p143<>$;(dMUtg*knc0o9$jy3j_b7U#h48|`3Q`TjD9Fv0SeXVwQg5h`lmpR7&tMkIaU!fR?_9$cspM0L0xn`MquL>&(7nuL8kTf!3IVPPShp)A&^!m^DC?Bu<ZuHdv{bgxgoMt$c23>;;<Z0tc2t!VGm0S#B2wKnv8@q80AlN9dVK;SD0)Q%#X*#O8wvA{0}BP3r{SGRy;gmU=sR>vxB<E4TAB_)7JiQ-1t7VcBkk1!*7Yz~c6aRI90Ndud5}5#9W^t!i%qX%fJ~v8(HJ1k28L=g-5Sr~a<gtxO8((uX{w0TfN<3j+L!=%0tiLpkYl8Ijl+q(t|mfZ&0=pc$dvC}pDA9%AXG{x^x}w7c2`}Bmd~J<xg8e<ocb#;YM!*u$TZMah5EMC$g#iKSyiqh#+Y@Gs@Y^ZNn4r<E8JW#itynh!wgP)ISf0+Ir>;_js~ozHz$Nd>0@2t4q@K-HUYLP?D|F=L5;SBIRWj*ph_lBaI1Mhwq*2)8_aFjHgTE2*fy8LWWavSmC8B`+wRX-O4VXkcc0|A*}FVL?XdKQHIm$Nrz@W-#wWgsIB=1iO*>xKQFbdH8Ci2+a^TP{`J<XKpg97XJ51y8ujC3G0LSF>l|<`s0|(L&`QHtJn_XE+d@v=pS6#W8xpkfLY=5kpLm4}X0o#%_Cb^$vvvnB5lotqj+lZ`-XwrJ!6PeW+?(#;`3p9tIDL}MVBEnYdCQ_0xYT4h_+7Z2l5D&AEYT}-<btua0&SsA~#m(mv!l+Q~p=v(Qu(sDm7d@>J%KDSJsWNlEpI4?r<W<l{h04kYYqeBNM_pyqL-$V<0nej7=!@V>>#8s5a>j(NWl~nHy%;K?q`AI=)B#fcc!AAu<gy{v3vp@9Da##5$|7L)Xi~ORMF%KL^3jpT4hDhEPg{?>JX9t@gpPnfaJCN{Qh7$BDit}+py02@qCk2eU7P*q*r%vZTLC)eV)+`45lLH#SxzX^ui@lzAd>;Fi_X&QX!{2b)Cf{!DUjg$Ce6+j&*-#!kUg#f7=vSGg?TujE+CW2rz*sb!Yr~%mcTglGY@!FUl5^pAUn)%TI9Z82Jk>)bBCE%Hwp7<H7G{~M4EjL32NjZ)X%b$!SkMk0cf_`Z{+n+N?pE>t<69Y_Xy#C;e6+_0QTkbMp@{R-O@p8C3GwpuZxcfQ#H6GPbb$@wBXmUv^!+(DW;i|8MC+LMTSXNscsZGOeZA|1?Wt;kNvSBP2>aN#Hp#d0(3z;!O6PTXWm{BQCoOOMg^P-6LSENm#oy&ukjM9qk0Cmk7id4ts$30$tfX_PR*Q=c1&Mbg(`b`{e{+iIL#eiXUvDs#1m2LWS-ok*E*5yjInU}{?CK^`DFOkwqwqla=HzcFrSaq#L>gWxUQja1d}@Jh`(^6U@Mr_G}Y{Z{ebAakfvZIt#QC`WW8!dM=do9kGJWm6EKh35k1Foh*$3?IBIU$ug}1?%1EaT6Pl!=IvOLMCgqVr2ZA~rY40Y!kL@Hl_TKkcpCYW@B&!-m1-5uCr9N*NL!4*m$#x&T?d>Can>H*8Bja!2BOs_xiXzfjf{#n>tWXEl>fjMY^wIEwEJD`7#4-3bau6XyW*y!Zv~UF?;wUsMLSfmtn)1U5;ugvx55g^Q$UN+^LB6%LUj^En>a)hCw{>uop}%!<=n(b5JDW2mGzENoSV$Gt8wt)ZwuwzsX+m$hi{ZNYE_$7O7v#}X^eBT`h>>lYDaUP&D=&;cbNA3B=VB)hyT8$ZZ>&4rSutxAcsd8}mo9jRFnN*U%S_#xWPUhJVh)@zhCH0gX(YPam3D4sm3Brgp;(<;0dLRTji71Y9WNa&WNmdN|HT}3#jKqc%j*zr47lUPg3)l4NVA59wyxPNEl_<9t)nhPAKGEtkDb?{q7Urr4G0&ts^&HFb*L86mem{1Oo*^*9_Tp(XlmN6SEA0d@-*!I22u>Px34G_;AFf~ss<}yH-T?l<rC|&0le}-!9ZvGGV?eo0C5N}5*;RggoY?h*4subKB^V*hKEIjIYZ68=vN)xLx07SbTq;`x^_mRr&+E7^c0ki9@)Kj;Nb292M+HAf&b9%1B1s0_DLoyXH;JmyDgI{r!ofDh|jh12{}Y@4^HAs8rJuYCJMU;cnIj!;Gw~zgM65Q5Gi6ibY4lZrynB)s4V<Jz|^Izue51RhcMgPv^$$U$c+zxaYuoVO=VFnbkxq88M?!<5PTE<s3LQA{l#);+#H!11uku0wNRLGr@#~mFx`1DYomP>rL;ku`V=tZlR8yKB!67Ez{5!$KT;=NzC{HCWrff(6P1=Rl)H-b6A~h52a3*-UoD7?_5F=qgKK3N?j;jOmMU2uB`0AHgCc3C$k|zIO9)?#U9}m7p6HAMOO48SvwqE`=?kOI?)=Lw@xpdykrJT5qEjODa50h>)I7jKmSv>dTdI^o{X=WmeY}O}THii>8aZ{QEF;5E8S8{#Vb@=WXdquQ$r+WS-$uzZqoLoFrQKdN02--~nL9)1QvokXDF76%)g}gvr8`Q67aVBSTC=Y~hRCLz>%7L7nmh7wtDMLb6T+w)%{!Qi+i4V=X%g>+VWQ{*KxPs^i@<x6c*b))QtcMUuew%B>BniWFlLQ}MYs9XEjC8~1ZB1X@Gs<f?7N9em#T~t->FZRnE~wacZ4J=Jr696KWlZbpxTdb#P;J>9AR$mVlEG5D!fSrlA8=yDTKs2@~5H)rZUSP%Yo6P&ShUP{dTzWvN^4XyJ&AQEy`)x^^R}gCIfdIS5F^zX%+mg{q#<EQm$=UeJkV>;ArY&nqAp!>Qhy(%z_?6c_&LBKgl(VV+4uKvC0-x8I#%7wfqE@OdGA1g$IKu8H;)s;ei%RPTowyIKO4d>)pr7n@5-yZ$AFUmg>;z?sl#04fXY=1t$(PnNJnc+0^<})hg}iA;fUqF592Nos~7hI#9sE7R}L`HWB(`r+nNiGTu4Eaq4hyU_y^s$^-A5C5eZ!>A*)Kk&!SDBk^Ud2Fdd(M+o5wn|~7P+%-=cWhWzzXr4LENvGVXl`|IwuGqq&AVuA=+ivCY$Cz^l)7k=ydP2i!CRb)<;$5W(ZmNw}wm^l7aA7^3taD=#YuQ;F`0qEHaIwHLF4{GW&;ypcB8!RzeWGB2EAy1C9t!4$;(;b<6QBi&4Kz)qUC3<%plHgjDLOCguBTvn(0R|Puu^D31BF@+k?$-$;5Cu9l&u0AL^58W49g-JLqHGg_F_XhV@BA64~x`rs2Slo9_!^33}t9)Wm6By<QR_mTM{1vGyti+E4AfljqK|lRXyf8WSQ9e34!w31!+o=K?$o_+6&n35t2i@ZM{C~!xzHN6S*aqFO@_LBpruW-L`dW80-v-<dC*7SQIXegzlYv#nk#*b9=z$XNGlFMi2)b^*c;PM?9jY69N_yCoUDti>k<uQYM!%QyWKp&)!toM5cqlI;~BlirKv1mDP4}j>PS9M>qTqR$D<~GM^PGQ5s-SR~S}(ri4JGKpqDmfg0t;8fn`EWaLZZ=|;|8EEd$ATQ0zp)~p3vOFr?XiecQ?us&ltRajcdj2{-w=R}`{ko)N1*hKCfZbyYLA2-VGQhtMgaw(iKyT_eRp|vc%wk&1?1aT@hW$}ep&Wn=O6X3(L){8<BdEjzJW_a-yhq)@0vJ}#9-(srp;{Hmh;6_am(q?k~w#m}7qc$v+!z0Sym=XCl#C(eyOD0#?Qfx^Oa6<$v8<@kwg^7L|&1uGKn#Xw&i#eC_XvS<O&`LmQ#;e}5IFGqHUb~o~K6KvS&z&Inm|zj}yzZ4PoBDuR6i9`&#hKs%_Y^Gv@Wi+feY#xeX{_o;7u04GhTAC8(fu}%*Lg6@`s;S=2$j}QhXbsIRVX(`>Gsz{@?_9<!b*oM6B`-~!tMNZv))RM!NJA1HJ56z;H?CY<~S$(J7S#`=Rp*w*7+0th59Un7GP(^xp?9WBd-rk!-h4TP}kN|bu_N-Fv3coxNF3^rLSOwRDVX8YFLL4^Qy*9cQ*sOpxZ||GD~DfNC)GHtu2vAuSDFZu{=&FjZ)Z_md28+l*E+z{DzM}xH0fFLXoq&)yfS`${>4dgl1wEj_maTH;SL_E|;7MLYBn0E-;vB5C+2BhBc7^31EnF15{XUfRvdrYH3m%8Jz4i(1C~?${m7TZH(J$B}>Ez>(W#P=BS7cs3SACrYa6^6~S*G3!DXO>C9`A5ij;YsX0P^kDAGTMrO3VXaKa6m>)2JWwkRlOPN{;!=gJ@H|tZ;DqKuTz_y5REK)qTy0;p02F(R!*K;TeGfBI%s|4KCm^xz<)v`N?k{yU(`vH*<v~e~rYnHem)_5=U0A{lj{ZYOF?xWjVH<GMzBxa}x$cIMe6h>h-g{8y8atwsr$}_Es9xY@t6qU0bHhXt5OEGwvl2$5{=bKhYLC23)j7eBDg0e_S>Rf((t`NPDwYOm-S~}DyJat&zvY=oSj5c-Z2Gr?{;p&VL%2L_hV`Oy2e0!wYw#r(88-j$cf@y+yzQMG}&_%hq1VfqJS;sik!>pAx;_U)eDQs(A1ElWkxG3>Xwm*q522nOqV;qgd<cH`)9*k5<(=#F+;mx{rD^C;LgnL%mYPdq~&biCg_(MKC%f<Cu=yH8~wWRAfS3vzK{~xJ>U8Sy@FFj2%oLJJGJ6ql2B5$N)l4&yNDQ8qni`+z}Qijzex@)465lD_X^2{F9s!pf`0=OgCG%<a_x*(pksZ=}xz_pMzsY0&FBRmU~0Z&Z(uAL#Zw#l@&uVq&#pVMXpOJ7(bsX1#7Tf>P$vCz_+LMGXR@wiz3<FGHGh-=dVui{8uSWbsjZB9*{n-ATxcJB>0^z^OW-o3ed)7lLMt6J1|j_XBqor6=f%<P=r*1w^@Z|#P0*Z&XqvR{tuW*Y#XTGZ1GxL1Ka-;hId=VZMHMh5r7UrK`ul(Sf>nj0ANzJVNf%zE##8yLVfA#THX;6^6rIuEal-q436AZ4@pyBTMNcEz+&%XIK~#;{Q;63jMd`gTnS6Ts3-w7j{zX7o8!2#H`5rOXstSqYK4rmCRW7or^8<)(Uj;bjCRhx(;+n#Ur9<nS<%-vSJZc!ej#qn0=?w?ntrnLC@B$s6MnmhJ0S&R0#TJShZ?@Bn|3GM!WyhUDiRBIjFiDT9$e-H$WSAjyyuITAgC51C*cGlP~YJ^?j5ctyp&LMfZmN1T)wPD0zkk%Gu>fq4V~&s57im4M?8wbhy`X=cjm+2o`V9Wc^Hx*q4|N9G>kt3Ip8%)&jIe^0kmrOSzMc>?k#BG>4Fl_(CklDlM{6k_;%f^-D)SI;VwNA=A5Vl|%!KL5ICXmwL9wCbsiXnT~nw5x|o)_(McVXOgqycIQ&dbIS6W|r;Bp3!sAP(&w@QHtn19AN348WW?MKPN0~BVZ&>0Ja@x*?CK(js#W_iJ8uF9QEbkHNCOBcCBQk(WH`n4eP))v5}}Tj&2%5LI9SU&{2iqd#|T;PyJYQlp6GD3yl&I^A1GC2+uy&l0@XqB{)ABlM1#cdJC#FVyZDVB$yGei6$D+Fpo|Y$ruZA5-AyL$WcLQnwcUtQ#QQ1xrdq6&j&hGN`#eH7F#Emvx6xyV~a~Bh`tnkw$VXqDK*?A+PyI9vysBbZ7+(VPl%$eb}JnEMVidCodX3AbKcDLM%~cHP?bf{$GHhLp-=zGLWcS^ns3bbu9qt<w;fbD1$@Dq(01^Q2n|-To^j)pXC(nHrbEp(HCdmKoRuTPR9~1JRV@iP0r)@Z@yIULQVy6%9^P)yc)ZX&aR~uDP?OhP=Sr+u@F&*XW|-)~Wa(M&sqQ`X7g-60TF$+im7^@Oohq@{scB!YZSR|#^QANf_b~M7_#R-w7K>S4orDcRD5;abq0h<R5J_Ex@rQ1$TY1J^@+VyVCuE?OYn5?{AOHvk)u9rZbf8h(LXw?#uBLMU%#bynDil(>`y|&YUg+&{<v4Kf`FZeMil}xI%8=2$-sAzU6i6+`-Ul-k^=We-R|~eGT-lx0)=z=Ly=AzbtI6cNWy_cMGD<pP7IcqMmgJ>vm{~L6(b$SQEaOQO;CC=_Zla;mFsnsODpJw2S%&4d=G_T&#aWI~i>yA4?5^&(Q%9G4wu!PRG|lLS!NZr_`87;3;lVb?sRi_f5>N&@V7X8mGxM1>xIIsI{4x(`_gqgo&NzOJ1mId@9>8{U&>_n=@tmFnQaClIH0ZZ|l3fW_$Ss*E=%|1IbCy1wp$gF1Mov%RwZ@+i6>ZIoOm;;<Kc5-!sH$rnb^G7-!e3T0K>#MKmM)6Lx>pKB1Fr@q)PaW8FbNWGZ@PiNZE|Yusp$sY#B95gyEd8<C#wiAh~QLE>+iGcD-9gp?-GMrOwr^Ov$r%TrP11lqQe<?T|N@XLe%7_MBOZ`fZKH9sd}4_u|O<`52gqymg<IBhU;-dVk*M}QrJ3=fDizJpSwOTpnaz%Jj+*bTLrT+g~gObtGQY$<&v0hX$l%Eq$NS@Es1X&j=mf<`W&LYI43<XoJq}uRZWIg@#?*MU?e;n7fo@dq@^n3j0*aF0&6Sr8|w1>EPq()I=?q(y`)*j0EZ$L(dt#4Hgsufj=Kvc{tF^|u7cSt*xMs8e}-_VZmia7T$Q&lk2<@M6dnDV1o+s%Ogb9QdgD3lgE`EWYI%k=#<$VDSIUAdiu!ns(x)!tN!@j<2vM%Z%(M;dbYb?chA+*b21A{ajUmow4WDEVBsI(k1WCYDfJ}otJ1;ufFpe?8IGQLkozpl0b8-?7>oW|w<xAr|n;y??w5<W9ZB8{R^3#(|4uk)MmZE__8Y_1dZ7HKvZ8QdqC`A%Q=u*T~gyh;IurTs#TwK{~8b#ec%5h5FSUc@4OIz1ftC<MoCcL=nmnLc2cN;a#BjhNHa9c)g+LWF;(M&Eg;_FVi9E9y05c~8dE9-_9nI5&aPzL<0>sWUk=U4{c6YQV7<XdqUhr#@k?F_=a;8O%mZ@9*vdD0*YNfxwQQ-Xu^BX8zrikXH?$(`~cG#ZmdGKhrFn(#dh!-X!#il`G@(+km_6<bEyJ7MIroPiGEc^rIPgL&d=-H{n>1f<l|xX$N^_c)joFj|V3ITWsIAfWj9MT+=k(co4=J6S@Efqf=8D)G1<z!{`_02$L?lA42wU2>P#ld#L5yEoI&5gH*PU@U${9#0|;GA9z(d6MI{#_qXepG5B5?e5&U7))cA_StP0C1(Ht5;bP&^<;V!ZvP`C+CM-W$s38>@T5W-eLwk%&n=%`AuOL>J!rAx?|Df)_k{F{h_5~^STD1-&zxN?tfrpdi@~B45u+F`Uq(VIF<}(PldRNBV?~goA}wMChsi=ITQf{F%sss&6<FOmpIfvj9<X7ib_xq1TwcxRS*8aPmb0Ax3pL(clWFkuNTLQ?vpHIZ0|^ppAgtyTD(;+C5!|rC<`2`bu?+8&qsd*juL(KFg|?z3JE&jupogbaM;u@m`Dl(wg3ZtJ%m{-<^Uk_k^Lbu54asUx@3sgK8aBa&f$+e=In>$$aj+&5#3kfrAG976a}_4^z(;@)hv8&Agf)~gOa}{cQ-wiRE;b}c)U8?eD@~&6B$*>TIWeFPwyb4LVDI&e4nl_zGv+(Fk)8MbP)V3r3Ru|#KzlM(F^I{*3Y^?bQ*X|UkRs--DOT+id|W|?+BNr<44Hq&&!WCNx63%DRf{LE)TyR%*Ru?KBbX<s6<pth!C%-r_C%A9jG#o)tBnYM);a1in@=g|cBm(M?^JK<<Heh5r4P<bq$<0lYB5!rshOO~mGfLP=EF8>=l!k0dDg53&?wK0=qC@Xj;tDK38UK77|XeY)iCA7*IdPZk^B<d3alI}h}BpHMFndDPUR8O2ymi2KnlnLtHRg1jm59ibbEU>2n`j^_xp50US8WB*@E3!EQR1$BP?IPowHFOz`(ci)k1@U*dDj@-WovXwz1Z!7v`~7Q&J(UFOR$dV`4=G$2?2w8G#jwkhLXWGn0->=^WxO*CSN!gXl28g<+h}vJiU8B@^fRXt@Xf^ft!ZbvG{c!R^pf)AB?-mzQ&MDJ3a1xQ0?9S`O1E#>1_#^0>vEgyHZBv^X6?&s$?}YMYKIr_rcCO(~OL`mifhyZb25^XR3CQPd$JS#?_>lHp!Mp}9IdaCYO`$&!)Xh03jzi9|82M=?W%ihPAA3f-o}1=MGUYk%j-Cq01wL_%eE6=C;~khX=h4ybz)$u0&$8x`z0!$O=2xN2@T+(2G0sXlLhZI&&u02@MNNbI$1_%dj9Wm9_EGg|g#XkY<qCQymnLYY@-ByaQxDA~#EGm51XJzfD};i7IYaf4?c3#9c8aq!oOK;jHfA+5G)bWPbg69`Feg5jv;ioLlmgKh+Z@|fDsEb{Cog>>E@A`+H%*}EIOS;E{24eELIZJ}&oy6affPz@!DMCO5OwHa~0yRMYuvfs#zHadl?oIPA-$pos{2|h0kEMO>rk}e~M=@?DqTOEnAj!vj%PBT%5E`T0M&u^Kmnu+h_P=pq6uIAn_dZl2Prd?JNFgJzjM6=G-_Isu(Ic6Ddh(OtTY6u@xMM$6Qj%lMbu1Mp9d6J`Wnhb3p)XKiCDk_=>wrVsDSV3ew=+&Go)7%zzv|7%)(kgo9x~NCtTL*w!IW($;k<+6%573o;Eej+~dzcl-#mtp1u2uik$1$@Jx00j11+z_BCG@b==OF=Y(|(^+UDgv@RLc>2m*ffpYKTPwUbyB2&@7KJu`X)pWh&-CB)AB^X(0i{fyU{4Y}XDiBg4!4{dxJkh_t27);4cPUj@o?V%rDN(+z%l$`?BCs$0<fREvcAxm><#PB=9es27+?2H$plP^9;{rN~^TvD8e~C=s?EnK=OK9x0!`?ag6;v`g5{FvnqN_%RUKr*RPp3|T49IY*-l9jG}2@`YZhxWZbRH`+JI;oaCXFN(pBDL;td9!!;8lUggy*2r+0kwD-rc;x{+%GD#HA!&d-dg_`6&1Uq9b{HlvB(@Kw6PD0!B4tjPsk|lSQfX5v>f<SoOJ7TQMO+@<7^q7HnZ|WXDg%3EOk)mf7$B37(7WnZKgIFddKv}iyS0_|+1I86-I~)>wVph|R%OkH|Izl0<CCyO8zKl8m_!wd%O9b^RBbN<Dq^fY*Z+~LcX_5z$^sv)XSBTyiCXQ-ej(1ZeyvHAkqY)NLs&~Qp&zMnVS)+O<Mg?c-9$kF`-0ACE$5h?3==5l!SSPyc<Akv83GVD)g(Z-0V7M99P>cM+(q<8W=1L~{#!Hd%6>jxneu_b-nDc7pJJb`k!&X5urKrrZ0pu?UZ5P;K%z;pX^CPjJ==o$fg7v!LkR1@h`}90cH{i;D%Pl(28he>#Q)oEKYn)(%~0usEDnKs@dLqnySBX3VreN>GObWfRkU1@EZo>}LaFYqKRyh1ps4#cTeT3SxGR~{fjfCB(3Mdgwx*r-!zk*_xGazw5gG#i>ZD$DWYIbpCtTT&F~vL|3Hn9$HdiSnlG3~NytGks2)Qs<aJN!+*@AAGi2k4_r7F7p;Syku7?vnvAA?C!GcsNkm=l-|-9E}W3q?sLG%7u)QD6;~!92*OZEvZVGyIDY8hTr+P<kCpWz_Isn?UcY8yelSd1Pky=-$D>!>$79P2@#Hhe&eY1CAwBmm3m5DO_4;BLj>9A<gP}9Vk>0`igUJi9}Q6(Lj%*!UfwXu=>mC93mQ?yR6YnGv^*&SJ0p2Dhx3m)f!AN^NND$HOykl&K}x0+Pa1thuiENAQkg(DF}L=yMy~CB}%rY!%BzS>zJ!y3nkR&T(mN>`x8zZu;^H9R5Fb+^6--Fmg&ju%<I8hQzc4H%FOS)T31N;o#ABbXw{czU%-}9$05OMSBvap;*pR7C7XnqCF9s+!{jV?WJ(j|FEQ}?NSH8;qsI?z)dJyPEl_4J2aXvb%a{h!G;+<RKxrW{e_eQe;_|80EVwF=Z>>b=l;xSZP4x6@e%Bn~zT-Gs*_9X?+pcZN_LRqd&<Nt|rqrmD8Y%70ca(1Q6~`#YC2+}6m`XjHkdDt#K3S1l7L$|PDK$oBu%rv+jSDMn5#9ZViHwd?xv7Qc>SSyzh)S9ae{L$gz}AQpEzOib&IR-nj$8UYA?z)vS5e~6<&CnG(T#?R))tbBaG;U$4w>`OhMJCBEsaN{j_BP|Qy4<0FWcoyvX>2WMi<D16SHSnsWgi8&fY3H#WLm^63f&qzRX}zG>g6N5XRP>T(|yz?7az`T}72RT<^ZuTM|N8R6s@}Ad7-#g&;x_AV}EKNjeLX<fXgQojj6W(n}W2f~bQ!$^-*HQ3o5rQCwgIbOv`u90|)H@C}Fyjw0ire^~@|L}%o?wVbNDr%v5l_r2F4K;J-D-SbYJbE<AFr>ah!a@H!c72>SR6!ILQ_But(W&0|vUN^T7mIpVM2RBqYyGSj{WAo}BpjCM0S`bh~<Zit5ha|UV(=)7&5+*!w5bm@H9eyVAqHcU|^T`NQ#jH<djo1s!l9{~BXNYebhN!yuoAFW)IY}9K+&N%ZC%1K$$ZS59WFN9ti#3eS;eoinfd#1G&F2}?<g2F+%3jzR*bss<=*t(eLp7sIr?^s^Zd|DuOWUe91(J7%p?aRsb}QnR%U&rouj3t+p*4xOuEbl;bE$lX-@A`Po9*Qwy-C{a$~)(W-lZ;G6h|=odV9OX>AJZc@o?7#z9#~9+}Vk6*5&+i$8b-7dANTsZB4-Dq$+Bb!(ZsR%3)~d23Y|%#YI%Ht%3XdHsjTeT%#$uy}(aoY!Vj>klxj*Ixm6Ep3qQd_LZC-SB%oFTg#oi9hHarhPe@1=9p;hpLL4+x6hZCoOcRO1=W_A@Zc0rBsb|Rt<IO1p37n+v*vo7?_lB_J2#C=n7;FD!UeC=*ltb2V407Fo61wqDED&JIwsjAnuai061&0GWy<PR<l0w{wf1E<<~H|isLG?|_)0d^GrRb?CUJ9y<!+F0z?QIW?`a<zsB9_s#JX;!f5X-+T_t(xT1O9G6y(0^Kz~7p#&Y&T3%H6X*90B6;?-|T1h3R_VWwp-#F0}gQRS?9nXMzAXl_GL>-{{#;IX@=9p!{&Em(?%-d+oKdcAzXovKvxd;5on=7Xg_-wl&Wh(7lAj;^7(L;PaIb?s_%Ox$DDEqtx>kJ!0s2)uBKCe=gMlwA5f?<2J9DW6rQIF?!mqYzl4vnOR#QCjUx6qDNCtla|4sycDkxIy?$O*OTep}UDiU4wnY1D#z-m!zcXXq(5%3+jk1PI(W&blqUxgYL0%r#3X@rT6J_#>F~UJ7!LJs-S#?R@whbYt~pJ8B&W=_AS`{V;NPfXw+@X6Q9<Vepq-(@WnD|WGtH0c~h9Ei}Kt)OZE@d7FgoYp!5kbs9i!-dmdGc>wUvRvC1R6PT{0Z4Ap}JqGwQRY8~94WRG=NMej1noATmrWw1T&?6}s^xpin=++`0)$7IUiz9^X9@?cqAN$WX(P>0KWFNphcxhgk{zpJwhXO^W$;PSezE$Tv1&$-}APvTr~${K4x<*{!{ipLl4ozJx2Gw0GCxjcZ)Nb{}HXRljTabh;%umJ1V+z!q%Bmq|lTr;j}fu9M=e8sPI>ls~f0kvrp5b{h5_W2=egm(H7cGNM=kD#ksn5|W>R}ZU;z@LP6A(8YnIz7|#9kuo9(fs`9=%p3K;;tcWJ{q{WEKk^_T<zFn_3|NGcZsv%;v3jXw52^)H7msT(##O+aALj_*XC6J*OrGWby=v6<CVuy3na6}Xzlrw!{+Y3T?1jR5m%8e9m`l3?WtlRgYZ;0y{ymClNMU(E_qzTgo-|oVJ%JN+UrkQx;oLm1t8^Alw~VfIcL$i6=^9s1zSo6S_`XL=#;W`&^^!-js5+mS`NJCFYg^19FUtgmBDhXC~RmS5a(p#N+S&C;$ob4Vp-k_zId)YPS0(&<P@q)t}%f>r__p4L6g#ovpG3Ri%eoR5%&V-cz9LI<Wul$Q=BWz_G<{+jQJ+FQ>U11W8uh^w~jay;1xBSBJCy7nIhM0dn#=5%-EdA`$HZN`l6R`cBQHod6V*|%%@lLwj`<YT}ID%JinVC$`fM%_YBk9)f+d+c}&&JI?P!UTfZSzQD_9MW&e=0c8I&MH5I<D(7r)ALG<4zllYB)ncl9!;m&n&q};(x{05IcP3ic0g|6l~cB<(^z)3}FJ3~m<S8Y#09VNGXWvX>!d2b!J8%^H0C2xg|OQOBAZ?MZmyNN?jRT+bYE>C%kW9l*~_AJin`({H=52$l#oISY^V6K<b7igT(9#1>goS_uq!5lqvuz_I8NKvnA%Ip~<2MzL7lDI)-UVK>P)swN#5tEdYfA18^@A4iWm6da=>1EftjxyTid))KH{hwm_q*YwPt5^QP=A@e8C;t=xyesf;C#-fwcP8y>*WlZ*a=9q0!UcRD^NghOCEWOijxaMqI#Yc+y4&-`ge#rmF86SbaS0Fi@Rg9EN<3~TOU^}Io3N`IwPU%aZ!>mC6ryAioquOvxwC7-hH32s^u7pvkcaDd6?s2utXXj_E!*FL<)mL*P+_O1Q^K8|CT2+HDx8zbj(3|XZ3r?wN+)LGIs8<|oj^P!cCAM~s)Cy`bY~s|98sJ4hX&SEy1TJ=WXkiGU!gd&!dqZx7u(#^)gv56^WE3>!Olvhym?*xUF5B}e8E~?vklflw!KkS53LQ?wFg<RxI&rDb{l(A*&O@5plh=_tgyLrK-@I4c~IGx2AP0}n$GQCr8`Mk8>n7iRv5?O6lE(I=7Uu(x6sD^VGDwT8wZB?91896WO#ak;YY03#7TQQyR3M3T>I9DBQM4vHSLO|qlpU|L-a9Rx2yJXn9s#*(#PTGo(fCcnm4P=;<?p8rHj5!iu8;k_2{-rPgmdYP)&C>`Me?WA5~j%M_9R<>#_JZoXpi~Attld8Evo67YmJ>Ep@hU=-ANP#f?#w9~gD7mr>uu#r55-XlXCS>s05wnPS!pxvyxaR_D6@*}++0{9(i#&su>^93SP%!sfn#HGItN>+j@>xzK5)3CF<T5M2FaWvhEbT~+{usbV}b$)i(hdT_>h+(&ueKwI)Y!z%X7rdjtZ`MotwnKw^gjget^DmQg1gB!Tjb?tLzGtVLqGKZRKXD_t48~HhmZ_F_sK5;9b!FtrewmO+I`X_3wTNlXsShYUy@!aH|6M-v!Hg^to_DLt^;3k1}m)EMBY{@<_*Zu8$%CMtzknh!RXdmP!I2ZBmz~gMlUA)z|zf`QdUuxR*G)GUghyL0uOEeWyADKq$BYgX&Z=f=?m34RZb@Q%=_gRCXQx$5z-(2?+au9hwHkvlhC;8dN_BDOIe8;M5V4y56N~ox#Y@ug+t!DI&u3q`A2}Qe#)5X;^j2vDv)QK5!w!R)_N5c2m+L%w*yxvWffxh0JSi^8neuvXd9-@PdD9ejfccz;hyxbe;Ur+2U^Xy!3#-e#=WirWYbMHDttxC@$4$RNAobu;!$6qdY_Y7qyR<q*%q%1_J)Zy;hndrlW-7fE0*wh|;yVrINZRVXzu${9qb5@(A0m=`hAZkC$ty|~v9zWr)QXItZ>$tdmV68OM$uj)FyWrFKdA2oO+I+aiEs$BA?eR3aA|_q!gO%QDo2PAkCu}S_hASI}D!pZE^3IPa&K($N->Od13>x3Nb@BYFR!zhlTxckryrj+ES0yoFZtb}^t!Fo@E9!=KxhmE=(6?o)W!*9p6e6|V=Pb=^S|qm4xm`?8f6{encibHgPLp(|OLbFu?OL;@+V9|X)ex#(R`2;pUe`#tEub~msb#3+0Zt4~Qcesq^d@5achoX#HVu{E3O>u9FLb|?wLdg&8zJs;nx4=6U;(jMUrp<_b}qQZR}a4(N?l;KsWKRs$QtsKWmwx+H9%Fd=&nv0bm&+o)mXX$7M2o2fA-pX=2pHqmCg%yDAr`v;)i_+SfT_s5k**?9e1XESv5Ys>tp||ddbS*=1z5=pT1A1TAkPV(%s#pGmp2co3pxQpD%{SLE&j>%hajqT}H?vtUL$?9(2SiqqEegYN%R6v6fi6jpN-6x5eU2kMK|^yjPyvwRO-MXV7t&9?}D@TkjKNm)g<MH=@cVyakKp>Yd{bEZ{Sx_GtnBsHWMj1=Q|?I45^BI--*F$6Ix`9pJF{Y)fgT56+CvF8u<bxy&j{Z{FfK$=Q8<>%|;dc)1zWp4i@Ss`C1RHf?H{DH6*YGxNLNtjPezsT?N;+)f+1_>|F~cMtUSl<Q+6<8h{Mw#ODohtyNjJM*EQa?hIft*obCxUL->?ilPGsPqr9sWV%*ULfvtkOtg*yY{SD)dsDS@0NA;^s}VPjLeQgS^w5W>qs2rn>K~IH%QzXl)N;E^~ghWq(}eIb6S}@m^F;Ta*=tczbt$-^~jTH)^dBh)Y{V(5px-Niq;iklp=PU$+awNr38DKArBT*b(Op60y2g*QRCxbt#e47w5WQ9nb#k>n8F)h&^>B6jjM&4<|b!qwRotJwPR-4y3|oMyu@yFiWR1IP)r>1q}OhU!3lQ2{YHb%jiuG@Y^I&+td?dj7e8vVRGsz<T|g%6F8y~kXRJSq3e(QdNtf4l^~y~&;osZia4via&gUqub?fP|a%6nHrcH(Isb9#<pbm3l=`xX@FcWt&=kp^%YBVW+-cxoT%t}O@Q#s-6XjeCP2U&-chNko_8>!nMVwFH@*}{xUD%yP=7vlv$uLezc8It!2RC<TV&L6ffQ_gETJ${9E^wY|VvUC!mTJ&$tSDk#jmD(Fce^;kohYNP*Dcq!z3KksQIMJ_YWUSz)csmWV-;;WjSYJ_}m>)jk?l;$1@h&UgjZQvxtGm1Lji{-%o6@dB9P<+%G+NK?OgfD|Q+RI|y$86#fX#SO$<BzmNPDHkzI;pr?h>zdd<^yl3)@h0vkW_?PP0uGYj%buE;=;F39H^lPu}`UJCY6_&QsKd7;4{DD>g4FL#Ns;(~nlxaeQ;2%S5|nZ?JAaSu0Byg(*9+WHW|k)auUTC9h}7W7w9tQK;r{`ohe5S(2xnSS9og*CTP2^-?;*C0(n6Vf#RLr)_U!E^;T&iBk78*6ssZJ19>*cU#qjWlFXccb@wS#LashU?O9zN4XQR04veDtf=FyL1)3FDl;Pa?PCG0<tB1Mu{XTWTAH4B9y(K=oy=Ts;XM^US;p^|mrB{(fy&Ujp00QZnWxwA(WMUJY^%N&&~sl@!u5vR#J~%6oB?oQTa8(+G<lp6bSlrgFD<TkDlZ(ablG>p)nM!)Z^@atp>OTfDP2~a_T-j}bj=<vjb$LMT_L{`Rn8!tg-c_KNL?<JytpLvA|Z4Y`}A@vKXMNzV$@2YI7Qyw)7~Yw#BzAT7IRsB(?{Gfl3l;pqVVoIRI^AbXYbr$C*Qi!)&RB8md%8(jai>^)VxkIVJ0TE?#{kpIGHU+QB#GpjE^n9|7pg@2JQT~=O0|JE(uc`J8()%`-ZR1J6KT1Y@e*)T)PLl;_B0T;*6@N2%tFIE2@0L6eITy_j6n6kVS0Tnj`*^THFSwf0hl592me4l(bnH47A$}(Lkpmt(Di3_^%kqJU$807-sim!WE(NFeUFzZCl5!7#DL>^zxEkQ7^mJyaT&V%(XFu)vf8mXVr=2MQIz-e0_MRzuYs>$4}_+GrqEF)aJS;M19WVvrI3>=d}>4+htN<ks5R`pkf~kAnI{)$#3z{w5k1-uFkH_mAHS^=fL20B;&?$Xt3Jap;kMvPLg(}e+_x2U){#4&lxILNA1H~LROoyPawE+r>g1;cn(!(JcQ#cal4c7r$y{r<ubdh!y-Cvt24RFt@uB_o0>i~vh`SP`S0tC+_l}5%Twns;Cmu#gd?&#Xbvz=RC;5*zp{qk<2lTYi%EHBaL4@0;D6nKazmlrfS(_;UDq|puf`EoN)6WNgiSo?N=Np+YlKaU$kAEz&zr}(g>`?0ZjH8gIBV7rFebyT35ngQ8J^KW_=&PS63NL>2Z@{F-8N%C!4}0jN)V5zamfzIWgvTCl1C}*p(&T4h_-->=PGA{#hT@NcY|>^9P9?kcfm*=BE~RS_y#(|+|Fpq=Nx%t!}uI>4?>trBHh*NxIe9^q5gc;mOA+nk`3H#G@QC?@6adiYVFe0c#+bet){H6dChZ6O(n=v#$>`%K&oSYy*3wk_QQ3|-czZEDd@aZgQBT3`AKNmkx0i*vE1{@!px{jjf}YBAb%x}hwPpWV&a&xe-&3pWhGs!vtV?~ffzrz7s|4*l3Sxra3^b!{~-SHljWt8V(MbH36tISn@H$stg~ZaNQ?)A{rWmI>RjGT+G2Ec?1|-Fi>Y_B<+HUVeFt`P!Ld`WQOnRK*VCd>WGTbC;oddsVs2?q+q(6PK7J|M7Rv~7R++0ej=g=4va-)GR}nerhf+p^ygVBUUNNnmvdqfgGp{GpzO1va{I0&9j!IYe05>wD_i7UB75>d{gUAQ6qro@zl2~E3+!t5nlW<6BO5A+Rx+GX`K{ML|)pJK9x%_Flz>iZo4&qadq^g~jgqw7rjWoWS(8H{SbygOaY)Nb6gpQx>$#jSt@0AC;HV*TzoPH2cnRxVdSeKWef(*8Rs)(%hh?U6Bb?pPwr(std`49G_9?`GQWhb<Sg|_aQ<<3z~61s2afMda~6khF5VsInh6JIMwyFf=}u5TUTd{imt!3*}b$C=!IIO2L7e?Y#onszy=_hL!<q^olC8n^UVlaA+P-NK=)dfy;=-dLn9Lv4NQ;S6i**49er`VC#D3s18WHua>|t&3IN23yqrSP>IlNdH#hxTM@2>#m~uaZl-dhOk&1`r;aF@6bTi&S44X_I{<&zCF_KV;$Dlg02GH8+%`MyLnNZ>6gxQlDCJ;HJ1yzHfxtPXLfb#VK1eu?Da@<GuCi#Mb7nL#^0~~?Ja_#PR?5fy3}PlG5vv#zQHcB7bVtARQG3(HKTb`tJm>f_%zb>ry>sCrd>=e&NxUd_B5vYuxguv>}6&O*L-DuKX!k)gI_|-og?kgEOXc|iIsA_Ma?^nGr^rQ-yDT$2lt3u;U;6Ee5C&?;bd-68@8E9S<>8qe4T`?q04SnDL%5+o!Q0z&LhrZRktH<`>z)#xI8E0>*SP2ZVXU|o45ldsHEg>VLrnXt`x}C^AxA`N}bb}mz*tbCAO|&J#j`^c-34Z6lHNW6aS?0MBK~k-dcKH5mth2o&7}<l66$pR0g^_rRUh>bwfQJ@u(h;$k~byeejXGpOCyprbijw&gk0GKds9|^Iz#ETX!sTf5*W3be4IXJ%_p!_2{7|8S@Wu^UCNff%!HE;u$3OX&X-&x#G<nyJl<Cgx?P#bTB^Ex7zHi^4^*H6E{;*p5F3XhQ(#j-#5rTw6qVb6`So<+r#OJLFZu5Mt?o#V+$&3kvtxx&gvTKTsOaWv2+>co(1w5Ov+QA@i@9Jo}{b$Z9I0S<*91u;A`lyLceSvroy+gd1jUEPdrTW>Mhn`y2MgG_fklEKuTWv=yjfg3{|F-x$k-5y)UuvoyXoO9>$0IhBsthcWP{}@vU2n!PA75;qLCBb&|}zMXxFP)LG_Ci*anp@5B_Fq1q5E+*}q`3B{_DEFPayl4}=4IP7tKk5_Tw_tCKEO8Fz#C!liWSUH0n=;JGdR-7JJpzQIoP6b(y<hkX^*edBY9d+XhXrLWjp!4`CUA-@p(>X3Z=1iB@jVQB0@&>!CLpAd78F^Uvcy(w}E*8uA|1j+zi?l?py94|M#^-I-gp)_K(8Z4Nr`g;Ye}&$`vUL1Dy=$PmOUJs^batpbjY%)lgE^)pGt&FU5cMO6AKw}DvXbRbFm*}9n2FTyqGGgQX6^F8(NFNu(AUptj)p&Ybd|?RV&2x>gB=?YcIEl~lX$Kt4|i|D?PNTochGG!TpgIn*PB^ySNlN6R=zr^hrY$m&{y5{Zp22xJZ=>&7rN()0_K-ewfA(HlZole`{q9RnoT|FW$Bsad7f@8VJs1F{{gkzDyHS5xhR#<tJkvFB_`}~Z!dJmHT0Tt4xfZs-j9;5u-f3N%d~^5#(!GqJ#hNucDuYFOQ=Q4g)Oa_@skte`A0RP&yQ7&xc3!(tr*aIItKWyc~C}2yTd7*lhWrv5?Rka5i(P#7Rm=jtmCZP+TS<SmFd$^S)?fIR<7#LlU@p?sncR^oy-rvGqWflS0s&UV9bsDXRLDQm&B3P%HVKZhvO<G+)dSJK|3R{PutCUM4u+|-WIE^i^U+xq|%mh3a>)@kT}gM{ccb($+Nv;mg{VZ(k5^<o9Rd=!g1FvH<0VK5GiWUNo8}{0B=EZwb#E4#1hxMEwX1wY4^CzNZ#Xyt>x5Q+PBoR=-du^i*M?5Zs=fJIjEa{)a+O<e_$ON6liO%<F`0TJ&Y;(pH5z0+|HT19F)Dtxm{a3`gj@f&oD6DKg5+varbImIva=kbZ4V}?ph-|o9-Bm2`84U!u<fD`@{9Ut)1N6RGdMnRLSGK=X1Zc+}}&w9OiA<Q0X7645~W_>S3--D3>{|b1~ccwR)II`U~|Pk+ttN(|0L|Ey-C`%)Uj79~|zGcS`v@gQGiJ^W6ZDxU&^@e1lGLgsfqy(MsA*Q9DxnI7=5_2jFuiarokb;T|^aM0H499}gGTI_dpe_-rQ)ZSE@%whzSvxVB|V+TaOSb3;AlwLSb|E+*y%>$|oN_E8noRSbCD6PX*>DjRp26{gT3lBSsW`l4#r{i>KM7>{rnJA*-+20`a@hKKszHZ^l1NIP>OJg2KY^f)7%+6Sc9?jC+^^18m^!MLh$Gnf7VWhLu;j=gdx{H+dUY+Y7$t&UhznKnz0{Pbte-G22tZ_q3rUuRVw+|cLkR`PU?p-bz^g^p)jCA>)pzZx6Xw)gb3ciAu9VqE3x@p1JK2jbKPRJ6^Mr-OA(c9U0^iCG1l+#TfFf>zJt&T3Ftgp*5TKE=%bC84a<;as-o3`VA1h0kPM%v_B*IG#Q0!~AmDBOX44^XpFK_4RzYM-=M>LRC<z5wCsVrdeKBqV*P8tdd{9x^Py|kV)TB?(Xj!6q~>`7nfcQD0dEnMLW?)1W-(#tgXr!lroK0rWDEB#Zs+dnBy~stI+(ym2yW#Y?TXd&s+oKttH_ijSq=~U7h3?O}QXTe80}EaSt4SzPRyKghh?9<2fCC6Qp?ewLV=gf6ONuf6SSqi`W9O+=GjA^!&1%N~g(@m}_&LL#`dj9<n^84y}<imyaoRuZat+i!fG5Su{_*;V?~ip)RLJ7gKWsIpQvEp+E3mRJnx{z-kxml$p*M<;AC$+1knmab=NpZh6gy)=k{twRf#i$x=+xZ8KUt3mY8n?yhWMYcB5CGJSfxDRMoj_FderPndInFpE)#UijQmoA=CU*Y~E2Xtz2FZI0^V9)$OP+;d~lE_l#PNUp;3I}G{99c1FZrNCvYKqn*0?x3o>7SVEiPem+xoF>$^HC>$*o@3Fs^CRQXooC&bMqaW8TdKi5FL6b!-(9qA%o^ZrvJUIYQ1D7y)W(a_scLU!5StNKcPO=g9=bXsr@vm@u};srC#Yhb-8;8Zr##fBy!A3v>M7L$+leS~^9PtH#BFl@W^5=@n~cJVOTrtu=zMxA;-VwMHeHT$?rDA7=ZHCjy~cj2*e@3gSF>xn;QHGR!S`f-@lAX8kaT}Pe}OoqPzFEbDHEDJPB!5j!MO>6-sLm!%N!@EU5d;^w2fTAnCy<rnMdm@z4PL4%$xX-xJj=k*19VF8@95k)1(V^wUoy12w$f>pLKy(zYY9!K$jKo_S8Dl5qdYUriu+L`!mPmrg1$lH~PwFRW@|Vo6OIY8sfa(&b~E{7ZvsS!*7F<-(Bt1RJGKnFTET6gJ!~kf@PIlo@$1T%ntyQ54<~4wbB1+Ax1^D=Ni0cdXFXb#4|~lKTi`zV|<v1XY1lxBJQ;I9bLV1+k}Fk+{VCEuzy&rLU3J>c6(W^HHN-7&ONXmuxZ?B9A}?gu`kLIJ=1wp%jO=AsZ(V~Ev}i4QMiKW>}Xgg^ce4%<4M-!ax9H#fqbPs`39;m(bKOTl3R`iRyvo7=QI_LW5s8#l+h7}o+uY~F&B2J5wJ@E*bTX`8*@p**cl4zBL@3+A9f)Zc9aXd*Z|mP1YnnPVK?NGq)B6U2Vgfl*b$o&fR#qmU|njk@AsE8#-=22vC?Sb=jZEXc;W^b7T6MqKCeM5Aj*1VP-4#&mW;sLt9mpdM32;<B@jK)U_ta$g9XvklN>UnK2(d?2GKui&|>CrUJTK>8r0_FVYn>NBo{)oQ-wu##cew~iPBl9OUJNUIG4!eLOPSEXpd*Z?7$;0fu}I(1@-Lz>Vqxt3C9-Ls}CB%MV>Eph&%<h%KfgZ!cs1EQ!d4cA|hoo8)Q4!;j>=r<j?#<2>_qxFZwgC{0sVGMPA!T>8<qZO?rr4zX8OZGIF1a|4gH`LiCp!ZL^2R<EpC7R+w=U{^>>;9l>qN{_R9mqwL?pI7Mu#!-2yvWe)QQZ&4+>k=dpjA$o@zx&oJh^9c*+y|}?E=04cly|kt0&*4gzV^!G5p53~lV59(k0LM?s%7-O6Atp{qbs#ThCmOMH(a=GS<))Ll-gGu0NQ*;|oc>vqcob>WO$HUBA2eehM0e}4Z{wDc-42(9;apZi^dlOy=pzo70gB5aH^YW<me6TwvqYhCS1n&VZ8dz~?@xPuXj($%>(k2$e!fqqbcSyV$*H2EiN^H;P;WA*5dE4F4x)G1!okZu{@N#b0KspWlKPfIaKI2WVv`juRKB#dS)$-{g&O$UX{+ITt3U01p=k-3?@5z6VpyYUVcRA(`t&?N{-tK)baxT^aUP04&Zbz*Loo`W7-OmNhWQ7#LI@InTGh|n%-{{t?Ew=lNPdx-EnVbLTu4!Db16m})$bdPFmA>$QjrZed-cxS*U9i_>oi4(o?ijb3WzS!pjL>!^<s_X<6-j|uPL;RM?__&;q6@p5u$Ip*hYl6w`c*{Ao|t>Vwza;`Lh!4NRvH?o~6PDww+BsT1$7a!MxZJco9UupG*v||6vmU2g;hlbn~_d=S^X{nYjTm_bDyRlsr+^-%os$s>`~#*Els=Tujziya^>Hs%gne358c=OLsTpv;vrx`a?SPVk-4wI<<WA)vOzmHLI5Ta%pybX=2ruZDW=ByR=^U<5hh%A{r*Tc~-wTqDNJWPNn2?C7hI+Kba}yi<WJ-MiL+AQq&U2wKI%FwqS#nXup2BQdkxp;i*NRVhAbGH55qE;N{~s5MHj=A7U_`_0c^}q2S~>mH?vHXwbrI5K*CKUhfD`PFSz<le@ttmzMV9I_=_*J81_gjn^Iih~@!EH>+?QS2?$_Mp}!-*b&?2;1t-6>epNRj15v4V~kBPjzSnmxfr`*(mA%DpC}dT1+7Q6LG&ymSFjoYZ*MZ4T-BPvOGZ%MZU5OXOG<~&vskJ)DGA|lO8LA_Ax_n4mq7Fs-Q0$^jKIrWgO^TlrfI)39fE@tL3bH0iY$VsXv9{C&ejC`caF?<2)1H+ys%F2%Qx4SkILH#frUk-1%3ZVCM`t&lG4^p!oT?QMblr5>GO>mXUDEky=;XL*=YJ<vPIR)7KO-0(+`ua$nXq~(y8Pu2rz$R@&M64*!AWQj>t|UD~9AN$@M9dv!@)cgA`Y%C6*$)sQ#c47eVxSO>ki6$ny?CXC08&ieLHV`-?3fPRp#cStUv&jWr-3e}L{CTOs;dJ!k9RG6FA?4PH9IS82qBuW|@(qzIDw(|#9w$-T)YmzI{u+nemX5gB2t&y(TW^C0aKh;CJ(XT__qM*Y6VB&DPSa{UHvBjOO4vVjY7WHU~!z%GTbjD+Hqg7I9*CkPQIH4ck~PMm?{ub5tupch((8`O^*GfH4Xs=OGVIrs$gD3E!SlesIbS1%DrssY@q+r|=z{z!wCLiED*wy5wnxL&7)=+88W*vm<BzSd}l5PejG7C%aGZqu9%8&^{*>`+N}7zP*zR^)b!t}L*yHQH<%1G3x@g49xkA8$7G0we9m0+9AUz-8wkO$tFeAcWmP8tHR>q=OwKN>6dI$cFSeBvd@cP9hpHMx!n7f{3-~pTA`)4MrNzUO?5Tkv)6BhY6bq67$s*=7fZ7^{BBECf*!SE-n^PW%mmr<zf+}CLZV_IigQ;kYdfu{a6P$Xb~GcBnWE~#)1bv`|T=hWc{(af5Zs9|G>;};Tznizrl+8&}S*K?Q^}`Lcod`9t@YIRSpEv_Z5lnr+l$O5Eg%SDONXWmaP!IQ-esgyOx0r((W=Pd}oz~UWkC$g(f9NDpf6SM9SO1w#`2AjU!lQ1;%poW$GA=NjFq2RB7~tV$qcf0Yb9oI9Sw-J&2TxMNP1arY4(Kwc<LbrcxUjWLn)K4QQ!L&MEl@0WTD#4g_TPsBjz`X1kk*n|GIXm-Zm~<Kn!-Z<u!jTe!P<cQXbzb8st90Fr%SJrLUzGukAG0qnafY~iWoPv1ouvVOuDYb=(kEMY2TJQzOpfw+^v$pMa^7S^O`T)4hE8qI~qDswPSz~x*IDBP{WiEOy}%F+aGVt5!IF78Ggc$IdmQY&!1c|DNXlpq7}ujowm$93oMk*_$?k}Cx;j1cMsgx&>WC$SiUaq>o<{783bW(AB%b@Bv~qYE_YA1CTAX)$jG7_os-suE=`^8zABl%C=GLWpR8&}Bp{-8F~MY7V2-5<;sbjMg}(z^E<6aUmSXg>mH1FA-uxT&3fwHoQKs!P^)y10Uxo)YM=xUIvYgO-(E*`$XNvweD_?d)l~*1JFS#Z00{L;=cgoQ0Etboay{>Ci-O@|D}1(i2d8yt`Gn^$NdRFtqw1MT&NpHE7dS~X%u;B6bdp%l*VFTX^i7P4HQP`@>q<@;}qu?fXpH2%|T^liE*Y=9*h0uu^5%d!t{<}KRzrM?Q(#O71%<EzD6sP8+VSp21yg+LG%I}?*jBei1pS9!E;9vlbkzpMibGu0o+4TX?bZBj!+m!XyM%%Ie|o2vlk*<i-7AX=!^Sv)KDsU^W>v)rkmH2hdM=D;2sf3qp3NdyeK4RsA<+eLcUtqAZr|EhfR44F)-tn;S;bS7?TxWKs`LE%R5-40v<xj#iBNq8be6ASVWC%2qNWT5u}Qwl0ldwHel6;l-|K2hs{zDF&B#-gNrc5d)PmJVa12DkqRM5Q3w)$E>SD$mzkAyh<-eMGbn!ES8d`#ZHYgue!n6^LcrUVwr3GWtPn!Xey&|0!=qaPy$zyERaj)3Zrcto4|f~(Z6omZi*B77qK|c3so~|}wRUPJlg@;aKNqM<`s^|p9>z93vpt>#Z`!qk|J@_v_w&EIC%<;N#CiUm*|-xgk~o*H%*Oq*!f9WXjk^U*=vHUr9-?rHo!Phx70$N;aPLt#ySlS+Kdo>+8-RO@!nr#D_XWUNn~jUVx!N5nki)aC5$jdR`#Xpasxa=IA-c5<hz{-?*@}P#wi2S3YrO4+5qP;{siuc3R}5N)>QD^ARV4=D8WDr=hmS${`^F&r8DkLs0x<{|G%+yI<#?US<5!pHgnO2}^0J*)F>!g+tMkDn_)6`3_Ev`yRuf_!c;3}9D*oyK$6pxW_-g_je>s5TuLN-XMF5UVAK<v80gg)*;J5?<p6gL%V>*o$Zl|%r?KD=noyH2c(^zp#S+QBIK~O5cHXzn6qt~@-(1Z>deY!(~+^%H>l-NPKA6fAh6*axhif=o;%?h`-Nj+yKpW{@)yj_=78$?@G7^_Dg-VOzL)=~?IOF{r4<CEGgAkL=%{#3m@Z3F+*mCU{X;@nC`sn1JJU`qH~Um|@vF4vGg{nr7wxDln{;?`B~vErbB{vS8gG+bOoMr&O0Ke(2~eeI__W5}mGW5}mGV~Bv`S^;oe0|1V{Ho)<h1voM0e99hk4(d+A@z()3{t^Hu#-dMo#v;!&fU!5Ivb{nNJgXqOTlY*mc8<Wytp?8>pjN>bc)K2;R=ESzDk%5aWesu%s8y4k0cw>yK&^tZ{HY$GRzdFv9bXJ`2dGu<XheH#LQjXv|FABHB@o?Vdh!o!hr;>zatpW>Wk~=bQ;&97K*+=LH5TwNm7x>5EMTj8S#1M<+m$Q=0mL~Lz^wefT=J33&GriwiIjfog9<0lxOG^a$E`eL5pFN_8jElXOT)!YuU=zO{l^zv6XL#e&d1|U5`T4o<1Y+wVr&s`Vhj;*{FMMsj3EM!OCR94qybKhAp%Z}6#^dq>_9z1-19;7A=5eBu>H^KrR7462hoErwD6#$Ti$5_aj^*?l-bsH3kWZ}_3*G{H!9nfxRz{doOaXzJK|APyn+PuKXbY);9ctFM>g<ns`S=(TR>kyndfV&DDE{ycCTAx_iiJK;@)jUQQW(YD2jWx5t+Mp8<Dwtw-K4UcN>wpd#QtK*7K4R7z_U7ORQ7h8qlfZQmt2~4rBLW0i8O0#MS^@80mjo=fR@7nh<x0k9j)!$2=YVW1f!wF}tJR+Ma~tuLN+SqZe>o`T)lz4RBnl04D~9$MOsSPoXByyLA;k%k%=fwy#$&?=pB$q*GT|c(@#5JX{0<59eP1=b+3BAmscm8~7ts90CYs@wRRYxE>Xd0A`m9W5=nS&d@n-o8gwso^3=i?Ab=-dCxW?&wI8JdET>)$n&0UM4tC-Bl5gw8<FQdnLX)kFOz(jw*D&9*5CIDx~&U1(MAQFXrls-vkGvWTY%#X103fW;5gd=_dl;z-weK8Tvs95Yd+@_+b&fvR~bAgl;SE2&z*jITu7gx2(8ov7p`;}@7e}j-l&%g$P=|7^kph6#lq|u!QV|n9a#!fQ7KH|S-G;*Jo%{R$+Y94LLw7O4cB=5S&H&e5@XY)u7vj+2~SvMQ-C*1?wEojx8{Go3R~Dl<`tS2%b^*qRlh?xj(>(&Ywl-91YnaVQ^WF848&v68S3{lbfs`k!bIu^{QRG4;%6j2L+u|D-aeVYg|~YWbbqYg{yPDMH|Ts~=$Chlz}sOfZMu1?4Q`TBUZ-FpC>aPR@IKSq2z=!W9m-hwCZB>;HixQkqAcMf3#yC(eyr&eDKd8Gf9^q_Gww|<**RAGrMxgef72{OUb6F>Xw;Sj2=(NWop`{OsDyrU$xaxnPwuvWC!+yerYE$POLj8+6yVF=6Vy<X&qJtI#2Uh(pQJSw0VgyT0VgyT0VgyT0VgyT0VgyT0ndJLPU6D4dMEK+ucp51{p5GOn)<Hyli&4f>bqV|eb@WR?|QZKT?_2jRF1OI(uxdlpSuWBFNEkH4VOopX-yO+jEm+Irci@0tO%bKLRqYiG!)(=l%8Q8z<kv{TJIYOSvTm)y>NH)22|r4c$RlJWBC;ri>bi4E-Nq=Qh~9IY2`_`H3<!CY!Zsgk#1OYy^s&4dwi@blQ$N;p1QFBIBn~$CiONX=QOEOA3gP`a2g?b5>qguw|Rn``x2=ip;kTI7Fi@xH;FvWc&+nM^beE_cdPpHtO{dI9;(GQy<JOsna33V(@=ou<0|CFtdAo`<Jf?Z>xd&ux*}fQW$?eC;x}n2mfwWxD<7Vnf|U&xn!(MQo4I)gHwODRT+P#Ntf4va6NQ)qhhfUp$wQiAS`((5C8o>RrxDE*&6csj90H6^Z}B0;dAADV-ua;sdQ=c_{P2RLB@2^5_NXtn9;>Lo=-pPs#8{E_ds1Vg$BU5kS);f6;9jK}x(o7K)gmvIKCiq{4tXOBs~UN2E|2H#wQ))@IN|=69I=Wu%5CR6pWIZ+aJfr0%5CR6pWIZ+aJd_5l-tgCKDnus)yWNmy;eam_lCGrBs7!A;tVw6S@zGjH^vMb506t|^<bR%b(kGa>p78~muKxfT~6i6RX&yw%7>fxh~<>a!4KtB%*826=k&caPOJ#y;Ez)4TNH|?V|#be3d;fA_}=2j*pE@_SfzDv8t-w%Aqufj48w~kJZehr@TK(ALLwV=ESdt)gs_Ee@o%IU*3~ilZ<K)yX86Io>~d2Jwk|_9z=$=`C(N3t)!D~TLhX*B#1Ife36(d763TcCB@|(DYYuV?;RL=5pSCrJESs~}5|4AsGp<kYw%$Pb3axtEXrT9-vcKyho5EdanU<TS?i^c{f0?ezGuQ5;g$+Tw2GA*{7N;!P7vegcr~WyTM9b9g%Zv$%gTuo5t4K;jWtfFDFUB5HmO{rRgs#2W!P~nMxbXJH1l_Nzw>uM1cze=7<LV7>&nM`PHS)ZT99wird0&1_KY|Jl;RJ4fn!a;hQ-gYHtU--6DE6{#P`n9175|+IC(0(JO(g)%`~#e7Nj0@J`CO0Mx6I4fu=dJqh1kGbLa}-GsJ2*qG$NoK|ER`xyuONou>cL{`k;Z)er`lfu8}>v`4hBty?_(e^#YDd3gGx03Bd7D5`gECRW5}P)#QG%n%qx*&lrkjlu#_8XMu+OD=AerURsU;_a1$es|}*}nWJ2kIZ2o_E}l=CLJiWeB77SNJ<?EksrDp*_vq@R^n1H@HaHT^SPina?QVvb_pJtWVb_7BQD7{L0)s3UhZ=|A!r8kGLOz&ozD-f!bZ%8!s*tLz!YOQs)oubpoRZt6k0+M9Enr~kN2t`a2?$Qz#5Ua~wplO*{R1V#M_0@6>nbd;MNlb@*Jn9XO+bLc=L`jieo2LVry1hFNSJ`!CQU$q<7w>%|D7tnN=vbP6{@ZL+^5F`1giU1&CQr{;EHVjRz}r1+XMu2;!Ee41BYSCeiIN(F|GMws=nq|K{QiLKu#gqk4~SkNb$Hxg>jeq>(A3&uz=%-7Z@!WZUnRpvVVMe^-D$l<)CHy3_alY5G5%jeb#{MKDh5_hE9R}QnkoSrOzvGltbRg!m37In+tTE;e9hsDTW~2%aY?#u|~P=eCLy!N*OM9sYbc&eCLy!N*OM9LydCV`OYUdm9jdyVMy1C2Iih(=z-M&W$3YMyD;>?N<fIA2c{^*KaI+ht70r6R17!o5z8r;gCEMNn2S@C&S@x(6Dz_fctT<vb$Ep0>Db;~QNwaTH@>&{#q|!QF0cz7oW?J@;*f?OVR#XRM;dxyJinpGC=^WrXhPV+wx-!$)W+;ilz|Lp)Pp_hl!TcC_^PPh1cX?filIb@A47>n%$!Cf*f&KfVMIcki)0ywd>pwSn!sJ~<S-1W$Hu_d+^-YYP<Z>Zf$}A0Ft)N*z~X#?7mdW$0``w2>B3jPJ^>xuoEY1jFt}rz6Tt>M(0K0#|72{~+dHeiVzgSeBU|(<Me|qMQy5{u6E+T|*c;TL3zScn67y@OVB#X!yWQhC>TOv93UAvDG;V0{_Q3?*u?}{ugEbUt?_lBW3TytnV+7uICvdT^LMg*5yNiyXTj?@7-Us|T-rnfwc8qm&V;!B&!&pZ**3q%rJ38J8LC5kQ6;700oi=y__%6RfsQR)|?g8a99resIw_|GHSnp`^FxETPt9Qh%^h>$t@7V9Yq>$Q^2K1S&;e96d+%HjU?Mbm0^O9#J7P_nHL5gJZITdwv-06eup&dR0z;RIn9N%&PaD34Lz;THIobcTKP`2Y<oQslJ#wRLP3?(W{48`(GD3)GAiLV_)iLXVPBrYUn&BjYB3BbL`jGqu)Wn8aQri)?HxOhHk3N=W>itxoIB)*s<4TYEC3JWkF*hlMggB1r^kJ1j~+jcj@%TNa-5EhA8P6ftdDlka-KS?kaGQbrUF3)|TZ7Cd;@>p$cG?2qy=vXA{TUbBKV=aUw&Br}0Ki2&*H&D02&{s4NsUM+I(>9Pebrbhtz%39k1^ojh!=<W@+@zhKFM^6P-uTX-Qep}pGZY|ttqQpj*0qR{uz`F++CT!wzp=dYoUG!fYAKdO)Vjjw5swWdG=YldW^5U8<+gvrRXp1U5_96a%9sO(Vak3RNK7$*lf-o6Ne!Y&d{fi$y_pnXZ}t?YE6(Sd5uxQPbPq4!_~8Xf%Nr(x>`h-zy;V_v%}cFDiLoN<_Ylo2Bz@Ls?moCjX@;(X{7$vVOQp{%Z<Isc$ik{dUYpCcrYQ&Z*f^yam~h`qj#kAQ<+k&kPi`t@xZI^0<+k&kPi`t@xZDjj%5CR6pWIZ+>g0xjUaKFNdx~WwRu+_H<PFj?5~~IwmXVmE5FhfA$djvhEFlyRH}4V4DVKvE%Bh%(Q<TnWaT+I9)K@KKSVjio>6qw9_v+$mo@Fnm914&c!t`~Vf(}P3H=%OxM!C*fe>w-rKw5ClQLs5iB+`O23@@VaNDEGk=eOXjy?`-YRsfn1W*Al0#%vkNKou68XQA6*OTwP<weFtCUa;%5s_7GERXN126JIY`O0m@>lzY;G6G{fc7Pcd$aHGh2-5Xn69qxyVEAI|;8M5jJ)Z4WNdcXO|(-RwCV_RoqTW0_q+d3QDI<ryty{$9d4G!vF+HWQs_tAO!M~7GR0rmR_^lj>d*=yL~Erttw&`=cj#?S%Jt5r5S64|bOV1c*KCvf5I)&yO6yCZ=+HZ+Y5O)`AB4^8kkXQfTy9QC#=0fo0q6Lj+oZpW16+w8KP<FO&{r8MM4&}~B)&(=SjVRrl?4>WHW8)(J`8jHf%Kr=Sb7~HXeW}h5rc$W_y_X#STD2Ezt_6_j2`zJ)n=lAORWf;2}*|XF6eks%wwmJ!C>We}h0r*1oWxmy!gv0lH8o{9e59&_BzpdWyM(}*OD2XL&oCgWTIgn5+zl37xB^1jpp;+>g#|p84w1rSSe@Ou5{wnksCWbL~@qCO6VT@UEHqrM`8wvzoh7BTM{=SSv-A8Jvu|Wh$uPMVX(jX8Cs=!zt1;*kiFi3M(sB1;H;P!>4As?Xo8x`g=p!p4wDzEttmcMpmLtIW`#}>2k8XFR+AE8py#)fV++QIkk-D<Rh+S2FG7ghauK!pXi2&zMWrv_0e#S_^yzHVqh^o}y%O&PfZvEuePI~X@K1df+>8th9EtU3PB68lpMa-EiM`E{rU#|8F`#{>}?#z$3{FeOCI!~P9d@oW=B%t>sEA`TpeDf>+jF~zh-9oi%>MKn`Q5HHFh!07ZJ>lNoAGa&r-Tl9b+;ppK7nMX35UiPssr#`HxzvdUM#)`2b>-VI(MUNgK>9YoH_rX0)qwGS+uT+b)RQkNqM#0iX7EU$N+C1(s%{Z_h$0@~7g?nVL`C%<`+xgBXH<dD6?oy3%+xgBXH<dD6?uHuWw)34&ZYpJMax0Yt3+~ZWB8xAm4@u)gtQ3S8A7Y9^c&v8_psR8$Ayf{^_%Nqj4t^-7VlGZmI;Y#xIK_Gov2;UC_rma0*ZCqZn9Juk?lQwO+egNBZO0bVZ3<(H>95SibYi*DYrX{Ykr#7`ozM!N@m;kEZ!h}7yEXl)!@@f;v3!O+ZAR_;7GOAlFks(TJ+*i3wO4p2J398_%E8z<2#>aAcNtUKLop05qVQ;Ic7*4%X0NFT3XmGYR73JmqRWs-RamFXXFpZpTbF2tPwW`kqu%z8<@zyhZ|k*ZXKr8VwPz=KMa#<F>VCZT>_n%M!^$1X7Qz;`E$t&&A8Maak&jbi&ofmcuJ-fX3KRDo7pb>)1HIo=qu(SbjH%vZs<%yHO!Xd9y-kkCRPR@o>aB;Fx9L%G$UjQbqmN4z@aAixgFd1xnvamju}xQRZ=7~iKe2-EVi(vF2Zzxki7O}I{fj<gks{~6AY`v2$bzdu>=PQr|5NfFm(UVw*E8B(Xp9SQf0v-UTfJSIfWq4z1O4)t{xYV&jOj1@8Pi|n+nD|$-^TP8^AuoEgD_<Xmt*k0Iy!?MGd4QQx3SS#zKxB}@@;H%=FiyZEZ@dPXa4N#qjTc<H#I{4LWPa&*(<J&N6sy(;y{%FI8+Cy2mpuA2_F*R@ac-3NjQ`Tlmx(UQSaYI@O-%_iCr+92MNVFkWehYgktF>6w5B5Sn`s`-seG5)@(d~NdV@<D)bzX31jTy`4|_%7_%aLhb^WvBKIf>yo>`ffO*6|T1(9V8IbhhRq%^A#DWD?U@VUUV{sH1r1@6(0U2Cy`$E&;52l*WxEph?{dfzOr@&TWCNU@^rDz*Ct@mh)TLHFl%TTuhZ1Wv$d0a{L!YUARIef@F+BJwuDW1rt@r0oP(Lb&NyeT7pM68<GmRK%+SOqvf)NZgJLNI=`MPfgxAivY{E&3g*dvSqXOIp~PDt(U%?IS9<V%xvr%9(w%1#{vy5|{&rVaooaEtq0ja|~@v-#|1|kG5QvLx9m~`JYjoZ&YF2rLNsWcjW?(A6}4oB*W>cR`+7|K1Ka49=Dnr#)_=plWGp#Ylo!I8Z6xh_Y;k>10c(|7HO&Ud8LhlrHw3{YNWM!{4sYg?513WdsAZMDb^^no#%Wq(<wt_F4ZWro#%Wq(<wt_Zm3aaJJ0!Krc+icvr-_i&>p=avUtK^FArMm5C<*r0G@T+!_I@zQ&vG9o-}!JRf8p1H6U^vvAhyh$ETQ!Pn6E5$<K!sVT5`*y%h)I6->BquD-K>MH>lnNn>o!d~8+T#vNOgA6u0-bYE(#^29P_m236&UX_QpkX3nN?)40LG<V-$tG6bKby%y1DR6Z==`aBPYv@jT?W2_=M1;r16d_8ZBt%roAw*oe71CF=L89v@tnu$$DJdnX7={;7c;p!yjOROJQ`1K)K<eGPyi#mPLy2CCL`orwE>_t`70mUjUTifAW?aUXqgE%OW6J25GHO#8Q%1*>QG+|CjE*Uz7V67S87(jv7O%-xM)~sx)norvpUqeV(bp^kp$4|493_W7|1i@V$MqTBUaO&-Z`d(1QMLAE7umR<R$2ROw+($ty*-zJx^e*j$Cjqy6$9~D@v$Jhh{C&#I!ew!;kMp>u|P(TZUyOvnn&PesS2B7g4-L9Y#sr?G_^U{$et^-#c=3}p;Q45y#@3W0Eb$3Rd*5&<$eo-Kdjz=p=)O>CA>V=jiiK%dFt9Em8I%^If9cVCHbk+xp1Kj3v6*8%2Eu%Qpcc&k!&&ONX7L{Yc<H>S4zf#JruX>Y;a*K1&}bC+2Itlgkpgu6w553xG*IY7o}2hJkPICB`dI2h^|p#+&O^TX8f^ZZ2YM$>@<ErJS~4XZ6QJ7=>=Mb+QoX>Ukr2HV(_P*lgJjviZtF~sd&YPr%@(pyiy=uLm*!pquP=<3?X}R*wPY-hegeCxg2Eu!e^AlsK{gTU&>Q5{NB6J<_B*#>fZ3#Ek7xk_mdZE?0A5Lx4R6K>!<4N0y9gD`}nD9z`II?ao2YHwnnm}l`N;K_tP#y2|%~|L_)`dw?7-`{o8dH(zhx}9CvxDv{%bF(BMib<{t1iIiX8UcA;^J%vEo54K$V*w6J>;bZPIT^tI{mHYWka+LVO;$yKLf=-bp=IRV9*lZ3h>oGeRt|Fpp-^bY;`=$;z%v4;&bE;#6go<b}^ZF#|9(^?!aI`wws+9VBlKR(glAMXsb5<6^k;EG#HM{rDbM^Ip|N1BSi%XxiGoT5NZE*@ovQ>cSHa{_aY@p2JOLoSsx`W%x7Orgld!fA^Rqd295RKnylhF9}kq7r=9P>1NRRM^b6vu*6~=|_*a3SBF-x|_{Ve=}-`COvK%<`>)y%rDuZA8baNCw4e8N+{7e#89HCK0zvMgvXsIA;Skv@#QKJI%gmBf0Unue3UerKQWEKTUu^jA@wb-X?Vqk52Es*@k)Vs4S{@<IQ1;GTWTmZOH(QtO4f|~33A5$bL0E!vx(Yzi#wD(VTQ6J6SWl&Hxddp`r&|@ol=^2R8yJ-_6-GVOte>w$DeQH;q8ha#>mC<jXyPt^OL}Q1D@OO`e}yX8p^*h8Tbtns>p@HX^W2R)Zmjt7+#v26xPF9_mWEsP>~<bSaPTr4gMUhvUTD@z~9Jrmv)!n{bUt3uvQL+*VzVr3x~t|xhia8{X0ka516m+5=v&+>O%`Y(1t#X@`jr~&hwEd&#uNP;kXm<m61MT^AeC%AIW(M$U1&PsR3j>SXZQHzshF=vz-bi;ej;1?4j{xibg@#{&O=hiw>q|J*WtH5bhVZC+n6mCqWb{tYO`uJ8NohAAa4QDrhkfPd_EVdn|#ER{_!%67h7Ao)+en1E!I_^$6eG+BbRiO;hm`6}JbKU_+_Y%u1z$62Ow3?$Bj+`a{ubj-2y@K6Gee8TU}MkRx$nmm>L1pz(h?@lEJG3_{Pk-(510(C1w3%llQKgSa>W{hoUJ_tYBDI986VF6G!9R&SdE@y4;1c<gC82*Wd;#Fw+yGreDq-pHW8+@(P)mXZQ}Jk4_-(`xyaT*W*^y=_fE;c!{<?xr`Z70*h*fme82nAknev$i>?wvTUKV?$xZb9G`B^Dgy9uT18t?a8~Qh~>x3Ht<3M8n*a2TI~fMSik>}R){yUX-AL1>le)Q0N1k^1jTrzSrNhX$3aAoa1XrLBU}^Y`MnF%F^dhMn5AIMhG6bZEQvQ-UkLcH(tG!jFEozau?pU=D!o$nq{eoi_QLMd-rr{mZ6+-$9PJK5u`ccMbPuD|4e)1|n~4C4qZdhHA78%yh<S1t=Eq@}mv8N|x{@h2Jm4u4{4_N*G_!^V1cg*XiAl*&>ZIhfglc;lX><l}?c}7yZrD3Uu0l;!LaUjS97d{B52q?lEzQl%tQotC87r3wvc8}R6D}91ZMbA~cZ&-L5}f86NO1{40$fJ8`~NJ0yQ_r~p4HPIhWZ3|wa}yF=(72lZo!TV@ChME`&n^7htlASX}Baf43~oKeC1&a_87_~hv6Jj3wHa32tF|cY5x$UN!1~7XF|^22#MzI-ydMb_mxsVAfy;vB(fMtG`AQIWXwUF!09!{$l|6=tQseO#q@Mb0o`5e@cm)~2j0i2ut~t%c9#Hfi1}fQ_yGXNs<1)gW5)LL82X-gr@{0o67KdXVLK3}@5r~)5GC#o18Je4u|e{_nu`WzYZouoTr{_o8k$=`dTaUqH;>14`EXU~4qudnKaY;@06dube|f0?mxua)QPc~%nH{?*3$xM1^l0sXIdKuBUFed-t<tl1UN{6b>y~(O<K1-fm51|`fbF!5+(gA=1M}U$idrc&OB0Z4sxFHqS0UA>z*c=mMQ_xgC0|w1ZyV6}RrCi2^n{B3&Vc44J+jF4$c?HJzf0TQFS%4j|IUDRtLQ%%&}UTiMgzhbFUDQ1{8!X*$lE{YLo1tZ+i?xbWemJ}$4w}oG4M~@zk_lroc{d+<yDMYL~d`}aWTrR0KOaLS8)F@%CX>n4azg=a<HKo=T$xm%UO>q7E4Y1A2Ze9Dx?O(`!$IP0=(U1pu2XAz}t5W^qK7=@b(J>y?^@%yd9P}ze(66?J?64tFsWY!FW9%Y2vuZ>50nTQp1UJNyJ13E9Vy@IJ`q8k$Hl*4;yIw9pLR61C74}ynW9=<L~f2XAtpp9>E<_bKJTL@?qB6t@9L11^$njx_5zbPMcEqpey=nqVB=l_Y-vw-kwO*y(e<iJ-RNz+UTB@Ns0H6tD~?AI(~H$8{U(vqj>iTu<`1qZ?zEMcv-Nvdinyw_SMskWIer<tf#xldit5vdiw7f^|YxO*50j}7cp4*O2hyYk9XtZnfngq{tOR%@o(4eP)@+`2pIo%3H*kKLfd&59uxU*kPg?k2||{*48>do>emA+^{+A2xO~K~X>Q!^Q2VJ5loKg$kSV{kT0+0RI`Qi+`Ri$FCl$ivukTdQRqbw0v0vCw$8y)I9fF%WC}}TMEdavgub)!T>pES!f1~zeAxx$`SwT--<EDIE!JbW~d}5nOdAZsPfH3*%7ZmiSE|)IWdt}{{zhMQ)u6tM$vg;mJiP9X`HBky6Mk=rq0y}@EF;mDz!Q=`d<XCB1sIDB0Sq#QxCEDQG;avp0<5TepY`XgW?S75cMT%9xXPl*vLTP%CY^6{<hizQ7{<OnWwTeMGDa{IEU0}0vux1W6RSg4KN4Z$Lf|6DC)G*e8c*Q`x;6q<Uz+0M%R}}U{?^aFZTe^+5Y7gn!$9gO19Z#n0{V4M!AlQ`H2FEldl-MWWE_IN4QX;({G+4aeXM_)s)Zkm0_9Ok!tRWC$L>lkLRJ>xt`;f3SUMUc-A&{^6JvFm824%LW3@5;BBHL(U6pbS4V*D^><dA0MP#0r{JVpx)JyA&QEr?o~eEzxSdRKcbqQ5p>rg@4E=ilTurI4amcp*97?R4%TN8A(w+rSF*2qZU$VW~L`%gkX|Vh+Rdau|&0F!XU4o;A~^8X=z^LbQkoef@KZ&;MNNhyHWoLld7ghSL2c^n?qudc-g92><+CUh?zf0+mq0c$I2TC9JKGH$8-52}~&IN6klqD7dKMbAat36ys4=(|g{pw2?`JL@uypitM|MGC=mtVR*$ryiz0JElb5~2*hg)<l89zjw>3Kb&?AA6Yh?#EU6tK03WHs@obRk9|1U@PK(<F`WY(mU%Ls?uE66&Lk4j_mguO7)<<`eyGUd1UG7AonN2t_vv6?DswIQ`Ij}g2#hu2kGoUna>WCez%jM)M(ia<E^_oeje3R*msp(4%udXS51A9$P@^c0!r+*QwCTD&TLoxY9XnosBjOHo+Im%0OE;2U1VDPCzXA)7Jt7rk~)2F}0^k$qNlLJrrV01j8c&QfvotwQqJ)ounSkgl7PbK~~=)SMh{V2OgC4U#G<XheF+(b7_e3V_JI={>JQ3%DI>fXiQ#+OZg`1ffT54otQFjng!y30%xcJ06&6+KOe%crgsrA=cK0s#lG@8E``6OpxsZLn%)9#eIhS7XGAcf2_aj|8@1Yr6%5h2;-hFi?Th3}AT)G}X0C`6706T`4xQ7ESMihF(b0CN@qdHGErMa0W&JbQz1kMKd3{mhPJXd@H5b1Mo+5+Bc(CihhPB_)yq1O7<Th?lFl03Ul%fBwr@m_?M|^RP)5l!U48#u0sa-GqE^|#hu2^T2%6uCQco(NxEF_sv>={;edm#Mdh1J|K`;6rG^7*O5eZ^s!4vHg}c(f2-f=prcrm1Uxc1OIEj;+J>(Q>U!N+y%qK<R)1UfQE!&*p!F@o-$MPAeJo$BtXy49|kq=8Z8dDR@y-;0o$}<?X?<v&2dqBz8&;*h_Z&W3SPFBJS6L;J=XqCHB(>t_H(+f%3kO)B&nW92e(g23iOpNGIsDHnb_z{3#SV<B-4;3={8J9Nt8H)Yd5Z$DK$gb_sX1m874c)A;;5i!`(O=5mjZbz?+N;uGIphOf%uiI<5Em^sUqb8@7*hsp;`t8B2EXGL5hbtj<xid>2+M4g$ZY-S+EhJNKcjAAY6W(^qVt`kl+JT~I$yU4!U(%~bf=x0y;~>J%HPeeNx#RfQ(!btU8PK<lt*J!nsKXbU|8z=snqv7sf(<(T-&9VFV|Gc@LYRR2j;rOYRk1<YWZ?ar3}xtCv{-18(3|*wo5HvuBnvax%Q;4BG=aWgGbEy155_}iXMJMm_9E<pNnzRr=Nzv_{_ogG~_V$r9iw$IEb1=`q`L>=CSlN&8K^M=-#`Xq8mdAy7z|4TjWzkOjZCfRRP3Ai=|=-NKPU}otO|6r;po00lX6)nkYi>LwIPS2#MqenUq(N6sq|MG+jNf#-#NR-kCUNzzeRHj5jtnj!MRxnwv(4Zc9^3E%|M3X|5^#_~!AWlCSZ?Zf<-+E?C}bW<yLKi2}$w%wcJWu2msd#HStY$YN-KJpb6OY5XG+QPFT@6!L*|L-nuB`^Eoo<{k1=F?md7;-ra_@F#Yt9GXRC|4IATfy$)#U+p=vPi9Z8L*>BBqxGm9NvWL5;a!mp@9CP02N?$8OTNJjr0Hsu$VWX&`E7M9<x+D>5rh{dOXe;+FV#!jP#1|QDtt1E3HbMv_fBq$4aJ5bUmNf`0K-(`!P9XsCWj5$#TrgOu6bNd>Gx~i?;x*xv*29B!-b}@%al1zPkpj@AgDI!#Q2{ndpN7lciM5@eLMUF#cGAwpY305(s<;kHt7NEfchqF#Yu%b5;rX)Q!j$(6&kdPAoyj%F&B5uRnJcuQ>?aR=%isK!?Qu9uDWCnivMA9&8(jdh~Wj7&IB%#b`gMS@rQP#LA$oVY5Cba>>weTetv5D2JLgG!Ev;(HyjH&@@Qv34KK12AVM<juBU<R8?JZgIzqb&ar4tqQ_X9(+{iS0%VS?~2NPBvVEE9?_ARF(SWd2<5G^&Rb+vfD62==Bh*v7n^&R6iHeKV=Bk;iDpq|~1%R}}rm`6Q25{H-N;OjGFNsU&|5LV|4C0Z(sSJExr<YVu&=&*d0RNLL#Ef>q-N<db?&j%H{!K1Q+v6+KSx^@X;9pz%}3QGFaxG9WvAYL&LuT-L&7{+UCBIpr#vJup|H^SuV(d{JUe6hM0nm@)X>CR<e=tlNVM?usej8tG>4=O%`M~RHFnS)Js6k)8RT&!I|$&TVXVXOo3ih+0~jdy>dnqj=gCW4;FzNq>>0jJE>_(cd5M!%7NKd9VFs)_H-#$3PVN_<JDAlN-Y1!3?gu`o7su*v2c#yZNy+7*;+uJ?zr4#X=4;*~Vsvlbq8KO*2+4T12z)znPzB|V+}Q2qY%w5ouSXa{iOFQA6p|4meVO2*O;gYsM&CH^HR`{|D8f=cwKL0K|*A*`8$O*XDD)=@6juApS&`b8M)K)hlgUP<F+G_EFs9yLa=pkWUq(c_!=TmSK*P<kRL&!th~UvjdaJ|cybXz9tIEEU+3Iao6XoAllo#yZNy+7*;+G|z^y4#X=4;+5D<gl}Y`(NK6~SN7E)yi#twZwI*t#n|)=B`_;r&%v5G*z^n~h;@{UwJRvWx~UmH;7x%aFtrFV5~(UQYZsyyq*ktR;|W)zWRpKr{eFI$Y#7PYBLiBxJJLew%%D7!0_l|;@zQ(Dpd8N+64Bs=ux1W6S)s#NN4Z$Lf|5Pv1!1fM@rr?XtVG|N;P5R1-o>eS1xDOcl8r=e_Z3RCuY4y9p?D5k+m|@TE(YbKv?+*nfo;mcnmO3y@E*oG%Ej6hl&q}p4r3jNR}91}mFVj{FkWL5L62PCCvMQmMiSdp4qA!6!okf$AfCfEZT-I(l#|kBL97exvK*|LgH2Y}FxF8n)~=vrW&Lm%>p;9>AYQ3N-!g;o8k-1u<PtM+w^KHf*vD|tO7zVlZXN>h9JXm|(8Zvfl&%h9U0_$|V9gwCva*J;j&iYf1tlx%HDRm+@rr?XC5>n4)8xuKL62Nu4Y+m8MIsMn8MN=E^DKQPC=aDTdL>7^w3XUoSdKp*B%;9!Va*(Ddfz#Sb(D*>D=5A19L72juNa7Do;fGUaOFuLWE(^~Raj(O3M26H;gf*wbA`4Mc)MJuZiVQl5{Oys7ia<t7a&drw#a3(5VI-3U61C85*#1{+<+5jCeAcw;d7>(MRL6<i9v@;Yd9C+agP27Lpw*{<-MBX^7lJMvm6tI2a4*SH0lzFe%bn1OGe=BD+UpwUriu}b84eFwGo`!C{Awui3lzc8*at~Im{=ec|Lct3}5>;5Mv2MkJF%45IxUeLG*iX*H{q!#vCL6k`Z|O&|HlOQFfM%2yc_m(uffK(>V!5>fs(Sl~+uV<Em3-7!M%VZikmop9<6$-*ASELKxRlh#r2Xl@wkejPW44Xr6@!FZa&VEFk)*jpxW-C<vFPg_o-Q{PZi|MFy{=r4o^gm>SMQOznp4AabOoTLIAqor`USktQb>D<C>WgBC+{t_oXN@!+eHAd~08og?sayUE}U+u`L-6*hC=m8ByKBe*;Y;6&bjPC|?dtc+0#AxM!$Yp%&6&PRc*bY+mcA>%E`{px%CQic5D?dBH_8(F2utx@4yI9&Lsn10kocEpvXjcgka4nH)877tN{Dg0QRz|%vzicUY2D?OyU3_hlneg|ueQ^tQ&DXdck(Wk<r+0-}-vk#l_Li`+d)Brp2jnj`R-hQRZ_YsYUO?eAX2l$t$@U3jBt}HS2Yyyz*1{F^A5a2iEc}RRwCB0FF$7PU+OB9kqlJ8W{9jfyW=Oya|Lr)6^u;<md@p;vh`EU;LJ9Ue1h3KD5C-D9`GJ4${lM==VXjU8sai)iZ#dw6^Xb_*G(OMyT!`TK6%RkOU8yc+qJZ|OZaU?uHJCi2;bC&eaA?d}r8x`-j#E1C%HSDaB_Xo&twQO-fGerJztoWskGFo*$Y#Jf?N$?EF*8~$4_EI7FDzR|~G*z7=nK~pdG3GlOgK{CC-zo0RTJvdz=w%vIp5&-K#3f+|D^e%S0VHBBcZ~XRiVEYhzeRtmOzb#!f73+F<p3{*b%8ygJ`;Q{zEn$1Bg62Dfq11xz<VGSuOSexF*qMWWfLY3$Dbl$Q&boi4@Bo`&?<;7(4f}UD%xv6f2*ROG@vWhX#E+ZX1mgGNvh^Rk*hXk01|(`2D0i*l_A=uLGEQ^>=E_j<64Dz_A6Jo*Gt8M0LK5RFjfPbucAZ|Pw}q`?TvbvS^?1yX^^{wq0@cH^sq3<Qhh>k+^N;^8HbS4_!O$<Q^>`K6+e_sGIEeS9@916<%SqU|6cd=<fTNlBxc3G55g-1;zgl&43t(-!BRhIGhjnVtobxKNE4HKutU~OaUgSaU1C8FrxIG@Y*%Y^F+=DVgXz1NLG+o?CM>lSs|Cc&u8Bw)cR_dZE(j+FcnA$X@<x<i5<_wN#;T>~!W?{>jPEx`hH<644KxJMXC6Gq{SDJ9(6qjkLhDO;Xz|4jM1shX?FShs%$*IttvEwPmmARSvoW6)z~|d%YtWr4ddhqa`o=j}niW`@qEHHqB!5u6c!vi}zH8}>5WmwfUZfa)!_TFpW4O$0J{!+5Fo<8GiMB%2@G0XA`n6idj!~RvoTe$xK*GqC9VN|m=U70@NB}VhxZegi9d14$L}ysV3-Qz3kAJ%XIZV>C0x3xW&2y(hzuQoN=npk$WwRpo8ZFLBSLl^)jU`rg_;ZS)e7a!@(Owlca<LnaT;A(uhg!ko&-n_q%}|BtrX<zXn_Q|_d#IKbYPX>Z(H%*u>vp(QcX^9`mqNbY(7oO%_*D@7wZVeulLiaZF0d(%h|m7}Nko56V%{E%c`J>{G%iswA$e-Wgv>o}(nHkL!Br4_tp>G1)HFF_!hx%E`b-mJ$0OTksF|kQNQe)!95rmRj*w_>1trnk)<L3CMSrpS`4c(=t}f4dot}yC$h+M^a(aRS`*1e9h+Uz6{G<wfiiwL!D<B1pm&z81+?ZC4u0=?G*)XP0HjGEIy)nCRBX$cy^2>%XeX?OZx_2+!r+)r}$pTg%s47$Vwu9u1c>MXTL%tQr-=tF#Q~Phb>Iz0GCJ0kHCL{($$Nmi~25I_d<m2?E6i#1C;pEj$X-=^+iW$TpS4kw5aEe@&I;YVFF-fi#VVWEU@iR4_R){V&d_uIrhQu52FIoH{ZnD`5BK@bSY7l)=gH}THPX-I3w`;jqy5-}vr$$FUs(k*}(#jz|!ITd~&6f_+mLpy6OHDoVkCKttLDgyIsW9$LPHY~5x1Sj3NzEhh_TL8jOw-7JBd!t`^D8)<h~g{iA49TG6d9<$sF9{=eF0b0fa=iXAo-{17}GZ$4`5qh7r9L=1c^`#p#IPCvjc(!Hd!GZWu|@*Jz9enLUfu2ErRHYdXhF!7=affpR)#)d^(h@!}_x=f#_Bhwy@%{YF+kS3iL(O@*w(%Aplk81p_K7d0uUD3DJ2PM5rj&ISh#b6IefP__>sD?M_#R>9&CJ3K}nkHDkY5Kbp)FO=A)IauFMLDY5scU;jRBjRTOrk<ox$Ou7L@A#5Z4<2U@-jM&wIvbmT(l?~$&Y+0#ej*M)c1H`C3qe29D9qD+iqJG~r2Oz|T8%E-1Wr&Fje*kq`f-m$}|8tHFg*RhxwfP3hs1|6Z=eaaW{7X*u`RNs5jyj7n!VN0X0a8pqUI=UEV3Ykv80#n(YgbUx2p2wJ`iG1H@rr?X^1(ay@mThZ+84k7bPXyg`>;vc%FQ$4VRB-UjtL4NCh3{ZN3@Lpqey-sr;N}O5prI;9f<zb*a|@O`qM2ucmd{3a_Ovjgvb-M&R42$o?rs<V&<s`%&(Y}igrZ^S|JQA3Pa<2lPRTe)afZ{x$$nbX~#`~l>cK=Vx;jQNE2$1Vq$vQ{nFCzuTugV?Mb?N4(8{>O})D|u6L7&o)@Fi6TV=Aa;=1Dhftm$$=MDmaw6B5pa2H;6{o5+OSLeBHAlh6`8bq14`)UYjq?p8Pt8?2g$U9ece)pe?ip*&h_BCYVB2S(_{I?+J@xbi7+z;;c~{ItSyz}?3<Y)tX&8;%QABymz%<2T5F$x$F#5)my<J|>xhmbcRu;0cD66F)QZ5$N*osh~J5wsMgOt+7SfNntR%jI!wy?I{&Ha;hmv)x`G@!!$_)lVN7C#RlM*Fc=`{$kces1PJFXX>CLTVXP^6etU)4!o}i0L2HGB}`MnQ{nxpaXRU;815Q6AuBOj0{43e2ayEY%~-K8g0O!;i4|Eg)Rf=<3W$|?coDnm=cClM-HC?Yr{xI>*ufNCb)x5J!%AAjfzj)Quqagq@<zpa~q91i<l7wqekJV#RfpVEeo|2j@l3|04rTLM@DW{p>F{K@UBb8W1m;Q-!cav)R|R;<XM0KG;=15<XHl|^gNUT>6IMu(iaGVa(q*ehz2i&HFL1Z1%fcvQ7+c5pyUDpu*_f`h*u26lh3P^9{*;o+OJrmqMHop5*0NE49Shpc(US<YXx#E49F!%*)Yed&qo!)RVpm9{?-wA`It$4y^4N5g<ylt(WG4kX}@GZ5WUGyu3!=Qv`Gn3Alkx;hkJ~oBL=#w_*>wAael|g`E8zj)D&?B>nfDV@$wXz{1HUGnMw)3uTd$#uYeCzKi;hd<bOYdAPc}BpFyPjF9rM^_2csj_`eic0K#d+L`t$K8*%PMJ;Aw-zar%I`ziH=Yiyd}H_fO0rUPpIrbCV}g@7NQNkh_qMKyRuf6Vy#FEt=PZ4`BgmdteNhV7s(&a{E}Xd1clSjfS}l@It%OG9f4Lu=7!Z%t=<R0vw+pwTy{2N5%p&rIi;6YWC1kU*U51scoJCF2L70d>APoDI=dow|R^NUOt_JTfyokQ`1|tRXEcflxbD=o_qgzksJx{KO-qw@*Rh1Dn*1WKl3@`=q(Cr{}nsw}fKuzJp~KqR-+xSQduYI1%H;lf(}%B_@f@!I&+<nByjdVvY~SoDj_Y0F5!6T1E#QOi+w2Bq$!NF;=Hibn$!?4Mw_*tT>GDe7TM&%>PI6E|vgeX9mrN#!&8jHHDuvaogmS5lFj3_XbOVF|!W8y3N$>s+*faMQ;wy<oK3Q%yEp!3PvihcLkDT8Z(7l6iluVLXMSo29k?{F^j>N@?1YvN2;w5<0oL=^hU`yk>WLu6`%2+X9Vo;>Vl*uc<~ep>ySdzhL<0h(GN7n-}=YgsKMrF(k_OyPZ-c|9CGAQB_Q&j1`VRW)TQOPkhC=KeO^W8LO!Yz089JR{x;WVe-srCwdTpowc)oYcl@ja%9E%G@bcGGRZEk5+I*+qIVp)R{8yAaN`n;N5z9MjUt<;W6q8!s5nw~uq8-5y>uY&PM<ti^b|2{i`)Cf*tN_>_&6c{rZpuX(uy4|&xA;jvn2R)EKNuqQQ@Kb3_ERBJA2=@$X~2dsRqD6qA`RGY)udCT-mQ?nXh{E~*D6_K-5!7)G3?<f9z3u6C^gJ#jOPqpziqUGU1H-7bge!k2alYGGPYQa!b^?U5Qr|<Ai`dhv0K&8|7=o1^tSYr52>FYF)1PX<Mfn&RzLrrNeR&x(o??v9Wp%P9XcgMkJ2DA<(cZ|cbJqAou8hvqJG|BQbM#hJ>})<=POJ~i0)2Ld8_*QpG``L-j<&75%u#=OiGA8nx69i)X&U1_X9^EG>A;e*z{R4JZqLlgy@wg185~gKc?NO`26>|^x7b5CwAQ-!XfaJ6!zb$kSm^-tN0!Z2Jr_pqgIIiofdp4CE{ZWtwp1?Le!)rO!gW3s!I8<h9^WH(;zY>W338dtw{^f^&k){K5<17wAo-|f)V?K`tf>=<XT)eH0V;>sxoKyZ(C8uy{6U#ow(<_uEC+;Gr@+`5Bdu#Vwf251sfeCpUf^MEn7nfTmFDQ&wn>gMIj2+KFz5pB>%4Q6bjKPx=>a^)TT%~pLNAqNQtvBLmZQQ5k#k%Z#0b%XOVYJouaxNqW`5qiy_)<QC&U)Z^vl%i;p4LFZZy&PZ9mSaaQ|##3%l+5Z&M3vI+@uf3h6i{>h=Y0t-z~lySoJlO-5CuD4e-5N*m8hpe~!`MGkY+_(-<mq7GZ4O$G*e_02Nd3A=jZyH3G!GY?>PpEJ_TfV#biaGKBXYY3W*Y2;p-9e(GRmcku;;S{cMG)PfLUD`<Ufyr;Fq@(#Y*G#qmM{fCJKIl-70z~$+-WC)bdiG;%~n4`*vJM*$2cw~L9P%?&c&q2=`290Phi7bg%{pDParo9a4E+<@`pA?=KcK$?h3X6QD|WsebWXmwU6OoAVXFF%t6Dj;AJ>oAwhL5u`6!d8Gz@_Zy-e%&qpx|r0C-LC>BeAIX;zQsi|5#ALqtEiY}gyVpB^P#g@QQbn(0uZNCE%W`QlkIFW-yvn`gw@EW5?V_a_atPuZ%7R7P2-Wa(F;bcTQ11So;eKYGD2WGjYRH~6vO9`iMWLKQsNL+W&+=6AI#`2ax$;SucO$fweC6ND<nZ4=dPL65J5(}sj1}UqkOTi*G1=DN{5wTF(9mqJIzh{$+g2@#^$g$EV1Ib0fn8jdB`?;h?hX2+B!Y+a6!zwJY;j>5JWn3=+x1Bu#F9)bl>W1+4x?W8ZqBHH(St8x1MQVen&8ST?dZT94_C~}g{hp3XP)_6N(!&I&g__d|n$yA)2u{9v6~$>0#c2`2X%WTAKi_gWEvGmwCpayqIQgbljD5%9)C$obLT%v$nqN3<J3E5l*9y_M^t$L-T<_6bm)?T}iP&a_B`LB^JGBUJ(baHMA!XwF9n?1BhA?G>XdPQdTyER8IPE|rf1M-3HrF~QivI!g2UQq1<|Xfn%tt(~Hwh1+5i1%vIiY(LOT`kT{EmnF0U6wFu0J%~k3+d9xF^$^y0rwCaXis>$r1hq0RP9jP7boko=R5I*pHixFMBsRPGU?VFAa@9L_+(>88XlM$=PVXGX?WIC#A<oT0YmFC&PQr(-a`ucRqlYLUfA?W!DaGtruuSh+cSsjR<d_T%ZxtWU}QdXd&7lx>18xKy*-pRzkF5NzgU|Z(q=&wn4N{3$+5Gf2%=l5H+IbDo*Zz1D9vSHZfeFMP5$0JUJpRP=ScclOyJlsuW9gWHXkl6jM2}8B5l{86Me;Ws}HQI)#kolgPOxoJ2}EiI#8@Dd8kq!bzlrlX6RV2r1zqw1kI{5*|WJcnB%sA-N@-OiDPJmT)pD;bdCE$)tpnb4z$EDdDlSgvXK+9!pDjEGgl!xh0%JN;rj<a0)5m6k5V5q=Zv)OE`;^a274$EK<T*w1l%r31?xc3U(~=%`!mBUzow>7pR}-UD<&uKF##~5Ix19HADP7E9oK?Uv82vM<9*{ajQ$t>i90VP=Bi8f3ZkH{1DT5H@`{6XIe0bTb+DX<$%E}&J0AqXAKd{(5S^>m!V;c93cw#pt_W5t)oNl=N<c&FXFfS1!`Lv-x7bTSQY*J#|lP1U<U9I8U?l(CnxRa{^+L5M)C>5H0JYK=Nfc$jVOevi{#IJ2vZhSoUiWY)Ip-Rpe%&{xgaUs{|0`uQi2UsyHd<<cQdYd5{j#ygoel#=M;<OF>nITpnM<ChS-5eUII^H(hKT&{i_eQz$YAAV6Q%C1WTANb%;C#b|GdGgF;gBI^i~6x1JP<v<++{oAFvFdkRc(e@GSg6Z#7*f-i8mmfP>hF|uj=$k2f3FLf_9W#pHLRWlo4JJ}IOmPUZ%TNfB?h(p-S`W5zE1(~PidnZJpJc@j+8_UWoGE}%*RXC0ne+nDsP>4`^_HQAy_(>&9gF3xLrHyMjPD)n%FF5HO-wFk`J*)}sR%riVI)=8tjZ9^F_ktuGKimY~t@exEYVUBTs_u)~fFt$|RR#}P_0`3KUzho_<|6rrAlz;mWrHBBLjxGQNIu3<FylyLq%gJ#{j!Q)#7%ploA$!PQFjox@Ee>KUJQ{ps#@Nt-tv}0<SkY$Z?WF;HiXDqs#@OC=*!y>*K=Ydj4XaIJhiaFNsU{@4fc4%5kJwF+b3l=qw0kq=v<QrcOWAUl;z?bK(UyIqRXDVe-27Ft<{Af$>()SjV>FVdkdOw#UOWT<hcNfo_mhXFugNOr>qK4SP-Vn5+g;0D)ZNkm3e5H7otK0#q~O!=T<0&MfyW*^P88+2TJ&KO=aQfsDLN3LG?MO9W``F;}K9a_n0L2ppqfGTi)J|L9~l(=n%c-bD0fvBrQPNV|4BY(-tENiTqVjgF>r-D=9FYrX}^-6&4sJjr#!ByzDl{qIn4UaP$Sm<>%sU3$+dIq$kc!7FbwO02YK3c+CL*gen_C)$sm#NNM~WA&=uCG{z-C<{e{`qpo>!bSb0IRk-5gZZD-|Y)^^%RyLwij%+Y?B%(^qB^p6oOKfN3t56KViX5!Q7>jatSR}Z*6aIpg1*@=pdw7mG;&0t65)g#2g`0Q#d)r!g6=ovgQ+UZ|%EdA~<zkRv2}IXx&|-*gP$7LxroiT?-!C>vU6z1!reTRuq7X`j5K3{^n@y=$0wf5jWeGUh2I1-Gq#J&|tKk2JPQN|q!G}{!ID}J8`1vQbw*4<?n+QVu;4O$JRQN{}!s>cITB?B%mV)qu>EJbZ{N$w%_^>3`zaSkSFS`N$yFK`~A~{wsNT&1Q->t$Qp!7ccZ=f(VJuWA_xP%`(zh`JBkDs6A#K&`Qz*}7>d_0kdaES-MfJVCatB`rh2PRpEA@v_ZJO{uJ*1)s)f#M0_Y@{3F2Szdok4EDNem<kh<t7#WLWR>{3|D7`CaG|pI>32}3U_tO@G2F4R)x2y@L?4`ro!XZk+f4)xKxD~uMLy$S1Mepj$y4-;hI*OUnsq&7lfq;yh!mYsqiq;@mqd;AKsjt_{VtgfsU{I@B{E(6<(skgVmIzAJqr^{X^+}ur(|_;QgeP=8vCSs>HuL5Fg4RtG)Dl+KZ3g8&o(Oh4|U7;Eye=j^BG#x(8mQ^t({{EPTl4v7Ykw;X|m;K8_Op;fs=CR{E0_-We)<w+f$z^h)n+QeksvGK7BWDNlL%=)Z4KSo$C4lqV~F7XC7Y*P+5LBzLX&zI^Od;Vu<^4CU|5Dtr!&W1;jXdCDt`UQ^EU&WjInbt3%98TcpX#P{XDR{AF+`6mbBpA(4RnNdF`qxzARK8xRIe{Wwt_E(GClT~<(3L#(Tsqk*3*M-u*c5#y4n*-^64AH^qYsCk-o<sO^Gw|=qiSNsQt@Q6g^3M&#|8XGxa~btxE~+0{>9hEa_V@PX;{p|a04{X_eQ&kGS0Utcp$czT;ZIcvddsIh_4y>lXI>jk4?iH!A3!c759W`bPpEX?Ss8{8czY1P@vCWkz<Xq65)b6775^CYozBasZ}1%-L}6iRGTfuW$?D|pLKOb%g~<@~x7$?sYZT&ogXhVQqwtI6WQf1(M^SibM>1^AsE2p2Nrt=7yy|XG{e<$nP=yz%utSB{jg_x>Myq@uS7Ezal)hhuFIM@^LFE`)p3kU|waefJ6;49s4B^u%%v;{yuCcuLQ{~$_R^H+n?eg}O@2z9yE1p`*_tmN#udQ==zQt3XS>-h;XL&uHQ9k&|Dvz^NIebKgSEz9JSoui#Jo(?Q^8G$k4lnoe=mJkJDxbSvr2Jo|!sRGm5FXYg!xL24s>0PO{H+S#qROG#^7yzakDsdWmnwWxg|GDT@#X)?cgpbhDtx7s$3rUr8&$sZ<~K|JIUf1%QsIw0`6*YKpB9ym^HtcU!c{Mm{Q2a6)yib}QpwN%Dfur0mmWyoy!56jI=zAPPEha}Dx9stGd%dOUXctBRpGHJycC7_dC2qqpd9x0_rY>N__PY2Q{f*y`(b-qUf_508k&Aq`ie@oL4|`Ve9syh|3eDC+rtk(H=}aE`NIz`HwgdJBM-nIS0R+=<sSNg_w1S^-d%OVhu^<|!tZ(Tp`Bl@!mCtxwWqzjR`uIQs_-}zPEp}0?_}h2mS;Rz=D~mJ!esb6(2o@UdKBX4Mvs00<7{62-~`l;aJwmIjQ>~;2=7$kJu1A9JWaj#<pq9QS67#Qs!BIQg{P=+{%RV3k%C|3;fEiP3(5iK7eBb%ApD$19)N#Ig;2hywbS^3_x06Dyvyo@55K<?g+m_vFRFRQtt$MQ3h!_|Zi?q2&wS-q9{e54li_<{UZcW4qYyu*dgjkCj|`o^E=S{BsGg1=EC+<kRCtjJS9$WYx8((Xm5%Dtzd@xtN`-G$;mI8|{^<&Su7@9fDySTAe({6L4Z@Fk<N^4#sC@s%GhPGUO&v+R<#ob`-%m#2Vh_IdnxVog+LIxES}sh6yW5i?e%jPJ-3k?UsBnYF+u$3PCc_g{_;$4Jx7(BcVYNQ}s0x4YS+9n5)~xkpSTBZt*S8)F-#u&n7s~-*lM2VHaDPw!_O`sh@1wv6(a%c1P^D{A;YBL!DAV}s6@19U4?iD8<$&{tA6#w_e%&Jv!0%8Yl;@=$`hfR9If-|Bo$%rJPoeNO5B_Ua{XbHL$Ek3-=W40nt9kSP!l7A(*QCOWP>7!!RJwms;lFwIn_-{SxBm<EE^FTg#x>aQh5g%ad+H;W1Hy;hgV`^Ne8BIXRW$vq^p~wlhF7TYlb-d9&nWnf9)9?_2bBZPAAWGTLHLA69)SN*g;1UkdE|LACqCf4uquf+$uqv^#fRUYL}8N$|MIqEc!dhD@zlpXXg~W0Dtyc{Uik2Q_>+`R<EvB%cG>e)2zF7Q_34AlP?%xgedsb2UX%=d_*WtPQ2DCmH`@3^D7*xvKP_kerlRyy>nv|5{izxGo0>C!KyM{V|F#z?eHK2>_h~4<FExDlZdU}Rhjx063Zb3emVtj2!k=Gf{Jipv7Ct^lcasVq_M9g;6`jA!i~rROe0=B9e(0W?df{Wd4|wojr{Ggicy=KE><s+>Q1G)VGF-00t5o=L74CO&GJNaBG`*j!ONPHx;jdNrTNOU7!sk@@XODb8tCEh7-U*dtI8%kERA_u(d3;BOZ^|eSU-}zzroS{0e|1j$OEcud&s7Nj8Wmpe!T(hy89t@LKX~x};;C<wJ@R9`SE=x|9{e2_C&Nosc!dhDQsFf!yjF#uQ{fj>c=Ica{s%qu@bf_=&*yUTuQngw3Z$1eJ;1+@!h2Ep0~J1~!iQD3dc6#<L*aevX?}qJZWX>qh3{A4M^t#F3a>_Vee|}V^t&?fakwE6e?v}wxLmW!x7u<EE&tKt@8kCaL?7zSqn`SR>lxr3v_2Ugfx=TzcxFa;4hmZ{<j3+nufo5m@C8qPe0VQbeth!y<Og_zqIW2g6F-wszHmNpe$Ga6htdm8kINN@`0<tR*&h7I75pg`{;vvWZ;;_3Ju*DKhfaUE!aEk>pXk8{x}7RyJ;`)F{8klSh|_!U&qZNq`t=I_eiUBs!M_CIeME)3J@}Yz7C!L36@~YC@W1TA|EdbVrNTQr>2bQe>Hj|k|1k=G>A{EV;oy3+LwaQh7qa>A@y&XBR0#JxK8WZ+2)E}Qp+dOs@wh;Kn4S+G<hsWr7tU{%T)y(a*Tcabb#TkulPY}H)4p)}pQH5n`LPEtl-~m<C&Ncn_`JuTSYG_spCZE}RCqiJ@$)qWfAiaAc!~<!-cIBHRlyH9RfY$v@bxNuqY6KCDxH4ZskNoY_|sJQb`{Q7VVeruRk&V-TU7X7#K*@E%L#aY@4?6UD9@8&hYHuBuup}5JFh<U-jzY`5k==GDtz1%KB>azfX-R@=!K>~_%s=Q6ovcEk>L$z%kVwtB*Sl@@WFFv`iCldlT~<(hu`h9>Gbz0_#b8`<@xT}G(O;g{C6t6Me}L7v*e%g|2KF2F>+LO{9Ug<uD|ZCP)dO!6^Vcio7=s%cU6(Q+uOEFuXjuLT1wHp&hE_JPP;p^&dlE3Vk#BH0*27?Lj+0FgcyECL9AlLT1~|!{6R&c#URvRQ6t1^w3MjS@0<61dpmF6<4UZFliYoGKJ)$czVG|K@6FE34$5^S{S?wvTFrj}+FgS5a-<zSYJMB>af#lh;rBiyzre-&&X4zU`VP_)NJsjj^k#`3={qz1@1CK)Cp7vlljL;rcWLCW>{HYD8S)Fht2O+artt61Dg65!;yI0;v!(A$<wZXT`rH)#{ihyITd|*)A>D|y9qY_eO}){{m647i-HCJ;(mQ+A`p!Gc`gD8`AbkYsw?3r&JsSSK8oe)Q_>W`1T$7B_8<J}NMDoM&%Y1^SkfxDlH1f|Nz8~rH5<P(Qry6-3-%Ci3BYpdSB>yYKe}nY55`6>dn;Ll?pKSO2GnAi-|I;|m%1EC?x>q+puHp1TynYMP-5UPs>!P#;>0L<oApP39Gn2m<>1WOoe{x-vUW;@i($69tL0Xdh|9{gbA0rxjw`ll#x;Wh{(fvrb;_nVu2cmdqca%PW_cuF{@4<m6{wPxMYFF`l!~4YVjN<dtV@RLJ=WPd(iswz@r?$n9XqS<`j^6_vLn^-i$spZ<bSKgkPSmecVm&uSeolEblP2<*;{9XIWEwfF#GA<pB|e=TZdTzl$nEo0_)PNpA{9Q1Jbk_jZy{S1?^<pqv&j_~tMEAxeHA{JELGz3$kUxFd_Fm-#9M307{%L2x8lo$X3`G5ufi9Q=RFmE4k`O8{9IBVSK$lE=DSq*d8DAk7m>0OKc8&9TZKdLcdPIV$gw>t{6ezyJ{5jZBN*aKG`OO3L;NEe{1OemRD*w1gJ0T!4K=f0!T;-N8E3!XKdmkw#NNhh5En&Cr1dt$MREEf;twM(ij;}(mwPd^aRK=w##y|ra#j<=FC?4qkK*Sxaei_yKNoueu4v-=MG?7f0jFuy(=F-Qig<^Fk0YLu@LLgIE8%w|-Xr0U3qSAS=O+;VG4i)a{4XPZ5c5jBHvBEbmmt4*HODE$citD(GjAIDDdE>5o{{id5#J}_-$Z;V+7&OW{~_XEm-t^oe7A(ZiTLdjehTr$QoH6fbNmGIi?X-`@r4q94Doge?`h`wP@6;$-x%_@lQPz&a}lo~{xssV5#NRQJ_&yi@mmp}iTG29@0R!vpr2c@T}u)FMKjNnotV#}e7~(3kMCl;_DPfCdx#&A@OjfY-Y&hg;L_>Xzvz#6-D5n&8|&(3)RU3)m?3{-eb)JZYsh~NDJtr`ihs{^tPdC;kw4Fb9o;y;976t668~$6KPTZQ5tr+H^9+tZE%7fyyhY0AHHaUT_^lZ%ZjJNicH}4WcntX)=l458{>FLj9@Nt=%}09?KPLI}Bg79%_))}<Nci6oKOy0BXL9_ogkK)wjq~Z%fS*GekLv-y6!J<e9vw`?VCH1asXuO+$$Gu<cvi!INQ1wOcEzIfD#SZxsrh>~_$Cc*Yw!sTe#b0ze7>RK|Bi<Ls0Kf&(KD+>jW5>VAJgE87NS^H5HhIYzfpsaY4BS#ID0*~Dj)W1_z!9DS6g^Kh?}Mh5dWKof7WbuoD;Lv{5=|cqXu_0_)ZP}&}?-a4$S855;u1%aYFrrM$h{ieC`}Ie!d1@rop>4_|P1+|2Yl+xCY;)!5`M(Ps~yG<Doe`ZsI03hjnRau3C>ZSFNWySKY1$HTZ#0PiyUFUD*1$#_lgQcHh$A|I+Abo2TYqHc!pJN`v=n@Zouwhd93eiTBy}Yxp14;6ItCj@ug={*xMf_Ix$INP}Ol!Mo<G{TZH*`Ga4gyoUJre07}nApcgW{(Mhk_XXq^U!v?s{LhGsFKb-P+l8%ayB}|5{=@wXt{=qu`RZ1+-2sgrLxb;V<^G5-i^Q|>Cp7#owyNX#w#J{9HZ{JmO|55T8&TdZZ)j8dv#m|NKH1f#?ysjbc3;-``TI8Yyz_63o{QSm{(nM)_qS{29Su(CmVv|yO3T#=nzMZ?AJDvOTGY*LgU@~@v69jZTuTBt6k<suU$9b6;8kr~NHdO1m0zc8te`gtylmiQx=>HHgVwX=-Ex)sWh+kumzG?!Qncz>Gwbr%1PztPySZ!SDzMSKXBojHYbGAgRM&^%{niMuZyD(9Knn#czn%KFGg`E$?F5!r_AK~6mWr<`8Maf8QQKsuy11oMXci;FeKSMlk}uW-xSy=~5;C9)t5goEG^mt|RwJCN29{rEuikbp3{nR_$ybAd>rk)a1a^rlTFI~Yfd>tvff4e@J2^T=<4GEXs^iP+Adj1iC+aY#p39*=1)qX2fQe4*?*ZGfR=eJ?XXLG%k>8%_1m$)rf!0i$WeQ6Lla3k1igiZPB7~vznC1Dl8@iI{o^&N&1X<`G8VKR~wui|X+LfEYx>d#;10%O$67vja)M|)`*?`>CfY=SlHbU174E6O6Q0iB5G)<GSe7PL92>sozYfnO4ulZd=YF>8=q`~LyqQ`1XB@5EU47)lJm$H}oMHez7?*)EP85xP?iD`M(sO_`t4@%&o>#!`Lrb|bQZq6uDGjKhh8kGr>cT14Sfn~<JJ65bxGtm*-v8myCMwMEuG>{Pw8bQrUsZ<4#x-*D`9Yk0uUA>`qeTt?A`za;;*T+0-Bu2Lkr?WwPrR_j=*(L~#R!YDR+-n9m($rcMTHC)NDzYkP0C%zI<|S1f>_Sj2TWq*f(|2jXa7-AYb!>y#pxbtRnlpT>Ys9dN70>Ehk)N1|$5S;vIywPG0Fu{rz%>}sV;z#I<u2s*NYNdqmgl)13Bx0~X-(v<auDV}iwL3pHw^Z!Pba~*;q^&nFjiC?Gom+oIUZ(-@>0UB1k@eDJc?ZFW?{)2kW7+@>4t?8TYzakw0d<mHB5(l`vy`_(rFngQ7{7Kc6(3Hnt^m*k|tuEvE`735XzNfP#9e=oy!{OTq>1Jq&BR}#wn@I6l)E?K&Fa2D&D-Ag5p>r4&teaJl({KPAYT`CIPENH(0#aBc`*#^0HxjX?w8C2w3g#y2Hv3J-5ow=jo_tlncu(bJR+uz{~6kno7kJP^pVBRw)~->1#tUHP&Aq8m{vlXE^}+ZGM^#tWq{C%>brLW!DR6uW9lLia=eY!(PP#jtWc{yb)>W&<Wm%Q7gz##xN0E(O?R7(=E_DFku7*4-%o4?PHNRLD%Fb44Q*M?m+Jb`9e<*T<Yyh(|D|th-s6lX6^$Jmg+ueFkK6^0RT4R(?M%ov@pwCh?*gzA^C5zWS5~a^m@Z{QWJ2p(XqpNoeo33+H)u4Gt6d3RFBQfVnkI5C^ZgZIS3^y5=$m)=PCgvg(?I46R9z&Idws06E6>H(Q-zE0=Eo{k*IO(xgn8zqLHk5Fy)mD=1_Wad65lZ%@XEEKgvS3x?WYt_pt>5oeWN|V`d?+L|sdyKy3M-yzXM3Y|{@LjR^^U;EIWNJL@m>nnkrA2N8F42u;@yv-LFwkW7gpww|RJOd)<?+D<elA`3%iH4}~+rhgD-1yvYpS;9m%iDg2VcM!`7JCH2=*CW1*u7`C}*fOZbzU2kAVL!ME3cgdJtQf(lb6Bj3)CP?PGnWCjY!`5f@(`w?X9oqCknOz4MYEWZ2WZ2rq`WTId^s1>Y&K0|cO;9J!K^vsC0QABpj2N2Vyh;r01U$+T*boTlGOkx=#<sr$v`t>Ls{xOyyS~v#78hQ4g;z-n9eXQQ-kX^7Kf>wf)z+Q+X+z|3m5)S9tzMMW^L%OB&sj7be-dlJGJSfe%6-*6fG{b%wpZNfiJB^1|sL68`Py^zr_d&3`0MO9*xYM+ELjRjJwn~U~-0kwm)JUxuON*ktZ|M2Uc$)rCFWKc9^SimS=G$4nt$LQS?OxR9WmWOmMDfRD3IC=j_~+nvE=*pF1fjR{~!eVRh?CYV);rE$fEz`HJURCMj8^5>zW$l(p1yOvN-5dISsDKJHXF{ik`U26R0&`H+Mp2t(Gm?vk`MEQ1=RjrzRW=!AEPmdO$<Q(YadQCU8#7EO|-^f2>Itf67S##Ye7taAzI9k-#m8!R7ItRR<6f=q{cNfgH=(UiT;W-i^DSUEq1<^BVv!gx*L<Wf{#LX4K+1{4Yc%o~)qS=r*cn{dkNk+PbLX^q7EYKh&t#^5%V(}MWqxPcXeVjC-aE_8HIt%GtEyJ%hoYxnT1z=nRztU92KQ<zl3E8?!Q{)ECc&ng;>5kHlS0f~hRZ}u@Z>f#6A%99w(F>o3#+GCz;8i7G#Rsru~3Z^%C24<j`@c^<La)?H3@&<?N5TC)gQL;fj7~}T2=A7@77~Exrw>L4<%2h@|ge9FXPHktztzF9HJZnsxv71ZrIgA0qFh%1>)O3~(w&P_MVb3i2A@*Adx>VwCk<Me1yx5l|=w%ZBbm^S!wLN+Iv@7Jr{w+aYk>q6i>~Z<rdi%{$dJrGr&mjC6xsVt864<-_n(O4nelS5di46dFG(}ItcQ2f-^Iz;66ZDAW|1^oRuX*3ElNbBTYLra+-%J|YKaRSEyx4~(=;7&6`*QoggxAELbFp7d(4HBS@{1MnUnM*yV*f<#xi?aIN0r?FUy<a+{x?B)OZ)cPCAvqF7yIM{mA@mE<sXvd#eO<LcTQpd5lLR`vl8?lE7kJicwCYf`wRq?w<pT+`!*4KyznST=?|p+kh1;nOY&krhM?b_!v4=Bd9g3Bwm(o3kn{H?S$;f92c!Wf+y5Q>wGuuy*dg|@Y~I1C+};+6z5{=4b@F20Oks!GUs?V=!uw9hi~SvCls|#~&yeJVUu@e`Q=Pon-?;T=PWMe=e_B&izP4{;Cnrax_{s8fC3&%r=Gd1w?U3?kspQXsCaz1!i~UILU*@z&vM<XoLi_TzS0OLYA59Xyq^Yqcvtzl&zRVlb$OpG^`h|O=0g!n=sgeK7VjhtlQUc1nYc=x4E4h5(x+pI54r}7~%1vDU*Uv^J<oHpI{U>8QV;{TmgWJDNBcHu<R!9#@FCUP3BekpUSbUtzXK;fb%LDc(R-S*@^sLz0O$w*D{O6~L{{oHtt1aBp#1#4SA9Pm=<^\")))\nimport C"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <ctime>\n#include <atcoder/all>\nusing namespace std;\n#define _LL long long\n#define rep(i, n) for (_LL i = 0; i < (_LL)(n); i++)\n#define vecrep(itr, v) for (auto itr = (v).begin(); itr != (v).end(); itr++)\nusing namespace atcoder;\n\nint main()\n{\n    int n, d; cin >> n >> d;\n    vector<pair<int, int>> p(n);\n    rep(i, n) cin >> p[i].first >> p[i].second; \n    two_sat ts(n);\n    rep(i, n - 1)\n        for(int j = i + 1; j < n; j++ )\n        {\n            if( abs(p[i].first - p[j].first) < d ) ts.add_clause(i, false, j, false);\n            if( abs(p[i].first - p[j].second) < d ) ts.add_clause(i, false, j, true);\n            if( abs(p[i].second - p[j].first) < d ) ts.add_clause(i, true, j, false);\n            if( abs(p[i].second - p[j].second) < d ) ts.add_clause(i, true, j, true);\n        }\n\n    if( ts.satisfiable() )\n    {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, n) cout << (ans[i] ? p[i].first : p[i].second) << endl;\n    }\n    else\n    {\n        cout << \"No\" << endl;\n    }\n\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\n#define REP(i,m,n) for(int i=(m);i<(n);++i)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int N,D;\n  scanf(\"%d%d\",&N,&D);\n  \n  vector<int> x(N),y(N);\n  rep(i,N){\n    cin >> x[i] >> y[i];\n  }\n  \n  two_sat ts(N);\n  \n  rep(i,N){\n    rep(j,N){\n      if(i>=j){\n        continue;\n      }\n      if(abs(x[i]-x[j])<D){\n        ts.add_clause(i,false,j,false);\n      }      \n      if(abs(x[i]-y[j])<D){\n        ts.add_clause(i,false,j,true);\n      }\n      if(abs(y[i]-x[j])<D){\n        ts.add_clause(i,true,j,false);\n      }\n      if(abs(y[i]-y[j])<D){\n        ts.add_clause(i,true,j,true);\n      }\n    }\n  }\n  \n  if(!ts.satisfiable()){\n    printf(\"No\\n\");\n  }\n  else{\n    printf(\"Yes\\n\");\n    auto answer=ts.answer();\n    rep(i,N){\n      if(answer[i]){\n        printf(\"%d\\n\",x[i]);\n      }\n      else{\n        printf(\"%d\\n\",y[i]);\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>; using vi = vector<int>; using vvi = vector<vi>; using vl = vector<ll>; using vvl = vector<vl>;\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#include <atcoder/all>\nusing namespace atcoder;\n\n// 旗iの座標をFiとする。\n// Fi=Xi or Fi=Yi である。\n// (Fi=Xi or Fj=Xj) は (Fi=Yi → Fj=Xj) と同値。\n// 対偶を取ると，Fj=Yj → Fi=Xi と更に同値。\n// i=0,1,...,N-1に対し，\n// (1)|Xi-Xj|<D のとき (Fi=Xi → Fj=Yj) i.e. (Fi=Yi or Fj=Yj) というクローズを加え，\n// (2)|Xi-Yj|<D のとき (Fi=Xi → Fj=Xj) i.e. (Fi=Yi or Fj=Xj) というクローズを加え，\n// (3)|Yi-Yj|<D のとき (Fi=Yi → Fj=Xj) i.e. (Fi=Xi or Fj=Xj) というクローズを加え，\n// (4)|Yi-Xj|<D のとき (Fi=Yi → Fj=Yj) i.e. (Fi=Xi or Fj=Yj) というクローズを加える。 ※(2)でカバー済\n// Fi=Xiであることをtrueで，Fi=Yiであることをfalseで表す。\n\nint main() {\n\tint N, D; cin >> N >> D;\n\tvi X(N), Y(N); rep(i, N) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\trep(i, N) rep2(j, i, N) {\n\t\tif (i != j and abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\tif (i != j and abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> v = ts.answer();\n\t\trep(i, N) cout << (v[i] ? X[i] : Y[i]) << endl;\n\t\t// for (auto e : ts.answer()) {\n\t\t// \tdbl(e);\n\t\t// }\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FASTIO\n//using namespace std;\n\nusing ll = long long;\nusing Vi = std::vector<int>;\nusing Vl = std::vector<ll>;\nusing Pii = std::pair<int, int>;\nusing Pll = std::pair<ll, ll>;\n\nconstexpr int I_INF = std::numeric_limits<int>::max();\nconstexpr ll L_INF = std::numeric_limits<ll>::max();\n\ntemplate <typename T1, typename T2>\ninline bool chmin(T1& a, const T2& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1& a, const T2& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nclass Prints {\nprivate:\n    class __Prints {\n    public:\n        __Prints(const char* sep, const char* term) : sep(sep), term(term) {}\n        template <class... Args>\n        void operator()(const Args&... args) const { print(args...); }\n        template <typename T>\n        void pvec(const T& vec, size_t sz) const {\n            for (size_t i = 0; i < sz; i++)\n                std::cout << vec[i] << (i == sz - 1 ? term : sep);\n        }\n        template <typename T>\n        void pmat(const T& mat, size_t h, size_t w) {\n            for (size_t i = 0; i < h; i++)\n                for (size_t j = 0; j < w; j++)\n                    std::cout << mat[i][j] << (j == w - 1 ? term : sep);\n        }\n\n    private:\n        const char *sep, *term;\n        void print() const { std::cout << term; }\n        void print_rest() const { std::cout << term; }\n        template <class T, class... Tail>\n        void print(const T& head, const Tail&... tail) const { std::cout << head, print_rest(tail...); }\n        template <class T, class... Tail>\n        void print_rest(const T& head, const Tail&... tail) const { std::cout << sep << head, print_rest(tail...); }\n    };\n\npublic:\n    Prints() {}\n    __Prints operator()(const char* sep = \" \", const char* term = \"\\n\") const { return __Prints(sep, term); }\n};\n\nPrints prints;\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nclass SccGraph {\nprivate:\n    int n;\n    std::vector<std::vector<int>> g, rg;\n\npublic:\n    SccGraph(int n) : n(n), g(n), rg(n) {}\n    void add_edge(int a, int b) {\n        g[a].emplace_back(b);\n        rg[b].emplace_back(a);\n    }\n    std::vector<std::vector<int>> scc() {\n        std::vector<std::vector<int>> res;\n        std::vector<int> vs;\n        vs.reserve(n);\n        std::vector<bool> used(n);\n        auto dfs1 = [&](auto&& self, int idx) -> void {\n            used[idx] = true;\n            for (const auto& v : g[idx])\n                if (!used[v]) self(self, v);\n            vs.emplace_back(idx);\n        };\n        auto dfs2 = [&](auto&& self, int idx) -> void {\n            used[idx] = true;\n            res.back().emplace_back(idx);\n            for (const auto& v : rg[idx])\n                if (!used[v]) self(self, v);\n        };\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) dfs1(dfs1, i);\n        }\n        used.assign(n, false);\n        for (int i = n - 1; i >= 0; i--) {\n            if (!used[vs[i]]) {\n                res.emplace_back();\n                dfs2(dfs2, vs[i]);\n            }\n        }\n        return res;\n    }\n};\n\nclass TwoSat {\nprivate:\n    int n;\n    SccGraph scc_graph;\n    std::vector<int> scc_ord;\n\npublic:\n    TwoSat(int n) : n(n), scc_graph(n * 2), scc_ord(n * 2) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        scc_graph.add_edge((f ? i + n : i), (!g ? j + n : j));\n        scc_graph.add_edge((g ? j + n : j), (!f ? i + n : i));\n    }\n    // complexity : O(n + m) (m : the number of clauses)\n    bool satisfiable() {\n        auto scc_res = scc_graph.scc();\n        const int scc_sz = static_cast<int>(scc_res.size());\n        for (int i = 0; i < scc_sz; i++)\n            for (const auto& v : scc_res[i])\n                scc_ord[v] = i;\n        bool res = true;\n        for (int i = 0; i < n; i++) {\n            if (scc_ord[i] == scc_ord[i + n]) {\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n    // complexity : O(n)\n    std::vector<bool> answer() {\n        std::vector<bool> res(n);\n        for (int i = 0; i < n; i++)\n            if (scc_ord[i] > scc_ord[i + n]) res[i] = true;\n        return res;\n    }\n};\n\nvoid solve() {\n    int N, D;\n    std::cin >> N >> D;\n    Vl xs(N), ys(N);\n    for (ll i = 0; i < N; i++) {\n        std::cin >> xs[i] >> ys[i];\n    }\n    TwoSat ts(N);\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            if (abs(xs[i] - xs[j]) < D) ts.add_clause(i, false, j, false);\n            if (abs(xs[i] - ys[j]) < D) ts.add_clause(i, false, j, true);\n            if (abs(ys[i] - xs[j]) < D) ts.add_clause(i, true, j, false);\n            if (abs(ys[i] - ys[j]) < D) ts.add_clause(i, true, j, true);\n        }\n    }\n    bool ok = ts.satisfiable();\n    if (!ok) {\n        prints()(\"No\");\n        return;\n    }\n    auto res = ts.answer();\n    prints()(\"Yes\");\n    for (ll i = 0; i < N; i++) {\n        prints()(res[i] ? xs[i] : ys[i]);\n    }\n}\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nint main() {\n#ifdef FASTIO\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n#endif\n#ifdef FILEINPUT\n    std::ifstream ifs(\"./in_out/input.txt\");\n    std::cin.rdbuf(ifs.rdbuf());\n#endif\n#ifdef FILEOUTPUT\n    std::ofstream ofs(\"./in_out/output.txt\");\n    std::cout.rdbuf(ofs.rdbuf());\n#endif\n    std::cout << std::setprecision(18) << std::fixed;\n    solve();\n    std::cout << std::flush;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct SCC {\npublic:\n    SCC(vector<vector<int>>& G) : G(G), comp(G.size(), -1), visited(G.size()), G_rev(G.size()) {\n        for (int u = 0; u < G.size(); u++) {\n            for (int v : G[u]) G_rev[v].push_back(u);\n        }\n\n        for (int v = 0; v < G.size(); v++) dfs(v);\n        reverse(order.begin(), order.end());\n        int c = 0;\n        for (int v : order) if (comp[v] == -1) rdfs(v, c++);\n    }\n\n    int operator[](int k) const {\n        return comp[k];\n    }\n\nprivate:\n    vector<vector<int>> G, G_rev;\n    vector<int> comp, order;\n    vector<bool> visited;\n\n    void dfs(int u) {\n        if (visited[u]) return;\n        visited[u] = true;\n        for (int v : G[u]) dfs(v);\n        order.push_back(u);\n    }\n\n    void rdfs(int u, int c) {\n        if (comp[u] != -1) return;\n        comp[u] = c;\n        for (int v : G_rev[u]) rdfs(v, c);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    vector<vector<int>> G(2*N);\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                G[i].push_back(N + j);\n                G[j].push_back(N + i);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                G[i].push_back(j);\n                G[N + j].push_back(N + i);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                G[N + i].push_back(N + j);\n                G[j].push_back(i);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                G[N + i].push_back(j);\n                G[N + j].push_back(i);\n            }\n        }\n    }\n    SCC scc(G);\n    for (int i = 0; i < N; i++) {\n        if (scc[i] == scc[N + i]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n    for (int i = 0; i < N; i++) {\n        if (scc[i] > scc[N + i]) cout << X[i];\n        else cout << Y[i];\n        cout << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#include<atcoder/all>\nusing namespace atcoder;\n\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nusing mint = modint998244353;\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\n\nint main() {\n\tll N, D;\n\tcin >> N >> D;\n\n\tvll X(N), Y(N);\n\trep(i, N)cin >> X[i] >> Y[i];\n\n\ttwo_sat ts(N);\n\n\trep(i, N)rep(j, N) {\n\t\tif (i == j) { continue; }\n\t\tif (abs(X[i] - X[j]) < D) { ts.add_clause(i, false, j, false); }\n\t\tif (abs(X[i] - Y[j]) < D) { ts.add_clause(i, false, j, true); }\n\t\tif (abs(Y[i] - X[j]) < D) { ts.add_clause(i, true, j, false); }\n\t\tif (abs(Y[i] - Y[j]) < D) { ts.add_clause(i, true, j, true); }\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tauto ans = ts.answer();\n\t\tcout << \"Yes\" << endl;\n\t\trep(i, N) {\n\t\t\tif (ans[i]) { cout << X[i] << endl; }\n\t\t\telse { cout << Y[i] << endl; }\n\t\t}\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nstruct SCC{\n  ll n;\n  vector<vector<ll>>&G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>&g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,bool tx,ll y,bool ty){//x:true x+n:false\n    g[x+tx*n].PB(y+!tx*n);\n    g[y+ty*n].PB(x+!ty*n);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] > scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,d;cin>>n>>d;\n  auto v=vec(n,2,0LL);\n  rep(i,0,n)cin>>v[i][0]>>v[i][1];\n  TwoSat sat(n);\n  rep(i,0,n)rep(ti,0,2)rep(j,i+1,n)rep(tj,0,2){\n    if(abs(v[i][ti]-v[j][tj])<d){\n      sat.add_or(i,!ti,j,!tj);\n    }\n  }\n  judge=sat.solve(true);\n  ans1(judge);\n  if(judge){\n    rep(i,0,n)cout<<v[i][sat.ans[i]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"O3\")\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define EPS (1e-9)\n#define INF (1e17)\n#define PI (acos(-1))\n//const double PI = acos(-1);\n//const double EPS = 1e-15;\n//long long INF=(long long)1E17;\n#define i_7 (long long)(1e9+7)\n//#define i_7 998'244'353\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nlong long po(long a, long b){\n    if(b==0){\n        return 1;\n    }\n    \n    long long z = po(a,b/2);\n    z = mod(z*z);\n    if(b%2!=0){\n        z = mod(a*z);\n    }\n    return z;\n}\n \nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=std::sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n \nlong long gcd_(long long a, long long b){\n  if(a<b){\n    std::swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \n//using namespace std;\n//using namespace boost::multiprecision;\n//using namespace __gnu_pbds;\n\nint main(){\n  using namespace std;\n  using namespace atcoder;\n  \n  int n, d;\n  cin>>n>>d;\n  int x[n], y[n];\n  REP(i, n) cin>>x[i]>>y[i];\n  \n  two_sat ts(2 * n);\n  REP(i, n){\n    ts.add_clause(i, true, i + n, true);\n    ts.add_clause(i, false, i + n, false);\n  }\n  REP(i, n){\n    for(int j = i + 1; j < n; j++){\n      if(abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n      if(abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n      if(abs(y[i] - x[j]) < d) ts.add_clause(i + n, false, j, false);\n      if(abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n    }\n  }\n  bool possible = ts.satisfiable();\n  if(!possible){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  vector<bool> ans = ts.answer();\n  REP(i, n){\n    if(ans[i]){\n      cout << x[i] << endl;\n    }else{\n      cout << y[i] << endl;\n    }\n  }    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\nstruct SCC { int stamp, scc_num;\n  struct Node : vector<int> {\n    int dfn, low, scc; bool inS;\n    Node() { dfn = low = scc = -1; inS = false; }\n  };\n  vector<Node> N; vector<int> stk;\n  void init(int n) {\n    N.clear(); N.resize(n); stk.clear();\n  }\n  void addEdge(int u, int v) { N[u].push_back(v); }\n  void Tarjan(int u) { N[u].low = N[u].dfn = stamp++;\n    stk.push_back(u); N[u].inS = true;\n    for (auto &v : N[u]) if (!~N[v].dfn) Tarjan(v),\n      N[u].low = min(N[u].low, N[v].low);\n    else if (N[v].inS)\n      N[u].low = min(N[u].low, N[v].dfn);\n    if (N[u].dfn == N[u].low) {\n      int v; do { v = stk.back(); stk.pop_back();\n        N[v].scc = scc_num; N[v].inS = false;\n      } while (v != u); scc_num++;\n    }\n  }\n  void run() { stamp = scc_num = 0;\n    for (int i = 0 ; i < N.size() ; i++)\n      if (!~N[i].dfn) Tarjan(i);\n  }\n};\n// LatexBegin\nstruct _2Sat : SCC {\n  void init(int n) { SCC::init(2 * n); }\n  /* addCond(0, 0, 1, 1) -> v0 or !v1*/\n  void addCond(int o1, int v1, int o2, int v2) {\n    addEdge((v1 << 1) | (o1 ^ 1), (v2 << 1) | o2);\n    addEdge((v2 << 1) | (o2 ^ 1), (v1 << 1) | o1);\n  }\n  bool check() {\n    for (int i = 0 ; i < N.size() ; i += 2)\n      if (N[i].scc == N[i ^ 1].scc) return false;\n    return true;\n  }\n  vector<int> construct() { vector<int> ret;\n    for (int i = 0 ; i < N.size() ; i += 2)\n      ret.push_back(N[i].scc < N[i ^ 1].scc);\n    return assert(check()), ret;\n  }\n} solver;\n// LatexEnd\ntypedef long long LL;\ntypedef pair<LL, LL> pii;\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int n; LL d; cin >> n >> d;\n    vector<pii> arr(n);\n    vector<int> pts;\n    for (auto &p : arr) {\n        cin >> p.F >> p.S;\n        pts.push_back(p.F);\n        pts.push_back(p.S);\n    }\n    solver.init(2 * n);\n    for (int i = 0 ; i < 2 * n ; i++) {\n        for (int j = 0 ; j < i ; j++) {\n            if (abs(pts[i] - pts[j]) >= d)\n                continue;\n            solver.addEdge(i * 2 + 1, j * 2 + 0);\n            solver.addEdge(j * 2 + 1, i * 2 + 0);\n        }\n    }\n    for (int i = 0 ; i < 2 * n ; i += 2) {\n        solver.addEdge(i * 2 + 0, (i + 1) * 2 + 1);\n        solver.addEdge((i + 1) * 2 + 0, i * 2 + 1);\n    }\n    solver.run();\n    if (solver.check()) {\n        cout << \"Yes\\n\";\n        auto ans = solver.construct();\n        for (int i = 0 ; i < n ; i++) {\n            if (ans[i])\n                cout << arr[i].S << '\\n';\n            else\n                cout << arr[i].F << '\\n';\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nstruct SCC{\n    int n;\n    vector<vector<int>> g,rg;\n    vector<int> vs,cmp;\n    vector<bool> used;\n    SCC(int _n){\n        n=_n;\n        g=vector<vector<int>>(n);rg=g;\n        cmp=vector<int>(n);used=vector<bool>(n);\n    }\n    void add_edge(int f, int t){\n        g[f].push_back(t);\n        rg[t].push_back(f);\n    }\n    int init(){\n        rep(i,n)if(!used[i])dfs(i);\n        int k=0;\n        used=vector<bool>(n,false);\n        per(i,n){\n            if(!used[vs[i]]){\n                rdfs(vs[i],k);\n                k++;\n            }\n        }\n        return k;\n    }\n    private:\n    void dfs(int v){\n        used[v]=true;\n        rep(i,g[v].size()){\n            if(!used[g[v][i]])dfs(g[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v]=true;cmp[v]=k;\n        rep(i,rg[v].size()){\n            if(!used[rg[v][i]]){\n                rdfs(rg[v][i],k);\n            }\n        }\n    }\n};\n\nstruct twoSAT{\n    vector<bool> ans;\n    twoSAT(int _n):n(_n),graph(2*_n),ans(_n){}\n    void add_edge(int i,bool x,int j,bool y){//i=>j;\n        if(!x)i+=n;if(!y)j+=n;\n        graph.add_edge((i+n)%(2*n),j);\n        graph.add_edge((j+n)%(2*n),i);\n    }\n    bool exe(){\n        graph.init();\n        rep(i,n){\n            if(graph.cmp[i]==graph.cmp[i+n])return false;\n            else if(graph.cmp[i]>graph.cmp[i+n])ans[i]=true;\n            else ans[i]=false;\n        }\n        return true;\n    }\n    private:\n    int n;SCC graph;\n};\n\nint main(){\n    ll n,d;cin >> n >>d;\n    twoSAT g(n);\n    vl x(n),y(n);rep(i,n)cin >> x[i] >> y[i];\n    rep(i,n){\n        repl(j,i+1,n){\n            if(abs(x[i]-x[j])<d){\n                g.add_edge(i,0,j,0);\n            }\n            if(abs(x[i]-y[j])<d){\n                g.add_edge(i,0,j,1);\n            }\n            if(abs(y[i]-x[j])<d){\n                g.add_edge(i,1,j,0);\n            }\n            if(abs(y[i]-y[j])<d){\n                g.add_edge(i,1,j,1);\n            }\n        }\n    }\n    if(g.exe()){\n        cout << \"Yes\" <<endl;\n        rep(i,n){\n            if(g.ans[i])cout << x[i] <<endl;\n            else cout << y[i] <<endl;\n        }\n    }\n    else{\n        cout << \"No\" <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/twosat>\n\nusing namespace std;\nusing ll = long long;\n\n\nint main()\n{\n\tint n, d; cin >> n >> d;\n\tvector<pair<int,int>> a(n);\n\tatcoder::two_sat ts(n);\n\tfor(int i = 0; i < n; i++)cin >> a[i].first >> a[i].second;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\n\t\t\tint dx = a[i].first;\n\t\t\tint dy = a[i].second;\n\t\t\tif(abs(dx - a[j].first) < d)  ts.add_clause(i, false, j, false);\n\t\t\tif(abs(dx - a[j].second) < d) ts.add_clause(i, false, j, true);\n\t\t\tif(abs(dy - a[i].first) < d)  ts.add_clause(i, true, j, false);\n\t\t\tif(abs(dy - a[i].second) < d) ts.add_clause(i, true, j, true);\n\n\t\t}\n\t}\n\n\tbool sat = ts.satisfiable();\n\tcout << (sat ? \"Yes\" : \"No\") << endl;\n\tif(sat) {\n\t\tauto v = ts.answer();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcout << (v[i] ? a[i].first : a[i].second) << endl;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct StronglyConnectedComponents{\n    vector<vector<int>> G,rG,C,T;\n    vector<int> vs,cmp,used;\n    StronglyConnectedComponents(int n):G(n),rG(n),cmp(n),used(n){}\n    void add_edge(int u,int v){\n        G[u].emplace_back(v);\n        rG[v].emplace_back(u);\n    }\n    void dfs(int v){\n        used[v]=1;\n        for (int u:G[v]) if(!used[u]) dfs(u);\n        vs.emplace_back(v);\n    }\n    void rdfs(int v,int k){\n        used[v]=1;\n        cmp[v]=k;\n        C[k].emplace_back(v);\n        for (int u:rG[v]) if (!used[u]) rdfs(u,k);\n    }\n    int build(){\n        int n=G.size();\n        for (int i=0;i<n;++i) if (!used[i]) dfs(i);\n        fill(used.begin(),used.end(),0);\n        int k=0;\n        for (int i=n-1;i>=0;--i){\n            if (!used[vs[i]]){\n                C.emplace_back(),T.emplace_back();\n                rdfs(vs[i],k++);\n            }\n        }\n        for (int v=0;v<n;++v) for (int u:G[v]){\n            if (cmp[v]!=cmp[u]) T[cmp[v]].emplace_back(cmp[u]);\n        }\n        for (int i=0;i<k;++i){\n            sort(T[i].begin(),T[i].end());\n            T[i].erase(unique(T[i].begin(),T[i].end()),T[i].end());\n        }\n        return k;\n    }\n    int operator[](int i) const{\n        return cmp[i];\n    }\n};\n\nstruct TwoSatisfiability{\n    int n;\n    StronglyConnectedComponents SCC;\n    TwoSatisfiability(int n):n(n),SCC(n*2){}\n    int neg(int v){return (n+v)%(n*2);}\n    void add_if(int u,int v){\n        SCC.add_edge(u,v);\n        SCC.add_edge(neg(v),neg(u));\n    }\n    void add_or(int u,int v){\n        add_if(neg(u),v);\n    }\n    void add_nand(int u,int v){\n        add_if(u,neg(v));\n    }\n    void set_true(int v){\n        SCC.add_edge(neg(v),v);\n    }\n    void set_false(int v){\n        SCC.add_edge(v,neg(v));\n    }\n    vector<int> build(){\n        SCC.build();\n        vector<int> res(n);\n        for (int i=0;i<n;++i){\n            if (SCC[i]==SCC[n+i]) return {};\n            res[i]=SCC[i]>SCC[n+i];\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,D; cin >> N >> D;\n    vector<int> X(N),Y(N);\n    for (int i=0;i<N;++i) cin >> X[i] >> Y[i];\n    TwoSatisfiability TS(2*N);\n    for (int i=0;i<2*N;i+=2){\n        TS.add_or(i,i+1);\n        TS.add_nand(i,i+1);\n    }\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            if (abs(X[i]-X[j])<D) TS.add_nand(i<<1|0,j<<1|0);\n            if (abs(X[i]-Y[j])<D) TS.add_nand(i<<1|0,j<<1|1);\n            if (abs(Y[i]-X[j])<D) TS.add_nand(i<<1|1,j<<1|0);\n            if (abs(Y[i]-Y[j])<D) TS.add_nand(i<<1|1,j<<1|1);\n        }\n    }\n\n    vector<int> ans=TS.build();\n    if (ans.empty()){cout << \"No\" << '\\n'; return 0;}\n    cout << \"Yes\" << '\\n';\n    for (int i=0;i<N;++i){\n        cout << (ans[i<<1|0]?X[i]:Y[i]) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* #region header */\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n#ifdef LOCAL\n#include \"cxx-prettyprint-master/prettyprint.hpp\"\nvoid debug() { cout << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug(Head H, Tail... T) {\n    cout << \" \" << H;\n    debug(T...);\n}\n#else\n#define debug(...) 42\n#endif\n// types\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntypedef pair<ll, ll> Pl;\ntypedef pair<int, int> Pi;\ntypedef vector<ll> vl;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntemplate <typename T>\nusing mat = vector<vector<T>>;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<long long>> vvl;\ntypedef vector<vector<char>> vvc;\n\n// abreviations\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define rep_(i, a_, b_, a, b, ...) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define rep(i, ...) rep_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define rrep_(i, a_, b_, a, b, ...) \\\n    for (ll i = (b - 1), min_i = (a); i >= min_i; i--)\n#define rrep(i, ...) rrep_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define SZ(x) ((ll)(x).size())\n#define pb(x) push_back(x)\n#define eb(x) emplace_back(x)\n#define mp make_pair\n#define print(x) cout << x << endl\n#define vprint(x)                         \\\n    rep(i, x.size()) cout << x[i] << ' '; \\\n    cout << endl\n#define vsum(x) accumulate(all(x), 0LL)\n#define vmax(a) *max_element(all(a))\n#define vmin(a) *min_element(all(a))\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n// functions\n// gcd(0, x) fails.\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <typename T>\nT mypow(T x, ll n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) (ret *= x);\n        (x *= x);\n        n >>= 1;\n    }\n    return ret;\n}\nll modpow(ll x, ll n, const ll mod) {\n    ll ret = 1;\n    while (n > 0) {\n        if (n & 1) (ret *= x);\n        (x *= x);\n        n >>= 1;\n        x %= mod;\n        ret %= mod;\n    }\n    return ret;\n}\nuint64_t my_rand(void) {\n    static uint64_t x = 88172645463325252ULL;\n    x = x ^ (x << 13);\n    x = x ^ (x >> 7);\n    return x = x ^ (x << 17);\n}\nll popcnt(ull x) { return __builtin_popcountll(x); }\n// graph template\ntemplate <typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    bool operator<(const edge<T> &r) const { return cost < r.cost; }\n\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\nstruct Timer {\n    clock_t start_time;\n    void start() { start_time = clock(); }\n    int lap() {\n        // return x ms.\n        return (clock() - start_time) * 1000 / CLOCKS_PER_SEC;\n    }\n};\n/* #endregion*/\n// constant\n#define inf 1000000005\n#define INF 4000000004000000000LL\n#define mod 1000000007LL\n#define endl '\\n'\nconst long double eps = 0.000001;\nconst long double PI = 3.141592653589793;\n// library\nconst vector<bool> flag = {false, true};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << setprecision(20);\n    ll n, d;\n    cin >> n >> d;\n    vl x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    mat<ll> z = {x, y};\n    two_sat ts(n);\n    rep(i, n) {\n        rep(j, i + 1, n) {\n            rep(pi, 2) {\n                rep(pj, 2) {\n                    if (abs(z[pi][i] - z[pj][j]) < d) {\n                        ts.add_clause(i, flag[pi], j, flag[pj]);\n                    }\n                }\n            }\n        }\n    }\n    bool ans = ts.satisfiable();\n    if (ans) {\n        print(\"Yes\");\n        auto res = ts.answer();\n        rep(i, n) {\n            if (res[i])\n                print(x[i]);\n            else\n                print(y[i]);\n        }\n    } else {\n        print(\"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef tuple<ll, ll, ll> tl3;\n\ntypedef modint998244353 mint;\n\nconst int BIG_NUM = 1e9;\nconst ll INF = 1000000000000000000;\n//const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\n\nconst ll MAX = 1e9 + 5;\n\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\ttwo_sat ts(n);\n\tvector<int> x(n);\n\tvector<int> y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ts.satisfiable()) {\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\n\tcout << \"Yes\" << endl;\n\tauto ans = ts.answer();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ans[i]) {\n\t\t\tcout << x[i] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << y[i] << endl;\n\t\t}\n\t}\n\t\t \n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incII(i, l, r) for(LL i = (l)    ; i <= (r); i++)\n#define incIX(i, l, r) for(LL i = (l)    ; i <  (r); i++)\n#define incXI(i, l, r) for(LL i = (l) + 1; i <= (r); i++)\n#define incXX(i, l, r) for(LL i = (l) + 1; i <  (r); i++)\n#define decII(i, l, r) for(LL i = (r)    ; i >= (l); i--)\n#define decIX(i, l, r) for(LL i = (r) - 1; i >= (l); i--)\n#define decXI(i, l, r) for(LL i = (r)    ; i >  (l); i--)\n#define decXX(i, l, r) for(LL i = (r) - 1; i >  (l); i--)\n#define inc(i, n)  incIX(i, 0, n)\n#define dec(i, n)  decIX(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\nauto inII = [](auto x, auto l, auto r) { return (l <= x && x <= r); };\nauto inIX = [](auto x, auto l, auto r) { return (l <= x && x <  r); };\nauto inXI = [](auto x, auto l, auto r) { return (l <  x && x <= r); };\nauto inXX = [](auto x, auto l, auto r) { return (l <  x && x <  r); };\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define RV(c) reverse(ALL(c))\n#define SC static_cast\n#define SI(c) SC<int>(c.size())\n#define SL(c) SC<LL >(c.size())\n#define RF(e, c) for(auto & e: c)\n#define SF(c, ...) for(auto & [__VA_ARGS__]: c)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\nauto * IS = & cin;\nauto * OS = & cout;\narray<string, 3> SEQ = { \"\", \" \", \"\" };\n// input elements (as a tuple)\ntemplate<typename U, int I> void in_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void in_(U & t) { (* IS) >> get<I>(t); in_<U, I + 1, B ...>(t); }\ntemplate<typename ... T> auto in() { tuple<T ...> t; in_<tuple<T ...>, 0, T ...>(t); return t; }\n// input an array\ntemplate<typename T, int N> auto ain() { array<T, N> a; inc(i, N) { (* IS) >> a[i]; } return a; }\n// input a (multi-dimensional) vector\ntemplate<typename T> T vin() { T v; (* IS) >> v; return v; }\ntemplate<typename T, typename N, typename ... M> auto vin(N n, M ... m) {\n\tvector<decltype(vin<T, M ...>(m ...))> v(n); inc(i, n) { v[i] = vin<T, M ...>(m ...); } return v;\n}\n// input multi-column (as a tuple of vector)\ntemplate<typename U, int I> void colin_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void colin_(U & t) {\n\tA a; (* IS) >> a; get<I>(t).push_back(a); colin_<U, I + 1, B ...>(t);\n}\ntemplate<typename ... T> auto colin(int n) {\n\ttuple<vector<T> ...> t; inc(i, n) { colin_<tuple<vector<T> ...>, 0, T ...>(t); } return t;\n}\n// output elements\nvoid out_([[maybe_unused]] string s) { }\ntemplate<typename A> void out_([[maybe_unused]] string s, A && a) { (* OS) << a; }\ntemplate<typename A, typename ... B> void out_(string s, A && a, B && ... b) { (* OS) << a << s; out_(s, b ...); }\nauto outF = [](auto x, auto y, auto z, auto ... a) { (* OS) << x; out_(y, a ...); (* OS) << z << flush; };\nauto out  = [](auto ... a) { outF(\"\", \" \" , \"\\n\", a ...); };\nauto outS = [](auto ... a) { outF(\"\", \" \" , \" \" , a ...); };\nauto outL = [](auto ... a) { outF(\"\", \"\\n\", \"\\n\", a ...); };\nauto outN = [](auto ... a) { outF(\"\", \"\"  , \"\"  , a ...); };\n// output a (multi-dimensional) vector\ntemplate<typename T> ostream & operator<<(ostream & os, vector<T> const & v) {\n\tos << SEQ[0]; inc(i, SI(v)) { os << (i == 0 ? \"\" : SEQ[1]) << v[i]; } return (os << SEQ[2]);\n}\ntemplate<typename T> void vout_(T && v) { (* OS) << v; }\ntemplate<typename T, typename A, typename ... B> void vout_(T && v, A a, B ... b) {\n\tinc(i, SI(v)) { (* OS) << (i == 0 ? \"\" : a); vout_(v[i], b ...); }\n}\ntemplate<typename T, typename A, typename ... B> void vout(T && v, A a, B ... b) {\n\tvout_(v, b ...); (* OS) << a << flush;\n}\n\n// ---- ----\n\n#include <atcoder/all>\nusing namespace atcoder;\n\nint main() {\n\tauto [n, d] = ain<int, 2>();\n\tauto v = vin<int>(n, 2);\n\ttwo_sat ts(n);\n\tinc(i, n) {\n\tinc(j, i) {\n\t\tinc(ii, 2) { bool I = ii;\n\t\tinc(jj, 2) { bool J = jj;\n\t\t\tif(abs(v[i][ii] - v[j][jj]) < d) { ts.add_clause(i, ! I, j, ! J); }\n\t\t}\n\t\t}\n\t}\n\t}\n\tauto ok = ts.satisfiable();\n\tout(ok ? \"Yes\" : \"No\");\n\tif(ok) {\n\t\tauto ans = ts.answer();\n\t\tinc(i, n) { out(v[i][ans[i] ? 1 : 0]); }\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/* #region Head */\n\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pll = pair<ll, ll>;\ntemplate <class T> using vc = vector<T>;\ntemplate <class T> using vvc = vc<vc<T>>;\nusing vll = vc<ll>;\nusing vvll = vvc<ll>;\nusing vld = vc<ld>;\nusing vvld = vvc<ld>;\nusing vs = vc<string>;\nusing vvs = vvc<string>;\ntemplate <class T, class U> using um = unordered_map<T, U>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqa = priority_queue<T, vc<T>, greater<T>>;\ntemplate <class T> using us = unordered_set<T>;\n\n#define REP(i, m, n) for (ll i = (m), i##_len = (ll)(n); i < i##_len; ++(i))\n#define REPM(i, m, n) for (ll i = (m), i##_max = (ll)(n); i <= i##_max; ++(i))\n#define REPR(i, m, n) for (ll i = (m), i##_min = (ll)(n); i >= i##_min; --(i))\n#define REPD(i, m, n, d) for (ll i = (m), i##_len = (ll)(n); i < i##_len; i += (d))\n#define REPMD(i, m, n, d) for (ll i = (m), i##_max = (ll)(n); i <= i##_max; i += (d))\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define ALL(x) begin(x), end(x)\n#define SIZE(x) ((ll)(x).size())\n#define PERM(c)                                                                                                        \\\n    sort(ALL(c));                                                                                                      \\\n    for (bool c##p = 1; c##p; c##p = next_permutation(ALL(c)))\n#define UNIQ(v) v.erase(unique(ALL(v)), v.end());\n\n#define endl '\\n'\n#define sqrt sqrtl\n#define floor floorl\n#define log2 log2l\n\nconstexpr ll INF = 1'010'000'000'000'000'017LL;\nconstexpr int IINF = 1'000'000'007LL;\nconstexpr ll MOD = 1'000'000'007LL; // 1e9 + 7\n// constexpr ll MOD = 998244353;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.14159265358979323846;\n\ntemplate <typename T> istream &operator>>(istream &is, vc<T> &vec) { // vector 入力\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T> ostream &operator<<(ostream &os, vc<T> &vec) { // vector 出力 (for dump)\n    os << \"{\";\n    REP(i, 0, SIZE(vec)) os << vec[i] << (i == i_len - 1 ? \"\" : \", \");\n    os << \"}\";\n    return os;\n}\ntemplate <typename T> ostream &operator>>(ostream &os, vc<T> &vec) { // vector 出力 (inline)\n    REP(i, 0, SIZE(vec)) os << vec[i] << (i == i_len - 1 ? \"\\n\" : \" \");\n    return os;\n}\n\ntemplate <typename T, typename U> istream &operator>>(istream &is, pair<T, U> &pair_var) { // pair 入力\n    is >> pair_var.first >> pair_var.second;\n    return is;\n}\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, pair<T, U> &pair_var) { // pair 出力\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// map, um, set, us 出力\ntemplate <class T> ostream &out_iter(ostream &os, T &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        auto itrcp = itr;\n        if (++itrcp != map_var.end()) os << \", \";\n    }\n    return os << \"}\";\n}\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &map_var) { return out_iter(os, map_var); }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, um<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        auto [key, value] = *itr;\n        os << \"(\" << key << \", \" << value << \")\";\n        auto itrcp = itr;\n        if (++itrcp != map_var.end()) os << \", \";\n    }\n    os << \"}\";\n    return os;\n}\ntemplate <typename T> ostream &operator<<(ostream &os, set<T> &set_var) { return out_iter(os, set_var); }\ntemplate <typename T> ostream &operator<<(ostream &os, us<T> &set_var) { return out_iter(os, set_var); }\ntemplate <typename T> ostream &operator<<(ostream &os, pq<T> &pq_var) {\n    pq<T> pq_cp(pq_var);\n    os << \"{\";\n    if (!pq_cp.empty()) {\n        os << pq_cp.top(), pq_cp.pop();\n        while (!pq_cp.empty()) os << \", \" << pq_cp.top(), pq_cp.pop();\n    }\n    return os << \"}\";\n}\n\n// dump\n#define DUMPOUT cerr\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(move(tail)...);\n}\n\n// chmax (更新「される」かもしれない値が前)\ntemplate <typename T, typename U, typename Comp = less<>> bool chmax(T &xmax, const U &x, Comp comp = {}) {\n    if (comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\n// chmin (更新「される」かもしれない値が前)\ntemplate <typename T, typename U, typename Comp = less<>> bool chmin(T &xmin, const U &x, Comp comp = {}) {\n    if (comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n// ローカル用\n#define DEBUG_\n\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                                                                      \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                                                                    \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" << endl                                        \\\n            << \"    \",                                                                                                 \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n#define VAR(type, ...)                                                                                                 \\\n    type __VA_ARGS__;                                                                                                  \\\n    cin >> __VA_ARGS__;\n\ntemplate <typename T> istream &operator,(istream &is, T &rhs) { return is >> rhs; }\ntemplate <typename T> ostream &operator,(ostream &os, const T &rhs) { return os << ' ' << rhs; }\n\nstruct AtCoderInitialize {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n    AtCoderInitialize() {\n        ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n        cout << fixed << setprecision(IOS_PREC);\n        if (AUTOFLUSH) cout << unitbuf;\n    }\n} ATCODER_INITIALIZE;\n\nvoid Yn(bool p) { cout << (p ? \"Yes\" : \"No\") << endl; }\nvoid YN(bool p) { cout << (p ? \"YES\" : \"NO\") << endl; }\n\n/* #endregion */\n\n/* #region Graph */\n\n// エッジ（本来エッジは双方向だが，ここでは単方向で管理）\ntemplate <class weight_t = int, class flow_t = int> struct Edge {\n    ll src;          // エッジ始点となる頂点\n    ll dst;          // エッジ終点となる頂点\n    weight_t weight; // 重み\n    flow_t cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(ll src, ll dst, weight_t weight) : src(src), dst(dst), weight(weight) {}\n    Edge(ll src, ll dst, weight_t weight, flow_t cap) : src(src), dst(dst), weight(weight), cap(cap) {}\n    // Edge 標準出力\n    friend ostream &operator<<(ostream &os, Edge &edge) {\n        os << \"(\" << edge.src << \" -> \" << edge.dst << \", \" << edge.weight << \")\";\n        return os;\n    }\n};\n// 同じ頂点を始点とするエッジ集合\ntemplate <class weight_t = int, class flow_t = int> class Node : public vc<Edge<weight_t, flow_t>> {\n  public:\n    ll idx;\n    Node() : vc<Edge<weight_t, flow_t>>() {}\n    // void add(int a, int b, weight_t w, flow_t cap) { this->emplace_back(a, b, w, cap); };\n};\n// graph[i] := 頂点 i を始点とするエッジ集合\ntemplate <class weight_t = int, class flow_t = int> class Graph : public vc<Node<weight_t, flow_t>> {\n  public:\n    Graph() : vc<Node<weight_t, flow_t>>() {}\n    Graph(int n) : vc<Node<weight_t, flow_t>>(n) { REP(i, 0, n)(*this)[i].idx = i; }\n    // 単方向\n    void add_arc(int a, int b, weight_t w = 1, flow_t cap = 1) { (*this)[a].emplace_back(a, b, w, cap); }\n    // 双方向\n    void add_edge(int a, int b, weight_t w = 1, flow_t cap = 1) { add_arc(a, b, w, cap), add_arc(b, a, w, cap); }\n};\n// using Array = vc<Weight>;\n// using Matrix = vc<Array>;\n\n/* #endregion */\n\n/* #region scc */\n\n// 強連結成分分解\ntemplate <class weight_t, class flow_t> vll scc(const Graph<weight_t, flow_t> &g) {\n    ll n = SIZE(g);                // ノード数\n    Graph<weight_t, flow_t> rg(n); // 逆向きのグラフ\n    for (const Node<weight_t, flow_t> &es : g)\n        for (Edge<weight_t, flow_t> e : es) {\n            swap(e.src, e.dst);\n            rg[e.src].emplace_back(e);\n        }\n\n    vll order;\n    order.reserve(n);\n\n    { // dfs 1回目\n        vc<bool> visited(n), added(n);\n        REP(i, 0, n) {\n            if (visited[i]) continue;\n            stack<ll> stk;\n            stk.push(i);\n            while (!stk.empty()) {\n                ll cur = stk.top();\n                visited[cur] = true;\n                bool pushed = false;\n                for (const Edge<weight_t, flow_t> &e : g[cur])\n                    if (!visited[e.dst]) stk.push(e.dst), pushed = true;\n                if (!pushed) { // カレントノードからは未訪問ノードへ到達できない\n                    ll t = stk.top();\n                    stk.pop(); // 未訪問ノードへ到達できないノードは除いていく\n                    if (!added[t]) added[t] = true, order.push_back(t);\n                }\n            }\n        }\n        reverse(ALL(order));\n    }\n\n    vll ret(n, -1);\n    { // dfs 2回目\n        ll groupnum = 0;\n        for (ll &v : order) {\n            if (ret[v] != -1) continue;\n            stack<ll> stk;\n            stk.push(v);\n            while (!stk.empty()) {\n                ll cur = stk.top();\n                stk.pop(), ret[cur] = groupnum;\n                for (Edge<weight_t, flow_t> &e : rg[cur])\n                    if (ret[e.dst] == -1) stk.push(e.dst);\n            }\n            ++groupnum;\n        }\n    }\n    return ret;\n}\n\n/* #endregion */\n\n/* #region TwoSat */\n\n// 2-SAT\nstruct TwoSat {\n    using G = Graph<int, int>;\n    int _var_cnt;   // 命題論理式に含まれる変数の個数\n    int _sz;        // グラフのサイズ\n    G graph;        // graph[i] <-> not(graph[i+_var_cnt])\n    vc<int> result; // 結果格納用，外からアクセスする前提\n    // var_cnt: 変数の個数，P と ¬P あわせて1個．\n    TwoSat(int var_cnt) : _var_cnt(var_cnt), _sz(var_cnt * 2), graph(_sz), result(var_cnt) {}\n    // (x ∨ y) の形の節を追加する．¬x は x+_var_cnt に変えておく．\n    void add_arcs(int x, int y) {\n        graph.add_arc((x + _var_cnt) % _sz, y); // ¬x -> y\n        graph.add_arc((y + _var_cnt) % _sz, x); // ¬y -> x\n    }\n    // 充足可能性を判定する．不能なら false. 可能なら result に変数の T/F を入れる．\n    bool sat() {\n        vll groups = scc(graph);\n        // dump(groups);\n        REP(i, 0, _var_cnt) if (groups[i] == groups[i + _var_cnt]) return false;\n        REP(i, 0, _var_cnt) result[i] = groups[i] > groups[i + _var_cnt];\n        return true;\n    }\n};\n\n/* #endregion */\n\n// Problem\nvoid solve() {\n    VAR(ll, n, d); //\n    vll x(n), y(n);\n    REP(i, 0, n) cin >> x[i] >> y[i];\n\n    // 相異なる旗のペア (i, j) すべてに対して\n    // 距離が d 以上でないような組み合わせは除外する\n    TwoSat ts(n); // true := x のほうを使う, false := y のほうを使う\n    auto inv = [&n](int p) { return (n + p) % (2 * n); };\n    REP(i, 0, n - 1) REP(j, i + 1, n) {\n        if (abs(x[i] - x[j]) < d) { // どっちとも x というパターンは無理 = 片方は y である必要がある\n            ts.add_arcs(inv(i), inv(j)); // ¬A ∨ ¬B\n        }\n        if (abs(x[i] - y[j]) < d) { // (i,j)->(x,y), というパターンは無理 = (i->y または j->x) である必要がある\n            ts.add_arcs(inv(i), j);\n        }\n        if (abs(y[i] - x[j]) < d) { // (i,j)->(y,x), というパターンは無理 = (i->x または j->y) である必要がある\n            ts.add_arcs(i, inv(j));\n        }\n        if (abs(y[i] - y[j]) < d) { // どっちとも y というパターンは無理 = 片方は x である必要がある\n            ts.add_arcs(i, j);\n        }\n    }\n\n    if (ts.sat()) {\n        Yn(true);\n        // dump(ts.result);\n        REP(i, 0, n) { cout << (ts.result[i] ? x[i] : y[i]) << endl; }\n    } else {\n        Yn(false);\n    }\n}\n\n// entry point\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <atcoder/all>\nusing namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nint main() {\n    ll N,D; cin >> N >> D;\n    vector<ll> X(N),Y(N);\n    rep(i,N) cin >> X[i] >> Y[i];\n\n    two_sat TS(N);\n    rep(i,N) {\n        rep(j,i) {\n            if (abs(X[i]-X[j]) < D) {\n                TS.add_clause(i,0,j,0);\n            }\n            if (abs(X[i]-Y[j]) < D) {\n                TS.add_clause(i,0,j,1);\n            }\n            if (abs(Y[i]-X[j]) < D) {\n                TS.add_clause(i,1,j,0);\n            }\n            if (abs(Y[i]-Y[j]) < D) {\n                TS.add_clause(i,1,j,1);\n            }\n        }\n    }\n\n    if (TS.satisfiable()) {\n        cout << \"Yes\" << ln;\n        auto x = TS.answer();\n        rep(i,N) cout << (x[i] ? X[i] : Y[i]) << ln;\n    } else {\n        cout << \"No\" << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\nnamespace Ruby {\n\ttemplate <class F> struct Callable {\n\t\tF func;\n\t\tCallable(const F& f) : func(f) {}\n\t};\n\ttemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\t\treturn c.func(v);\n\t}\n\n\tstruct Sort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(begin(v), end(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Sort;\n\tstruct RSort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\t\tsort(rbegin(v), rend(v));\n\t\t\treturn v;\n\t\t}\n\t} RSort;\n\tstruct Reverse_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\t\treverse(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Reverse;\n\tstruct Unique_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Unique;\n\tstruct Uniq_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Uniq;\n\tstruct Rotate_impl {\n\t\ttemplate <class F> auto operator()(int left) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} Rotate;\n\tstruct Max_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\t\treturn *max_element(begin(v), end(v));\n\t\t}\n\t} Max;\n\tstruct Min_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\t\treturn *min_element(begin(v), end(v));\n\t\t}\n\t} Min;\n\tstruct MaxPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MaxPos;\n\tstruct MinPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MinPos;\n\tstruct MaxBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_it = begin(v);\n\t\t\t\tauto max_val = f(*max_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_it = it;\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *max_it;\n\t\t\t});\n\t\t}\n\t} MaxBy;\n\tstruct MinBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_it = begin(v);\n\t\t\t\tauto min_val = f(*min_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_it = it;\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *min_it;\n\t\t\t});\n\t\t}\n\t} MinBy;\n\tstruct MaxOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max_val;\n\t\t\t});\n\t\t}\n\t} MaxOf;\n\tstruct MinOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn min_val;\n\t\t\t});\n\t\t}\n\t} MinOf;\n\tstruct Count_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count(begin(v), end(v), val);\n\t\t\t});\n\t\t}\n\t} Count;\n\tstruct CountIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count_if(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t} CountIf;\n\tstruct Index_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} Index;\n\tstruct IndexIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} IndexIf;\n\tstruct FindIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t\t});\n\t\t}\n\t} FindIf;\n\tstruct Sum_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\t\treturn a + f(b);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t\t}\n\t} Sum;\n\tstruct Includes {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t\t});\n\t\t}\n\t} Includes;\n\tstruct IncludesIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t\t});\n\t\t}\n\t} IncludesIf;\n\tstruct RemoveIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} RemoveIf;\n\tstruct Each_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tf(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} Each;\n\tstruct Select_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\t\tvector<value_type> res;\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Select;\n\tstruct Map_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\t\tvector<result_type> res;\n\t\t\t\tres.reserve(size(v));\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tres.push_back(f(i));\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Map;\n\tstruct Indexed_impl {\n\t\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\t\tusing value_type = typename T::value_type;\n\t\t\tvector<pair<value_type, int>> res;\n\t\t\tres.reserve(size(v));\n\t\t\tint index = 0;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.emplace_back(i, index++);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} Indexed;\n\tstruct AllOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (!f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} AllOf;\n\tstruct AnyOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t} AnyOf;\n\tstruct NoneOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} NoneOf;\n};  // namespace Ruby\nusing namespace Ruby;\n\n// --- functions --- //\nnamespace Functions {\n\ttemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i) res += s;\n\t\treturn res;\n\t}\n\ttemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2));\n\t\treturn v;\n\t}\n\ttemplate <class T> inline T Ceil(T n, T m) {\n\t\treturn (n + m - 1) / m;\n\t}\n\ttemplate <class T> inline T Ceil2(T n, T m) {\n\t\treturn Ceil(n, m) * m;\n\t}\n\ttemplate <class T> inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate <class T> inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate <class T> inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\ttemplate <class T> inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate <class T> inline bool isSquere(T n) {\n\t\tT s = sqrt(n);\n\t\treturn s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate <class T = long long> inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n\t}\n\ttemplate <class T> inline T Pow(T a, T n) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) r *= a;\n\t\t\ta *= a;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1)\n\t\t\t\tr = r * a % m, n--;\n\t\t\telse\n\t\t\t\ta = a * a % m, n /= 2;\n\t\t}\n\t\treturn r;\n\t}\n}  // namespace Functions\nusing namespace Functions;\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\n#include <atcoder/all>\nint main() {\n\tini(n, d);\n\tatcoder::two_sat t(n);\n\tauto [x, y] = in.multiple<int, int>(n);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, false, j, false);\n\t\t}\n\t}\n\tif (t.satisfiable()) {\n\t\tout(true);\n\t\tauto ans = t.answer();\n\t\trep(i, n) out(ans[i] ? y[i] : x[i]);\n\t} else {\n\t\tout(false);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr double EPS = 1e-8;\nconstexpr int MOD = 1000000007;\n// constexpr int MOD = 998244353;\nconstexpr int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconstexpr int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\n#include <atcoder/twosat>\nusing namespace atcoder;\n\nint main() {\n  int n, d; cin >> n >> d;\n  vector<int> x(n), y(n); REP(i, n) cin >> x[i] >> y[i];\n  two_sat ts(n);\n  REP(i, n) FOR(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n    if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n    if (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n    if (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n  }\n  if (!ts.satisfiable()) {\n    cout << \"No\\n\";\n    return 0;\n  }\n  cout << \"Yes\\n\";\n  vector<bool> ans = ts.answer();\n  REP(i, n) cout << (ans[i] ? x[i] : y[i]) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define INF_LL 1000000000000000000LL\n#define INF 200000000\n#define MOD 998244353\n#define ll long long\n#define all(x) x.begin(), x.end()\n#define REP(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, n) REP(i, 0, n)\n// typedef float double;\n// typedef priority_queue prique;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<ll> vl;\ntypedef vector<vi> matrix;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint sign[2] = {1, -1};\ntemplate <class T> bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nll modpow(ll a, ll b, ll m) {\n    if(b == 0)\n        return 1;\n    ll t = modpow(a, b / 2, m);\n    if(b & 1) {\n        return (t * t % m) * a % m;\n    } else {\n        return t * t % m;\n    }\n}\n\nstruct edge {\n    int to;\n    ll cost;\n    edge(int t, ll c) { to = t, cost = c; }\n};\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<P> x(n);\n    rep(i, n) cin >> x[i].first >> x[i].second;\n    two_sat ts(n);\n    rep(i, n) REP(j, i + 1, n) {\n        if(abs(x[i].first - x[j].first) < d)\n            ts.add_clause(i, false, j, false);\n        if(abs(x[i].first - x[j].second) < d)\n            ts.add_clause(i, false, j, true);\n        if(abs(x[i].second - x[j].first) < d)\n            ts.add_clause(i, true, j, false);\n        if(abs(x[i].second - x[j].second) < d)\n            ts.add_clause(i, true, j, true);\n    }\n    if(ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        vector<bool> ans = ts.answer();\n        rep(i, n) {\n            if(ans[i]) {\n                cout << x[i].first << endl;\n            } else {\n                cout << x[i].second << endl;\n            }\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sun Sep 20 19:35:42 JST 2020\n **/\n\n\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n\nsigned main() {\n    Int n, D;\n    std::cin >> n >> D;\n    std::vector<Int> X(n), Y(n);\n    REP(i, n) std::cin >> X[i] >> Y[i];\n    atcoder::two_sat ts(n);\n    REP(i, n) {\n        REP(j, i) {\n            if (std::abs(X[i] - X[j]) < D) ts.add_clause(i, true, j, true);\n            if (std::abs(X[i] - Y[j]) < D) ts.add_clause(i, true, j, false);\n            if (std::abs(Y[i] - X[j]) < D) ts.add_clause(i, false, j, true);\n            if (std::abs(Y[i] - Y[j]) < D) ts.add_clause(i, false, j, false);\n        }\n    }\n    if (ts.satisfiable()) {\n        std::cout << \"Yes\\n\";\n        auto res = ts.answer();\n        REP(i, n) std::cout << (res[i] ? Y : X)[i] << \"\\n\";\n    } else {\n        std::cout << \"No\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <numeric>\n#include <functional>\n#include <atcoder/all>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define rrep(i,a) for(ll i=ll(a-1);i>=0;--i)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline void Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\",k = \" \";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+k;\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nll gcd(ll a, ll b) {\n    return a ? gcd(b%a,a) : b;\n}\n\nconst int INF = 1e9;\nconst ll MOD = 1000000007;\nconst ll MOD2 = 998244353;\nconst ll MOD3 = 1e6;\nconst ll EPS = 1e-10;\nint sgn(const double a){\n    return (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n}\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> tri;\ntypedef pair<long double,long double> point;\ntypedef complex<long double> Point;\nconst ll MAX = 1e9;\nconstexpr ll nx[4] = {-1,0,1,0};\nconstexpr ll ny[4] = {0,1,0,-1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,d;\n    cin >> n >> d;\n    vector<ll> x(n),y(n);\n    rep(i,n) cin >> x[i] >> y[i];\n    two_sat g(n);\n    rep(i,n-1){\n        rep(j,i+1,n){\n            if (abs(x[i]-x[j]) < d) g.add_clause(i,0,j,0);\n            if (abs(x[i]-y[j]) < d) g.add_clause(i,0,j,1);\n            if (abs(y[i]-x[j]) < d) g.add_clause(i,1,j,0);\n            if (abs(y[i]-y[j]) < d) g.add_clause(i,1,j,1);\n        }\n    }\n    bool f = g.satisfiable();\n    if (f){\n        auto ans = g.answer();\n        vector<ll> a(n);\n        rep(i,n){\n            if (ans[i]) a[i] = x[i];\n            else a[i] = y[i]; \n        }\n        PRINT(\"Yes\");\n        rep(i,n) PRINT(a[i]);\n    }\n    else{\n        PRINT(\"No\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << endl\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, d;\n    cin >> n >> d;\n    vector<P> v(n);\n    rep(i, n) cin >> v[i].first >> v[i].second;\n    two_sat g(n);\n    rep(i, n) rep(j, i) {\n        rep(ii, 2) {\n            rep(jj, 2) {\n                if (abs(v[i].first-v[j].first)<d) {\n                    g.add_clause(i, ii==1, j, jj==1);\n                }\n                swap(v[j].first, v[j].second);\n            }\n            swap(v[i].first, v[i].second);\n        }\n    }\n    bool ok = g.satisfiable();\n    if (!ok) {\n        pr(\"No\");\n        return 0;\n    }\n    pr(\"Yes\");\n    auto ans = g.answer();\n\n    rep(i, n) {\n        if (ans[i]) pr(v[i].first);\n        else pr(v[i].second);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n\nstruct strongly_connected_componects {\n  int n;\n  std::vector<std::vector<int>> G;\n  std::vector<int> id;\n  std::vector<int> low;\n  std::vector<int> num;\n  std::vector<int> st;\n  std::vector<bool> in_st;\n  int cnt;\n  int group;\n\n  strongly_connected_componects(int n):\n    n(n), G(n) {}\n\n  void add_edge(int a, int b) {\n    G[a].emplace_back(b);\n  }\n\n  void visit(int v) {\n    low[v] = num[v] = ++cnt;\n    st.emplace_back(v);\n    in_st[v] = true;\n\n    for(auto t: G[v]) {\n      if(num[t] == 0) {\n        visit(t);\n        low[v] = std::min(low[v], low[t]);\n      }\n      else if(in_st[t]) {\n        low[v] = std::min(low[v], num[t]);\n      }\n    }\n\n    if(low[v] == num[v]) {\n      while(true) {\n        int t = st.back();\n        st.pop_back();\n        in_st[t] = false;\n        id[t] = group;\n        if(v == t) break;\n      }\n      group++;\n    }\n  }\n\n  // id... トポロジカル順\n  void build_scc() {\n    id.assign(n, -1);\n    low.assign(n, 0);\n    num.assign(n, 0);\n    st.reserve(n);\n    in_st.assign(n, false);\n    cnt = 0;\n    group = 0;\n    for(int i = 0;i < n;i++) {\n      if(num[i] == 0) {\n        visit(i);\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      id[i] = group - 1 - id[i];\n    }\n  }\n};\n\n#include <tuple>\n\nstruct two_sat {\n  int n;\n  strongly_connected_componects scc;\n  two_sat(int n): n(n), scc(n * 2) {}\n\n  // add ((x == x_is) or (y == y_is))\n  void add_closure(int x, bool x_is, int y, bool y_is) {\n    scc.add_edge(x + n * (x_is ? 0 : 1), y + n * (y_is ? 1 : 0));\n    scc.add_edge(y + n * (y_is ? 0 : 1), x + n * (x_is ? 1 : 0));\n  }\n\n  std::tuple<bool, std::vector<bool>> build_ans() {\n    scc.build_scc();\n    std::vector<bool> ans(n);\n    for(int i = 0;i < n;i++) {\n      if(scc.id[i] == scc.id[i + n]) { return { false, std::vector<bool>() }; }\n      ans[i] = scc.id[i] < scc.id[i + n];\n    }\n    return { true, std::move(ans) };\n  }\n};\n\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define STRINGIFY(n) #n\n#define TOSTRING(n) STRINGIFY(n)\n#define PREFIX \"#\" TOSTRING(__LINE__) \"| \"\n#define debug(x) \\\n{ \\\n  std::cout << PREFIX << #x << \" = \" << x << std::endl; \\\n}\n\nstd::ostream& output_indent(std::ostream& os, int ind) {\n  for(int i = 0; i < ind; i++) os << \" \";\n  return os;\n}\n\ntemplate<class S, class T> std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p);\ntemplate<class T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& v);\n\ntemplate<class S, class T> std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {\n  return (os << \"(\" << p.first << \", \" << p.second << \")\");\n}\ntemplate<class T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n  os << \"[\";\n  for(int i = 0;i < v.size();i++) os << v[i] << \", \";\n  return (os << \"]\");\n}\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) { return std::vector<T>(n, std::forward<T>(val)); }\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\ntemplate<class Cond> struct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  template<class T> bool operator()(T& a, const T& b) const { if(cond(a, b)) { a = b; return true; } return false; }\n};\ntemplate<class Cond> chain<Cond> make_chain(Cond cond) { return chain<Cond>(cond); }\n\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  int N, D;\n  cin >> N >> D;\n  vector<int> X(N);\n  vector<int> Y(N);\n  rep(i,0,N) {\n    cin >> X[i] >> Y[i];\n  }\n  two_sat sat(N);\n  rep(i,0,N) {\n    rep(j,i + 1,N) {\n      if(abs(X[i] - X[j]) < D) {\n        sat.add_closure(i, false, j, false);\n      }\n      if(abs(X[i] - Y[j]) < D) {\n        sat.add_closure(i, false, j, true);\n      }\n      if(abs(Y[i] - X[j]) < D) {\n        sat.add_closure(i, true, j, false);\n      }\n      if(abs(Y[i] - Y[j]) < D) {\n        sat.add_closure(i, true, j, true);\n      }\n    }\n  }\n  auto [sati, ans] = sat.build_ans();\n  if(sati) {\n    cout << \"Yes\\n\";\n    for(int i = 0; i < N;i++) {\n      if(ans[i]) {\n        cout << X[i] << '\\n';\n      }\n      else {\n        cout << Y[i] << '\\n';\n      }\n    }\n  }\n  else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #pragma GCC target(\"arch=skylake-avx512\")\n// export CPLUS_INCLUDE_PATH=\"/Users/shuzaei/Desktop/ac-library\"\n// /usr/bin/env python3 \"/Users/shuzaei/Desktop/ac-library/expander.py\"\n// /Users/shuzaei/Desktop/Solve.cpp\n#include <atcoder/all>\nusing namespace atcoder;\n\n#pragma region template\n\n// Define\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <class T> using pvector = vector<pair<T, T>>;\ntemplate <class T> using rpriority_queue = priority_queue<T, vector<T>, greater<T>>;\nconstexpr const ll dx[4] = {1, 0, -1, 0};\nconstexpr const ll dy[4] = {0, 1, 0, -1};\nconstexpr const ll MOD = 1e9 + 7;\nconstexpr const ll mod = 998244353;\nconstexpr const ll INF = 1LL << 60;\nconstexpr const ll inf = 1 << 30;\nconstexpr const char rt = '\\n';\nconstexpr const char sp = ' ';\n#define rt(i, n) (i == (ll)(n) -1 ? rt : sp)\n#define len(x) ((ll)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define ifn(x) if (not(x))\n#define elif else if\n#define elifn else ifn\n#define fi first\n#define se second\n#define uniq(x) (sort(all(x)), (x).erase(unique(all(x)), (x).end()))\n#define bis(x, y) ((ll)(lower_bound(all(x), y) - (x).begin()))\n\nusing graph = vector<vector<ll>>;\ntemplate <class T> using wgraph = vector<vector<pair<ll, T>>>;\nbool __DIRECTED__ = true;\nbool __ZERO_INDEXED__ = false;\nistream &operator>>(istream &is, graph &g) {\n    ll a, b;\n    is >> a >> b;\n    if (__ZERO_INDEXED__ == false) a--, b--;\n    g[a].pb(b);\n    if (__DIRECTED__ == false) g[b].pb(a);\n    return is;\n}\ntemplate <class T> istream &operator>>(istream &is, wgraph<T> &g) {\n    ll a, b;\n    T c;\n    is >> a >> b >> c;\n    if (__ZERO_INDEXED__ == false) a--, b--;\n    g[a].pb({b, c});\n    if (__DIRECTED__ == false) g[b].pb({a, c});\n    return is;\n}\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n// Debug\n#define debug(...)                                                                                 \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #__VA_ARGS__ << \" = \";                                         \\\n        for (auto &&__i : {__VA_ARGS__}) cerr << \"[\" << __i << \"] \";                               \\\n        cerr << rt;                                                                                \\\n    }\n\n#define dump(a, h, w)                                                                              \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #a << \" = [\" << rt;                                            \\\n        rep(__i, h) {                                                                              \\\n            rep(__j, w) {                                                                          \\\n                if (abs(a[__i][__j]) >= INF / 2 and a[__i][__j] <= -INF / 2) cerr << '-';          \\\n                if (abs(a[__i][__j]) >= INF / 2) cerr << \"∞\" << sp;                                \\\n                else                                                                               \\\n                    cerr << a[__i][__j] << sp;                                                     \\\n            }                                                                                      \\\n            cerr << rt;                                                                            \\\n        }                                                                                          \\\n        cerr << \"]\" << rt;                                                                         \\\n    }\n\n#define vdump(a, n)                                                                                \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #a << \" = [\";                                                  \\\n        rep(__i, n) {                                                                              \\\n            if (__i) cerr << sp;                                                                   \\\n            if (abs(a[__i]) >= INF / 2 and a[__i] <= -INF / 2) cerr << '-';                        \\\n            if (abs(a[__i]) >= INF / 2) cerr << \"∞\" << sp;                                         \\\n            else                                                                                   \\\n                cerr << a[__i];                                                                    \\\n        }                                                                                          \\\n        cerr << \"]\" << rt;                                                                         \\\n    }\n\n// Loop\n#define inc(i, a, n) for (ll i = (a), _##i = (n); i <= _##i; ++i)\n#define dec(i, a, n) for (ll i = (a), _##i = (n); i >= _##i; --i)\n#define rep(i, n) for (ll i = 0, _##i = (n); i < _##i; ++i)\n#define each(i, a) for (auto &&i : a)\n\n// Stream\n#define fout(n) cout << fixed << setprecision(n)\nstruct io {\n    io() { cin.tie(nullptr), ios::sync_with_stdio(false); }\n} io;\n\n// Speed\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n// Math\ninline constexpr ll gcd(const ll a, const ll b) { return b ? gcd(b, a % b) : a; }\ninline constexpr ll lcm(const ll a, const ll b) { return a / gcd(a, b) * b; }\n\ninline constexpr ll modulo(const ll n, const ll m = MOD) {\n    ll k = n % m;\n    return k + m * (k < 0);\n}\ninline constexpr ll chmod(ll &n, const ll m = MOD) {\n    n %= m;\n    return n += m * (n < 0);\n}\ninline constexpr ll mpow(ll a, ll n, const ll m = MOD) {\n    ll r = 1;\n    rep(i, 64) {\n        if (n & (1LL << i)) r *= a;\n        chmod(r, m);\n        a *= a;\n        chmod(a, m);\n    }\n    return r;\n}\ninline ll inv(const ll n, const ll m = MOD) {\n    ll a = n, b = m, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return modulo(x, m);\n}\n\n#pragma endregion\n\nstruct SCC {\n    ll num, new_num;\n    vector<vector<ll>> graph;\n    vector<vector<ll>> rgraph;\n    vector<vector<ll>> new_graph;\n    vector<ll> tp_index;\n    vector<ll> nodes;\n    vector<bool> used;\n\n    SCC(ll n) : num(n), graph(n), rgraph(n), tp_index(n), used(n) {}\n    void add_edge(ll from, ll to) {\n        graph[from].push_back(to);\n        rgraph[to].push_back(from);\n    }\n    void dfs(ll pos) {\n        used[pos] = true;\n        for (ll i : graph[pos])\n            if (not used[i]) dfs(i);\n        nodes.push_back(pos);\n    }\n    void rdfs(ll pos, ll k) {\n        used[pos] = true, tp_index[pos] = k;\n        for (ll i : rgraph[pos])\n            if (not used[i]) rdfs(i, k);\n    }\n\n    ll scc() {\n        fill(used.begin(), used.end(), false);\n        nodes.clear();\n        for (ll i = 0; i < num; i++)\n            if (not used[i]) dfs(i);\n        reverse(nodes.begin(), nodes.end());\n        fill(used.begin(), used.end(), false);\n        ll k = 0;\n        for (ll i : nodes)\n            if (not used[i]) rdfs(i, k++);\n        return new_num = k;\n    }\n\n    void new_add_edge(ll from, ll to) {\n        ll f = tp_index[from], t = tp_index[to];\n        if (f == t) return;\n        new_graph[f].push_back(t);\n    }\n    void build_new_graph() {\n        new_graph.resize(new_num);\n        for (ll i = 0; i < num; i++)\n            for (ll j : graph[i]) new_add_edge(i, j);\n        for (vector<ll> &g : new_graph) {\n            sort(g.begin(), g.end());\n            g.erase(unique(g.begin(), g.end()), g.end());\n        }\n    }\n};\nstruct SAT {\n    ll n;\n    SCC scc;\n    vector<bool> result;\n\n    SAT(ll n) : n(n), scc(2 * n), result(2 * n) {}\n    ll inverse(ll x) { return x >= n ? x - n : x + n; }\n    void addliteral(ll a, ll b, bool a_inv = false, bool b_inv = false) {\n        if (a_inv) a = inverse(a);\n        if (b_inv) b = inverse(b);\n        scc.add_edge(inverse(a), b);\n        scc.add_edge(inverse(b), a);\n    }\n    bool calc() {\n        scc.scc();\n        for (ll i = 0; i < n; i++) {\n            if (scc.tp_index[i] > scc.tp_index[n + i]) {\n                result[i] = true;\n                result[n + i] = false;\n            } else if (scc.tp_index[i] == scc.tp_index[n + i]) {\n                return false;\n            } else {\n                result[n + i] = true;\n                result[i] = false;\n            }\n        }\n        return true;\n    }\n    bool val(ll x) { return result[x]; }\n};\n\nsigned main() {\n    ll N, D;\n    cin >> N >> D;\n    ll X[N], Y[N];\n    SAT s(N);\n    rep(i, N) {\n        cin >> X[i] >> Y[i];\n        rep(j, i) {\n            if (abs(X[i] - X[j]) < D) s.addliteral(i, j, 1, 1);\n            if (abs(X[i] - Y[j]) < D) s.addliteral(i, j, 1, 0);\n            if (abs(Y[i] - X[j]) < D) s.addliteral(i, j, 0, 1);\n            if (abs(Y[i] - Y[j]) < D) s.addliteral(i, j, 0, 0);\n        }\n    }\n    auto res = s.calc();\n    cout << (res ? \"Yes\" : \"No\") << rt;\n    if (res) rep(i, N) cout << (s.val(i) ? X[i] : Y[i]) << rt;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aryssoncf\n */\n\n\n\n// Taken from: https://github.com/bqi343/USACO/blob/master/Implementations/content/contest/templateShort.cpp\n\n#include <utility>\n#include <vector>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n#include <stack>\n#include <array>\n#include <unordered_set>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pii;\n\ntypedef vector<int> vi;\ntypedef vector<ull> vul;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpii;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define rsz resize\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nconst int MOD = 1e9+7; // 998244353; // = (119<<23)+1\nconst int MX = 2e5+5;\n\ntemplate<class T> bool ckmin(T& a, const T& b) {\n    return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) {\n    return a < b ? a = b, 1 : 0; }\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\n//\n// Created by aryssoncf on 28/10/2019.\n//\n\n#include <type_traits>\n\n\n#include <iterator>\n\n\ntemplate <typename T>\nconstexpr auto hasBegin(int) -> decltype(std::begin(std::declval<T>()), true) {\n    return true;\n}\n\nconstexpr bool hasBegin(...) {\n    return false;\n}\n\ntemplate <typename T>\nusing IsContainer = std::integral_constant<bool, hasBegin<T>(0)>;\n\n\n#ifndef JHELPER_EXAMPLE_PROJECT_IO_HPP\n#define JHELPER_EXAMPLE_PROJECT_IO_HPP\n\n#endif //JHELPER_EXAMPLE_PROJECT_IO_HPP\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &element: vec) {\n        is >> element;\n    }\n    return is;\n}\n\ntemplate<typename T, typename U>\nstd::istream &operator>>(std::istream &is, std::pair<T, U> &p) {\n    is >> p.first;\n    is >> p.second;\n    return is;\n}\n\ntemplate <class X, class Y>\nstd::ostream & operator << (std::ostream & os, std::pair <X, Y> const& p) {\n    return os << p.first << \" \" << p.second;\n}\n\ntemplate <class Ch, class Tr, class Container>\nstd::basic_ostream <Ch, Tr> & operator << (std::basic_ostream <Ch, Tr>& os, Container const& x) {\n    bool first = true;\n    for(auto& y : x) {\n        if (first) {\n            first = false;\n        } else {\n            os << \" \";\n        }\n        os << y;\n    }\n    return os;\n}\n\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n\n\n\n\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_SCC_HPP\n\n\n\n\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_TWOSAT_HPP\n\n\nusing namespace std;\n\nclass HTwoSAT {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n        int n, d;\n        in >> n >> d;\n        vector<vi> X(n, vi(2));\n        in >> X;\n        atcoder::two_sat ts(n);\n        FOR(i, 0, n) {\n            FOR(k, 0, 2) {\n                FOR(j, i + 1, n) {\n                    FOR(l, 0, 2) {\n                        if (abs(X[i][k] - X[j][l]) < d) {\n                            ts.add_clause(i, not k, j, not l);\n                        }\n                    }\n                }\n            }\n        }\n        bool res = ts.satisfiable();\n        if (res) {\n            vector<bool> states = ts.answer();\n            out << \"Yes\" << '\\n';\n            FOR(i, 0, n) {\n                int x = X[i][states[i]];\n                out << x << '\\n';\n            }\n        } else {\n            out << \"No\" << '\\n';\n        }\n\t}\n\n\tvoid setup() {}\n};\n\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n\tHTwoSAT solver;\n    solver.setup();\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n    out << std::fixed;\n    out.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tatcoder::two_sat t(n);\n\tvector<int> x(n), y(n);\n\trep(i, n) cin >> x[i] >> y[i];\n\trep(i, n) for (int j = i + 1; j < n; ++j) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, false, j, false);\n\t\t}\n\t}\n\tif (t.satisfiable()) {\n\t\tputs(\"Yes\");\n\t\tauto ans = t.answer();\n\t\trep(i, n) cout << (ans[i] ? y[i] : x[i]) << endl;\n\t} else {\n\t\tputs(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct SCC {\npublic:\n    SCC(int n) : G(n), G_rev(n), comp(n, -1), visited(n) {}\n\n    void add_edge(int u, int v) {\n        G[u].push_back(v);\n        G_rev[v].push_back(u);\n    }\n\n    void build() {\n        for (int v = 0; v < G.size(); v++) dfs(v);\n        reverse(order.begin(), order.end());\n        int c = 0;\n        for (int v : order) if (comp[v] == -1) rdfs(v, c++);\n    }\n\n    int operator[](int i) const {\n        return comp[i];\n    }\n\nprivate:\n    vector<vector<int>> G, G_rev;\n    vector<int> comp, order;\n    vector<bool> visited;\n\n    void dfs(int u) {\n        if (visited[u]) return;\n        visited[u] = true;\n        for (int v : G[u]) dfs(v);\n        order.push_back(u);\n    }\n\n    void rdfs(int u, int c) {\n        if (comp[u] != -1) return;\n        comp[u] = c;\n        for (int v : G_rev[u]) rdfs(v, c);\n    }\n};\n\nstruct TwoSat {\n    bool satisfiable = true;\n\n    TwoSat(int n) : n(n), scc(2 * n), val(n) {}\n\n    void add_clause(int u, bool a, int v, bool b) {\n        scc.add_edge(n * a + u, n * (!b) + v);\n        scc.add_edge(n * b + v, n * (!a) + u);\n    }\n\n    void solve() {\n        scc.build();\n        for (int i = 0; i < n; i++) {\n            if (scc[i] == scc[n + i]) {\n                satisfiable = false;\n                break;\n            }\n            val[i] = scc[i] > scc[n + i];\n        }\n    }\n\n    bool operator[](int i) const {\n        return val[i];\n    }\n\nprivate:\n    int n;\n    SCC scc;\n    vector<bool> val;\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    TwoSat sat(N);\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                sat.add_clause(i, false, j, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                sat.add_clause(i, false, j, true);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                sat.add_clause(i, true, j, false);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                sat.add_clause(i, true, j, true);\n            }\n        }\n    }\n    sat.solve();\n    if (sat.satisfiable) {\n        cout << \"Yes\\n\";\n        for (int i = 0; i < N; i++) {\n            if (sat[i]) cout << X[i];\n            else cout << Y[i];\n            cout << \"\\n\";\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    two_sat ts(n);\n    int d; cin >> d;\n    vector<int> x(n), y(n);\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n    }\n    rep(i, n) {\n        for(int j = i + 1; j < n; ++ j) {\n            if(abs(x[i] - x[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            } \n        }\n    }\n    if(!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return;\n    }\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    rep(i, n) {\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nclass strong_components{\nprivate:\n    vector<vector<int>> v,rv,nv;\n    vector<int> rs,visited,cmp,cmp_size;\n    void dfs(int n){\n        visited[n] = 1;\n        for(auto x:v[n]) if(!visited[x]) dfs(x);\n        rs.push_back(n);\n    }\n    void rdfs(int n,int cnt){\n        visited[n] = 1;\n        cmp[n] = cnt;\n        for(auto x:rv[n]) if(!visited[x]) rdfs(x,cnt);\n    }\npublic:\n    strong_components(int N,vector<vector<int>>& graph){\n        v = graph;\n        rv = vector<vector<int>>(N);\n        visited = cmp = cmp_size = vector<int>(N,0);\n        for(int i=0;i<N;i++) for(auto x:v[i]) rv[x].push_back(i);\n        for(int i=0;i<N;i++) if(!visited[i]) dfs(i);\n        for(int i=0;i<N;i++) visited[i] = 0;\n        int now = 0;\n        for(int i=(int) rs.size()-1;i>=0;i--) if(!visited[rs[i]]) rdfs(rs[i],now++);\n        nv = vector<vector<int>>(now);\n        for(int i=0;i<N;i++){\n            for(auto x:v[i]){\n                if(cmp[i]!=cmp[x]){\n                    nv[cmp[i]].push_back(cmp[x]);\n                    cmp_size[cmp[x]]++;\n                }\n            }\n        }\n    }\n    int find(int n){return cmp[n];}\n    bool is_same_group(int a,int b){return cmp[a]==cmp[b];}\n};\n\nclass SAT{\nprivate:\n    int N;\n    vector<vector<int>> v;\npublic:\n    SAT(int N):N(N){\n        v = vector<vector<int>>(2*N);\n    }\n    void add_closure(int x, bool bx, int y, bool by){\n        v[x+(!bx)*N].push_back(y+by*N);\n        v[y+(!by)*N].push_back(x+bx*N);\n    }\n    vector<int> solve(){\n        strong_components scc(2*N,v);\n        //不可能か判定\n        vector<int> res(N);\n        for(int i=0;i<N;i++){\n            //同じ強連結成分にあったらだめ\n            if(scc.is_same_group(i,i+N)) return vector<int> {};\n            res[i] = (scc.find(i)<scc.find(i+N));\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,D;\n    cin >> N >> D;\n    vec<int> X(N),Y(N);\n    for(int i=0;i<N;i++) cin >> X[i] >> Y[i];\n    SAT sat(N);\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        if(abs(X[i]-X[j])<D) sat.add_closure(i,false,j,false);\n        if(abs(X[i]-Y[j])<D) sat.add_closure(i,false,j,true);\n        if(abs(Y[i]-X[j])<D) sat.add_closure(i,true,j,false);\n        if(abs(Y[i]-Y[j])<D) sat.add_closure(i,true,j,true);\n    }\n    auto res = sat.solve();\n    if(res.empty()){\n        cout << \"No\\n\";\n        return 0;\n    }\n    cout << \"Yes\\n\";\n    for(int i=0;i<N;i++) cout << (res[i]? X[i]:Y[i]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n\tint V;\n\tconst vector<vector<int>> &g;\n\tint num_of_comp;\n\tvector<int> comp;\n\tvector<vector<int>> dag;\n\tvector<vector<int>> group_set;\n\n\tvector<vector<int>> rg;\n\tvector<int> order;\n\tvector<bool> used;\n\n\tStronglyConnectedComponents(const vector<vector<int>> &g) : V(g.size()), g(g) {}\n\n\tvoid calc() {\n\t\tnum_of_comp = 0;\n\t\tcomp.assign(V, -1);\n\t\tused.assign(V, false);\n\t\torder.reserve(V);\n\t\trg.resize(V);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int e : g[i]) {\n\t\t\t\trg[e].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (!used[i]) dfs1(i);\n\t\t}\n\t\tfor (int i = V-1; i >= 0; i--) {\n\t\t\tconst int v = order[i];\n\t\t\tif (comp[v] == -1) {\n\t\t\t\tdfs2(v);\n\t\t\t\tnum_of_comp++;\n\t\t\t}\n\t\t}\n\t\tdag.resize(num_of_comp);\n\t\tgroup_set.resize(num_of_comp);\n\t\tfor (int i = 0; i < V; i++) group_set[comp[i]].push_back(i);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int e : g[i]) {\n\t\t\t\tconst int x = comp[i], y = comp[e];\n\t\t\t\tif (x != y) dag[x].push_back(y);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid dfs1(int v) {\n\t\tused[v] = true;\n\t\tfor (int nv : g[v]) {\n\t\t\tif (used[nv]) continue;\n\t\t\tdfs1(nv);\n\t\t}\n\t\torder.push_back(v);\n\t}\n\n\tvoid dfs2(int v) {\n\t\tcomp[v] = num_of_comp;\n\t\tfor (int nv : rg[v]) {\n\t\t\tif (comp[nv] != -1) continue;\n\t\t\tdfs2(nv);\n\t\t}\n\t}\n};\n\nstruct TwoSAT\n{\n\tint n;\n\tbool ok;\n\tvector<bool> ans;\n\n\tvector<vector<int>> g;\n\n\tTwoSAT(int n) : n(n), g(2*n) {}\n\n\tvoid add_clause(int i, bool bool_i, int j, bool bool_j) {\n\t\tg[2*i + !bool_i].push_back(2*j + bool_j);\n\t\tg[2*j + !bool_j].push_back(2*i + bool_i);\n\t}\n\n\tvoid calc() {\n\t\tStronglyConnectedComponents scc(g);\n\t\tscc.calc();\n\t\tok = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (scc.comp[2*i] == scc.comp[2*i + 1]) return;\n\t\t}\n\t\tok = true;\n\t\tans.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans[i] = scc.comp[2*i] < scc.comp[2*i + 1];\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tTwoSAT sat(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor (int j = i+1; j < n; j++) {\n\t\t\tif (abs(x[i]-x[j]) < d) sat.add_clause(i, 1, j, 1);\n\t\t\tif (abs(x[i]-y[j]) < d) sat.add_clause(i, 1, j, 0);\n\t\t\tif (abs(y[i]-x[j]) < d) sat.add_clause(i, 0, j, 1);\n\t\t\tif (abs(y[i]-y[j]) < d) sat.add_clause(i, 0, j, 0);\n\t\t}\n\t}\n\tsat.calc();\n\tif (sat.ok) {\n\t\tcout << \"Yes\" << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (sat.ans[i]) cout << y[i] << '\\n';\n\t\t\telse cout << x[i] << '\\n';\n\t\t}\n\t} else cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma region template\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- Ruby --- //\ntemplate <class F> struct Callable {\n\tF func;\n\tCallable(const F& f) : func(f) {}\n};\ntemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\treturn c.func(v);\n}\n\nstruct Sort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(begin(v), end(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\treturn v;\n\t}\n} Sort;\nstruct RSort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\tsort(rbegin(v), rend(v));\n\t\treturn v;\n\t}\n} RSort;\nstruct Reverse_impl {\n\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\treverse(begin(v), end(v));\n\t\treturn v;\n\t}\n} Reverse;\nstruct Unique_impl {\n\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Unique;\nstruct Uniq_impl {\n\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Uniq;\nstruct Rotate_impl {\n\ttemplate <class F> auto operator()(int left) {\n\t\treturn Callable([&](auto v) {\n\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} Rotate;\nstruct Max_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\treturn *max_element(begin(v), end(v));\n\t}\n} Max;\nstruct Min_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\treturn *min_element(begin(v), end(v));\n\t}\n} Min;\nstruct MaxPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t}\n} MaxPos;\nstruct MinPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t}\n} MinPos;\nstruct MaxBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_it = begin(v);\n\t\t\tauto max_val = f(*max_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_it = it;\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *max_it;\n\t\t});\n\t}\n} MaxBy;\nstruct MinBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_it = begin(v);\n\t\t\tauto min_val = f(*min_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_it = it;\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *min_it;\n\t\t});\n\t}\n} MinBy;\nstruct MaxOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_val;\n\t\t});\n\t}\n} MaxOf;\nstruct MinOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min_val;\n\t\t});\n\t}\n} MinOf;\nstruct Count_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count(begin(v), end(v), val);\n\t\t});\n\t}\n} Count;\nstruct CountIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count_if(begin(v), end(v), f);\n\t\t});\n\t}\n} CountIf;\nstruct Index_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} Index;\nstruct IndexIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} IndexIf;\nstruct FindIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t});\n\t}\n} FindIf;\nstruct Sum_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\treturn a + f(b);\n\t\t\t});\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t}\n} Sum;\nstruct Includes {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t});\n\t}\n} Includes;\nstruct IncludesIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t});\n\t}\n} IncludesIf;\nstruct RemoveIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} RemoveIf;\nstruct Each_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tf(i);\n\t\t\t}\n\t\t});\n\t}\n} Each;\nstruct Select_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\tvector<value_type> res;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Select;\nstruct Map_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\tvector<result_type> res;\n\t\t\tres.reserve(size(v));\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.push_back(f(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Map;\nstruct Indexed_impl {\n\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\tusing value_type = typename T::value_type;\n\t\tvector<pair<value_type, int>> res;\n\t\tres.reserve(size(v));\n\t\tint index = 0;\n\t\tfor (const auto& i : v) {\n\t\t\tres.emplace_back(i, index++);\n\t\t}\n\t\treturn res;\n\t}\n} Indexed;\nstruct AllOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (!f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} AllOf;\nstruct AnyOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n} AnyOf;\nstruct NoneOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} NoneOf;\n\n// --- functions --- //\ntemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\treturn lower_bound(all(a), v) - a.begin();\n}\ntemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\treturn upper_bound(all(a), v) - a.begin();\n}\ntemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n}\ninline auto operator*(string s, size_t n) {\n\tstring res;\n\tfor (size_t i = 0; i < n; ++i) res += s;\n\treturn res;\n}\ntemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\tv.insert(v.end(), all(v2));\n\treturn v;\n}\ntemplate <class T> inline T Ceil(T n, T m) {\n\treturn (n + m - 1) / m;\n}\ntemplate <class T> inline T Ceil2(T n, T m) {\n\treturn Ceil(n, m) * m;\n}\ntemplate <class T> inline T Tri(T n) {\n\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n}\ntemplate <class T> inline T nC2(T n) {\n\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n}\ntemplate <class T> inline T Mid(const T& l, const T& r) {\n\treturn l + (r - l) / 2;\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\treturn min <= v && v < max;\n}\ntemplate <class T> inline bool isSquere(T n) {\n\tT s = sqrt(n);\n\treturn s * s == n || (s + 1) * (s + 1) == n;\n}\ntemplate <class T = long long> inline T BIT(int b) {\n\treturn T(1) << b;\n}\ntemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n}\ntemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n}\ntemplate <class T> inline T Pow(T a, T n) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) r *= a;\n\t\ta *= a;\n\t\tn /= 2;\n\t}\n\treturn r;\n}\ntemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tr = r * a % m, n--;\n\t\telse\n\t\t\ta = a * a % m, n /= 2;\n\t}\n\treturn r;\n}\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n#pragma endregion\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Reference:\n\t\t// R. Tarjan,\n\t\t// Depth-First Search and Linear Graph Algorithms\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\n\t// Reference:\n\t// B. Aspvall, M. Plass, and R. Tarjan,\n\t// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n\t// Formulas\n\tstruct two_sat {\n\tpublic:\n\t\ttwo_sat() : _n(0), scc(0) {}\n\t\ttwo_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n\t\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\t\tassert(0 <= i && i < _n);\n\t\t\tassert(0 <= j && j < _n);\n\t\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t\t}\n\t\tbool satisfiable() {\n\t\t\tauto id = scc.scc_ids().second;\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tif (id[2 * i] == id[2 * i + 1]) return false;\n\t\t\t\t_answer[i] = id[2 * i] < id[2 * i + 1];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tstd::vector<bool> answer() {\n\t\t\treturn _answer;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<bool> _answer;\n\t\tinternal::scc_graph scc;\n\t};\n\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tin(n, d);\n\tatcoder::two_sat t(n);\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, false, j, false);\n\t\t}\n\t}\n\tif (t.satisfiable()) {\n\t\tout(true);\n\t\tauto ans = t.answer();\n\t\trep(i, n) out(ans[i] ? y[i] : x[i]);\n\t} else {\n\t\tout(false);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define repit(it, li) for(auto it=li.begin(); it!=li.end(); it++)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint main(){\n\tint n, d;\n\tcin>>n>>d;\n\tvector<vector<int>> x(n);\n\trep(i, n) x[i]=vector<int>(2);\n\trep(i, n) cin>>x[i][0]>>x[i][1];\n\n\ttwo_sat ts(n);\n\tfor(int i=0; i<n-1; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\trep(a, 2) rep(b, 2){\n\t\t\t\tif(abs(x[i][a]-x[j][b])<d) ts.add_clause(i, !a, j, !b);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=ts.satisfiable();\n\tif(ok){\n\t\tcout<<\"Yes\"<<endl;\n\t\tauto vb=ts.answer();\n\t\trep(i, n) cout<< x[i][vb[i]] <<endl;\n\t}\n\telse cout<<\"No\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\nstruct scc_graph {\npublic:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n \n    void add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n \n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                }\n                else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return { group_num, ids };\n    }\n \n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\nprivate:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\nstruct two_sat {\npublic:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n \n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n \nprivate:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n \nint main(){\n    int n, d; cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n \n    two_sat data(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x[i] - x[j]) < d) data.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) data.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < d) data.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < d) data.add_clause(i, true, j, true);\n        }\n    }\n \n    if (!data.satisfiable()) {\n        cout << \"No\" << \"\\n\";\n        return 0;\n    }\n    cout << \"Yes\" << \"\\n\";\n    auto ans = data.answer();\n    for (int i = 0; i < n; i++) cout << (ans[i] ? x[i] : y[i]) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf (INT_MAX/2-100)\n#define infl (LLONG_MAX/3)\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nll n,d;\nll x[1005][2];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>d;\n\ttwo_sat g(n);\n\trep(i,n)rep(j,2)cin>>x[i][j];\n\trep(i,n){\n\t\trng(j,i+1,n){\n\t\t\trep(k,2){\n\t\t\t\trep(l,2){\n\t\t\t\t\tif(abs(x[i][k]-x[j][l])<d){\n\t\t\t\t\t\tg.add_clause(i,k^1,j,l^1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(g.satisfiable()){\n\t\tYes(false);\n\t\tvc<bool>ans=g.answer();\n\t\trep(i,n){\n\t\t\tprint(x[i][ans[i]]);\n\t\t}\n\t}else{\n\t\tNo();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <atcoder/all>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) for(int sz=0;sz<int(vec.size());sz++) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, d; cin >> n >> d;\n    vll x(n), y(n);\n    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\n    atcoder::two_sat ts(2 * n);\n    for (int i = 0; i < n; i++) {\n        ts.add_clause(i, true, i + n, true);\n        ts.add_clause(i, false, i + n, false);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n            if (abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n        }\n    }\n\n    if (ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        V<bool> ans = ts.answer();\n        for (int i = 0; i < 2 * n; i++) {\n            if (ans[i]) cout << (i < n ? x : y)[i % n] << '\\n';\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n  int N,D;\n  cin >> N >> D;\n  vector<int> X(N),Y(N);\n  for(int i=0;i<N;i++) cin >> X[i] >> Y[i];\n  \n  two_sat T(N);\n  for(int i=0;i<N;i++){\n    for(int j=i+1;j<N;j++){\n      if(abs(X[i]-X[j])<D) T.add_clause(i,true,j,true);\n      if(abs(X[i]-Y[j])<D) T.add_clause(i,true,j,false);\n      if(abs(Y[i]-X[j])<D) T.add_clause(i,false,j,true);\n      if(abs(Y[i]-Y[j])<D) T.add_clause(i,false,j,false);\n    }\n  }\n  \n  if(T.satisfiable()){\n    cout << \"Yes\" << endl;\n    vector<bool> V = T.answer();\n    for(int i=0;i<N;i++){\n      if(V[i]) cout << Y[i] << endl;\n      else cout << X[i] << endl;\n    }\n  }\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst int N = 100000;\n\nint vertexid[N];\nint L[N], R[N];\nint fl;\nvector<int> graph[N];\n\nvoid build(int v, int l, int r)\n{\n  L[v] = l, R[v] = r;\n  if (l + 1 == r)\n  {\n    vertexid[v] = l;\n    return;\n  }\n  int m = (l + r) / 2;\n  vertexid[v] = fl++;\n  build(2 * v + 1, l, m);\n  build(2 * v + 2, m, r);\n  graph[vertexid[v]].push_back(vertexid[2 * v + 1]);\n  graph[vertexid[v]].push_back(vertexid[2 * v + 2]);\n}\n\nvoid connect(int from, int l, int r, int v)\n{\n  if (r <= L[v] || R[v] <= l) return;\n  if (l <= L[v] && R[v] <= r)\n  {\n    graph[from].push_back(vertexid[v]);\n    return;\n  }\n  connect(from, l, r, 2 * v + 1);\n  connect(from, l, r, 2 * v + 2);\n}\n\nint main()\n{\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n  }\n  vector<pair<int, int> > f;\n  for (int i = 0; i < n; i++)\n  {\n    f.push_back({y[i], 2 * i + 1});\n    f.push_back({x[i], 2 * i});\n  }\n  vector<int> pos(2 * n);\n  sort(f.begin(), f.end());\n  for (int i = 0; i < 2 * n; i++)\n  {\n    pos[f[i].second] = i;\n  }\n  fl = 2 * n;\n  build(0, 0, 2 * n);\n  for (int i = 0; i < 2 * n; i++)\n  {\n    int c = x[f[i].second / 2] + y[f[i].second / 2] - f[i].first;\n    int mirror = pos[f[i].second ^ 1];\n    int L, R;\n    {\n      int le = -1, ri = 2 * n;\n      while (le + 1 < ri)\n      {\n        int mi = (le + ri) / 2;\n        if (f[mi].first <= c - d) le = mi;\n        else ri = mi;\n      }\n      L = ri;\n    }\n    {\n      int le = -1, ri = 2 * n;\n      while (le + 1 < ri)\n      {\n        int mi = (le + ri) / 2;\n        if (f[mi].first >= c + d) ri = mi;\n        else le = mi;\n      }\n      R = le;\n    }\n    if (L <= mirror - 1)\n    {\n      connect(i, L, mirror, 0);\n    }\n    if (mirror + 1 <= R)\n    {\n      connect(i, mirror + 1, R + 1, 0);\n    }\n  }\n  scc_graph G(fl);\n  for (int i = 0; i < fl; i++)\n  {\n    for (auto u : graph[i])\n    {\n      G.add_edge(i, u);\n    }\n  }\n  vector<vector<int> > scc = G.scc();\n  vector<int> wh(fl);\n  for (int i = 0; i < scc.size(); i++)\n  {\n    for (int j = 0; j < scc[i].size(); j++)\n    {\n      wh[scc[i][j]] = i;\n    }\n  }\n  vector<int> ans(n);\n  for (int i = 0; i < n; i++)\n  {\n    if (wh[pos[2 * i]] == wh[pos[2 * i + 1]])\n    {\n      cout << \"No\\n\";\n      return 0;\n    }\n    ans[i] = wh[pos[2 * i]] > wh[pos[2 * i + 1]];\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; i++)\n  {\n    if (ans[i]) cout << y[i] << \"\\n\";\n    else cout << x[i] << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing namespace atcoder;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\nint main() {\n  \n  int n, d; cin >> n >> d;\n  vector<int> x(n);\n  vector<int> y(n);\n\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n\n  two_sat ts(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (abs(x[i] - x[j]) < d) {\n        // x[i] と x[j] は同時に使えない\n        // 否定を取った論理式を追加する\n        ts.add_clause(i, false, j, false);\n      }\n      if (abs(x[i] - y[j]) < d) {\n        ts.add_clause(i, false, j, true);\n      }\n      if (abs(y[i] - x[j]) < d) {\n        ts.add_clause(i, true, j, false);\n      }\n      if (abs(y[i] - y[j]) < d) {\n        ts.add_clause(i, true, j, true);\n      }\n    }\n  }\n\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  cout << \"Yes\" << endl;\n  auto answer = ts.answer();\n  for (int i = 0; i < n; i++) {\n    if (answer[i]) {\n      cout << x[i] << endl;\n    } else {\n      cout << y[i] << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<atcoder/all>\nusing namespace atcoder;\n\n#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nint main() {\n    int N, D; scanf(\"%d%d\", &N, &D);\n    int X[1000][2]; rep(i, N) rep(j, 2) scanf(\"%d\", &X[i][j]);\n    two_sat G(N);\n    rep(i, N) rep(j, i) {\n        if (abs(X[i][0] - X[j][0]) < D) G.add_clause(i, false, j, false);\n        if (abs(X[i][0] - X[j][1]) < D) G.add_clause(i, false, j, true);\n        if (abs(X[i][1] - X[j][0]) < D) G.add_clause(i, true, j, false);\n        if (abs(X[i][1] - X[j][1]) < D) G.add_clause(i, true, j, true);\n    }\n    bool ok = G.satisfiable();\n    printf(ok ? \"Yes\\n\" : \"No\\n\");\n    if (ok) {\n        auto ans = G.answer();\n        rep(i, N) printf(\"%d\\n\", ans[i] ? X[i][0] : X[i][1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n\n#include <boost/rational.hpp>\n*/\n//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define _GLIBCXX_DEBUG\n#define rep(i,t) for (ll i = (ll)(0); i < (ll)(t); i++)\n#define rep2(i,s,t) for (ll i = (ll)(s); i < (ll)(t); i++)\n#define rep3(i,t) for (ll i = (ll)(1); i <= (ll)(t); i++)\n#define rep4(i,s,t) for (ll i = (ll)(s); i <= (ll)(t); i++)\n#define repr(i,t) for (ll i = (t-1); i>=(0);i--)\n#define repr2(i,s,t) for (ll i = (t-1); i>=(s);i--)\n#define repr3(i,t) for (ll i = (t); i>=(1);i--)\n#define repr4(i,s,t) for (ll i = (t); i>=(s);i--)\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc =pair<char,char>;\nusing pll = pair<ll,ll>;\nusing pii = pair<int,int>;\nusing pdd = pair<double,double>;\nusing tuplis = array<ll,3>;\ntemplate<class T> using pq = priority_queue<T,vector<T>,greater<T>>;\ninline const ll LINF = 1e18;\ninline const ll MINF = 1e15;\ninline const int INF = 1e9+1e5;\ninline const int mod=1000000007;\n//inline const int mod=998244353;\n\n\n\ninline const ld DINF = numeric_limits<ld>::infinity();\ninline const ld EPS=1e-9;\ninline const ld PI=acos(-1);\n//const ll dx[] ={0,1,0,-1,1,-1,1,-1};\n//const ll dy[] ={1,0,-1,0,1,1,-1,-1};\ninline const bool ingrid(const int i,const int j,const int H,const int W){return i>=0&&i<H&&j>=0&&j<W;}\ninline const ll dx[] ={0,1,0,-1};\ninline const ll dy[] ={1,0,-1,0};\ninline const bool is_low(char c){ return('a'<=c)&&(c<='z');}\ninline const bool is_upp (char c) {return('A'<=c)&&(c<='Z');}\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define rrep(n) for(ll i=(n);i--;)\n#define stlen(s) ll s.size()-1\n#define all(v) begin(v), end(v)\n#define range(v,a) begin(v),begin(v)+a\n#define range2(v,a,b) begin(v)+a,begin(v)+b\n#define range3(v,a) begin(v)+1,begin(v)+a+1\n#define range4(v,a,b) begin(v)+a+1,begin(v)+b+1\n#define allr(v) rbegin(v), v.rend(v)\n#define ranger(v,a) rbegin(v),rbegin(v)+a\n#define ranger2(v,a,b) rbegin(v)+a,rbegin(v)+b\n#define ranger3(v,a) rbegin(v)+1,rbegin(v)+a+1\n#define ranger4(v,a,b) rbegin(v)+a+1,rbegin(v)+b+1\n#define cout(n) cout<<std::fixed<<std::setprecision(n)\n//#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__; in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__; in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__; in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a)); a.erase(unique(all(a)),end(a));\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size); in(name)\n#define vv(type,name,h,...) vector<vector<type>> name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>> name(h,vector<type>(w)); in(name)\ntemplate<class T> inline const auto min(const T& a){ return *min_element(all(a));}\ntemplate<class T> inline const auto max(const T& a){ return *max_element(all(a));}\ninline const ll popcnt(const ull a){return __builtin_popcountll(a);}\ninline const ll gcd(ll a,ll b){while(b){ll c=b; b=a%b;a=c;}return a;}\ninline const ll lcm(ll a,ll b){unless(a&&b) return 0;return a*b/gcd(a,b);}\ninline const ll intpow(ll a,ll b){ll ans=1; while(b){if(b&1)ans*=a;a *=a; b/=2;}return ans;}\ninline const ll modpow(ll a,ll b, ll p=mod){ll ans=1; while(b){if(b&1)(ans*=a)%=p;(a*=a)%=p;b/=2;}return ans;}\ntemplate<class T,class U>inline const bool chmin(T& a,const U& b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T,class U>inline const bool chmax( T& a,const U& b){if(a<b){a=b;return 1;}return 0;}\ninline const vector<ll> iota(const ll n){vector<ll> a(n); iota(all(a),0);return a;}\ninline const vector<pll> factor(ull x){vector<pll> ans; for(ull i=2;i*i<=x;i++)if(x%i==0){ans.push_back({i,1});while((x/=i)%i==0)ans.back().second++;}if(x!=1)ans.push_back({x,1});return ans;}\ninline const map<ll,ll> factor_map(ull x){map<ll,ll> ans; for(ull i=2; i*i<=x;i++)if(x%i==0){ans[i]=1;while((x/=i)%i==0)ans[i]++;}if(x!=1)ans[x]=1;return ans;}\ninline const vector<ll> divisor(ull x){vector<ll> ans; for(ull i=2;i*i<=x;i++)if(x%i==0)ans.push_back(i);rrep(ans.size()-(ans.back()*ans.back()==x))ans.push_back(x/ans[i]);return ans;}\ninline const int scan() {return getchar();}\ninline const void scan(int &a){scanf(\"%d\", &a);}\ninline const void scan(unsigned& a){scanf(\"%u\",&a);}\ninline const void scan(long& a){scanf(\"%ld\",&a);}\ninline const void scan(long long& a){scanf(\"%lld\", &a);}\ninline const void scan(char& a){ do{a=getchar();}while(a==' '||a=='\\n');}\ninline const void scan(float& a){ scanf(\"%f\",&a);}\ninline const void scan(double& a){ scanf(\"%lf\",&a);}\ninline const void scan(long double& a){ scanf(\"%Lf\",&a);}\ninline const void scan( string& a){cin>> a;}\ntemplate<class T>inline const void scan( vector<T>& a){for(auto&& i:a)scan(i);}\ntemplate<class T,size_t size>inline const void scan(array<T, size>& a){for(auto&& i:a)scan(i);}\ntemplate<class T,class L>inline const void scan( pair<T,L>&p){scan(p.first);scan(p.second);}\ntemplate<class T,size_t size>inline const void scan( T (&a)[size]){ for(auto&& i:a)scan(i);}\ninline const void in(){}\ntemplate <class Head,class... Tail>inline const void in( Head& head, Tail&... tail){scan(head);in(tail...);}\ninline const int ctoi(const char c){if(c>='a'&&c<='z'){return c-'a';} if(c>='A'&&c<='Z'){return c-'A';}if(c>='0'&&c<='9'){return c-'0';}return -1;}\ninline const void print(){putchar(' ');}\ninline const void print(const bool a){printf(\"%d\", a);}\ninline const void print(const int a){printf(\"%d\",a);}\ninline const void print(const unsigned a){ printf(\"%u\",a);}\ninline const void print(const long a){printf(\"%ld\",a);}\ninline const void print(const unsigned long long a){printf(\"%llu\",a);}\ninline const void print(const char a){ printf(\"%c\",a);}\ninline const void print(const double a){printf(\"%.15f\",a);}\ninline const void print(const long double a){printf(\"%.15Lf\",a);}\ninline const void print(const string&a){for(auto&&i :a)print(i);}\ntemplate<class T> inline const void print(const vector<T> &a){if(a.empty())return ;print(a[0]);for(auto i=a.begin();++i!=a.end();){putchar(' ');print(*i);}}\ntemplate<class T> inline const void print(const deque<T>&a ){if(a.empty())return;print(a[0]);for(auto i=a.begin(); ++i!=a.end();){putchar(' ');print(*i);}}\ntemplate<class T, size_t size>inline const void print(const T (&a)[size]){print(a[0]);for(auto i=a;++i!=end(a);){putchar(' ');print(*i);}}\ntemplate<class T>inline const void print(const T& a){cout<<a;}\ninline const int out(){putchar('\\n');return 0;}\ntemplate<class T> inline const int out(const T& t){print(t);putchar('\\n');return 0;}\ntemplate<class Head,class... Tail>inline const int out(const Head& head,const Tail&... tail){print(head);putchar(' ');out(tail...);return 0;}\ninline const int first(const bool i){return out(i?\"first\":\"second\");}\ninline const int yes(const bool i){return out(i?\"yes\":\"no\");}\ninline const int Yes(const bool i){return out(i?\"Yes\":\"No\");}\ninline const int YES(const bool i){return out(i?\"YES\":\"NO\");}\ninline const int possible(const bool i){return out(i?\"possible\":\"impossible\");}\ninline const int Possible(const bool i){return out(i?\"Possible\":\"Impossible\");}\ninline const int POSSIBLE(const bool i){return out(i?\"POSSIBLE\":\"IMPOSSIBLE\");}\n\n \nusing Graph = vector<vector<int>>;\nusing Graphw = vector<vector<pair<ll,ll>>>;\nusing mat = vector<vector<ll>>;\nusing vec = vector<ll>;\n\n/*\nnamespace mp = boost::multiprecision;\n// 任意長整数型\nusing Bint = mp::cpp_int;\n// 仮数部長が32の浮動小数点数型\nusing Real32 = mp::number<mp::cpp_dec_float<32>>;\n// 仮数部長が1024の浮動小数点数型\nusing Real1024 = mp::number<mp::cpp_dec_float<1024>>;\n// 有理数型\nusing Rat = boost::rational<Bint>;\n*/\n\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n\nsigned main(){\n\nINT(N,D);\ntwo_sat ts(N);\nint X[N],Y[N];\nrep(i,N)cin>>X[i]>>Y[i];\nrep(i,N)rep2(j,i+1,N){\n    if(abs(X[i]-X[j])<D){\n        ts.add_clause(i,false,j,false);\n    }\n    if(abs(X[i]-Y[j])<D){\n        ts.add_clause(i,false,j,true);\n    }\n    if(abs(Y[i]-X[j])<D){\n        ts.add_clause(i,true,j,false);\n    }\n    if(abs(Y[i]-Y[j])<D){\n        ts.add_clause(i,true,j,true);\n    }\n}\n\nif(!ts.satisfiable()){\n    cout<<\"No\"<<endl;\n    return 0;\n}\ncout<<\"Yes\"<<endl;\nauto ans=ts.answer();\nrep(i,N){\n    if(ans[i])out(X[i]);\n    else out(Y[i]);\n}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nusing CostType = ll;\nstruct Edge {\n  int src, dst; CostType cost;\n  Edge(int src, int dst, CostType cost = 0) : src(src), dst(dst), cost(cost) {}\n  inline bool operator<(const Edge &x) const {\n    return cost != x.cost ? cost < x.cost : dst != x.dst ? dst < x.dst : src < x.src;\n  }\n  inline bool operator<=(const Edge &x) const { return !(x < *this); }\n  inline bool operator>(const Edge &x) const { return x < *this; }\n  inline bool operator>=(const Edge &x) const { return !(*this < x); }\n};\n\nstruct SCC {\n  vector<int> id;\n  vector<vector<int>> vertices;\n  vector<vector<Edge>> comp;\n\n  SCC(const vector<vector<Edge>> &graph, bool heavy = false) : graph(graph), heavy(heavy) {\n    n = graph.size();\n    rev_graph.resize(n);\n    REP(i, n) for (const Edge &e : graph[i]) {\n      rev_graph[e.dst].emplace_back(e.dst, e.src, e.cost);\n    }\n    used.assign(n, false);\n    id.assign(n, -1);\n    REP(i, n) {\n      if (!used[i]) dfs(i);\n    }\n    int now = 0;\n    for (int i = n - 1; i >= 0; --i) {\n      if (id[order[i]] == -1) {\n        if (heavy) vertices.emplace_back();\n        rev_dfs(order[i], now++);\n      }\n    }\n    comp.resize(now);\n    REP(i, n) for (const Edge &e : graph[i]) {\n      if (id[i] != id[e.dst]) comp[id[i]].emplace_back(id[i], id[e.dst], e.cost);\n    }\n    // if (heavy) {\n    //   REP(i, now) sort(ALL(vertices[i]));\n    // }\n  }\n\nprivate:\n  bool heavy;\n  int n;\n  vector<vector<Edge>> graph, rev_graph;\n  vector<bool> used;\n  vector<int> order;\n\n  void dfs(int ver) {\n    used[ver] = true;\n    for (const Edge &e : graph[ver]) {\n      if (!used[e.dst]) dfs(e.dst);\n    }\n    order.emplace_back(ver);\n  }\n\n  void rev_dfs(int ver, int now) {\n    id[ver] = now;\n    if (heavy) vertices[now].emplace_back(ver);\n    for (Edge &e : rev_graph[ver]) {\n      if (id[e.dst] == -1) rev_dfs(e.dst, now);\n    }\n  }\n};\n\nstruct TwoSat {\n  TwoSat(int n) : n(n), graph(n << 1) {}\n\n  int negate(int x) const { return (n + x) % (n << 1); }\n\n  void add_or(int x, int y) {\n    graph[negate(x)].emplace_back(negate(x), y);\n    graph[negate(y)].emplace_back(negate(y), x);\n  }\n\n  void add_if(int x, int y) { add_or(negate(x), y); }\n\n  void add_nand(int x, int y) { add_or(negate(x), negate(y)); }\n\n  void set_true(int x) { add_or(x, x); }\n\n  void set_false(int x) { set_true(negate(x)); }\n\n  vector<bool> build() const {\n    SCC scc(graph);\n    vector<bool> res(n);\n    REP(i, n) {\n      if (scc.id[i] == scc.id[negate(i)]) return {};\n      res[i] = scc.id[negate(i)] < scc.id[i];\n    }\n    return res;\n  }\n\nprivate:\n  int n;\n  vector<vector<Edge>> graph;\n};\n\nint main() {\n  int n, d; cin >> n >> d;\n  vector<int> x(n), y(n); REP(i, n) cin >> x[i] >> y[i];\n  TwoSat ts(n);\n  REP(i, n) FOR(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_nand(i, j);\n    if (abs(x[i] - y[j]) < d) ts.add_nand(i, ts.negate(j));\n    if (abs(y[i] - x[j]) < d) ts.add_nand(ts.negate(i), j);\n    if (abs(y[i] - y[j]) < d) ts.add_nand(ts.negate(i), ts.negate(j));\n  }\n  vector<bool> ans = ts.build();\n  if (ans.empty()) {\n    cout << \"No\\n\";\n    return 0;\n  }\n  cout << \"Yes\\n\";\n  REP(i, n) cout << (ans[i] ? x[i] : y[i]) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing namespace std;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector a(n, vector(2, 0));\n\trep(i, n) rep(j, 2) cin >> a[i][j];\n\n\tatcoder::two_sat t(n);\n\trep(i, n) for (int j = i + 1; j < n; ++j) rep(k, 4) {\n\t\tif (abs(a[i][k >> 1] - a[j][k & 1]) < d) t.add_clause(i, k >> 1, j, k & 1);\n\t}\n\tif (t.satisfiable()) {\n\t\tputs(\"Yes\");\n\t\tauto ans = t.answer();\n\t\trep(i, n) cout << a[i][!ans[i]] << endl;\n\t} else {\n\t\tputs(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <atcoder/twosat>\nusing namespace atcoder;\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nvoid solve(long long N, long long D, std::vector<long long> X, std::vector<long long> Y){\n    // select X = true, select Y = false\n    two_sat ts(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i, 0, j, 0);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i, 0, j, 1);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, 1, j, 0);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, 1, j, 1);\n            }\n        }\n    }\n    bool result = ts.satisfiable();\n    if (!result) {\n        cout << NO << endl;\n        return;\n    }\n    cout << YES << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < N; i++) {\n        if (answer[i]) {\n            cout << X[i] << endl;\n        } else {\n            cout << Y[i] << endl;\n        }\n    }\n}\n\n// Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long D;\n    scanf(\"%lld\",&D);\n    std::vector<long long> X(N);\n    std::vector<long long> Y(N);\n    for(int i = 0 ; i < N ; i++){\n        scanf(\"%lld\",&X[i]);\n        scanf(\"%lld\",&Y[i]);\n    }\n    solve(N, D, std::move(X), std::move(Y));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long \n\nint n;\nLL d;\nLL x[1000],y[1000];\n\nint main(){\n    cin>>n>>d;\n    auto ts = atcoder::two_sat(2*n);\n    REP(i,n){\n        cin>>x[i]>>y[i];\n        ts.add_clause(i,true,n+i,true);\n        REP(j,i){\n            if(abs(x[i]-x[j]) < d)ts.add_clause(i,false,j,false);\n            if(abs(x[i]-y[j]) < d)ts.add_clause(i,false,n+j,false);\n            if(abs(y[i]-x[j]) < d)ts.add_clause(n+i,false,j,false);\n            if(abs(y[i]-y[j]) < d)ts.add_clause(n+i,false,n+j,false);\n        }\n    }\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        auto ta = ts.answer();\n        REP(i,n){\n            if(ta[i])cout<<x[i]<<endl;\n            else cout<<y[i]<<endl;\n        }\n    }else{\n       cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\nstruct SCC { int stamp, scc_num;\n  struct Node : vector<int> {\n    int dfn, low, scc; bool inS;\n    Node() { dfn = low = scc = -1; inS = false; }\n  };\n  vector<Node> N; vector<int> stk;\n  void init(int n) {\n    N.clear(); N.resize(n); stk.clear();\n  }\n  void addEdge(int u, int v) { N[u].push_back(v); }\n  void Tarjan(int u) { N[u].low = N[u].dfn = stamp++;\n    stk.push_back(u); N[u].inS = true;\n    for (auto &v : N[u]) if (!~N[v].dfn) Tarjan(v),\n      N[u].low = min(N[u].low, N[v].low);\n    else if (N[v].inS)\n      N[u].low = min(N[u].low, N[v].dfn);\n    if (N[u].dfn == N[u].low) {\n      int v; do { v = stk.back(); stk.pop_back();\n        N[v].scc = scc_num; N[v].inS = false;\n      } while (v != u); scc_num++;\n    }\n  }\n  void run() { stamp = scc_num = 0;\n    for (int i = 0 ; i < N.size() ; i++)\n      if (!~N[i].dfn) Tarjan(i);\n  }\n};\n// LatexBegin\nstruct _2Sat : SCC {\n  void init(int n) { SCC::init(2 * n); }\n  /* addCond(0, 0, 1, 1) -> v0 or !v1*/\n  void addCond(int o1, int v1, int o2, int v2) {\n    addEdge((v1 << 1) | (o1 ^ 1), (v2 << 1) | o2);\n    addEdge((v2 << 1) | (o2 ^ 1), (v1 << 1) | o1);\n  }\n  bool check() {\n    for (int i = 0 ; i < N.size() ; i += 2)\n      if (N[i].scc == N[i ^ 1].scc) return false;\n    return true;\n  }\n  vector<int> construct() { vector<int> ret;\n    for (int i = 0 ; i < N.size() ; i += 2)\n      ret.push_back(N[i].scc < N[i ^ 1].scc);\n    return assert(check()), ret;\n  }\n} solver;\n// LatexEnd\ntypedef long long LL;\ntypedef pair<LL, LL> pii;\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int n; LL d; cin >> n >> d;\n    vector<pii> arr(n);\n    vector<int> pts;\n    for (auto &p : arr) {\n        cin >> p.F >> p.S;\n        pts.push_back(p.F);\n        pts.push_back(p.S);\n    }\n    solver.init(2 * n);\n    for (int i = 0 ; i < 2 * n ; i++) {\n        for (int j = 0 ; j < i ; j++) {\n            if (abs(pts[i] - pts[j]) >= d)\n                continue;\n            solver.addEdge(i * 2 + 1, j * 2 + 0);\n            solver.addEdge(j * 2 + 1, i * 2 + 0);\n        }\n    }\n    for (int i = 0 ; i < 2 * n ; i += 2) {\n        solver.addEdge(i * 2 + 0, (i + 1) * 2 + 1);\n        solver.addEdge((i + 1) * 2 + 0, i * 2 + 1);\n    }\n    solver.run();\n    if (solver.check()) {\n        cout << \"Yes\\n\";\n        auto ans = solver.construct();\n        for (int i = 0 ; i < 2 * n ; i += 2) {\n            if (ans[i])\n                cout << arr[i / 2].S << '\\n';\n            else\n                cout << arr[i / 2].F << '\\n';\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define rrep(i, n) for (int i = (int)n-1; i >= 0; --i)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\ntemplate<typename T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\nnamespace detail {\n    template<typename T, int N>\n    auto make_vec(vector<int>& sizes, T const& x) {\n        if constexpr (N == 1) {\n            return vector(sizes[0], x);\n        } else {\n            int size = sizes[N-1];\n            sizes.pop_back();\n            return vector(size, make_vec<T, N-1>(sizes, x));\n        }\n    }\n}\ntemplate<typename T, int N>\nauto make_vec(int const(&sizes)[N], T const& x = T()) {\n    vector<int> s(N);\n    for (int i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n    return detail::make_vec<T, N>(s, x);\n}\n__attribute__((constructor))\nvoid fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    auto x = make_vec<int>({n, 2});\n    rep(i, n) cin >> x[i][0] >> x[i][1];\n    two_sat ts(n);\n\n    auto ng = [&](int a, int b) { return abs(a - b) < d; };\n    rep(i, n) for (int j = i+1; j < n; ++j) {\n        rep(k, 2) rep(l, 2) {\n            if (ng(x[i][k], x[j][l])) {\n                ts.add_clause(i, 1-k, j, 1-l);\n            }\n        }\n    }\n    bool ans = ts.satisfiable();\n    if (ans) {\n        cout << \"Yes\\n\";\n        auto v = ts.answer();\n        rep(i, n) cout << x[i][v[i]] << '\\n';\n    } else {\n        cout << \"No\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(12), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nusing Int = long long;\nvector<int> scc(const vector<vector<int>> &G) {\n    int N = G.size();\n    vector<int> low(N), dfsnum(N, -1), comp(N, -1);\n    stack<int> L;\n    int num = 0, conum = 0;\n    auto visit = [&](auto&& visit, int p) -> void {\n        L.push(p);\n        low[p] = dfsnum[p] = num++;\n        for (int q : G[p]) {\n            if (comp[q] >= 0) continue;\n            if (dfsnum[q] < 0) {\n                visit(visit, q);\n                low[p] = min(low[p], low[q]);\n            } else {\n                low[p] = min(low[p], dfsnum[q]);\n            }\n        }\n        if (low[p] == dfsnum[p]) {\n            for (;;) {\n                int v = L.top(); L.pop();\n                comp[v] = conum;\n                if (v == p) break;\n            }\n            conum++;\n        }\n    };\n    for (int i = 0; i < N; i++) {\n        if (comp[i] < 0) visit(visit, i);\n    }\n    return comp;\n}\nstruct TwoSat {\n    int N;\n    vector<vector<int>> G;\n    TwoSat(int n) : N(n), G(2 * n) {}\n    int neg(int x) {\n        if (x < N) return x + N;\n        else return x - N;\n    }\n    void add_clause(int x, int y) {\n        G[neg(x)].push_back(y);\n        G[neg(y)].push_back(x);\n    }\n    vector<bool> satisfy() {\n        vector<bool> ans(N);\n        auto comp = scc(G);\n        for (int i = 0; i < N; i++) {\n            if (comp[i] == comp[i + N]) {\n                return {};\n            }\n            ans[i] = comp[i] < comp[i + N];\n        }\n        return ans;\n    }\n};\nint main() {\n    int N, D; cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    TwoSat ts(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            // !(i is X && j is X) == !(i && j) == !i || !j\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(ts.neg(i), ts.neg(j));\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(ts.neg(i), j);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, ts.neg(j));\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, j);\n            }\n        }\n    }\n    auto ans = ts.satisfy();\n    if (ans.empty()) {\n        cout << \"No\\n\";\n    } else {\n        cout << \"Yes\\n\";\n        for (int i = 0; i < N; i++) {\n            cout << (ans[i] ? X[i] : Y[i]) << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define per1(i,n) for(int i=n;i>0;i--)\n#define all(v) v.begin(), v.end()\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,d;\n    cin>>n>>d;\n    two_sat A(n);\n    vec x(n),y(n);\n    rep(i,n) cin>>x[i]>>y[i];\n    rep(i,n)for(int j=i+1;j<n;j++){\n        if(abs(x[i]-x[j])<d) A.add_clause(i,0,j,0);\n        if(abs(x[i]-y[j])<d) A.add_clause(i,0,j,1);\n        if(abs(y[i]-x[j])<d) A.add_clause(i,1,j,0);\n        if(abs(y[i]-y[j])<d) A.add_clause(i,1,j,1);\n    }\n    if(A.satisfiable()){\n        cout<<\"Yes\\n\";\n        auto B=A.answer();\n        rep(i,B.size()){\n            if(B[i]) cout<<x[i]<<\"\\n\";\n            else cout<<y[i]<<\"\\n\";\n        }\n    }\n    else cout<<\"No\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n//#define fr(i,j,k) for(int i=j;i<k;i++)\n//#define f(n) fr(i,0,n)\n//#define f1(n) fr(i,1,n+1)\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\nconst ll mod = 1e9 + 7;\nconst int maxn = 2e5+5;\n#include<atcoder/all>\nusing namespace atcoder;\nvoid solve() {\n    int n, d;\n    cin >> n >> d;\n    int x[n],y[n];\n    for (int i = 0 ; i < n ; i++) {\n        cin >> x[i] >> y[i];\n    }\n    two_sat g(n);\n    for (int i = 0 ; i < n ; i++) {\n        for (int j = i+1 ; j < n ; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                g.add_clause(i,false,j,false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                g.add_clause(i,false,j,true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                g.add_clause(i,true,j,false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                g.add_clause(i,true,j,true);\n            }\n        }\n    }\n    if (!g.satisfiable()) {\n        cout << \"No\\n\";\n        return;\n    }\n    auto res = g.answer();\n    cout << \"Yes\\n\";\n    for (int i = 0 ; i <n ; i++) {\n        cout << (res[i] ? x[i] : y[i]) << '\\n';\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int c = 0;\n    int t;\n    if (!c) {\n        t = 1;\n    }\n    else {\n        cin >> t;\n    }\n    while (t--) {\n        solve();\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << ' ' << H; debug_out(T...); }\n#define debug(...) cerr << 'L' << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << 'L' << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing ll = long long;\nusing ld = long double;\nusing Vi = V<int>;  using VVi = V<Vi>;\nusing Vl = V<ll>;   using VVl = V<Vl>;\nusing Vd = V<ld>;   using VVd = V<Vd>;\nusing Vb = V<bool>; using VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\n// template<typename T, int n> istream &operator>>(istream &is, array<T, n> &v) { rep(i, n) is >> v[i]; return is; }\n// template<typename T, int n> ostream &operator<<(ostream &os, const array<T, n> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline ll cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\nint main() {\n  int n, d; cin >> n >> d;\n  V<array<int, 2>> xy(n);\n  rep(i, n) cin >> xy[i][0] >> xy[i][1];\n\n  two_sat ts(n);\n\n  rep(i, n) rep2(j, i+1, n) {\n    rep(p, 2) rep(q, 2) {\n      if (abs(xy[i][p] - xy[j][q]) < d) ts.add_clause(i, p^1, j, q^1);\n    }\n  }\n\n  if (ts.satisfiable()) {\n    cout << \"Yes\\n\";\n    auto ans = ts.answer();\n    rep(i, n) cout << xy[i][ans[i]] << '\\n';\n  }\n  else cout << \"No\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                // not (x[i] : True and x[j] : True)\n                // equal \n                // (x[i] : False or x[j] : False)\n                // equal \n                // (y[i] : True or y[j] : True)              \n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();//[True or False] * len(ts.answer())\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n#include <random>\n\n#include <atcoder/all>\n\n#define FOR_LT(i, beg, end) for (decltype(end) i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (decltype(end) i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (decltype(beg) i = beg; end <= i; i--)\n#define REP(n)              for (decltype(n) repeat_index = 0; repeat_index < n; repeat_index++)\n\nusing namespace std;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(20);\n\n\tint n, d; cin >> n >> d;\n\tvector<pair<int64_t, int64_t>> ps(n); for (auto& p : ps) { cin >> p.first >> p.second; }\n\n\tatcoder::two_sat ts(n);\n\tFOR_LT(i, 0, n) {\n\t\tauto& sp = ps[i];\n\t\tFOR_LT(j, i + 1, n) {\n\t\t\tauto& tp = ps[j];\n\t\t\tif (abs(sp.first - tp.first) < d) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(sp.first - tp.second) < d) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(sp.second - tp.first) < d) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(sp.second - tp.second) < d) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tbool ret = ts.satisfiable();\n\tif (!ret) {\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"Yes\" << endl;\n\n\tauto ans = ts.answer();\n\tFOR_LT(i, 0, n) {\n\t\tif (ans[i]) cout << ps[i].first << endl;\n\t\telse cout << ps[i].second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <boost/hana/functional/fix.hpp>\n\ntemplate <typename T, typename = void>\nstruct is_iterable : std::false_type {};\ntemplate <typename T>\nstruct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),\n                                  decltype(std::end(std::declval<T>()))>>\n    : std::true_type {};\n\ntemplate <typename T, typename = void>\nstruct is_pair : std::false_type {};\ntemplate <typename T>\nstruct is_pair<T, std::void_t<decltype(std::declval<T>().first),\n                              decltype(std::declval<T>().second)>>\n    : std::true_type {};\n\ntemplate <typename T>\nvoid debug(const T& v) {\n  if constexpr (is_pair<T>::value) {\n    std::cerr << \"{\";\n    debug(v.first);\n    std::cerr << \", \";\n    debug(v.second);\n    std::cerr << \"}\";\n  } else if constexpr (is_iterable<T>::value &&\n                       !std::is_same<T, std::string>::value) {\n    std::cerr << \"{\";\n    for (auto it = std::begin(v); it != std::end(v); ++it) {\n      if (it != std::begin(v)) std::cerr << \", \";\n      debug(*it);\n    }\n    std::cerr << \"}\";\n  } else {\n    std::cerr << v;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid debug(const T& value, const Ts&... args) {\n  debug(value);\n  std::cerr << \", \";\n  debug(args...);\n}\n#if DEBUG\n#define dbg(...)                        \\\n  do {                                  \\\n    cerr << #__VA_ARGS__ << \": \";       \\\n    debug(__VA_ARGS__);                 \\\n    cerr << \" (L\" << __LINE__ << \")\\n\"; \\\n  } while (0)\n#else\n#define dbg(...)\n#endif\n\nvoid read_from_cin() {}\ntemplate <typename T, typename... Ts>\nvoid read_from_cin(T& value, Ts&... args) {\n  std::cin >> value;\n  read_from_cin(args...);\n}\n#define rd(type, ...) \\\n  type __VA_ARGS__;   \\\n  read_from_cin(__VA_ARGS__);\n#define ints(...) rd(int, __VA_ARGS__);\n#define strings(...) rd(string, __VA_ARGS__);\n\ntemplate <typename T>\nvoid write_to_cout(const T& value) {\n  if constexpr (std::is_same<T, bool>::value) {\n    std::cout << (value ? \"Yes\" : \"No\");\n  } else {\n    std::cout << value;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid write_to_cout(const T& value, const Ts&... args) {\n  write_to_cout(value);\n  std::cout << ' ';\n  write_to_cout(args...);\n}\n#define wt(...)                 \\\n  do {                          \\\n    write_to_cout(__VA_ARGS__); \\\n    cout << '\\n';               \\\n  } while (0)\n\n#define all(x) (x).begin(), (x).end()\n\n#define rep_dispatch(_1, _2, _3, name, ...) name\n\n#define rep3(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep1(n) rep2(_loop_variable_, n)\n#define rep(...) rep_dispatch(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)\n\n#define rrep3(i, a, b) for (int i = (int)(b)-1; i >= a; --i)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep1(n) rrep2(_loop_variable_, n)\n#define rrep(...) rep_dispatch(__VA_ARGS__, rrep3, rrep2, rrep1)(__VA_ARGS__)\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n  for (T& vi : v) is >> vi;\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T, typename U>\nbool chmax(T& a, U b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nbool chmin(T& a, U b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nT max(T a, U b) {\n  return a > b ? a : b;\n}\n\ntemplate <typename T, typename U>\nT mix(T a, U b) {\n  return a < b ? a : b;\n}\n\ntemplate <typename T>\nint sz(const T& v) {\n  return v.size();\n}\n\ntemplate <typename T>\nint popcount(T i) {\n  return std::bitset<std::numeric_limits<T>::digits>(i).count();\n}\n\nusing i64 = std::int64_t;\nusing i32 = std::int32_t;\n\ntemplate <typename T>\nusing low_priority_queue =\n    std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <typename T>\nusing V = std::vector<T>;\ntemplate <typename T>\nusing VV = V<V<T>>;\n\nvoid Main();\n\nint main() {\n  Main();\n  return 0;\n}\n\nconst auto& Fix = boost::hana::fix;\n\nusing namespace std;\n\n#define int i64\n\n#pragma once\n\ntemplate <typename T>\nstruct Edge {\n  int from, to;\n  T weight;\n};\n\ntemplate <typename T>\nclass Graph {\n public:\n  Graph(int n) : edges_(n) {}\n  void AddEdge(int from, int to, T weight = T()) {\n    edges_[from].push_back({from, to, weight});\n  }\n  const std::vector<Edge<T>>& Edges(int from) const { return edges_[from]; }\n  int NumVertices() const { return edges_.size(); }\n\n private:\n  std::vector<std::vector<Edge<T>>> edges_;\n};\n\ntemplate <typename T>\nstd::vector<std::vector<int>> StronglyConnectedComponents(\n    const Graph<T>& graph) {\n  int n = graph.NumVertices();\n  std::vector<int> nodes;\n  std::vector<bool> visited(n);\n  std::function<void(int)> dfs = [&](int u) {\n    visited[u] = true;\n    for (const Edge<T>& e : graph.Edges(u)) {\n      if (!visited[e.to]) {\n        dfs(e.to);\n      }\n    }\n    nodes.push_back(u);\n  };\n  for (int u = 0; u < n; ++u) {\n    if (!visited[u]) dfs(u);\n  }\n  std::vector<std::vector<int>> rgraph(n);\n  for (int u = 0; u < n; ++u) {\n    for (const Edge<T> e : graph.Edges(u)) {\n      rgraph[e.to].push_back(u);\n    }\n  }\n  std::vector<bool> rvisited(n);\n  std::vector<std::vector<int>> sccs;\n  std::function<void(std::vector<int>&, int)> rdfs = [&](std::vector<int>& scc,\n                                                         int u) {\n    rvisited[u] = true;\n    scc.push_back(u);\n    for (int v : rgraph[u]) {\n      if (!rvisited[v]) {\n        rdfs(scc, v);\n      }\n    }\n  };\n  for (int i = n - 1; i >= 0; --i) {\n    int u = nodes[i];\n    if (!rvisited[u]) {\n      std::vector<int> scc;\n      rdfs(scc, u);\n      sccs.push_back(scc);\n    }\n  }\n  return sccs;\n}\n\nvoid Main() {\n  ints(n, d);\n  V<int> x(n), y(n);\n  rep(i, n) cin >> x[i] >> y[i];\n\n  Graph<int> g(n * 2);\n\n  rep(i, n - 1) rep(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) {\n      // !i v !j = (i -> !j) ^ (j -> !i)\n      g.AddEdge(i, n + j);\n      g.AddEdge(j, n + i);\n    }\n    if (abs(x[i] - y[j]) < d) {\n      // !i v j = (i -> j) ^ (!j -> !i)\n      g.AddEdge(i, j);\n      g.AddEdge(n + j, n + i);\n    }\n    if (abs(y[i] - x[j]) < d) {\n      // i v !j = (!i -> !j) ^ (j -> i)\n      g.AddEdge(n + i, n + j);\n      g.AddEdge(j, i);\n    }\n    if (abs(y[i] - y[j]) < d) {\n      // i v j = (!i -> j) ^ (!j -> i)\n      g.AddEdge(n + i, j);\n      g.AddEdge(n + j, i);\n    }\n  }\n\n  VV<int> scc = StronglyConnectedComponents(g);\n  V<int> t(n), f(n);\n  rep(i, scc.size()) for (int j : scc[i]) {\n    if (j < n) {\n      t[j] = i;\n    } else {\n      f[j - n] = i;\n    }\n  }\n  bool ok = true;\n  V<int> v;\n  rep(i, n) {\n    if (t[i] == f[i]) {\n      ok = false;\n    } else {\n      v.push_back((t[i] > f[i] ? x : y)[i]);\n    }\n  }\n  wt(ok);\n  if (ok) {\n    for (int vi : v) wt(vi);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _DEBUG\n#include \"bits/stdc++.h\"\n#include <atcoder/all>\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,a4,x,...) x\n#define debug_1(x1) cout<<#x1<<\": \"<<x1<<endl\n#define debug_2(x1,x2) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<endl\n#define debug_3(x1,x2,x3) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<endl\n#define debug_4(x1,x2,x3,x4) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<endl\n#define debug_5(x1,x2,x3,x4,x5) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<\", \"#x5<<\": \"<<x5<<endl\n#ifdef _DEBUG\n#define debug(...) CHOOSE((__VA_ARGS__,debug_5,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n#define rep(index,num) for(int index=0;index<(int)num;index++)\n#define rep1(index,num) for(int index=1;index<=(int)num;index++)\n#define brep(index,num) for(int index=(int)num-1;index>=0;index--)\n#define brep1(index,num) for(int index=(int)num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nusing namespace atcoder;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=(ll)1e+18+1;\nint INF=1e+9+1;\nint main(){\n\tint N,D,X[1001][2];\n\tscan(N>>D);\n\trep(i,N){\n\t\tscan(X[i][0]>>X[i][1]);\n\t}\n\ttwo_sat ts(N);\n\trep(i,N){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\trep(k,2){\n\t\t\t\trep(l,2){\n\t\t\t\t\tif(abs(X[i][k]-X[j][l])<D){\n\t\t\t\t\t\tts.add_clause(i,!k,j,!l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ts.satisfiable()){\n\t\tprin(\"Yes\");\n\t\tauto ans=ts.answer();\n\t\trep(i,ans.size()){\n\t\t\tprin(X[i][ans[i]]);\n\t\t}\n\t}\n\telse prin(\"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<long long> VL;\ntypedef vector<vector<long long>> VVL;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define EXIST(m,v) (m).find((v)) != (m).end()\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconstexpr double EPS = 1e-9;\nconstexpr double PI  = 3.1415926535897932;\nconstexpr int INF = 2147483647;\nconstexpr long long LINF = 1LL<<60;\nconstexpr long long MOD = 1000000007; // 998244353;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n\nvoid Main(){\n    int N,D; cin >> N >> D;\n    VI X(N), Y(N); REP(i,N) cin >> X[i] >> Y[i];\n\n    two_sat ts(N);\n\n    REP(i,N-1)FOR(j,i+1,N){\n        if(abs(X[i]-X[j])<D) ts.add_clause(i,0,j,0);\n        if(abs(X[i]-Y[j])<D) ts.add_clause(i,0,j,1);\n        if(abs(Y[i]-X[j])<D) ts.add_clause(i,1,j,0);\n        if(abs(Y[i]-Y[j])<D) ts.add_clause(i,1,j,1);\n    }\n\n    if(!ts.satisfiable()) cout << \"No\" << en;\n    else{\n        cout << \"Yes\" << en;\n        vector<bool> ans = ts.answer();\n        REP(i,N) cout << (ans[i] ? X[i] : Y[i]) << en;\n    }\n    return;\n}\n\nint main(void){\n    cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);\n    int t=1; //cin>>t;\n    REP(_,t) Main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define range2(i,a,b) ((a)<=(i) && (i)<=(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct two_sat {\n  template <class E> struct csr {\n      std::vector<int> start;\n      std::vector<E> elist;\n      csr(int n, const std::vector<std::pair<int, E>>& edges)\n          : start(n + 1), elist(edges.size()) {\n          for (auto e : edges) {\n              start[e.first + 1]++;\n          }\n          for (int i = 1; i <= n; i++) {\n              start[i] += start[i - 1];\n          }\n          auto counter = start;\n          for (auto e : edges) {\n              elist[counter[e.first]++] = e.second;\n          }\n      }\n  };\n\n  // Reference:\n  // R. Tarjan,\n  // Depth-First Search and Linear Graph Algorithms\n  struct scc_graph {\n    public:\n      scc_graph(int n) : _n(n) {}\n\n      int num_vertices() { return _n; }\n\n      void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n      // @return pair of (# of scc, scc id)\n      std::pair<int, std::vector<int>> scc_ids() {\n          auto g = csr<edge>(_n, edges);\n          int now_ord = 0, group_num = 0;\n          std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n          visited.reserve(_n);\n          auto dfs = [&](auto self, int v) -> void {\n              low[v] = ord[v] = now_ord++;\n              visited.push_back(v);\n              for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                  auto to = g.elist[i].to;\n                  if (ord[to] == -1) {\n                      self(self, to);\n                      low[v] = std::min(low[v], low[to]);\n                  } else {\n                      low[v] = std::min(low[v], ord[to]);\n                  }\n              }\n              if (low[v] == ord[v]) {\n                  while (true) {\n                      int u = visited.back();\n                      visited.pop_back();\n                      ord[u] = _n;\n                      ids[u] = group_num;\n                      if (u == v) break;\n                  }\n                  group_num++;\n              }\n          };\n          for (int i = 0; i < _n; i++) {\n              if (ord[i] == -1) dfs(dfs, i);\n          }\n          for (auto& x : ids) {\n              x = group_num - 1 - x;\n          }\n          return {group_num, ids};\n      }\n\n      std::vector<std::vector<int>> scc() {\n          auto ids = scc_ids();\n          int group_num = ids.first;\n          std::vector<int> counts(group_num);\n          for (auto x : ids.second) counts[x]++;\n          std::vector<std::vector<int>> groups(ids.first);\n          for (int i = 0; i < group_num; i++) {\n              groups[i].reserve(counts[i]);\n          }\n          for (int i = 0; i < _n; i++) {\n              groups[ids.second[i]].push_back(i);\n          }\n          return groups;\n      }\n\n    private:\n      int _n;\n      struct edge {\n          int to;\n      };\n      std::vector<std::pair<int, edge>> edges;\n  };\n\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n\nvoid solve(){\n  int N,D;\n  cin >> N >> D;\n\n  vector<int> x(N),y(N);\n  REP(i,N) cin >> x[i] >> y[i];\n\n  two_sat ts(N);\n  \n  REP(i,N) FOR(j,i+1,N){\n    if(abs(x[i]-x[j]) < D) ts.add_clause(i,false,j,false);\n    if(abs(x[i]-y[j]) < D) ts.add_clause(i,false,j,true);\n    if(abs(y[i]-x[j]) < D) ts.add_clause(i,true,j,false);\n    if(abs(y[i]-y[j]) < D) ts.add_clause(i,true,j,true);\n  }\n\n  if(!ts.satisfiable()) cout << \"No\" << endl;\n  else{\n    cout << \"Yes\" << endl;\n    REP(i,N){\n      if(ts.answer()[i]) cout << x[i] << endl;\n      else cout << y[i] << endl;\n    }\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct StronglyConnectedComponent{\n  int n, comp_size;\n  vector<vector<int>> g, revg;\n  vector<int> comp, order, used;\n\n  StronglyConnectedComponent (int sz) {\n    n = sz;\n    g.resize(n); revg.resize(n);\n    comp.assign(n, -1);\n    used.assign(n, 0);\n  }\n\n  int operator[] (int u) {\n    return comp[u];\n  }\n\n  void add (int u, int v){\n    g[u].emplace_back(v);\n    revg[v].emplace_back(u);\n  }\n\n  void dfs (int u){\n    if (used[u]) return ;\n    used[u] = 1;\n    for (auto v : g[u]) dfs(v);\n    order.emplace_back(u);\n    return ;\n  }\n\n  void rdfs (int u, int k){\n    if (comp[u] != -1) return ;\n    comp[u] = k;\n    for (auto v : revg[u]) rdfs(v, k);\n    return ;\n  }\n\n  void build (vector<vector<int>> &ref){\n    for (int i = 0; i < n; i++) dfs(i);\n    reverse(order.begin(), order.end());\n    int cur = 0;\n    for (auto i : order) {\n      if (comp[i] == -1) {\n        rdfs(i, cur);\n        cur++;\n      }\n    }\n    ref.resize(cur);\n    for (int i = 0; i < g.size(); i++) {\n      for (auto j : g[i]) {\n        int u = comp[i], v = comp[j];\n        if (u == v) continue;\n        ref[u].emplace_back(v);\n      }\n    }\n  }\n\n};\n\nint main(){\n\n  int n, d;\n  cin >> n >> d;\n  StronglyConnectedComponent scc(2 * n);\n  vector<int> x(n), y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      //　x : 1, y : 0\n      if (i == j) continue;\n      if (abs(x[i] - x[j]) < d) scc.add(i, j + n);\n      if (abs(y[i] - x[j]) < d) scc.add(i + n, j + n);\n      if (abs(x[i] - y[j]) < d) scc.add(i, j);\n      if (abs(y[i] - y[j]) < d) scc.add(i + n, j);\n    }\n  }\n\n  vector<vector<int>> g;\n  scc.build(g);\n  for (int i = 0; i < n; i++) {\n    if (scc[i] == scc[i + n]) {\n      cout << \"No\" << endl;\n      return 0;\n    } \n  }\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < n; i++) cout << (scc[i] > scc[i + n] ? x[i] : y[i]) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\ntemplate<class T>bool chmax(T &a, const T &b) {if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if(b<a){a=b;return 1;}return 0;}\n\nstruct SCC{\n  vector<vector<int> > G,R,T,C;//T:強連結分解後のグラフ\n  vector<int> vs,used,blg;\n  SCC(int n):G(n),R(n),used(n),blg(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    R[v].emplace_back(u);\n  }\n\n  int size(){\n    return T.size();\n  }\n\n  void dfs(int v){\n    used[v]=1;\n    for(int u:G[v])\n      if(!used[u]) dfs(u);\n    vs.emplace_back(v);\n  }\n\n  void rdfs(int v,int k){\n    used[v]=1;\n    blg[v]=k;\n    C[k].emplace_back(v);\n    for(int u:R[v])\n      if(!used[u]) rdfs(u,k);\n  }\n\n  int build(){\n    int n=G.size();\n    for(int v=0;v<n;v++)\n      if(!used[v]) dfs(v);\n\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=n-1;i>=0;i--){\n      if(!used[vs[i]]){\n        T.emplace_back();\n        C.emplace_back();\n        rdfs(vs[i],k++);\n      }\n    }\n    for(int v=0;v<n;v++)\n      for(int u:G[v])\n        if(blg[v]!=blg[u])\n          T[blg[v]].push_back(blg[u]);\n\n    for(int i=0;i<k;i++){\n      sort(T[i].begin(),T[i].end());\n      T[i].erase(unique(T[i].begin(),T[i].end()),T[i].end());\n    }\n    return k;\n  }\n  int operator[](int k) const{return blg[k];};//頂点kの属する強連結成分\n};\n\nstruct TwoSat{\n  int n;\n  SCC scc;\n  TwoSat(int n):n(n),scc(n*2){}\n  int negate(int v){return (n+v)%(n*2);}\n  void add_if(int u,int v){\n    // u -> v <=> !v -> !u\n    scc.add_edge(u,v);\n    scc.add_edge(negate(v),negate(u));\n  }\n  void add_or(int u,int v){\n    // u or v <=> !u -> v\n    add_if(negate(u),v);\n  }\n  void add_nand(int u,int v){\n    // u nand v <=> u -> !v\n    add_if(u,negate(v));\n  }\n  void set_true(int v){\n    //  v <=> !v ->  v\n    scc.add_edge(negate(v),v);\n  }\n  void set_false(int v){\n    // !v <=>  v -> !v\n    scc.add_edge(v,negate(v));\n  }\n  vector<int> build(){//構築不可->空vector\n    scc.build();\n    vector<int> res(n);\n    for(int i=0;i<n;i++){\n      if(scc[i]==scc[n+i]) return {};\n      res[i]=scc[i]>scc[n+i];\n    }\n    return res;\n  }\n};\n\nint n,d;\nint x[2010],y[2010];\n\nvoid solve(){\n    cin >> n >> d;\n    TwoSat sat(n);\n    rep(i,n) cin >> x[i] >> y[i];\n    rep(i,n){\n        rep(j,n){\n            if(i==j) continue;\n            if(abs(x[i]-x[j])<d) sat.add_nand(i,j);\n            if(abs(x[i]-y[j])<d) sat.add_nand(i,sat.negate(j));\n            if(abs(y[i]-x[j])<d) sat.add_nand(sat.negate(i),j);\n            if(abs(y[i]-y[j])<d) sat.add_nand(sat.negate(i),sat.negate(j));\n        }\n    }\n    vector<int> ans=sat.build();\n    if(ans.empty()) {\n        cout << \"No\" << endl;\n        return;\n    }\n    cout << \"Yes\" << endl;\n    rep(i,n){\n        cout << (ans[i]?x[i]:y[i]) << endl;\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n// #define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n\nvoid solve() {\n    int n, d; cin >> n >> d;\n    two_sat ts(n);\n    vec x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    \n    rep(i, n){\n        Rep(j, i+1, n){\n            if(abs(x[i]-x[j]) < d) ts.add_clause(i, false, j, false);\n            if(abs(x[i]-y[j]) < d) ts.add_clause(i, false, j, true);\n            if(abs(y[i]-x[j]) < d) ts.add_clause(i, true, j, false);\n            if(abs(y[i]-y[j]) < d) ts.add_clause(i, true, j, true);\n        }\n    }\n    if(!ts.satisfiable()) cout << \"No\" << endl;\n    else{\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, n){\n            if(ans[i]){\n                cout << x[i] << endl;\n            }else{\n                cout << y[i] << endl;\n            }\n        }\n    }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>; using vi = vector<int>; using vvi = vector<vi>; using vl = vector<ll>; using vvl = vector<vl>;\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\nusing namespace atcoder;\n\n// 旗iの座標をFiとする。\n// Fi=Xi or Fi=Yi である。\n// (Fi=Xi or Fj=Xj) は (Fi=Yi → Fj=Xj) と同値。\n// 対偶を取ると，Fj=Yj → Fi=Xi と更に同値。\n// i=0,1,...,N-1に対し，\n// (1)|Xi-Xj|<D のとき (Fi=Xi → Fj=Yj) i.e. (Fi=Yi or Fj=Yj) というクローズを加え，\n// (2)|Xi-Yj|<D のとき (Fi=Xi → Fj=Xj) i.e. (Fi=Yi or Fj=Xj) というクローズを加え，\n// (3)|Yi-Yj|<D のとき (Fi=Yi → Fj=Xj) i.e. (Fi=Xi or Fj=Xj) というクローズを加え，\n// (4)|Yi-Xj|<D のとき (Fi=Yi → Fj=Yj) i.e. (Fi=Xi or Fj=Yj) というクローズを加える。 ※(2)でカバー済\n// Fi=Xiであることをtrueで，Fi=Yiであることをfalseで表す。\n\nint main() {\n\tint N, D; cin >> N >> D;\n\tvi X(N), Y(N); rep(i, N) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\trep(i, N - 1) rep2(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\tif (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t\tif (abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> v = ts.answer();\n\t\trep(i, N) cout << (v[i] ? X[i] : Y[i]) << endl;\n\t\t// for (auto e : ts.answer()) {\n\t\t// \tdbl(e);\n\t\t// }\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nstruct SCC{\n  ll n;\n  vector<vector<ll>>&G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>&g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,bool tx,ll y,bool ty){//x+n:true x:false\n    g[x+!tx*n].push_back(y+ty*n);\n    g[y+!ty*n].push_back(x+tx*n);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] < scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,d;cin>>n>>d;\n  auto v=vec(n,2,0LL);\n  rep(i,0,n)cin>>v[i][0]>>v[i][1];\n  TwoSat sat(n);\n  rep(i,0,n)rep(ti,0,2)rep(j,i+1,n)rep(tj,0,2){\n    if(abs(v[i][ti]-v[j][tj])<d){\n      sat.add_or(i,!ti,j,!tj);\n    }\n  }\n  judge=sat.solve(true);\n  ans1(judge);\n  if(judge){\n    rep(i,0,n)cout<<v[i][sat.ans[i]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\nusing mInt = modint998244353;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000\n\n\n\nint main(){\n\t\n\tint N,D;\n\tcin>>N>>D;\n\t\n\tvector<int> X(2*N);\n\trep(i,2*N)cin>>X[i];\n\t\n\ttwo_sat S(2*N);\n\t\n\trep(i,N){\n\t\tS.add_clause(i*2,true,i*2+1,true);\n\t\tS.add_clause(i*2,false,i*2+1,false);\n\t}\n\t\n\trep(i,2*N){\n\t\trep(j,2*N){\n\t\t\tif(i<j&&abs(X[i]-X[j])<D){\n\t\t\t\tS.add_clause(i,false,j,false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(S.satisfiable()){\n\t\tcout<<\"Yes\"<<endl;\n\t\tvector<bool> ans = S.answer();\n\t\trep(i,ans.size()){\n\t\t\tif(ans[i])cout<<X[i]<<endl;\n\t\t}\n\t}\n\telse{\n\t\tcout<<\"No\"<<endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <utility>\n#include <vector>\n#include <atcoder/all>\n\ntemplate <class InputIterator>\nstd::ostream& range_output(std::ostream& os_arg, InputIterator first_arg, InputIterator last_arg){ if(first_arg != last_arg){ do{ os_arg << *(first_arg++); if(first_arg == last_arg) break; os_arg << ' '; } while(true); }  return os_arg; }\ntemplate <class Tp> std::ostream& operator << (std::ostream& os_arg, const std::vector<Tp>& arr_arg){ return range_output(os_arg, arr_arg.cbegin(), arr_arg.cend()); }\ntemplate <class Tp, std::size_t Size> std::ostream& operator << (std::ostream& os_arg, const std::array<Tp, Size>& arr_arg){ return range_output(os_arg, arr_arg.cbegin(), arr_arg.cend()); }\ntemplate <class S, class T> std::ostream& operator << (std::ostream& os_arg, const std::pair<S, T>& pair_arg){ return os_arg << '(' << pair_arg.first << \", \" << pair_arg.second << ')'; }\n\n#ifndef ONLINE_JUDGE\n    template <typename Head> void dump_out(Head head_arg){ std::cerr << head_arg << '\\n'; }\n    template <typename Head, typename... Tail>\n    void dump_out(Head head_arg, Tail... tail_args){ std::cerr << head_arg << \", \"; dump_out(tail_args...); }\n    #define dump(...) do { std::cerr << \"[in line \" << __LINE__ << \"] \" << #__VA_ARGS__ << \" : \"; dump_out(__VA_ARGS__); } while(false)\n#else\n    #define dump(...) (void(0))\n#endif\n\n\n\n\nint main(void){\n    std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); \n    std::cout << std::fixed << std::setprecision(16);\n    int n, d; std::cin >> n >> d;\n    std::vector<int> x(n), y(n);\n    for(int i = 0; i < n; ++i) std::cin >> x[i] >> y[i];\n    atcoder::two_sat TS(n);\n    const auto social_distance = [&](int a, int b){\n        const int dis = a - b;\n        return dis <= -d or dis >= d;\n    };\n    for(int i = 0; i < n; ++i) for(int j = i + 1; j < n; ++j){\n        if(not social_distance(x[i], x[j])) TS.add_clause(i, false, j, false);\n        if(not social_distance(x[i], y[j])) TS.add_clause(i, false, j, true);\n        if(not social_distance(y[i], x[j])) TS.add_clause(i, true, j, false);\n        if(not social_distance(y[i], y[j])) TS.add_clause(i, true, j, true);\n    } \n    if(not TS.satisfiable()){ std::cout << \"No\\n\"; return 0; }\n    std::cout << \"Yes\\n\";\n    const auto v = TS.answer();\n    for(int i = 0; i < n; ++i){\n        if(v[i]) std::cout << x[i] << '\\n';\n        else     std::cout << y[i] << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n \n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define INF 1001001001\n#define MAX 1e18\n\nconst int mod = 998244353;\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n\n  two_sat ts(n);\n  rep(i,n) for (int j = i+1; j < n; j++) {\n    if (abs(x[i]-x[j]) < d) ts.add_clause(i,false,j,false);\n    if (abs(x[i]-y[j]) < d) ts.add_clause(i,false,j,true);\n    if (abs(y[i]-x[j]) < d) ts.add_clause(i,true,j,false);\n    if (abs(y[i]-y[j]) < d) ts.add_clause(i,true,j,true);\n  }\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  vector<bool> res = ts.answer();\n  cout << \"Yes\" << endl;\n  rep(i,n) cout << (res[i]?x[i]:y[i]) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"atcoder/all\"\nusing namespace std;\nusing namespace atcoder;\n\n///////////////////////////////////////////\nconst long long int INF = 1LL<<60;\nconst long long int Mod = 1000000007;\nusing ll = long long int; using ci = const int;\nusing vi = vector<int>;  using Vi = vector<long long int>;\nusing P = pair<int, int>;  using PLL = pair<ll, ll>;\nusing matrix = vector<vector<ll>>;\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define all(x) (x).begin(),(x).end()\n#define rp(i,N) for(ll i = 0; i < (ll)N; i++)\n#define repi(i,a,b) for(ll i = ll(a); i < ll(b); ++i)\ntemplate<class T>bool chmax(T &former, const T &b) { if (former<b) { former=b; return true; } return false; }\ntemplate<class T>bool chmin(T &former, const T &b) { if (b<former) { former=b; return true; } return false; }\ntemplate<class T>T sqar(T x){ return x*x; }//sqrt(x)は平方根;\n#define Sort(v) std::sort(v.begin(), v.end(), std::greater<decltype(v[0])>()) //降順でVをソート\n#define p_queue(v) priority_queue<v, vector<v>, greater<v> >\ntemplate<class T> inline void princ(T x){cout<<x<<\" \";}; \ntemplate<class T> inline void print(T x){cout<<x<<\"\\n\";};\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\n///////////////////////////////////////////////////////////////////////////////////\n\nvoid solve(){\n    ll n,d;\n    cin >> n >> d;\n    Vi x(n),y(n);\n    rp(i,n) cin >> x[i] >> y[i];\n    two_sat ts(n);\n    rp(i,n){\n        repi(j,i+1,n){\n            if(abs(x[i]-x[j]) < d){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(x[i]-y[j]) < d){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(y[i]-x[j]) < d){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(y[i]-y[j]) < d){\n                ts.add_clause(i,true,j,true);\n            }           \n        }\n    }\n    if(!ts.satisfiable()){\n        print(\"No\");\n        return;\n    }\n    print(\"Yes\");\n    vector<bool> ans=ts.answer();\n    rp(i,n){\n        if(ans[i]) print(x[i]);\n        else print(y[i]);\n    }\n    return;\n}\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    std::cout<<std::fixed<<std::setprecision(30);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n\n#include <atcoder/all>\n\nusing namespace atcoder;\nusing namespace std;\nusing lint = long long;\nusing P = pair<lint, lint>;\n\n#define rep(i, n) for (lint i = 0; i < (n); ++i)\n#define rep1(i, n) for (lint i = 1; i < (n); ++i)\n#define repn(i, a, b) for(lint i = (a); i < (b); ++i)\n#define rep_inv(i, n) for (lint i = (n); i >= 0; --i)\n#define rep_inv1(i, n) for(lint i = (n); i >= 1; --i)\n#define all(vec) (vec).begin(), (vec).end()\n#define cend printf(\"\\n\")\n\nconstexpr lint Mod = /**/ 1000'000'007LL /*/ 998'244'353LL /**/;\nconstexpr lint Inf = 4'500'000'000'000'000'007LL; //4.5e18+7\nconstexpr double Pi = 3.141592653589793;\n\ntemplate<class T> using prique     = priority_queue<T>;\ntemplate<class T> using prique_inv = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline istream& operator>>(istream& is, vector<T>& v) { for (auto& e : v) is >> e; return is; }\ntemplate<class T> inline ostream& operator<<(ostream& os, const vector<T>& v) {\n\tsize_t i = 0, n = v.size();\n\tfor (const auto& e : v) {\n\t\tos << e;\n\t\tif (i + 1 < n) os << \" \";\n\t\t++i;\n\t}\n\treturn os;\n}\ntemplate<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& rhs) { return is >> rhs.first >> rhs.second; }\ntemplate<class T, class U> inline ostream& operator<<(ostream& os, const pair<T, U>& rhs) { return os << \"{\" << rhs.first << \", \" << rhs.second << \"}\"; }\ntemplate<class T, class U> inline void print(const T& a, const U& b, bool f) {\n\tif (f) cout << a << \"\\n\";\n\telse cout << b << \"\\n\";\n}\ntemplate<class InputIterator> void arrin(InputIterator first, InputIterator last) { for (; first != last; ++first) cin >> (*first); }\ntemplate<class InputIterator> void arrout(InputIterator first, InputIterator last) {\n\tfor (; first != last; ++first) {\n\t\tcout << (*first) << ((first + 1) != last ? \" \" : \"\\n\");\n\t}\n}\n\nbool pri(lint x) { \n\tfor (lint i = 2; i * i <= x; ++i) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn 1 < x; \n}\n\nlint fact[3'000'000];\nvoid fact_init(lint n, lint m = Mod) {\n\tif (3'000'000 <= n) return;\n\tfact[0] = fact[1] = 1;\n\tfor (lint i = 2; i <= n; ++i) {\n\t\tfact[i] = i * fact[i - 1] % m;\n\t}\n}\n\nlint modpow(lint x, lint n, lint m = Mod) {\n\tlint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % m;\n\t\tx = x * x % m;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlint intpow(lint x, lint n) {\n\tlint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlint comb(lint n, lint r, lint m = Mod) {\n\tif (r == 0 || r == n) return 1;\n\tlint res = fact[n] * modpow(fact[n - r], m - 2, m) % m * modpow(fact[r], m - 2, m) % m;\n\treturn res < 0 ? res + m : res;\n}\n\nmap<lint, lint> factring(lint n) {\n\tmap<lint, lint> res;\n\tfor (lint i = 2; i * i <= n; ++i) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\t++res[i];\n\t\t}\n\t}\n\tif (n != 1) ++res[n];\n\treturn res;\n}\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\n\tvector<int>x(n), y(n);\n\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\ttwo_sat ts(n);\n\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\tif (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n\t\t\tif (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n\t\t\tif (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n\t\t\tif (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n\t\t}\n\t}\n\n\tif (!ts.satisfiable()) cout << \"No\\n\";\n\telse {\n\t\tconst auto& ans = ts.answer();\n\t\tfor (int i = 0;  bool b : ans) {\n\t\t\tif (b) cout << x[i] << \"\\n\";\n\t\t\telse cout << y[i] << \"\\n\";\n\t\t\t++i;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <atcoder/twosat>\n\nnamespace ac = atcoder;\n\nvoid solve() {\n    int n, d;\n    std::cin >> n >> d;\n\n    std::vector<int> xs(n * 2);\n    for (auto& x : xs) std::cin >> x;\n\n    ac::two_sat ts(n * 2);\n    for (int i = 0; i < n * 2; i += 2) {\n        ts.add_clause(i, true, i + 1, true);\n        ts.add_clause(i, false, i + 1, false);\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (std::abs(xs[i] - xs[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        std::cout << \"No\\n\";\n        return;\n    }\n\n    std::cout << \"Yes\\n\";\n    auto ans = ts.answer();\n    for (int i = 0; i < n * 2; ++i) {\n        if (ans[i]) std::cout << xs[i] << \"\\n\";\n    }\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate <typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate <typename V, typename T> void ndfill(V &x, const T &val) { x = val; }\ntemplate <typename V, typename T> void ndfill(vector<V> &vec, const T &val) { for (auto &v : vec) ndfill(v, val); }\ntemplate <typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate <typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate <typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate <typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate <typename T> vector<T> srtunq(vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }\n#if __cplusplus >= 201703L\ntemplate <typename... T> istream &operator>>(istream &is, tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <typename... T> ostream &operator<<(ostream &os, const tuple<T...> &tpl) { std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os; }\n#endif\ntemplate <typename T> ostream &operator<<(ostream &os, const deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << '(' << pa.first << ',' << pa.second << ')'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\n#ifdef HITONANODE_LOCAL\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl\n#else\n#define dbg(x)\n#endif\n\n// Directed graph library to find strongly connected components （強連結成分分解）\n// 0-indexed directed graph\n// Complexity: O(V + E)\nstruct DirectedGraphSCC {\n    int V; // # of Vertices\n    std::vector<std::vector<int>> to, from;\n    std::vector<int> used;  // Only true/false\n    std::vector<int> vs;\n    std::vector<int> cmp;\n    int scc_num = -1;\n\n    DirectedGraphSCC(int V = 0) : V(V), to(V), from(V), cmp(V) {}\n\n    void _dfs(int v) {\n        used[v] = true;\n        for (auto t : to[v]) if (!used[t]) _dfs(t);\n        vs.push_back(v);\n    }\n    void _rdfs(int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for (auto t : from[v]) if (!used[t]) _rdfs(t, k);\n    }\n\n    void add_edge(int from_, int to_) {\n        assert(from_ >= 0 and from_ < V and to_ >= 0 and to_ < V);\n        to[from_].push_back(to_);\n        from[to_].push_back(from_);\n    }\n\n    // Detect strongly connected components and return # of them.\n    // Also, assign each vertex `v` the scc id `cmp[v]` (0-indexed)\n    int FindStronglyConnectedComponents() {\n        used.assign(V, false);\n        vs.clear();\n        for (int v = 0; v < V; v++) if (!used[v]) _dfs(v);\n        used.assign(V, false);\n        scc_num = 0;\n        for (int i = (int)vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) _rdfs(vs[i], scc_num++);\n        return scc_num;\n    }\n\n    // Find and output the vertices that form a closed cycle.\n    // output: {v_1, ..., v_C}, where C is the length of cycle,\n    //         {} if there's NO cycle (graph is DAG)\n    std::vector<int> DetectCycle()\n    {\n        int ns = FindStronglyConnectedComponents();\n        if (ns == V) return {};\n        std::vector<int> cnt(ns);\n        for (auto x : cmp) cnt[x]++;\n        const int c = std::find_if(cnt.begin(), cnt.end(), [](int x) { return x > 1; }) - cnt.begin();\n        const int init = std::find(cmp.begin(), cmp.end(), c) - cmp.begin();\n        used.assign(V, false);\n        std::vector<int> ret;\n        auto dfs = [&](auto &&dfs, int now, bool b0) -> bool {\n            if (now == init and b0) return true;\n            for (auto nxt : to[now]) if (cmp[nxt] == c and !used[nxt])\n            {\n                ret.emplace_back(nxt), used[nxt] = 1;\n                if (dfs(dfs, nxt, true)) return true;\n                ret.pop_back();\n            }\n            return false;\n        };\n        dfs(dfs, init, false);\n        return ret;\n    }\n\n    // After calling `FindStronglyConnectedComponents()`, generate a new graph by uniting all vertices\n    // belonging to the same component(The resultant graph is DAG).\n    DirectedGraphSCC GenerateTopologicalGraph() {\n        DirectedGraphSCC newgraph(scc_num);\n        for (int s = 0; s < V; s++) for (auto t : to[s]) {\n            if (cmp[s] != cmp[t]) newgraph.add_edge(cmp[s], cmp[t]);\n        }\n        return newgraph;\n    }\n};\n\n// 2-SAT solver: Find a solution for  `(Ai v Aj) ^ (Ak v Al) ^ ... = true`\n// - `nb_sat_vars`: Number of variables\n// - Considering a graph with `2 * nb_sat_vars` vertices\n// - Vertices [0, nb_sat_vars) means `Ai`\n// - vertices [nb_sat_vars, 2 * nb_sat_vars) means `not Ai`\nstruct SATSolver : DirectedGraphSCC {\n    int nb_sat_vars;\n    std::vector<int> solution;\n    SATSolver(int nb_variables = 0) : DirectedGraphSCC(nb_variables * 2), nb_sat_vars(nb_variables), solution(nb_sat_vars) {}\n    void add_x_or_y_constraint(bool is_x_true, int x, bool is_y_true, int y) {\n        assert(x >= 0 and x < nb_sat_vars);\n        assert(y >= 0 and y < nb_sat_vars);\n        if (!is_x_true) x += nb_sat_vars;\n        if (!is_y_true) y += nb_sat_vars;\n        add_edge((x + nb_sat_vars) % (nb_sat_vars * 2), y);\n        add_edge((y + nb_sat_vars) % (nb_sat_vars * 2), x);\n    }\n    // Solve the 2-SAT problem. If no solution exists, return `false`.\n    // Otherwise, dump one solution to `solution` and return `true`.\n    bool run() {\n        FindStronglyConnectedComponents();\n        for (int i = 0; i < nb_sat_vars; i++) {\n            if (cmp[i] == cmp[i + nb_sat_vars]) return false;\n            solution[i] = cmp[i] > cmp[i + nb_sat_vars];\n        }\n        return true;\n    }\n};\n\nint main()\n{\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    REP(i, N) cin >> X[i] >> Y[i];\n    SATSolver solver(N);\n    REP(i, N) REP(j, i)\n    {\n        int d00 = abs(X[i] - X[j]) >= D;\n        int d01 = abs(X[i] - Y[j]) >= D;\n        int d11 = abs(Y[i] - Y[j]) >= D;\n        int d10 = abs(Y[i] - X[j]) >= D;\n        if (!d00) solver.add_x_or_y_constraint(1, i, 1, j);\n        if (!d01) solver.add_x_or_y_constraint(1, i, 0, j);\n        if (!d11) solver.add_x_or_y_constraint(0, i, 0, j);\n        if (!d10) solver.add_x_or_y_constraint(0, i, 1, j);\n    }\n    auto ret = solver.run();\n    if (!ret) puts(\"No\");\n    else\n    {\n        cout << \"Yes\\n\";\n        REP(i, N) cout << (solver.solution[i] ? Y[i] : X[i]) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n///*\n#include <atcoder/all>\nusing namespace atcoder;\n//*/\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\n\n\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\nconst ll mod = 1000000007ll;\n//const ll mod = 10000000000ll;\n//const ll mod = 10000;\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n#define rep(i, n)         for(ll i = 0; i < (ll)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define bbrep(n)           for(int bbit=0;bbit<(1<<n);bbit++)\n#define erep(i,container) for (auto &i : container)\n#define itrep(i,container) for (auto i : container)\n#define irep(i, n)        for(ll i = n-1; i >= (ll)0ll; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n//#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n#define vout(a) erep(qxqxqx,a)std::cout << qxqxqx << ' ';std::cout  << std::endl;\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n//#define vvector(name,typ,m,n)vector<vector<typ> > name(m,vector<typ> (n))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\":\"\n#define RES(a,i,j) a.resize(i);rep(ii,i)a[ii].resize(j);\n#define RESRES(a,i,j,k) a.resize(i);rep(ii,i)a[ii].resize(j);reprep(ii,jj,i,j){dp[ii][jj].resize(k)};\n#define res resize\n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define ppppri(a,b,c,d) std::cout << a<<\" \"<<b <<\" \"<< c<<' '<<d<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define SUM(a) accumulate(all(a),0ll) \n#define stirng string\n#define gin(a,b) int a,b;std::cin >> a>>b;a--;b--;\n#define popcount __builtin_popcount\n#define permu(a) next_permutation(all(a))\n//#define grid_input(a,type) int h,w;std::cin >> h>>w;vvector(a,type,h,w,0);reprep(i,j,h,w)std::cin >> a[i][j];\n\n//typedef long long T;\nll ceil(ll a,ll b){\n    return ((a+b-1)/b);\n}\nconst int INF = 2000000000;\n//const ll INF64 =3223372036854775807ll;\n//const ll INF64 = 9223372036854775807ll;\nconst ll INF64 = 9223372036854775ll;\nconst ll MOD = 1000000007ll;\n//const ll MOD = 1000003ll;\nconst ll OD = 1000000000000007ll;\nconst dou pi=3.141592653589793;\nlong long modpow(long long a, long long n,ll MOD) { //累乗の余剰\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\n\n//メモ\n//ゲーム(Grundy数とか)の復習をする\n//群論の勉強をする？\n//ドツボにハマったら頑張って今までの思考をリセットする\n//学会のスライドを作る(水曜日まで)\n//周期性の実験をする\n//リスニング力をどうにかする\n//GT学会の会費を払う\n/*\n#include <atcoder/all>\nusing namespace atcoder;\n*/\n/*\n#include <atcoder/all>\nusing namespace atcoder;\n*/\n\n\nint main(){\n    int n,d;\n    std::cin >> n>>d;\n    two_sat ts(n);\n    std::vector<int> a(n),b(n);\n    rep(i,n)std::cin >> a[i]>>b[i];\n    rep(i,n){\n        rep(j,n){\n            if(i==j)continue;\n            if(abs(a[i]-a[j])<d)ts.add_clause(i,0,j,0);\n            if(abs(a[i]-b[j])<d)ts.add_clause(i,0,j,1);\n            if(abs(b[i]-a[j])<d)ts.add_clause(i,1,j,0);\n            if(abs(b[i]-b[j])<d)ts.add_clause(i,1,j,1);\n        }\n        \n    }\n    if(ts.satisfiable()){\n        std::cout << Yes << std::endl;\n        std::vector<bool> ans=ts.answer();\n        rep(i,n){\n            if(ans[i])std::cout << a[i] << std::endl;\n            else std::cout << b[i] << std::endl;\n        }\n    }  \n    else{\n        std::cout << No << std::endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\n#define debug_value(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << #x << \"=\" << x << endl;\n#define debug(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << x << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N_MAX = 200000;\nint N;\nbool used[N_MAX];\nint idx[N_MAX];\nvector<int> vs;\nvector<int> buf;\nvector<int> G[N_MAX];\nvector<int> G_inv[N_MAX];\nvector<vector<int>> ans;\n\nvoid clear(){\n    for(int i = 0; i < N; i++) used[i] = false;\n}\n\nvoid dfs1(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        if(!used[G[v][i]]) dfs1(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid dfs2(int v, int k){\n    used[v] = true;\n    idx[v] = k;\n    for(int i = 0; i < G_inv[v].size(); i++){\n        if(!used[G_inv[v][i]]) dfs2(G_inv[v][i], k);\n    }\n    buf.push_back(v);\n}\n\nvoid scc(){\n    for(int i = 0; i < N; i++){\n        if(!used[i]) dfs1(i);\n    }\n    clear();\n    int cur = 0;\n    for(int i = vs.size()-1; i >= 0; i--){\n        if(!used[vs[i]]) {\n            dfs2(vs[i], cur);\n            cur++;\n            ans.push_back(buf);\n            buf.clear();\n        }\n    }\n}\n\nll X[1000], Y[1000];\nll D;\n\nint scc_idx[2000];\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int n; cin >> n >> D;\n    N = 2*n;\n    for(int i = 0; i < n; i++) cin >> X[i] >> Y[i];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == j) continue;\n            ll d1 = abs(X[i]-X[j]);\n            ll d2 = abs(X[i]-Y[j]);\n            \n            if(d1 < D && d2 < D) {\n                G[i].push_back(n+i);\n                G_inv[n+i].push_back(i);\n            }else if(d1 < D){\n                G[i].push_back(j+n);\n                G_inv[j+n].push_back(i);\n            }else if(d2 < D){\n                G[i].push_back(j);\n                G_inv[j].push_back(i);\n            }\n\n            ll d3 = abs(Y[i]-X[j]);\n            ll d4 = abs(Y[i]-Y[j]);\n            if(d3 < D && d4 < D) {\n                G[n+i].push_back(i);\n                G_inv[i].push_back(n+i);\n            }else if(d3 < D){\n                G[n+i].push_back(j+n);\n                G_inv[j+n].push_back(n+i);\n            }else if(d4 < D){\n                G[n+i].push_back(j);\n                G_inv[j].push_back(n+i);\n            }\n        }\n    }\n    scc();\n    for(int idx = 0; idx < ans.size(); idx++){\n        for(int i : ans[idx]){\n            scc_idx[i] = idx;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(scc_idx[i] == scc_idx[i+n]){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    for(int i = 0; i < n; i++){\n        if(scc_idx[i] < scc_idx[i+n]){\n            cout << Y[i] << endl;\n        }else{\n            cout << X[i] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define int long long\n#define sint signed\n#define endl \"\\n\" // fflush(stdout);\n#define ALL(v) (v).begin(),(v).end()\n#define Vi vector<int>\n#define VVi vector<Vi>\n#define VVVi vector<VVi>\n#define Vm vector<mint>\n#define Vs vector<string>\n#define Vd vector<double>\n#define Vc vector<char>\n#define Pii pair<int,int>\n#define Pdd pair<double,double>\n#define VPii vector<Pii>\n#define Tiii tuple<int,int,int>\n#define VTiii vector<Tiii>\n#define PQi priority_queue<int>\n#define PQir priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define itos to_string\n#define stoi stoll\n#define FI first\n#define SE second\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define cyes cout<<\"yes\"<<endl\n#define cno cout<<\"no\"<<endl\n#define sortr(v) sort(v,greater<>())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repeq(i,a,b) for(int i=a;i<=b;i++)\n#define repreq(i,a,b) for(int i=a;i>=b;i--)\n#define dem(a,b) ((a+b-1)/(b))\n#define INF 3000000000000000000 // 3.0*10^18\n#define MAX LLONG_MAX\n#define PI acos(-1.0L)\nconst int MOD = 998244353; // case\n//const int MOD = 1000000007; // 10^9 + 7\nconst double EPS = 1e-6;\n\nusing namespace std;\nusing namespace atcoder;\n\n/* debug */\ntemplate <typename T> // vector\nostream& operator<<(ostream& os,const vector<T> &V){int N=V.size();\nif(N==0){os<<'.';return os;}rep(i,0,N-1){os<<V[i]<<' ';}os<<V[N-1];return os;}\ntemplate <typename T> // vector vector\nostream& operator<<(ostream& os,const vector<vector<T>> &V){\nint N=V.size();rep(i,0,N-1)cout<<V[i]<<endl;cout<<V[N-1];return os;}\ntemplate <typename T,typename S> // pair\nostream& operator<<(ostream& os, pair<T,S> const&P){os<<P.FI<<' '<<P.SE;return os;}\ntemplate <typename T> // set\nostream& operator<<(ostream& os,set<T> &S){auto it=S.begin();while(it!=S.end()){\nos<<*it;if(next(it,1)!=S.end())os<<' ';it++;};return os;}\ntemplate <typename T> // deque\nostream& operator<<(ostream& os, deque<T> &q){for(auto it=q.begin();it<q.end();it++){\nos<<*it;if(it+1!=q.end())os<<\" \";}return os;}\n\n/* useful */\ntemplate<typename T>void Vin(vector<T> &v){int n=v.size();rep(i,0,n)cin>>v[i];}\nint scomb(int n, int r){if(r<0||r>n)return 0;if((n-r)<r)r=n-r; // nCr\nint a=1;for(int i=n;i>n-r;--i){a=a*i;}for(int i=1;i<r+1;++i){a=a/i;}return a;}\nVi vis(Vi &v){Vi S(v.size()+1);rep(i,1,S.size())S[i]+=v[i-1]+S[i-1];return S;}\nint digit_sum(int n){int ret=0; while(n>0){ret+=n%10;n/=10;}return ret;}\nint digit(int k,int i){string s = itos(k);return s[s.size()-i]-'0';} // i桁目の数字\ntemplate<typename T>void press(T &v){v.erase(unique(ALL(v)),v.end());} // 圧縮\nVi zip(Vi b){int Z=b.size(); // 座標圧縮\nPii p[Z+10];int a=b.size();Vi l(a);for(int i=0;i<a;i++)\np[i]=mp(b[i],i);sort(p,p+a);int w=0;for(int i=0;i<a;i++)\n{if(i&&p[i].first!=p[i-1].first)w++;l[p[i].second]=w;}return l;}\nint modiv(int a,int b){return a*pow_mod(b,MOD-2,MOD)%MOD;} // a÷b(%MOD)\nint SMALLER(Vi &a,int x){return lower_bound(a.begin(),a.end(),x)-a.begin();}\nint orSMALLER(Vi &a,int x){return upper_bound(a.begin(),a.end(),x)-a.begin();}\nint BIGGER(Vi &a,int x){return a.size()-orSMALLER(a,x);}\nint orBIGGER(Vi &a,int x){return a.size()-SMALLER(a,x);}\nint COUNT(Vi &a,int x) {return upper_bound(ALL(a),x)-lower_bound(ALL(a),x);}\nint maxind(Vi &a){return max_element(ALL(a))-a.begin();}\nint minind(Vi &a){return min_element(ALL(a))-a.begin();}\nVi nibe2V(){Vi a(60);int q = 1;rep(i,0,60){a[i]=q;q*=2;}return a;}\n//Vi nibe = nibe2V(); // 2^n\nVi stpowV(){Vi a(1000005);a[0]=1;repeq(i,1,1000004)a[i]=a[i-1]*i%MOD;return a;}\n//Vi stpow = stpowV(); // 階乗配列(%MOD)\n\nusing mint = static_modint<MOD>;\n\n/****************************** START ******************************/\n\nsigned main() {\n  cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(12);\n  int n,d;cin >> n >> d;\n  two_sat ts(n);\n  \n  Vi x(n),y(n);\n  rep(i,0,n) cin >> x[i] >> y[i];\n  \n  rep(i,0,n)rep(j,i+1,n){\n    if(abs(x[i]-x[j]) < d) ts.add_clause(i,0,j,0);\n    if(abs(x[i]-y[j]) < d) ts.add_clause(i,0,j,1);\n    if(abs(y[i]-x[j]) < d) ts.add_clause(i,1,j,0);\n    if(abs(y[i]-y[j]) < d) ts.add_clause(i,1,j,1);\n  }\n  if(!ts.satisfiable()) {cNo;return 0;}\n  cYes;\n  auto ans = ts.answer();\n  rep(i,0,n){\n    if(ans[i]) cout << x[i] << endl;\n    else cout << y[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/twosat>\n\nusing namespace std;\nusing ll = long long;\n\n\nint main()\n{\n\tint n, d; cin >> n >> d;\n\tvector<pair<int,int>> a(n);\n\tatcoder::two_sat ts(n);\n\tfor(int i = 0; i < n; i++)cin >> a[i].first >> a[i].second;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\n\t\t\tint dx = a[i].first;\n\t\t\tint dy = a[i].second;\n\t\t\tif(abs(dx - a[j].first) < d)  ts.add_clause(i, false, j, false);\n\t\t\tif(abs(dx - a[j].second) < d) ts.add_clause(i, false, j, true);\n\t\t\tif(abs(dy - a[j].first) < d)  ts.add_clause(i, true, j, false);\n\t\t\tif(abs(dy - a[j].second) < d) ts.add_clause(i, true, j, true);\n\n\t\t}\n\t}\n\n\tbool sat = ts.satisfiable();\n\tcout << (sat ? \"Yes\" : \"No\") << endl;\n\tif(sat) {\n\t\tauto v = ts.answer();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcout << (v[i] ? a[i].first : a[i].second) << endl;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long int\n#define ld long double\n#define yorn(f) cout<<((f)?\"Yes\":\"No\")<<endl;\n#define YORN(f) cout<<((f)?\"YES\":\"NO\")<<endl;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define repi(i, n) for (ll i = 1; i < (ll)(n); i++)\n#define all(x) (x).begin(), (x).end()\n#define put(x) cout << x << endl;\n#define println(x) cout << x << endl;\nusing namespace std;\nusing namespace atcoder;\nvoid Main()\n{\n    ll n, D;\n    cin >> n >> D;\n\n    vector<ll> x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    \n    two_sat ts(n);\n    for (ll i = 0; i < n - 1; i++) {\n        for (ll j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(y[i] - y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n            if (abs(x[i] - y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        put(\"No\");\n        return;\n    }\n\n    put(\"Yes\");\n    rep(i, n) {\n        if (ts.answer()[i]) {\n            put(x[i]);\n        }\n        else {\n            put(y[i]);\n        }\n    }\n\n}\nsigned main(){ Main();return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region atcoder\n#include <atcoder/twosat>\nusing namespace atcoder;\n/* These are for segment tree\nint op(int a, int b){return max(a, b);}\nint e(){return -1;}\nbool f(int v){ return v < target;}\n*/\n#pragma endregion\n#pragma region macros\nusing ll = long long;\nusing vi = vector<int>;\nusing vs = vector<string>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\ntemplate<class T>bool chmax(T &a, const T b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a / gcd(a, b) * b;}\n#pragma endregion\n#pragma region debug for var, v, vv\n#define debug(var)  do{std::cout << #var << \" : \";view(var);}while(0)\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){cout << endl;int cnt = 0;for(const auto& v : vv){cout << cnt << \"th : \"; view(v); cnt++;} cout << endl;}\n#pragma endregion\nconst ll mod = 1000000007;\nconst int inf = 1001001001;\nconst ll INF = 1001001001001001001;\nconst int MAX = 2000005;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint main() {\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\tint n, d; cin >> n >> d;\n\ttwo_sat g(n);\n\tvi x(n), y(n);\n\trep(i, n) cin >> x[i] >> y[i];\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif(abs(x[i] - x[j]) < d) g.add_clause(i, false, j, false);\n\t\t\tif(abs(x[i] - y[j]) < d) g.add_clause(i, false, j, true);\n\t\t\tif(abs(y[i] - x[j]) < d) g.add_clause(i, true, j, false);\n\t\t\tif(abs(y[i] - y[j]) < d) g.add_clause(i, true, j, true);\n\t\t}\n\t}\n\tif(!g.satisfiable()) cout << \"No\" << endl;\n\telse{\n\t\tcout << \"Yes\" << endl;\n\t\tauto ans = g.answer();\n\t\trep(i, n){\n\t\t\tif(ans[i]) cout << x[i] << endl;\n\t\t\telse cout << y[i] << endl;\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1;} return 0;}\nstruct init{init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}}init_;\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\n// ACL template\nint main() {\n    ll N, D;\n    cin >> N >> D;\n    two_sat ts(N);\n\n    vvc<ll> A(N, vl(2));\n    rep(i, N) cin >> A[i][0] >> A[i][1];\n\n    rep(i, N) repe(j, i + 1, N){\n        rep(ai, 2) rep(aj, 2){\n            if(abs(A[i][ai] - A[j][aj]) < D)\n                ts.add_clause(i, ai, j, aj);\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << \"No\" << '\\n';\n    }else{\n        cout << \"Yes\" << '\\n';\n        auto ans = ts.answer();\n        rep(i, N) cout << (ans[i] ? A[i][0] : A[i][1]) << '\\n';\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ld> pld;\ntypedef pair<pii, int> ppiii;\ntypedef pair<pii, ll> ppiil;\ntypedef pair<pll, ll> pplll;\ntypedef pair<pli, int> pplii;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<pll>> vvpll;\n#define rep(i, a, b) for (ll i=(a); i<(b); i++)\n#define rrep(i, a, b) for (ll i=(a); i>(b); i--)\n#define pb push_back\n#define tostr to_string\n#define mkp make_pair\n#define list2d(name, N, M, type, init) vector<vector<type>> name(N, vector<type>(M, init))\nconst ll INF = LONG_LONG_MAX;\nconst ll MOD = 998244353;\n\nvoid print(ld out) { cout << fixed << setprecision(15) << out << '\\n'; }\nvoid print(double out) { cout << fixed << setprecision(15) << out << '\\n'; }\ntemplate<typename T> void print(T out) { cout << out << '\\n'; }\ntemplate<typename T1, typename T2> void print(pair<T1, T2> out) { cout << out.first << ' ' << out.second << '\\n'; }\ntemplate<typename T> void print(vector<T> A) { rep(i, 0, A.size()) { cout << A[i]; cout << (i == A.size()-1 ? '\\n' : ' '); } }\ntemplate<typename T> void print(set<T> S) { vector<T> A(S.begin(), S.end()); print(A); }\n\ntemplate<typename T> inline bool chmax(T &x, T y) { return (y > x) ? x = y, true : false; }\ntemplate<typename T> inline bool chmin(T &x, T y) { return (y < x) ? x = y, true : false; }\n\nll sum(vector<ll> A) { ll res = 0; for (ll a: A) res += a; return res; }\nll max(vector<ll> A) { ll res = -INF; for (ll a: A) chmax(res, a); return res; }\nll min(vector<ll> A) { ll res = INF; for (ll a: A) chmin(res, a); return res; }\n\nll toint(string s) { ll res = 0; for (char c : s) { res *= 10; res += (c - '0'); } return res; }\n// 数字なら'0'、アルファベットなら'a'みたいに使い分ける\n// int toint(char c) { return c - '0'; }\n// char tochar(int i) { return '0' + i; }\n\ninline ll pow(int x, ll n) { ll res = 1; rep(_, 0, n) res *= x; return res; }\ninline ll pow(ll x, ll n, int mod) { ll res = 1; while (n > 0) { if (n & 1) { res = (res * x) % mod; } x = (x * x) % mod; n >>= 1; } return res; }\n\ninline ll floor(ll a, ll b) { if (a < 0) { return (a-b+1) / b; } else { return a / b; } }\ninline ll ceil(ll a, ll b) { if (a >= 0) { return (a+b-1) / b; } else { return a / b; } }\npll divmod(ll a, ll b) { ll d = a / b; ll m = a % b; return {d, m}; }\n\nint popcount(ll S) { return __builtin_popcountll(S); }\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n\nusing namespace atcoder;\n\nll N, D;\nvector<ll> L, R;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> D;\n\n    // ts[i] := 旗iを左に置くか\n    two_sat ts(N);\n    L.resize(N);\n    R.resize(N);\n    rep(i, 0, N) cin >> L[i] >> R[i];\n\n    rep(i, 0, N) {\n        rep(j, i+1, N) {\n            // i左かつj左がダメ\n            if (abs(L[i] - L[j]) < D) {\n                // i右またはj右を条件にする\n                ts.add_clause(i, false, j, false);\n            }\n            // i左かつj右がダメ\n            if (abs(L[i] - R[j]) < D) {\n                // i右またはj左を条件にする\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(R[i] - L[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(R[i] - R[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        print(\"No\");\n        return 0;\n    }\n\n    vector<bool> res = ts.answer();\n    vector<ll> ans;\n    rep(i, 0, N) {\n        if (res[i]) {\n            ans.pb(L[i]);\n        } else {\n            ans.pb(R[i]);\n        }\n    }\n    print(\"Yes\");\n    for (ll a : ans) {\n        print(a);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n#include<random>\n\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tif (d[j][i] != INF && d[i][k] != INF)chmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tvector<int> in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<int, vector<int>, greater<int>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tint n;\npublic:\n\tUnionFind(int size) : data(size, -1), n(size) { }\n\tbool merge(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tn -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint num() {//集合の数を返す\n\t\treturn n;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id, vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) {\n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\nnamespace internal {\n\n\ttemplate <class E> struct csr {\n\t\tstd::vector<int> start;\n\t\tstd::vector<E> elist;\n\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges)\n\t\t\t: start(n + 1), elist(edges.size()) {\n\t\t\tfor (auto e : edges) {\n\t\t\t\tstart[e.first + 1]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tstart[i] += start[i - 1];\n\t\t\t}\n\t\t\tauto counter = start;\n\t\t\tfor (auto e : edges) {\n\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Reference:\n\t// R. Tarjan,\n\t// Depth-First Search and Linear Graph Algorithms\n\tstruct scc_graph {\n\tpublic:\n\t\tscc_graph(int n) : _n(n) {}\n\n\t\tint num_vertices() { return _n; }\n\n\t\tvoid add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n\n\t\t// @return pair of (# of scc, scc id)\n\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\tint now_ord = 0, group_num = 0;\n\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\tvisited.reserve(_n);\n\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\tvisited.push_back(v);\n\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t}\n\t\t\t\t\tgroup_num++;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t}\n\t\t\tfor (auto& x : ids) {\n\t\t\t\tx = group_num - 1 - x;\n\t\t\t}\n\t\t\treturn { group_num, ids };\n\t\t}\n\n\t\tstd::vector<std::vector<int>> scc() {\n\t\t\tauto ids = scc_ids();\n\t\t\tint group_num = ids.first;\n\t\t\tstd::vector<int> counts(group_num);\n\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t}\n\t\t\treturn groups;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstruct edge {\n\t\t\tint to;\n\t\t};\n\t\tstd::vector<std::pair<int, edge>> edges;\n\t};\n\n}  // namespace internal\n\nstruct two_sat {\npublic:\n\ttwo_sat() : _n(0), scc(0) {}\n\ttwo_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\tassert(0 <= i && i < _n);\n\t\tassert(0 <= j && j < _n);\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t}\n\tbool satisfiable() {\n\t\tauto id = scc.scc_ids().second;\n\t\tfor (int i = 0; i < _n; i++) {\n\t\t\tif (id[2 * i] == id[2 * i + 1]) return false;\n\t\t\t_answer[i] = id[2 * i] < id[2 * i + 1];\n\t\t}\n\t\treturn true;\n\t}\n\tstd::vector<bool> answer() { return _answer; }\n\nprivate:\n\tint _n;\n\tstd::vector<bool> _answer;\n\tinternal::scc_graph scc;\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, d;\n\tcin >> n >> d;\n\ttwo_sat ts(2 * n);\n\tArray a(2 * n);\n\tfor (auto &e : a)cin >> e;\n\tREP(i, n)ts.add_clause(2 * i, 1, 2 * i + 1, 1);\n\tREP(i, 2 * n)rep(j, i+1, 2 * n) {\n\t\tif (abs(a[i] - a[j]) < d)ts.add_clause(i, 0, j, 0);\n\t}\n\tif (ts.satisfiable() == false)cout << \"No\" << \"\\n\";\n\telse {\n\t\tcout << \"Yes\" << \"\\n\";\n\t\tauto ans = ts.answer();\n\t\tREP(i, n) {\n\t\t\tif (ans[2 * i] == 1)cout << a[2 * i] << \"\\n\";\n\t\t\telse cout << a[2 * i + 1] << \"\\n\";\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SCC{\n    int N;\n    vector<bool> used;\n    vector<int> vs;\n    vector<int> cmp;\n\n    void dfs(int v, const vector<vector<int>>& G){\n        used[v] = true;\n        for(auto u : G[v]){\n            if(!used[u]) dfs(u, G);\n        }\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k, const vector<vector<int>>& rG){\n        used[v] = true;\n        cmp[v] = k;\n        for(auto u : rG[v]){\n            if(!used[u]) rdfs(u, k, rG);\n        }\n    }\n\n    SCC(int N, const vector<vector<int>>& G):N(N){\n        vector<vector<int>> rG(N);\n        for(int i=0; i<N; i++) for(int j : G[i]) rG[j].push_back(i);\n        used.resize(N);\n        fill(used.begin(), used.end(), false);\n        for(int v=0; v<N; v++){\n            if(!used[v]) dfs(v, G);\n        }\n\n        fill(used.begin(), used.end(), false);\n        cmp.resize(N);\n        int k = 0;\n        for(int i = vs.size()-1; i>=0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++, rG);\n        }\n    }\n\n    vector<vector<int>> dump_graph(const vector<vector<int>>& G){\n        int sz = *max_element(cmp.begin(), cmp.end()) + 1;\n        vector<vector<int>> edges2(sz);\n        for(int i=0; i<N; i++){\n            for(auto j : G[i]){\n                if(cmp[i] != cmp[j]){\n                    edges2[cmp[i]].push_back(cmp[j]);\n                }\n            }\n        }\n        return edges2;\n    }\n};\n\nint main(){\n    int N, D;\n    cin >> N >> D;\n    vector<int> A(2*N);\n    for(int i=0; i<2*N; i++) cin >> A[i];\n    vector<vector<int>> edges(2*N);\n    for(int i=0; i<2*N; i++) for(int j=0; j<i; j++) if(i/2 != j/2 && abs(A[i] - A[j]) < D){\n        edges[i].push_back(j^1);\n        edges[j].push_back(i^1);\n    }\n\n    SCC scc(2*N, edges);\n    \n    vector<int> ans(N);\n    for(int i=0; i<N; i++){\n        int c1 = scc.cmp[2*i], c2 = scc.cmp[2*i+1];\n        if(c1 == c2){\n            cout << \"No\" << endl;\n            return 0;\n        }else if(c1 < c2){\n            ans[i] = A[2*i+1];\n        }else{\n            ans[i] = A[2*i];\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    for(int a : ans) cout << a << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n#define ll long long\n#define ld long double\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define rrep(i,n) RREP(i,(n)-1,0)\n#define all(v) v.begin(), v.end()\n#define endk '\\n'\nconst int inf = 1e9+7;\nconst ll longinf = 1LL<<60;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-10;\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b){if(a>b) a=b;}\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b){if(a<b) a=b;}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n; ll d; cin >> n >> d;\n  vector<vector<ll>> X(2, vector<ll>(n));\n  rep(i, n) cin >> X[0][i] >> X[1][i];\n  two_sat ts(n);\n  rep(i, n) REP(j, i+1, n) {\n    rep(k, 2) rep(l, 2) {\n      if(abs(X[k][i]-X[l][j])<d) {\n        ts.add_clause(i, !k, j, !l);\n      }\n    }\n  }\n  if(!ts.satisfiable()) {\n    cout << \"No\" << endk;\n  } else {\n    cout << \"Yes\" << endk;\n    auto ans = ts.answer();\n    rep(i, n) cout << X[ans[i]][i] << endk;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    for(auto itr = a.begin(); itr != a.end(); itr++){\n\t\tcout << *itr << \" \";\n\t}\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){\n\tcout << \"debug: \" << a << \" \" << b << \"\\n\";\n}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << \"debug: \" << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {cout << \"#\" << \"\\n\";}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nint main(){\n\tint n,d; cin >> n >> d;\n    vvl v(n,vl(2));\n    two_sat ts(n);\n    rep(i,n) rep(j,2) cin >> v[i][j];\n    rep(i,n){\n        REP(j,i+1,n){\n            rep(k,2){\n                rep(l,2){\n                    if(abs(v[i][k] - v[j][l]) < d){\n                        ts.add_clause(i,k,j,l);\n                    }\n                }\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << \"\\n\";\n        return 0;\n    }\n    cout << \"Yes\" << \"\\n\";\n    auto a = ts.answer();\n    rep(i,n) cout << v[i][a[i]^1] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    int n,d;\n    cin >> n >> d;\n    two_sat ts(n);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(abs(x[i]-x[j])<d){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(y[i]-y[j])<d){\n                ts.add_clause(i,true,j,true);\n            }\n            if(abs(x[i]-y[j])<d){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(y[i]-x[j])<d){\n                ts.add_clause(i,true,j,false);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans=ts.answer();\n    rep(i,n){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define range2(i,a,b) ((a)<=(i) && (i)<=(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct two_sat {\n  template <class E> struct csr {\n      std::vector<int> start;\n      std::vector<E> elist;\n      csr(int n, const std::vector<std::pair<int, E>>& edges)\n          : start(n + 1), elist(edges.size()) {\n          for (auto e : edges) {\n              start[e.first + 1]++;\n          }\n          for (int i = 1; i <= n; i++) {\n              start[i] += start[i - 1];\n          }\n          auto counter = start;\n          for (auto e : edges) {\n              elist[counter[e.first]++] = e.second;\n          }\n      }\n  };\n\n  // Reference:\n  // R. Tarjan,\n  // Depth-First Search and Linear Graph Algorithms\n  struct scc_graph {\n    public:\n      scc_graph(int n) : _n(n) {}\n\n      int num_vertices() { return _n; }\n\n      void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n      // @return pair of (# of scc, scc id)\n      std::pair<int, std::vector<int>> scc_ids() {\n          auto g = csr<edge>(_n, edges);\n          int now_ord = 0, group_num = 0;\n          std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n          visited.reserve(_n);\n          auto dfs = [&](auto self, int v) -> void {\n              low[v] = ord[v] = now_ord++;\n              visited.push_back(v);\n              for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                  auto to = g.elist[i].to;\n                  if (ord[to] == -1) {\n                      self(self, to);\n                      low[v] = std::min(low[v], low[to]);\n                  } else {\n                      low[v] = std::min(low[v], ord[to]);\n                  }\n              }\n              if (low[v] == ord[v]) {\n                  while (true) {\n                      int u = visited.back();\n                      visited.pop_back();\n                      ord[u] = _n;\n                      ids[u] = group_num;\n                      if (u == v) break;\n                  }\n                  group_num++;\n              }\n          };\n          for (int i = 0; i < _n; i++) {\n              if (ord[i] == -1) dfs(dfs, i);\n          }\n          for (auto& x : ids) {\n              x = group_num - 1 - x;\n          }\n          return {group_num, ids};\n      }\n\n      std::vector<std::vector<int>> scc() {\n          auto ids = scc_ids();\n          int group_num = ids.first;\n          std::vector<int> counts(group_num);\n          for (auto x : ids.second) counts[x]++;\n          std::vector<std::vector<int>> groups(ids.first);\n          for (int i = 0; i < group_num; i++) {\n              groups[i].reserve(counts[i]);\n          }\n          for (int i = 0; i < _n; i++) {\n              groups[ids.second[i]].push_back(i);\n          }\n          return groups;\n      }\n\n    private:\n      int _n;\n      struct edge {\n          int to;\n      };\n      std::vector<std::pair<int, edge>> edges;\n  };\n\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n\nvoid solve(){\n  int N,D;\n  cin >> N >> D;\n\n  vector<int> x(N),y(N);\n  REP(i,N) cin >> x[i] >> y[i];\n\n  two_sat ts(N);\n  \n  REP(i,N) FOR(j,i+1,N){\n    if(abs(x[i]-x[j]) < D) ts.add_clause(i,false,j,false);\n    if(abs(x[i]-y[j]) < D) ts.add_clause(i,false,j,true);\n    if(abs(y[i]-x[j]) < D) ts.add_clause(i,true,j,false);\n    //if(abs(y[i]-y[j]) < D) ts.add_clause(i,true,j,true);\n  }\n\n  if(!ts.satisfiable()) cout << \"No\" << endl;\n  else{\n    cout << \"Yes\" << endl;\n    REP(i,N){\n      if(ts.answer()[i]) cout << x[i] << endl;\n      else cout << y[i] << endl;\n    }\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}\n}\n#include <utility>\nnamespace atcoder {\nnamespace internal {\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    unsigned int umod() const { return _m; }\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n>\nconstexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m>\nconstexpr int primitive_root = primitive_root_constexpr(m);\n}\n}\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,\n                                                   std::true_type, std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value, std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 = typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>;\ntemplate <class T>\nusing is_integral =\n    typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value || is_unsigned_int128<T>::value,\n                              std::true_type, std::false_type>::type;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value, std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,\n                              std::true_type, std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value, make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>, std::common_type<T>>::type>::type;\n#else\ntemplate <class T>\nusing is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value, std::true_type, std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value && std::is_unsigned<T>::value, std::true_type, std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value, std::make_unsigned<T>, std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T>\nusing to_unsigned_t = typename to_unsigned<T>::type;\n}\n}\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T>\nusing is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T>\nusing is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n   public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs; }\n    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs; }\n    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs; }\n    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs; }\n    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v; }\n    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v; }\n\n   private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id>\nstruct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n   public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs; }\n    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs; }\n    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs; }\n    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs; }\n    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v; }\n    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v; }\n\n   private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id>\ninternal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class>\nstruct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}\n}\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] = (unsigned long long)(mint::mod() + l.val() - r.val()) * inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353, class T, std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a, const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;\n    static constexpr unsigned long long MOD2 = 167772161;\n    static constexpr unsigned long long MOD3 = 469762049;\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 = internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 = internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        long long diff = c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct dsu {\n   public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(std::remove_if(result.begin(), result.end(), [&](const std::vector<int>& v) { return v.empty(); }),\n                     result.end());\n        return result;\n    }\n\n   private:\n    int _n;\n    std::vector<int> parent_or_size;\n};\n}\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class T>\nstruct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n   public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n   private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n}\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S), F (*composition)(F, F), F (*id)()>\nstruct lazy_segtree {\n   public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)>\n    int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G>\n    int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)>\n    int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G>\n    int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n   private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\nstd::pair<long long, long long> crt(const std::vector<long long>& r, const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        if ((r1 - r0) % g) return {0, 0};\n        long long x = (r1 - r0) / g % u1 * im % u1;\n        r0 += x * m0;\n        m0 *= u1;\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}\n#include <algorithm>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T>\nstruct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}\n}\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap>\nstruct mf_graph {\n   public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) { return flow(s, t, std::numeric_limits<Cap>::max()); }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d = self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n   private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost>\nstruct mcf_graph {\n   public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) { return flow(s, t, std::numeric_limits<Cap>::max()); }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) { return slope(s, t, flow_limit).back(); }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) { return slope(s, t, std::numeric_limits<Cap>::max()); }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(), std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n   private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E>\nstruct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\nstruct scc_graph {\n   public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n   private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}\n}\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n   public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n   private:\n    internal::scc_graph internal;\n};\n}\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()>\nstruct segtree {\n   public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)>\n    int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F>\n    int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)>\n    int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F>\n    int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n   private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T>\nstd::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\ntemplate <class T>\nstd::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n}\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct two_sat {\n   public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n   private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}\n\nusing namespace std;\n\n#define NDEBUG\n#include <cassert>\n\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> llll;\ntypedef pair<double, double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<llll> vllll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a) int((a).size())\n#define pb push_back\n#define eb emplace_back\n#define FOR(var, from, to) for (int var = (from); var <= (to); ++var)\n#define rep(var, n) for (int var = 0; var < (n); ++var)\n#define rep1(var, n) for (int var = 1; var <= (n); ++var)\n#define repC2(vari, varj, n)                 \\\n    for (int vari = 0; vari < (n)-1; ++vari) \\\n        for (int varj = vari + 1; varj < (n); ++varj)\n#define repC3(vari, varj, vark, n)                      \\\n    for (int vari = 0; vari < (n)-2; ++vari)            \\\n        for (int varj = vari + 1; varj < (n)-1; ++varj) \\\n            for (int vark = varj + 1; vark < (n); ++vark)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define tr(i, c) for (auto i = (c).begin(); i != (c).end(); ++i)\n#define found(s, e) ((s).find(e) != (s).end())\n#define mset(arr, val) memset(arr, val, sizeof(arr))\n#define mid(x, y) ((x) + ((y) - (x)) / 2)\n#define IN(x, a, b) ((a) <= (x) && (x) <= (b))\n#define cons make_pair\n#define clamp(v, lo, hi) min(max(v, lo), hi)\n#define ABS(x) max((x), -(x))\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n\ntemplate <typename T1, typename T2>\ninline void amin(T1& a, T2 const& b) {\n    if (a > b) a = b;\n}\ntemplate <typename T1, typename T2>\ninline void amax(T1& a, T2 const& b) {\n    if (a < b) a = b;\n}\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n    return vector<T>(x, a);\n}\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n    auto cont = vectors(y, z, zs...);\n    return vector<decltype(cont)>(x, cont);\n}\n\ninline ll square(ll x) { return x * x; }\ninline ll gcd(ll a, ll b) {\n    while (a) swap(a, b %= a);\n    return b;\n}\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ntemplate <typename T>\ninline T mod(T a, T b) {\n    return ((a % b) + b) % b;\n}\n\ntemplate <typename T>\nint find_left(vector<T>& v, T elem) {\n    return (int)(upper_bound(v.begin(), v.end(), elem) - v.begin()) - 1;\n}\ntemplate <typename T>\nint find_right(vector<T>& v, T elem) {\n    return (int)(lower_bound(v.begin(), v.end(), elem) - v.begin());\n}\n\nconst ll MOD = 1000000007LL;\n\ninline ll ADD(ll x, ll y) { return (x + y) % MOD; }\ninline ll SUB(ll x, ll y) { return (x - y + MOD) % MOD; }\ninline ll MUL(ll x, ll y) { return x * y % MOD; }\ninline ll POW(ll x, ll e) {\n    ll v = 1;\n    for (; e; x = MUL(x, x), e >>= 1)\n        if (e & 1) v = MUL(v, x);\n    return v;\n}\ninline ll INV(ll y) { /*assert(y%MOD!=0);*/\n    return POW(y, MOD - 2);\n}\ninline ll DIV(ll x, ll y) { return MUL(x, INV(y)); }\n\n#define INTSPACE 12\nchar _buf[INTSPACE * 1000000 + 3];\n\nint loadint() {\n    if (fgets(_buf, INTSPACE + 3, stdin) == NULL) return 0;\n    return atoi(_buf);\n}\n\nint loadvec(vector<int>& v, int N = -1) {\n    if (N == 0) {\n        v.clear();\n        return 0;\n    }\n    if (N == -1) {\n        N = loadint();\n        if (N == 0) return 0;\n    }\n    int bufsize = INTSPACE * N + 3;\n    if (fgets(_buf, bufsize, stdin) == NULL) return 0;\n    v.resize(N);\n\n    int i = 0;\n    bool last = false;\n    for (char* p = &_buf[0];;) {\n        char* q = p;\n        while (*q > ' ') ++q;\n        if (*q == 0x0D || *q == 0x0A) last = true;\n        *q = 0;\n        v[i++] = atoi(p);\n        if (last || i == N) break;\n        p = q + 1;\n    }\n    return i;\n}\nvoid read_cr() { fgets(_buf, 256, stdin); }\n\nvoid horizontal(vector<int>& v) {\n    int L = v.size();\n    for (int i = 0; i < L; ++i) {\n        printf(\"%d%c\", v[i], (i == L - 1) ? '\\n' : ' ');\n    }\n}\nvoid horizontall(vector<long long>& v) {\n    int L = v.size();\n    for (int i = 0; i < L; ++i) {\n        printf(\"%lld%c\", v[i], (i == L - 1) ? '\\n' : ' ');\n    }\n}\n\nvoid solve(int N, int D, vi& x, vi& _x) {\n    atcoder::two_sat ts(N);\n\n    repC2(i, j, N) {\n        if (ABS(x[i] - x[j]) < D) {\n            ts.add_clause(i, !true, j, !true);\n        }\n        if (ABS(x[i] - _x[j]) < D) {\n            ts.add_clause(i, !true, j, !false);\n        }\n        if (ABS(_x[i] - x[j]) < D) {\n            ts.add_clause(i, !false, j, !true);\n        }\n        if (ABS(_x[i] - _x[j]) < D) {\n            ts.add_clause(i, !false, j, !false);\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        printf(\"No\\n\");\n        return;\n    }\n\n    printf(\"Yes\\n\");\n    vector<bool> ans = ts.answer();\n    rep(i, N) { printf(\"%d\\n\", ans[i] ? x[i] : _x[i]); }\n    return;\n}\n\nint main() {\n    int N, D;\n    scanf(\"%d %d%*c\", &N, &D);\n    vi x(N), y(N);\n    rep(i, N) { scanf(\"%d %d%*c\", &x[i], &y[i]); }\n\n    solve(N, D, x, y);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    VV<int> vec(N);\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        vec[i] = V<int>{x, y};\n    }\n    two_sat g(N);\n    rep(i, N) {\n        rep(j, i) {\n            rep(p, 2) rep(q, 2) {\n                if (abs(vec[i][p] - vec[j][q]) < D) {\n                    g.add_clause(i, p ^ 1, j, q ^ 1);\n                }\n            }\n        }\n    }\n    if (!g.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans = g.answer();\n    rep(i, N) { cout << vec[i][ans[i]] << '\\n'; }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define all(v) v.begin(),v.end()\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\n/* example\n    int n=scc.scc();\n    scc.build(n,g);\n    (g:outside)\n*/\nstruct SCC{\n    vector<int> used,cmp,vs;\n    vector<vector<int>> ori;\n    vector<vector<int>> v,rv;\n    SCC(){}\n    SCC(int n):used(n),cmp(n,-1),v(n),rv(n){}\n \n    void add_edge(int x,int y){\n        v[x].push_back(y);\n        rv[y].push_back(x);\n    }\n    void dfs(int x){\n        used[x]=true;\n        for(auto to:v[x]) if(!used[to]) dfs(to);\n        vs.push_back(x);\n    }\n \n    void rdfs(int x,int k){\n        cmp[x]=k;\n        for(auto to:rv[x]) if(cmp[to]==-1) rdfs(to,k);\n    }\n \n    int scc(){\n        for(int i=0;i<used.size();i++) if(!used[i]) dfs(i);\n        reverse(vs.begin(),vs.end());\n        int k=0;\n        for(auto x:vs) if(cmp[x]==-1) rdfs(x,k++);\n\n        ori.resize(k);\n        for(int i=0;i<used.size();i++) ori[cmp[i]].push_back(i);\n\n        return k;//k:size\n    }\n\n    void build(int k,vector<vector<int>> &g){\n        g.resize(k);\n        for(int i=0;i<v.size();i++){\n            for(auto to:v[i]){\n                int x=cmp[i],y=cmp[to];\n                if(x!=y) g[x].push_back(y);\n            }\n        }\n    }\n};\n\n// depends on SCC\n// !x:2*x, x:2*x+1\nstruct two_SAT{\n    int N;\n    SCC graph;\n    vector<bool> answer;\n\n    two_SAT(){}\n    two_SAT(int n):N(n),graph(2*N),answer(N){}\n\n    void add_edge(int i,bool f,int j,bool g){\n        graph.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        graph.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    \n    bool satisfiable(){\n        int K=graph.scc();\n        auto ids=graph.cmp;\n        for(int i=0;i<N;++i){\n            if(ids[2*i]==ids[2*i+1]) return false;\n            answer[i]=(ids[2*i] < ids[2*i+1]);\n        }\n        return true;\n    }\n\n    vector<bool> getAnswer(){\n        return answer;\n    }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  ll D;\n  cin>>N>>D;\n  vector<ll> X(N),Y(N);\n  rep(i,N) cin>>X[i]>>Y[i];\n\n  two_SAT sat(N);\n  for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n      if(abs(X[i]-X[j])<D) sat.add_edge(i,false,j,false);\n      if(abs(X[i]-Y[j])<D) sat.add_edge(i,false,j,true);\n      if(abs(Y[i]-X[j])<D) sat.add_edge(i,true,j,false);\n      if(abs(Y[i]-Y[j])<D) sat.add_edge(i,true,j,true);\n  }\n\n  if(sat.satisfiable()==false){\n      cout<<\"No\"<<endl;\n      return 0;\n  }\n\n  cout<<\"Yes\"<<\"\\n\";\n  vector<bool> ans=sat.getAnswer();\n  rep(i,N){\n      if(ans[i]) cout<<X[i]<<\"\\n\";\n      else cout<<Y[i]<<\"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/twosat>\n\nusing namespace std;\nusing ll = long long;\n\n\nint main()\n{\n\tint n, d; cin >> n >> d;\n\tvector<pair<int,int>> a(n);\n\tatcoder::two_sat ts(n);\n\tfor(int i = 0; i < n; i++)cin >> a[i].first >> a[i].second;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\n\t\t\tint dx = a[i].first;\n\t\t\tint dy = a[i].second;\n\t\t\tif(abs(dx - a[j].first) < d)  ts.add_clause(i, false, j, false);\n\t\t\tif(abs(dx - a[j].second) < d) ts.add_clause(i, false, j, true);\n\t\t\tif(abs(dy - a[i].first) < d)  ts.add_clause(i, true, j, false);\n\t\t\tif(abs(dy - a[i].second) < d) ts.add_clause(i, true, j, true);\n\n\t\t}\n\t}\n\n\tbool sat = ts.satisfiable();\n\tcout << (sat ? \"Yes\" : \"No\") << endl;\n\tif(sat) {\n\t\tauto v = ts.answer();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcout << (v[i] ? a[i].first : a[i].second) << endl;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=500005;\nconst ll INF=1LL<<30;\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\n    namespace internal {\n        // @param n `0 <= n`\n        // @return minimum non-negative `x` s.t. `n <= 2**x`\n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        // @param n `1 <= n`\n        // @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\n    namespace internal {\n        // @param m `1 <= m`\n        // @return x mod m\n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        // Fast moduler by barrett reduction\n        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n        // NOTE: reconsider after Ice Lake\n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            // @param m `1 <= m`\n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            // @return m\n            unsigned int umod() const { return _m; }\n            // @param a `0 <= a < m`\n            // @param b `0 <= b < m`\n            // @return `a * b % m`\n            unsigned int mul(unsigned int a, unsigned int b) const {\n                // [1] m = 1\n                // a = b = im = 0, so okay\n                // [2] m >= 2\n                // im = ceil(2^64 / m)\n                // -> im * m = 2^64 + r (0 <= r < m)\n                // let z = a*b = c*m + d (0 <= c, d < m)\n                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n                // ((ab * im) >> 64) == c or c + 1\n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        // @param n `0 <= n`\n        // @param m `1 <= m`\n        // @return `(x ** n) % m`\n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        // Reference:\n        // M. Forisek and J. Jancina,\n        // Fast Primality Testing for Integers That Fit into a Machine Word\n        // @param n `0 <= n`\n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        // @param b `1 <= b`\n        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            // Contracts:\n            // [1] s - m0 * a = 0 (mod b)\n            // [2] t - m1 * a = 0 (mod b)\n            // [3] s * |m1| + t * |m0| <= b\n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                // [3]:\n                // (s - t * u) * |m1| + t * |m0 - m1 * u|\n                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n                // = s * |m1| + t * |m0| <= b\n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            // by [3]: |m0| <= b/g\n            // by g != b: |m0| < b/g\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        // Compile time primitive root\n        // @param m must be prime\n        // @return primitive root (and minimum in now)\n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\n    namespace internal {\n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\n    namespace internal {\n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        // Reference:\n        // R. Tarjan,\n        // Depth-First Search and Linear Graph Algorithms\n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            int num_vertices() { return _n; }\n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            // @return pair of (# of scc, scc id)\n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\n    namespace internal {\n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n#else\n        template <class T> using is_integral = typename std::is_integral<T>;\n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n#endif\n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\n    namespace internal {\n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n    }  // namespace internal\n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        unsigned int val() const { return _v; }\n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        unsigned int val() const { return _v; }\n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    namespace internal {\n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n    }  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\n    namespace internal {\n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n    }  // namespace internal\n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            // B = 2^63, -B <= x, r(real value) < B\n            // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n            // r = c1[i] (mod MOD1)\n            // focus on MOD1\n            // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n            // r = x,\n            //     x - M' + (0 or 2B),\n            //     x - 2M' + (0, 2B or 4B),\n            //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n            // (r - x) = 0, (0)\n            //           - M' + (0 or 2B), (1)\n            //           -2M' + (0 or 2B or 4B), (2)\n            //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n            // we checked that\n            //   ((1) mod MOD1) mod 5 = 2\n            //   ((2) mod MOD1) mod 5 = 3\n            //   ((3) mod MOD1) mod 5 = 4\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        return c;\n    }\n}  // namespace atcoder\n#endif  // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n    // Implement (union by size) + (path compression)\n    // Reference:\n    // Zvi Galil and Giuseppe F. Italiano,\n    // Data structures and algorithms for disjoint set union problems\n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n    private:\n        int _n;\n        // root node: -1 * component size\n        // otherwise: parent\n        std::vector<int> parent_or_size;\n    };\n}  // namespace atcoder\n#endif  // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n    // Reference: https://en.wikipedia.org/wiki/Fenwick_tree\n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n    private:\n        int _n;\n        std::vector<U> data;\n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n}  // namespace atcoder\n#endif  // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n}  // namespace atcoder\n#endif  // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    // (rem, mod)\n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        // Contracts: 0 <= r0 < m0\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n            // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n            // r2 % m0 = r0\n            // r2 % m1 = r1\n            // -> (r0 + x*m0) % m1 = r1\n            // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n            // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n            // im = inv(u0) (mod u1) (0 <= im < u1)\n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            long long u1 = (m1 / g);\n            // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n            if ((r1 - r0) % g) return {0, 0};\n            // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n            long long x = (r1 - r0) / g % u1 * im % u1;\n            // |r0| + |m0 * x|\n            // < m0 + m0 * (u1 - 1)\n            // = m0 + m0 * m1 / g - m0\n            // = lcm(m0, m1)\n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n}  // namespace atcoder\n#endif  // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n}  // namespace atcoder\n#endif  // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            // variants (C = maxcost):\n            // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n            // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                    // dist[v] >= 0 (all reduced cost are positive)\n                    // dist[v] <= (n-1)C\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        // |-dual[e.to] + dual[v]| <= (n-1)C\n                        // cost <= C - -(n-1)C + 0 = nC\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    // dual[v] = dual[v] - dist[t] + dist[v]\n                    //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                    //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                    //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n}  // namespace atcoder\n#endif  // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n    private:\n        internal::scc_graph internal;\n    };\n}  // namespace atcoder\n#endif  // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n}  // namespace atcoder\n#endif  // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\n    namespace internal {\n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        // SA-IS, linear-time suffix array construction\n        // Reference:\n        // G. Nong, S. Zhang, and W. H. Chan,\n        // Two Efficient Algorithms for Linear Time Suffix Array Construction\n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            induce(lms);\n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n    }  // namespace internal\n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    // Reference:\n    // T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    // Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    // Applications\n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    // Reference:\n    // D. Gusfield,\n    // Algorithms on Strings, Trees, and Sequences: Computer Science and\n    // Computational Biology\n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n}  // namespace atcoder\n#endif  // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n    // Reference:\n    // B. Aspvall, M. Plass, and R. Tarjan,\n    // A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n    // Formulas\n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,D;cin>>N>>D;\n    atcoder::two_sat ts(N);\n    \n    vector<vector<int>> s(N,vector<int>(2));\n    for(int i=0;i<N;i++) cin>>s[i][0]>>s[i][1];\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            for(int a=0;a<2;a++){\n                for(int b=0;b<2;b++){\n                    if(abs(s[i][a]-s[j][b])<D) ts.add_clause(i,!a,j,!b);\n                }\n            }\n        }\n    }\n    \n    bool c=ts.satisfiable();\n    \n    if(c){\n        cout<<\"Yes\"<<endl;\n        \n        auto x=ts.answer();\n        \n        for(int i=0;i<N;i++){\n            if(x[i]) cout<<s[i][1]<<\"\\n\";\n            else cout<<s[i][0]<<\"\\n\";\n        }\n    }else{\n        cout<<\"No\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <atcoder/all>\n\nusing ll = long long int;\nconst int INF = (1<<25);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll x[1111][2];\n\nint main(void){\n\tint n,i,f,j,g;\n\tll d;\n\tstd::cin >> n >> d;\n\tatcoder::two_sat ts(n);\n\tfor(i=0; i<n; ++i){\n\t\tfor(f=0; f<2; ++f){\n\t\t\tstd::cin >> x[i][f];\n\t\t\tfor(j=0; j<i; ++j){\n\t\t\t\tfor(g=0; g<2; ++g){\n\t\t\t\t\tif(abs(x[i][f]-x[j][g])<d){\n\t\t\t\t\t\tts.add_clause(i,!f,j,!g);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tauto ans = ts.satisfiable();\n\tif(!ans){\n\t\tstd::cout << \"No\" << std::endl;\n\t\treturn 0;\n\t}\n\tstd::cout << \"Yes\" << std::endl;\n\tauto v = ts.answer();\n\tfor(i=0; i<n; ++i){\n\t\tstd::cout << x[i][v[i]] << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nll X[1005][2];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, D;\n    cin >> N >> D;\n    for(int i = 0; i < N; i++) {\n        cin >> X[i][0] >> X[i][1];\n    }\n    atcoder::two_sat g(N);\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < i; j++) {\n            for(int k = 0; k < 2; k++) {\n                for(int l = 0; l < 2; l++) {\n                    if(abs(X[i][k] - X[j][l]) < D) {\n                        g.add_clause(i, (1 - k) == 1 , j, (1 - l) == 1);\n                    }\n                }\n            }\n        }\n    }\n    if(!g.satisfiable()) {\n        cout << \"No\" << endl;\n    } else {\n        cout << \"Yes\" << endl;\n        auto v = g.answer();\n        for(int i = 0; i < N; i++) {\n            if(v[i]) cout << X[i][1] << endl;\n            else cout << X[i][0] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"O3\")\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define EPS (1e-9)\n#define INF (1e17)\n#define PI (acos(-1))\n//const double PI = acos(-1);\n//const double EPS = 1e-15;\n//long long INF=(long long)1E17;\n#define i_7 (long long)(1e9+7)\n//#define i_7 998'244'353\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nlong long po(long a, long b){\n    if(b==0){\n        return 1;\n    }\n    \n    long long z = po(a,b/2);\n    z = mod(z*z);\n    if(b%2!=0){\n        z = mod(a*z);\n    }\n    return z;\n}\n \nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=std::sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n \nlong long gcd_(long long a, long long b){\n  if(a<b){\n    std::swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \n//using namespace std;\n//using namespace boost::multiprecision;\n//using namespace __gnu_pbds;\n\nint main(){\n  using namespace std;\n  using namespace atcoder;\n  \n  int n, d;\n  cin>>n>>d;\n  int x[n], y[n];\n  REP(i, n) cin>>x[i]>>y[i];\n  \n  two_sat ts(2 * n);\n  REP(i, n){\n    ts.add_clause(i, true, i + n, true);\n    ts.add_clause(i, false, i + n, false);\n  }\n  REP(i, n){\n    for(int j = i + 1; j < n; j++){\n      if(abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n      if(abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n      if(abs(y[i] - x[j]) < d) ts.add_clause(i + n, false, j, false);\n      if(abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n    }\n  }\n  bool possible = ts.satisfiable();\n  if(!possible){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  vector<bool> ans = ts.answer();\n  REP(i, n){\n    if(ts[i]){\n      cout << x[i] << endl;\n    }else{\n      cout << y[i] << endl;\n    }\n  }    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n,d;\n  cin >> n >> d;\n  two_sat ts(n);\n  vector<int> x(n),y(n);\n  for(int i = 0; i < n; ++i) cin >> x[i] >> y[i];\n  for(int i = 0; i < n; ++i){\n    for(int j = i+1; j < n; ++j){\n      if(abs(x[i]-x[j]) < d) ts.add_clause(i,false,j,false);\n      if(abs(x[i]-y[j]) < d) ts.add_clause(i,false,j,true);\n      if(abs(y[i]-x[j]) < d) ts.add_clause(i,true,j,false);\n      if(abs(y[i]-y[j]) < d) ts.add_clause(i,true,j,true);\n    }\n  }\n  if(ts.satisfiable()){\n    cout << \"Yes\\n\";\n    vector<bool> ans = ts.answer();\n    for(int i = 0; i < n; ++i){\n      if(ans[i]) cout << x[i] << '\\n';\n      else cout << y[i] << '\\n';\n    }\n  }\n  else cout << \"No\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\n#include <atcoder/all>\nusing namespace atcoder;\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<ll> x(N), y(N);\n    rep(i, N) {\n        cin >> x[i] >> y[i];\n    }\n    two_sat ts(N);\n    rep(i,N) {\n        for(int j = i+1; j<N; ++j) {\n            if (abs(x[i]-x[j])<D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i]-y[j])<D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i]-x[j])<D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i]-y[j])<D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    rep(i, N){\n        if (ans[i]) {\n            cout << x[i] << endl;\n        } else {\n            cout << y[i] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i ++)\n#define irep(i,n) for (int i = (int)(n) - 1;i >= 0;--i)\nusing namespace std;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;// = 998244353;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\n\n\nstruct StronglyConnectedComponents {\n    int N;\n    vector<vector<int>> G,rG;\n    vector<int> group,order;\n\n    StronglyConnectedComponents(int _N): N(_N) {\n        G.resize(N); rG.resize(N); group.assign(N,1);\n    }\n    \n    void add_edge(int a,int b) {\n        G[a].push_back(b);\n        rG[b].push_back(a);\n    }\n\n    void dfs(int v) {\n        group[v] = -1;\n        for (int e: G[v]) {\n            if (group[e] > 0) dfs(e);\n        }\n        order.push_back(v);\n    }\n\n    void rdfs(int v,int cnt) {\n        group[v] = cnt;\n        for (int e: rG[v]) {\n            if (group[e] < 0) rdfs(e,cnt);\n        }\n    }\n\n    void build() {\n        for (int i = 0;i < N;i ++) {\n            if (group[i] > 0) dfs(i);\n        }\n        reverse(begin(order),end(order));\n        int cnt = 0;\n        for (int v: order) {\n            if (group[v] < 0) rdfs(v,cnt),cnt++;\n        }\n    }\n\n    int operator[](int i) {\n        return group[i];\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N; ll D; cin >> N >> D;\n    vector<ll> X(N),Y(N);\n    rep(i,N) cin >> X[i] >> Y[i];\n\n    StronglyConnectedComponents scc(2*N);\n    rep(i,N) {\n        for (int j = i + 1;j < N;++j) {\n            if (abs(X[i] - X[j]) < D) {\n                scc.add_edge(i,j + N);\n                scc.add_edge(j,i + N);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                scc.add_edge(i,j);\n                scc.add_edge(j + N,i + N);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                scc.add_edge(i + N,j + N);\n                scc.add_edge(j,i);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                scc.add_edge(i + N,j);\n                scc.add_edge(j + N,i);\n            }\n        }\n    }\n    scc.build();\n    vector<int> ans(N);\n    rep(i,N) {\n        if (scc[i] == scc[i + N]) {\n            cout << \"No\" << '\\n';\n            return 0;\n        }\n        if (scc[i] < scc[i + N]) ans[i] = Y[i];\n        else ans[i] = X[i];\n    }\n    cout << \"Yes\" << '\\n';\n    rep(i,N) cout << ans[i] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nstruct SCC{\n    int n;\n    vector<vector<int>> g,rg;\n    vector<int> vs,cmp;\n    vector<bool> used;\n    SCC(int _n){\n        n=_n;\n        g=vector<vector<int>>(n);rg=g;\n        cmp=vector<int>(n);used=vector<bool>(n);\n    }\n    void add_edge(int f, int t){\n        g[f].push_back(t);\n        rg[t].push_back(f);\n    }\n    int init(){\n        rep(i,n)if(!used[i])dfs(i);\n        int k=0;\n        used=vector<bool>(n,false);\n        per(i,n){\n            if(!used[vs[i]]){\n                rdfs(vs[i],k);\n                k++;\n            }\n        }\n        return k;\n    }\n    private:\n    void dfs(int v){\n        used[v]=true;\n        rep(i,g[v].size()){\n            if(!used[g[v][i]])dfs(g[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v]=true;cmp[v]=k;\n        rep(i,rg[v].size()){\n            if(!used[rg[v][i]]){\n                rdfs(rg[v][i],k);\n            }\n        }\n    }\n};\n\nstruct twoSAT{\n    vector<bool> ans;\n    twoSAT(int _n):n(_n),graph(2*n),ans(n){}\n    void add_edge(int i,bool x,int j,bool y){//i=>j;\n        if(!x)i+=n;if(!y)j+=n;\n        graph.add_edge((i+n)%(2*n),j);\n        graph.add_edge((j+n)%(2*n),i);\n    }\n    bool exe(){\n        graph.init();\n        rep(i,n){\n            if(graph.cmp[i]==graph.cmp[i+n])return false;\n            else if(graph.cmp[i]>graph.cmp[i+n])ans[i]=true;\n            else ans[i]=false;\n        }\n        return true;\n    }\n    private:\n    int n;SCC graph;\n};\n\nint main(){\n    ll n,d;cin >> n >>d;\n    twoSAT g(n);\n    vl x(n),y(n);rep(i,n)cin >> x[i] >> y[i];\n    rep(i,n){\n        repl(j,i+1,n){\n            if(abs(x[i]-x[j])<d){\n                g.add_edge(i,0,j,0);\n            }\n            if(abs(x[i]-y[j])<d){\n                g.add_edge(i,0,j,1);\n            }\n            if(abs(y[i]-x[j])<d){\n                g.add_edge(i,1,j,0);\n            }\n            if(abs(y[i]-y[j])<d){\n                g.add_edge(i,1,j,1);\n            }\n        }\n    }\n    if(g.exe()){\n        cout << \"Yes\" <<endl;\n        rep(i,n){\n            if(g.ans[i])cout << x[i] <<endl;\n            else cout << y[i] <<endl;\n        }\n    }\n    else{\n        cout << \"No\" <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param n `0 <= n`\n        // @return minimum non-negative `x` s.t. `n <= 2**x`\n        int ceil_pow2(int n)\n        {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n))\n                x++;\n            return x;\n        }\n        // @param n `1 <= n`\n        // @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\n        int bsf(unsigned int n)\n        {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param m `1 <= m`\n        // @return x mod m\n        constexpr long long safe_mod(long long x, long long m)\n        {\n            x %= m;\n            if (x < 0)\n                x += m;\n            return x;\n        }\n        // Fast moduler by barrett reduction\n        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n        // NOTE: reconsider after Ice Lake\n        struct barrett\n        {\n            unsigned int _m;\n            unsigned long long im;\n            // @param m `1 <= m`\n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            // @return m\n            unsigned int umod() const { return _m; }\n            // @param a `0 <= a < m`\n            // @param b `0 <= b < m`\n            // @return `a * b % m`\n            unsigned int mul(unsigned int a, unsigned int b) const\n            {\n                // [1] m = 1\n                // a = b = im = 0, so okay\n                // [2] m >= 2\n                // im = ceil(2^64 / m)\n                // -> im * m = 2^64 + r (0 <= r < m)\n                // let z = a*b = c*m + d (0 <= c, d < m)\n                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n                // ((ab * im) >> 64) == c or c + 1\n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v)\n                    v += _m;\n                return v;\n            }\n        };\n        // @param n `0 <= n`\n        // @param m `1 <= m`\n        // @return `(x ** n) % m`\n        constexpr long long pow_mod_constexpr(long long x, long long n, int m)\n        {\n            if (m == 1)\n                return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n)\n            {\n                if (n & 1)\n                    r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        // Reference:\n        // M. Forisek and J. Jancina,\n        // Fast Primality Testing for Integers That Fit into a Machine Word\n        // @param n `0 <= n`\n        constexpr bool is_prime_constexpr(int n)\n        {\n            if (n <= 1)\n                return false;\n            if (n == 2 || n == 7 || n == 61)\n                return true;\n            if (n % 2 == 0)\n                return false;\n            long long d = n - 1;\n            while (d % 2 == 0)\n                d /= 2;\n            for (long long a : {2, 7, 61})\n            {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1)\n                {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n>\n        constexpr bool is_prime = is_prime_constexpr(n);\n        // @param b `1 <= b`\n        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)\n        {\n            a = safe_mod(a, b);\n            if (a == 0)\n                return {b, 0};\n            // Contracts:\n            // [1] s - m0 * a = 0 (mod b)\n            // [2] t - m1 * a = 0 (mod b)\n            // [3] s * |m1| + t * |m0| <= b\n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            while (t)\n            {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b\n                // [3]:\n                // (s - t * u) * |m1| + t * |m0 - m1 * u|\n                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n                // = s * |m1| + t * |m0| <= b\n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            // by [3]: |m0| <= b/g\n            // by g != b: |m0| < b/g\n            if (m0 < 0)\n                m0 += b / s;\n            return {s, m0};\n        }\n        // Compile time primitive root\n        // @param m must be prime\n        // @return primitive root (and minimum in now)\n        constexpr int primitive_root_constexpr(int m)\n        {\n            if (m == 2)\n                return 1;\n            if (m == 167772161)\n                return 3;\n            if (m == 469762049)\n                return 3;\n            if (m == 754974721)\n                return 11;\n            if (m == 998244353)\n                return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0)\n                x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    divs[cnt++] = i;\n                    while (x % i == 0)\n                    {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1)\n            {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++)\n            {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++)\n                {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    return g;\n            }\n        }\n        template <int m>\n        constexpr int primitive_root = primitive_root_constexpr(m);\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class T>\n        struct simple_queue\n        {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T &t) { payload.push_back(t); }\n            T &front() { return payload[pos]; }\n            void clear()\n            {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class E>\n        struct csr\n        {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>> &edges)\n                : start(n + 1), elist(edges.size())\n            {\n                for (auto e : edges)\n                {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++)\n                {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges)\n                {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        // Reference:\n        // R. Tarjan,\n        // Depth-First Search and Linear Graph Algorithms\n        struct scc_graph\n        {\n        public:\n            scc_graph(int n) : _n(n) {}\n            int num_vertices() { return _n; }\n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            // @return pair of (# of scc, scc id)\n            std::pair<int, std::vector<int>> scc_ids()\n            {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++)\n                    {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1)\n                        {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        }\n                        else\n                        {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v])\n                    {\n                        while (true)\n                        {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v)\n                                break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++)\n                {\n                    if (ord[i] == -1)\n                        dfs(dfs, i);\n                }\n                for (auto &x : ids)\n                {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            std::vector<std::vector<int>> scc()\n            {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second)\n                    counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++)\n                {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++)\n                {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n\n        private:\n            int _n;\n            struct edge\n            {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder\n{\n    namespace internal\n    {\n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                          std::is_same<T, __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                          std::is_same<T, unsigned __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using make_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value,\n                                      __uint128_t,\n                                      unsigned __int128>;\n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                          is_signed_int128<T>::value ||\n                                                          is_unsigned_int128<T>::value,\n                                                      std::true_type,\n                                                      std::false_type>::type;\n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n                                                            is_signed_int128<T>::value,\n                                                        std::true_type,\n                                                        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<(is_integral<T>::value &&\n                                       std::is_unsigned<T>::value) ||\n                                          is_unsigned_int128<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<\n            is_signed_int128<T>::value,\n            make_unsigned_int128<T>,\n            typename std::conditional<std::is_signed<T>::value,\n                                      std::make_unsigned<T>,\n                                      std::common_type<T>>::type>::type;\n#else\n        template <class T>\n        using is_integral = typename std::is_integral<T>;\n        template <class T>\n        using is_signed_int =\n            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<is_integral<T>::value &&\n                                          std::is_unsigned<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                                      std::make_unsigned<T>,\n                                                      std::common_type<T>>::type;\n#endif\n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        template <class T>\n        using to_unsigned_t = typename to_unsigned<T>::type;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        struct modint_base\n        {\n        };\n        struct static_modint_base : modint_base\n        {\n        };\n        template <class T>\n        using is_modint = std::is_base_of<modint_base, T>;\n        template <class T>\n        using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n    } // namespace internal\n    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>\n    struct static_modint : internal::static_modint_base\n    {\n        using mint = static_modint;\n\n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0)\n                x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v -= rhs._v;\n            if (_v >= umod())\n                _v += umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            if (prime)\n            {\n                assert(_v);\n                return pow(umod() - 2);\n            }\n            else\n            {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    template <int id>\n    struct dynamic_modint : internal::modint_base\n    {\n        using mint = dynamic_modint;\n\n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m)\n        {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0)\n                x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v += mod() - rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id>\n    internal::barrett dynamic_modint<id>::bt = 998244353;\n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    namespace internal\n    {\n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        template <class>\n        struct is_dynamic_modint : public std::false_type\n        {\n        };\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type\n        {\n        };\n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_e[30]; // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly_inv(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_ie[30]; // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            for (int ph = h; ph >= 1; ph--)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                            (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                            inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n    } // namespace internal\n    template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        if (std::min(n, m) <= 60)\n        {\n            if (n < m)\n            {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++)\n        {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++)\n            a[i] *= iz;\n        return a;\n    }\n    template <unsigned int mod = 998244353,\n              class T,\n              std::enable_if_t<internal::is_integral<T>::value> * = nullptr>\n    std::vector<T> convolution(const std::vector<T> &a, const std::vector<T> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++)\n        {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++)\n        {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    std::vector<long long> convolution_ll(const std::vector<long long> &a,\n                                          const std::vector<long long> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        static constexpr unsigned long long MOD1 = 754974721; // 2^24\n        static constexpr unsigned long long MOD2 = 167772161; // 2^25\n        static constexpr unsigned long long MOD3 = 469762049; // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        static constexpr unsigned long long i1 =\n            internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n            internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n            internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            // B = 2^63, -B <= x, r(real value) < B\n            // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n            // r = c1[i] (mod MOD1)\n            // focus on MOD1\n            // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n            // r = x,\n            //     x - M' + (0 or 2B),\n            //     x - 2M' + (0, 2B or 4B),\n            //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n            // (r - x) = 0, (0)\n            //           - M' + (0 or 2B), (1)\n            //           -2M' + (0 or 2B or 4B), (2)\n            //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n            // we checked that\n            //   ((1) mod MOD1) mod 5 = 2\n            //   ((2) mod MOD1) mod 5 = 3\n            //   ((3) mod MOD1) mod 5 = 4\n            long long diff =\n                c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0)\n                diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        return c;\n    }\n} // namespace atcoder\n#endif // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Implement (union by size) + (path compression)\n    // Reference:\n    // Zvi Galil and Giuseppe F. Italiano,\n    // Data structures and algorithms for disjoint set union problems\n    struct dsu\n    {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        int merge(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y)\n                return x;\n            if (-parent_or_size[x] < -parent_or_size[y])\n                std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        bool same(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        int leader(int a)\n        {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0)\n                return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        int size(int a)\n        {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        std::vector<std::vector<int>> groups()\n        {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++)\n            {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                std::remove_if(result.begin(), result.end(),\n                               [&](const std::vector<int> &v) { return v.empty(); }),\n                result.end());\n            return result;\n        }\n\n    private:\n        int _n;\n        // root node: -1 * component size\n        // otherwise: parent\n        std::vector<int> parent_or_size;\n    };\n} // namespace atcoder\n#endif // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference: https://en.wikipedia.org/wiki/Fenwick_tree\n    template <class T>\n    struct fenwick_tree\n    {\n        using U = internal::to_unsigned_t<T>;\n\n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        void add(int p, T x)\n        {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n)\n            {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        T sum(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n\n    private:\n        int _n;\n        std::vector<U> data;\n        U sum(int r)\n        {\n            U s = 0;\n            while (r > 0)\n            {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder\n{\n    template <class S,\n              S (*op)(S, S),\n              S (*e)(),\n              class F,\n              S (*mapping)(F, S),\n              F (*composition)(F, F),\n              F (*id)()>\n    struct lazy_segtree\n    {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            return d[p];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push(r >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        void apply(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        void apply(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push((r - 1) >> i);\n            }\n            {\n                int l2 = l, r2 = r;\n                while (l < r)\n                {\n                    if (l & 1)\n                        all_apply(l++, f);\n                    if (r & 1)\n                        all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    update(l >> i);\n                if (((r >> i) << i) != r)\n                    update((r - 1) >> i);\n            }\n        }\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                push(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                push((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f)\n        {\n            d[k] = mapping(f, d[k]);\n            if (k < size)\n                lz[k] = composition(f, lz[k]);\n        }\n        void push(int k)\n        {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder\n{\n    long long pow_mod(long long x, long long n, int m)\n    {\n        assert(0 <= n && 1 <= m);\n        if (m == 1)\n            return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n)\n        {\n            if (n & 1)\n                r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    long long inv_mod(long long x, long long m)\n    {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    // (rem, mod)\n    std::pair<long long, long long> crt(const std::vector<long long> &r,\n                                        const std::vector<long long> &m)\n    {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        // Contracts: 0 <= r0 < m0\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++)\n        {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1)\n            {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0)\n            {\n                if (r0 % m1 != r1)\n                    return {0, 0};\n                continue;\n            }\n            // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n            // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n            // r2 % m0 = r0\n            // r2 % m1 = r1\n            // -> (r0 + x*m0) % m1 = r1\n            // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n            // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n            // im = inv(u0) (mod u1) (0 <= im < u1)\n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            long long u1 = (m1 / g);\n            // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n            if ((r1 - r0) % g)\n                return {0, 0};\n            // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n            long long x = (r1 - r0) / g % u1 * im % u1;\n            // |r0| + |m0 * x|\n            // < m0 + m0 * (u1 - 1)\n            // = m0 + m0 * m1 / g - m0\n            // = lcm(m0, m1)\n            r0 += x * m0;\n            m0 *= u1; // -> lcm(m0, m1)\n            if (r0 < 0)\n                r0 += m0;\n        }\n        return {r0, m0};\n    }\n    long long floor_sum(long long n, long long m, long long a, long long b)\n    {\n        long long ans = 0;\n        if (a >= m)\n        {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m)\n        {\n            ans += n * (b / m);\n            b %= m;\n        }\n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0)\n            return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n} // namespace atcoder\n#endif // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap>\n    struct mf_graph\n    {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++)\n            {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto &_e = g[pos[i].first][pos[i].second];\n            auto &_re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        Cap flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty())\n                {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v])\n                    {\n                        if (e.cap == 0 || level[e.to] >= 0)\n                            continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t)\n                            return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s)\n                    return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int &i = iter[v]; i < int(g[v].size()); i++)\n                {\n                    _edge &e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0)\n                        continue;\n                    Cap d =\n                        self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0)\n                        continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up)\n                        break;\n                }\n                return res;\n            };\n            Cap flow = 0;\n            while (flow < flow_limit)\n            {\n                bfs();\n                if (level[t] == -1)\n                    break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit)\n                {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f)\n                        break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        std::vector<bool> min_cut(int s)\n        {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty())\n            {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p])\n                {\n                    if (e.cap && !visited[e.to])\n                    {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap, class Cost>\n    struct mcf_graph\n    {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap, Cost cost)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first,\n                _e.to,\n                _e.cap + _re.cap,\n                _re.cap,\n                _e.cost,\n            };\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++)\n            {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        std::pair<Cap, Cost> flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit)\n        {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t)\n        {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            // variants (C = maxcost):\n            // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n            // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q\n                {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty())\n                {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v])\n                        continue;\n                    vis[v] = true;\n                    if (v == t)\n                        break;\n                    // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                    // dist[v] >= 0 (all reduced cost are positive)\n                    // dist[v] <= (n-1)C\n                    for (int i = 0; i < int(g[v].size()); i++)\n                    {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap)\n                            continue;\n                        // |-dual[e.to] + dual[v]| <= (n-1)C\n                        // cost <= C - -(n-1)C + 0 = nC\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost)\n                        {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t])\n                {\n                    return false;\n                }\n                for (int v = 0; v < _n; v++)\n                {\n                    if (!vis[v])\n                        continue;\n                    // dual[v] = dual[v] - dist[t] + dist[v]\n                    //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                    //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                    //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit)\n            {\n                if (!dual_ref())\n                    break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v])\n                {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v])\n                {\n                    auto &e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d)\n                {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    struct scc_graph\n    {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        void add_edge(int from, int to)\n        {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n    private:\n        internal::scc_graph internal;\n    };\n} // namespace atcoder\n#endif // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f)\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f)\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n} // namespace atcoder\n#endif // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        std::vector<int> sa_naive(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r)\n                    return false;\n                while (l < n && r < n)\n                {\n                    if (s[l] != s[r])\n                        return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        std::vector<int> sa_doubling(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2)\n            {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y])\n                        return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        // SA-IS, linear-time suffix array construction\n        // Reference:\n        // G. Nong, S. Zhang, and W. H. Chan,\n        // Two Efficient Algorithms for Linear Time Suffix Array Construction\n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int> &s, int upper)\n        {\n            int n = int(s.size());\n            if (n == 0)\n                return {};\n            if (n == 1)\n                return {0};\n            if (n == 2)\n            {\n                if (s[0] < s[1])\n                {\n                    return {0, 1};\n                }\n                else\n                {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE)\n            {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING)\n            {\n                return sa_doubling(s);\n            }\n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--)\n            {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++)\n            {\n                if (!ls[i])\n                {\n                    sum_s[s[i]]++;\n                }\n                else\n                {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++)\n            {\n                sum_s[i] += sum_l[i];\n                if (i < upper)\n                    sum_l[i + 1] += sum_s[i];\n            }\n            auto induce = [&](const std::vector<int> &lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms)\n                {\n                    if (d == n)\n                        continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1])\n                    {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1])\n                    {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms.push_back(i);\n                }\n            }\n            induce(lms);\n            if (m)\n            {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa)\n                {\n                    if (lms_map[v] != -1)\n                        sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++)\n                {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r)\n                    {\n                        same = false;\n                    }\n                    else\n                    {\n                        while (l < end_l)\n                        {\n                            if (s[l] != s[r])\n                            {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r])\n                            same = false;\n                    }\n                    if (!same)\n                        rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                auto rec_sa =\n                    sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                for (int i = 0; i < m; i++)\n                {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n    } // namespace internal\n    std::vector<int> suffix_array(const std::vector<int> &s, int upper)\n    {\n        assert(0 <= upper);\n        for (int d : s)\n        {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    template <class T>\n    std::vector<int> suffix_array(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (i && s[idx[i - 1]] != s[idx[i]])\n                now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    std::vector<int> suffix_array(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    // Reference:\n    // T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    // Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    // Applications\n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T> &s,\n                               const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++)\n        {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (h > 0)\n                h--;\n            if (rnk[i] == 0)\n                continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++)\n            {\n                if (s[j + h] != s[i + h])\n                    break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    std::vector<int> lcp_array(const std::string &s, const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    // Reference:\n    // D. Gusfield,\n    // Algorithms on Strings, Trees, and Sequences: Computer Science and\n    // Computational Biology\n    template <class T>\n    std::vector<int> z_algorithm(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        if (n == 0)\n            return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++)\n        {\n            int &k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k])\n                k++;\n            if (j + z[j] < i + z[i])\n                j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    std::vector<int> z_algorithm(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n} // namespace atcoder\n#endif // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference:\n    // B. Aspvall, M. Plass, and R. Tarjan,\n    // A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n    // Formulas\n    struct two_sat\n    {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        void add_clause(int i, bool f, int j, bool g)\n        {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable()\n        {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++)\n            {\n                if (id[2 * i] == id[2 * i + 1])\n                    return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n\n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n} // namespace atcoder\n#endif // ATCODER_TWOSAT_HPP\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define endl '\\n'\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define modd 1000000007ll\n//#define modd 998244353ll\n#define flagcount(bit) __builtin_popcount(bit)\n#define flag(x) (1ll << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1ll << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define idx_lower(v, x) (distance(v.begin(), low2way(v, x)))  //配列vでx未満の要素数を返す\n#define idx_upper(v, x) (distance(v.begin(), high2way(v, x))) //配列vでx以下の要素数を返す\n#define idx_lower2(v, x) (v.size() - idx_lower(v, x))         //配列vでx以上の要素数を返す\n#define idx_upper2(v, x) (v.size() - idx_upper(v, x))         //配列vでxより大きい要素の数を返す\n#define putout(a) cout << a << '\\n'\n#define Sum(v) accumulate(all(v), 0ll)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return -1;\n}\ntemplate <typename T>\nstring make_string(T N)\n{\n    string ret;\n    T now = N;\n    while (now > 0)\n    {\n        T x = now % 10;\n        ret += (char)('0' + x);\n        now /= 10;\n    }\n    reverse(all(ret));\n    return ret;\n}\ntemplate <typename T>\nT gcd(T a, T b)\n{\n    if (a % b == 0)\n    {\n        return (b);\n    }\n    else\n    {\n        return (gcd(b, a % b));\n    }\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nbool chmax(T &a, const T &b)\n{\n    if (a < b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nbool chmin(T &a, const T &b)\n{\n    if (a > b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//2次元配列の宣言\n//vector<vector<ll>> field(h, vector<ll>(w));\nint main()\n{\n    cout << fixed << setprecision(15);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll N, D;\n    cin >> N >> D;\n    vector<ll> X(N), Y(N);\n    loop(i, N) cin >> X[i] >> Y[i];\n    string y = \"Yes\", n = \"No\";\n    two_sat ts(N);\n    loop(i, N)\n    {\n        Loop(j, i + 1, N)\n        {\n            if (abs(X[i] - X[j]) < D)\n                ts.add_clause(i, 0, j, 0);\n            if (abs(X[i] - Y[j]) < D)\n                ts.add_clause(i, 0, j, 1);\n            if (abs(Y[i] - X[j]) < D)\n                ts.add_clause(i, 1, j, 0);\n            if (abs(Y[i] - Y[j]) < D)\n                ts.add_clause(i, 1, j, 1);\n        }\n    }\n    if (!ts.satisfiable())\n    {\n        putout(n);\n        return 0;\n    }\n    vector<bool> ans = ts.answer();\n    putout(y);\n    loop(i, N)\n    {\n        if (ans[i])\n            putout(X[i]);\n        else\n            putout(Y[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>; using vi = vector<int>; using vvi = vector<vi>; using vl = vector<ll>; using vvl = vector<vl>;\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#include <atcoder/all>\nusing namespace atcoder;\n\n// 旗iの座標をFiとする。\n// Fi=Xi or Fi=Yi である。\n// (Fi=Xi or Fj=Xj) は (Fi=Yi → Fj=Xj) と同値。\n// 対偶を取ると，Fj=Yj → Fi=Xi と更に同値。\n// i=0,1,...,N-1に対し，\n// (1)|Xi-Xj|<D のとき (Fi=Xi → Fj=Yj) i.e. (Fi=Yi or Fj=Yj) というクローズを加え，\n// (2)|Xi-Yj|<D のとき (Fi=Xi → Fj=Xj) i.e. (Fi=Yi or Fj=Xj) というクローズを加え，\n// (3)|Yi-Yj|<D のとき (Fi=Yi → Fj=Xj) i.e. (Fi=Xi or Fj=Xj) というクローズを加え，\n// (4)|Yi-Xj|<D のとき (Fi=Yi → Fj=Yj) i.e. (Fi=Xi or Fj=Yj) というクローズを加える。 ※(2)でカバー済\n// Fi=Xiであることをtrueで，Fi=Yiであることをfalseで表す。\n\nint main() {\n\tint N, D; cin >> N >> D;\n\tvi X(N), Y(N); rep(i, N) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\trep(i, N) rep2(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\tif (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> v = ts.answer();\n\t\trep(i, N) cout << (v[i] ? X[i] : Y[i]) << endl;\n\t\t// for (auto e : ts.answer()) {\n\t\t// \tdbl(e);\n\t\t// }\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\nusing ll = long long;\nusing Edge = int;\nusing Graph = vector<vector<Edge>>;\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\nconst ll MOD = 1000000007;\nconst ll nmax = 8;\nconst ll INF = 1e13;\nconst int MAX = 510000;\nbool graph[nmax][nmax];\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll COM(int n, int k)\n{\n    if (n < k)\n        return 0;\n    if (n < 0 || k < 0)\n        return 0;\n\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nvector<vector<ll>> dist = vector<vector<ll>>(nmax, vector<ll>(nmax, INF));\nstruct SegmentTree\n{\nprivate:\n    ll n;\n    vector<ll> node;\n\npublic:\n    SegmentTree(vector<ll> v)\n    {\n        ll sz = v.size();\n        n = 1;\n        while (n < sz)\n        {\n            n *= 2;\n        }\n        node.resize(2 * n - 1, INF);\n\n        for (ll i = 0; i < sz; i++)\n        {\n            node[i + n - 1] = v[i];\n        }\n\n        for (ll i = n - 2; i >= 0; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n    void update(ll x, ll val)\n    {\n        x += (n - 1);\n        node[x] = val;\n        while (x > 0)\n        {\n            x = (x - 1) / 2;\n            node[x] = min(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n\n    // findは半開区間で考える\n    ll find(ll a, ll b, ll k = 0, ll l = 0, ll r = -1)\n    {\n        if (r < 0)\n            r = n;\n\n        if (r <= a || b <= l)\n            return INF;\n\n        if (a <= l && r <= b)\n            return node[k];\n\n        ll vl = find(a, b, 2 * k + 1, l, (l + r) / 2);\n        ll vr = find(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n};\nvoid warshall_floyd(ll n)\n{\n    for (size_t i = 0; i < n; i++)\n    {\n        for (size_t j = 0; j < n; j++)\n        {\n            for (size_t k = 0; k < n; k++)\n            {\n                dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n            }\n        }\n    }\n}\n\nclass UnionFind\n{\npublic:\n    vector<ll> Parent;\n\n    UnionFind(ll N)\n    {\n        Parent = vector<ll>(N, -1);\n    }\n    ll find(ll A)\n    {\n        if (Parent[A] < 0)\n            return A;\n        return Parent[A] = find(Parent[A]);\n    }\n\n    ll size(ll A)\n    {\n        return -Parent[find(A)];\n    }\n\n    bool Union(ll A, ll B)\n    {\n        A = find(A);\n        B = find(B);\n        if (A == B)\n        {\n            return false;\n        }\n        if (size(A) < size(B))\n            swap(A, B);\n\n        Parent[A] += Parent[B];\n        Parent[B] = A;\n\n        return true;\n    }\n};\n\nll gcd(ll a, ll b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b)\n{\n    ll g = gcd(a, b);\n    return a / g * b;\n}\n\nll mulMod(ll a, ll b)\n{\n    return (((a % MOD) * (b % MOD)) % MOD);\n}\n\nll powMod(ll a, ll p)\n{\n    if (p == 0)\n    {\n        return 1;\n    }\n    else if (p % 2 == 0)\n    {\n        ll half = powMod(a, p / 2);\n        return mulMod(half, half);\n    }\n    else\n    {\n        return mulMod(powMod(a, p - 1), a);\n    }\n}\n\nll ceil(ll a, ll b)\n{\n    return (a + b - 1) / b;\n}\n\nvector<ll> tsort(Graph G)\n{\n    ll N = G.size();\n    vector<ll> in(N);\n    for (auto &&edges : G)\n    {\n        for (auto &&edge : edges)\n        {\n            in[edge]++;\n        }\n    }\n\n    queue<int> que;\n\n    for (int i = 0; i < N; i++)\n    {\n        if (in[i] == 0)\n        {\n            que.push(i);\n        }\n    }\n    int cnt = 0;\n    vector<ll> ans;\n    while (!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        ans.push_back(v);\n        for (auto &&next : G[v])\n        {\n\n            in[next]--;\n            if (in[next] == 0)\n            {\n                que.push(next);\n            }\n        }\n    }\n    return ans;\n}\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nvoid solve(long long N, long long D, std::vector<long long> X, std::vector<long long> Y){\n\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long D;\n    scanf(\"%lld\",&D);\n\n    two_sat ts(N);\n\n    std::vector<long long> x(N);\n    std::vector<long long> y(N);\n    for(int i = 0 ; i < N ; i++){\n        scanf(\"%lld\",&x[i]);\n        scanf(\"%lld\",&y[i]);\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = i+1; j < N; j++)\n        {\n            if(abs(x[i]-x[j]) < D){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(x[i]-y[j]) < D){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(y[i]-x[j])<D){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(y[i]-y[j]) < D){\n                ts.add_clause(i,true,j,true);\n            }\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n\n    auto ans = ts.answer();\n\n    for (int i = 0; i < N; i++)\n    {\n        if(ans[i]){\n            cout << x[i] << endl;\n        }else{\n            cout << y[i] << endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"O3\")\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define EPS (1e-9)\n#define INF (1e17)\n#define PI (acos(-1))\n//const double PI = acos(-1);\n//const double EPS = 1e-15;\n//long long INF=(long long)1E17;\n#define i_7 (long long)(1e9+7)\n//#define i_7 998'244'353\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nlong long po(long a, long b){\n    if(b==0){\n        return 1;\n    }\n    \n    long long z = po(a,b/2);\n    z = mod(z*z);\n    if(b%2!=0){\n        z = mod(a*z);\n    }\n    return z;\n}\n \nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=std::sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n \nlong long gcd_(long long a, long long b){\n  if(a<b){\n    std::swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \n//using namespace std;\n//using namespace boost::multiprecision;\n//using namespace __gnu_pbds;\n\nint main(){\n  using namespace std;\n  using namespace atcoder;\n  \n  int n, d;\n  cin>>n>>d;\n  int x[n], y[n];\n  REP(i, n) cin>>x[i]>>y[i];\n  \n  two_sat ts(2 * n);\n  REP(i, n){\n    ts.add_clause(i, true, j, true);\n    ts.add_clause(i, false, j, false);\n  }\n  REP(i, n){\n    for(int j = i + 1; j < n; j++){\n      if(abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n      if(abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n      if(abs(y[i] - x[j]) < d) ts.add_clause(i + n, false, j, false);\n      if(abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n    }\n  }\n  bool possible = ts.satisfiable();\n  if(!possible){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  vector<bool> ans = ts.answer();\n  REP(i, n){\n    if(ts[i]){\n      cout << x[i] << endl;\n    }else{\n      cout << y[i] << endl;\n    }\n  }    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i, n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, d, x, y;\n    cin >> n >> d;\n    int xy[n][2];\n    rep(i, n) {\n        cin >> x >> y;\n        xy[i][0] = x;\n        xy[i][1] = y;\n    }\n    two_sat ts(n);\n    for (int i=0; i<n-1; i++) for (int j=i+1; j<n; j++) rep(k, 2) rep(l, 2) {\n        if (abs(xy[i][k]-xy[j][l])<d) ts.add_clause(i, 1-k, j, 1-l);\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, n) cout << xy[i][ans[i]] << \"\\n\";\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -----------------------------------\n// author   : MatsuTaku\n// country  : Japan\n// created  : 09/08/20 03:55:25\n// -----------------------------------\n\n#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int n,d; cin>>n>>d;\n  vector<array<int, 2>> Q(n);\n  for (int i = 0; i < n; i++) {\n    int x,y; cin>>x>>y;\n    Q[i] = {x, y};\n  }\n\n  atcoder::two_sat ts(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          if (abs(Q[i][k] - Q[j][l]) < d)\n            ts.add_clause(i, k^1, j, l^1);\n        }\n      }\n    }\n  }\n  if (ts.satisfiable()) {\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    for (int i = 0; i < n; i++) {\n      cout << Q[i][ans[i]] << endl;\n    }\n  } else {\n    cout << \"No\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<atcoder/all>\n#include<algorithm>\n\nusing namespace std;\n\n\nint n, d;\nint x[1100], y[1100];\n\nint main(){\n    cin >> n >> d;\n    for(int i = 0;i < n;i++){\n        cin >> x[i] >> y[i];\n    }\n    atcoder::two_sat ts(n);\n    for(int i = 0;i < n;i++){\n        for(int j = i + 1;j < n;j++){\n            if(abs(x[i] - x[j]) < d){\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(x[i] - y[j]) < d){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(y[i] - x[j]) < d){\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(y[i] - y[j]) < d){\n                ts.add_clause(i, true, j, true);\n            }           \n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for(int i = 0;i < n;i++){\n        cout << (answer[i]?x[i]:y[i]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n#include \"atcoder/all\"\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n\n    vector<P> v(n);\n    for (P &p:v) cin >> p.first >> p.second;\n\n    atcoder::two_sat ts(n);\n\n    rep(i, n) {\n        rep(j, n) {\n            if (i <= j) continue;\n            int ia = v[i].first;\n            int ib = v[i].second;\n            int ja = v[j].first;\n            int jb = v[j].second;\n\n            if (abs(ia - ja) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(ia - jb) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(ib - ja) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(ib - jb) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        ret();\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    rep(i, n) cout << (answer[i] ? v[i].first : v[i].second) << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#pragma GCC diagnostic ignored \"-Wall\"\n#pragma GCC diagnostic ignored \"-Wextra\"\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n#include \"atcoder/all\"\nusing namespace atcoder;\n#pragma GCC diagnostic warning \"-Wall\"\n#pragma GCC diagnostic warning \"-Wextra\"\n#pragma GCC diagnostic warning \"-Wconversion\"\n#pragma GCC diagnostic warning \"-Wpedantic\"\n#include <bits/stdc++.h>\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) (((n) >> (k)) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int MOD = (int)1e9 + 7;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = true;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n//#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n\ntwo_sat ts;\nint N, D;\nint x[1010], y[1010];\n\nvoid solve() {\n    ts = two_sat{N};\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(x[i] - x[j]) < D)\n                ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < D)\n                ts.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < D)\n                ts.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < D)\n                ts.add_clause(i, true, j, true);\n        }\n    }\n    if (!ts.satisfiable()) {\n        No();\n        return;\n    }\n    Yes();\n\n    auto ans = ts.answer();\n    for (int i = 0; i < N; i++) {\n        cout << (ans[i] ? x[i] : y[i]) << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> D;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<ll,ll> P;\ntypedef string str;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef dsu uf;\ntypedef fenwick_tree<ll> fw;\n\nconst ll mod=1e9+7;\nconst ll inf=1e18;\n\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define repr(i,m,n) for(ll i=m-1;i>=n;i--)\n#define fi first\n#define se second\n#define chmax(x,y) x=max(x,y)\n#define chmin(x,y) x=min(x,y)\n#define eb(x) emplace_back(x)\n#define pb(x) pop_back(x)\n#define all(x) x.begin(),x.end()\n#define allr(x) x.rbegin(),x.rend()\n#define pc(x) __builtin_popcount(x)\n#define gll greater<ll>()\n\n\n\nvoid solve(){\n int n,d;\n  cin >> n >> d;\n vector<int> x(2*n);\n  rep(i,0,2*n) cin >> x[i];\n  \n  two_sat s(2*n);\n  rep(i,0,n){\n   s.add_clause(i*2,true,i*2+1,true);\n   s.add_clause(i*2,false,i*2+1,false);\n  }\n  \n  rep(i,0,2*n){\n   rep(j,i+1,2*n) if(abs(x[i]-x[j])<d) s.add_clause(i,false,j,false); \n  }\n  \n  if(s.satisfiable()){\n   cout << \"Yes\" << endl; \n    vb ans=s.answer();\n    rep(i,0,ans.size()) if(ans[i]) cout << x[i] << endl;\n  }else{\n  cout << \"No\" << endl;\n    \n  }\n  \n}\nint main(){\n   cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <atcoder/all>\n\n#define F first\n#define S second\n//#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace atcoder;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000000;\nconst int K = 100000;\nconst int mod = 1e9 + 7;\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n, d;\n    cin >> n >> d;\n    two_sat ts(2 * n);\n    vector <int> a(2 * n);\n    for (int i = 0; i < n; i++){\n        cin >> a[2 * i] >> a[2 * i + 1];\n        ts.add_clause(2 * i, true, 2 * i + 1, true);\n        ts.add_clause(2 * i, false, 2 * i + 1, false);\n    }\n    int l = 0;\n    for (int i = 0; i < a.size(); i++){\n        for (int j = i + 1; j < a.size(); j++){\n            if (abs(a[i] - a[j]) < d){\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n    bool ans = ts.satisfiable();\n    if (ans){\n        cout << \"Yes\" << endl;\n        vector <bool> res = ts.answer();\n        for (int i = 0; i < 2 * n; i++){\n            if (res[i]){\n                cout << a[i] << endl;\n            }\n        }\n    } else{\n        cout << \"No\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iomanip>\n#include <climits>\n#include <functional>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<string> VS;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<PII> VPI;\ntypedef vector<PLL> VPL;\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pf push_front\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define ub upper_bound\n#define lb lower_bound\n\n#include <atcoder/convolution>\n#include <atcoder/dsu>\n#include <atcoder/fenwicktree>\n#include <atcoder/lazysegtree>\n#include <atcoder/math>\n#include <atcoder/maxflow>\n#include <atcoder/mincostflow>\n#include <atcoder/modint>\n#include <atcoder/scc>\n#include <atcoder/segtree>\n#include <atcoder/string>\n#include <atcoder/twosat>\n\nusing namespace atcoder;\n//typedef modint998244353 mint;\n\nint main(){\n  int N,D;\n  cin>>N>>D;\n  VI X(N),Y(N);\n  rep(i,N) cin>>X[i]>>Y[i];\n  two_sat ts(N);\n  rep(i,N) rep(j,N){\n    if(i>=j) continue;\n    if(abs(X[i]-X[j])<D) ts.add_clause(i, false, j, false);\n    if(abs(X[i]-Y[j])<D) ts.add_clause(i, false, j, true);\n    if(abs(Y[i]-X[j])<D) ts.add_clause(i, true, j, false);\n    if(abs(Y[i]-Y[j])<D) ts.add_clause(i, true, j, true);\n  }\n  if(!ts.satisfiable()){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  auto ans=ts.answer();\n  cout<<\"Yes\"<<endl;\n  rep(i,N){\n    if(ans[i]) cout<<X[i]<<endl;\n    else cout<<Y[i]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>; using vi = vector<int>; using vvi = vector<vi>; using vl = vector<ll>; using vvl = vector<vl>;\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#include <atcoder/all>\nusing namespace atcoder;\n\n// 旗iの座標をFiとする。\n// Fi=Xi or Fi=Yi である。\n// (Fi=Xi or Fj=Xj) は (Fi=Yi → Fj=Xj) と同値。\n// 対偶を取ると，Fj=Yj → Fi=Xi と更に同値。\n// i=0,1,...,N-1に対し，\n// (1)|Xi-Xj|<D のとき (Fi=Xi → Fj=Yj) i.e. (Fi=Yi or Fj=Yj) というクローズを加え，\n// (2)|Xi-Yj|<D のとき (Fi=Xi → Fj=Xj) i.e. (Fi=Yi or Fj=Xj) というクローズを加え，\n// (3)|Yi-Yj|<D のとき (Fi=Yi → Fj=Xj) i.e. (Fi=Xi or Fj=Xj) というクローズを加え，\n// (4)|Yi-Xj|<D のとき (Fi=Yi → Fj=Yj) i.e. (Fi=Xi or Fj=Yj) というクローズを加える。 ※(2)でカバー済\n// Fi=Xiであることをtrueで，Fi=Yiであることをfalseで表す。\n\nint main() {\n\tint N, D; cin >> N >> D;\n\tvi X(N), Y(N); rep(i, N) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\trep(i, N - 1) rep2(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\tif (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> v = ts.answer();\n\t\trep(i, N) cout << (v[i] ? X[i] : Y[i]) << endl;\n\t\t// for (auto e : ts.answer()) {\n\t\t// \tdbl(e);\n\t\t// }\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n\n    atcoder::two_sat sat(n * 2);\n    vector<int> x(n), y(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        sat.add_clause(i, false, n + i, false);\n        sat.add_clause(i, true, n + i, true);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x[i] - x[j]) < d) {\n                sat.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                sat.add_clause(i, false, n + j, false);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                sat.add_clause(n + i, false, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                sat.add_clause(n + i, false, n + j, false);\n            }\n        }\n    }\n\n    bool b = sat.satisfiable();\n\n    if (b) {\n        cout << \"Yes\\n\";\n        auto ans = sat.answer();\n        for (int i = 0; i < n; i++) {\n            if (ans[i]) {\n                cout << x[i] << \"\\n\";\n            } else {\n                cout << y[i] << \"\\n\";\n            }\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for(int i = 0; i < N; ++i)  cin >> X[i] >> Y[i];\n\n    vector<vector<int>> graph(N * 2), rev(N * 2);\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < i; ++j){\n            if(abs(X[i] - X[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2 + 1);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2 + 1);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                graph[i * 2].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2);\n            }\n            if(abs(Y[i] - Y[j]) < D){\n                graph[i * 2].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2);\n            }\n        }\n    }\n\n    vector<int> vs;\n    vector<bool> used(N * 2, false);\n    auto dfs = [&](auto&& self, int cur) -> void {\n        used[cur] = true;\n        for(int nxt : graph[cur]){\n            if(!used[nxt])  self(self, nxt);\n        }\n        vs.emplace_back(cur);\n    };\n    for(int v = 0; v < N * 2; ++v){\n        if(!used[v])    dfs(dfs, v);\n    }\n    reverse(vs.begin(), vs.end());\n\n    vector<int> scc_id(N * 2, -1);\n    int K = 0;\n    auto rdfs = [&](auto&& self, int cur) -> void {\n        scc_id[cur] = K;\n        for(int nxt : rev[cur]){\n            if(scc_id[nxt] == -1)   self(self, nxt);\n        }\n    };\n    for(int v : vs){\n        if(scc_id[v] == -1){\n            rdfs(rdfs, v);\n            ++K;\n        }\n    }\n\n    vector<bool> ans(N);\n    for(int i = 0; i < N; ++i){\n        if(scc_id[i * 2] == scc_id[i * 2 + 1]){\n            cout << \"No\\n\";\n            return 0;\n        }\n        ans[i] = scc_id[i * 2] < scc_id[i * 2 + 1];\n    }\n\n    cout << \"Yes\\n\";\n    for(int i = 0; i < N; ++i)  cout << (ans[i] ? X[i] : Y[i]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n//Strongly Connected Components\n#include<vector>\nstruct SCC{\n\tint n;\n\tvector<int>comp,order;\n\tvector<bool>used;\n\tvector<vector<int> >G,RG;\n\tSCC(int _n=0):n(_n),comp(_n,-1),used(_n,false),G(_n),RG(_n){}\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].push_back(to);\n\t\tRG[to].push_back(from);\n\t}\n\tvoid copy(const vector<vector<int> >&H)\n\t{\n\t\tfor(int i=0;i<H.size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<H[i].size();j++)\n\t\t\t{\n\t\t\t\tG[i].push_back(H[i][j]);\n\t\t\t\tRG[H[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint operator[](int u)const{return comp[u];}\n\tvoid dfs(int u)\n\t{\n\t\tused[u]=true;\n\t\tfor(int i=0;i<G[u].size();i++)if(!used[G[u][i]])dfs(G[u][i]);\n\t\torder.push_back(u);\n\t}\n\tvoid rdfs(int u,int cnt)\n\t{\n\t\tcomp[u]=cnt;\n\t\tfor(int i=0;i<RG[u].size();i++)if(comp[RG[u][i]]==-1)rdfs(RG[u][i],cnt);\n\t}\n\tint build()\n\t{\n\t\tfor(int i=0;i<n;i++)if(!used[i])dfs(i);\n\t\tint cnt=0;\n\t\tfor(int i=n-1;i>=0;i--)if(comp[order[i]]==-1)rdfs(order[i],cnt++);\n\t\treturn cnt;\n\t}\n\tint build(vector<vector<int> >&H)\n\t{\n\t\tint ret=build();\n\t\tH.assign(ret,vector<int>());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t{\n\t\t\t\tif(comp[i]!=comp[G[i][j]])\n\t\t\t\t\tH[comp[i]].push_back(comp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nint N,D;\nint X[1000],Y[1000];\nmain()\n{\n\tcin>>N>>D;\n\tSCC P(2*N);\n\tfor(int i=0;i<N;i++)cin>>X[i]>>Y[i];\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++)\n\t{\n\t\tif(abs(X[i]-X[j])<D)\n\t\t{\n\t\t\tP.add_edge(2*i,2*j+1);\n\t\t\tP.add_edge(2*j,2*i+1);\n\t\t}\n\t\tif(abs(Y[i]-X[j])<D)\n\t\t{\n\t\t\tP.add_edge(2*i+1,2*j+1);\n\t\t\tP.add_edge(2*j,2*i);\n\t\t}\n\t\tif(abs(X[i]-Y[j])<D)\n\t\t{\n\t\t\tP.add_edge(2*i,2*j);\n\t\t\tP.add_edge(2*j+1,2*i+1);\n\t\t}\n\t\tif(abs(Y[i]-Y[j])<D)\n\t\t{\n\t\t\tP.add_edge(2*i+1,2*j);\n\t\t\tP.add_edge(2*j+1,2*i);\n\t\t}\n\t}\n\tP.build();\n\tbool ok=true;\n\tfor(int i=0;i<N;i++)if(P[2*i]==P[2*i+1])ok=false;\n\tif(ok)\n\t{\n\t\tcout<<\"Yes\"<<endl;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tcout<<(P[2*i]>P[2*i+1]?X[i]:Y[i])<<endl;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout<<\"No\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <iostream>\n\nint main()\n{\n    int N, D;\n    std::cin >> N >> D;\n\n    std::vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) {\n        std::cin >> X[i] >> Y[i];\n    }\n\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (std::abs(X[i] - X[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n            if (std::abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (std::abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (std::abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if (not ts.satisfiable()) {\n        std::cout << \"No\" << '\\n';\n        return 0;\n    }\n\n    std::cout << \"Yes\" << '\\n';\n    const auto ans = ts.answer();\n    for (int i = 0; i < N; i++) {\n        std::cout << (ans[i]? Y[i] : X[i]) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nint main(){\n  int n,d;\n  cin>>n>>d;\n  vector<vector<int>> xy(n,vector<int>(2));\n  vector<vector<int>> xif;\n  for(int i=0;i<n;i++){\n    cin>>xy.at(i).at(0)>>xy.at(i).at(1);\n    xif.push_back({xy.at(i).at(0),i,0});\n    xif.push_back({xy.at(i).at(1),i,1});\n  }\n  sort(xif.begin(),xif.end());\n  two_sat f(n);\n  for(int l=0,r=0;l<n*2;l++){\n    while(r<n*2&&xif.at(r).at(0)<xif.at(l).at(0)+d)\n      r++;\n    for(int i=l+1;i<r;i++)\n      f.add_clause(xif.at(l).at(1),!(bool)xif.at(l).at(2),xif.at(i).at(1),!(bool)xif.at(i).at(2));\n  }\n  cout<<(f.satisfiable()?\"Yes\":\"No\")<<endl;\n  if(!f.satisfiable())\n    return 0;\n  vector<bool> a=f.answer();\n  for(int i=0;i<n;i++)\n    cout<<xy.at(i).at((int)a.at(i))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct sat2{\n    int N, n;\n    vector<vector<int>> G, rG;\n    vector<bool> used;\n    vector<int> temp;\n    vector<int> order;//分解後のトポロジカル順序\n    vector<bool> judge;\n    sat2(int V){\n        G.resize(2 * V);\n        rG.resize(2 * V);\n        N = 2 * V;\n        n = V;\n        order.resize(2 * V);\n        judge.resize(V);\n    }\n    void add_edge(int s, int t){\n        G[s].push_back(t);\n        rG[t].push_back(s);\n    }\n    void add(int s, bool f, int t, bool g){\n        add_edge(s + (f ? n : 0), t + (g ? 0 : n));\n        add_edge(t + (g ? n : 0), s + (f ? 0 : n));\n    }\n    void dfs(int s){\n        used[s] = true;\n        for(int j: G[s]){\n            if(!used[j]) dfs(j);\n        }\n        temp.push_back(s);\n    }\n    void rdfs(int s, int k){\n        used[s] = true;\n        order[s] = k;\n        for(int j: rG[s]){\n            if(!used[j]) rdfs(j, k);\n        }\n    }\n    bool solve(){//分解後の頂点数を返す\n        used.resize(N, false);\n        for(int i = 0; i < N; i++){\n            if(!used[i]) dfs(i);\n        }\n        used.assign(N, false);  \n        int k = 0;\n        for(int i = (int)temp.size() - 1; i >= 0; i--){ //番号が大きい方から順にdfs\n            if(!used[temp[i]]) {\n                rdfs(temp[i], k);\n                k++;\n            }\n        }\n        bool flag = true;\n        for(int i = 0; i < n; i++){\n            if(order[i] > order[i + n]) judge[i] = true;\n            else if(order[i] < order[i + n]) judge[i] = false;\n            else flag = false;\n        }\n        return flag;\n    }\n};\nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    int N, D;\n    cin >> N >> D;\n    sat2 sat2(N);\n    vector<int> X(N), Y(N);\n    for(int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N; j++){\n            if(abs(X[i] - X[j]) < D) sat2.add(i, false, j, false);\n            if(abs(X[i] - Y[j]) < D) sat2.add(i, false, j, true);\n            if(abs(Y[i] - X[j]) < D) sat2.add(i, true, j, false);\n            if(abs(Y[i] - Y[j]) < D) sat2.add(i, true, j, true);\n        }\n    }\n    bool flag = sat2.solve();\n    if(!flag) cout << \"No\" << endl;\n    else{\n        cout << \"Yes\" << endl;\n        for(int i = 0; i < N; i++){\n            if(sat2.judge[i]) cout << X[i] << endl;\n            else cout << Y[i] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#include <utility>\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\nint main(){\n  ll n, d;scanf(\"%lld %lld\", &n, &d);\n  two_sat t(2*n+1);\n  vll p(2*n);\n  for(int i=0;i<n;i++) {\n    scanf(\"%lld %lld\", &p[2*i], &p[2*i+1]);\n    t.add_clause(2*i, 1, 2*i+1, 1);\n  }\n  for(int i=0;i<2*n;i++){\n    for(int j=i+1;j<2*n;j++){\n      if(abs(p[i] - p[j]) < d) t.add_clause(i, 0, j, 0);\n    }\n  }\n  bool f = t.satisfiable();\n  if(!f) printf(\"No\\n\");\n  else{\n    printf(\"Yes\\n\");\n    auto ans = t.answer();\n    for(int i=0;i<n;i++){\n      if(ans[2*i]) printf(\"%lld\\n\", p[2*i]);\n      else printf(\"%lld\\n\", p[2*i+1]);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    long long N,D;\n    cin>>N>>D;\n    long long X[N],Y[N];\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n\n    two_sat ts(N);\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            long long pat1=(X[i]-X[j])*(X[i]-X[j]);\n            long long pat2=X[i]*X[i]+Y[j]*Y[j];\n            long long pat3=Y[i]*Y[i]+X[j]*X[j];\n            long long pat4=(Y[i]-Y[j])*(Y[i]-Y[j]);\n            //cout<<i<<\",\"<<j<<\"---\"<<pat1<<\",\"<<pat2<<\",\"<<pat3<<\",\"<<pat4<<\",\"<<D*D<<endl;\n            if(pat1<D*D) ts.add_clause(i,true,j,true);\n            if(pat2<D*D) ts.add_clause(i,true,j,false);\n            if(pat3<D*D) ts.add_clause(i,false,j,true);\n            if(pat4<D*D) ts.add_clause(i,false,j,false);\n        }\n    }\n\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        vector<bool> v=ts.answer();\n        for(int i=0;i<v.size();i++){\n            if(!v[i]) cout<<X[i]<<endl;\n            else cout<<Y[i]<<endl;\n        }\n    }\n    else cout<<\"No\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    int n, d; cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\n    two_sat data(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x[i] - x[j]) < d) data.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) data.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < d) data.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < d) data.add_clause(i, true, j, true);\n        }\n    }\n\n    if (!data.satisfiable()) {\n        cout << \"No\" << \"\\n\";\n        return 0;\n    }\n    cout << \"Yes\" << \"\\n\";\n    auto ans = data.answer();\n    for (int i = 0; i < n; i++) cout << (ans[i] ? x[i] : y[i]) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma region template\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- Ruby --- //\ntemplate <class F> struct Callable {\n\tF func;\n\tCallable(const F& f) : func(f) {}\n};\ntemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\treturn c.func(v);\n}\n\nstruct Sort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(begin(v), end(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\treturn v;\n\t}\n} Sort;\nstruct RSort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\tsort(rbegin(v), rend(v));\n\t\treturn v;\n\t}\n} RSort;\nstruct Reverse_impl {\n\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\treverse(begin(v), end(v));\n\t\treturn v;\n\t}\n} Reverse;\nstruct Unique_impl {\n\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Unique;\nstruct Uniq_impl {\n\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Uniq;\nstruct Rotate_impl {\n\ttemplate <class F> auto operator()(int left) {\n\t\treturn Callable([&](auto v) {\n\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} Rotate;\nstruct Max_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\treturn *max_element(begin(v), end(v));\n\t}\n} Max;\nstruct Min_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\treturn *min_element(begin(v), end(v));\n\t}\n} Min;\nstruct MaxPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t}\n} MaxPos;\nstruct MinPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t}\n} MinPos;\nstruct MaxBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_it = begin(v);\n\t\t\tauto max_val = f(*max_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_it = it;\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *max_it;\n\t\t});\n\t}\n} MaxBy;\nstruct MinBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_it = begin(v);\n\t\t\tauto min_val = f(*min_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_it = it;\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *min_it;\n\t\t});\n\t}\n} MinBy;\nstruct MaxOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_val;\n\t\t});\n\t}\n} MaxOf;\nstruct MinOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min_val;\n\t\t});\n\t}\n} MinOf;\nstruct Count_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count(begin(v), end(v), val);\n\t\t});\n\t}\n} Count;\nstruct CountIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count_if(begin(v), end(v), f);\n\t\t});\n\t}\n} CountIf;\nstruct Index_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} Index;\nstruct IndexIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} IndexIf;\nstruct FindIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t});\n\t}\n} FindIf;\nstruct Sum_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\treturn a + f(b);\n\t\t\t});\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t}\n} Sum;\nstruct Includes {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t});\n\t}\n} Includes;\nstruct IncludesIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t});\n\t}\n} IncludesIf;\nstruct RemoveIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} RemoveIf;\nstruct Each_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tf(i);\n\t\t\t}\n\t\t});\n\t}\n} Each;\nstruct Select_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\tvector<value_type> res;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Select;\nstruct Map_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\tvector<result_type> res;\n\t\t\tres.reserve(size(v));\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.push_back(f(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Map;\nstruct Indexed_impl {\n\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\tusing value_type = typename T::value_type;\n\t\tvector<pair<value_type, int>> res;\n\t\tres.reserve(size(v));\n\t\tint index = 0;\n\t\tfor (const auto& i : v) {\n\t\t\tres.emplace_back(i, index++);\n\t\t}\n\t\treturn res;\n\t}\n} Indexed;\nstruct AllOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (!f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} AllOf;\nstruct AnyOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n} AnyOf;\nstruct NoneOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} NoneOf;\n\n// --- functions --- //\ntemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\treturn lower_bound(all(a), v) - a.begin();\n}\ntemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\treturn upper_bound(all(a), v) - a.begin();\n}\ntemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n}\ninline auto operator*(string s, size_t n) {\n\tstring res;\n\tfor (size_t i = 0; i < n; ++i) res += s;\n\treturn res;\n}\ntemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\tv.insert(v.end(), all(v2));\n\treturn v;\n}\ntemplate <class T> inline T Ceil(T n, T m) {\n\treturn (n + m - 1) / m;\n}\ntemplate <class T> inline T Ceil2(T n, T m) {\n\treturn Ceil(n, m) * m;\n}\ntemplate <class T> inline T Tri(T n) {\n\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n}\ntemplate <class T> inline T nC2(T n) {\n\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n}\ntemplate <class T> inline T Mid(const T& l, const T& r) {\n\treturn l + (r - l) / 2;\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\treturn min <= v && v < max;\n}\ntemplate <class T> inline bool isSquere(T n) {\n\tT s = sqrt(n);\n\treturn s * s == n || (s + 1) * (s + 1) == n;\n}\ntemplate <class T = long long> inline T BIT(int b) {\n\treturn T(1) << b;\n}\ntemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n}\ntemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n}\ntemplate <class T> inline T Pow(T a, T n) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) r *= a;\n\t\ta *= a;\n\t\tn /= 2;\n\t}\n\treturn r;\n}\ntemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tr = r * a % m, n--;\n\t\telse\n\t\t\ta = a * a % m, n /= 2;\n\t}\n\treturn r;\n}\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n#pragma endregion\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\nbool ans[1001];\n\nint main() {\n\tin(n, d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tbitset<1001> ans;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tout.exit(\"No\");\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans[i] = true;\n\t}\n\n\tout(\"Yes\");\n\trep(i, n) out(ans[i] ? y[i] : x[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\nbool ans[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans[i] = true;\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(ans[i] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\ntypedef int64_t ll;\n\nint main(){\n  int n,d;\n  cin>>n>>d;\n  atcoder::two_sat ts(n);\n  ll x[n],y[n];\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n-1;i++){\n    for(int j=i+1;j<n;j++){\n      if(abs(x[i]-x[j])<d)ts.add_clause(i,false,j,false);\n      if(abs(x[i]-y[j])<d)ts.add_clause(i,false,j,true);\n      if(abs(y[i]-x[j])<d)ts.add_clause(i,true,j,false);\n      if(abs(y[i]-y[j])<d)ts.add_clause(i,true,j,true);\n    }\n  }\n  cout<<(ts.satisfiable() ? \"Yes\" : \"No\")<<endl;\n  if(ts.satisfiable()){\n    vector<bool> ans=ts.answer();\n    for(int i=0;i<n;i++){\n      if(ans[i])cout<<x[i]<<endl;\n      else cout<<y[i]<<endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef vector <vector<int>> Graph;\n\n// 強連結成分分解ライブラリ\nclass StronglyConnectedComponent {\npublic:\n  Graph G;\n  Graph rG;\n  Graph cG;\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> componentId;\n  int componentCount;\n  int V;\n\n  StronglyConnectedComponent(int V) {\n    this->V = V;\n    used = vector<bool>(V);\n    componentId = vector<int>(V);\n    G = Graph(V);\n    rG = Graph(V);\n  }\n\n  void add_edge(int from, int to) {\n    assert(0 <= from && from < V);\n    assert(0 <= to && to < V);\n\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void run() {\n    fill(used.begin(), used.end(), false);\n    componentCount = 0;\n    vs.clear();\n\n    for (int v = 0; v < V; ++v) {\n      if (used[v]) continue;\n\n      dfs(v);\n    }\n\n    fill(used.begin(), used.end(), false);\n\n    for (int i = vs.size() - 1; i >= 0; --i) {\n      int v = vs[i];\n      if (used[v]) continue;\n\n      cG.push_back(vector<int>());\n      rdfs(v, componentCount++);\n    }\n  }\n\nprivate:\n  void dfs(int v) {\n    used[v] = true;\n\n    for (int i = 0; i < (int) G[v].size(); ++i) {\n      int u = G[v][i];\n\n      if (used[u]) continue;\n\n      dfs(u);\n    }\n\n    vs.push_back(v);\n  }\n\n  void rdfs(int v, int k) {\n    used[v] = true;\n    componentId[v] = k;\n    cG[k].push_back(v);\n\n    for (int i = 0; i < (int) rG[v].size(); ++i) {\n      int u = rG[v][i];\n\n      if (used[u]) continue;\n\n      rdfs(u, k);\n    }\n  }\n};\n\nconst int MAX_V = 2010;\nint N, D;\nbool answer[MAX_V];\nStronglyConnectedComponent scc(MAX_V);\n\nvoid add_clause(int i, bool f, int j, bool g) {\n  assert(0 <= i && i < N);\n  assert(0 <= j && j < N);\n  scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n  scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n}\n\nbool satisfiable() {\n  scc.run();\n  memset(answer, false, sizeof(answer));\n\n  for (int i = 0; i < N; ++i) {\n    if (scc.componentId[2 * i] == scc.componentId[2 * i + 1]) return false;\n    answer[i] = scc.componentId[2 * i] < scc.componentId[2 * i + 1];\n  }\n\n  return true;\n}\n\nint main() {\n  cin >> N >> D;\n\n  int X[N];\n  int Y[N];\n\n  int x, y;\n  for (int i = 0; i < N; ++i) {\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n  }\n\n  for (int i = 0; i < N; ++i) {\n    int x1 = X[i];\n    int y1 = Y[i];\n\n    for (int j = i + 1; j < N; ++j) {\n      if (i == j) continue;\n\n      int x2 = X[j];\n      int y2 = Y[j];\n\n      if (abs(x1 - x2) < D) {\n        add_clause(i, false, j, false);\n      }\n\n      if (abs(x1 - y2) < D) {\n        add_clause(i, false, j, true);\n      }\n\n      if (abs(y1 - x2) < D) {\n        add_clause(i, true, j, false);\n      }\n\n      if (abs(y1 - y2) < D) {\n        add_clause(i, true, j, true);\n      }\n    }\n  }\n\n  if (satisfiable()) {\n    cout << \"Yes\" << endl;\n\n    for (int i = 0; i < N; ++i) {\n      if (answer[i]) {\n        cout << X[i] << endl;\n      } else {\n        cout << Y[i] << endl;\n      }\n    }\n  } else {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\n\ntypedef long long ll;\ntypedef std::pair<ll, ll> P;\n\nconstexpr ll INF = 1e15;\nconstexpr ll mod = 1e9+7;\n\n#define rep(i,n) for(int i = 0; i < int(n); i++)\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n\nint main() {\n    ll n, d;\n    cin >> n >> d;\n    vector<P> ps(n);\n    rep(i, n) {\n        cin >> ps[i].first >> ps[i].second;\n    }\n    auto graph = atcoder::two_sat(n);\n    rep(i, n) {\n        rep(j, n) {\n            if (i == j) continue;\n            //条件を満たさない場合にノードをつなぐ\n            if (abs(ps[i].first - ps[j].first) < d) {\n                graph.add_clause(i, true, j, true);\n            }\n            if (abs(ps[i].first - ps[j].second) < d) {\n                graph.add_clause(i, true, j, false);\n            }\n            if (abs(ps[i].second - ps[j].first) < d) {\n                graph.add_clause(i, false, j, true);\n            }\n            if (abs(ps[i].second - ps[j].second) < d) {\n                graph.add_clause(i, false, j, false);\n            }\n        }\n    }\n    if (graph.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = graph.answer();\n        rep(i, n) {\n            if (ans[i]) {\n                cout << ps[i].first << endl;\n            }\n            else {\n                cout << ps[i].second << endl;\n            }\n        }\n        return 0;\n    }\n    cout << \"No\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <cstring>\n#include <functional>\n#include <cctype>\n#include <locale>\n#define ll long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> Pll;\n#define fout(num) cout << fixed << setprecision(20) << (num) << endl\n//s[i]=tolower(s[i]); islower(s[i]); cout << tolower(s[i])はバグ\n//vector<vector<ll>> dp(n,vector<ll>(n))\n//2-dim:vector<vector<Type>> vv(n, vector<Type>(m, d));\n//3-dim:vector<vector<vector<Type>>> vvv(n, vector<vector<Type>>(m, vector<Type>(l, d)));\ntemplate<typename T>\nstruct SCC{\n    T &G;\n    vector<vector<int>> Ngraph,Rgraph;\n    vector<int> comp,order;\n    vector<bool> used;\n    SCC(T &g):G(g),Ngraph((int)g.size()),Rgraph((int)g.size()),comp((int)g.size(),-1),used((int)g.size()){\n        for(int i=0;i<(int)g.size();i++){\n            for(auto to:g[i]){\n                Ngraph[i].push_back((int)to);\n                Rgraph[(int)to].push_back(i);\n            }\n        }\n    }\n    int operator[](int idx){\n        //assert(0<=idx&&idx<comp.size());\n        return comp[idx];\n    }\n    void dfs(int idx){\n        if(used[idx]) return;\n        used[idx]=true;\n        for(auto &to:Ngraph[idx]) dfs(to);\n        order.push_back(idx);\n    }\n    void rdfs(int idx,int cnt){\n        if(comp[idx]!=-1) return;\n        comp[idx]=cnt;\n        for(auto &to:Rgraph[idx]) rdfs(to,cnt);\n    }\n    void build(vector<vector<int>> &ret){\n        for(int i=0;i<(int)Ngraph.size();i++) dfs(i);\n        reverse(order.begin(),order.end());\n        int group=0;\n        for(auto i:order){\n            if(comp[i]==-1){\n                rdfs(i,group);\n                group++;\n            }\n        }\n        ret.resize(group);\n        for(int i=0;i<(int)G.size();i++){\n            for(auto &to:G[i]){\n                int s=comp[i],t=comp[to];\n                if(s!=t) ret[s].push_back(t);\n            }\n        }\n    }\n};\nstruct two_sat{\nprivate:\n    int _n;\n    vector<bool> _answer;\n    vector<vector<int>> _v;\npublic:\n    two_sat():_n(0){}\n    two_sat(vector<vector<int>> &v):_n((int)v.size()),_answer((int)v.size()),_v(v){}\n    bool satisfiable(){\n        vector<vector<int>> hoge;\n        SCC<vector<vector<int>>> scc(_v);\n        scc.build(hoge);\n        for(int i=0;2*i+1<_n;i++){\n            //assert(2*i+1<scc.comp.size());\n            if(scc[2*i]==scc[2*i+1]) return false;\n            _answer[i] = scc[2*i] < scc[2*i+1];\n        }\n        return true;\n    }\n    vector<bool> answer(){\n        return _answer;\n    }\n};\n\nsigned main(){\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    int n,d; cin >> n >> d;\n    vector<int> x(n),y(n);\n    rep(i,n) cin >> x[i] >> y[i];\n    vector<vector<int>> v(2*n);\n    auto add_E=[&](int x_i,bool x_f,int x_j,bool x_g){\n        //cout << \"DEEEEEN\" << endl;\n        v[2*x_i+(x_f?0:1)].push_back(2*x_j+(x_g?1:0));\n        v[2*x_j+(x_g?0:1)].push_back(2*x_i+(x_f?1:0));\n    };\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if (abs(x[i] - x[j]) < d) {\n                add_E(i,false,j,false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                add_E(i,false,j,true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                add_E(i,true,j,false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                add_E(i,true,j,true);\n            }\n        }\n    }\n    //rep(i,2*n) cout << v[i].size() << \" \";\n    two_sat ts(v);\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n    }else{\n        cout << \"Yes\" << endl;\n        vector<bool> as=ts.answer();\n        rep(i,n){\n            cout << (as[i]?x[i]:y[i]) << \"\\n\";\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// 2020-09-20 19:18:45\n// clang-format off\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"lib/debug.hpp\"\n#else\n#define debug(...) 1\n#endif\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define rep(i, n) REP(i, 0, (n))\n#define repc(i, n) REPC(i, 0, (n))\n#define REP(i, n, m) for (int i = (int)(n); i < (int)(m); i++)\n#define REPC(i, n, m) for (int i = (int)(n); i <= (int)(m); i++)\n#define REPCM(i, n, m) for (int i = (int)(n); i >= (int)(m); i--)\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pr = pair<ll, ll>;\nusing vll = vector<ll>;\nusing vpr = vector<pr>;\nusing P = pair<int, int>;\ntemplate<class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } else return false; }\ntemplate<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }\n// #include <atcoder/convolution>\n// #include <atcoder/dsu>\n// #include <atcoder/fenwicktree>\n// #include <atcoder/lazysegtree>\n// #include <atcoder/math>\n// #include <atcoder/maxflow>\n// #include <atcoder/mincostflow>\n// #include <atcoder/modint>\n// #include <atcoder/scc>\n// #include <atcoder/segtree>\n// #include <atcoder/string>\n#include <atcoder/twosat>\n// #include <atcoder/all>\nusing namespace atcoder;\n\n// clang-format on\nvoid answer() {\n  int n, d;\n  cin >> n >> d;\n  two_sat G(n);\n  vector<int> x(n), y(n);\n  rep(i, n) cin >> x[i] >> y[i];\n  rep(i, n - 1) REP(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) {\n      G.add_clause(i, false, j, false);\n    }\n    if (abs(x[i] - y[j]) < d) {\n      G.add_clause(i, false, j, true);\n    }\n    if (abs(y[i] - x[j]) < d) {\n      G.add_clause(i, true, j, false);\n    }\n    if (abs(y[i] - y[j]) < d) {\n      G.add_clause(i, true, j, true);\n    }\n  }\n  if (!G.satisfiable()) {\n    cout << \"No\" << '\\n';\n    return;\n  }\n  cout << \"Yes\" << '\\n';\n  auto ans = G.answer();\n  rep(i, n) cout << (ans[i] ? x[i] : y[i]) << '\\n';\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  answer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <bits/extc++.h>\n#include <atcoder/all>\n\n#define int long long\n#define ull unsigned long long\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n//#define inf 2000000000\n#define inf 8000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define print1(a) cout << (a) << '\\n'\n#define print2(a,b) cout << (a) << ' ',print1(b)\n#define print3(a,b,c) cout << (a) << ' ',print2(b,c)\n#define print4(a,b,c,d) cout << (a) << ' ',print3(b,c,d)\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define ordered_set tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace atcoder;\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod;\nconst int maxn=1005;\n//i_am_noob\nint n,d,a[maxn],b[maxn];\ntwo_sat noob(maxn);\nvector<bool> vec;\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    cin >> n >> d;\n    rep(n) cin >> a[i] >> b[i];\n    rep(n) rep2(j,i+1,n){\n        if(abs(a[i]-a[j])<d) noob.add_clause(i,false,j,false);\n        if(abs(a[i]-b[j])<d) noob.add_clause(i,false,j,true);\n        if(abs(b[i]-a[j])<d) noob.add_clause(i,true,j,false);\n        if(abs(b[i]-b[j])<d) noob.add_clause(i,true,j,true); \n    }\n    if(!noob.satisfiable()){\n        print1(\"No\");\n        return 0;\n    }\n    vec=noob.answer();\n    print1(\"Yes\");\n    rep(n) print1(vec[i]?a[i]:b[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nstruct SCC{\nprivate:\n    int V;\n    vector<vector<int>> G, rG;\n    vector<bool> used;\n    vector<int> pos;\npublic:\n    SCC(int _V=0){\n        V = _V;\n        G.resize(V);\n        rG.resize(V);\n    }\n    void init(int _V){\n        V = _V;\n        G.resize(V);\n        rG.resize(V);\n    }\n    void add(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n    void dfs(int v){\n        used[v] = true;\n        for(int i=0; i<G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        pos.push_back(v);\n    }\n    void rdfs(int v, vector<int>& ls){\n        used[v] = true;\n        ls.push_back(v);\n        for(int i=0; i<rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], ls);\n        }\n    }\n    vector<vector<int>> scc(){\n        pos.clear();\n        used.clear();\n        used.resize(V, false);\n        for(int i=0; i<V; i++){\n            if(!used[i]) dfs(i);\n        }\n        used.clear();\n        used.resize(V, false);\n        vector<vector<int>> ret;\n        for(int i=V-1; i>=0; i--){\n            if(!used[pos[i]]){\n                ret.push_back(vector<int>());\n                rdfs(pos[i], ret.back());\n            }\n        }\n        return ret;\n    }\n};\n\nstruct TWO_SAT{\nprivate:\n    int N;\n    SCC s;\n    vector<bool> ans;\npublic:\n    TWO_SAT(int _N=0){\n        N = _N;\n        s.init(2*N);\n    }\n    void init(int _N){\n        N = _N;\n        s.init(2*N);\n    }\n    void add(int i, bool bi, int j, bool bj){\n        if(!bi) i = N + i;\n        if(!bj) j = N + j;\n        s.add((i+N)%(2*N), j);\n        s.add((j+N)%(2*N), i);\n    }\n    bool satisfiable(){\n        auto v = s.scc();\n        vector<int> cmp(2*N);\n        for(int i=0; i<v.size(); i++){\n            for(int j=0; j<v[i].size(); j++){\n                cmp[v[i][j]] = i;\n            }\n        }\n        ans = vector<bool>(N, false);\n        for(int i=0; i<N; i++){\n            if(cmp[i] == cmp[N+i]) return false;\n            ans[i] = (cmp[i] > cmp[N+i]);\n        }\n        return true;\n    }\n    vector<bool> answer(){\n        return ans;\n    }\n};\n\nint N, D;\nint X[1000], Y[1000];\nvector<pair<int,pair<int,bool>>> v;\nTWO_SAT ts;\n\nsigned main(){\n    cin >> N >> D;\n    rep(i, N){\n        cin >> X[i] >> Y[i];\n    }\n    sort(all(v));\n    ts.init(N);\n    rep(i, N){\n        rep(j, N){\n            if(i == j) continue;\n            if(abs(X[i]-X[j]) < D) ts.add(i, true, j, true);\n            if(abs(X[i]-Y[j]) < D) ts.add(i, true, j, false);\n            if(abs(Y[i]-X[j]) < D) ts.add(i, false, j, true);\n            if(abs(Y[i]-Y[j]) < D) ts.add(i, false, j, false);\n        }\n    }\n    if(ts.satisfiable()){\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, N) cout << (!ans[i] ? X[i] : Y[i]) << endl;\n    }\n    else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n\tint V;\n\tconst vector<vector<int>> &g;\n\tint num_of_comp;\n\tvector<int> comp;\n\tvector<vector<int>> dag;\n\tvector<vector<int>> group_set;\n\n\tvector<vector<int>> rg;\n\tvector<int> order;\n\tvector<bool> used;\n\n\tStronglyConnectedComponents(const vector<vector<int>> &g) : V(g.size()), g(g) {}\n\n\tvoid calc() {\n\t\tnum_of_comp = 0;\n\t\tcomp.assign(V, -1);\n\t\tused.assign(V, false);\n\t\torder.reserve(V);\n\t\trg.resize(V);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int e : g[i]) {\n\t\t\t\trg[e].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (!used[i]) dfs1(i);\n\t\t}\n\t\tfor (int i = V-1; i >= 0; i--) {\n\t\t\tconst int v = order[i];\n\t\t\tif (comp[v] == -1) {\n\t\t\t\tdfs2(v);\n\t\t\t\tnum_of_comp++;\n\t\t\t}\n\t\t}\n\t\tdag.resize(num_of_comp);\n\t\tgroup_set.resize(num_of_comp);\n\t\tfor (int i = 0; i < V; i++) group_set[comp[i]].push_back(i);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (int e : g[i]) {\n\t\t\t\tconst int x = comp[i], y = comp[e];\n\t\t\t\tif (x != y) dag[x].push_back(y);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid dfs1(int v) {\n\t\tused[v] = true;\n\t\tfor (int nv : g[v]) {\n\t\t\tif (used[nv]) continue;\n\t\t\tdfs1(nv);\n\t\t}\n\t\torder.push_back(v);\n\t}\n\n\tvoid dfs2(int v) {\n\t\tcomp[v] = num_of_comp;\n\t\tfor (int nv : rg[v]) {\n\t\t\tif (comp[nv] != -1) continue;\n\t\t\tdfs2(nv);\n\t\t}\n\t}\n};\n\nstruct TwoSAT\n{\n\tint n;\n\tbool ok;\n\tvector<bool> ans;\n\n\tvector<vector<int>> g;\n\n\tTwoSAT(int n) : n(n), g(2*n) {}\n\n\tvoid add_clause(int i, bool bool_i, int j, bool bool_j) {\n\t\tg[2*i + !bool_i].push_back(2*j + bool_j);\n\t\tg[2*j + !bool_j].push_back(2*i + bool_i);\n\t}\n\n\tvoid add_clause_not(int i, bool bool_i, int j, bool bool_j) {\n\t\tg[2*i + bool_i].push_back(2*j + !bool_j);\n\t\tg[2*j + bool_j].push_back(2*i + !bool_i);\n\t}\n\n\tvoid calc() {\n\t\tStronglyConnectedComponents scc(g);\n\t\tscc.calc();\n\t\tok = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (scc.comp[2*i] == scc.comp[2*i + 1]) return;\n\t\t}\n\t\tok = true;\n\t\tans.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans[i] = scc.comp[2*i] < scc.comp[2*i + 1];\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tTwoSAT sat(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor (int j = i+1; j < n; j++) {\n\t\t\tif (abs(x[i]-x[j]) < d) sat.add_clause_not(i, 0, j, 0);\n\t\t\tif (abs(x[i]-y[j]) < d) sat.add_clause_not(i, 0, j, 1);\n\t\t\tif (abs(y[i]-x[j]) < d) sat.add_clause_not(i, 1, j, 0);\n\t\t\tif (abs(y[i]-y[j]) < d) sat.add_clause_not(i, 1, j, 1);\n\t\t}\n\t}\n\tsat.calc();\n\tif (sat.ok) {\n\t\tcout << \"Yes\" << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (sat.ans[i]) cout << y[i] << '\\n';\n\t\t\telse cout << x[i] << '\\n';\n\t\t}\n\t} else cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    long long N,D;\n    cin>>N>>D;\n    long long X[N],Y[N];\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n\n    two_sat ts(N);\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            int pat1=(X[i]-X[j])*(X[i]-X[j]);\n            int pat2=X[i]*X[i]+Y[j]*Y[j];\n            int pat3=Y[i]*Y[i]+X[j]*X[j];\n            int pat4=(Y[i]-Y[j])*(Y[i]-Y[j]);\n            //cout<<i<<\",\"<<j<<\"---\"<<pat1<<\",\"<<pat2<<\",\"<<pat3<<\",\"<<pat4<<\",\"<<D*D<<endl;\n            if(pat1<D*D) ts.add_clause(i,true,j,true);\n            if(pat2<D*D) ts.add_clause(i,true,j,false);\n            if(pat3<D*D) ts.add_clause(i,false,j,true);\n            if(pat4<D*D) ts.add_clause(i,false,j,false);\n        }\n    }\n\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        vector<bool> v=ts.answer();\n        for(int i=0;i<v.size();i++){\n            if(!v[i]) cout<<X[i]<<endl;\n            else cout<<Y[i]<<endl;\n        }\n    }\n    else cout<<\"No\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <numeric>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\n/*\n * @title StronglyConnectedComponents\n */\nclass StronglyConnectedComponents{\n\tint num,is_2sat,half,max_id,cnt;\n\tvector<vector<int>> edge;\n\tvector<int> label,order,low;\n    stack<size_t> st;\n\tinline int rev(int i) { return i < half ? i + half : i - half; }\n    inline void dfs(int& from) {\n        low[from]=order[from]=cnt++;\n        st.push(from);\n        for(int& to:edge[from]) {\n            if(order[to]==-1) {\n                dfs(to);\n                low[from]=min(low[from],low[to]);\n            }\n            else {\n                low[from]=min(low[from],order[to]);\n            }\n        }\n        if (low[from] == order[from]) {\n            while(st.size()) {\n                int u = st.top();st.pop();\n                order[u] = num;\n                label[u] = max_id;\n                if (u == from) break;\n            }\n            max_id++;\n        }\n    }\npublic:\n\tStronglyConnectedComponents(const int n, bool is_2sat=0):num(n),max_id(0),cnt(0),is_2sat(is_2sat){\n\t\tif(is_2sat) num<<=1;\n\t\tedge.resize(num);\n\t\tlabel.resize(num);\n        order.resize(num,-1);\n        low.resize(num);\n        half=(num>>1);\n\t}\n\tinline int operator[](int idx) {\n\t\treturn label[idx];\n\t}\n\tinline void make_edge(const int from,const int to) {\n\t\tedge[from].push_back(to);\n\t}\n    //xがflg_xならばyがflg_y\n\tinline void make_condition(int x, bool flg_x, int y, bool flg_y) {\n\t\tif (!flg_x) x = rev(x);\n\t\tif (!flg_y) y = rev(y);\n\t\tmake_edge(x, y);\n\t\tmake_edge(rev(y), rev(x));\n\t}\n    //is_2sat=1のときに、2satを満たすかを返却する\n\tinline bool solve(void) {\n        for (int i = 0; i < num; i++) if (order[i] == -1) dfs(i);\n        for (int& id:label) id = max_id-1-id;\n\t\tif(!is_2sat) return true;\n\t\tfor (int i = 0; i < num; ++i) if (label[i] == label[rev(i)]) return false;\n\t\treturn true;\n\t}\n    vector<vector<int>> topological_sort(void) {\n        vector<vector<int>> ret(max_id);\n        for(int i=0;i<num;++i) ret[label[i]].push_back(i);\n        return ret;\n    }\n\tint is_true(int i) {\n\t\treturn label[i] > label[rev(i)];\n\t}\n\tvoid print(void) {\n\t\tfor(auto id:label) cout << id << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int N,D; cin >> N >> D;\n    StronglyConnectedComponents scc(N,1);\n    vector<int> X(2*N);\n    for(int i=0;i<N;++i) cin >> X[i] >> X[i+N];\n    for(int i=0;i<2*N;++i) {\n        for(int j=0;j<2*N;++j) {\n            if(i==j||abs(i-j)==N) continue;\n            if(abs(X[i]-X[j])<D) scc.make_condition(i%N,(i<N),j%N,!(j<N));\n        }\n    }\n    bool f=scc.solve();\n    if(f) {\n        cout << \"Yes\\n\";\n        for(int i=0;i<N;++i) {\n            cout << (scc.is_true(i)?X[i]:X[i+N]) << \"\\n\";\n        }\n    }\n    else{\n        cout << \"No\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\ntemplate<class T> using pque = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr int mod1e9 = 1000000007;\nconstexpr int mod998 = 998244353;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\nconstexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };\nint dx[] = { 1,0,-1,0,1,1,-1,-1 }; int dy[] = { 0,1,0,-1,1,-1,1,-1 };\nvoid fail() { cout << \"-1\\n\"; exit(0); } void no() { cout << \"No\\n\"; exit(0); }\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }\ntemplate<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }\n\nstruct fastio {\n\tfastio() {\n\t\tcin.tie(0); cout.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(20);\n\t\tcerr << fixed << setprecision(20);\n\t}\n}fastio_;\n\nclass SCC {\n\tvector<vector<int>> graph;\n\tvector<vector<int>> revgraph;\n\tvector<int> vs;\n\tvector<bool> used;\npublic:\n\tvector<int> cmp;\n\tSCC(int n) {\n\t\tgraph = revgraph = vector<vector<int>>(n, vector<int>());\n\t\tvs = cmp = vector<int>(n);\n\t\tused = vector<bool>(n);\n\t}\n\tvoid add_edge(int from, int to) {\n\t\tgraph[from].push_back(to);\n\t\trevgraph[to].push_back(from);\n\t}\n\tvoid add_edge(int from, int a, int b, int s) {\n\t\ta += s; b += s;\n\t\twhile (a < b) {\n\t\t\tif (a & 1) add_edge(from, s + (a++));\n\t\t\tif (b & 1) add_edge(from, s + (--b));\n\t\t\ta >>= 1; b >>= 1;\n\t\t}\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int i : graph[v]) {\n\t\t\tif (!used[i]) dfs(i);\n\t\t}\n\t\tvs.push_back(v);\n\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor (int i : revgraph[v]) {\n\t\t\tif (!used[i]) rdfs(i, k);\n\t\t}\n\t}\n\tint solve() {\n\t\tint n = graph.size();\n\t\tfor (int i = 0; i < n; i++) used[i] = false;\n\t\tvs.clear();\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (!used[v]) dfs(v);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) used[i] = false;\n\t\tint k = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t\t}\n\t\treturn k;\n\t}\n};\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tSCC scc(4 * n);\n\tvector<int> x(2 * n);\n\trep(i, 2 * n) cin >> x[i];\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n) {\n\t\t\tif (i == j) continue;\n\t\t\tif (j - i == 1 && i % 2 == 0) {\n\t\t\t\tscc.add_edge(i * 2 + 1, j * 2);\n\t\t\t\tscc.add_edge(j * 2 + 1, i * 2);\n\t\t\t}\n\t\t\telse if (abs(x[i] - x[j]) < d) {\n\t\t\t\tscc.add_edge(i * 2, j * 2 + 1);\n\t\t\t}\n\t\t}\n\t}\n\tscc.solve();\n\tvector<int> ans(2 * n);\n\trep(i, 2 * n) {\n\t\tif (scc.cmp[2 * i] == scc.cmp[2 * i + 1]) no();\n\t\telse if (scc.cmp[2 * i] > scc.cmp[2 * i + 1] && (i % 2 == 0 || !ans[i - 1])) ans[i] = 1;\n\t}\n\tcout << \"Yes\\n\";\n\trep(i, 2 * n) if (ans[i]) cout << x[i] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#pragma region template 3.0\n#define G3(_1, _2, _3, F, ...) F\n#define G4(_1, _2, _3, _4, F, ...) F\n#define G5(_1, _2, _3, _4, _5, F, ...) F\n#define G6(_1, _2, _3, _4, _5, _6, F, ...) F\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nusing vec = vector<T>;\ntemplate <typename T>\nusing vec2 = vec<vec<T>>;\ntemplate <typename T>\nusing vec3 = vec<vec2<T>>;\ntemplate <typename T>\nusing vec4 = vec<vec3<T>>;\nusing vi = vec<ll>;\nusing vvi = vec2<ll>;\nusing ii = pair<ll, ll>;\nusing iii = tuple<ll, ll, ll>;\nusing vii = vec<ii>;\nusing vs = vec<string>;\nusing vb = vec<bool>;\ntemplate <typename T>\nusing pq = priority_queue<T, vector<T>, greater<T>>;\n#define VEC1(T, n1) vec<T>(n1)\n#define VEC2(T, n1, n2) vec2<T>(n1, VEC1(T, n2))\n#define VEC3(T, n1, n2, n3) vec3<T>(n1, VEC2(T, n2, n3))\n#define VEC4(T, n1, n2, n3, n4) vec4<T>(n1, VEC3(T, n2, n3, n4))\n#define vec(...) G5(__VA_ARGS__, VEC4, VEC3, VEC2, VEC1)(__VA_ARGS__)\n#define VEC1V(T, n1, v) vec<T>(n1, v)\n#define VEC2V(T, n1, n2, v) vec2<T>(n1, VEC1V(T, n2, v))\n#define VEC3V(T, n1, n2, n3, v) vec3<T>(n1, VEC2V(T, n2, n3, v))\n#define VEC4V(T, n1, n2, n3, n4, v) vec4<T>(n1, VEC3V(T, n2, n3, n4, v))\n#define vecv(...) G6(__VA_ARGS__, VEC4V, VEC3V, VEC2V, VEC1V)(__VA_ARGS__)\n#define REP0(i, n) for (ll i = 0; i < (n); ++i)\n#define REP(i, j, n) for (ll i = (j); i < (n); ++i)\n#define rep(...) G3(__VA_ARGS__, REP, REP0)(__VA_ARGS__)\n#define REP1(i, n) for (ll i = 1; i <= (n); ++i)\n#define REPI(i, j, n) for (ll i = (j); i <= (n); ++i)\n#define repi(...) G3(__VA_ARGS__, REPI, REP1)(__VA_ARGS__)\n#define RREP0(i, n) for (ll i = (n)-1; i >= 0; --i)\n#define RREP(i, j, n) for (ll i = (n)-1; i >= (j); --i)\n#define rrep(...) G3(__VA_ARGS__, RREP, RREP0)(__VA_ARGS__)\n#define RREP1(i, n) for (ll i = (n); i >= 1; --i)\n#define RREPI(i, j, n) for (ll i = (n); i >= (j); --i)\n#define rrepi(...) G3(__VA_ARGS__, RREPI, RREP1)(__VA_ARGS__)\n#define each(i, a) for (auto &i : a)\n#define ch(f, x, y) x = f((x), (y))\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define RSORT(a) \\\n  SORT(a);       \\\n  reverse(ALL(a))\n#define IN1(T, a) \\\n  T a;            \\\n  cin >> a;\n#define IN2(T, a, b) \\\n  T a, b;            \\\n  cin >> a >> b;\n#define IN3(T, a, b, c) \\\n  T a, b, c;            \\\n  cin >> a >> b >> c;\n#define IN4(T, a, b, c, d) \\\n  T a, b, c, d;            \\\n  cin >> a >> b >> c >> d;\n#define in(...) G5(__VA_ARGS__, IN4, IN3, IN2, IN1)(__VA_ARGS__)\n#define ll(...) in(ll, __VA_ARGS__)\n#define STR(...) in(string, __VA_ARGS__)\n#define VIN1(T, a, n) \\\n  vec<T> a(n);        \\\n  each(i, a) cin >> i;\n#define VIN2(T, a, b, n) \\\n  vec<T> a(n), b(n);     \\\n  rep(i, n) cin >> a[i] >> b[i];\n#define VIN3(T, a, b, c, n) \\\n  vec<T> a(n), b(n), c(n);  \\\n  rep(i, n) cin >> a[i] >> b[i] >> c[i];\n#define VIN4(T, a, b, c, d, n)   \\\n  vec<T> a(n), b(n), c(n), d(n); \\\n  rep(i, n) cin >> a[i] >> b[i] >> c[i] >> d[i];\n#define vin(...) G6(__VA_ARGS__, VIN4, VIN3, VIN2, VIN1)(__VA_ARGS__)\n#define vll(...) vin(ll, __VA_ARGS__)\n#define vvll(a, n)       \\\n  vvi a = vec(ll, n, n); \\\n  rep(i, n) rep(j, n) cin >> a[i][j];\n#define out(x) cout << (x) << endl;\n#define fout(x) cout << fixed << setprecision(15) << (x) << endl;\n#define DUMP1(a) cout << #a << \" = \" << (a) << endl;\n#define DUMP2(a, b) \\\n  cout << #a << \" = \" << (a) << ' ' << #b << \" = \" << (b) << endl;\n#define DUMP3(a, b, c)                                                 \\\n  cout << #a << \" = \" << (a) << ' ' << #b << \" = \" << (b) << ' ' << #c \\\n       << \" = \" << (c) << endl;\n#define DUMP4(a, b, c, d)                                              \\\n  cout << #a << \" = \" << (a) << ' ' << #b << \" = \" << (b) << ' ' << #c \\\n       << \" = \" << (c) << ' ' << #d << \" = \" << (d) << endl;\n#define DUMP5(a, b, c, d, e)                                              \\\n  cout << #a << \" = \" << (a) << ' ' << #b << \" = \" << (b) << ' ' << #c    \\\n       << \" = \" << (c) << ' ' << #d << \" = \" << (d) << ' ' << #e << \" = \" \\\n       << (e) << endl;\n#define dump(...) \\\n  G5(__VA_ARGS__, DUMP5, DUMP4, DUMP3, DUMP2, DUMP1)(__VA_ARGS__)\ntemplate <typename T>\nostream &jout(T s, T e, string sep = \" \", ostream &os = cout) {\n  if (s != e) {\n    os << *s;\n    ++s;\n  }\n  while (s != e) {\n    os << sep << *s;\n    ++s;\n  }\n  return os;\n}\nostream &yes(bool cond, string y = \"Yes\", string n = \"No\", ostream &os = cout) {\n  os << (cond ? y : n) << endl;\n  return os;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T1, typename T2, typename T3>\nostream &operator<<(ostream &os, const tuple<T1, T2, T3> &t) {\n  return os << '(' << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t)\n            << ')';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  return jout(ALL(v), \", \", os << '[') << ']';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &s) {\n  return jout(ALL(s), \", \", os << '{') << '}';\n}\ntemplate <typename K, typename V>\nostream &operator<<(ostream &os, const map<K, V> &m) {\n  return jout(ALL(m), \", \", os << '{') << '}';\n}\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n#pragma endregion template\nusing namespace atcoder;\n\nint main() {\n  ll(N, D);\n  vll(X, Y, N);\n  two_sat ts(2 * N);\n  rep(i, N) { ts.add_clause(2 * i, true, 2 * i + 1, true); }\n  rep(i, N) {\n    rep(j, i + 1, N) {\n      if (abs(X[i] - X[j]) < D) {\n        ts.add_clause(2 * i, false, 2 * j, false);\n      }\n      if (abs(X[i] - Y[j]) < D) {\n        ts.add_clause(2 * i, false, 2 * j + 1, false);\n      }\n      if (abs(Y[i] - X[j]) < D) {\n        ts.add_clause(2 * i + 1, false, 2 * j, false);\n      }\n      if (abs(Y[i] - Y[j]) < D) {\n        ts.add_clause(2 * i + 1, false, 2 * j + 1, false);\n      }\n    }\n  }\n  if (ts.satisfiable()) {\n    out(\"Yes\");\n    auto x = ts.answer();\n    rep(i, N) {\n      if (x[2 * i]) {\n        out(X[i]);\n      } else {\n        out(Y[i]);\n      }\n    }\n  } else {\n    out(\"No\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst int N = 100000;\n\nint vertexid[N];\nint L[N], R[N];\nint fl;\nvector<int> graph[N];\n\nvoid build(int v, int l, int r)\n{\n  L[v] = l, R[v] = r;\n  if (l + 1 == r)\n  {\n    vertexid[v] = l;\n    return;\n  }\n  int m = (l + r) / 2;\n  vertexid[v] = fl++;\n  build(2 * v + 1, l, m);\n  build(2 * v + 2, m, r);\n  graph[vertexid[v]].push_back(vertexid[2 * v + 1]);\n  graph[vertexid[v]].push_back(vertexid[2 * v + 2]);\n}\n\nvoid connect(int from, int l, int r, int v)\n{\n  if (r <= L[v] || R[v] <= l) return;\n  if (l <= L[v] && R[v] <= r)\n  {\n    graph[from].push_back(vertexid[v]);\n    return;\n  }\n  connect(from, l, r, 2 * v + 1);\n  connect(from, l, r, 2 * v + 2);\n}\n\nint main()\n{\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n  }\n  vector<pair<int, int> > f;\n  for (int i = 0; i < n; i++)\n  {\n    f.push_back({y[i], 2 * i + 1});\n    f.push_back({x[i], 2 * i});\n  }\n  vector<int> pos(2 * n);\n  sort(f.begin(), f.end());\n  for (int i = 0; i < 2 * n; i++)\n  {\n    pos[f[i].second] = i;\n  }\n  fl = 2 * n;\n  build(0, 0, 2 * n);\n  for (int i = 0; i < 2 * n; i++)\n  {\n    int c = x[f[i].second / 2] + y[f[i].second / 2] - f[i].first;\n    int mirror = pos[f[i].second ^ 1];\n    int L = 0;\n    while (f[L].first <= c - d) L++;\n    int R = 2 * n - 1;\n    while (f[R].first >= c + d) R--;\n    if (L <= mirror - 1)\n    {\n      connect(i, L, mirror, 0);\n    }\n    if (mirror + 1 <= R)\n    {\n      connect(i, mirror + 1, R + 1, 0);\n    }\n  }\n  scc_graph G(fl);\n  for (int i = 0; i < fl; i++)\n  {\n    for (auto u : graph[i])\n    {\n      G.add_edge(i, u);\n    }\n  }\n  vector<vector<int> > scc = G.scc();\n  vector<int> wh(fl);\n  for (int i = 0; i < scc.size(); i++)\n  {\n    for (int j = 0; j < scc[i].size(); j++)\n    {\n      wh[scc[i][j]] = i;\n    }\n  }\n  vector<int> ans(n);\n  for (int i = 0; i < n; i++)\n  {\n    if (wh[pos[2 * i]] == wh[pos[2 * i + 1]])\n    {\n      cout << \"No\\n\";\n      return 0;\n    }\n    ans[i] = wh[pos[2 * i]] > wh[pos[2 * i + 1]];\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; i++)\n  {\n    if (ans[i]) cout << y[i] << \"\\n\";\n    else cout << x[i] << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ld = long double;\n\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\n#define e_b emplace_back\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) ((x).erase(unique(all(x)),(x).end()))\n#define sz(x) ((int)(x).size())\n\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n\n#ifdef LOCAL//compile with -DLOCAL\n#define debug(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \"<<(x)<<endl\n#define debug_vec(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \";\\\n  rep(i,sz(x)){cerr<<x[i]<<\" \";}cerr<<endl\n#define debug_mat(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \"<<endl;\\\n  rep(i,sz(x)){rep(j,sz(x[i])){cerr<<x[i][j]<<\" \";}cerr<<endl;}cerr<<endl\n#else\n#define debug(x) void(0)\n#define debug_vec(x) void(0)\n#define debug_mat(x) void(0)\n#endif\n\ntemplate<class T> bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);cin.tie(0);\n  int N,D;\n  cin >> N >> D;\n  vector<ll> X(N),Y(N);\n  rep(i,N)  cin >> X.at(i) >> Y.at(i);\n\n  two_sat ts(2*N);\n  rep(i,N){\n    ts.add_clause(i, true, i+N, true);\n    ts.add_clause(i, false, i+N, false);\n  }\n  rep(i,N){\n    REP(j,i+1,N){\n      if(abs(X.at(i)-X.at(j)) < D)  ts.add_clause(i, false, j, false);\n      if(abs(X.at(i)-Y.at(j)) < D)  ts.add_clause(i, false, j+N, false);\n      if(abs(Y.at(i)-X.at(j)) < D)  ts.add_clause(i+N, false, j, false);\n      if(abs(Y.at(i)-Y.at(j)) < D)  ts.add_clause(i+N, false, j+N, false);\n    }\n  }\n\n  if(!ts.satisfiable()){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n\n  vector<bool> ans = ts.answer();\n  rep(i,N){\n    if(ans.at(i)) cout << X.at(i) << endl;\n    else  cout << Y.at(i) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <chrono>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,Q,K,A,B;\nstring S;\ntypedef pair<ll, ll> P;\nconst ll INF = (1LL<<60);\n\nvoid dfs1(int n, mat &G, vec &ord){\n    int k(0);\n    vector<int> iter(n, -1);\n    stack<int> sta;\n    rep(i, n) {\n        if(iter[i] < 0) sta.push(i);\n        while (!sta.empty()) {\n            int v = sta.top();\n            if ((++iter[v]) == G[v].size()) {\n                ord[k++] = v;\n                sta.pop();\n            } else {\n                int to = G[v][iter[v]];\n                if(iter[to] < 0) sta.push(to);\n            }\n        }\n    }\n}\nvoid dfs2(int n, mat &G, vec &ord, mat &res){\n    int k(0);\n    vector<bool> used(n, false);\n    stack<int> sta;\n    Rrep(i, n){\n        int s = ord[i];\n        if(!used[s]){\n            used[s] = true;\n            sta.push(s);\n            while(!sta.empty()){\n                int v = sta.top(); sta.pop();\n                res[k].push_back(v);\n                for(int to : G[v]) {\n                    if(!used[to]) {\n                        used[to] = true;\n                        sta.push(to);\n                    }\n                }\n            }\n            ++k;\n        }\n    }\n    res.resize(k);\n}\n\nvoid scc(mat &G, mat &res){\n    int n = G.size();\n    res.resize(n);\n    mat G_rev(n, vec(0));\n    rep(u, n) for(int v : G[u]) G_rev[v].push_back(u);\n    vec ord(n);\n    dfs1(n, G, ord);\n    dfs2(n, G_rev, ord, res);\n}\n\nint main() {\n    cin >> N >> K;\n    mat G(N * 2, vec(0)), scc_list;\n    vec x(N * 2), pos(N * 2);\n    rep(i, N) cin>>x[i]>>x[i + N];\n    rep(i, N * 2){\n        rep(j, i) {\n            if(abs(x[i] - x[j]) < K) {\n                int i_inv = (i + N) % (N * 2), j_inv = (j + N) % (N * 2);\n                G[i].push_back(j_inv);\n                G[j].push_back(i_inv);\n            }\n        }\n    }\n    scc(G, scc_list);\n    rep(i, (int)scc_list.size()){\n        for(int v : scc_list[i]) pos[v] = i;\n    }\n    //rep(i, N) cout<<pos[i]<<' '<<pos[i + N]<<endl;\n    bool ok = true;\n    rep(i, N) if(pos[i] == pos[i + N]) ok = false;\n    cout<<(ok ? \"Yes\" : \"No\")<<endl;\n    if(ok){\n        rep(i, N){\n            cout<<(pos[i] > pos[i + N] ? x[i] : x[i + N])<<endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for(int i = 0; i < N; ++i)  cin >> X[i] >> Y[i];\n\n    vector<vector<int>> graph(N * 2), rev(N * 2);\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < i; ++j){\n            if(abs(X[i] - X[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2 + 1);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2 + 1);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                graph[i * 2].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2);\n            }\n            if(abs(Y[i] - Y[j]) < D){\n                graph[i * 2].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2);\n            }\n        }\n    }\n\n    vector<int> vs;\n    vector<bool> used(N * 2, false);\n    auto dfs = [&](auto&& self, int cur) -> void {\n        used[cur] = true;\n        for(int nxt : graph[cur]){\n            if(!used[nxt])  self(self, nxt);\n        }\n        vs.emplace_back(cur);\n    };\n    for(int v = 0; v < N * 2; ++v){\n        if(!used[v])    dfs(dfs, v);\n    }\n    reverse(vs.begin(), vs.end());\n\n    vector<int> scc_id(N * 2, -1);\n    int K = 0;\n    auto rdfs = [&](auto&& self, int cur) -> void {\n        scc_id[cur] = K;\n        for(int nxt : rev[cur]){\n            if(scc_id[nxt] == -1)   self(self, nxt);\n        }\n    };\n    for(int v : vs){\n        if(scc_id[v] == -1){\n            rdfs(rdfs, v);\n            ++K;\n        }\n    }\n\n    vector<bool> ans(N);\n    for(int i = 0; i < N; ++i){\n        if(scc_id[i * 2] == scc_id[i * 2 + 1]){\n            cout << \"No\\n\";\n            return 0;\n        }\n        ans[i] = scc_id[i * 2] < scc_id[i * 2 + 1];\n    }\n\n    cout << \"Yes\\n\";\n    for(int i = 0; i < N; ++i)  cout << ((ans[i] ? X[i] : Y[i])) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n #include<atcoder/all>\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[400100];\n                int inv[400010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n\nvoid solve(){\nint n,d;\n\tcin>>n>>d;\n\tusing namespace atcoder;\n\tvector<pa> ve(n);\n\ttwo_sat ss(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i].first>>ve[i].second;\n\t\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\tif(abs(ve[i].first-ve[j].first)<d) ss.add_clause(i,0,j,0);\n\t\tif(abs(ve[i].first-ve[j].second)<d) ss.add_clause(i,0,j,1);\n\t\tif(abs(ve[i].second-ve[j].first)<d) ss.add_clause(i,1,j,0);\n\t\tif(abs(ve[i].second-ve[j].second)<d) ss.add_clause(i,1,j,1);\n\t\t\n\t}\n\tif(ss.satisfiable()){\n\t\tcout<<\"Yes\"<<endl;\n\t\tauto W=ss.answer();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(W[i])cout<<ve[i].first<<endl;\n\t\t\telse cout<<ve[i].second<<endl;\n\t\t}\n\t}\n\telse cout<<\"No\"<<endl;\n}\n\n\n\nsigned main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\nint n=1;\n\t//cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tsolve();\n\n\t}\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nstruct SCC {\n    vector<vector<int>> G, G_r, G_out;\n    vector<int> vs, used, cmp;\n    SCC() = default;\n    explicit SCC(int n) : G(n), G_r(n), G_out(n), used(n), cmp(n) {}\n\n    void add_edge(int a, int b){\n        G[a].emplace_back(b);\n        G_r[b].emplace_back(a);\n    }\n\n    void dfs(int v){\n        used[v] = 1;\n        for (auto &&u : G[v]) if(!used[u]) dfs(u);\n        vs.emplace_back(v);\n    }\n\n    void dfs_r(int v, int k){\n        used[v] = 1;\n        cmp[v] = k;\n        for (auto &&u : G_r[v]) if(!used[u]) dfs_r(u, k);\n    }\n\n    int build() {\n        int n = G.size();\n        for (int i = 0; i < n; ++i) if(!used[i]) dfs(i);\n        fill(used.begin(),used.end(), 0);\n        int k = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if(!used[vs[i]]){\n                dfs_r(vs[i], k++);\n            }\n        }\n        G_out.resize(k);\n        for (int i = 0; i < n; ++i) {\n            for (auto &&j : G[i]) {\n                if(cmp[i] != cmp[j]){\n                    G_out[cmp[i]].emplace_back(cmp[j]);\n                }\n            }\n        }\n        for (int i = 0; i < k; ++i) {\n            sort(G_out.begin(), G_out.end());\n            G_out.erase(unique(G_out.begin(), G_out.end()), G_out.end());\n        }\n        return k;\n    }\n\n    int operator[](int k) const { return cmp[k]; }\n};\n\nstruct TwoSAT {\n    int n;\n    SCC scc;\n    explicit TwoSAT(int n) : n(n), scc(n*2) {};\n    int negate(int v){\n        int ret = n+v;\n        if(ret >= n*2) ret -= n*2;\n        return ret;\n    }\n\n    vector<int> build() {\n        scc.build();\n        vector<int> res(n);\n        for (int i = 0; i < n; ++i) {\n            if(scc[i] == scc[n+i]) return {};\n            res[i] = scc[i] > scc[n+i];\n        }\n        return res;\n    }\n\n    void add_if(int u, int v){ // u -> v\n        scc.add_edge(u, v);\n        scc.add_edge(negate(v), negate(u));\n    }\n\n    void add_or(int u, int v){ // u || v\n        add_if(negate(u), v);\n    }\n};\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> xs[i] >> ys[i];\n    }\n    TwoSAT G(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            if(abs(xs[i]-xs[j]) < d) G.add_if(i, j+n);\n            if(abs(xs[i]-ys[j]) < d) G.add_if(i, j);\n            if(abs(ys[i]-xs[j]) < d) G.add_if(i+n, j+n);\n            if(abs(ys[i]-ys[j]) < d) G.add_if(i+n, j);\n        }\n    }\n    auto res = G.build();\n    if(res.empty()) puts(\"No\");\n    else {\n        puts(\"Yes\");\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d\\n\", res[i] ? xs[i] : ys[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\tauthor:  Kite_kuma\n\tcreated: 2020.09.09 15:54:18 */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma region aliases\n\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define foa(s, v) for(auto &s : v)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vvvi = vector<vector<vector<int>>>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing qll = queue<long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n\n#pragma endregion\n\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 3e16;\nconst long double pi = acos(-1);\nconst char el = '\\n';\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n#pragma endregion\n\n#pragma region basic_procedure\n\ntemplate <class T>\ninline bool isin(T x, T lef, T rig) {\n\treturn ((lef <= x) && (x < rig));\n}\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid Yes(bool f = 1) { cout << (f ? \"Yes\" : \"No\") << \"\\n\"; }\nvoid No() { cout << \"No\\n\"; }\nvoid YES(bool f = 1) { cout << (f ? \"YES\" : \"NO\") << \"\\n\"; }\nvoid NO() { cout << \"NO\\n\"; }\ntemplate <class T>\nvoid drop(T answer) {\n\tcout << answer << \"\\n\";\n\texit(0);\n}\nvoid err() {\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nvector<long long> vin(long long n) {  //整数n個の入力を受け取ってベクトルに突っ込んで返す\n\tvector<long long> v(n);\n\tfor(long long i = 0; i < n; i++) {\n\t\tcin >> v[i];\n\t}\n\treturn v;\n}\n\n//ベクトルの出力(検証済)\n// vectorの中身を出力する 答えの出力に利用可能\ntemplate <class T>\nvoid vout(vector<T> &v, bool tate = 0) {\n\tif(v.size() > 0) {\n\t\tfor(auto it = v.begin(); it < v.end(); it++) {\n\t\t\tcout << *it;\n\t\t\tif(it != v.end() - 1) {\n\t\t\t\tif(tate)\n\t\t\t\t\tcout << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n}\n\ntemplate <class T>\nvoid add(vector<T> &v, T val) {\t //ベクトルの各要素に加算\n\tfor(auto &a : v) a += val;\n\treturn;\n}\n\n// vectorの中身を数える map<要素,個数>を返す\ntemplate <class T>\nmap<T, long long> cntv(vector<T> v) {\n\tmap<T, long long> m;\n\tfor(auto &g : v) {\n\t\tif(m.count(g))\n\t\t\tm[g]++;\n\t\telse\n\t\t\tm[g] = 1;\n\t}\n\treturn m;\n}\n\n//配列圧縮(検証済)\n//{1,36,1,3,8,-2,-92}を\n//{2, 5,2,3,4, 1,  0}にする\ntemplate <class T>\nvector<long long> press(vector<T> &v) {\n\tlong long n = v.size();\n\tvector<long long> w(n);\n\tmap<T, long long> m;\n\tfor(T &p : v) m[p] = 0;\n\tlong long i = 0;\n\tfor(auto &p : m) {\n\t\tp.second = i;\n\t\ti++;\n\t}\n\tfor(long long i = 0; i < n; i++) w.at(i) = m[v.at(i)];\n\treturn w;\n}\n\ntemplate <class T>\nT divup(T a, T b) {\n\t//端数繰りあがり割り算\n\tassert(b != 0);\n\tT x = abs(a);\n\tT y = abs(b);\n\tT z = (x + y - 1) / y;\n\tif((a < 0 && b > 0) || (a > 0 && b < 0))\n\t\treturn -z;\n\telse if(a == 0)\n\t\treturn 0;\n\telse\n\t\treturn z;\n}\n\nlong long POW(long long a, long long n) {\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ntemplate <class T>\nint sgn(T x) {\t//符号関数\n\tif(x < 0) return -1;\n\tif(x == 0) return 0;\n\treturn 1;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\t // a^n mod\n\tif(mod == 1) return 0LL;\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// a * x % mod == __gcd(a,mod)なるxを返す\n// a が modの倍数でないことが条件\nlong long modinv(long long a, long long mod) {\n\tlong long b = mod, u = 1, v = 0;\n\twhile(b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif(u < 0) u += mod;\n\treturn u;\n}\n\nvvll comb(100, vll(100, -1));\nlong long com(long long n, long long k) {  //普通の二項計数(overflowに注意)\n\tassert(n < 100 && k < 100);\n\tif(n < k || k < 0 || n < 0) return 0;\n\tif(comb[n][k] != -1) return comb[n][k];\n\tll res;\n\tif(n - k < k)\n\t\tres = com(n, n - k);\n\telse if(k == 0)\n\t\tres = 1;\n\telse\n\t\tres = com(n - 1, k - 1) + com(n - 1, k);\n\tcomb[n][k] = res;\n\treturn res;\n}\n\n// nCk modを求める\nconst ll MAX = 5100000;\n// この値は求める二項計数の値に応じて変える\n// MAX=3*10^7のとき1900msほど、ほぼ比例\n// MAX=5*10^6程度ならそれほど気にしなくてよい(300ms程)\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid cominit() {\n\t// テーブルを作る前処理\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nlong long commod(ll n, ll k) {\t// 二項係数計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nlong long pmod(ll n, ll k) {  //順列計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[n - k] % mod;\n}\nlong long hmod(ll n, ll k) {  // nHk計算\n\t// n個の区別しないoを区別するk個の箱に入れる方法の総数\n\t//(n+k-1)C(k-1)と等しい\n\treturn commod(n + k - 1, n);\n}\n#pragma endregion\n\n#pragma region input\n#define VEC(type, name, size) \\\n\tvector<type> name(size);  \\\n\tINPUT(name)\n#define VVEC(type, name, h, w)                     \\\n\tvector<vector<type>> name(h, vector<type>(w)); \\\n\tINPUT(name)\n#define INT(...)     \\\n\tint __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n#define LL(...)            \\\n\tlong long __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n#define STR(...)        \\\n\tstring __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n#define CHAR(...)     \\\n\tchar __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n#define DOUBLE(...)     \\\n\tdouble __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n#define LD(...)              \\\n\tlong double __VA_ARGS__; \\\n\tINPUT(__VA_ARGS__)\n\ntemplate <class T>\nvoid scan(T &a) {\n\tcin >> a;\n}\ntemplate <class T>\nvoid scan(vector<T> &a) {\n\tfor(auto &i : a) scan(i);\n}\ntemplate <class T, class L>\nvoid scan(pair<T, L> &p) {\n\tscan(p.first);\n\tscan(p.second);\n}\nvoid INPUT() {}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head &head, Tail &... tail) {\n\tscan(head);\n\tINPUT(tail...);\n}\ntemplate <class T>\ninline void print(T x) {\n\tcout << x << '\\n';\n}\n\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n#pragma endregion\n\n#pragma region debug\n\n#pragma region output\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\tif(i) os << \" \";\n\t\tos << v[i];\n\t}\n\treturn os;\n}\n#pragma endregion\n\n#pragma region view\n\ntemplate <typename T>\nvoid view(const T e) {\n\tstd::cerr << e;\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::pair<T, U> &p) {\n\tstd::cerr << \"(\";\n\tview(p.first);\n\tcerr << \", \";\n\tview(p.second);\n\tcerr << \")\";\n}\n\ntemplate <typename T>\nvoid view(std::set<T> &s) {\n\tif(s.empty()) {\n\t\tcerr << \"{ }\";\n\t\treturn;\n\t}\n\tstd::cerr << \"{ \";\n\tfor(auto &t : s) {\n\t\tview(t);\n\t\tstd::cerr << \", \";\n\t}\n\tstd::cerr << \"\\b\\b }\";\n}\n\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tif(v.empty()) {\n\t\tcerr << \"{ }\";\n\t\treturn;\n\t}\n\tstd::cerr << \"{ \";\n\tfor(const auto &e : v) {\n\t\tview(e);\n\t\tstd::cerr << \", \";\n\t}\n\tstd::cerr << \"\\b\\b }\";\n}\n\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tstd::cerr << \"{\\n\";\n\tfor(const auto &v : vv) {\n\t\tstd::cerr << \"\\t\";\n\t\tview(v);\n\t\tcerr << \"\\n\";\n\t}\n\tstd::cerr << \"}\";\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::vector<std::pair<T, U>> &v) {\n\tstd::cerr << \"{\\n\";\n\tfor(const auto &c : v) {\n\t\tstd::cerr << \"\\t(\";\n\t\tview(c.first);\n\t\tcerr << \", \";\n\t\tview(c.second);\n\t\tcerr << \")\\n\";\n\t}\n\tstd::cerr << \"}\";\n}\n\ntemplate <typename T, typename U>\nvoid view(const std::map<T, U> &m) {\n\tstd::cerr << \"{\\n\";\n\tfor(auto &t : m) {\n\t\tstd::cerr << \"\\t[\";\n\t\tview(t.first);\n\t\tcerr << \"] : \";\n\t\tview(t.second);\n\t\tcerr << \"\\n\";\n\t}\n\tstd::cerr << \"}\";\n}\n\n#pragma endregion\n\n// when debugging : g++ foo.cpp -DLOCAL\n#ifdef LOCAL\nvoid debug_out() {}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tview(H);\n\tcerr << \", \";\n\tdebug_out(T...);\n}\n#define debug(...)                                           \\\n\tdo {                                                     \\\n\t\tcerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"] : [\"; \\\n\t\tdebug_out(__VA_ARGS__);                              \\\n\t\tcerr << \"\\b\\b]\\n\";                                   \\\n\t} while(0)\n#define dump(x)                                 \\\n\tdo {                                        \\\n\t\tcerr << __LINE__ << \" \" << #x << \" : \"; \\\n\t\tview(x);                                \\\n\t\tcerr << \"\\n\";                           \\\n\t} while(0)\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\n#pragma endregion\n\n#include <atcoder/twosat>\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout << fixed << setprecision(15);\n\tsrand((unsigned)time(NULL));\n\n\tINT(n);\n\n\tatcoder::two_sat ts(n);\n\n\tINT(d);\n\tvi x(n), y(n);\n\trep(i, n) { INPUT(x[i], y[i]); }\n\n\trep(i, n) {\n\t\tRep(j, i + 1, n) {\n\t\t\tif(abs(x[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, 0, j, 0);\n\t\t\t}\n\t\t\tif(abs(x[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, 0, j, 1);\n\t\t\t}\n\t\t\tif(abs(y[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, 1, j, 0);\n\t\t\t}\n\t\t\tif(abs(y[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, 1, j, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(ts.satisfiable()) {\n\t\tYes();\n\t\tauto v = ts.answer();\n\t\tvi ans(n);\n\t\trep(i, n) { ans[i] = (!v[i] ? y[i] : x[i]); }\n\t\tvout(ans,1);\n\t} else {\n\t\tNo();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) begin(v),end(v)\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr ll INF = 1ll<<30;\nconstexpr ll longINF = 1ll<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr bool debug = 0;\n//---------------------------------//\n\n#include <atcoder/twosat>\n\nint main() {\n\tint N, D;\n\tscanf(\"%d %d\", &N, &D);\n\tvector<int> X(N), Y(N);\n\tREP(i, N) scanf(\"%d %d\", &X[i], &Y[i]);\n\t\n\tatcoder::two_sat sat(N);\n\tREP(i, N) FOR(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) sat.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) sat.add_clause(i, true, j, false);\n\t\tif (abs(Y[i] - X[j]) < D) sat.add_clause(i, false, j, true);\n\t\tif (abs(Y[i] - Y[j]) < D) sat.add_clause(i, false, j, false);\n\t}\n\t\n\tif (!sat.satisfiable()) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n\tauto ans = sat.answer();\n\tREP(i, N) printf(\"%d\\n\", ans[i] ? Y[i] : X[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nusing Vec = vector<ll>;\nusing VecP = vector<P>;\nusing VecB = vector<bool>;\nusing VecC = vector<char>;\nusing VecD = vector<ld>;\nusing VecS = vector<string>;\ntemplate <class T>\nusing Vec2 = vector<vector<T>>;\n#define REP(i, m, n) for(ll i = (m); i < (n); ++i)\n#define REPN(i, m, n) for(ll i = (m); i <= (n); ++i)\n#define REPR(i, m, n) for(ll i = (m)-1; i >= (n); --i)\n#define REPNR(i, m, n) for(ll i = (m); i >= (n); --i)\n#define rep(i, n) REP(i, 0, n)\n#define repn(i, n) REPN(i, 1, n)\n#define repr(i, n) REPR(i, n, 0)\n#define repnr(i, n) REPNR(i, n, 1)\n#define all(s) (s).begin(), (s).end()\n#define pb push_back\n#define fs first\n#define sc second\ntemplate <class T1, class T2>\nbool chmax(T1 &a, const T2 b){if(a < b){a = b; return true;} return false;}\ntemplate <class T1, class T2>\nbool chmin(T1 &a, const T2 b){if(a > b){a = b; return true;} return false;}\nll pow2(const int n){return (1LL << n);}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    for (T i : v) os << i << ' ';\n    return os;\n}\nvoid co() { cout << endl; }\ntemplate <class Head, class... Tail>\nvoid co(Head&& head, Tail&&... tail) {\n    cout << head << ' ';\n    co(forward<Tail>(tail)...);\n}\nvoid ce() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid ce(Head&& head, Tail&&... tail) {\n    cerr << head << ' ';\n    ce(forward<Tail>(tail)...);\n}\nvoid sonic(){ios::sync_with_stdio(false); cin.tie(0);}\nvoid setp(const int n){cout << fixed << setprecision(n);}\nconstexpr int INF = 1000000001;\nconstexpr ll LINF = 1000000000000000001;\nconstexpr ll MOD = 1000000007;\nconstexpr ll MOD_N = 998244353;\nconstexpr ld EPS = 1e-11;\nconst double PI = acos(-1);\n\nint main(void) {\n    ll n, d;\n    cin >> n >> d;\n    Vec x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    two_sat ts(n);\n\n    rep(i, n){\n        REP(j, i + 1, n){\n            if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n        }\n    }\n\n    if (!ts.satisfiable()) puts(\"No\");\n    else{\n        puts(\"Yes\");\n        auto ans = ts.answer();\n        rep(i, n) co(ans[i] ? x[i] : y[i]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define rrep(i, n) for (int i = (int)n-1; i >= 0; --i)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\ntemplate<typename T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\nnamespace detail {\n    template<typename T, int N>\n    auto make_vec(vector<int>& sizes, T const& x) {\n        if constexpr (N == 1) {\n            return vector(sizes[0], x);\n        } else {\n            int size = sizes[N-1];\n            sizes.pop_back();\n            return vector(size, make_vec<T, N-1>(sizes, x));\n        }\n    }\n}\ntemplate<typename T, int N>\nauto make_vec(int const(&sizes)[N], T const& x = T()) {\n    vector<int> s(N);\n    for (int i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n    return detail::make_vec<T, N>(s, x);\n}\n__attribute__((constructor))\nvoid fast_io() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    auto x = make_vec<int>({n, 2});\n    rep(i, n) cin >> x[i][0] >> x[i][1];\n    two_sat ts(n);\n\n    auto ng = [&](int a, int b) { return abs(a - b) < d; };\n    rep(i, n) for (int j = i+1; j < n; ++j) {\n        rep(k, 2) rep(l, 2) {\n            if (ng(x[i][k], x[j][l])) {\n                ts.add_clause(i, 1-k, j, 1-l);\n            }\n        }\n    }\n    bool ans = ts.satisfiable();\n    if (ans) {\n        cout << \"Yes\\n\";\n        auto v = ts.answer();\n        rep(i, n) cout << x[i][v[i]] << '\\n';\n    } else {\n        cout << \"No\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <cstddef>\n#include <algorithm>\n\nstruct strongly_connected_component {\n\tusing size_type = std::size_t;\nprivate :\n\tsize_type num;\n\tstd::vector<std::vector<size_type>> g, scc;\n\tstd::vector<size_type> low, order, index;\n\tstd::vector<bool> instack;\n\tstd::stack<size_type> sta;\n\n\tvoid chmin (size_type &a, const size_type &b) noexcept {\n\t\tif (a > b) a = b;\n\t}\n\n\tvoid dfs (size_type v) noexcept {\n\t\tlow[v] = order[v] = ++num;\n\t\tsta.push(v); instack[v] = true;\n\t\tfor (const size_type &u : g[v]) {\n\t\t\tif (order[u] == 0) {\n\t\t\t\tdfs(u);\n\t\t\t\tchmin(low[v], low[u]);\n\t\t\t} else if (instack[u]) {\n\t\t\t\tchmin(low[v], order[u]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == order[v]) {\n\t\t\tscc.push_back(std::vector<size_type>());\n\t\t\twhile (true) {\n\t\t\t\tconst size_type u = sta.top();\n\t\t\t\tsta.pop(); instack[u] = false;\n\t\t\t\tscc.back().push_back(u);\n\t\t\t\tif (u == v) break;\n\t\t\t}\n\t\t}\n\t}\n\npublic :\n\texplicit strongly_connected_component (size_type n)\n\tnoexcept : num(0), g(n), scc(), low(n, 0), order(n, 0), index(n), instack(n, false), sta() { }\n\n\tvoid add_edge (size_type v, size_type u) noexcept {\n\t\tg[v].push_back(u);\n\t}\n\n\tsize_type solve () noexcept {\n\t\tfor (size_type v = 0; v < g.size(); v++) if (not order[v]) dfs(v);\n\t\tstd::reverse(scc.begin(), scc.end());\n\t\tfor (size_type i = 0; i < scc.size(); i++) {\n\t\t\tfor (const size_type &v : scc[i]) index[v] = i;\n\t\t}\n\t\treturn scc.size();\n\t}\n\n\tconst std::vector<std::vector<size_type>> &get_scc () const noexcept {\n\t\treturn scc;\n\t}\n\n\tsize_type size () const noexcept {\n\t\treturn scc.size();\n\t}\n\n\tconst size_type &operator[] (size_type v) const noexcept {\n\t\treturn index[v];\n\t}\n\n};\n\n\n#include <vector>\n#include <cstddef>\n\nstruct two_sat {\n\tusing size_type = std::size_t;\nprivate :\n\tstrongly_connected_component scc;\n\tstd::vector<bool> answer;\n\npublic :\n\ttwo_sat (size_type n) noexcept : scc(n << 1), answer(n) { }\n\n\tvoid add_clause (size_type a, bool f, size_type b, bool g) noexcept {\n\t\tscc.add_edge(a << 1 | not f, b << 1 | g);\n\t\tscc.add_edge(b << 1 | not g, a << 1 | f);\n\t}\n\n\tbool satisfiable () noexcept {\n\t\tscc.solve();\n\t\tfor (size_type i = 0; i < answer.size(); i++) {\n\t\t\tif (scc[i << 1 | 0] == scc[i << 1 | 1]) return false;\n\t\t\tanswer[i] = (scc[i << 1 | 0] < scc[i << 1 | 1]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool get (const size_type i) const noexcept {\n\t\treturn answer[i];\n\t}\n\n};\n\n\n\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nint main() {\n\tint n, d;\n\tstd::cin >> n >> d;\n\tstd::vector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> x[i] >> y[i];\n\t}\n\t\n\ttwo_sat sat(n);\n\t\n\tauto f = [&] (int a, int b) {\n\t\treturn std::abs(a - b) < d;\n\t};\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (f(x[i], x[j])) sat.add_clause(i, 1, j, 1);\n\t\t\tif (f(x[i], y[j])) sat.add_clause(i, 1, j, 0);\n\t\t\tif (f(y[i], x[j])) sat.add_clause(i, 0, j, 1);\n\t\t\tif (f(y[i], y[j])) sat.add_clause(i, 0, j, 0);\n\t\t}\n\t}\n\t\n\tif (sat.satisfiable()) {\n\t\tstd::cout << \"Yes\" << '\\n';\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::cout << (sat.get(i) ? y[i] : x[i]) << '\\n';\n\t\t}\n\t} else {\n\t\tstd::cout << \"No\" << '\\n';\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nstruct Graph {\n    std::vector<std::vector<Edge<Cost>>> graph;\n\n    Graph(int n = 0) : graph(n) {}\n\n    void span(bool direct, int src, int dst, Cost cost = 1) {\n        graph[src].emplace_back(src, dst, cost);\n        if (!direct) graph[dst].emplace_back(dst, src, cost);\n    }\n\n    int size() const { return graph.size(); }\n    void clear() { graph.clear(); }\n    void resize(int n) { graph.resize(n); }\n\n    std::vector<Edge<Cost>>& operator[](int v) { return graph[v]; }\n    std::vector<Edge<Cost>> operator[](int v) const { return graph[v]; }\n};\n\ntemplate <class Cost = int>\nstruct StronglyConnectedComponents {\n    Graph<Cost> graph, rgraph;\n    std::vector<bool> visited;\n    std::vector<int> stk;\n\n    // id[v] = 頂点vはgroups[id[v]]に属する\n    std::vector<int> id;\n    std::vector<std::vector<int>> groups;\n\n    explicit StronglyConnectedComponents(const Graph<Cost>& g)\n        : graph(g), visited(graph.size(), false), id(graph.size(), -1) {\n        revinit();\n\n        for (int v = 0; v < (int)graph.size(); ++v) dfs(v);\n\n        while (!stk.empty()) {\n            int v = stk.back();\n            stk.pop_back();\n            if (id[v] < 0) {\n                groups.emplace_back();\n                rdfs(v);\n            }\n        }\n    }\n\n    void revinit() {\n        rgraph = Graph<Cost>(graph.size());\n        for (int v = 0; v < (int)graph.size(); ++v) {\n            for (const auto& e : graph[v]) {\n                rgraph[e.dst].emplace_back(e.dst, v, e.cost);\n            }\n        }\n    }\n\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (const auto& e : graph[v]) dfs(e.dst);\n        stk.push_back(v);\n    }\n\n    void rdfs(int v) {\n        if (id[v] >= 0) return;\n        id[v] = groups.size() - 1;\n        groups.back().push_back(v);\n        for (const auto& e : rgraph[v]) rdfs(e.dst);\n    }\n};\n\nstruct TwoSat {\n    int vnum;\n    Graph<> graph;\n\n    explicit TwoSat(int n) : vnum(n), graph(n * 2) {}\n\n    // t=1 <=> true\n    int enc(int x, bool t) {\n        return x + (t ? vnum : 0);\n    }\n\n    // [tx]x V [ty]y\n    void span(int x, bool tx, int y, bool ty) {\n        graph[enc(x, !tx)].emplace_back(enc(x, !tx), enc(y, ty));\n        graph[enc(y, !ty)].emplace_back(enc(y, !ty), enc(x, tx));\n    }\n\n    // if unsatisfiable, return an empty vector\n    std::vector<bool> exec() {\n        StronglyConnectedComponents scc(graph);\n\n        std::vector<bool> assign(vnum);\n        for (int x = 0; x < vnum; ++x) {\n            int fid = scc.id[enc(x, false)],\n                tid = scc.id[enc(x, true)];\n\n            if (fid == tid) {\n                assign.clear();\n                break;\n            } else {\n                assign[x] = (fid < tid);\n            }\n        }\n        return assign;\n    }\n};\n\nvoid solve() {\n    int n, d;\n    std::cin >> n >> d;\n\n    std::vector<int> xs(n * 2);\n    for (auto& x : xs) std::cin >> x;\n\n    TwoSat ts(n * 2);\n    for (int i = 0; i < n * 2; i += 2) {\n        ts.span(i, true, i + 1, true);\n        ts.span(i, false, i + 1, false);\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (std::abs(xs[i] - xs[j]) < d) {\n                ts.span(i, false, j, false);\n            }\n        }\n    }\n\n    auto ans = ts.exec();\n    if (ans.empty()) {\n        std::cout << \"No\\n\";\n        return;\n    }\n\n    std::cout << \"Yes\\n\";\n    for (int i = 0; i < n * 2; ++i) {\n        if (ans[i]) std::cout << xs[i] << \"\\n\";\n    }\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This Code was made by Chinese_zjc_.\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <time.h>\n// #include<windows.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 0.0000000001;\nconst int INF = 0x3fffffffffffffff;\nint n, d, x[1005], y[1005], dfn[2005], low[2005], fa[2005], in[2005], tim, cnt;\nbool ins[2005], ans[2005];\nvector<int> to[2005], To[2005], inside[2005];\nqueue<int> que;\nstack<int> sta;\nvoid Tarjan(int now)\n{\n    dfn[now] = low[now] = ++tim;\n    ins[now] = true;\n    sta.push(now);\n    for (int i = 0; i < (int)to[now].size(); ++i)\n    {\n        if (!dfn[to[now][i]])\n        {\n            Tarjan(to[now][i]);\n            low[now] = min(low[now], low[to[now][i]]);\n        }\n        else if (ins[to[now][i]])\n        {\n            low[now] = min(low[now], low[to[now][i]]);\n        }\n    }\n    if (dfn[now] == low[now])\n    {\n        ++cnt;\n        int tmp = sta.top();\n        while (tmp != now)\n        {\n            ins[tmp] = false;\n            inside[cnt].push_back(tmp);\n            fa[tmp] = cnt;\n            sta.pop();\n            tmp = sta.top();\n        }\n        ins[now] = false;\n        inside[cnt].push_back(now);\n        fa[now] = cnt;\n        sta.pop();\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> d;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> x[i] >> y[i];\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = 1; j <= n; ++j)\n        {\n            if (i == j)\n            {\n                continue;\n            }\n            if (abs(x[i] - x[j]) < d)\n            {\n                to[i << 1 | 0].push_back(j << 1 | 1);\n            }\n            if (abs(x[i] - y[j]) < d)\n            {\n                to[i << 1 | 0].push_back(j << 1 | 0);\n            }\n            if (abs(y[i] - x[j]) < d)\n            {\n                to[i << 1 | 1].push_back(j << 1 | 1);\n            }\n            if (abs(y[i] - y[j]) < d)\n            {\n                to[i << 1 | 1].push_back(j << 1 | 0);\n            }\n        }\n    }\n    for (int i = 2; i <= (n << 1 | 1); ++i)\n    {\n        if (!dfn[i])\n        {\n            Tarjan(i);\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        if (fa[i << 1] == fa[i << 1 | 1])\n        {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    for (int i = 1; i <= cnt; ++i)\n    {\n        for (int j = 0; j < (int)inside[i].size(); ++j)\n        {\n            for (int k = 0; k < (int)to[inside[i][j]].size(); ++k)\n            {\n                if (i != fa[to[inside[i][j]][k]])\n                {\n                    To[i].push_back(fa[to[inside[i][j]][k]]);\n                    ++in[To[i].back()];\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= cnt; ++i)\n    {\n        if (!in[i])\n        {\n            que.push(i);\n        }\n    }\n    while (!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n        for (int i = 0; i < (int)inside[now].size(); ++i)\n        {\n            ans[inside[now][i] >> 1] = inside[now][i] & 1;\n        }\n        for (int i = 0; i < (int)To[now].size(); ++i)\n        {\n            --in[To[now][i]];\n            if (!in[To[now][i]])\n            {\n                que.push(To[now][i]);\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; ++i)\n    {\n        cout << (ans[i] ? y[i] : x[i]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *\tauthor: nok0\n *\tcreated: 2020.09.08 09:42:33\n**/\n#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(int i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(int i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V<V<T>>;\nusing P = pair<int, int>;\n#define VEC(type, name, size)\\\n\tV<type> name(size);\\\n\tIN(name)\n#define VVEC(type, name, h, w)\\\n\tVV<type> name(h, V<type>(w));\\\n\tIN(name)\n#define INT(...)\\\n\tint __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\n#define LL(...)\\\n\tll __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\n#define STR(...)\\\n\tstring __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\n#define CHAR(...)\\\n\tchar __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\n#define DOUBLE(...)\\\n\tDOUBLE __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\n#define LD(...)\\\n\tLD __VA_ARGS__;\\\n\tIN(__VA_ARGS__)\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(V<T> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T> void scan(V<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p){\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p){\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const V<T> &v){\n\tREP(i, SZ(v)){\n\t\tif(i) os << \" \";\n\t\tos << v[i];\n\t}\n\treturn os;\n}\n//debug\ntemplate <typename T>\nvoid view(const V<T> &v){\n\tcerr << \"{ \";\n\tfor(const auto &e : v){\n\t\tcerr << e << \", \";\n\t}\n\tcerr << \"\\b\\b }\";\n}\ntemplate <typename T>\nvoid view(const VV<T> &vv){\n\tcerr << \"{\\n\";\n\tfor(const auto &v : vv){\n\t\tcerr << \"\\t\";\n\t\tview(v);\n\t\tcerr << \"\\n\";\n\t}\n\tcerr << \"}\";\n}\ntemplate <typename T, typename U>\nvoid view(const V<pair<T, U>> &v){\n\tcerr << \"{\\n\";\n\tfor(const auto &c : v) cerr << \"\\t(\" << c.first << \", \" << c.second << \")\\n\";\n\tcerr << \"}\";\n}\ntemplate <typename T, typename U>\nvoid view(const map<T, U> &m){\n\tcerr << \"{\\n\";\n\tfor(auto &t : m) cerr << \"\\t[\" << t.first << \"] : \" << t.second << \"\\n\";\n\tcerr << \"}\";\n}\ntemplate <typename T, typename U>\nvoid view(const pair<T, U> &p){ cerr << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <typename T>\nvoid view(const set<T> &s) {\n\tcerr << \"{ \";\n\tfor(auto &t : s) {\n\t\tview(t);\n\t\tcerr << \", \";\n\t}\n\tcerr << \"\\b\\b }\";\n}\ntemplate <typename T>\nvoid view(T e) { cerr << e;}\n#ifdef LOCAL\nvoid debug_out() {}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tview(H);\n\tcerr << \", \";\n\tdebug_out(T...);\n}\n#define debug(...)                                           \\\n\tdo{                                                     \\\n\t\tcerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"] : [\"; \\\n\t\tdebug_out(__VA_ARGS__);                              \\\n\t\tcerr << \"\\b\\b]\\n\";                                   \\\n\t} while(0)\n#else\n#define debug(...) (void(0))\n#endif\ntemplate <class T> V<T> press(V<T> &x){ \n\tV<T> res = x;\n\tsort(all(res));\n\tres.erase(unique(all(res)), res.end());\n\tREP(i, SZ(x)){\n\t\tx[i] = lower_bound(all(res), x[i]) - res.begin();\n\t}\n\treturn res;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T divup(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nstruct iofast{iofast(){ios::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(15);}}iofast_;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n#pragma endregion\n\n// Graph Template\nstruct Edge{\n\tll to,cost;\n\tEdge(ll to,ll cost):to(to),cost(cost){}\n\tbool operator < (const Edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nusing Graph = VV<>;\nusing WGraph = VV<Edge>;\n\nvoid Read_Graph(Graph &g, int m, bool directed = false){\n\tREP(i, m){\n\t\tLL(u, v); \n\t\tg[u].pb(v);\n\t\tif(!directed) g[v].pb(u);\n\t}\n}\nvoid Read_Tree(Graph &g, bool directed = false) {Read_Graph(g, SZ(g) - 1, directed);}\n\nvoid Read_Graph(WGraph &g, int m, bool directed = false){\n\tREP(i, m){\n\t\tLL(u, v, c); u--; v--;\n\t\tg[u].pb({v, c});\n\t\tif(!directed) g[v].pb({u, c});\n\t}\n}\nvoid Read_Tree(WGraph &g, bool directed = false) {Read_Graph(g, SZ(g) - 1, directed);}\n\n//Strongly Connected Components(強成分連結分解)(Graph Templateと併用)\nstruct SCC{\n\tconst Graph &g;\n\tGraph ng, rg;\n\tV<int> compo, order, used;\n\n\t//g:元のグラフ, ret:強連結成分分解後のグラフ\n\tSCC(Graph &g, Graph &ret) : g(g), ng(SZ(g)), rg(SZ(g)), compo(SZ(g), -1), used(SZ(g)){\n\t\tREP(i, SZ(g)){\n\t\t\tfor(auto v : g[i]){\n\t\t\t\tng[i].pb(v);\n\t\t\t\trg[v].pb(i);\n\t\t\t}\n\t\t}\n\t\tbuild(ret);\n\t}\n\n\tint operator[](int k){ return compo[k];}\n\n\tvoid dfs(int now){\n\t\tif(used[now]) return;\n\t\tused[now] = true;\n\t\tfor(auto to : ng[now]) dfs(to);\n\t\torder.eb(now);\n\t}\n\n\tvoid rdfs(int now, int count){\n\t\tif(compo[now] != -1) return;\n\t\tcompo[now] = count;\n\t\tfor(auto to : rg[now]) rdfs(to, count);\n\t}\n\n\tvoid build(Graph &ret){\n\t\tREP(i, SZ(ng)) dfs(i);\n\t\treverse(all(order));\n\t\tint group = 0;\n\t\tfor(auto i : order) if(compo[i] == -1) rdfs(i, group), group++;\n\t\tret.resize(group);\n\t\tREP(i, SZ(g)){\n\t\t\tfor(auto &to : g[i]){\n\t\t\t\tint s = compo[i], t = compo[to];\n\t\t\t\tif(s != t) ret[s].eb(t);\n\t\t\t}\n\t\t}\n\t}\n};\n\n//2-SAT(SCCと併用)\nstruct TwoSat{\n\tint n;\n\tGraph g;\n\tTwoSat(int n) : n(n), g(n * 2){}\n\tint negate(int v){return (n + v) % (n * 2);}\n\tvoid add_if(int u,int v){\n\t\t//u -> v <=> !v -> !u\n\t\tg[u].pb(v);\n\t\tg[negate(v)].pb(negate(u));\n\t}\n\tvoid add_or(int u,int v){\n\t\t//u or v <=> !u -> v\n\t\tadd_if(negate(u), v);\n\t}\n\tvoid add_nand(int u,int v){\n\t\t//u nand v <=> u -> !v\n\t\tadd_if(u, negate(v));\n\t}\n\tvoid set_true(int v){\n\t\t//v <=> !v ->  v\n\t\tg[negate(v)].pb(v);\n\t}\n\tvoid set_false(int v){\n\t\t//!v <=>  v -> !v\n\t\tg[v].pb(negate(v));\n\t}\n\tvector<int> build(){\n\t\tGraph ret;\n\t\tSCC scc(g, ret);\n\t\tvector<int> res(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(scc[i] == scc[n+i]) return {};\n\t\t\tres[i] = scc[i] > scc[n+i];\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tINT(n, d);\n\tVEC(P, a, n);\n\tTwoSat TS(n);\n\tREP(i, n) REP(j, n){\n\t\tif(i == j) continue;\n\t\tif(abs(a[i].first - a[j].first) < d) TS.add_nand(i, j);\n\t\tif(abs(a[i].first - a[j].second) < d) TS.add_nand(i, j + n);\n\t\tif(abs(a[i].second - a[j].first) < d) TS.add_nand(i + n, j);\n\t\tif(abs(a[i].second - a[j].second) < d) TS.add_nand(i + n, j + n);\n\t}\n\tauto res = TS.build();\n\tYes(SZ(res));\n\tREP(i, SZ(res)) print(res[i] ? a[i].first : a[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <cmath>\n#include <utility>\n#include <functional>\n#include <map>\n#include <set>\n#include <cctype>\n#include <fstream>\n#include <numeric>\n#include <cassert>\n\n#include <cstdint>\n#include <iomanip>\n#include <cstring>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll = long long;\n#define ALL(a) (a).begin(), (a).end()\n\n#define FOR(i, a, b) for (long long int i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (long long int i = (a); i >= (b); i--)\n\nconst int MOD = 1000000007;\n\n#define LLONG_MAXs 9223372036854775800 / 2\n//#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\n#define ALL(a) (a).begin(), (a).end()\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrimeNum(ll x)\n{ // 素数である場合 true を返す\n    if (x <= 1)\n    { // 1以下である場合は素数でないことがすぐにわかる\n        return false;\n    }\n    // sqrt( double型 ) は引数の平方根を double型で返すので、int型でキャスト\n    int n = (int)sqrt((double)x);\n    for (int i = 2; i <= n; i++)\n    {\n        if (x % i == 0)\n        { // 割り切る整数がある場合、即判定終了\n            return false;\n        }\n    }\n    return true; // 割り切る整数がない場合、素数である\n}\n\nll myPow(ll x, ll n, ll m)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n\nconstexpr ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nconstexpr ll lcm(ll a, ll b) { return a * b / gcd(a, b); }\nconstexpr ll abs(ll a, ll b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr double dabs(double a, double b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr ll min(ll a, ll b)\n{\n    if (a >= b)\n        return b;\n    if (a < b)\n        return a;\n}\n\nconstexpr ll max(ll a, ll b)\n{\n    if (a >= b)\n        return a;\n    if (a < b)\n        return b;\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dx8[8] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy8[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nclass UnionFind\n{\npublic:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> Parent;\n\n    //作るときはParentの値を全て-1にする\n    //こうすると全てバラバラになる\n    UnionFind(int N)\n    {\n        Parent = vector<int>(N, -1);\n    }\n\n    //Aがどのグループに属しているか調べる\n    int root(int A)\n    {\n        if (Parent[A] < 0)\n            return A;\n        return Parent[A] = root(Parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A)\n    {\n        return -Parent[root(A)]; //親をとってきたい]\n    }\n    bool issame(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    //AとBをくっ付ける\n    bool connect(int A, int B)\n    {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B)\n        {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n\n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらひっくり返しちゃう。\n        if (size(A) < size(B))\n            swap(A, B);\n\n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n\n        return true;\n    }\n};\n\nlong long fac[510000], finv[510000], inv[510000];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < 510000; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n    if (n < k)\n        return 0;\n    if (n < 0 || k < 0)\n        return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long modinv(long long a, long long m)\n{\n    long long b = m, u = 1, v = 0;\n    while (b)\n    {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n\nvoid yn(bool flag)\n{\n    if (flag)\n    {\n        cout << \"Yes\" << endl;\n    }\n    else\n    {\n        cout << \"No\" << endl;\n    }\n    return;\n}\nvoid YN(bool flag)\n{\n    if (flag)\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n    return;\n}\n\nstd::vector<ll> enum_div(ll n) //nの約数を列挙\n{\n    std::vector<ll> ret;\n    for (ll i = 1; i * i <= n; ++i)\n    {\n        if (n % i == 0)\n        {\n            ret.push_back(i);\n            if (i != 1 && i * i != n)\n            {\n                ret.push_back(n / i);\n            }\n        }\n    }\n    ret.push_back(n);\n    return ret;\n}\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate <int MOD>\nstruct Fp\n{\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD)\n    {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept\n    {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator+(const Fp &r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator-(const Fp &r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator*(const Fp &r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator/(const Fp &r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp &operator+=(const Fp &r) noexcept\n    {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept\n    {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept\n    {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept\n    {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b)\n        {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept\n    {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept\n    {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept\n    {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept\n    {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\n// グラフセット\nstruct Edge\n{\n    ll to;     // 辺の行き先\n    ll weight; // 辺の重み\n    Edge(int t, int w) : to(t), weight(w) {}\n};\n//using Graph = vector<vector<Edge>>;\n#define def 0\ntemplate <class V, int NV>\nstruct SegTree\n{ //[l,r)\n    V comp(V &l, V &r) { return max(l, r); };\n\n    vector<V> val;\n    SegTree() { val = vector<V>(NV * 2, def); }\n    V get(int x, int y, int l = 0, int r = NV, int k = 1)\n    {\n        if (r <= x || y <= l)\n            return def;\n        if (x <= l && r <= y)\n            return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2);\n        auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);\n        return comp(a, b);\n    }\n    void update(int i, V v)\n    {\n        i += NV;\n        val[i] = v;\n        while (i > 1)\n            i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n    }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\ntypedef vector<vector<long long>> matrix;\nmatrix mul_mod(matrix A, matrix B)\n{\n    int H = A.size();\n    int W = B[0].size();\n    int K = A[0].size();\n\n    matrix C(H, vector<ll>(W, 0));\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            for (int k = 0; k < K; k++)\n            {\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\n\n// 区間加算にも対応した BIT\ntemplate <class Abel>\nstruct BIT\n{\n    vector<Abel> dat[2];\n    Abel UNITY_SUM = 0; // to be set\n\n    /* [1, n] */\n    BIT(int n) { init(n); }\n    void init(int n)\n    {\n        for (int iter = 0; iter < 2; ++iter)\n            dat[iter].assign(n + 1, UNITY_SUM);\n    }\n\n    /* a, b are 1-indexed, [a, b) */\n    inline void sub_add(int p, int a, Abel x)\n    {\n        for (int i = a; i < (int)dat[p].size(); i += i & -i)\n            dat[p][i] = dat[p][i] + x;\n    }\n    inline void add(int a, int b, Abel x)\n    {\n        sub_add(0, a, x * -(a - 1));\n        sub_add(1, a, x);\n        sub_add(0, b, x * (b - 1));\n        sub_add(1, b, x * (-1));\n    }\n\n    /* a is 1-indexed, [a, b) */\n    inline Abel sub_sum(int p, int a)\n    {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[p][i];\n        return res;\n    }\n    inline Abel sum(int a, int b)\n    {\n        return sub_sum(0, b - 1) + sub_sum(1, b - 1) * (b - 1) - sub_sum(0, a - 1) - sub_sum(1, a - 1) * (a - 1);\n    }\n\n    /* debug */\n    void print()\n    {\n        for (int i = 1; i < (int)dat[0].size(); ++i)\n            cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\nusing Graph = vector<vector<ll>>;\n\nvoid print(const std::vector<int> &v)\n{\n    std::for_each(v.begin(), v.end(), [](int x) {\n        std::cout << x << \" \";\n    });\n    std::cout << std::endl;\n}\nconst double PI = 3.14159265358979323846;\nll times_cap(ll a, ll b)\n{\n    if (log10(a) + log10(b) >= 19.0)\n        return -1;\n    else\n        return a * b;\n}\n\n// konpairu command\n//  g++ code.cpp -std=c++14 -I .\n//cout << std::setprecision(30) << ans << endl;\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        x[i]--;\n        y[i]--;\n    }\n    int left = 0, right = 1e10;\n    // ts[i] = (i-th flag is located on x[i])\n\n    \n    two_sat ts(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n \ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n \ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n \n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define rep(i,a) FOR(i,0,a)\n#define RFOR(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define RF0R(i,a) RFOR(i,0,a)\n#define rrep(i,a) RFOR(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n \ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n \ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n \n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n \ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n \ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n \n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n}\n\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n \n// OUTPUT\ntemplate<class A> void printl(A x) { cout << ts(x); }\ntemplate<class H, class... T> void printl(const H& h, const T&... t) { \n\tprintl(h); printl(t...); }\nvoid print() { printl(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void print(const H& h, const T&... t) { \n\tprintl(h); if (sizeof...(t)) printl(\" \"); print(t...); }\n \n// DEBUG\nvoid DBG() { cerr << \" ##\"<< endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define printe(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: \", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define printe(...) 0\n\t#define chk(...) 0\n#endif\n \n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nsigned main(){\n    setIO(); \n    //ll N; re(N);\n\tll N, D; re(N,D);\n\t//vi A(N); re(A);\n\tvi X(N),Y(N);\n\trep(i,N){\n\t\tre(X[i],Y[i]);\n\t} \n\ttwo_sat ts(N);\n\trep(i,N){\n\t\tint xi=X[i],yi=Y[i];\n\t\tFOR(j,i+1,N){\n\t\t\t\n\t\t\tint xj=X[j],yj=Y[j];\n\t\t\tif (abs(xi-xj)<D){\n\t\t\t\tts.add_clause(i,false,j,false);\n\t\t\t}\n\t\t\tif (abs(yi-xj)<D){\n\t\t\t\tts.add_clause(i,true,j,false);\n\t\t\t}\n\t\t\tif (abs(xi-yj)<D){\n\t\t\t\tts.add_clause(i,false,j,true);\n\t\t\t}\n\t\t\tif (abs(yi-yj)<D){\n\t\t\t\tts.add_clause(i,true,j,true);\n\t\t\t}\n\n\t\t}\n\t}\n\tauto sas=ts.satisfiable();\n\tif(!sas){\n\t\tprint(\"No\");return 0;\n\t}\n\tprint(\"Yes\");\n\tauto ans=ts.answer();\n\trep(i,N){\n\t\tif (ans[i]){\n\t\t\tprint(X[i]);\n\t\t}\n\t\telse print(Y[i]);\n\t}\n\t\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define INF_LL 1000000000000000000LL\n#define INF 200000000\n#define MOD 998244353\n#define ll long long\n#define all(x) x.begin(), x.end()\n#define REP(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, n) REP(i, 0, n)\n// typedef float double;\n// typedef priority_queue prique;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<ll> vl;\ntypedef vector<vi> matrix;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint sign[2] = {1, -1};\ntemplate <class T> bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nll modpow(ll a, ll b, ll m) {\n    if(b == 0)\n        return 1;\n    ll t = modpow(a, b / 2, m);\n    if(b & 1) {\n        return (t * t % m) * a % m;\n    } else {\n        return t * t % m;\n    }\n}\n\nstruct edge {\n    int to;\n    ll cost;\n    edge(int t, ll c) { to = t, cost = c; }\n};\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<P> x(n);\n    rep(i, n) cin >> x[i].first >> x[i].second;\n    two_sat ts(n);\n    rep(i, n) REP(j, i + 1, n) {\n        if(abs(x[i].first - x[j].first) < d)\n            ts.add_clause(i, false, j, false);\n        if(abs(x[i].first - x[j].second) < d)\n            ts.add_clause(i, false, j, true);\n        if(abs(x[i].second - x[j].first) < d)\n            ts.add_clause(i, true, j, false);\n        if(abs(x[i].second - x[j].second) < d)\n            ts.add_clause(i, true, j, true);\n    }\n    if(ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        vector<bool> ans = ts.answer();\n        rep(i, n) {\n            if(ans[i]) {\n                cout << x[i].first << endl;\n            } else {\n                cout << x[i].second << endl;\n            }\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <utility>\n\n#include <atcoder/twosat>\n\nusing namespace std;\nusing namespace atcoder;\n#define rep(i,l,r) for(int i = l; i < r; ++i)\n\nint main() {\n    int n, d, x, y, a, b;\n    cin >> n >> d;\n\n    two_sat ts(n);\n    vector<pair<int, int>> xy;\n    rep(i, 0, n) {\n        cin >> x >> y;\n\n        rep(j, 0, i) {\n            a = xy[j].first;\n            b = xy[j].second;\n\n            if (abs(x - a) < d) ts.add_clause(i, false, j, false);\n            if (abs(x - b) < d) ts.add_clause(i, false, j, true);\n            if (abs(y - a) < d) ts.add_clause(i, true, j, false);\n            if (abs(y - b) < d) ts.add_clause(i, true, j, true);\n        }\n\n        xy.push_back({x, y});\n    }\n\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, 0, n) cout << (ans[i] ? xy[i].first : xy[i].second) << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i,n) for (int i = 0;i < (int)(n);i++)\nusing ll = long long;\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\nconst long long INF = 1LL << 60;\nconst double pi=acos(-1.0);\nint dx[9] = {1, 0, -1, 0, 1, 1, -1, -1, 0};\nint dy[9] = {0, 1, 0, -1, 1, -1, -1, 1, 0};\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\n\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  // cout << fixed << setprecision(15);\n  \n  ll N,D; cin>>N>>D;\n  vector<ll> x(N),y(N); rep(i,N) cin>>x[i]>>y[i];\n  \n  two_sat ts(N);\n  rep(i,N){\n    for(int j=i+1;j<N;j++){\n      if(abs(x[i]-x[j])<D) ts.add_clause(i,0,j,0);\n      if(abs(y[i]-y[j])<D) ts.add_clause(i,1,j,1);\n      if(abs(x[i]-y[j])<D) ts.add_clause(i,0,j,1);\n      if(abs(y[i]-x[j])<D) ts.add_clause(i,1,j,0);\n    }\n  }\n  \n  if(!ts.satisfiable()) {cout<<\"No\"<<'\\n'; return 0;}\n  else cout<<\"Yes\"<<'\\n';\n  \n  auto ans_vec=ts.answer();\n  \n  rep(i,N) cout<<(ans_vec[i]?x[i]:y[i])<<'\\n';\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i-->0;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcountll\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst int md=998244353;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0||n<k?0ll:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}int dist(int a,int b){return dep[a]+dep[b]-2*dep[operator()(a,b)];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\ntemplate<typename T,typename U>void sort2(vector<T>&a,vector<U>&b){int N=a.size();assert(b.size()==N);vector<pair<T,U>>v;fr(i,N){v<<pair<T,U>{a[i],b[i]};}Sort(v);fr(i,N){a[i]=v[i].first;b[i]=v[i].second;}}\ntemplate<typename T,typename U,typename V>void sort3(vector<T>&a,vector<U>&b,vector<V>&c){int N=a.size();assert(b.size()==N);assert(c.size()==N);vector<pair<T,pair<U,V>>>v;fr(i,N){v.push_back({a[i],{b[i],c[i]}});}Sort(v);fr(i,N){a[i]=v[i].first;b[i]=v[i].second.first;c[i]=v[i].second.second;}}\nvb SAT2(vvi E){int N=E.size();assert(N%2==0);vi T(N,-1);{vvi R(N);vi v;{vb u(N);function<void(int)>f=[&](int i){if(u[i])return;u[i]=true;for(int j:E[i]){R[j]<<i;f(j);}v<<i;};fr(i,N){f(i);}}{int k=0;function<void(int)>f=[&](int i){T[i]=k;for(int j:R[i]){if(T[j]==-1){f(j);}}};rf(i,v.size()){if(T[v[i]]==-1){f(v[i]);++k;}}}}vb z(N);fr(i,N/2){if(T[2*i]==T[2*i+1]){return vb{};}z[2*i+(T[2*i]<T[2*i+1])]=true;}return z;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,D;cin>>N>>D;\n\tvi A(2*N);cin>>A;\n\tvvi E(2*N);\n\tfr(i,N)fr(j,i){\n\t\tfr(k,2)fr(l,2){\n\t\t\tint a=2*i+k,b=2*j+l;\n\t\t\tif(abs(A[a]-A[b])<D){\n\t\t\t\tE[a]<<(b^1);\n\t\t\t\tE[b]<<(a^1);\n\t\t\t}\n\t\t}\n\t}\n\tvb z=SAT2(E);\n\tif(Yn(z.size())){\n\t\tfr(i,N){\n\t\t\tprint(A[2*i+z[2*i+1]]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n\nusing namespace std;\n#ifdef __DEBUG__\n    void debug_out() { cerr << endl; } \n    template <typename Head, typename... Tail>\n    void debug_out(Head H, Tail... T) {cerr << \" \" << H; debug_out(T...);}\n    #define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n    #define debug(...) \n#endif\n\nusing ll = long long int;\nusing pii = pair<int, int>;\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\n\nint N,D;\nvector<pii> X;\ninline void input(){\n    fast_io();\n    cin >> N >> D;\n    for (int i = 0; i < N; i++)\n    {\n        int x,y; cin >> x >> y;\n        X.emplace_back(x,y);\n    }\n}\n\ninline int solve(){\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            if(i==j) continue;\n            if(abs(X[i].first-X[j].first)<D) ts.add_clause(i,true,j,true);\n            if(abs(X[i].first-X[j].second)<D) ts.add_clause(i,true,j,false);\n            if(abs(X[i].second-X[j].first)<D) ts.add_clause(i,false,j,true);\n            if(abs(X[i].second-X[j].second)<D) ts.add_clause(i,false,j,false);\n        }\n    }\n    cout << (ts.satisfiable() ? \"Yes\" : \"No\") << endl;\n    if(ts.satisfiable()){\n        auto ans = ts.answer();\n        for (int i = 0; i < N; i++)\n        {\n            if(!ans[i]) cout << X[i].first << \"\\n\";\n            else cout << X[i].second << \"\\n\";\n        }\n    }\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //SCC decomposition\n    void dfs(int v, vector<bool> &used, vec &vs){\n        used[v] = true;\n        REP(i, G[v].size()){\n            if(!used[G[v][i].to]) dfs(G[v][i].to, used, vs);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k, vector<bool> &used, vec &cmp){\n        used[v] = true;\n        cmp[v] = k;\n        REP(i, G[v].size()){\n            if(!used[G[v][i].to]) rdfs(G[v][i].to, k, used, cmp);\n        }\n    }\n    //u->v => cmp[u]<cmp[v]\n    vec scc(int &k){\n        vector<bool> used(N, false);\n        vec vs(0), cmp(N);\n        REP(i, N){\n            if(!used[i]) dfs(i, used, vs);\n        }\n        //reverse graph\n        Graph rG(N);\n        REP(v, N) REP(i, G[v].size()) rG.add_Directed_edge(G[v][i].to, v, G[v][i].cost);\n\n        fill(used.begin(), used.end(), false);\n        k = 0;\n        IREP(i, vs.size()){\n            if(!used[vs[i]]) rG.rdfs(vs[i], k++, used, cmp);\n        }\n        return cmp;\n    }\n    //2-SAT用\n    //N=2nとして、0,...,n-1の否定をn,...,2n-1で表す\n    int NOT(int X){ return (X + N / 2) % N; }\n    void add_X(int X){\n        add_Directed_edge(NOT(X), X);    \n    } \n    void add_AorB(int A, int B){\n        add_Directed_edge(NOT(A), B);\n        add_Directed_edge(NOT(B), A);\n    }\n    bool solve_2SAT(vector<bool> &ans){\n        int k;\n        int n = N / 2;\n        vec cmp = scc(k);\n        ans.resize(n);\n        REP(i, n){\n            if(cmp[i] == cmp[i + n]) return false;\n            else if(cmp[i] < cmp[i + n]) ans[i] = false;\n            else ans[i] = true;\n        }\n        return true;\n    }\n\n};\n\nsigned main(){\n\n    int N, D; cin >> N >> D;\n    vec X(N), Y(N);\n    REP(i, N){\n        cin >> X[i] >> Y[i];\n    }\n\n    Graph G(2 * N);\n    REP(i, N) REP(j, i){\n        if(abs(X[i] - X[j]) < D) G.add_AorB(i + N, j + N);\n        if(abs(X[i] - Y[j]) < D) G.add_AorB(i + N, j);\n        if(abs(Y[i] - X[j]) < D) G.add_AorB(i, j + N);\n        if(abs(Y[i] - Y[j]) < D) G.add_AorB(i, j);\n    }\n    v_bool ans;\n    bool ok = G.solve_2SAT(ans);\n    if(ok){\n        Out(\"Yes\");\n        REP(i, N) chOut(ans[i], X[i], Y[i]);\n    }else{\n        Out(\"No\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/practice2/tasks/practice2_h\n#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define int long long\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, s, n) for (int i = (s), i##_len = (n); i < i##_len; ++i)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define ALLR(obj) (obj).rbegin(), (obj).rend()\n#define CEIL(a, b) ((a - 1) / b + 1)\n\nvoid solve() {\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    REP(i, N) cin >> X[i] >> Y[i];\n    two_sat ts(N);\n    REP(i, N) REP(j, i) {\n        if (abs(X[i] - X[j]) < D) {\n            ts.add_clause(i, false, j, false);\n        }\n        if (abs(X[i] - Y[j]) < D) {\n            ts.add_clause(i, false, j, true);\n        }\n        if (abs(Y[i] - X[j]) < D) {\n            ts.add_clause(i, true, j, false);\n        }\n        if (abs(Y[i] - Y[j]) < D) {\n            ts.add_clause(i, true, j, true);\n        }\n    }\n    if (!ts.satisfiable()) {\n        cout << \"No\\n\";\n        return;\n    }\n    cout << \"Yes\\n\";\n    auto ans = ts.answer();\n    REP(i, N) {\n        if (ans[i]) {\n            cout << X[i] << \"\\n\";\n        } else {\n            cout << Y[i] << \"\\n\";\n        }\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, D, X[1010][2];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> D;\n\trep(i, 0, N) rep(j, 0, 2) cin >> X[i][j];\n\n\ttwo_sat ts(N);\n\trep(x1, 0, N) rep(b1, 0, 2) rep(x2, x1 + 1, N) rep(b2, 0, 2) {\n\t\tint d = abs(X[x1][b1] - X[x2][b2]);\n\t\tif (d < D) ts.add_clause(x1, b1, x2, b2);\n\t}\n\tbool ans = ts.satisfiable();\n\n\tif (!ans) {\n\t\tprintf(\"No\\n\");\n\t\treturn;\n\t}\n\n\tauto v = ts.answer();\n\n\tprintf(\"Yes\\n\");\n\trep(i, 0, N) printf(\"%d\\n\", X[i][1 - v[i]]);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n\nusing namespace std;\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\n\nint N,D;\nvector<pair<int, int>> X;\ninline void input(){\n    fast_io();\n    cin >> N >> D;\n    for (int i = 0; i < N; i++)\n    {\n        int x,y; cin >> x >> y;\n        X.emplace_back(x,y);\n    }\n}\n\n#define xx true\n#define yy false\n#define x first\n#define y second\n\ninline int solve(){\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = i + 1; j < N; j++)\n        {\n            if(abs(X[i].x-X[j].x)<D) ts.add_clause(i,yy,j,yy);\n            if(abs(X[i].x-X[j].y)<D) ts.add_clause(i,yy,j,xx);\n            if(abs(X[i].y-X[j].x)<D) ts.add_clause(i,xx,j,yy);\n            if(abs(X[i].y-X[j].y)<D) ts.add_clause(i,xx,j,xx);\n        }\n    }\n    cout << (ts.satisfiable() ? \"Yes\" : \"No\") << endl;\n    if(ts.satisfiable()){\n        auto ans_locate = ts.answer();\n        for (int i = 0; i < N; i++)\n        {\n            if(ans_locate[i]) cout << X[i].x << \"\\n\";\n            else cout << X[i].y << \"\\n\";\n        }\n    }\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}\n#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\n\n#pragma region Macros\nusing ll = long long;\n#define int ll\nusing pii = pair<int, int>;\nusing tiii = tuple<int, int, int>;\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\n#define IOS\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(0);\\\n    cout.tie(0);\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define SORT(name) sort(name.begin(), name.end())\n#define RSORT(name)\\\n    SORT(name);\\\n    reverse(all(name));\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\ntemplate<typename T1,typename T2> inline void chmin(T1 &a, T2 b){ if(a > b) a = b; }\ntemplate<typename T1,typename T2> inline void chmax(T1 &a, T2 b){ if(a < b) a = b; }\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst double DINF = std::numeric_limits<double>::infinity();\n#pragma endregion\n\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\n// 強連結成分分解\nclass SCC {\n    public:\n        friend class TwoSat;\n        SCC() {}\n        SCC(int v) { Init(v); }\n        void Init(int v) {\n            m_V = v;\n            m_G.assign(v, vector<int>());\n            m_Rg.assign(v, vector<int>());\n            m_Used.assign(v, false);\n            m_Cmp.assign(v, 0);\n        }\n        void AddEdge(int from, int to) {\n            m_G[from].push_back(to);\n            m_Rg[to].push_back(from);\n        }\n        int Scc() {\n            m_Used.assign(m_V, false);\n            m_Vs.clear();\n            for(int v = 0; v < m_V; ++v) {\n                if(!m_Used[v]) { Dfs(v); }\n            }\n            m_Used.assign(m_V, false);\n            int k = 0;\n            for(int i = int(m_Vs.size() - 1); i >= 0; --i) {\n                if(!m_Used[m_Vs[i]]) { Rdfs(m_Vs[i], k++); }\n            }\n            return k;\n        }\n    private:\n        void Dfs(int v) {\n            m_Used[v] = true;\n            for(int i = 0; i < int(m_G[v].size()); ++i) {\n                if(!m_Used[m_G[v][i]]) { Dfs(m_G[v][i]); }\n            }\n            m_Vs.push_back(v);\n        }\n        void Rdfs(int v, int k) {\n            m_Used[v] = true;\n            m_Cmp[v] = k;\n            for(int i = 0; i < int(m_Rg[v].size()); ++i) {\n                if(!m_Used[m_Rg[v][i]]) { Rdfs(m_Rg[v][i], k); }\n            }\n        }\n    private:\n        int m_V;                    // 頂点数\n        vector< vector<int> >  m_G; // グラフの隣接リスト表現\n        vector< vector<int> > m_Rg; // 辺の向きが逆のグラフ\n        vector<int> m_Vs;           // 帰りがけ順の並び\n        vector<bool> m_Used;        // すでに調べたか\n        vector<int> m_Cmp;          // 属する強連結成分のトポロジカル順序\n};\n\nclass TwoSat {\n    public:\n        friend class SCC;\n        TwoSat() {}\n        TwoSat(int v) { Init(v); }\n        void Init(int v) {\n            m_V = v;\n            m_Scc.Init(m_V * 2);\n        }\n        void AddClause(int i, bool f, int j, bool g) {\n            int i_n = (f) ? i : (i + m_V);\n            int i_i = (f) ? (i + m_V) : i;\n            int j_n = (g) ? j : (j + m_V);\n            int j_i = (g) ? (j + m_V) : j;\n            m_Scc.AddEdge(i_i, j_n);\n            m_Scc.AddEdge(j_i, i_n);\n        }\n        bool Satisfiable() {\n            m_Scc.Scc();\n            for(int i = 0; i < m_V; ++i) {\n                if(m_Scc.m_Cmp[i] == m_Scc.m_Cmp[i + m_V]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        vector<bool> Answer() {\n            vector<bool> ret(m_V, false);\n            for(int i = 0; i < m_V; ++i) {\n                if(m_Scc.m_Cmp[i] > m_Scc.m_Cmp[i + m_V]) {\n                    ret[i] = true;\n                }\n            }\n            return ret;\n        }\n    private:\n        int m_V;\n        SCC m_Scc;\n};\n\nconst int MOD = 1000000007;\nconst int MAX_N = 100010;\n\nsigned main() {\n    IOS;\n\n    int N, D;\n    cin >> N >> D;\n    V<> X(N), Y(N);\n    REP(i, N) {\n        cin >> X[i] >> Y[i];\n    }\n    TwoSat ts(N);\n    // X を選択 := true\n    // Y を選択 := false\n    REP(i, N) {\n        for(int j = i + 1; j < N; ++j) {\n            //if(i == j) { continue; }\n            if(abs(X[i] - X[j]) < D) {\n                // この 2 つは共存できない(両方 X はダメ)\n                // -> どちらか 1 つは必ず Y を選ばなければならない\n                ts.AddClause(i, false, j, false);\n            }\n            if(abs(X[i] - Y[j]) < D) {\n                ts.AddClause(i, false, j, true);\n            }\n            if(abs(Y[i] - X[j]) < D) {\n                ts.AddClause(i, true, j, false);\n            }\n            if(abs(Y[i] - Y[j]) < D) {\n                ts.AddClause(i, true, j, true);\n            }\n        }\n    }\n    if(ts.Satisfiable()) {\n        Yes(true);\n        auto ans = ts.Answer();\n        REP(i, N) {\n            if(ans[i]) {\n                print(X[i]);\n            }\n            else {\n                print(Y[i]);\n            }\n        }\n    }\n    else {\n        Yes(false);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n#define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\nbool ans[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans[i] = true;\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(ans[i] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 4400019;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\nbool ans[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans[i] = true;\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(ans[i] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#include <atcoder/all>\n#define For(i, a, b) for (int(i) = (int)(a); (i) < (int)(b); ++(i))\n#define rFor(i, a, b) for (int(i) = (int)(a)-1; (i) >= (int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\nusing namespace atcoder;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nT div_floor(T a, T b) {\n    if (b < 0) a *= -1, b *= -1;\n    return a >= 0 ? a / b : (a + 1) / b - 1;\n}\ntemplate <class T>\nT div_ceil(T a, T b) {\n    if (b < 0) a *= -1, b *= -1;\n    return a > 0 ? (a - 1) / b + 1 : a / b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint main() {\n    int n, d;\n    scanf(\"%d%d\", &n, &d);\n    int x[n][2];\n    rep(i, n) rep(j, 2) scanf(\"%d\", &x[i][j]);\n    two_sat ts(n);\n    rep(i, n) For(j, i + 1, n) {\n        rep(k, 2) rep(l, 2) if (abs(x[i][k] - x[j][l]) < d) {\n            ts.add_clause(i, k ^ 1, j, l ^ 1);\n        }\n    }\n    bool ok = ts.satisfiable();\n    puts(ok ? \"Yes\" : \"No\");\n    if (ok) {\n        auto v = ts.answer();\n        rep(i, n) printf(\"%d\\n\", x[i][v[i]]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param n `0 <= n`\n        // @return minimum non-negative `x` s.t. `n <= 2**x`\n        int ceil_pow2(int n)\n        {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n))\n                x++;\n            return x;\n        }\n        // @param n `1 <= n`\n        // @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\n        int bsf(unsigned int n)\n        {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param m `1 <= m`\n        // @return x mod m\n        constexpr long long safe_mod(long long x, long long m)\n        {\n            x %= m;\n            if (x < 0)\n                x += m;\n            return x;\n        }\n        // Fast moduler by barrett reduction\n        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n        // NOTE: reconsider after Ice Lake\n        struct barrett\n        {\n            unsigned int _m;\n            unsigned long long im;\n            // @param m `1 <= m`\n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            // @return m\n            unsigned int umod() const { return _m; }\n            // @param a `0 <= a < m`\n            // @param b `0 <= b < m`\n            // @return `a * b % m`\n            unsigned int mul(unsigned int a, unsigned int b) const\n            {\n                // [1] m = 1\n                // a = b = im = 0, so okay\n                // [2] m >= 2\n                // im = ceil(2^64 / m)\n                // -> im * m = 2^64 + r (0 <= r < m)\n                // let z = a*b = c*m + d (0 <= c, d < m)\n                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n                // ((ab * im) >> 64) == c or c + 1\n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v)\n                    v += _m;\n                return v;\n            }\n        };\n        // @param n `0 <= n`\n        // @param m `1 <= m`\n        // @return `(x ** n) % m`\n        constexpr long long pow_mod_constexpr(long long x, long long n, int m)\n        {\n            if (m == 1)\n                return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n)\n            {\n                if (n & 1)\n                    r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        // Reference:\n        // M. Forisek and J. Jancina,\n        // Fast Primality Testing for Integers That Fit into a Machine Word\n        // @param n `0 <= n`\n        constexpr bool is_prime_constexpr(int n)\n        {\n            if (n <= 1)\n                return false;\n            if (n == 2 || n == 7 || n == 61)\n                return true;\n            if (n % 2 == 0)\n                return false;\n            long long d = n - 1;\n            while (d % 2 == 0)\n                d /= 2;\n            for (long long a : {2, 7, 61})\n            {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1)\n                {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n>\n        constexpr bool is_prime = is_prime_constexpr(n);\n        // @param b `1 <= b`\n        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)\n        {\n            a = safe_mod(a, b);\n            if (a == 0)\n                return {b, 0};\n            // Contracts:\n            // [1] s - m0 * a = 0 (mod b)\n            // [2] t - m1 * a = 0 (mod b)\n            // [3] s * |m1| + t * |m0| <= b\n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            while (t)\n            {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b\n                // [3]:\n                // (s - t * u) * |m1| + t * |m0 - m1 * u|\n                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n                // = s * |m1| + t * |m0| <= b\n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            // by [3]: |m0| <= b/g\n            // by g != b: |m0| < b/g\n            if (m0 < 0)\n                m0 += b / s;\n            return {s, m0};\n        }\n        // Compile time primitive root\n        // @param m must be prime\n        // @return primitive root (and minimum in now)\n        constexpr int primitive_root_constexpr(int m)\n        {\n            if (m == 2)\n                return 1;\n            if (m == 167772161)\n                return 3;\n            if (m == 469762049)\n                return 3;\n            if (m == 754974721)\n                return 11;\n            if (m == 998244353)\n                return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0)\n                x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    divs[cnt++] = i;\n                    while (x % i == 0)\n                    {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1)\n            {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++)\n            {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++)\n                {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    return g;\n            }\n        }\n        template <int m>\n        constexpr int primitive_root = primitive_root_constexpr(m);\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class T>\n        struct simple_queue\n        {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T &t) { payload.push_back(t); }\n            T &front() { return payload[pos]; }\n            void clear()\n            {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class E>\n        struct csr\n        {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>> &edges)\n                : start(n + 1), elist(edges.size())\n            {\n                for (auto e : edges)\n                {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++)\n                {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges)\n                {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        // Reference:\n        // R. Tarjan,\n        // Depth-First Search and Linear Graph Algorithms\n        struct scc_graph\n        {\n        public:\n            scc_graph(int n) : _n(n) {}\n            int num_vertices() { return _n; }\n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            // @return pair of (# of scc, scc id)\n            std::pair<int, std::vector<int>> scc_ids()\n            {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++)\n                    {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1)\n                        {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        }\n                        else\n                        {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v])\n                    {\n                        while (true)\n                        {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v)\n                                break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++)\n                {\n                    if (ord[i] == -1)\n                        dfs(dfs, i);\n                }\n                for (auto &x : ids)\n                {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            std::vector<std::vector<int>> scc()\n            {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second)\n                    counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++)\n                {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++)\n                {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n\n        private:\n            int _n;\n            struct edge\n            {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder\n{\n    namespace internal\n    {\n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                          std::is_same<T, __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                          std::is_same<T, unsigned __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using make_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value,\n                                      __uint128_t,\n                                      unsigned __int128>;\n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                          is_signed_int128<T>::value ||\n                                                          is_unsigned_int128<T>::value,\n                                                      std::true_type,\n                                                      std::false_type>::type;\n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n                                                            is_signed_int128<T>::value,\n                                                        std::true_type,\n                                                        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<(is_integral<T>::value &&\n                                       std::is_unsigned<T>::value) ||\n                                          is_unsigned_int128<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<\n            is_signed_int128<T>::value,\n            make_unsigned_int128<T>,\n            typename std::conditional<std::is_signed<T>::value,\n                                      std::make_unsigned<T>,\n                                      std::common_type<T>>::type>::type;\n#else\n        template <class T>\n        using is_integral = typename std::is_integral<T>;\n        template <class T>\n        using is_signed_int =\n            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<is_integral<T>::value &&\n                                          std::is_unsigned<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                                      std::make_unsigned<T>,\n                                                      std::common_type<T>>::type;\n#endif\n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        template <class T>\n        using to_unsigned_t = typename to_unsigned<T>::type;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        struct modint_base\n        {\n        };\n        struct static_modint_base : modint_base\n        {\n        };\n        template <class T>\n        using is_modint = std::is_base_of<modint_base, T>;\n        template <class T>\n        using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n    } // namespace internal\n    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>\n    struct static_modint : internal::static_modint_base\n    {\n        using mint = static_modint;\n\n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0)\n                x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v -= rhs._v;\n            if (_v >= umod())\n                _v += umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            if (prime)\n            {\n                assert(_v);\n                return pow(umod() - 2);\n            }\n            else\n            {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    template <int id>\n    struct dynamic_modint : internal::modint_base\n    {\n        using mint = dynamic_modint;\n\n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m)\n        {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0)\n                x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v += mod() - rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id>\n    internal::barrett dynamic_modint<id>::bt = 998244353;\n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    namespace internal\n    {\n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        template <class>\n        struct is_dynamic_modint : public std::false_type\n        {\n        };\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type\n        {\n        };\n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_e[30]; // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly_inv(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_ie[30]; // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            for (int ph = h; ph >= 1; ph--)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                            (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                            inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n    } // namespace internal\n    template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        if (std::min(n, m) <= 60)\n        {\n            if (n < m)\n            {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++)\n        {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++)\n            a[i] *= iz;\n        return a;\n    }\n    template <unsigned int mod = 998244353,\n              class T,\n              std::enable_if_t<internal::is_integral<T>::value> * = nullptr>\n    std::vector<T> convolution(const std::vector<T> &a, const std::vector<T> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++)\n        {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++)\n        {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    std::vector<long long> convolution_ll(const std::vector<long long> &a,\n                                          const std::vector<long long> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        static constexpr unsigned long long MOD1 = 754974721; // 2^24\n        static constexpr unsigned long long MOD2 = 167772161; // 2^25\n        static constexpr unsigned long long MOD3 = 469762049; // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        static constexpr unsigned long long i1 =\n            internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n            internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n            internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            // B = 2^63, -B <= x, r(real value) < B\n            // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n            // r = c1[i] (mod MOD1)\n            // focus on MOD1\n            // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n            // r = x,\n            //     x - M' + (0 or 2B),\n            //     x - 2M' + (0, 2B or 4B),\n            //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n            // (r - x) = 0, (0)\n            //           - M' + (0 or 2B), (1)\n            //           -2M' + (0 or 2B or 4B), (2)\n            //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n            // we checked that\n            //   ((1) mod MOD1) mod 5 = 2\n            //   ((2) mod MOD1) mod 5 = 3\n            //   ((3) mod MOD1) mod 5 = 4\n            long long diff =\n                c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0)\n                diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        return c;\n    }\n} // namespace atcoder\n#endif // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Implement (union by size) + (path compression)\n    // Reference:\n    // Zvi Galil and Giuseppe F. Italiano,\n    // Data structures and algorithms for disjoint set union problems\n    struct dsu\n    {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        int merge(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y)\n                return x;\n            if (-parent_or_size[x] < -parent_or_size[y])\n                std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        bool same(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        int leader(int a)\n        {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0)\n                return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        int size(int a)\n        {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        std::vector<std::vector<int>> groups()\n        {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++)\n            {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                std::remove_if(result.begin(), result.end(),\n                               [&](const std::vector<int> &v) { return v.empty(); }),\n                result.end());\n            return result;\n        }\n\n    private:\n        int _n;\n        // root node: -1 * component size\n        // otherwise: parent\n        std::vector<int> parent_or_size;\n    };\n} // namespace atcoder\n#endif // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference: https://en.wikipedia.org/wiki/Fenwick_tree\n    template <class T>\n    struct fenwick_tree\n    {\n        using U = internal::to_unsigned_t<T>;\n\n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        void add(int p, T x)\n        {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n)\n            {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        T sum(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n\n    private:\n        int _n;\n        std::vector<U> data;\n        U sum(int r)\n        {\n            U s = 0;\n            while (r > 0)\n            {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder\n{\n    template <class S,\n              S (*op)(S, S),\n              S (*e)(),\n              class F,\n              S (*mapping)(F, S),\n              F (*composition)(F, F),\n              F (*id)()>\n    struct lazy_segtree\n    {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            return d[p];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push(r >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        void apply(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        void apply(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push((r - 1) >> i);\n            }\n            {\n                int l2 = l, r2 = r;\n                while (l < r)\n                {\n                    if (l & 1)\n                        all_apply(l++, f);\n                    if (r & 1)\n                        all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    update(l >> i);\n                if (((r >> i) << i) != r)\n                    update((r - 1) >> i);\n            }\n        }\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                push(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                push((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f)\n        {\n            d[k] = mapping(f, d[k]);\n            if (k < size)\n                lz[k] = composition(f, lz[k]);\n        }\n        void push(int k)\n        {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder\n{\n    long long pow_mod(long long x, long long n, int m)\n    {\n        assert(0 <= n && 1 <= m);\n        if (m == 1)\n            return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n)\n        {\n            if (n & 1)\n                r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    long long inv_mod(long long x, long long m)\n    {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    // (rem, mod)\n    std::pair<long long, long long> crt(const std::vector<long long> &r,\n                                        const std::vector<long long> &m)\n    {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        // Contracts: 0 <= r0 < m0\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++)\n        {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1)\n            {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0)\n            {\n                if (r0 % m1 != r1)\n                    return {0, 0};\n                continue;\n            }\n            // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n            // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n            // r2 % m0 = r0\n            // r2 % m1 = r1\n            // -> (r0 + x*m0) % m1 = r1\n            // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n            // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n            // im = inv(u0) (mod u1) (0 <= im < u1)\n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            long long u1 = (m1 / g);\n            // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n            if ((r1 - r0) % g)\n                return {0, 0};\n            // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n            long long x = (r1 - r0) / g % u1 * im % u1;\n            // |r0| + |m0 * x|\n            // < m0 + m0 * (u1 - 1)\n            // = m0 + m0 * m1 / g - m0\n            // = lcm(m0, m1)\n            r0 += x * m0;\n            m0 *= u1; // -> lcm(m0, m1)\n            if (r0 < 0)\n                r0 += m0;\n        }\n        return {r0, m0};\n    }\n    long long floor_sum(long long n, long long m, long long a, long long b)\n    {\n        long long ans = 0;\n        if (a >= m)\n        {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m)\n        {\n            ans += n * (b / m);\n            b %= m;\n        }\n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0)\n            return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n} // namespace atcoder\n#endif // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap>\n    struct mf_graph\n    {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++)\n            {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto &_e = g[pos[i].first][pos[i].second];\n            auto &_re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        Cap flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty())\n                {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v])\n                    {\n                        if (e.cap == 0 || level[e.to] >= 0)\n                            continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t)\n                            return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s)\n                    return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int &i = iter[v]; i < int(g[v].size()); i++)\n                {\n                    _edge &e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0)\n                        continue;\n                    Cap d =\n                        self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0)\n                        continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up)\n                        break;\n                }\n                return res;\n            };\n            Cap flow = 0;\n            while (flow < flow_limit)\n            {\n                bfs();\n                if (level[t] == -1)\n                    break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit)\n                {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f)\n                        break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        std::vector<bool> min_cut(int s)\n        {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty())\n            {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p])\n                {\n                    if (e.cap && !visited[e.to])\n                    {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap, class Cost>\n    struct mcf_graph\n    {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap, Cost cost)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first,\n                _e.to,\n                _e.cap + _re.cap,\n                _re.cap,\n                _e.cost,\n            };\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++)\n            {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        std::pair<Cap, Cost> flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit)\n        {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t)\n        {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            // variants (C = maxcost):\n            // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n            // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q\n                {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty())\n                {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v])\n                        continue;\n                    vis[v] = true;\n                    if (v == t)\n                        break;\n                    // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                    // dist[v] >= 0 (all reduced cost are positive)\n                    // dist[v] <= (n-1)C\n                    for (int i = 0; i < int(g[v].size()); i++)\n                    {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap)\n                            continue;\n                        // |-dual[e.to] + dual[v]| <= (n-1)C\n                        // cost <= C - -(n-1)C + 0 = nC\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost)\n                        {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t])\n                {\n                    return false;\n                }\n                for (int v = 0; v < _n; v++)\n                {\n                    if (!vis[v])\n                        continue;\n                    // dual[v] = dual[v] - dist[t] + dist[v]\n                    //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                    //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                    //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit)\n            {\n                if (!dual_ref())\n                    break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v])\n                {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v])\n                {\n                    auto &e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d)\n                {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    struct scc_graph\n    {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        void add_edge(int from, int to)\n        {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n    private:\n        internal::scc_graph internal;\n    };\n} // namespace atcoder\n#endif // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f)\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f)\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n} // namespace atcoder\n#endif // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        std::vector<int> sa_naive(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r)\n                    return false;\n                while (l < n && r < n)\n                {\n                    if (s[l] != s[r])\n                        return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        std::vector<int> sa_doubling(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2)\n            {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y])\n                        return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        // SA-IS, linear-time suffix array construction\n        // Reference:\n        // G. Nong, S. Zhang, and W. H. Chan,\n        // Two Efficient Algorithms for Linear Time Suffix Array Construction\n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int> &s, int upper)\n        {\n            int n = int(s.size());\n            if (n == 0)\n                return {};\n            if (n == 1)\n                return {0};\n            if (n == 2)\n            {\n                if (s[0] < s[1])\n                {\n                    return {0, 1};\n                }\n                else\n                {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE)\n            {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING)\n            {\n                return sa_doubling(s);\n            }\n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--)\n            {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++)\n            {\n                if (!ls[i])\n                {\n                    sum_s[s[i]]++;\n                }\n                else\n                {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++)\n            {\n                sum_s[i] += sum_l[i];\n                if (i < upper)\n                    sum_l[i + 1] += sum_s[i];\n            }\n            auto induce = [&](const std::vector<int> &lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms)\n                {\n                    if (d == n)\n                        continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1])\n                    {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1])\n                    {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms.push_back(i);\n                }\n            }\n            induce(lms);\n            if (m)\n            {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa)\n                {\n                    if (lms_map[v] != -1)\n                        sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++)\n                {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r)\n                    {\n                        same = false;\n                    }\n                    else\n                    {\n                        while (l < end_l)\n                        {\n                            if (s[l] != s[r])\n                            {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r])\n                            same = false;\n                    }\n                    if (!same)\n                        rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                auto rec_sa =\n                    sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                for (int i = 0; i < m; i++)\n                {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n    } // namespace internal\n    std::vector<int> suffix_array(const std::vector<int> &s, int upper)\n    {\n        assert(0 <= upper);\n        for (int d : s)\n        {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    template <class T>\n    std::vector<int> suffix_array(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (i && s[idx[i - 1]] != s[idx[i]])\n                now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    std::vector<int> suffix_array(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    // Reference:\n    // T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    // Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    // Applications\n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T> &s,\n                               const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++)\n        {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (h > 0)\n                h--;\n            if (rnk[i] == 0)\n                continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++)\n            {\n                if (s[j + h] != s[i + h])\n                    break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    std::vector<int> lcp_array(const std::string &s, const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    // Reference:\n    // D. Gusfield,\n    // Algorithms on Strings, Trees, and Sequences: Computer Science and\n    // Computational Biology\n    template <class T>\n    std::vector<int> z_algorithm(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        if (n == 0)\n            return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++)\n        {\n            int &k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k])\n                k++;\n            if (j + z[j] < i + z[i])\n                j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    std::vector<int> z_algorithm(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n} // namespace atcoder\n#endif // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference:\n    // B. Aspvall, M. Plass, and R. Tarjan,\n    // A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n    // Formulas\n    struct two_sat\n    {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        void add_clause(int i, bool f, int j, bool g)\n        {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable()\n        {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++)\n            {\n                if (id[2 * i] == id[2 * i + 1])\n                    return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n\n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n} // namespace atcoder\n#endif // ATCODER_TWOSAT_HPP\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define endl '\\n'\n#define loop(i, n) for (unsigned int i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define modd 1000000007ll\n//#define modd 998244353ll\n#define flagcount(bit) __builtin_popcount(bit)\n#define flag(x) (1ll << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1ll << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define idx_lower(v, x) (distance(v.begin(), low2way(v, x)))  //配列vでx未満の要素数を返す\n#define idx_upper(v, x) (distance(v.begin(), high2way(v, x))) //配列vでx以下の要素数を返す\n#define idx_lower2(v, x) (v.size() - idx_lower(v, x))         //配列vでx以上の要素数を返す\n#define idx_upper2(v, x) (v.size() - idx_upper(v, x))         //配列vでxより大きい要素の数を返す\n#define putout(a) cout << a << '\\n'\n#define Sum(v) accumulate(all(v), 0ll)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return -1;\n}\ntemplate <typename T>\nstring make_string(T N)\n{\n    string ret;\n    T now = N;\n    while (now > 0)\n    {\n        T x = now % 10;\n        ret += (char)('0' + x);\n        now /= 10;\n    }\n    reverse(all(ret));\n    return ret;\n}\ntemplate <typename T>\nT gcd(T a, T b)\n{\n    if (a % b == 0)\n    {\n        return (b);\n    }\n    else\n    {\n        return (gcd(b, a % b));\n    }\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nbool chmax(T &a, const T &b)\n{\n    if (a < b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nbool chmin(T &a, const T &b)\n{\n    if (a > b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//2次元配列の宣言\n//vector<vector<ll>> field(h, vector<ll>(w));\nclass FastIO\n{\n    static const int rdata_sz = (1 << 25), wdata_sz = (1 << 25);\n    char rdata[rdata_sz], wdata[wdata_sz], *rb, *wb;\n    char tmp_s[20];\n\npublic:\n    FastIO()\n    {\n        fread(rdata, 1, rdata_sz, stdin);\n        rb = rdata;\n        wb = wdata;\n    }\n    ~FastIO()\n    {\n        fwrite(wdata, 1, wb - wdata, stdout);\n    }\n\n    template <typename T>\n    inline void read(T &x)\n    {\n        bool neg = false;\n        x = 0;\n        while ((*rb < '0' || *rb > '9') && *rb != '-')\n            ++rb;\n        if (*rb == '-')\n        {\n            neg = true;\n            ++rb;\n        }\n        while ('0' <= *rb && *rb <= '9')\n        {\n            x = 10 * x + (*rb - '0');\n            ++rb;\n        }\n        if (neg)\n            x = -x;\n    }\n\n#define pc(x) *(wb++) = x\n    template <typename T>\n    inline void write(T x)\n    {\n        if (x == 0)\n        {\n            pc('0');\n            pc('\\n');\n            return;\n        }\n        if (x < 0)\n        {\n            pc('-');\n            x = -x;\n        }\n        char *t = tmp_s;\n        while (x)\n        {\n            T y = x / 10;\n            *(t++) = (x - y * 10) + '0';\n            x = y;\n        }\n        while (t != tmp_s)\n            pc(*(--t));\n        pc('\\n');\n    }\n#undef pc\n};\nint main()\n{\n    FastIO io;\n    unsigned int N, D;\n    io.read(N);\n    io.read(D);\n    vector<int> X(N), Y(N);\n    loop(i, N)\n    {\n        io.read(X[i]);\n        io.read(Y[i]);\n    }\n    two_sat ts(N);\n    loop(i, N)\n    {\n        Loop(j, i + 1, N)\n        {\n            if (abs(X[i] - X[j]) < D)\n                ts.add_clause(i, 0, j, 0);\n            if (abs(X[i] - Y[j]) < D)\n                ts.add_clause(i, 0, j, 1);\n            if (abs(Y[i] - X[j]) < D)\n                ts.add_clause(i, 1, j, 0);\n            if (abs(Y[i] - Y[j]) < D)\n                ts.add_clause(i, 1, j, 1);\n        }\n    }\n    if (!ts.satisfiable())\n    {\n        putout(\"No\");\n        return 0;\n    }\n    vector<bool> ans = ts.answer();\n    putout(\"Yes\");\n    loop(i, N)\n    {\n        if (ans[i])\n            io.write(X[i]);\n        else\n            io.write(Y[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define USE_FREAD\n#ifdef USE_FREAD\nconstexpr size_t MAX_SIZE = 22020;\nchar buf[MAX_SIZE];\nstruct Input {\n\tsize_t i;\n\tInput() {\n\t\ti = 0;\n\t\tfread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\treturn buf[i++];\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n/*\n * 2-sat\n * \n * 変数 x0,x1,....,xN-1に対して\n * (xi = f) V (xj = g)\n * をいうクロージャを足し、すべて満たす変数の割り当てがあるかどうかを解く \n */\n\n/*\n SCC:強連結成分分解\n 有向グラフにおいて「お互いに行き来できる ⟺ 同じグループ」を満たすように頂点をグループ分け\n */\nclass SCC {\npublic:\n    typedef int TYPE;\n    TYPE V;\nprivate:    \n    vector<vector<TYPE>> G;             // 入力グラフ\n    vector<vector<TYPE>> rG;            // 入力の逆辺グラフ\n    vector<vector<TYPE>> group_G;       // 強連結成分同士の有向辺グラフ\n    vector<vector<TYPE>> group_rG;      // 強連結成分同士の無向辺グラフ\n    vector<vector<TYPE>> each_group_G;  // 各強連結成分内のグラフ（トポロジカル順）\n    vector<TYPE> group;                 // 各頂点の強連結成分グループ番号\n    vector<TYPE> List;\npublic:    \n    vector<int> visited;\n    int group_num;\n    \n    SCC(TYPE V) :V(V),group_num(0) {\n        G.resize(V); rG.resize(V);\n    }\n    \n    void init(TYPE V){\n        G.clear(); G.resize(V);\n        rG.clear(); rG.resize(V);\n    }\n    \n    void add_edge(TYPE u, TYPE v) {\n        G[u].emplace_back(v); rG[v].emplace_back(u);\n    }\n    \n    void dfs1(TYPE u) {\n        visited[u] = 1;\n        for (TYPE& next : G[u]){ if (visited[next] != 1) dfs1(next); }\n        List.emplace_back(u);\n    }\n    \n    void dfs2(TYPE u,TYPE group_num) {\n        visited[u] = 1; group[u] = group_num;\n        each_group_G.back().emplace_back(u);\n        for (TYPE& next : rG[u]){ if (visited[next] != 1) dfs2(next, group_num); }\n    }\n    \n    void scc() {\n        group.clear(); group.assign(V, -1);\n        visited.clear(); visited.assign(V, 0);\n        for (int i = 0; i < V;i++){ if (visited[i] != 1) dfs1(i); }\n        \n        reverse(List.begin(), List.end());\n        \n        visited.clear(); visited.assign(V, 0);\n        group_num = 0;\n        for (TYPE& v : List) { \n            if (visited[v] != 1){\n                each_group_G.emplace_back(vector<TYPE>());\n                dfs2(v, group_num++); \n            }\n        }\n\n        make_group_graph();\n    }\n    \n    void make_group_graph(){\n        group_G.clear(); group_G.resize(group_num);\n        group_rG.clear(); group_rG.resize(group_num);\n        for(int u = 0; u < V;u++){\n            for(TYPE& v: G[u]){\n                if(!same(u,v)){\n                    group_G[group[u]].emplace_back(group[v]);\n                    group_rG[group[v]].emplace_back(group[u]);\n                }\n            }\n        }\n    }\n    \n    TYPE get_group(TYPE n){ return group[n]; }\n    bool same(TYPE u,TYPE v) {\n        return group[u] == group[v];\n    }\n    \n    vector<vector<TYPE>>& get_G() { return G; }\n    vector<vector<TYPE>>& get_rG() { return rG; }\n    vector<vector<TYPE>>& get_group_G() { return group_G; }\n    vector<vector<TYPE>>& get_group_rG() { return group_rG; }\n    vector<vector<TYPE>>& get_each_group_G() { return each_group_G; }\n};\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    // (xi = f) V (xj = G)\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        scc.scc();\n        for (int i = 0; i < _n; i++) {\n            if(scc.get_group(2*i) == scc.get_group(2*i+1)) return false;\n            _answer[i] = scc.get_group(2*i) < scc.get_group(2*i+1);\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    SCC scc;\n};\ntemplate<class Type>\nType solve(Type res = Type()){\n    int N,D; cin >> N >> D;\n    vector<ll> X(N),Y(N);\n    for(int i = 0; i < N;i++) cin >> X[i] >> Y[i];\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(N);\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(abs(X[i] - X[j]) < D){\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(Y[i]-Y[j]) < D){\n                ts.add_clause(i,true,j,true);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for(int i = 0; i < N;i++){\n        if(answer[i]){\n            cout << X[i] << endl;\n        }else{\n            cout << Y[i] << endl;\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    solve<ll>(0);\n    // cout << fixed << setprecision(12) << solve<ll>() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Create your own template by modifying this file!\n#include <string>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <cassert>\n#include <deque>\n#include <stack>\n#include <functional>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x;  }\nvoid _R(int &x) { scanf(\"%d\", &x);  }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x);  }\nvoid _R(double &x) { scanf(\"%lf\", &x);  }\nvoid _R(char &x) { scanf(\" %c\", &x);  }\nvoid _R(char *x) { scanf(\"%s\", x);  }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...);  }\ntemplate<class T> void _W(const T &x) { cout << x;  }\nvoid _W(const int &x) { printf(\"%d\", x);  }\nvoid _W(const int64_t &x) { printf(\"%lld\", x);  }\nvoid _W(const double &x) { printf(\"%.16f\", x);  }\nvoid _W(const char &x) { putchar(x);  }\nvoid _W(const char *x) { printf(\"%s\", x);  }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' ');  }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...);  }\n#ifdef DEBUG\n #define debug(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define debug(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<20;\ntemplate<class T> void MIN(T& a, const T& b) { a = min(a, b); }\ntemplate<class T> void MAX(T& a, const T& b) { a = max(a, b); }\n\n#include <atcoder/all>\n#define MULTITEST 0\n\nusing namespace atcoder;\n\nvoid solve() {\n    int N, D;\n    R(N, D);\n    VI X(N), Y(N);\n    REP(i, N) {\n        R(X[i], Y[i]);\n    }\n    two_sat ts(N);\n    REP(i, N) {\n        REP(j, i) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if (ts.satisfiable()) {\n        puts(\"Yes\");\n        auto answer = ts.answer();\n        REP(i, N) {\n            W(answer[i] ? X[i] : Y[i]);\n        }\n    } else {\n        puts(\"No\");\n    }\n}\n\nint main() {\n#if MULTITEST    \n    CASET{\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define Rep(n) for (ll _ = 0; _ < (ll)(n); _++)\n\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nll min(int a,ll b){return min((ll)a,b);} ll min(ll a,int b){return min(a,(ll)b);}\n\n#define PRINT_VECTOR_MAX 100\ntemplate <class S> void print(vector<S> &v){for(ll i=0; i<(ll)min(v.size(),PRINT_VECTOR_MAX); i++){cerr << v[i] << ' ';}cerr << endl;}\ntemplate <class S> void print(vector<vector<S>> &v) {for (ll i = 0; i < (ll)min(v.size(),PRINT_VECTOR_MAX); i++) {for (ll j = 0; j < (ll)min(v[i].size(),PRINT_VECTOR_MAX); j++) {cerr << v[i][j] << ' ';}cerr << endl;}}\n\nvoid Main();\nint main(){\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn 0;\n}\n\nvoid Main(){\n\tint n, d; cin >> n >> d;\n\tvector<int> x(n), y(n);\n\trep(i,n) cin >> x[i] >> y[i];\n\ttwo_sat ts(n); // use x = true\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i == j) continue;\n\t\t\tif(abs(x[i] - x[j]) < d){\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif(abs(x[i] - y[j]) < d){\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif(abs(y[i] - x[j]) < d){\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif(abs(y[i] - y[j]) < d){\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tif(ts.satisfiable()){\n\t\tcout << \"Yes\\n\";\n\t\tauto ans = ts.answer();\n\t\trep(i,n){\n\t\t\tif(ans[i]) cout << x[i] << endl;\n\t\t\telse cout << y[i] << endl;\n\t\t}\n\t}else{\n\t\tcout << \"No\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long int\n#define MOD 1000000007\n#define P pair<ll,ll>\n#define INF 1000000000000000000\n\nusing namespace atcoder;\nusing namespace std;\n\nint main(void){\n  ll n, d;\n  cin >> n >> d;\n  \n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n  }\n  two_sat ts(2*n);\n  \n  for (int i = 0; i < n; i++){\n    ts.add_clause(2*i, true, 2*i+1, true);\n    ts.add_clause(2*i, false, 2*i+1, false);\n  }\n\n  for (int i = 0; i < n; i++){\n    for (int j = i+1; j < n; j++){\n      if (abs(x[i]-x[j]) < d){\n        ts.add_clause(2*i, false, 2*j, false);\n      }\n      if (abs(x[i]-y[j]) < d){\n        ts.add_clause(2*i, false, 2*j+1, false);\n      }\n      if (abs(y[i]-x[j]) < d){\n        ts.add_clause(2*i+1, false, 2*j, false);\n      }\n      if (abs(y[i]-y[j]) < d){\n        ts.add_clause(2*i+1, false, 2*j+1, false);\n      }\n    }\n  }\n\n  bool ok = ts.satisfiable();\n\n  if(ok){\n    cout << \"Yes\" << endl;\n    \n    vector<bool> wariate = ts.answer();\n    for (int i = 0; i < n; i++){\n      if (wariate[2*i]){\n        cout << x[i] << endl;\n      }\n      else\n        cout << y[i] << endl;\n    }\n  }\n  else\n    cout << \"No\" << endl;\n    \n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <boost/hana/functional/fix.hpp>\n\ntemplate <typename T, typename = void>\nstruct is_iterable : std::false_type {};\ntemplate <typename T>\nstruct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),\n                                  decltype(std::end(std::declval<T>()))>>\n    : std::true_type {};\n\ntemplate <typename T, typename = void>\nstruct is_pair : std::false_type {};\ntemplate <typename T>\nstruct is_pair<T, std::void_t<decltype(std::declval<T>().first),\n                              decltype(std::declval<T>().second)>>\n    : std::true_type {};\n\ntemplate <typename T>\nvoid debug(const T& v) {\n  if constexpr (is_pair<T>::value) {\n    std::cerr << \"{\";\n    debug(v.first);\n    std::cerr << \", \";\n    debug(v.second);\n    std::cerr << \"}\";\n  } else if constexpr (is_iterable<T>::value &&\n                       !std::is_same<T, std::string>::value) {\n    std::cerr << \"{\";\n    for (auto it = std::begin(v); it != std::end(v); ++it) {\n      if (it != std::begin(v)) std::cerr << \", \";\n      debug(*it);\n    }\n    std::cerr << \"}\";\n  } else {\n    std::cerr << v;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid debug(const T& value, const Ts&... args) {\n  debug(value);\n  std::cerr << \", \";\n  debug(args...);\n}\n#if DEBUG\n#define dbg(...)                        \\\n  do {                                  \\\n    cerr << #__VA_ARGS__ << \": \";       \\\n    debug(__VA_ARGS__);                 \\\n    cerr << \" (L\" << __LINE__ << \")\\n\"; \\\n  } while (0)\n#else\n#define dbg(...)\n#endif\n\nvoid read_from_cin() {}\ntemplate <typename T, typename... Ts>\nvoid read_from_cin(T& value, Ts&... args) {\n  std::cin >> value;\n  read_from_cin(args...);\n}\n#define rd(type, ...) \\\n  type __VA_ARGS__;   \\\n  read_from_cin(__VA_ARGS__);\n#define ints(...) rd(int, __VA_ARGS__);\n#define strings(...) rd(string, __VA_ARGS__);\n\ntemplate <typename T>\nvoid write_to_cout(const T& value) {\n  if constexpr (std::is_same<T, bool>::value) {\n    std::cout << (value ? \"Yes\" : \"No\");\n  } else {\n    std::cout << value;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid write_to_cout(const T& value, const Ts&... args) {\n  write_to_cout(value);\n  std::cout << ' ';\n  write_to_cout(args...);\n}\n#define wt(...)                 \\\n  do {                          \\\n    write_to_cout(__VA_ARGS__); \\\n    cout << '\\n';               \\\n  } while (0)\n\n#define all(x) (x).begin(), (x).end()\n\n#define rep_dispatch(_1, _2, _3, name, ...) name\n\n#define rep3(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep1(n) rep2(_loop_variable_, n)\n#define rep(...) rep_dispatch(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)\n\n#define rrep3(i, a, b) for (int i = (int)(b)-1; i >= a; --i)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep1(n) rrep2(_loop_variable_, n)\n#define rrep(...) rep_dispatch(__VA_ARGS__, rrep3, rrep2, rrep1)(__VA_ARGS__)\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n  for (T& vi : v) is >> vi;\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T, typename U>\nbool chmax(T& a, U b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nbool chmin(T& a, U b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nT max(T a, U b) {\n  return a > b ? a : b;\n}\n\ntemplate <typename T, typename U>\nT mix(T a, U b) {\n  return a < b ? a : b;\n}\n\ntemplate <typename T>\nint sz(const T& v) {\n  return v.size();\n}\n\ntemplate <typename T>\nint popcount(T i) {\n  return std::bitset<std::numeric_limits<T>::digits>(i).count();\n}\n\nusing i64 = std::int64_t;\nusing i32 = std::int32_t;\n\ntemplate <typename T>\nusing low_priority_queue =\n    std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <typename T>\nusing V = std::vector<T>;\ntemplate <typename T>\nusing VV = V<V<T>>;\n\nvoid Main();\n\nint main() {\n  Main();\n  return 0;\n}\n\nconst auto& Fix = boost::hana::fix;\n\nusing namespace std;\n\n#define int i64\n\n#pragma once\n\ntemplate <typename T>\nstruct Edge {\n  int from, to;\n  T weight;\n};\n\ntemplate <typename T>\nclass Graph {\n public:\n  Graph(int n) : edges_(n) {}\n  void AddEdge(int from, int to, T weight = T()) {\n    edges_[from].push_back({from, to, weight});\n  }\n  const std::vector<Edge<T>>& Edges(int from) const { return edges_[from]; }\n  int NumVertices() const { return edges_.size(); }\n\n private:\n  std::vector<std::vector<Edge<T>>> edges_;\n};\n\ntemplate <typename T>\nstd::vector<std::vector<int>> StronglyConnectedComponents(\n    const Graph<T>& graph) {\n  int n = graph.NumVertices();\n  std::vector<int> nodes;\n  std::vector<bool> visited(n);\n  std::function<void(int)> dfs = [&](int u) {\n    visited[u] = true;\n    for (const Edge<T>& e : graph.Edges(u)) {\n      if (!visited[e.to]) {\n        dfs(e.to);\n      }\n    }\n    nodes.push_back(u);\n  };\n  for (int u = 0; u < n; ++u) {\n    if (!visited[u]) dfs(u);\n  }\n  std::vector<std::vector<int>> rgraph(n);\n  for (int u = 0; u < n; ++u) {\n    for (const Edge<T> e : graph.Edges(u)) {\n      rgraph[e.to].push_back(u);\n    }\n  }\n  std::vector<bool> rvisited(n);\n  std::vector<std::vector<int>> sccs;\n  std::function<void(std::vector<int>&, int)> rdfs = [&](std::vector<int>& scc,\n                                                         int u) {\n    rvisited[u] = true;\n    scc.push_back(u);\n    for (int v : rgraph[u]) {\n      if (!rvisited[v]) {\n        rdfs(scc, v);\n      }\n    }\n  };\n  for (int i = n - 1; i >= 0; --i) {\n    int u = nodes[i];\n    if (!rvisited[u]) {\n      std::vector<int> scc;\n      rdfs(scc, u);\n      sccs.push_back(scc);\n    }\n  }\n  return sccs;\n}\n\nvoid Main() {\n  ints(n, d);\n  V<int> x(n), y(n);\n  rep(i, n) cin >> x[i] >> y[i];\n\n  Graph<int> g(n * 2);\n\n  rep(i, n - 1) rep(j, i + 1, n) {\n    bool X = abs(x[i] - x[j]) < d;\n    bool Y = abs(y[i] - y[j]) < d;\n    if (X) {\n      // !i v !j = (i -> !j) ^ (j -> !i)\n      g.AddEdge(i, n + j);\n      g.AddEdge(j, n + i);\n    }\n    if (Y) {\n      // i v j = (!i -> j) ^ (!j -> i)\n      g.AddEdge(n + i, j);\n      g.AddEdge(n + j, i);\n    }\n  }\n\n  VV<int> scc = StronglyConnectedComponents(g);\n  V<int> t(n), f(n);\n  rep(i, scc.size()) for (int j : scc[i]) {\n    if (j < n) {\n      t[j] = i;\n    } else {\n      f[j - n] = i;\n    }\n  }\n  bool ok = true;\n  V<int> v;\n  rep(i, n) {\n    if (t[i] == f[i]) {\n      ok = false;\n    } else {\n      v.push_back((t[i] > f[i] ? x : y)[i]);\n    }\n  }\n  wt(ok);\n  if (ok) {\n    for (int vi : v) wt(vi);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    rep(i, N) cin >> X[i] >> Y[i];\n    two_sat ts(N * 2);\n    rep(i, N) {\n        ts.add_clause(i * 2, true, i * 2 + 1, true);\n    }\n    rep(i, N - 1) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i * 2, false, j * 2, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i * 2, false, j * 2 + 1, false);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i * 2 + 1, false, j * 2, false);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i * 2 + 1, false, j * 2 + 1, false);\n            }\n        }\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        auto ans = ts.answer();\n        rep(i, N) {\n            if (ans[i * 2]) cout << X[i] << \"\\n\";\n            else cout << Y[i] << \"\\n\";\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n#define cauto const auto\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\ntemplate<class A,class B> pair<A,B> operator+(const pair<A,B> &p,const pair<A,B> &q){ return {p.X+q.X,p.Y+q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator+=(pair<A,B> &p,const pair<C,D> &q){ p.X+=q.X; p.Y+=q.Y; return p;}\ntemplate<class A,class B> pair<A,B> operator-(const pair<A,B> &p,const pair<A,B> &q){ return {p.X-q.X,p.Y-q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator-=(pair<A,B> &p,const pair<C,D> &q){ p.X-=q.X; p.Y-=q.Y; return p;}\ntemplate<class A,class B> istream& operator>>(istream &is, pair<A,B> &p){ is>>p.X>>p.Y; return is;}\ntemplate<class T=ll> T read(){ T re; cin>>re; return move(re);}\ntemplate<class T=ll> T read(const T &dec){ T re; cin>>re; return re-dec;}\ntemplate<class T=ll> vector<T> readV(const int sz){ vector<T> re(sz); for(auto &x:re) x=read<T>(); return move(re);}\ntemplate<class T=ll> vector<T> readV(const int sz, const T &dec){ vector<T> re(sz); for(auto &x:re) x=read<T>(dec); return move(re);}\nvv<int> readG(const int &n,const int &m){ vv<int> g(n); rep(_,m){ cauto a=read<int>(1),b=read<int>(1); g[a].pb(b); g[b].pb(a);} return move(g);}\nvv<int> readG(const int &n){ return readG(n,n-1);}\nconst ll MOD=1e9+7; //998244353\n\n#include <atcoder/all>\nusing namespace atcoder;\n#ifdef NUIP\n#include \"atcoder/output\"\n#endif\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tcauto n=read();\n\tcauto d=read();\n\tcauto xys=readV<pii>(n);\n\ttwo_sat ts(n);\n\trep(i,n)rep(j,i){\n\t\tif(abs(xys[i].X-xys[j].X)<d) ts.add_clause(i,1,j,1);\n\t\tif(abs(xys[i].X-xys[j].Y)<d) ts.add_clause(i,1,j,0);\n\t\tif(abs(xys[i].Y-xys[j].X)<d) ts.add_clause(i,0,j,1);\n\t\tif(abs(xys[i].Y-xys[j].Y)<d) ts.add_clause(i,0,j,0);\n\t}\n\tif(!ts.satisfiable()){\n\t\tcout<<\"No\" NL;\n\t\treturn 0;\n\t}\n\tcout<<\"Yes\" NL;\n\tcauto wit=ts.answer();\n\trep(i,n) cout<<(wit[i]?xys[i].Y:xys[i].X) NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region header\n#include <bits/stdc++.h>\n#define int long long\n#define all(a) begin(a), end(a)\n#define rall(a) rbegin(a), rend(a)\n#define mp make_pair\n#define rep1(i, n) for (decltype(+n) i = 0; i < (n); i++)\n#define rrep1(i, n) for (auto i = n - 1; i > static_cast<decltype(i)>(-1); i--)\n#define rep2(i, a, b) for (auto i = (a); i < (b); i++)\n#define rrep2(i, a, b) for (auto i = b - 1; i >= a; i--)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep2, rep1) (__VA_ARGS__)\n#define rrep(...) GET_MACRO(__VA_ARGS__, rrep2, rrep1) (__VA_ARGS__)\n#define each(i, a) for (auto &&i : (a))\nusing namespace std;\n\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vd = vector<ld>;\nusing vvd = vector<vd>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing pii = pair<int, int>;\nusing vp = vector<pii>;\nusing vvp = vector<vp>;\nusing mii = map<int, int>;\nusing vm = vector<mii>;\nusing vvm = vector<vm>;\ntemplate <class T, class U>\nusing umap = unordered_map<T, U>;\nusing umii = umap<int, int>;\nusing seti = set<int>;\ntemplate <class T>\nusing uset = unordered_set<T>;\nusing useti = uset<int>;\ntemplate <class T>\nusing less_queue = priority_queue<T>;\ntemplate <class T>\nusing greater_queue = priority_queue<T, vector<T>, greater<T>>;\nusing int128 = __int128_t;\n\nostream &operator<<(ostream &dest, int128 value) {\n  ostream::sentry s(dest);\n  if (s) {\n    int128 tmp = value < 0 ? -value : value;\n    char buffer[128];\n    char *d = end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    if (value < 0) {\n      --d;\n      *d = '-';\n    }\n    int len = end(buffer) - d;\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(ios_base::badbit);\n    }\n  }\n  return dest;\n}\n\nconst int INF = 1e18;\nconst ld EPS = 1e-10;\n\ntemplate <class T>\nvoid SORT(T &a) { stable_sort(all(a)); }\ntemplate <class T>\nvoid RSORT(T &a) { stable_sort(rall(a)); }\ntemplate <class T>\nvoid rev(T &a) { reverse(all(a)); }\ntemplate <class T>\nvoid uniq(T &a) { a.erase(unique(all(a)), end(a)); }\ntemplate <class T>\nauto min_of(const T &a) { return *min_element(all(a)); }\ntemplate <class T>\nauto max_of(const T &a) { return *max_element(all(a)); }\ntemplate <class T>\nT sum_of(const vector<T> &a) { return accumulate(all(a), (T)0); }\ntemplate <class T, class U>\nint count_of(const T &a, const U &i) { return count(all(a), i); }\ntemplate <class T>\nbool has(const vector<T> &a, const T &i) { return find(all(a), i) != a.end(); }\nbool has(const string &a, const char &i) { return find(all(a), i) != a.end(); }\ntemplate <class T>\nbool has(const set<T> &a, const T &i) { return a.find(i) != a.end(); }\ntemplate <class T, class U>\nbool has(const map<T, U> &a, const T &i) { return a.find(i) != a.end(); }\ntemplate <class T, class U>\nbool has(const umap<T, U> &a, const T &i) { return a.find(i) != a.end(); }\ntemplate <class T>\nint sz(const T &a) { return a.size(); };\n\nvoid CIN() {};\ntemplate <class T, class... U>\nvoid CIN(T &&x, U &&...y) {\n  cin >> x;\n  CIN(forward<U>(y)...);\n}\nvoid _COUT() { cout << '\\n'; }\ntemplate <class T, class... U>\nvoid _COUT(T &&x, U &&...y) {\n  cout << ' ' << x;\n  _COUT(forward<U>(y)...);\n}\nvoid COUT() { _COUT(); };\ntemplate <class T, class... U>\nvoid COUT(T &&x, U &&...y) {\n  cout << x;\n  _COUT(forward<U>(y)...);\n}\ntemplate <class T>\nvoid CSP(const T &x) { cout << x << ' '; }\ntemplate <class T>\nvoid CVEC(const T &v) {\n  int c = v.size() - 1;\n  for (int i = 0; i < c; i++) cout << v[i] << ' ';\n  if (c > -1) cout << v[c];\n  cout << '\\n';\n}\n\ntemplate <class T>\nbool amin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\nbool amax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nconstexpr int lshift(const int &x) noexcept { return 1ll << x; }\nconstexpr int popcount(const unsigned int &x) noexcept { return __builtin_popcountll(x); }\nconstexpr int least1(const unsigned int &x) noexcept { return __builtin_ffsll(x); }\nconstexpr int ceil_div(const int &x, const int &y) noexcept { return (x + y - 1) / y; }\n\n#pragma endregion header\n\nnamespace internal {\ntemplate <class E>\nstruct csr {\n  vector<int> start;\n  vector<E> elist;\n  csr(int n, const vector<pair<int, E>> &edges) : start(n + 1), elist(edges.size()) {\n    for (auto e : edges) start[e.first + 1]++;\n    for (int i = 1; i <= n; i++) start[i] += start[i - 1];\n    auto counter = start;\n    for (auto e : edges) elist[counter[e.first]++] = e.second;\n  }\n};\nstruct scc_graph {\npublic:\n  scc_graph(int n) : _n(n) {}\n  int num_vertices() { return _n; }\n  void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n  pair<int, vector<int>> scc_ids() {\n    auto g = csr<edge>(_n, edges);\n    int now_ord = 0, group_num = 0;\n    vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n    visited.reserve(_n);\n    auto dfs = [&](auto self, int v) -> void {\n      low[v] = ord[v] = now_ord++;\n      visited.push_back(v);\n      for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n        auto to = g.elist[i].to;\n        if (ord[to] == -1) {\n          self(self, to);\n          low[v] = min(low[v], low[to]);\n        } else {\n          low[v] = min(low[v], ord[to]);\n        }\n      }\n      if (low[v] == ord[v]) {\n        while (true) {\n          int u = visited.back();\n          visited.pop_back();\n          ord[u] = _n;\n          ids[u] = group_num;\n          if (u == v) break;\n        }\n        group_num++;\n      }\n    };\n    for (int i = 0; i < _n; i++) if (ord[i] == -1) dfs(dfs, i);\n    for (auto &x : ids) x = group_num - 1 - x;\n    return {group_num, ids};\n  }\n  vector<vector<int>> scc() {\n    auto ids = scc_ids();\n    int group_num = ids.first;\n    vector<int> counts(group_num);\n    for (auto x : ids.second) counts[x]++;\n    vector<vector<int>> groups(ids.first);\n    for (int i = 0; i < group_num; i++) groups[i].reserve(counts[i]);\n    for (int i = 0; i < _n; i++) groups[ids.second[i]].push_back(i);\n    return groups;\n  }\n\nprivate:\n  int _n;\n  struct edge { int to; };\n  vector<pair<int, edge>> edges;\n};\n}\n\nstruct two_sat {\npublic:\n  two_sat() : _n(0), scc(0) {}\n  two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n  void add_clause(int i, bool f, int j, bool g) {\n    assert(0 <= i && i < _n);\n    assert(0 <= j && j < _n);\n    scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n    scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n  }\n  bool satisfiable() {\n    auto id = scc.scc_ids().second;\n    for (int i = 0; i < _n; i++) {\n      if (id[2 * i] == id[2 * i + 1]) return false;\n      _answer[i] = id[2 * i] < id[2 * i + 1];\n    }\n    return true;\n  }\n  vector<bool> answer() { return _answer; }\n\nprivate:\n  int _n;\n  vector<bool> _answer;\n  internal::scc_graph scc;\n};\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nvoid solve(int N, int D, vi X, vi Y) {\n  two_sat ts(N);\n  rep(i, N - 1)rep(j, i + 1, N) {\n    if (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n    if (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n    if (abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n    if (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n  }\n  if (ts.satisfiable()) {\n    COUT(YES);\n    vb ans = ts.answer();\n    rep(i, N) COUT(ans[i] ? X[i] : Y[i]);\n  } else COUT(NO);\n}\n\n\n#pragma region main\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(15);\n\n  int N;\n  cin >> N;\n  int D;\n  cin >> D;\n  vi X(N);\n  vi Y(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> X[i];\n    cin >> Y[i];\n  }\n  solve(N, D, move(X), move(Y));\n}\n#pragma endregion main\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <utility>\n#include <fstream>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { a = abs(a), b = abs(b); while (b > 0) { tie(a, b) = make_pair(b, a % b); } return a; }\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n\nstruct StronglyConnectedComponents {\n\tint n, group_num, now_ord;\n\tvector<vector<int>> g;\n\tvector<int> low, ord, idx;\n\tStronglyConnectedComponents(int _n) :n(_n), low(n), ord(n, -1), idx(n), g(n), group_num(0), now_ord(0) {}\n\tvoid add_edge(int from, int to) {\n\t\tg[from].emplace_back(to);\n\t}\n\tvoid dfs(int cur, vector<int>& visited) {\n\t\tord[cur] = low[cur] = now_ord++;\n\t\tvisited.emplace_back(cur);\n\t\tfor (auto nxt : g[cur]) {\n\t\t\tif (ord[nxt] == -1) {\n\t\t\t\tdfs(nxt, visited);\n\t\t\t\tchmin(low[cur], low[nxt]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmin(low[cur], ord[nxt]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\twhile (true) {\n\t\t\t\tint v = visited.back();\n\t\t\t\tvisited.pop_back();\n\t\t\t\tord[v] = n; //別のdfs木からこないように\n\t\t\t\tidx[v] = group_num;\n\t\t\t\tif (cur == v) break;\n\t\t\t}\n\t\t\tgroup_num++;\n\t\t}\n\t}\n\n\n\n\t//sccのidxに入ってる頂点番号 idxはトポロジカル順\n\tvoid build() {\n\t\tvector<int> visited;\n\t\tfor (int i = 0; i < n; i++) if (ord[i] == -1) dfs(i, visited);\n\t\tfor (int i = 0; i < n; i++) idx[i] = group_num - 1 - idx[i];\n\t}\n\t//build()の後にやる\n\tvector<vector<int>> groups() {\n\t\tvector<vector<int>> ret(group_num);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret[idx[i]].emplace_back(i);\n\t\t}\n\t\treturn ret;\n\t}\n\tint operator[](int i) { return idx[i]; }\n};\n\n\nstruct TwoSAT {\npublic:\n\tint n;\n\tvector<bool> res;\n\tStronglyConnectedComponents scc;\n\tTwoSAT(int _n) :n(_n), res(n), scc(2 * n) {}\n\n\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t}\n\n\tbool satisfiable() {\n\t\tscc.build();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (scc[i * 2 + 0] == scc[i * 2 + 1]) return false;\n\t\t\tres[i] = scc[i * 2 + 0] < scc[i * 2 + 1];\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator[](int i) { return res[i]; }\n};\n\ntemplate<typename T>\nstruct Compress {\n\tvector<T> v;\n\tCompress() {}\n\tCompress(vector<T> _v) :v(_v) {\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\n\tvoid build(vector<T> _v) {\n\t\tv = _v;\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\tint get(T x) {\n\t\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n\t}\n\n\tT& operator[](int i) { return v[i]; }\n\n\n\tint size() {\n\t\treturn (int)v.size();\n\t}\n};\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, D; cin >> n >> D;\n\tTwoSAT ts(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(x[i] - x[j]) < D) ts.add_clause(i, false, j, false);\n\t\t\tif (abs(x[i] - y[j]) < D) ts.add_clause(i, false, j, true);\n\t\t\tif (abs(y[i] - x[j]) < D) ts.add_clause(i, true, j, false);\n\t\t\tif (abs(y[i] - y[j]) < D) ts.add_clause(i, true, j, true);\n\t\t}\n\t}\n\tif (!ts.satisfiable()) cout << \"No\" << \"\\n\";\n\telse {\n\t\tcout << \"Yes\" << \"\\n\";\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ts[i]) cout << x[i] << \"\\n\";\n\t\t\telse cout << y[i] << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <atcoder/all>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define endl '\\n'\n#define debug(x) std::cerr << #x << \" = \" << (x) << endl;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nll N, D;\nll X[1010], Y[1010];\n\nint main() {\n  std::cin >> N >> D;\n\n  rep( i, N )\n    std::cin >> X[i] >> Y[i];\n\n  atcoder::two_sat ts(N);\n\n  rep( i, N ) rep( j, i ) {\n    if( llabs(X[i]-X[j]) < D ) {\n      ts.add_clause( i, false, j, false );\n    }\n    if( llabs(X[i]-Y[j]) < D ) {\n      ts.add_clause( i, false, j, true );\n    }\n    if( llabs(Y[i]-X[j]) < D ) {\n      ts.add_clause( i, true, j, false );\n    }\n    if( llabs(Y[i]-Y[j]) < D ) {\n      ts.add_clause( i, true, j, true );\n    }\n  }\n\n  if( !ts.satisfiable() ) {\n    std::cout << \"No\" << endl;\n\n    return 0;\n  }\n\n  std::cout << \"Yes\" << endl;\n\n  auto vs = ts.answer();\n\n  rep( i, vs.size() ) {\n    std::cout << (vs[i] ? X[i] : Y[i]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\n#define REP(i,n) for(ll i=0;i<(ll)n;i++)\n#define dump(x)  cerr << \"Line \" << __LINE__ << \": \" <<  #x << \" = \" << (x) << \"\\n\";\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n\nusing ld = long double;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\n\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){os << \"(\" << v.first << \", \" << v.second << \")\"; return os;}\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<vector<T>> &v){ for(auto &e : v){os << e << \"\\n\";} return os;}\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n\ntemplate <class T> void UNIQUE(vector<T> &x) {sort(ALL(x));x.erase(unique(ALL(x)), x.end());}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nvoid fail() { cout << -1 << '\\n'; exit(0); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ntemplate<typename T> void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cerr<<v[i][0];for(ll j=1;j<w;j++)cerr spa v[i][j];cerr<<\"\\n\";}};\ntemplate<typename T> void debug(vector<T>&v,ll n){if(n!=0)cerr<<v[0];\nfor(ll i=1;i<n;i++)cerr spa v[i];\ncerr<<\"\\n\";};\n\nconst ll INF = (1ll<<62);\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst ll mod = (int)1e9 + 7;\n//const ll mod = 998244353;\n\nint main(){\n\n    ll N, D;\n    cin >> N >> D;\n    V<V<ll>> X(N, V<ll>(2, 0));\n    REP(i, N) cin >> X[i][0] >> X[i][1];\n\n    two_sat ts(N);\n    auto dist = [](ll x, ll y){return abs(x-y);};\n\n    REP(i, N){\n        REP(j, N){\n            if(i<j){\n                REP(k, 2){\n                    if(dist(X[i][k], X[j][0])<D){\n                        if(dist(X[i][k], X[j][1])<D){\n                            ts.add_clause(i, 1-k, i, 1-k);\n                        }else{\n                            ts.add_clause(i, 1-k, j, 1);\n                        }\n                    }else{\n                        if(dist(X[i][k], X[j][1])<D){\n                            ts.add_clause(i, 1-k, j, 0);\n                        }else{\n                            1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    auto ok = ts.satisfiable();\n\n    if(ok){\n        cout << \"Yes\\n\";\n        auto res = ts.answer();\n        REP(i, N){\n            cout << X[i][res[i]] << endl;\n        }\n    }else{\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n\n#include <atcoder/all>\n\nusing namespace atcoder;\nusing namespace std;\nusing lint = long long;\nusing P = pair<lint, lint>;\n\n#define rep(i, n) for (lint i = 0; i < (n); ++i)\n#define rep1(i, n) for (lint i = 1; i < (n); ++i)\n#define repn(i, a, b) for(lint i = (a); i < (b); ++i)\n#define rep_inv(i, n) for (lint i = (n); i >= 0; --i)\n#define rep_inv1(i, n) for(lint i = (n); i >= 1; --i)\n#define all(vec) (vec).begin(), (vec).end()\n#define cend printf(\"\\n\")\n\nconstexpr lint Mod = /**/ 1000'000'007LL /*/ 998'244'353LL /**/;\nconstexpr lint Inf = 4'500'000'000'000'000'007LL; //4.5e18+7\nconstexpr double Pi = 3.141592653589793;\n\ntemplate<class T> using prique     = priority_queue<T>;\ntemplate<class T> using prique_inv = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline istream& operator>>(istream& is, vector<T>& v) { for (auto& e : v) is >> e; return is; }\ntemplate<class T> inline ostream& operator<<(ostream& os, const vector<T>& v) {\n\tsize_t i = 0, n = v.size();\n\tfor (const auto& e : v) {\n\t\tos << e;\n\t\tif (i + 1 < n) os << \" \";\n\t\t++i;\n\t}\n\treturn os;\n}\ntemplate<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& rhs) { return is >> rhs.first >> rhs.second; }\ntemplate<class T, class U> inline ostream& operator<<(ostream& os, const pair<T, U>& rhs) { return os << \"{\" << rhs.first << \", \" << rhs.second << \"}\"; }\ntemplate<class T, class U> inline void print(const T& a, const U& b, bool f) {\n\tif (f) cout << a << \"\\n\";\n\telse cout << b << \"\\n\";\n}\ntemplate<class InputIterator> void arrin(InputIterator first, InputIterator last) { for (; first != last; ++first) cin >> (*first); }\ntemplate<class InputIterator> void arrout(InputIterator first, InputIterator last) {\n\tfor (; first != last; ++first) {\n\t\tcout << (*first) << ((first + 1) != last ? \" \" : \"\\n\");\n\t}\n}\n\nbool pri(lint x) { \n\tfor (lint i = 2; i * i <= x; ++i) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn 1 < x; \n}\n\nlint fact[3'000'000];\nvoid fact_init(lint n, lint m = Mod) {\n\tif (3'000'000 <= n) return;\n\tfact[0] = fact[1] = 1;\n\tfor (lint i = 2; i <= n; ++i) {\n\t\tfact[i] = i * fact[i - 1] % m;\n\t}\n}\n\nlint modpow(lint x, lint n, lint m = Mod) {\n\tlint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % m;\n\t\tx = x * x % m;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlint intpow(lint x, lint n) {\n\tlint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlint comb(lint n, lint r, lint m = Mod) {\n\tif (r == 0 || r == n) return 1;\n\tlint res = fact[n] * modpow(fact[n - r], m - 2, m) % m * modpow(fact[r], m - 2, m) % m;\n\treturn res < 0 ? res + m : res;\n}\n\nmap<lint, lint> factring(lint n) {\n\tmap<lint, lint> res;\n\tfor (lint i = 2; i * i <= n; ++i) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\t++res[i];\n\t\t}\n\t}\n\tif (n != 1) ++res[n];\n\treturn res;\n}\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\n\tvector<int>x(n), y(n);\n\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\ttwo_sat ts(n);\n\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\tif (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n\t\t\tif (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n\t\t\tif (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n\t\t\tif (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n\t\t}\n\t}\n\n\tif (!ts.satisfiable()) cout << \"No\\n\";\n\telse {\n\t\tcout << \"Yes\\n\";\n\t\tconst auto& ans = ts.answer();\n\t\tfor (int i = 0;  bool b : ans) {\n\t\t\tif (b) cout << x[i] << \"\\n\";\n\t\t\telse cout << y[i] << \"\\n\";\n\t\t\t++i;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimization (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n \ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 1e9+7;\nconstexpr long long inf = 3e18;\n\nstruct SCC{\n\tvector<vector<int>>G,rG;\n\tvector<bool>used;\n\tvector<int>vs;\n\tvoid addEdge(int x,int y){\n\t\tG[x].push_back(y);\n\t\trG[y].push_back(x);\n\t}\n\tvoid dfs(int x){\n\t\tused[x]=true;\n\t\tfor(int i:G[x])if(!used[i])dfs(i);\n\t\tvs.push_back(x);\n\t}\n\tvector<int>cmp;\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\tfor(int i:rG[v])if(!used[i])rdfs(i,k);\n\t}\n\tvoid scc(){\n\t\tfill(all(used),false);\n\t\trep(i,len(G))if(!used[i])dfs(i);\n\t\tfill(all(used),false);\n\t\tint k=0;\n\t\trev(i,len(vs))if(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\tSCC(int N):G(N),rG(N),used(N),cmp(N){}\n};\n\nint N,D;\nint X[1005][2];\nbool ng[1005][2];\nsigned main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tcin>>N>>D;\n\trep(i,N)cin>>X[i][0]>>X[i][1];\n\tSCC scc(2*N);\n\trep(i,N)for(int j=i+1;j<N;j++)rep(k,2)rep(l,2){\n\t\tif(abs(X[i][k]-X[j][l])<D){\n\t\t\tscc.addEdge((1-k)*N+i,l*N+j);\n\t\t\tscc.addEdge((1-l)*N+j,k*N+i);\n\t\t}\n\t}\n\tscc.scc();\n\trep(i,N){\n\t\tif(scc.cmp[i]==scc.cmp[i+N]){\n\t\t\tcout<<\"No\\n\";return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\\n\";\n\trep(i,N){\n\t\tcout<<X[i][scc.cmp[i]>scc.cmp[i+N]]<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\n\ntypedef long long ll;\ntypedef std::pair<ll, ll> P;\n\nconstexpr ll INF = 1e15;\nconstexpr ll mod = 1e9+7;\n\n#define rep(i,n) for(int i = 0; i < int(n); i++)\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n\nint main() {\n    ll n, d;\n    cin >> n >> d;\n    vector<P> ps(n);\n    rep(i, n) {\n        cin >> ps[i].first >> ps[i].second;\n    }\n    auto graph = atcoder::two_sat(n);\n    rep(i, n) {\n        rep(j, n) {\n            if (i == j) continue;\n            //条件を満たさない場合にノードをつなぐ\n            if (abs(ps[i].first - ps[j].first) < d) {\n                graph.add_clause(i, true, j, true);\n            }\n            if (abs(ps[i].first - ps[j].second) < d) {\n                graph.add_clause(i, true, j, false);\n            }\n            if (abs(ps[i].second - ps[j].first) < d) {\n                graph.add_clause(i, false, j, true);\n            }\n            if (abs(ps[i].second - ps[j].second) < d) {\n                graph.add_clause(i, false, j, false);\n            }\n        }\n    }\n    if (graph.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = graph.answer();\n        rep(i, n) {\n            if (ans[i]) {\n                cout << ps[i].first << endl;\n            }\n            else {\n                cout << ps[i].second << endl;\n            }\n        }\n        return 0;\n    }\n    cout << \"No\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct SCC {\npublic:\n    SCC(int n) : G(n), G_rev(n), comp(n, -1), visited(n) {}\n\n    void add_edge(int u, int v) {\n        G[u].push_back(v);\n        G_rev[v].push_back(u);\n    }\n\n    void build() {\n        for (int v = 0; v < G.size(); v++) dfs(v);\n        reverse(order.begin(), order.end());\n        int c = 0;\n        for (int v : order) if (comp[v] == -1) rdfs(v, c++);\n    }\n\n    int operator[](int i) const {\n        return comp[i];\n    }\n\nprivate:\n    vector<vector<int>> G, G_rev;\n    vector<int> comp, order;\n    vector<bool> visited;\n\n    void dfs(int u) {\n        if (visited[u]) return;\n        visited[u] = true;\n        for (int v : G[u]) dfs(v);\n        order.push_back(u);\n    }\n\n    void rdfs(int u, int c) {\n        if (comp[u] != -1) return;\n        comp[u] = c;\n        for (int v : G_rev[u]) rdfs(v, c);\n    }\n};\n\nstruct TwoSat {\n    bool satisfiable = true;\n\n    TwoSat(int n) : n(n), scc(2 * n), val(n) {}\n\n    void add_clause(int u, bool a, int v, bool b) {\n        scc.add_edge(n * a + u, n * (!b) + v);\n        scc.add_edge(n * b + v, n * (!a) + u);\n    }\n\n    void solve() {\n        scc.build();\n        for (int i = 0; i < n; i++) {\n            if (scc[i] == scc[n + i]) {\n                satisfiable = false;\n                break;\n            }\n            val[i] = scc[i] > scc[n + i];\n        }\n    }\n\n    bool operator[](int i) const {\n        return val[i];\n    }\n\nprivate:\n    int n;\n    SCC scc;\n    vector<bool> val;\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    TwoSat sat(N);\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                sat.add_clause(i, false, j, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                sat.add_clause(i, false, j, true);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                sat.add_clause(i, false, j, true);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                sat.add_clause(i, true, j, true);\n            }\n        }\n    }\n    sat.solve();\n    if (sat.satisfiable) {\n        cout << \"Yes\\n\";\n        for (int i = 0; i < N; i++) {\n            if (sat[i]) cout << X[i];\n            else cout << Y[i];\n            cout << \"\\n\";\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n*/\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\n//using mint = modint998244353;\nusing mint = modint1000000007;\n//////////////////////////\n\n\nll n,d;\nbool out(ll i,ll j){\n    if(abs(i-j)>=d)return false;\n    return true;\n}\n\nint main(){fastio\n    cin>>n>>d;\n    ll x[n],y[n];\n    rep(i,0,n-1)cin>>x[i]>>y[i];\n    two_sat ts(n);\n    rep(i,0,n-1){\n        rep(j,i+1,n-1){\n            if(out(x[i],x[j])){\n                ts.add_clause(i,false,j,false);\n            }\n            if(out(x[i],y[j])){\n                ts.add_clause(i,false,j,true);\n            }\n            if(out(y[i],x[j])){\n                ts.add_clause(i,true,j,false);\n            }\n            if(out(y[i],y[j])){\n                ts.add_clause(i,true,j,true);\n            }\n        }\n    }\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        vector<bool>ans=ts.answer();\n        rep(i,0,n-1){\n            if(ans[i])cout<<x[i]<<endl;\n            else cout<<y[i]<<endl;\n        }\n    }else{\n        cout<<\"No\"<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<atcoder/all>\n#include<vector>\nusing namespace std;\ntypedef long long li;\n#define yn(i) print((i)?\"Yes\":\"No\"),i\n#define dist(a,b) max((a)-(b),(b)-(a))\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define df 0\ntemplate<class T> void print(const T& t){ cout << t << \"\\n\"; }\ntemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { cout << t; if (sizeof...(ts)) cout << \" \"; print(ts...); }\n\nint main(){\n  int n;li d; cin >>n >>d;\n  vector<vector<li>> x(n,vector<li>(2));\n  atcoder::two_sat ts(n);\n  rep(i,n){\n    li a,b; cin >>a >>b;\n    x[i]={a,b};\n    rep(j,i) rep(ii,2) rep(jj,2){\n      if(dist(x[i][ii],x[j][jj])<d)\n        ts.add_clause(i,1-ii,j,1-jj);\n    }\n  }\n  if(yn(ts.satisfiable())){\n    vector<bool> ans=ts.answer();\n    rep(i,n)print(x[i][ans[i]]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <cmath>\n#include <utility>\n#include <functional>\n#include <map>\n#include <set>\n#include <cctype>\n#include <fstream>\n#include <numeric>\n#include <cassert>\n\n#include <cstdint>\n#include <iomanip>\n#include <cstring>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll = long long;\n#define ALL(a) (a).begin(), (a).end()\n\n#define FOR(i, a, b) for (long long int i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (long long int i = (a); i >= (b); i--)\n\nconst int MOD = 1000000007;\n\n#define LLONG_MAXs 9223372036854775800 / 2\n//#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\n#define ALL(a) (a).begin(), (a).end()\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrimeNum(ll x)\n{ // 素数である場合 true を返す\n    if (x <= 1)\n    { // 1以下である場合は素数でないことがすぐにわかる\n        return false;\n    }\n    // sqrt( double型 ) は引数の平方根を double型で返すので、int型でキャスト\n    int n = (int)sqrt((double)x);\n    for (int i = 2; i <= n; i++)\n    {\n        if (x % i == 0)\n        { // 割り切る整数がある場合、即判定終了\n            return false;\n        }\n    }\n    return true; // 割り切る整数がない場合、素数である\n}\n\nll myPow(ll x, ll n, ll m)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n\nconstexpr ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nconstexpr ll lcm(ll a, ll b) { return a * b / gcd(a, b); }\nconstexpr ll abs(ll a, ll b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr double dabs(double a, double b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr ll min(ll a, ll b)\n{\n    if (a >= b)\n        return b;\n    if (a < b)\n        return a;\n}\n\nconstexpr ll max(ll a, ll b)\n{\n    if (a >= b)\n        return a;\n    if (a < b)\n        return b;\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dx8[8] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy8[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nclass UnionFind\n{\npublic:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> Parent;\n\n    //作るときはParentの値を全て-1にする\n    //こうすると全てバラバラになる\n    UnionFind(int N)\n    {\n        Parent = vector<int>(N, -1);\n    }\n\n    //Aがどのグループに属しているか調べる\n    int root(int A)\n    {\n        if (Parent[A] < 0)\n            return A;\n        return Parent[A] = root(Parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A)\n    {\n        return -Parent[root(A)]; //親をとってきたい]\n    }\n    bool issame(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    //AとBをくっ付ける\n    bool connect(int A, int B)\n    {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B)\n        {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n\n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらひっくり返しちゃう。\n        if (size(A) < size(B))\n            swap(A, B);\n\n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n\n        return true;\n    }\n};\n\nlong long fac[510000], finv[510000], inv[510000];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < 510000; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n    if (n < k)\n        return 0;\n    if (n < 0 || k < 0)\n        return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long modinv(long long a, long long m)\n{\n    long long b = m, u = 1, v = 0;\n    while (b)\n    {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n\nvoid yn(bool flag)\n{\n    if (flag)\n    {\n        cout << \"Yes\" << endl;\n    }\n    else\n    {\n        cout << \"No\" << endl;\n    }\n    return;\n}\nvoid YN(bool flag)\n{\n    if (flag)\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n    return;\n}\n\nstd::vector<ll> enum_div(ll n) //nの約数を列挙\n{\n    std::vector<ll> ret;\n    for (ll i = 1; i * i <= n; ++i)\n    {\n        if (n % i == 0)\n        {\n            ret.push_back(i);\n            if (i != 1 && i * i != n)\n            {\n                ret.push_back(n / i);\n            }\n        }\n    }\n    ret.push_back(n);\n    return ret;\n}\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate <int MOD>\nstruct Fp\n{\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD)\n    {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept\n    {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator+(const Fp &r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator-(const Fp &r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator*(const Fp &r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator/(const Fp &r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp &operator+=(const Fp &r) noexcept\n    {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept\n    {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept\n    {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept\n    {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b)\n        {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept\n    {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept\n    {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept\n    {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept\n    {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\n// グラフセット\nstruct Edge\n{\n    ll to;     // 辺の行き先\n    ll weight; // 辺の重み\n    Edge(int t, int w) : to(t), weight(w) {}\n};\n//using Graph = vector<vector<Edge>>;\n#define def 0\ntemplate <class V, int NV>\nstruct SegTree\n{ //[l,r)\n    V comp(V &l, V &r) { return max(l, r); };\n\n    vector<V> val;\n    SegTree() { val = vector<V>(NV * 2, def); }\n    V get(int x, int y, int l = 0, int r = NV, int k = 1)\n    {\n        if (r <= x || y <= l)\n            return def;\n        if (x <= l && r <= y)\n            return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2);\n        auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);\n        return comp(a, b);\n    }\n    void update(int i, V v)\n    {\n        i += NV;\n        val[i] = v;\n        while (i > 1)\n            i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n    }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\ntypedef vector<vector<long long>> matrix;\nmatrix mul_mod(matrix A, matrix B)\n{\n    int H = A.size();\n    int W = B[0].size();\n    int K = A[0].size();\n\n    matrix C(H, vector<ll>(W, 0));\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            for (int k = 0; k < K; k++)\n            {\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\n\n// 区間加算にも対応した BIT\ntemplate <class Abel>\nstruct BIT\n{\n    vector<Abel> dat[2];\n    Abel UNITY_SUM = 0; // to be set\n\n    /* [1, n] */\n    BIT(int n) { init(n); }\n    void init(int n)\n    {\n        for (int iter = 0; iter < 2; ++iter)\n            dat[iter].assign(n + 1, UNITY_SUM);\n    }\n\n    /* a, b are 1-indexed, [a, b) */\n    inline void sub_add(int p, int a, Abel x)\n    {\n        for (int i = a; i < (int)dat[p].size(); i += i & -i)\n            dat[p][i] = dat[p][i] + x;\n    }\n    inline void add(int a, int b, Abel x)\n    {\n        sub_add(0, a, x * -(a - 1));\n        sub_add(1, a, x);\n        sub_add(0, b, x * (b - 1));\n        sub_add(1, b, x * (-1));\n    }\n\n    /* a is 1-indexed, [a, b) */\n    inline Abel sub_sum(int p, int a)\n    {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[p][i];\n        return res;\n    }\n    inline Abel sum(int a, int b)\n    {\n        return sub_sum(0, b - 1) + sub_sum(1, b - 1) * (b - 1) - sub_sum(0, a - 1) - sub_sum(1, a - 1) * (a - 1);\n    }\n\n    /* debug */\n    void print()\n    {\n        for (int i = 1; i < (int)dat[0].size(); ++i)\n            cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\nusing Graph = vector<vector<ll>>;\n\nvoid print(const std::vector<int> &v)\n{\n    std::for_each(v.begin(), v.end(), [](int x) {\n        std::cout << x << \" \";\n    });\n    std::cout << std::endl;\n}\nconst double PI = 3.14159265358979323846;\nll times_cap(ll a, ll b)\n{\n    if (log10(a) + log10(b) >= 19.0)\n        return -1;\n    else\n        return a * b;\n}\n\n// konpairu command\n//  g++ code.cpp -std=c++14 -I .\n//cout << std::setprecision(30) << ans << endl;\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\n#include <cassert>\n#include <vector>\n\n\n#include <algorithm>\n#include <utility>\n\n\nnamespace internal {\n\n    template <class E> struct csr {\n        std::vector<int> start;\n        std::vector<E> elist;\n        csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n          for (auto e : edges) {\n            start[e.first + 1]++;\n          }\n          for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n          }\n          auto counter = start;\n          for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n          }\n        }\n    };\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\n    struct scc_graph {\n    public:\n        scc_graph(int n) : _n(n) {}\n\n        int num_vertices() { return _n; }\n\n        void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n        // @return pair of (# of scc, scc id)\n        std::pair<int, std::vector<int>> scc_ids() {\n          auto g = csr<edge>(_n, edges);\n          int now_ord = 0, group_num = 0;\n          std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n          visited.reserve(_n);\n          auto dfs = [&](auto self, int v) -> void {\n              low[v] = ord[v] = now_ord++;\n              visited.push_back(v);\n              for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                  self(self, to);\n                  low[v] = std::min(low[v], low[to]);\n                } else {\n                  low[v] = std::min(low[v], ord[to]);\n                }\n              }\n              if (low[v] == ord[v]) {\n                while (true) {\n                  int u = visited.back();\n                  visited.pop_back();\n                  ord[u] = _n;\n                  ids[u] = group_num;\n                  if (u == v) break;\n                }\n                group_num++;\n              }\n          };\n          for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n          }\n          for (auto& x : ids) {\n            x = group_num - 1 - x;\n          }\n          return {group_num, ids};\n        }\n\n        std::vector<std::vector<int>> scc() {\n          auto ids = scc_ids();\n          int group_num = ids.first;\n          std::vector<int> counts(group_num);\n          for (auto x : ids.second) counts[x]++;\n          std::vector<std::vector<int>> groups(ids.first);\n          for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n          }\n          for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n          }\n          return groups;\n        }\n\n    private:\n        int _n;\n        struct edge {\n            int to;\n        };\n        std::vector<std::pair<int, edge>> edges;\n    };\n\n}  // namespace internal\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\npublic:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n      assert(0 <= i && i < _n);\n      assert(0 <= j && j < _n);\n      scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n      scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n      auto id = scc.scc_ids().second;\n      for (int i = 0; i < _n; i++) {\n        if (id[2 * i] == id[2 * i + 1]) return false;\n        _answer[i] = id[2 * i] < id[2 * i + 1];\n      }\n      return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\nprivate:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n\nclass HTwoSAT {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, d; cin >> n >> d;\n      vector<int> x(n), y(n);\n      rep(i, n) {\n        cin >> x[i] >> y[i];\n      }\n      auto ts = two_sat(2*n);\n      rep(i, n) {\n        ts.add_clause(i, true, i+n, true);\n      }\n\n      for(int i=0; i<n; i++) {\n        for(int j=i+1; j<n; j++) {\n          if (abs(x[i]-x[j]) < d) {\n            ts.add_clause(i, false, j, false);\n          }\n          if (abs(y[i]-y[j]) < d) {\n            ts.add_clause(i+n, false, j+n, false);\n          }\n          if (abs(x[i]-y[j]) < d) {\n            ts.add_clause(i, false, j+n, false);\n          }\n          if (abs(y[i]-x[j]) < d) {\n            ts.add_clause(i+n, false, j, false);\n          }\n        }\n      }\n\n      if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return;\n      }\n      cout << \"Yes\" << endl;\n      auto ret = ts.answer();\n      rep(i, n) {\n        if (ret[i]) {\n          cout << x[i] << '\\n';\n        } else {\n          cout << y[i] << '\\n';\n        }\n      }\n\n    }\n};\n\nsigned main() {\n  HTwoSAT solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//g++ main.cpp -I /usr/local/include/ac-library\n#include<cmath>\n#include <atcoder/all>\n#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\nusing namespace atcoder;\nstack<int> st;\nqueue<int> qu;\nqueue<pair<int,int> > qu2;\npriority_queue<int> pq;\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define rep2(i,n) for(int i=1; i<=(int)(n); i++)\n#define mins(x,y) x=min(x,y)\n#define maxs(x,y) x=max(x,y)\n#define ALL(a) a.begin(), a.end()\ntypedef set<int> set_t;\ntypedef set<string> set_g;\ntypedef complex<double> xy_t;\nstatic const int NIL = -1;\nstatic const int INF = 1000000007;\n#define mp make_pair\n#define sz(x) int(x.sise())\n#define mod 1000000007\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\ndeque<int> deq;\n#define fi first\n#define se second\n//const ll MOD = 998244353;\nconst ll MOD = (1e+9) + 7;\ntypedef pair<int, int> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nint main(){\n    ll n,d;\n    cin >> n>> d;\n    ll x[n],y[n];\n    rep(i,n){\n        cin >> x[i]>> y[i];\n    }\n    two_sat ts(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            ll pat1=abs(x[i]-x[j]);\n            ll pat2=abs(x[i]-y[j]);\n            ll pat3=abs(y[i]-x[j]);\n            ll pat4=abs(y[i]-y[j]);\n            if(pat1<d)ts.add_clause(i,true,j,true);\n            if(pat2<d)ts.add_clause(i,true,j,false);\n            if(pat3<d)ts.add_clause(i,false,j,true);\n            if(pat4<d)ts.add_clause(i,false,j,false);\n        }\n    }\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        vector<bool> v=ts.answer();\n        rep(i,v.size()){\n            if(!v[i])cout<<x[i]<<endl;\n            else cout<<y[i]<<endl;\n        }\n    }\n    else cout<< \"No\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    // @return m\n    unsigned int umod() const { return _m; }\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  // namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}  // namespace internal\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}  // namespace atcoder\n#endif  // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);    \n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n}  // namespace atcoder\n#endif  // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;  \n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}  // namespace atcoder\n#endif  // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}  // namespace atcoder\n#endif  // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}  // namespace atcoder\n#endif  // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}  // namespace internal\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n}  // namespace atcoder\n#endif  // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n\n\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n//#include<boost/multiprecision/cpp_int.hpp>\n//#include<boost/multiprecision/cpp_dec_float.hpp>\n//namespace mp=boost::multiprecision;\n//#define mulint mp::cpp_int\n//#define mulfloat mp::cpp_dec_float_100\nusing namespace std;\nusing namespace atcoder;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n//constexpr int MOD=1000000007;\nconstexpr int MOD=998244353;\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(lint (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(lint (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcountll(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\n#define fi first\n#define se second\ntypedef long long lint;\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nconst int MAX_N=2e5+5;\n//struct edge{lint to,num;};\n//vector<int> bucket[MAX_N/1000];\n\nlint op(lint a,lint b){\n    return a+b;\n}\nlint e(){\n    return 0;\n}\nlint tgt;\nbool f(lint res){\n    return tgt>res;\n}\n\nint main(void){\n    int N,D;\n    cin >> N >> D;\n    int X[N],Y[N];\n    rep(i,N) cin >> X[i] >> Y[i];\n    two_sat ts(N);\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        if(abs(X[i]-X[j])<D) ts.add_clause(i,1,j,1);\n        if(abs(X[i]-Y[j])<D) ts.add_clause(i,1,j,0);\n        if(abs(Y[i]-X[j])<D) ts.add_clause(i,0,j,1);\n        if(abs(Y[i]-Y[j])<D) ts.add_clause(i,0,j,0);\n    }\n    if(ts.satisfiable()) cout << \"Yes\" << endl;\n    else{\n        cout << \"No\" << endl;\n        return 0;\n    }\n    vector<bool> res=ts.answer();\n    rep(i,N){\n        if(res[i]) cout << Y[i] << endl;\n        else cout << X[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define reps(i, n) for(int i=1, i##_len=(n); i<=i##_len; ++i)\n#define rrep(i, n) for(int i=((int)(n)-1); i>=0; --i)\n#define rreps(i, n) for(int i=((int)(n)); i>0; --i)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((int)(x).size())\n#define pl(s) cout << (s) << \"\\n\";\n#define pls(...) {bool space = false; for(auto i : __VA_ARGS__) (cout << (space?\" \":\"\") << i), space = true; cout << \"\\n\";}\n#define plexit(s) {cout << (s) << \"\\n\"; exit(0);}\n#define yes(s) cout << ((s)?\"Yes\":\"No\") << \"\\n\";\n#ifdef __LOCAL\n#include <dump.hpp>\n#define dump(...) DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \" << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" << endl << \"    \", dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\ntemplate<typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nstruct IOInit { IOInit() { cin.tie(nullptr); ios::sync_with_stdio(false); dump(\"READY\"); /*cout << unitbuf;*/} } IO_INIT;\nusing ll = long long; using ull = unsigned long long; using ld = long double;\ntemplate<typename T = int> using V = vector<T>; template<typename T = int> using P = pair<T, T>;\nusing Vi = V<int>; using Vl = V<ll>; using Vd = V<ld>; using VVi = V<Vi>; using VVl = V<Vl>; using Pi = P<int>; using Pl = P<ll>; using Pd = P<ld>;\nconstexpr ll MOD = 1000000007; constexpr int INF = (1 << 30) - 1; constexpr ll INFL = 1LL << 60; constexpr ld EPS = 1e-12; constexpr ld PI = 3.141592653589793238462643383279;\n\n\n\nsigned main(void) {\n  int n, d; cin >> n >> d;\n  Vi x(n), y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n\n  two_sat ts(n);\n  rep(i,n) {\n    for (int j = i+1; j < n; ++j) {\n      if (abs(x[i]-x[j]) < d) ts.add_clause(i, false, j, false);\n      if (abs(x[i]-y[j]) < d) ts.add_clause(i, false, j, true);\n      if (abs(y[i]-x[j]) < d) ts.add_clause(i, true, j, false);\n      if (abs(y[i]-y[j]) < d) ts.add_clause(i, true, j, true);\n    }\n  }\n\n  if (!ts.satisfiable()) plexit(\"No\")\n\n  pl(\"Yes\")\n  auto answer = ts.answer();\n  rep(i,n) {\n    if (answer[i]) pl(x[i])\n    else pl(y[i])\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// #include <atcoder/all>\n\nusing namespace std;\n// using namespace atcoder;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\nsigned main() {\n    int n, d;\n    cin >> n >> d;\n    set<int> st;\n    vi x(n), y(n);\n    rep (i, n) {\n        cin >> x[i] >> y[i];\n        st.insert(x[i]);\n        st.insert(y[i]);\n    }\n\n    map<int, int> mp;\n    int shu = 0;\n    for (auto itr = st.begin(); itr != st.end(); itr++) {\n        mp[*itr] = shu++;\n    }\n\n    two_sat sat(shu);\n\n    rep (i, n) {\n        int u = mp[x[i]], v = mp[y[i]];\n        sat.add_clause(u, true, v, true);\n    }\n    for (auto itr = st.begin(); itr != st.end(); itr++) {\n        ll x = *itr, u = mp[*itr];\n        for (auto itr2 = st.begin(); itr2 != st.end(); itr2++) {\n            ll y = *itr2, v = mp[*itr2];\n            if (x == y) continue;\n            if (abs(x - y) < d) {\n                sat.add_clause(u, false, v, false);\n            }\n        }\n    }\n\n    if (not sat.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    vector<bool> ans = sat.answer();\n    DEBUG_VEC(ans);\n    rep (i, n) {\n        int u = mp[x[i]], v = mp[y[i]];\n        if (ans[u]) {\n            cout << x[i] << endl;\n        }\n        else {\n            cout << y[i] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma region template\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- Ruby --- //\ntemplate <class F> struct Callable {\n\tF func;\n\tCallable(const F& f) : func(f) {}\n};\ntemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\treturn c.func(v);\n}\n\nstruct Sort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(begin(v), end(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\treturn v;\n\t}\n} Sort;\nstruct RSort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\tsort(rbegin(v), rend(v));\n\t\treturn v;\n\t}\n} RSort;\nstruct Reverse_impl {\n\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\treverse(begin(v), end(v));\n\t\treturn v;\n\t}\n} Reverse;\nstruct Unique_impl {\n\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Unique;\nstruct Uniq_impl {\n\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Uniq;\nstruct Rotate_impl {\n\ttemplate <class F> auto operator()(int left) {\n\t\treturn Callable([&](auto v) {\n\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} Rotate;\nstruct Max_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\treturn *max_element(begin(v), end(v));\n\t}\n} Max;\nstruct Min_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\treturn *min_element(begin(v), end(v));\n\t}\n} Min;\nstruct MaxPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t}\n} MaxPos;\nstruct MinPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t}\n} MinPos;\nstruct MaxBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_it = begin(v);\n\t\t\tauto max_val = f(*max_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_it = it;\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *max_it;\n\t\t});\n\t}\n} MaxBy;\nstruct MinBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_it = begin(v);\n\t\t\tauto min_val = f(*min_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_it = it;\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *min_it;\n\t\t});\n\t}\n} MinBy;\nstruct MaxOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_val;\n\t\t});\n\t}\n} MaxOf;\nstruct MinOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min_val;\n\t\t});\n\t}\n} MinOf;\nstruct Count_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count(begin(v), end(v), val);\n\t\t});\n\t}\n} Count;\nstruct CountIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count_if(begin(v), end(v), f);\n\t\t});\n\t}\n} CountIf;\nstruct Index_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} Index;\nstruct IndexIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} IndexIf;\nstruct FindIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t});\n\t}\n} FindIf;\nstruct Sum_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\treturn a + f(b);\n\t\t\t});\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t}\n} Sum;\nstruct Includes {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t});\n\t}\n} Includes;\nstruct IncludesIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t});\n\t}\n} IncludesIf;\nstruct RemoveIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} RemoveIf;\nstruct Each_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tf(i);\n\t\t\t}\n\t\t});\n\t}\n} Each;\nstruct Select_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\tvector<value_type> res;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Select;\nstruct Map_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\tvector<result_type> res;\n\t\t\tres.reserve(size(v));\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.push_back(f(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Map;\nstruct Indexed_impl {\n\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\tusing value_type = typename T::value_type;\n\t\tvector<pair<value_type, int>> res;\n\t\tres.reserve(size(v));\n\t\tint index = 0;\n\t\tfor (const auto& i : v) {\n\t\t\tres.emplace_back(i, index++);\n\t\t}\n\t\treturn res;\n\t}\n} Indexed;\nstruct AllOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (!f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} AllOf;\nstruct AnyOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n} AnyOf;\nstruct NoneOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} NoneOf;\n\n// --- functions --- //\ntemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\treturn lower_bound(all(a), v) - a.begin();\n}\ntemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\treturn upper_bound(all(a), v) - a.begin();\n}\ntemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n}\ninline auto operator*(string s, size_t n) {\n\tstring res;\n\tfor (size_t i = 0; i < n; ++i) res += s;\n\treturn res;\n}\ntemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\tv.insert(v.end(), all(v2));\n\treturn v;\n}\ntemplate <class T> inline T Ceil(T n, T m) {\n\treturn (n + m - 1) / m;\n}\ntemplate <class T> inline T Ceil2(T n, T m) {\n\treturn Ceil(n, m) * m;\n}\ntemplate <class T> inline T Tri(T n) {\n\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n}\ntemplate <class T> inline T nC2(T n) {\n\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n}\ntemplate <class T> inline T Mid(const T& l, const T& r) {\n\treturn l + (r - l) / 2;\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\treturn min <= v && v < max;\n}\ntemplate <class T> inline bool isSquere(T n) {\n\tT s = sqrt(n);\n\treturn s * s == n || (s + 1) * (s + 1) == n;\n}\ntemplate <class T = long long> inline T BIT(int b) {\n\treturn T(1) << b;\n}\ntemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n}\ntemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n}\ntemplate <class T> inline T Pow(T a, T n) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) r *= a;\n\t\ta *= a;\n\t\tn /= 2;\n\t}\n\treturn r;\n}\ntemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tr = r * a % m, n--;\n\t\telse\n\t\t\ta = a * a % m, n /= 2;\n\t}\n\treturn r;\n}\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n#pragma endregion\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\nbool ans[1001];\n\nint main() {\n\tin(n, d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tout.exit(\"No\");\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans[i] = true;\n\t}\n\n\tout(\"Yes\");\n\trep(i, n) out(ans[i] ? y[i] : x[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main()\n{\n    ll N, D;\n    cin >> N >> D;\n    two_sat ts(N);\n    vector<ll> X(N), Y(N);\n    for(int i=0;i<N;i++){\n        cin >> X[i] >> Y[i];\n    }\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            if(abs(X[i] - X[j]) < D){\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(Y[i] - Y[j]) < D){\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto ret = ts.answer();\n    for(int i=0;i<N;i++){\n        cout << (ret[i]? X[i]:Y[i]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nint main(){\n    ll n, d;\n    cin >> n >> d;\n    vector<ll> x(n), y(n);\n    REP(i, n){\n        cin >> x.at(i) >> y.at(i);\n    }\n\n    two_sat ts(n);\n\n    REP(i, n){\n        for(ll j = i + 1; j < n; ++j){\n            // xi, xj\n            if(abs(x.at(i) - x.at(j)) < d){\n                ts.add_clause(i, true, j, true);\n            }\n            // xi, yj\n            if(abs(x.at(i) - y.at(j)) < d){\n                ts.add_clause(i, true, j, false);\n            }\n            // yi, xj\n            if(abs(y.at(i) - y.at(j)) < d){\n                ts.add_clause(i, false, j, false);\n            }\n            // yi, yj;\n            if(abs(y.at(i) - y.at(j)) < d){\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << NO << endl;\n        return 0;\n    }\n    cout << YES << endl;\n\n    vector<bool> ans = ts.answer();\n    REP(i, n){\n        if(ans.at(i)){\n            cout << y.at(i) << endl;\n        }else{\n            cout << x.at(i) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, d;\n    cin >> n >> d;\n    int x[1000][2];\n    rep(i, n) rep(j, 2) cin >> x[i][j];\n\n    atcoder::two_sat ts(n);\n    rep(i, n) rep(j, i) rep(k, 4) if(abs(x[i][k >> 1] - x[j][k & 1]) < d)\n        ts.add_clause(i, k >> 1, j, k & 1);\n\n    if(ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        auto ans = ts.answer();\n        rep(i, n) cout << x[i][!ans[i]] << endl;\n    } else\n        cout << \"No\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include<atcoder/all>\n\nusing namespace std;\n\nusing namespace atcoder;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << endl\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n//#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << \" \\n\"[i==(int)v.size()-1]\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\nvoid Yes(bool cond) { cout << (cond ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool cond) { cout << (cond ? \"YES\" : \"NO\") << '\\n'; }\n\n\n\nvoid solve() {\n\tint N, D; cin >> N >> D;\n\ttwo_sat ts(N);\n\tvector<vector<int>>v(N, vector<int>(2));\n\tREP(i, N) {\n\t\tcin >> v[i][0] >> v[i][1];\n\t\tVSORT(v[i]);\n\t}\n\tREP(i, N) {\n\t\tFOR(j, i + 1, N) {\n\t\t\tREP(k, 2)REP(l, 2) {\n\t\t\t\tif (abs(v[i][k] - v[j][l]) < D)ts.add_clause(i, 1^k, j, 1^l);\n\t\t\t}\n\t\t}\n\t}\n\tbool ok = ts.satisfiable();\n\tif (!ok) {\n\t\tprint(\"No\");\n\t}\n\telse {\n\t\tvector<bool>ans = ts.answer();\n\t\tprint(\"Yes\");\n\t\tREP(i, N) {\n\t\t\tprint(v[i][ans[i]]);\n\t\t}\n\t}\n}\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nint main(){\n    ll n, d;\n    cin >> n >> d;\n    vector<array<ll, 2>> p(n);\n    vector<ll> x(n), y(n);\n    REP(i, n){\n        cin >> p.at(i).at(0) >> p.at(i).at(1);\n    }\n\n    two_sat ts(n);\n\n    REP(i, n){\n        for(ll j = i + 1; j < n; ++j){\n            REP(k1, 2){\n                REP(k2, 2){\n                    if(abs(p.at(i).at(k1) - p.at(j).at(k2)) < d){\n                        ts.add_clause(i, (bool)(1 - k1), j, (bool)(1 - k2));\n                    }\n                }\n            }\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << NO << endl;\n        return 0;\n    }\n    cout << YES << endl;\n\n    vector<bool> ans = ts.answer();\n    REP(i, n){\n        cout << p.at(i).at(ans.at(i)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n \n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define INF 1001001001\n#define MAX 1e18\n\nconst int mod = 998244353;\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n\n  two_sat ts(n);\n  rep(i,n) for (int j = i+1; j < n; j++) {\n    if (abs(x[i]-x[j]) < d) ts.add_clause(i,false,j,false);\n    if (abs(x[i]-y[j]) < d) ts.add_clause(i,false,j,true);\n    if (abs(y[i]-x[j]) < d) ts.add_clause(i,true,j,false);\n    if (abs(y[i]-y[j]) < d) ts.add_clause(i,true,j,true);\n  }\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  vector<bool> res = ts.answer();\n  cout << \"Yes\" << endl;\n  rep(i,n) cout << (res[i]?x[i]:y[i]) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nstruct SCC{\n    int n;\n    vector<vector<int>> g,rg;\n    vector<int> vs,cmp;\n    vector<bool> used;\n    SCC(int _n){\n        n=_n;\n        g=vector<vector<int>>(n);rg=g;\n        cmp=vector<int>(n);used=vector<bool>(n);\n    }\n    void add_edge(int f, int t){\n        g[f].push_back(t);\n        rg[t].push_back(f);\n    }\n    int init(){\n        rep(i,n)if(!used[i])dfs(i);\n        int k=0;\n        used=vector<bool>(n,false);\n        per(i,n){\n            if(!used[vs[i]]){\n                rdfs(vs[i],k);\n                k++;\n            }\n        }\n        return k;\n    }\n    private:\n    void dfs(int v){\n        used[v]=true;\n        rep(i,g[v].size()){\n            if(!used[g[v][i]])dfs(g[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v]=true;cmp[v]=k;\n        rep(i,rg[v].size()){\n            if(!used[rg[v][i]]){\n                rdfs(rg[v][i],k);\n            }\n        }\n    }\n};\n\nint main(){\n    ll n,d;cin >> n >>d;\n    SCC g(2*n);\n    vl x(n),y(n);rep(i,n)cin >> x[i] >> y[i];\n    rep(i,n){\n        repl(j,i+1,n){\n            if(abs(x[i]-x[j])<d){\n                g.add_edge(i,j+n);\n                g.add_edge(j,i+n);\n\n            }\n            if(abs(x[i]-y[j])<d){\n                g.add_edge(i,j);\n                g.add_edge(j+n,i+n);\n            }\n            if(abs(y[i]-x[j])<d){\n                g.add_edge(i+n,j+n);\n                g.add_edge(j,i);\n            }\n            if(abs(y[i]-y[j])<d){\n                g.add_edge(i+n,j);\n                g.add_edge(j+n,i);\n            }\n        }\n    }\n    g.init();\n    bool ok=true;\n    rep(i,n){\n        if(g.cmp[i]==g.cmp[i+n])ok=false;\n    }\n    if(ok){\n        cout << \"Yes\" <<endl;\n        rep(i,n){\n            if(g.cmp[i]>g.cmp[i+n])cout << x[i] <<endl;\n            else cout << y[i] <<endl;\n        }\n    }\n    else{\n        cout << \"No\" <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nclass SCC {\npublic:\n\tstatic const int MV = 2025000;\n\tvector<vector<int> > SC; int NV,GR[MV];\nprivate:\n\tvector<int> E[MV], RE[MV], NUM; int vis[MV];\npublic:\n\tvoid init(int NV) { this->NV=NV; for(int i=0;i<NV;i++) { E[i].clear(); RE[i].clear();}}\n\tvoid add_edge(int x,int y) { E[x].push_back(y); RE[y].push_back(x); }\n\tvoid dfs(int cu) { vis[cu]=1; for(int i=0;i<E[cu].size();i++) if(!vis[E[cu][i]]) dfs(E[cu][i]); NUM.push_back(cu); }\n\tvoid revdfs(int cu, int ind) { int i; vis[cu]=1; GR[cu]=ind; SC[ind].push_back(cu);\n\t\tFOR(i,RE[cu].size()) if(!vis[RE[cu][i]]) revdfs(RE[cu][i],ind);}\n\tvoid scc() {\n\t\tint c=0,i; SC.clear(); SC.resize(NV); NUM.clear();\n\t\tassert(NV);\n\t\tFOR(i,NV) vis[i]=0; FOR(i,NV) if(!vis[i]) dfs(i); FOR(i,NV) vis[i]=0;\n\t\tfor(int i=NUM.size()-1;i>=0;i--) if(!vis[NUM[i]]){\n\t\t\tSC[c].clear(); revdfs(NUM[i],c); sort(SC[c].begin(),SC[c].end()); c++;\n\t\t}\n\t\tSC.resize(c);\n\t}\n};\n\nclass TwoSat {\n\tint NV;\n\tSCC sc;\npublic:\n\tvector<int> val;\n\tvoid init(int NV) { this->NV=NV*2; sc.init(NV*2); val.resize(NV);}\n\tvoid add_edge(int x,int y) { // k+0:normal k+NV:inverse\n\t\tsc.add_edge((x+NV/2)%NV,y);\n\t\tsc.add_edge((y+NV/2)%NV,x);\n\t}\n\tbool sat() { // empty:false \n\t\tsc.scc();\n\t\tfor(int i=0;i<NV/2;i++) if(sc.GR[i]==sc.GR[i+NV/2]) return false;\n\t\tfor(int i=0;i<NV/2;i++) val[i]=sc.GR[i]>sc.GR[i+NV/2];\n\t\treturn true;\n\t}\n};\n\nint N,D;\nint X[1010],Y[1010];\nTwoSat ts;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>D;\n\tts.init(N);\n\tFOR(i,N) cin>>X[i]>>Y[i];\n\tFOR(y,N) FOR(x,y) {\n\t\tif(abs(X[x]-X[y])<D) ts.add_edge(x+N,y+N);\n\t\tif(abs(Y[x]-Y[y])<D) ts.add_edge(x,y);\n\t\tif(abs(X[x]-Y[y])<D) ts.add_edge(x+N,y);\n\t\tif(abs(Y[x]-X[y])<D) ts.add_edge(x,y+N);\n\t}\n\tif(ts.sat()) {\n\t\tcout<<\"Yes\"<<endl;\n\t\tFOR(i,N) {\n\t\t\tif(ts.val[i]) cout<<X[i]<<endl;\n\t\t\telse cout<<Y[i]<<endl;\n\t\t}\n\t}\n\telse {\n\t\tcout<<\"No\"<<endl;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    int n,d;\n    cin >> n >> d;\n    two_sat ts(n);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(abs(x[i]-x[j])<d){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(y[i]-y[j]<d)){\n                ts.add_clause(i,true,j,true);\n            }\n            if(abs(x[i]-y[j])<d){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(y[i]-x[j])<d){\n                ts.add_clause(i,false,j,true);\n            }\n        }\n    }\n    if(!ts.satisfied()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans=ts.answer();\n    rep(i,n){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n// #include<ext/pb_ds/assoc_container.hpp>\n// #include<ext/pb_ds/tree_policy.hpp>\n// #include<ext/pb_ds/tag_and_trait.hpp>\n// using namespace __gnu_pbds;\n// #include<boost/multiprecision/cpp_int.hpp>\n// namespace multiprecisioninteger = boost::multiprecision;\n// using cint=multiprecisioninteger::cpp_int;\nusing namespace std;\nusing ll=long long;\n#define double long double\nusing datas=pair<ll,ll>;\nusing ddatas=pair<double,double>;\nusing tdata=pair<ll,datas>;\nusing vec=vector<ll>;\nusing mat=vector<vec>;\nusing pvec=vector<datas>;\nusing pmat=vector<pvec>;\n// using llset=tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>;\n#define For(i,a,b) for(i=a;i<(ll)b;++i)\n#define bFor(i,b,a) for(i=b,--i;i>=(ll)a;--i)\n#define rep(i,N) For(i,0,N)\n#define rep1(i,N) For(i,1,N)\n#define brep(i,N) bFor(i,N,0)\n#define brep1(i,N) bFor(i,N,1)\n#define all(v) (v).begin(),(v).end()\n#define allr(v) (v).rbegin(),(v).rend()\n#define vsort(v) sort(all(v))\n#define vrsort(v) sort(allr(v))\n#define endl \"\\n\"\n#define eb emplace_back\n#define print(v) cout<<v<<endl\n#define printyes cout<<\"Yes\"<<endl\n#define printno cout<<\"No\"<<endl\n#define printYES cout<<\"YES\"<<endl\n#define printNO cout<<\"NO\"<<endl\n#define output(v) do{bool f=0;for(auto outi:v){cout<<(f?\" \":\"\")<<outi;f=1;}cout<<endl;}while(0)\n#define matoutput(v) do{for(auto outimat:v)output(outimat);}while(0)\nconst ll mod=1000000007;\n// const ll mod=998244353;\nconst ll inf=1LL<<60;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\ntemplate<class T> inline bool chmax(T& a,T b){bool x=a<b;if(x)a=b;return x;} \ntemplate<class T> inline bool chmin(T& a,T b){bool x=a>b;if(x)a=b;return x;} \n\nvoid startupcpp(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(15);\n}\nstruct scc_graph{\npublic:\n  scc_graph(int n):_n(n){}\n\n  void add_edge(int from,int to){\n    assert(0<=from&&from<_n);\n    assert(0<=to&&to<_n);\n    edges.push_back({from,{to}});\n  }\n  void add_clause(int i,bool f,int j,bool g){\n    assert(0<=i&&i*2<_n);\n    assert(0<=j&&j*2<_n);\n    add_edge(i<<1|!f,j<<1|g);\n    add_edge(j<<1|!g,i<<1|f);\n  }\n  //n must be *2\n  vector<bool> solve_twosat(){\n    auto id=scc_ids().second;\n    int m=_n>>1;\n    vector<bool> answer(m);\n    for(int i=0;i<m;++i){\n      if(id[i<<1]==id[i<<1|1])return{};\n      answer[i]=id[i<<1]<id[i<<1|1];\n    }\n    return answer;\n  }\n\n  vector<vector<int>> scc(){\n    auto ids=scc_ids();\n    int group_num=ids.first;\n    vector<int> counts(group_num);\n    for(auto x:ids.second)counts[x]++;\n    vector<vector<int>> groups(ids.first);\n    for(int i=0;i<group_num;++i){\n      groups[i].reserve(counts[i]);\n    }\n    for(int i=0;i<_n;++i){\n      groups[ids.second[i]].push_back(i);\n    }\n    return groups;\n  }\n\nprivate:\n  int _n;\n  struct edge{\n    int to;\n  };\n  struct csr{\n    vector<int> start;\n    vector<edge> elist;\n    csr(int n,const vector<pair<int,edge>>& edges):start(n+1),elist(edges.size()){\n      for(auto& e:edges)++start[e.first+1];\n      for(int i=0;i<n;++i)start[i+1]+=start[i];\n      auto counter=start;\n      for(auto& e:edges)elist[counter[e.first]++]=e.second;\n    }\n  };\n  vector<pair<int,edge>> edges;\n  // @return pair of(# of scc,scc id)\n  pair<int,vector<int>> scc_ids(){\n    auto g=csr(_n,edges);\n    int now_ord=0,group_num=0;\n    vector<int> visited,low(_n),ord(_n,-1),ids(_n);\n    visited.reserve(_n);\n    auto dfs=[&](auto self,int v)-> void{\n      low[v]=ord[v]=now_ord++;\n      visited.push_back(v);\n      for(int i=g.start[v];i<g.start[v+1];++i){\n        auto to=g.elist[i].to;\n        if(ord[to]==-1){\n          self(self,to);\n          low[v]=min(low[v],low[to]);\n        }else{\n          low[v]=min(low[v],ord[to]);\n        }\n      }\n      if(low[v]==ord[v]){\n        while(true){\n          int u=visited.back();\n          visited.pop_back();\n          ord[u]=_n;\n          ids[u]=group_num;\n          if(u==v)break;\n        }\n        group_num++;\n      }\n    };\n    for(int i=0;i<_n;++i){\n      if(ord[i]==-1)dfs(dfs,i);\n    }\n    for(auto& x:ids){\n      x=group_num-1-x;\n    }\n    return {group_num,ids};\n  }\n};\nint main(){\n  startupcpp();\n  int i,j,a,b,N,D;\n  cin>>N>>D;\n  vector<vector<int>> g(N,vector<int>(2));\n  scc_graph sg(N<<1);\n  rep(i,N){\n    cin>>g[i][0]>>g[i][1];\n  }\n  rep(i,N)For(j,i+1,N){\n    rep(a,2)rep(b,2)if(abs(g[i][a]-g[j][b])<D)sg.add_clause(i,a==0,j,b==0);\n  }\n  auto v=sg.solve_twosat();\n  if(!v.size()){\n    printno;\n    return 0;\n  }\n  printyes;\n  rep(i,N)print(g[i][v[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing     ll=long long;\nusing    vll=vector<   ll>;\nusing   vvll=vector<  vll>;\nusing  vvvll=vector< vvll>;\nusing vvvvll=vector<vvvll>;\nconstexpr ll INF = 1LL << 60;\nstruct Fast{ Fast(){ cin.tie(0); ios::sync_with_stdio(false); cout<<fixed<<setprecision(numeric_limits<double>::max_digits10); } } fast;\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){ T m=v[S]; rep(i,S,E)chmax(m,v[i]); return m; }\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){ T m=v[S]; rep(i,S,E)chmin(m,v[i]); return m; }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v,0,(ll)v.size()-1); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v,0,(ll)v.size()-1); }\ntemplate<class T> inline T Sum(vector<T> &v,ll S,ll E){ T s=T(); rep(i,S,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v,0,v.size()-1); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ninline ll CEIL(ll a,ll b){ return (a<0) ? -(-a/b) : (a+b-1)/b; }\ninline ll FLOOR(ll a,ll b){ return -CEIL(-a,b); }\n\n#if 1\n#include <atcoder/all>\n#endif\nusing namespace atcoder;\n\n\nvoid solve()\n{\n\tll n,d;  cin >> n >> d;\n\tvector<pair<ll,ll>> xy(n);\n\trep(i,0,n-1){ ll x; ll y; cin>>x>>y; xy[i]={x,y}; }\n\n\ttwo_sat ts(n);\n\n\trep(i,0,n-1){\n\t\trep(j,i+1,n-1){\n\t\t\tll xi,yi;  tie(xi,yi) = xy[i];\n\t\t\tll xj,yj;  tie(xj,yj) = xy[j];\n\n\t\t\tif (abs(xi-xj)<d){\n\t\t\t\tts.add_clause(i,false,j,false);\n\t\t\t}\n\t\t\tif (abs(yi-yj)<d){\n\t\t\t\tts.add_clause(i,true,j,true);\n\t\t\t}\n\t\t\tif (abs(yi-xj)<d){\n\t\t\t\tts.add_clause(i,true,j,false);\n\t\t\t}\n\t\t\tif (abs(xi-yj)<d){\n\t\t\t\tts.add_clause(i,false,j,true);\n\t\t\t}\n\t\t}\n\t}\n\tif (!ts.satisfiable()){\n\t\tcout << \"No\" << '\\n';return;\n\t}\n\tcout << \"Yes\" << '\\n';\n\tauto ans=ts.answer();\n\trep(i,0,n-1){\n\t\tll xi,yi;  tie(xi,yi) = xy[i];\n\t\tif (ans[i]){\n\t\t\tcout << xi << '\\n';\n\t\t}\n\t\telse{\n\t\t\tcout << yi << '\\n';\n\t\t}\n\t}\n}\n\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#include <atcoder/all>\n#define popcount __builtin_popcount\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, d;\n\tscanf(\"%d %d\", &n, &d);\n\tint x[2][1010];\n\tfor(int i=0; i<n; i++) scanf(\"%d %d\", &x[0][i], &x[1][i]);\n\ttwo_sat ts(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<i; j++){\n\t\t\tfor(int k=0; k<2; k++) for(int l=0; l<2; l++) if(abs(x[k][i]-x[l][j])<d) ts.add_clause(i, k^1, j, l^1);\n\t\t}\n\t}\n\tif(ts.satisfiable()){\n\t\tprintf(\"Yes\\n\");\n\t\tauto b=ts.answer();\n\t\tfor(int i=0; i<n; i++) printf(\"%d\\n\", x[b[i]][i]);\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x.at(i) >> y.at(i);\n    }\n    two_sat ts(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x.at(i) - x.at(j)) < d) ts.add_clause(i, false, j, false);\n            if (abs(x.at(i) - y.at(j)) < d) ts.add_clause(i, false, j, true);\n            if (abs(y.at(i) - x.at(j)) < d) ts.add_clause(i, true, j, false);\n            if (abs(y.at(i) - y.at(j)) < d) ts.add_clause(i, true, j, true);\n        }\n    }\n    if (not ts.satisfiable()) {\n        cout << \"No\" << endl;\n    } else {\n        cout << \"Yes\" << endl;\n        auto p = ts.answer();\n        for (int i = 0; i < n; i++) {\n            if (p[i]) {\n                cout << x.at(i) << endl;\n            } else {\n                cout << y.at(i) << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\n#include <atcoder/twosat>\n//python3 ac-library/expander.py sol.cpp\n\nint main(){\n   int n,d; cin>>n>>d;\n   vector<int> x(n),y(n);\n   rep(i,0,n)cin>>x[i]>>y[i];\n   atcoder::two_sat g(n*2);\n   rep(i,0,n)g.add_clause(i,1,i+n,1);\n   rep(i,0,n)rep(j,0,n)if(i!=j){\n      if(abs(x[i]-x[j])<d){\n         g.add_clause(i,0,j,0);\n      }\n      if(abs(y[j]-y[i])<d){\n         g.add_clause(j+n,0,i+n,0);\n      }\n      if(abs(x[j]-y[i])<d){\n         g.add_clause(j,0,i+n,0);\n      }\n      if(abs(y[j]-x[i])<d){\n         g.add_clause(j+n,0,i,0);\n      }\n   }\n   bool can=g.satisfiable();\n   if(can){\n      puts(\"Yes\");\n      auto res=g.answer();\n      rep(i,0,n){\n         if(res[i])cout<<x[i]<<endl;\n         else cout<<y[i]<<endl;\n      }\n   }\n   else puts(\"No\");\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); i++)\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    scc_graph scc;\n};\n\nint main(){\n  int n,d; cin>>n>>d;\n  vector<int> x(n),y(n);\n  rep(i,n) cin>>x[i]>>y[i];\n\n  two_sat ts(n);\n\n  rep(i,n){\n    for(int j=i+1;j<n;j++){\n      if(abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n      if(abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n      if(abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n      if(abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n    }\n  }\n\n  if(!ts.satisfiable()){\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  cout << \"Yes\" << endl;\n  auto answer = ts.answer();\n  rep(i,n){\n    if(answer[i]){\n      cout << x[i] << endl;\n    }else{\n      cout << y[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FASTIO\n//using namespace std;\n#include <atcoder/all>\n\nusing ll = long long;\nusing Vi = std::vector<int>;\nusing Vl = std::vector<ll>;\nusing Pii = std::pair<int, int>;\nusing Pll = std::pair<ll, ll>;\n\nconstexpr int I_INF = std::numeric_limits<int>::max();\nconstexpr ll L_INF = std::numeric_limits<ll>::max();\n\ntemplate <typename T1, typename T2>\ninline bool chmin(T1& a, const T2& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1& a, const T2& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nclass Prints {\nprivate:\n    class __Prints {\n    public:\n        __Prints(const char* sep, const char* term) : sep(sep), term(term) {}\n        template <class... Args>\n        void operator()(const Args&... args) const { print(args...); }\n        template <typename T>\n        void pvec(const T& vec, size_t sz) const {\n            for (size_t i = 0; i < sz; i++)\n                std::cout << vec[i] << (i == sz - 1 ? term : sep);\n        }\n        template <typename T>\n        void pmat(const T& mat, size_t h, size_t w) {\n            for (size_t i = 0; i < h; i++)\n                for (size_t j = 0; j < w; j++)\n                    std::cout << mat[i][j] << (j == w - 1 ? term : sep);\n        }\n\n    private:\n        const char *sep, *term;\n        void print() const { std::cout << term; }\n        void print_rest() const { std::cout << term; }\n        template <class T, class... Tail>\n        void print(const T& head, const Tail&... tail) const { std::cout << head, print_rest(tail...); }\n        template <class T, class... Tail>\n        void print_rest(const T& head, const Tail&... tail) const { std::cout << sep << head, print_rest(tail...); }\n    };\n\npublic:\n    Prints() {}\n    __Prints operator()(const char* sep = \" \", const char* term = \"\\n\") const { return __Prints(sep, term); }\n};\n\nPrints prints;\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nvoid solve() {\n    int N, D;\n    std::cin >> N >> D;\n    Vl xs(N), ys(N);\n    for (ll i = 0; i < N; i++) {\n        std::cin >> xs[i] >> ys[i];\n    }\n    atcoder::two_sat ts(N);\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            if (abs(xs[i] - xs[j]) < D) ts.add_clause(i, false, j, false);\n            if (abs(xs[i] - ys[j]) < D) ts.add_clause(i, false, j, true);\n            if (abs(ys[i] - xs[j]) < D) ts.add_clause(i, true, j, false);\n            if (abs(ys[i] - ys[j]) < D) ts.add_clause(i, true, j, true);\n        }\n    }\n    bool ok = ts.satisfiable();\n    if (!ok) {\n        prints()(\"No\");\n        return;\n    }\n    auto res = ts.answer();\n    prints()(\"Yes\");\n    for (ll i = 0; i < N; i++) {\n        prints()(res[i] ? xs[i] : ys[i]);\n    }\n}\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nint main() {\n#ifdef FASTIO\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n#endif\n#ifdef FILEINPUT\n    std::ifstream ifs(\"./in_out/input.txt\");\n    std::cin.rdbuf(ifs.rdbuf());\n#endif\n#ifdef FILEOUTPUT\n    std::ofstream ofs(\"./in_out/output.txt\");\n    std::cout.rdbuf(ofs.rdbuf());\n#endif\n    std::cout << std::setprecision(18) << std::fixed;\n    solve();\n    std::cout << std::flush;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <charconv>\n#include <climits>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nconstexpr size_t MAX_SIZE = 22020;\nchar buf[MAX_SIZE];\nstruct Input {\n\tsize_t i;\n\tInput() {\n\t\ti = 0;\n\t\tfread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\treturn buf[i++];\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void putui(int v) noexcept {\n\tchar buf[11]{};\n\tauto [ptr, e] = to_chars(begin(buf), end(buf), v);\n\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n}\ninline void putul(ll v) noexcept {\n\tchar buf[20]{};\n\tauto [ptr, e] = to_chars(begin(buf), end(buf), v);\n\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d, x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + !f, 2 * j + g);\n\t\tscc.add_edge(2 * j + !g, 2 * i + f);\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\nconstexpr bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\nconstexpr bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n, d;\n  cin >> n >> d;\n  vi x(n), y(n);\n  rep(i, n){\n    cin >> x[i] >> y[i];\n  }\n  two_sat ts(n);\n  rep(i, n)repr(j, i+1, n){\n    if(abs(x[i]-x[j]) < d) ts.add_clause(i, 1, j, 1);\n    if(abs(x[i]-y[j]) < d) ts.add_clause(i, 1, j, 0);\n    if(abs(y[i]-x[j]) < d) ts.add_clause(i, 0, j, 1);\n    if(abs(y[i]-y[j]) < d) ts.add_clause(i, 0, j, 0);\n  }\n  auto ans = ts.satisfiable();\n  if(ans){\n    print(\"Yes\");\n    int i = 0;\n    for(auto&& e: ts.answer()){\n      print(e ? y[i] : x[i]);\n      i++;\n    }\n  }else{\n    print(\"No\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nstruct SCC{\n  ll n;\n  vector<vector<ll>>&G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>&g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,bool tx,ll y,bool ty){//x+n:true x:false\n    //cout<<x spa tx spa y spa ty<<endl;\n    g[x+tx*n].push_back(y+!ty*n);\n    g[y+ty*n].push_back(x+!tx*n);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] > scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,d;cin>>n>>d;\n  auto v=vec(n,2,0LL);\n  rep(i,0,n)cin>>v[i][0]>>v[i][1];\n  TwoSat sat(n);\n  rep(i,0,n)rep(ti,0,2)rep(j,i+1,n)rep(tj,0,2){\n    if(abs(v[i][ti]-v[j][tj])<d){\n      sat.add_or(i,!ti,j,!tj);\n    }\n  }\n  judge=sat.solve(true);\n  ans1(judge);\n  if(judge){\n    rep(i,0,n)cout<<v[i][sat.ans[i]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include \"pch.h\"\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <climits>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <fstream>\n#include <stack>\n#include <random>\n#include <atcoder/twosat>\n\ntypedef long long ll;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<long long, long long> Pll;\ntypedef std::pair<double, double> Pdd;\n\n#define rip(i, n, s) for (int i = (s);i < (int)( n ); i++)\n#define all(a) a.begin(), a.end()\n#define MM << \" \" <<\n\ntemplate<typename T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate<typename T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<typename T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nvoid vdeb(std::vector<T> &da) {\n    for (int i = 0;i < da.size();i++) {\n        if (i == da.size() - 1) std::cout << da[i];\n        else std::cout << da[i] << ' ';\n    }\n    std::cout << '\\n';\n}\ntemplate<typename T>\nvoid vdeb(std::vector<std::vector<T>> &da) {\n    for (int i = 0;i < da.size();i++) {\n        std::cout << i << ' ';\n        vdeb(da[i]);\n    }\n    std::cout << '\\n';\n}\n\nusing namespace std;\nnamespace ac = atcoder;\n\nint main() {\n    ll n,d; cin >> n >> d;\n    vector<Pll> da(n);\n    rip(i,n,0) cin >> da[i].first >> da[i].second;\n    ac::two_sat g(n);\n    rip(i,n,0) {\n        rip(j,i,0) {\n            if(abs(da[i].first-da[j].first) < d) g.add_clause(i,false,j,false);\n            if(abs(da[i].first-da[j].second) < d) g.add_clause(i,false,j,true);\n            if(abs(da[i].second-da[j].first) < d) g.add_clause(i,true,j,false);\n            if(abs(da[i].second-da[j].second) < d) g.add_clause(i,true,j,true);\n        }\n    }\n    if(g.satisfiable()) {\n        printf(\"Yes\\n\");\n        auto ans = g.answer();\n        rip(i,n,0) {\n            if(ans[i]) printf(\"%lld\\n\", da[i].first);\n            else printf(\"%lld\\n\", da[i].second);\n        }\n    }\n    else {\n        printf(\"No\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i,n) for (int i = 0; i < (int)(n); i ++)\n#define irep(i,n) for (int i = (int)(n) - 1;i >= 0;--i)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;// = 998244353;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N,D;cin >> N >> D;\n    vector<int> X(N),Y(N);\n    rep(i,N) cin >> X[i] >> Y[i];\n\n    two_sat ts(2*N);\n    rep(i,N) {\n        ts.add_clause(i,true,i + N,true);\n        ts.add_clause(i,false,i + N,false);\n    }\n    rep(i,N) {\n        for (int j = i + 1;j < N; ++j) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i + N,true,j + N,true);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i + N,true,j,true);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i,true,j + N,true);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i,true,j,true);\n            }\n        }\n    }\n    if (!ts.satisfiable()) {\n        cout << \"No\" << '\\n';\n        return 0;\n    }\n    auto ans = ts.answer();\n    cout << \"Yes\" << '\\n';\n    rep(i,N) {\n        cout << (ans[i] ? X[i]:Y[i]) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << endl\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, d;\n    cin >> n >> d;\n    vector<P> v(n);\n    rep(i, n) cin >> v[i].first >> v[i].second;\n    two_sat g(n);\n    rep(i, n) rep(j, i) {\n        rep(ii, 2) {\n            rep(jj, 2) {\n                if (abs(v[i].first-v[j].first)<d) {\n                    g.add_clause(i, ii==0, j, jj==0);\n                }\n                swap(v[j].first, v[j].second);\n            }\n            swap(v[i].first, v[i].second);\n        }\n    }\n    bool ok = g.satisfiable();\n    if (!ok) {\n        pr(\"No\");\n        return 0;\n    }\n    pr(\"Yes\");\n    auto ans = g.answer();\n\n    rep(i, n) {\n        if (!ans[i]) pr(v[i].first);\n        else pr(v[i].second);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define STRING(str) #str\n#define ll long long\n\ntemplate <typename T >\nvoid print_vec_1d(vector<T> x, string name) {\n\tcout << name << endl;\n\tcout << \"[ \";\n\tfor (int i=0;i<x.size();i++) {\n\t\tcout << x[i];\n\t\tif (i != x.size()-1) cout << \", \";\n\t\telse cout << \" ]\" << endl;\n\t}\n}\n\nint main() {\n\tint N, D;\n\tcin >> N >> D;\n\tvector<int> X(N), Y(N);\n\tfor (int i=0;i<N;i++) {\n\t\tcin >> X[i];\n\t\tcin >> Y[i];\n\t}\n\n\ttwo_sat ts(N);\n\tfor (int i=0;i<N;i++) {\n\t\tfor (int j=i+1;j<N;j++) {\n\t\t\tif (abs(X[i]-X[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(X[i]-Y[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(Y[i]-X[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(Y[i]-Y[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> ans = ts.answer();\n\t\tfor (int i=0;i<N;i++) {\n\t\t\tif (ans[i]) {\n\t\t\t\tcout << X[i] << endl;\n\t\t\t} else {\n\t\t\t\tcout << Y[i] << endl;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nstruct SCC{\n  ll n;\n  vector<vector<ll>>&G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>&g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,bool tx,ll y,bool ty){//x+n:true x:false\n    g[x+!tx*n].push_back(y+ty*n);\n    g[y+!ty*n].push_back(x+tx*n);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] < scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,d;cin>>n>>d;\n  auto v=vec(n,2,0LL);\n  rep(i,0,n)cin>>v[i][0]>>v[i][1];\n  TwoSat sat(n);\n  rep(i,0,n)rep(ti,0,2)rep(j,i+1,n)rep(tj,0,2){\n    if(abs(v[i][ti]-v[j][tj])<d){\n      sat.add_or(i,!ti,j,!tj);\n    }\n  }\n  judge=sat.solve(true);\n  ans1(judge);\n  if(judge){\n    rep(i,0,n)cout<<v[i][sat.ans[i]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n\tint N, D;\n\tcin >> N >> D;\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t\t\tif (abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n\t\t\tif (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\t}\n\t}\n\tbool ans = ts.satisfiable();\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\tif (ans) {\n\t\tvector<bool> b = ts.answer();\n\t\tfor (int i = 0; i < N; i++) cout << (b[i] ? X[i] : Y[i]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#include <bits/stdc++.h>\n#define rep(a,n) for (ll a = 0; a < (n); ++a)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<vector<int> > Graph;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst ll INF = 1e18;\n\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll n,d;\n    cin >> n >> d;\n    vector<ll>x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    two_sat ts(n);\n    rep(i,n){\n        rep(j,n){\n            if(i>=j)continue;\n            if(abs(x[i]-x[j])<d)ts.add_clause(i,false,j,false);\n            if(abs(x[i]-y[j])<d)ts.add_clause(i,false,j,true);\n            if(abs(y[i]-x[j])<d)ts.add_clause(i,true,j,false);\n            if(abs(y[i]-y[j])<d)ts.add_clause(i,true,j,true);\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    rep(i,n){\n        if(ans[i]){\n            cout << x[i] << endl;\n        }\n        else{\n            cout << y[i] << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\n#ifdef LOCAL\n#define DEBUG(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define DEBUG(...) 6;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) {bool f = true; os << \"[\"; for (const auto &x : c) {if (!f) os << \", \"; f = false; os << x;} return os << \"]\";}\ntemplate<typename T> void debug(string s, T x) {cerr << s << \" = \" << x << \"\\n\";}\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) {cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...);}\n\nint x[1005], y[1005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    int n, d;\n    cin >> n >> d;\n    two_sat ts(n);\n    for (int i=0; i<n; i++) {\n        cin >> x[i] >> y[i];\n        for (int j=0; j<i; j++) {\n            if (abs(x[i] - x[j]) < d)\n                ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d)\n                ts.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < d)\n                ts.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < d)\n                ts.add_clause(i, true, j, true);\n        }\n    }\n\n    if (ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        auto ret = ts.answer();\n        for (int i=0; i<n; i++)\n            cout << (ret[i] ? x[i] : y[i]) << \"\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\n\n// #LIB#\n\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\n#define double long double\n#define rep(i, n) for (long long i = 0; i < (n); ++i)\n#define repr(i, a, b) for (auto i = (a); i < (b); ++i)\n#define itr(x, c) for (auto&& x : (c))\n#define updatemax(t, v) ((t) = std::max((t), (v)))\n#define updatemin(t, v) ((t) = std::min((t), (v)))\n#ifdef ONLINE_JUDGE\n#define endl _endl\nconst char _endl = (cin.tie(0), cout.tie(0), ios::sync_with_stdio(0), cout.precision(16), '\\n');\n#endif\n\nconst string Yes = \"Yes\";\nconst string No = \"No\";\nint main() {\n  ll n, d;\n  cin >> n >> d;\n  vector<ll> x(n), y(n);\n  rep(i, n) cin >> x[i] >> y[i];\n  two_sat ts(2 * n);\n  rep(i, n) {\n    ts.add_clause(i, false, i + n, false);\n    ts.add_clause(i, true, i + n, true);\n  }\n  rep(i, n) repr(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n    if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n    if (abs(y[i] - x[j]) < d) ts.add_clause(i + n, false, j, false);\n    if (abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n  }\n  auto sat = ts.satisfiable();\n  if (sat) {\n    cout << Yes << endl;\n    auto ans = ts.answer();\n    rep(i, n) cout << (ans[i] ? x : y)[i] << endl;\n  } else {\n    cout << No << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int64 N, D;\n  cin >> N >> D;\n  two_sat sat(N);\n  vector<int64> X(N), Y(N);\n  REP(i, N) {\n    cin >> X[i] >> Y[i];\n  }\n  REP(i, N) {\n    REP(j, N) {\n      if (i == j) continue;\n      if (abs(X[i] - X[j]) < D)\n        sat.add_clause(i, false, j, false);\n      if (abs(X[i] - Y[j]) < D)\n        sat.add_clause(i, false, j, true);\n      if (abs(Y[i] - X[j]) < D)\n        sat.add_clause(i, true, j, false);\n      if (abs(Y[i] - Y[j]) < D)\n        sat.add_clause(i, true, j, true);\n    }\n  }\n  if (sat.satisfiable()) {\n    cout << \"Yes\" << endl;\n    auto ans = sat.answer();\n    REP(i, ans.size()) {\n      cout << (ans[i] ? X[i] : Y[i]) << endl;\n    }\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <random>\n#include <chrono>\n#include <algorithm>\n#define rep(i, x) for(ll i = 0; i < x; i++)\n#define CONCAT_(x,y) x##y\n#define CONCAT(x,y) CONCAT_(x,y)\n#define _v1 CONCAT(qyw1, __LINE__) // unique name in same line (otherwise use __COUNTER__)\n#define _v2 CONCAT(qyw2, __LINE__)\n#define forbits(i, m) for (int _v1 = m, i = __builtin_ctz(_v1); _v1 != 0; _v1 ^= _v1 & -_v1, i = __builtin_ctz(_v1))\n#define forsubm(s, m) for (int s = m; s >= 0; s = !s ? -1 : m & (s - 1))\nint __nextXZW(int v){int t=v|(v-1);int w=(t+1)|(((~t&-~t)-1)>>(__builtin_ctz(v)+1));return w;}\n#define ksets(i, n, k) for (int i = (1u << k) - 1, max = i << (n - k); i <= max; i = __nextXZW(i))\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = (ll)1e9+7;\nconst ll N = 5e5+5, inf = 1e9+5000;\nll add(ll x, ll y) { x += y; if (x >= MOD) return x - MOD; return x; }\nll sub(ll x, ll y) { x -= y; if (x < 0) return x + MOD; return x; }\nll mult(ll x, ll y) { return (x * y) % MOD; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n#include <atcoder/twosat>\nusing namespace atcoder; \n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n, d; cin >> n >> d;\n\n  two_sat SAT(n);\n  vector<pair<int, int>> flags(n);\n  rep (i, n) {\n    int x, y; cin >> x >> y;\n    flags[i] = {x, y};\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      if (abs(flags[i].first-flags[j].first) < d) {\n        SAT.add_clause(i, 1, j, 1);\n      }\n      if (abs(flags[i].first-flags[j].second) < d) {\n        SAT.add_clause(i, 1, j, 0);\n      }\n      if (abs(flags[i].second-flags[j].first) < d) {\n        SAT.add_clause(i, 0, j, 1);\n      }\n      if (abs(flags[i].second-flags[j].second) < d) {\n        SAT.add_clause(i, 0, j, 0);\n      }\n    }\n  }\n\n  if (!SAT.satisfiable()) {\n    cout << \"No\" << '\\n';\n  } else {\n    cout << \"Yes\" << '\\n';\n    auto answer = SAT.answer();\n    for (int i = 0; i < answer.size(); i++) {\n      if (answer[i]) cout << flags[i].second << '\\n';\n      else cout << flags[i].first << '\\n';\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i, n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, d, x, y;\n    cin >> n >> d;\n    int xy[n][2];\n    rep(i, n) {\n        cin >> x >> y;\n        xy[i][0] = x;\n        xy[i][1] = y;\n    }\n    two_sat ts(n);\n    for (int i=0; i<n-1; i++) for (int j=i+1; j<n; j++) rep(k, 2) rep(l, 2) {\n        if (abs(xy[i][k]-xy[j][l]<d)) ts.add_clause(i, 1-k, j, 1-l);\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, n) cout << xy[i][ans[i]] << \"\\n\";\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct SCC{\n  ll n;\n  vector<vector<ll>>G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,ll y){\n    g[(x+n)%(2*n)].PB(y);\n    g[(y+n)%(2*n)].PB(x);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] > scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  string tmp;cin>>tmp;cin>>tmp;\n  ll n,m;cin>>n>>m;\n  TwoSat sat(n);\n  rep(i,0,m){\n    ll x,y,v;cin>>x>>y>>v;\n    ll x2=(abs(x)-1)+(x<0)*n;\n    ll y2=(abs(y)-1)+(y<0)*n;\n    sat.add_or(x2,y2);\n  }\n  \n  if(!sat.solve(true)){\n    cout<<\"s UNSATISFIABLE\"<<endl;\n  }\n  else{\n    cout<<\"s SATISFIABLE\"<<endl;\n    cout<<\"v\";\n    rep(i,0,n){\n      ll k=i+1;\n      if(!sat.ans[i])k*=-1;\n      cout<<\" \"<<k;\n    }\n    cout<<\" 0\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E>\nstruct csr {\n  std::vector<int> start;\n  std::vector<E> elist;\n  csr(int n, const std::vector<std::pair<int, E>>& edges)\n      : start(n + 1), elist(edges.size()) {\n    for (auto e : edges) {\n      start[e.first + 1]++;\n    }\n    for (int i = 1; i <= n; i++) {\n      start[i] += start[i - 1];\n    }\n    auto counter = start;\n    for (auto e : edges) {\n      elist[counter[e.first]++] = e.second;\n    }\n  }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n public:\n  scc_graph(int n) : _n(n) {}\n\n  int num_vertices() { return _n; }\n\n  void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n  // @return pair of (# of scc, scc id)\n  std::pair<int, std::vector<int>> scc_ids() {\n    auto g = csr<edge>(_n, edges);\n    int now_ord = 0, group_num = 0;\n    std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n    visited.reserve(_n);\n    auto dfs = [&](auto self, int v) -> void {\n      low[v] = ord[v] = now_ord++;\n      visited.push_back(v);\n      for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n        auto to = g.elist[i].to;\n        if (ord[to] == -1) {\n          self(self, to);\n          low[v] = std::min(low[v], low[to]);\n        } else {\n          low[v] = std::min(low[v], ord[to]);\n        }\n      }\n      if (low[v] == ord[v]) {\n        while (true) {\n          int u = visited.back();\n          visited.pop_back();\n          ord[u] = _n;\n          ids[u] = group_num;\n          if (u == v) break;\n        }\n        group_num++;\n      }\n    };\n    for (int i = 0; i < _n; i++) {\n      if (ord[i] == -1) dfs(dfs, i);\n    }\n    for (auto& x : ids) {\n      x = group_num - 1 - x;\n    }\n    return {group_num, ids};\n  }\n\n  std::vector<std::vector<int>> scc() {\n    auto ids = scc_ids();\n    int group_num = ids.first;\n    std::vector<int> counts(group_num);\n    for (auto x : ids.second) counts[x]++;\n    std::vector<std::vector<int>> groups(ids.first);\n    for (int i = 0; i < group_num; i++) {\n      groups[i].reserve(counts[i]);\n    }\n    for (int i = 0; i < _n; i++) {\n      groups[ids.second[i]].push_back(i);\n    }\n    return groups;\n  }\n\n private:\n  int _n;\n  struct edge {\n    int to;\n  };\n  std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n public:\n  two_sat() : _n(0), scc(0) {}\n  two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n  void add_clause(int i, bool f, int j, bool g) {\n    assert(0 <= i && i < _n);\n    assert(0 <= j && j < _n);\n    scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n    scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n  }\n  bool satisfiable() {\n    auto id = scc.scc_ids().second;\n    for (int i = 0; i < _n; i++) {\n      if (id[2 * i] == id[2 * i + 1]) return false;\n      _answer[i] = id[2 * i] < id[2 * i + 1];\n    }\n    return true;\n  }\n  std::vector<bool> answer() { return _answer; }\n\n private:\n  int _n;\n  std::vector<bool> _answer;\n  internal::scc_graph scc;\n};\n\n}  // namespace atcoder\nusing namespace atcoder;\n\nusing namespace std;\n\nnamespace fastio {\nstatic constexpr int SZ = 1 << 17;\nchar ibuf[SZ], obuf[SZ];\nint pil = 0, pir = 0, por = 0;\n\nstruct Pre {\n  char num[40000];\n  constexpr Pre() : num() {\n    for (int i = 0; i < 10000; i++) {\n      int n = i;\n      for (int j = 3; j >= 0; j--) {\n        num[i * 4 + j] = n % 10 + '0';\n        n /= 10;\n      }\n    }\n  }\n} constexpr pre;\n\ninline void load() {\n  memcpy(ibuf, ibuf + pil, pir - pil);\n  pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);\n  pil = 0;\n}\ninline void flush() {\n  fwrite(obuf, 1, por, stdout);\n  por = 0;\n}\n\ninline void rd(char& c) { c = ibuf[pil++]; }\ntemplate <typename T>\ninline void rd(T& x) {\n  if (pil + 32 > pir) load();\n  char c;\n  do\n    c = ibuf[pil++];\n  while (c < '-');\n  bool minus = 0;\n  if (c == '-') {\n    minus = 1;\n    c = ibuf[pil++];\n  }\n  x = 0;\n  while (c >= '0') {\n    x = x * 10 + (c & 15);\n    c = ibuf[pil++];\n  }\n  if (minus) x = -x;\n}\ninline void rd() {}\ntemplate <typename Head, typename... Tail>\ninline void rd(Head& head, Tail&... tail) {\n  rd(head);\n  rd(tail...);\n}\n\ninline void wt(char c) { obuf[por++] = c; }\ntemplate <typename T>\ninline void wt(T x) {\n  if (por > SZ - 32) flush();\n  if (!x) {\n    obuf[por++] = '0';\n    return;\n  }\n  if (x < 0) {\n    obuf[por++] = '-';\n    x = -x;\n  }\n  int i = 12;\n  char buf[16];\n  while (x >= 10000) {\n    memcpy(buf + i, pre.num + (x % 10000) * 4, 4);\n    x /= 10000;\n    i -= 4;\n  }\n  int d = x < 100 ? (x < 10 ? 1 : 2) : (x < 1000 ? 3 : 4);\n  memcpy(obuf + por, pre.num + x * 4 + 4 - d, d);\n  por += d;\n  memcpy(obuf + por, buf + i + 4, 12 - i);\n  por += 12 - i;\n}\n\ninline void wt() {}\ntemplate <typename Head, typename... Tail>\ninline void wt(Head head, Tail... tail) {\n  wt(head);\n  wt(tail...);\n}\ntemplate<typename T>\ninline void wtn(T x){\n  wt(x, '\\n');\n}\n\nstruct Dummy {\n  Dummy() { atexit(flush); }\n} dummy;\n\n}  // namespace fastio\nusing fastio::rd;\nusing fastio::wt;\nusing fastio::wtn;\n\nint main() {\n  int N,D;\n  rd(N,D);\n  vector<int> X(N), Y(N);\n  for (int i = 0; i < N; i++) rd(X[i], Y[i]);\n  \n  two_sat ts(N);\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < i; j++) {\n      if(abs(X[i] - X[j]) < D)\n        ts.add_clause(i, 1, j, 1); \n      if(abs(X[i] - Y[j]) < D)\n        ts.add_clause(i, 1, j, 0); \n      if(abs(Y[i] - X[j]) < D)\n        ts.add_clause(i, 0, j, 1); \n      if(abs(Y[i] - Y[j]) < D)\n        ts.add_clause(i, 0, j, 0); \n    }\n  }\n  bool ok = ts.satisfiable();\n  if(!ok){\n    wt('N','o','\\n');\n    return 0;\n  }\n  wt('Y','e','s','\\n');\n  auto ans = ts.answer();\n  for(int i = 0; i < N; i++) {\n    wtn(ans[i] ? Y[i] : X[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//                               S i r o t a n   w a t c h e s   o v e r   y o u .\n//\n//                                          ...Jggg+J+JJJg@NQmgJa.....,       \n//                                 ....gH@@@@HHB\"\"\"\"7\"YYYYHMMMMMMM@@@@@@@Hma,.   \n//                            ...JH@@MMHY\"!                        ? __\"\"YH@@@@N&...     \n//                        ..JH@@HY\"~                                          _TW@@@Mme.    \n//                     .Jg@@#\"=                                                   _TTM@@N..     \n//                  .Jg@@MY!                                                          ?T@@@h,.   \n//                .-@@@B!                                                                (TM@@@L     \n//              .(H@MY                                                                      ?W@@@+    \n//             .W@@@                                                                          .T@@@[       \n//           .d@@M!                                                                             .T@@N,   \n//          .d@M@'                                                                                -W@@o. \n//         (@@M\\                                                                                    ?M@N,\n//        -d@M%                    ..,                                      ..,                      j@@b  \n//       d@@M=                     TM9                                      ?MD                       W@@[ \n//      .H@M:                                                                                         .W@H,\n//      H@Ht                                                                                           ,@@#   \n//     (@@M~                                                                                           .@@h.\n//    .@@M%                        ..gmHHJ.                             .JdHga.                        .H@@e  \n//    j@@#_                       .@@@@@@@b                            J@@@@@@@h.                      .H@@\\ \n//    d@@@                       .4@@@@@@MF                            (@@@@@@@@                        H@@b  \n//    d@@[                         ?\"BMY\"=            .d@@@@H,          ?TWHHY\"!                        d@@e    \n//    J@@b          .JJJ-..,                         ,@@@@@@M%                       .........         -@@@M. \n//    ?@@M\\         ?YHHM@@@@b                ..      .W@@HP                        X@@HMWY\"=          d@@@#\n//    ,@@@L.                                 ?H@Ng&+gd@@#H@@NHaJ+gH@[                                  J@@@] \n//     X@@@[            ......                 ?\"YYYYY\"\"   ?\"YHHHB\"^                 .....            (@@@#   \n//      WH@N+.      .W@@@@MHB=                                                      .TWH@M@Hmc       .H@@M~    \n//     .H@@@@N,      _!~                                                                            .d@@@N,   \n//   .J@@#T@@@N,                                                                                  .d@@@@@@@b. \n//  (@@@@! .T@@@n,                                                                              .(H@@@H>.W@@@x  \n// (@@@F      4@@@@MaJ.                                                                       .d@@@@Y77   4@@@r \n//.H@@P         ?TM@@@@N...                                                               .-JH@HMY=        d@@N,\n//(@@@F             ?\"WM@@@MQa-,.                                                  .(J(JN@@M#\"             Z@@@L\n// d@@H,                 (M@@@@@@@Ng&maJ....                           .. ...J.J+W@@@@@@HY!               .dH@b \n// ?M@@@N&.        ..(JW@@@MM\"?7\"\"TYHMH@@HH@@@@@HHHgkHagHa(mggdmmagH@H@@Q@@HMMMHY\"7!TMM@@@HaJ,.        ..H@@@M^ \n//   ?\"W@@@@MN@@@@@H@@MMY\"                  _???!\"= ?WMMBYYTMH=7\"\"Y@\"\"?\"~^             _\"YM@@@@@@@@MH@@@@@#\"^ \n//       ?77WMMMYB\"\"!                                                                        _7\"WWMMMY\"7=     \n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <fstream>\n\n//std::ifstream ifs(\"b.in\");\n//auto& scan_in = ifs;\nauto& scan_in = std::cin;\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { scan_in >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { scan_in >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { scan_in >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { scan_in >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)scan_in>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)scan_in>>w;\n// output\ntemplate<typename T>void MACRO_OUT(const T t) { std::cout << t; }\ntemplate<typename First, typename...Rest>void MACRO_OUT(const First first, const Rest...rest) { std::cout << first << \" \"; MACRO_OUT(rest...); }\n#define OUT(...) MACRO_OUT(__VA_ARGS__);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define VOUT(v) for(size_t i = 0; i < v.size(); ++i) {OUT(v[i]);if(i+1<v.size()){SP}}\n#define EOUT(...) do{ OUT(__VA_ARGS__)BR; exit(0); }while(0);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t: \" << (dist) << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define REP(w, n) FOR(w, 0, n)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define RREP(w, n) RFOR(w, 0, n)\ntemplate<class S, class T, class U> bool IN(S a, T x, U b) { return a <= x && x < b; }\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n\tos << \"{\";\n\tfor (size_t i = 0; i < v.size(); ++i) os << v[i] << ((i + 1 < v.size()) ? \", \" : \"\"); os << \"}\";\n\treturn os;\n}\ntemplate<typename T>\nstd::ostream & operator<<(std::ostream & os, const std::set<T> & v) {\n\tos << \"{\";\n\tfor (auto it = v.cbegin();;) {\n\t\tos << *it; ++it;\n\t\tif (it == v.cend()) { os << \"}\"; break; }\n\t\telse { os << \", \"; }\n\t}\n\treturn os;\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream & os, const std::map<S, T> & m) {\n\tos << \"{\";\n\tfor (auto it = m.cbegin(); it != m.cend();) { os << it->first << \":\" << it->second; ++it; os << (it == m.cend() ? \"\" : \", \"); } os << \"}\";\n\treturn os;\n}\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream & os, std::queue<T> q) {\n\tos << \"<\";\n\twhile (!q.empty()) { os << q.front(); q.pop(); os << (q.empty() ? \"<\" : \", \"); }\n\treturn os;\n}\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream & os, std::stack<T> q) {\n\tos << \">\";\n\twhile (!q.empty()) { os << q.top(); q.pop(); os << (q.empty() ? \"]\" : \", \"); }\n\treturn os;\n}\nnamespace std {\n\ttemplate<typename S, typename T> class numeric_limits<pair<S, T>> {\n\tpublic:\n\t\tstatic constexpr pair<S, T> max() noexcept { return { numeric_limits<S>::max(), numeric_limits<T>::max() }; }\n\t\tstatic constexpr pair<S, T> lowest() noexcept { return { numeric_limits<S>::lowest(), numeric_limits<T>::lowest() }; }\n\t};\n}\n\n// type/const\nusing i64 = std::int_fast64_t;\nusing u64 = std::uint_fast64_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<i64, i64>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr i64 MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8---------\n\n// use 'getDAG' after 'addEdge'.\n// cmp : beforeV -> afterV ; v |-> cmp[v]\n// pre : afterV ->{beforeV}; v |-> pre[v] (vector)\nstruct StronglyConnectedComponent {\n\tint n;\n\tstd::vector<std::vector<int>> g, rg;\n\tstd::vector<bool> used;\n\tstd::vector<int> vs; // postorder\n\tstd::vector<int> cmp; // topo-order\n\tstd::vector<std::vector<int>> pre;\n\n\tStronglyConnectedComponent(int n) :\n\t\tn(n), g(n), rg(n), used(n), cmp(n) {}\n\n\tint operator[](int id) {\n\t\treturn cmp[id];\n\t}\n\n\tvoid addEdge(int from, int to) {\n\t\tg[from].emplace_back(to);\n\t\trg[to].emplace_back(from);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (size_t i = 0; i < g[v].size(); ++i) {\n\t\t\tif (!used[g[v][i]]) dfs(g[v][i]);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor (size_t i = 0; i < rg[v].size(); ++i) {\n\t\t\tif (!used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tused.assign(n, false);\n\t\tvs.clear();\n\t\tfor (size_t v = 0; v < n; ++v) {\n\t\t\tif (!used[v]) dfs(v);\n\t\t}\n\n\t\tused.assign(n, false);\n\t\tint k = 0;\n\t\tfor (signed i = vs.size() - 1; i >= 0; --i) {\n\t\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t\t}\n\n\t\treturn k;\n\t}\n\n\tbool same(int u, int v) {\n\t\treturn cmp[u] == cmp[v];\n\t}\n\n\tstd::vector<std::vector<int>> getDAG() {\n\t\tint N = scc();\n\t\tstd::vector<std::vector<int>> res(N);\n\t\tstd::vector<std::set<int>> set(N);\n\t\tpre.resize(N);\n\t\tREP(i, n) {\n\t\t\tset[cmp[i]].insert(i);\n\t\t}\n\t\tREP(i, N) {\n\t\t\tstd::set<int> out;\n\t\t\tfor (const auto& v : set[i]) {\n\t\t\t\tpre[i].emplace_back(v);\n\t\t\t\tfor (const auto& to : g[v]) {\n\t\t\t\t\tout.insert(cmp[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const auto& to : out) {\n\t\t\t\tif (i != to) res[i].emplace_back(to);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, d);\n\tVEC_ROW(int, n, x, y);\n\n\tStronglyConnectedComponent scc(n * 2);\n\tREP(i, n) REP(j, n) if(i != j) {\n\t\tif (std::abs(x[i] - x[j]) < d) {\n\t\t\tscc.addEdge(i, n + j);\n\t\t\tscc.addEdge(j, n + i);\n\t\t}\n\t\tif (std::abs(x[i] - y[j]) < d) {\n\t\t\tscc.addEdge(i, j);\n\t\t\tscc.addEdge(n + j, n + i);\n\t\t}\n\t\tif (std::abs(y[i] - x[j]) < d) {\n\t\t\tscc.addEdge(n + i, n + j);\n\t\t\tscc.addEdge(j, i);\n\t\t}\n\t\tif (std::abs(y[i] - y[j]) < d) {\n\t\t\tscc.addEdge(n + i, j);\n\t\t\tscc.addEdge(n + j, i);\n\t\t}\n\t}\n\n\tauto G = scc.getDAG();\n\tREP(i, n) {\n\t\tif (scc.cmp[i] == scc.cmp[n + i]) EOUT(\"No\");\n\t}\n\tOUT(\"Yes\")BR;\n\tREP(i, n) {\n\t\tOUT(scc.cmp[i] > scc.cmp[n + i] ? x[i] : y[i])BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\nnamespace Ruby {\n\ttemplate <class F> struct Callable {\n\t\tF func;\n\t\tCallable(const F& f) : func(f) {}\n\t};\n\ttemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\t\treturn c.func(v);\n\t}\n\n\tstruct Sort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(begin(v), end(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Sort;\n\tstruct RSort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\t\tsort(rbegin(v), rend(v));\n\t\t\treturn v;\n\t\t}\n\t} RSort;\n\tstruct Reverse_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\t\treverse(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Reverse;\n\tstruct Unique_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Unique;\n\tstruct Uniq_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Uniq;\n\tstruct Rotate_impl {\n\t\ttemplate <class F> auto operator()(int left) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} Rotate;\n\tstruct Max_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\t\treturn *max_element(begin(v), end(v));\n\t\t}\n\t} Max;\n\tstruct Min_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\t\treturn *min_element(begin(v), end(v));\n\t\t}\n\t} Min;\n\tstruct MaxPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MaxPos;\n\tstruct MinPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MinPos;\n\tstruct MaxBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_it = begin(v);\n\t\t\t\tauto max_val = f(*max_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_it = it;\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *max_it;\n\t\t\t});\n\t\t}\n\t} MaxBy;\n\tstruct MinBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_it = begin(v);\n\t\t\t\tauto min_val = f(*min_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_it = it;\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *min_it;\n\t\t\t});\n\t\t}\n\t} MinBy;\n\tstruct MaxOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max_val;\n\t\t\t});\n\t\t}\n\t} MaxOf;\n\tstruct MinOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn min_val;\n\t\t\t});\n\t\t}\n\t} MinOf;\n\tstruct Count_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count(begin(v), end(v), val);\n\t\t\t});\n\t\t}\n\t} Count;\n\tstruct CountIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count_if(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t} CountIf;\n\tstruct Index_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} Index;\n\tstruct IndexIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} IndexIf;\n\tstruct FindIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t\t});\n\t\t}\n\t} FindIf;\n\tstruct Sum_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\t\treturn a + f(b);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t\t}\n\t} Sum;\n\tstruct Includes {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t\t});\n\t\t}\n\t} Includes;\n\tstruct IncludesIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t\t});\n\t\t}\n\t} IncludesIf;\n\tstruct RemoveIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} RemoveIf;\n\tstruct Each_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tf(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} Each;\n\tstruct Select_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\t\tvector<value_type> res;\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Select;\n\tstruct Map_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\t\tvector<result_type> res;\n\t\t\t\tres.reserve(size(v));\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tres.push_back(f(i));\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Map;\n\tstruct Indexed_impl {\n\t\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\t\tusing value_type = typename T::value_type;\n\t\t\tvector<pair<value_type, int>> res;\n\t\t\tres.reserve(size(v));\n\t\t\tint index = 0;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.emplace_back(i, index++);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} Indexed;\n\tstruct AllOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (!f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} AllOf;\n\tstruct AnyOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t} AnyOf;\n\tstruct NoneOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} NoneOf;\n};  // namespace Ruby\nusing namespace Ruby;\n\n// --- functions --- //\nnamespace Functions {\n\ttemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i) res += s;\n\t\treturn res;\n\t}\n\ttemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2));\n\t\treturn v;\n\t}\n\ttemplate <class T> inline T Ceil(T n, T m) {\n\t\treturn (n + m - 1) / m;\n\t}\n\ttemplate <class T> inline T Ceil2(T n, T m) {\n\t\treturn Ceil(n, m) * m;\n\t}\n\ttemplate <class T> inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate <class T> inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate <class T> inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\ttemplate <class T> inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate <class T> inline bool isSquere(T n) {\n\t\tT s = sqrt(n);\n\t\treturn s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate <class T = long long> inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n\t}\n\ttemplate <class T> inline T Pow(T a, T n) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) r *= a;\n\t\t\ta *= a;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1)\n\t\t\t\tr = r * a % m, n--;\n\t\t\telse\n\t\t\t\ta = a * a % m, n /= 2;\n\t\t}\n\t\treturn r;\n\t}\n}  // namespace Functions\nusing namespace Functions;\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\n#include <atcoder/all>\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tin(n, d);\n\tatcoder::two_sat t(n);\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, false, j, false);\n\t\t}\n\t}\n\tif (t.satisfiable()) {\n\t\tout(true);\n\t\tauto ans = t.answer();\n\t\trep(i, n) out(ans[i] ? y[i] : x[i]);\n\t} else {\n\t\tout(false);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 22020;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\tif (i < end) {\n\t\t\treturn buf[i++];\n\t\t} else {\n\t\t\treturn EOF;\n\t\t}\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #pragma GCC target(\"arch=skylake-avx512\")\n// export CPLUS_INCLUDE_PATH=\"/Users/shuzaei/Desktop/ac-library\"\n// /usr/bin/env python3 \"/Users/shuzaei/Desktop/ac-library/expander.py\"\n// /Users/shuzaei/Desktop/Solve.cpp\n#include <atcoder/all>\nusing namespace atcoder;\n\n#pragma region template\n\n// Define\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <class T> using pvector = vector<pair<T, T>>;\ntemplate <class T> using rpriority_queue = priority_queue<T, vector<T>, greater<T>>;\nconstexpr const ll dx[4] = {1, 0, -1, 0};\nconstexpr const ll dy[4] = {0, 1, 0, -1};\nconstexpr const ll MOD = 1e9 + 7;\nconstexpr const ll mod = 998244353;\nconstexpr const ll INF = 1LL << 60;\nconstexpr const ll inf = 1 << 30;\nconstexpr const char rt = '\\n';\nconstexpr const char sp = ' ';\n#define rt(i, n) (i == (ll)(n) -1 ? rt : sp)\n#define len(x) ((ll)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define ifn(x) if (not(x))\n#define elif else if\n#define elifn else ifn\n#define fi first\n#define se second\n#define uniq(x) (sort(all(x)), (x).erase(unique(all(x)), (x).end()))\n#define bis(x, y) ((ll)(lower_bound(all(x), y) - (x).begin()))\n\nusing graph = vector<vector<ll>>;\ntemplate <class T> using wgraph = vector<vector<pair<ll, T>>>;\nbool __DIRECTED__ = true;\nbool __ZERO_INDEXED__ = false;\nistream &operator>>(istream &is, graph &g) {\n    ll a, b;\n    is >> a >> b;\n    if (__ZERO_INDEXED__ == false) a--, b--;\n    g[a].pb(b);\n    if (__DIRECTED__ == false) g[b].pb(a);\n    return is;\n}\ntemplate <class T> istream &operator>>(istream &is, wgraph<T> &g) {\n    ll a, b;\n    T c;\n    is >> a >> b >> c;\n    if (__ZERO_INDEXED__ == false) a--, b--;\n    g[a].pb({b, c});\n    if (__DIRECTED__ == false) g[b].pb({a, c});\n    return is;\n}\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n// Debug\n#define debug(...)                                                                                 \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #__VA_ARGS__ << \" = \";                                         \\\n        for (auto &&__i : {__VA_ARGS__}) cerr << \"[\" << __i << \"] \";                               \\\n        cerr << rt;                                                                                \\\n    }\n\n#define dump(a, h, w)                                                                              \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #a << \" = [\" << rt;                                            \\\n        rep(__i, h) {                                                                              \\\n            rep(__j, w) {                                                                          \\\n                if (abs(a[__i][__j]) >= INF / 2 and a[__i][__j] <= -INF / 2) cerr << '-';          \\\n                if (abs(a[__i][__j]) >= INF / 2) cerr << \"∞\" << sp;                                \\\n                else                                                                               \\\n                    cerr << a[__i][__j] << sp;                                                     \\\n            }                                                                                      \\\n            cerr << rt;                                                                            \\\n        }                                                                                          \\\n        cerr << \"]\" << rt;                                                                         \\\n    }\n\n#define vdump(a, n)                                                                                \\\n    {                                                                                              \\\n        cerr << __LINE__ << \": \" << #a << \" = [\";                                                  \\\n        rep(__i, n) {                                                                              \\\n            if (__i) cerr << sp;                                                                   \\\n            if (abs(a[__i]) >= INF / 2 and a[__i] <= -INF / 2) cerr << '-';                        \\\n            if (abs(a[__i]) >= INF / 2) cerr << \"∞\" << sp;                                         \\\n            else                                                                                   \\\n                cerr << a[__i];                                                                    \\\n        }                                                                                          \\\n        cerr << \"]\" << rt;                                                                         \\\n    }\n\n// Loop\n#define inc(i, a, n) for (ll i = (a), _##i = (n); i <= _##i; ++i)\n#define dec(i, a, n) for (ll i = (a), _##i = (n); i >= _##i; --i)\n#define rep(i, n) for (ll i = 0, _##i = (n); i < _##i; ++i)\n#define each(i, a) for (auto &&i : a)\n\n// Stream\n#define fout(n) cout << fixed << setprecision(n)\nstruct io {\n    io() { cin.tie(nullptr), ios::sync_with_stdio(false); }\n} io;\n\n// Speed\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n// Math\ninline constexpr ll gcd(const ll a, const ll b) { return b ? gcd(b, a % b) : a; }\ninline constexpr ll lcm(const ll a, const ll b) { return a / gcd(a, b) * b; }\n\ninline constexpr ll modulo(const ll n, const ll m = MOD) {\n    ll k = n % m;\n    return k + m * (k < 0);\n}\ninline constexpr ll chmod(ll &n, const ll m = MOD) {\n    n %= m;\n    return n += m * (n < 0);\n}\ninline constexpr ll mpow(ll a, ll n, const ll m = MOD) {\n    ll r = 1;\n    rep(i, 64) {\n        if (n & (1LL << i)) r *= a;\n        chmod(r, m);\n        a *= a;\n        chmod(a, m);\n    }\n    return r;\n}\ninline ll inv(const ll n, const ll m = MOD) {\n    ll a = n, b = m, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return modulo(x, m);\n}\n\n#pragma endregion\n\nstruct SCC {\n    ll num, new_num;\n    vector<vector<ll>> graph;\n    vector<vector<ll>> rgraph;\n    vector<vector<ll>> new_graph;\n    vector<ll> tp_index;\n    vector<ll> nodes;\n    vector<bool> used;\n\n    SCC(ll n) : num(n), graph(n), rgraph(n), tp_index(n), used(n) {}\n    void add_edge(ll from, ll to) {\n        graph[from].push_back(to);\n        rgraph[to].push_back(from);\n    }\n    void dfs(ll pos) {\n        used[pos] = true;\n        for (ll i : graph[pos])\n            if (not used[i]) dfs(i);\n        nodes.push_back(pos);\n    }\n    void rdfs(ll pos, ll k) {\n        used[pos] = true, tp_index[pos] = k;\n        for (ll i : rgraph[pos])\n            if (not used[i]) rdfs(i, k);\n    }\n\n    ll scc() {\n        fill(used.begin(), used.end(), false);\n        nodes.clear();\n        for (ll i = 0; i < num; i++)\n            if (not used[i]) dfs(i);\n        reverse(nodes.begin(), nodes.end());\n        fill(used.begin(), used.end(), false);\n        ll k = 0;\n        for (ll i : nodes)\n            if (not used[i]) rdfs(i, k++);\n        return new_num = k;\n    }\n\n    void new_add_edge(ll from, ll to) {\n        ll f = tp_index[from], t = tp_index[to];\n        if (f == t) return;\n        new_graph[f].push_back(t);\n    }\n    void build_new_graph() {\n        new_graph.resize(new_num);\n        for (ll i = 0; i < num; i++)\n            for (ll j : graph[i]) new_add_edge(i, j);\n        for (vector<ll> &g : new_graph) {\n            sort(g.begin(), g.end());\n            g.erase(unique(g.begin(), g.end()), g.end());\n        }\n    }\n};\nstruct SAT {\n    ll n;\n    SCC scc;\n    vector<bool> result;\n\n    SAT(ll n) : n(n), scc(2 * n), result(2 * n) {}\n    ll inverse(ll x) { return x >= n ? x - n : x + n; }\n    void addliteral(ll a, ll b, bool a_inv = false, bool b_inv = false) {\n        if (a_inv) a = inverse(a);\n        if (b_inv) b = inverse(b);\n        scc.add_edge(inverse(a), b);\n        scc.add_edge(inverse(b), a);\n    }\n    bool calc() {\n        scc.scc();\n        for (ll i = 0; i < n; i++) {\n            if (scc.tp_index[i] > scc.tp_index[n + i]) {\n                result[i] = true;\n                result[n + i] = false;\n            } else if (scc.tp_index[i] == scc.tp_index[n + i]) {\n                return false;\n            } else {\n                result[n + i] = true;\n                result[i] = false;\n            }\n        }\n        return true;\n    }\n    bool val(ll x) { return result[x]; }\n};\n\nsigned main() {\n    ll N, D;\n    cin >> N >> D;\n    ll X[N], Y[N];\n    two_sat s(N);\n    rep(i, N) {\n        cin >> X[i] >> Y[i];\n        rep(j, i) {\n            if (abs(X[i] - X[j]) < D) s.add_clause(i, 0, j, 0);\n            if (abs(X[i] - Y[j]) < D) s.add_clause(i, 0, j, 1);\n            if (abs(Y[i] - X[j]) < D) s.add_clause(i, 1, j, 0);\n            if (abs(Y[i] - Y[j]) < D) s.add_clause(i, 1, j, 1);\n        }\n    }\n    auto res = s.satisfiable();\n    cout << (res ? \"Yes\" : \"No\") << rt;\n    auto ans = s.answer();\n    if (res) rep(i, N) cout << (ans[i] ? X[i] : Y[i]) << rt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\n#define REP(i, init, n) for(int i = (int)(init); i < (int)(n); i++)\n\n#define vi vector<int>\n#define vl vector<long>\n#define vvi vector<vector<int>>\n#define vvl vector<vector<long>>\n#define pint pair<int, int>\n#define plong pair<long, long>\n\nint main() {\n    int N, D;\n    cin>> N >> D;\n    vector<plong> P(N); \n    two_sat ts(N);\n    REP(i, 0, N){\n        int x, y;\n        cin >> x >> y;\n        P[i] = {x, y};\n    }\n    REP(i, 0, N){\n        REP(j, i + 1, N){\n            if(abs(P[i].first - P[j].first) < D){\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(P[i].first - P[j].second) < D){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(P[i].second - P[j].first) < D){\n                ts.add_clause(i, true, j, false);  \n            }\n            if(abs(P[i].second - P[j].second) < D){\n                ts.add_clause(i, true, j, true);    \n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n    REP(i, 0, N){\n        if(ans[i]){\n            cout << P[i].first << endl;\n        }else{\n            cout << P[i].second << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nvoid stronglyConnectedComponents(\n    const vector<vector<int> >& edges, vector<int>& indexConvert,\n    vector<vector<int> >& nodesOut)\n{\n    const int n = edges.size();\n    vector<int> num(n, -1), low(n, -1);\n    vector<bool> isStk(n, false);\n    stack<int> stk;\n    int cnt = -1;\n    nodesOut.clear();\n\n    for(int i=0; i<n; ++i){\n        stack<pair<int, unsigned> > arg;\n        arg.push(make_pair(i, 0));\n\n        while(!arg.empty()){\n            int v = arg.top().first;\n            unsigned j = arg.top().second;\n            arg.pop();\n\n            if(j == 0){\n                if(num[v] != -1)\n                    continue;\n                num[v] = low[v] = ++ cnt;\n                stk.push(v);\n                isStk[v] = true;\n            }\n            else{\n                int w = edges[v][j-1];\n                if(isStk[w])\n                    low[v] = min(low[v], low[w]);\n            }\n\n            if(j < edges[v].size()){\n                arg.push(make_pair(v, j + 1));\n                int w = edges[v][j];\n                arg.push(make_pair(w, 0));\n            }\n            else if(low[v] == num[v]){\n                nodesOut.push_back(vector<int>());\n                for(;;){\n                    int w = stk.top();\n                    stk.pop();\n                    isStk[w] = false;\n                    nodesOut.back().push_back(w);\n                    if(v == w)\n                        break;\n                }\n            }\n        }\n    }\n\n    reverse(nodesOut.begin(), nodesOut.end()); // DAGにするために反転させる\n    const int m = nodesOut.size();\n    indexConvert.resize(n);\n    for(int i=0; i<m; ++i){\n        for(unsigned j=0; j<nodesOut[i].size(); ++j)\n            indexConvert[nodesOut[i][j]] = i;\n    }\n}\n\nbool is2sat(int n, const vector<pair<int, bool> >& v, vector<bool>& ans)\n{\n    vector<vector<int> > edges(2*n);\n    for(unsigned i=0; i<v.size(); i+=2){\n        int a = v[i].first * 2 + (v[i].second ? 0 : 1);\n        int b = v[i+1].first * 2 + (v[i+1].second ? 0 : 1);\n        edges[a^1].push_back(b);\n        edges[b^1].push_back(a);\n    }\n\n    vector<int> indexConvert;\n    vector<vector<int> > nodes;\n    stronglyConnectedComponents(edges, indexConvert, nodes);\n\n    ans.resize(n);\n    for(int i=0; i<n; ++i){\n        if(indexConvert[2*i] < indexConvert[2*i+1])\n            ans[i] = false;\n        else if(indexConvert[2*i+1] < indexConvert[2*i])\n            ans[i] = true;\n        else\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(2*n);\n    for(int i=0; i<2*n; ++i)\n        cin >> x[i];\n\n    vector<pair<int, bool> > v;\n    for(int i=0; i<2*n; ++i){\n        for(int j=i+1; j<2*n; ++j){\n            if(abs(x[i] - x[j]) < d){\n                v.push_back(make_pair(i / 2, i % 2 != 0));\n                v.push_back(make_pair(j / 2, j % 2 != 0));\n            }\n        }\n    }\n\n    vector<bool> ans;\n    if(is2sat(n, v, ans)){\n        cout << \"Yes\" << endl;\n        for(int i=0; i<n; ++i){\n            if(ans[i])\n                cout << x[2*i] << endl;\n            else\n                cout << x[2*i+1] << endl;\n        }\n    }\n    else{\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef vector <vector<int>> Graph;\n\n// 強連結成分分解ライブラリ\nclass StronglyConnectedComponent {\npublic:\n  Graph G;\n  Graph rG;\n  Graph cG;\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> componentId;\n  int componentCount;\n  int V;\n\n  StronglyConnectedComponent(int V) {\n    this->V = V;\n    used = vector<bool>(V);\n    componentId = vector<int>(V);\n    G = Graph(V);\n    rG = Graph(V);\n  }\n\n  void add_edge(int from, int to) {\n    assert(0 <= from < V);\n    assert(0 <= to < V);\n\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void run() {\n    fill(used.begin(), used.end(), false);\n    componentCount = 0;\n    vs.clear();\n\n    for (int v = 0; v < V; ++v) {\n      if (used[v]) continue;\n\n      dfs(v);\n    }\n\n    fill(used.begin(), used.end(), false);\n\n    for (int i = vs.size() - 1; i >= 0; --i) {\n      int v = vs[i];\n      if (used[v]) continue;\n\n      cG.push_back(vector<int>());\n      rdfs(v, componentCount++);\n    }\n  }\n\nprivate:\n  void dfs(int v) {\n    used[v] = true;\n\n    for (int i = 0; i < G[v].size(); ++i) {\n      int u = G[v][i];\n\n      if (used[u]) continue;\n\n      dfs(u);\n    }\n\n    vs.push_back(v);\n  }\n\n  void rdfs(int v, int k) {\n    used[v] = true;\n    componentId[v] = k;\n    cG[k].push_back(v);\n\n    for (int i = 0; i < rG[v].size(); ++i) {\n      int u = rG[v][i];\n\n      if (used[u]) continue;\n\n      rdfs(u, k);\n    }\n  }\n};\n\nconst int MAX_V = 2010;\nint N, D;\nbool answer[MAX_V];\nStronglyConnectedComponent scc(MAX_V);\n\nvoid add_clause(int i, bool f, int j, bool g) {\n  assert(0 <= i && i < N);\n  assert(0 <= j && j < N);\n  scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n  scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n}\n\nbool satisfiable() {\n  scc.run();\n  memset(answer, false, sizeof(answer));\n\n  for (int i = 0; i < N; ++i) {\n    if (scc.componentId[2 * i] == scc.componentId[2 * i + 1]) return false;\n    answer[i] = scc.componentId[2 * i] < scc.componentId[2 * i + 1];\n  }\n\n  return true;\n}\n\nint main() {\n  cin >> N >> D;\n\n  int X[N];\n  int Y[N];\n\n  int x, y;\n  for (int i = 0; i < N; ++i) {\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n  }\n\n  for (int i = 0; i < N; ++i) {\n    int x1 = X[i];\n    int y1 = Y[i];\n\n    for (int j = i + 1; j < N; ++j) {\n      if (i == j) continue;\n\n      int x2 = X[j];\n      int y2 = Y[j];\n\n      if (abs(x1 - x2) < D) {\n        add_clause(i, false, j, false);\n      }\n\n      if (abs(x1 - y2) < D) {\n        add_clause(i, false, j, true);\n      }\n\n      if (abs(y1 - x2) < D) {\n        add_clause(i, true, j, false);\n      }\n\n      if (abs(y1 - y2) < D) {\n        add_clause(i, true, j, true);\n      }\n    }\n  }\n\n  if (satisfiable()) {\n    cout << \"Yes\" << endl;\n\n    for (int i = 0; i < N; ++i) {\n      if (answer[i]) {\n        cout << X[i] << endl;\n      } else {\n        cout << Y[i] << endl;\n      }\n    }\n  } else {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    vector<ll> X(N), Y(N);\n    for (int i = 0; i < N; i++) scanf(\"%lld %lld\", &X[i], &Y[i]);\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = i+1; j < N; j++) {\n            if (abs(X[i]-X[j]) < D) ts.add_clause(i, false, j, false);\n            if (abs(X[i]-Y[j]) < D) ts.add_clause(i, false, j, true);\n            if (abs(Y[i]-X[j]) < D) ts.add_clause(i, true, j, false);\n            if (abs(Y[i]-Y[j]) < D) ts.add_clause(i, true, j, true);\n        }\n    }\n    if (ts.satisfiable()) {\n        printf(\"Yes\\n\");\n        vector<bool> answer = ts.answer();\n        for (int i = 0; i < N; i++) {\n            printf(\"%lld\\n\", (answer[i] ? X[i] : Y[i]));\n        }\n    }else{\n        printf(\"No\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing     ll=long long;\nusing    vll=vector<   ll>;\nusing   vvll=vector<  vll>;\nusing  vvvll=vector< vvll>;\nusing vvvvll=vector<vvvll>;\nconstexpr ll INF = 1LL << 60;\nstruct Fast{ Fast(){ cin.tie(0); ios::sync_with_stdio(false); cout<<fixed<<setprecision(numeric_limits<double>::max_digits10); } } fast;\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){ T m=v[S]; rep(i,S,E)chmax(m,v[i]); return m; }\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){ T m=v[S]; rep(i,S,E)chmin(m,v[i]); return m; }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v,0,(ll)v.size()-1); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v,0,(ll)v.size()-1); }\ntemplate<class T> inline T Sum(vector<T> &v,ll S,ll E){ T s=T(); rep(i,S,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v,0,v.size()-1); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ninline ll CEIL(ll a,ll b){ return (a<0) ? -(-a/b) : (a+b-1)/b; }\ninline ll FLOOR(ll a,ll b){ return -CEIL(-a,b); }\n\n#if 1\n#include <atcoder/all>\n#endif\nusing namespace atcoder;\n\n\nvoid solve()\n{\n\tll n,d;  cin >> n >> d;\n\tvector<pair<ll,ll>> xy(n);\n\trep(i,0,n-1){ ll x; ll y; cin>>x>>y; xy[i]={x,y}; }\n\n\ttwo_sat ts(n);\n\n\trep(i,0,n-1){\n\t\trep(j,i+1,n-1){\n\t\t\tll xi,yi;  tie(xi,yi) = xy[i];\n\t\t\tll xj,yj;  tie(xj,yj) = xy[j];\n\n\t\t\tif (abs(xi-xj)<d){\n\t\t\t\tts.add_clause(i,false,j,false);\n\t\t\t}\n\t\t\tif (abs(yi-yj)<d){\n\t\t\t\tts.add_clause(i,true,j,true);\n\t\t\t}\n\t\t\tif (abs(yi-xj)<d){\n\t\t\t\tts.add_clause(i,true,j,false);\n\t\t\t}\n\t\t\tif (abs(xi-yj)<d){\n\t\t\t\tts.add_clause(i,false,j,true);\n\t\t\t}\n\t\t}\n\t}\n\tif (!ts.satisfiable()){\n\t\tcout << \"No\" << '\\n';return;\n\t}\n\tcout << \"Yes\" << '\\n';\n\tauto ans=ts.answer();\n\trep(i,0,n-1){\n\t\tll xi,yi;  tie(xi,yi) = xy[i];\n\t\tif (ans[i]){\n\t\t\tcout << xi << '\\n';\n\t\t}\n\t\telse{\n\t\t\tcout << yi << '\\n';\n\t\t}\n\t}\n}\n\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// #include <atcoder/all>\n\nusing namespace std;\n// using namespace atcoder;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\nsigned main() {\n    int n, d;\n    cin >> n >> d;\n    set<int> st;\n    vi x(n), y(n);\n    rep (i, n) {\n        cin >> x[i] >> y[i];\n        st.insert(x[i]);\n        st.insert(y[i]);\n    }\n\n    map<int, int> mp;\n    int shu = 0;\n    for (auto itr = st.begin(); itr != st.end(); itr++) {\n        mp[*itr] = shu++;\n    }\n\n    two_sat sat(shu);\n\n    rep (i, n) {\n        int u = mp[x[i]], v = mp[y[i]];\n        sat.add_clause(u, true, v, true);\n    }\n    for (auto itr = st.begin(); itr != st.end(); itr++) {\n        ll x = *itr, u = mp[*itr];\n        for (auto itr2 = st.begin(); itr2 != st.end(); itr2++) {\n            ll y = *itr2, v = mp[*itr2];\n            if (x == y) continue;\n            if (abs(x - y) < d) {\n                sat.add_clause(u, false, v, false);\n            }\n        }\n    }\n\n    if (not sat.satisfiable()) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    vector<bool> ans = sat.answer();\n    DEBUG_VEC(ans);\n    rep (i, n) {\n        int u = mp[x[i]], v = mp[y[i]];\n        if (ans[u]) {\n            cout << x[i] << endl;\n        }\n        else {\n            cout << y[i] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nvoid stronglyConnectedComponents(\n    const vector<vector<int> >& edges, vector<int>& indexConvert,\n    vector<vector<int> >& nodesOut)\n{\n    const int n = edges.size();\n    vector<int> num(n, -1), low(n, -1);\n    vector<bool> isStk(n, false);\n    stack<int> stk;\n    int cnt = -1;\n    nodesOut.clear();\n\n    for(int i=0; i<n; ++i){\n        stack<pair<int, unsigned> > arg;\n        arg.push(make_pair(i, 0));\n\n        while(!arg.empty()){\n            int v = arg.top().first;\n            unsigned j = arg.top().second;\n            arg.pop();\n\n            if(j == 0){\n                if(num[v] != -1)\n                    continue;\n                num[v] = low[v] = ++ cnt;\n                stk.push(v);\n                isStk[v] = true;\n            }\n            else{\n                int w = edges[v][j-1];\n                if(isStk[w])\n                    low[v] = min(low[v], low[w]);\n            }\n\n            if(j < edges[v].size()){\n                arg.push(make_pair(v, j + 1));\n                int w = edges[v][j];\n                arg.push(make_pair(w, 0));\n            }\n            else if(low[v] == num[v]){\n                nodesOut.push_back(vector<int>());\n                for(;;){\n                    int w = stk.top();\n                    stk.pop();\n                    isStk[w] = false;\n                    nodesOut.back().push_back(w);\n                    if(v == w)\n                        break;\n                }\n            }\n        }\n    }\n\n    reverse(nodesOut.begin(), nodesOut.end()); // DAGにするために反転させる\n    const int m = nodesOut.size();\n    indexConvert.resize(n);\n    for(int i=0; i<m; ++i){\n        for(unsigned j=0; j<nodesOut[i].size(); ++j)\n            indexConvert[nodesOut[i][j]] = i;\n    }\n}\n\nbool is2sat(int n, const vector<pair<int, bool> >& v, vector<bool>& ans)\n{\n    vector<vector<int> > edges(2*n);\n    for(unsigned i=0; i<v.size(); i+=2){\n        int a = v[i].first * 2 + (v[i].second ? 0 : 1);\n        int b = v[i+1].first * 2 + (v[i+1].second ? 0 : 1);\n        edges[a^1].push_back(b);\n        edges[b^1].push_back(a);\n    }\n\n    vector<int> indexConvert;\n    vector<vector<int> > nodes;\n    stronglyConnectedComponents(edges, indexConvert, nodes);\n\n    ans.resize(n);\n    for(int i=0; i<n; ++i){\n        if(indexConvert[2*i] < indexConvert[2*i+1])\n            ans[i] = false;\n        else if(indexConvert[2*i+1] < indexConvert[2*i])\n            ans[i] = true;\n        else\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(2*n);\n    for(int i=0; i<2*n; ++i)\n        cin >> x[i];\n\n    vector<pair<int, bool> > v;\n    for(int i=0; i<2*n; ++i){\n        for(int j=i+2; j<2*n; ++j){\n            if(abs(x[i] - x[j]) < d){\n                v.push_back(make_pair(i / 2, i % 2 != 0));\n                v.push_back(make_pair(j / 2, j % 2 != 0));\n            }\n        }\n    }\n\n    vector<bool> ans;\n    if(is2sat(n, v, ans)){\n        cout << \"Yes\" << endl;\n        for(int i=0; i<n; ++i){\n            if(ans[i])\n                cout << x[2*i] << endl;\n            else\n                cout << x[2*i+1] << endl;\n        }\n    }\n    else{\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <string>\n#include <vector>\n#include <map>\n#include <deque>\n\n#include <atcoder/all>\n\nusing namespace atcoder;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, D;\n    cin >> N >> D;\n\n    vector<int> x(N), y(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    two_sat ts = two_sat(N);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (abs(x[i] - x[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        for (int i = 0; i < N; ++i) {\n            if (ans[i]) {\n                cout << x[i] << endl;\n            } else {\n                cout << y[i] << endl;\n            }\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main()\n{\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n  }\n  scc_graph g(2 * n);\n  vector<int> w(2 * n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      if (abs(x[i] - x[j]) < d)\n      {\n        g.add_edge(2 * i, 2 * j + 1);\n      }\n      if (abs(x[i] - y[j]) < d)\n      {\n        g.add_edge(2 * i, 2 * j);\n      }\n      if (abs(y[i] - x[j]) < d)\n      {\n        g.add_edge(2 * i + 1, 2 * j + 1);\n      }\n      if (abs(y[i] - y[j]) < d)\n      {\n        g.add_edge(2 * i + 1, 2 * j);\n      }\n    }\n  }\n  vector<vector<int> > S = g.scc();\n  for (int i = 0; i < S.size(); i++)\n  {\n    for (int j = 0; j < S[i].size(); j++)\n    {\n      w[S[i][j]] = i;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    if (w[2 * i] == w[2 * i + 1])\n    {\n      cout << \"No\\n\";\n      return 0;\n    }\n    w[i] = w[2 * i] < w[2 * i + 1];\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; i++)\n  {\n    if (w[i]) cout << y[i] << \"\\n\";\n    else cout << x[i] << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#include \"atcoder/all\"\nusing namespace atcoder;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nsigned main(){\n\tint N, D;\n\tcin >> N >> D;\n\tvector<int>x(N), y(N);\n\tREP(i, N) cin >> x[i] >> y[i];\n\n\ttwo_sat ts(N);\n\t// ts[i] = i-th flag is located on x[i]\n\tREP(i, N) {\n\t\tFOR(j, i + 1, N) {\n\t\t\tif(abs(x[i] - x[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif(abs(x[i] - y[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif(abs(y[i] - x[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif(abs(y[i] - y[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tif(!ts.satisfiable()) {\n\t\tout(\"No\");\n\t\treturn 0;\n\t}\n\n\tout(\"Yes\");\n\tauto ans = ts.answer();\n\tREP(i, N) {\n\t\tout((ans[i]) ? x[i] : y[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) begin(v),end(v)\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr ll INF = 1ll<<30;\nconstexpr ll longINF = 1ll<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr bool debug = 0;\n//---------------------------------//\n\n#include <atcoder/twosat>\n\nint main() {\n\tint N, D;\n\tscanf(\"%d %d\", &N, &D);\n\tvector<int> X(N), Y(N);\n\tREP(i, N) scanf(\"%d %d\", &X[i], &Y[i]);\n\t\n\tatcoder::two_sat sat(N);\n\tREP(i, N) FOR(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) sat.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) sat.add_clause(i, true, j, false);\n\t\tif (abs(Y[i] - X[j]) < D) sat.add_clause(i, false, j, true);\n\t\tif (abs(Y[i] - Y[j]) < D) sat.add_clause(i, false, j, false);\n\t}\n\t\n\tif (!sat.satisfiable()) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n\tauto ans = sat.answer();\n\tREP(i, N) printf(\"%d\\n\", ans[i] ? X[i] : Y[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nsigned main() {\n    int N, D;\n    cin >> N >> D;\n    vint X(N), Y(N);\n    rep(i, N) { cin >> X[i] >> Y[i]; }\n    two_sat ts(N);\n    rep(i, N) {\n        rep(j, i) {\n            if (abs(X[i] - X[j]) < D) { ts.add_clause(i, 0, j, 0); }\n            if (abs(X[i] - Y[j]) < D) { ts.add_clause(i, 0, j, 1); }\n            if (abs(Y[i] - X[j]) < D) { ts.add_clause(i, 1, j, 0); }\n            if (abs(Y[i] - Y[j]) < D) { ts.add_clause(i, 1, j, 1); }\n        }\n    }\n    if (ts.satisfiable()) { cout << \"Yes\" << endl; }\n    else { fin(\"No\"); }\n    auto ans = ts.answer();\n    rep(i, ans.size()) {\n        if (ans[i]) { cout << X[i] << endl; }\n        else { cout << Y[i] << endl; }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main()\n{\n  int n, d;\n  cin >> n >> d;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> x[i] >> y[i];\n  }\n  two_sat ts(n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      if (abs(x[i] - x[j]) < d) ts.add_clause(i, 1, j, 1);\n      if (abs(x[i] - y[j]) < d) ts.add_clause(i, 1, j, 0);\n      if (abs(y[i] - y[j]) < d) ts.add_clause(i, 0, j, 0);\n    }\n  }\n  int A = ts.satisfiable();\n  if (!A)\n  {\n    cout << \"No\";\n    return 0;\n  }\n  cout << \"Yes\\n\";\n  vector<bool> ans = ts.answer();\n  for (int i = 0; i < n; i++)\n  {\n    if (ans[i] == 0) cout << x[i] << \"\\n\";\n    else cout << y[i] << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing H = pair<ll, ll>;\nusing P = pair<ll, H>;\nusing vi = vector<ll>;\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(ll i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define pb emplace_back\n#define siz(a) (int)(a).size()\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) (lower_bound(all(b),(i))-(b).begin())\n#define ssp(i,n) (i==(ll)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) for(int quetimes_=(n);quetimes_>0;quetimes_--)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n#define found(a,x) (a.find(x)!=a.end())\nconstexpr ll mod = (ll)1e9 + 7;\nconstexpr ll Mod = 998244353;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = (ll)3 * 1e18;\nconstexpr int Inf = (ll)15 * 1e8;\nconstexpr int dx[] = { -1,1,0,0 }, dy[] = { 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(short g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g == 1) u.fs--, u.sc--; if (g == 2) u.fs--; return u; }\nbool ina(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nbool ina(int t, int l, int r) { return l <= t && t < r; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll popcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\ntemplate<typename T>\nclass csum {\n    vec<T> v;\npublic:\n    csum(vec<T>& a) :v(a) { build(); }\n    csum() {}\n    void init(vec<T>& a) { v = a; build(); }\n    void build() {\n        for (int i = 1; i < v.size(); i++) v[i] += v[i - 1];\n    }\n    //[l,r]\n    T a(int l, int r) {\n        if (r < l) return 0;\n        return v[r] - (l == 0 ? 0 : v[l - 1]);\n    }\n    //[l,r)\n    T b(int l, int r) {\n        return a(l, r - 1);\n    }\n    T a(pair<int, int>t) {\n        return a(t.first, t.second);\n    }\n    T b(pair<int, int>t) {\n        return b(t.first, t.second);\n    }\n};\nclass mint {\npublic:ll v;\n      mint(ll v = 0) { s(v % mod + mod); }\n      constexpr static int mod = Mod;// (ll)1e9 + 7;\n      constexpr static int fn_ = (ll)2e6 + 5;\n      static mint fact[fn_], comp[fn_];\n      mint pow(int x) const {\n          mint b(v), c(1);\n          while (x) {\n              if (x & 1) c *= b;\n              b *= b;\n              x >>= 1;\n          }\n          return c;\n      }\n      inline mint& s(int vv) {\n          v = vv < mod ? vv : vv - mod;\n          return *this;\n      }\n      inline mint inv()const { return pow(mod - 2); }\n      inline mint operator-()const { return mint() - *this; }\n      inline mint& operator+=(const mint b) { return s(v + b.v); }\n      inline mint& operator-=(const mint b) { return s(v + mod - b.v); }\n      inline mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }\n      inline mint& operator/=(const mint b) { v = v * b.inv().v % mod; return *this; }\n      inline mint operator+(const mint b) const { return mint(v) += b; }\n      inline mint operator-(const mint b) const { return mint(v) -= b; }\n      inline mint operator*(const mint b) const { return mint(v) *= b; }\n      inline mint operator/(const mint b) const { return mint(v) /= b; }\n      friend ostream& operator<<(ostream& os, const mint& m) {\n          return os << m.v;\n      }\n      friend istream& operator>>(istream& is, mint& m) {\n          int x; is >> x; m = mint(x);\n          return is;\n      }\n      bool operator<(const mint& r)const { return v < r.v; }\n      bool operator>(const mint& r)const { return v > r.v; }\n      bool operator<=(const mint& r)const { return v <= r.v; }\n      bool operator>=(const mint& r)const { return v >= r.v; }\n      bool operator==(const mint& r)const { return v == r.v; }\n      bool operator!=(const mint& r)const { return v != r.v; }\n      explicit operator bool()const { return v; }\n      explicit operator int()const { return v; }\n      mint comb(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              if (k > * this - k) k = *this - k;\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp * comp[k.v];\n          }\n          return fact[v] * comp[k.v] * comp[v - k.v];\n      }//nCk\n      mint perm(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp;\n          }\n          return fact[v] * comp[v - k.v];\n      }//nPk\n      static void combinit() {\n          fact[0] = 1;\n          for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);\n          comp[fn_ - 1] = fact[fn_ - 1].inv();\n          for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);\n      }\n}; mint mint::fact[fn_], mint::comp[fn_];\n\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\n#include<atcoder/all>\nusing namespace atcoder;\n\nsigned main() {\n    int n, d; cin >> n >> d;\n    vi x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    two_sat ts(n);\n    rep(i, n)rng(j, i + 1, n) {\n        if (abs(x[i] - x[j] < d)) ts.add_clause(i, false, j, false);\n        if (abs(x[i] - y[j] < d)) ts.add_clause(i, false, j, true);\n        if (abs(y[i] - x[j] < d)) ts.add_clause(i, true, j, false);\n        if (abs(y[i] - y[j] < d)) ts.add_clause(i, true, j, true);\n    }\n    if (!ts.satisfiable()) {\n        cno; return 0;\n    }\n    cyes;\n    auto ans = ts.answer();\n    rep(i, n) {\n        if (ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\nusing namespace atcoder;\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing P = pair<int, int>;\nusing PL = pair<lint, lint>;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\nconstexpr int MOD = 1000000007;\nconstexpr lint B1 = 1532834020;\nconstexpr lint M1 = 2147482409;\nconstexpr lint B2 = 1388622299;\nconstexpr lint M2 = 2147478017;\nconstexpr int INF = 2147483647;\nvoid yes(bool expr) {cout << (expr ? \"Yes\" : \"No\") << \"\\n\";}\ntemplate<class T>void chmax(T &a, const T &b) { if (a<b) a=b; }\ntemplate<class T>void chmin(T &a, const T &b) { if (b<a) a=b; }\nusing mint = modint998244353;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int N, D;\n  cin >> N >> D;\n  vector<int> X(N), Y(N);\n  REP(i, N) cin >> X[i] >> Y[i];\n  two_sat ts(N);\n  REP(i, N) FOR(j, i+1, N) {\n    if(abs(X[i]-X[j]) < D) ts.add_clause(i, false, j, false);\n    if(abs(X[i]-Y[j]) < D) ts.add_clause(i, false, j, true);\n    if(abs(Y[i]-X[j]) < D) ts.add_clause(i, true, j, false);\n    if(abs(Y[i]-Y[j]) < D) ts.add_clause(i, true, j, true);\n  }\n  if(!ts.satisfiable()) {\n    cout << \"No\" << \"\\n\";\n    return 0;\n  }\n  cout << \"Yes\" << \"\\n\";\n  auto ans = ts.answer();\n  REP(i, N) {\n    if(ans[i]) cout << X[i] << \"\\n\";\n    else cout << Y[i] << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst double pi = acos(-1.0);\nconst double EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nstruct Graph{\n    vector<vector<int>> es;\n    const int n;\n\n    Graph(int n) : n(n){\n        es.resize(n);\n    }\n\n    void add_edge(int from, int to, bool directed = false){\n        es[from].pb(to);\n        if(!directed) es[to].pb(from);\n    }\n};\n\nstruct Strongly_Connected_Components{\n    vector<vector<int>> es, rs;\n    vector<int> vs, comp;\n    vector<bool> used;\n    const int n;\n\n    Strongly_Connected_Components(int n) : n(n){\n        es.resize(n), rs.resize(n);\n        vs.resize(n), comp.resize(n), used.resize(n);\n    }\n\n    void add_edge(int from, int to, bool directed = true){\n        es[from].pb(to), rs[to].pb(from);\n        if(!directed) es[to].pb(from), rs[from].pb(to);\n    }\n\n    void dfs(int now){\n        used[now] = true;\n        for(auto &e: es[now]) if(!used[e]) dfs(e);\n        vs.pb(now);\n    }\n\n    void rdfs(int now, int cnt){\n        used[now] = true, comp[now] = cnt;\n        for(auto &e: rs[now]) if(!used[e]) rdfs(e, cnt);\n    }\n\n    Graph decompose(){\n        fill(all(used), false);\n        rep(i, n) if(!used[i]) dfs(i);\n        fill(all(used), false), reverse(all(vs));\n        int cnt = 0;\n        for(auto &e: vs) if(!used[e]) rdfs(e, cnt++);\n        Graph G(cnt);\n        rep(i, n){\n            for(auto &e: es[i]){\n                int u = comp[i], v = comp[e];\n                if(u != v) G.add_edge(u, v, true);\n            }\n        }\n        return G;\n    }\n\n    int operator [] (int k) const {return comp[k];}\n};\n\nint main(){\n    int N, D;\n    cin >> N >> D;\n    int x[N], y[N];\n    rep(i, N) cin >> x[i] >> y[i];\n    Strongly_Connected_Components G(2*N);\n    rep(i, N){\n        rep(j, i){\n            if(abs(x[i]-x[j]) < D) G.add_edge(i, N+j), G.add_edge(j, N+i);\n            if(abs(x[i]-y[j]) < D) G.add_edge(i, j), G.add_edge(N+j, N+i);\n            if(abs(y[i]-x[j]) < D) G.add_edge(N+i, N+j), G.add_edge(j, i);\n            if(abs(y[i]-y[j]) < D) G.add_edge(N+i, j), G.add_edge(N+j, i);\n        }\n    }\n    G.decompose();\n    int ans[N];\n    rep(i, N){\n        if(G[i] == G[N+i]) {cout << \"No\" << endl; return 0;}\n        if(G[i] > G[N+i]) ans[i] = x[i];\n        if(G[i] < G[N+i]) ans[i] = y[i];\n    }\n    cout << \"Yes\" << endl;\n    rep(i, N) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\nint main(){\n  int N, D;\n  cin >> N >> D;\n  vector<int> X(N), Y(N);\n  for (int i = 0; i < N; i++){\n    cin >> X[i] >> Y[i];\n  }\n  two_sat S(N);\n  for (int i = 0; i < N; i++){\n    for (int j = i + 1; j < N; j++){\n      if (abs(X[j] - X[i]) < D){\n        S.add_clause(i, true, j, true);\n      }\n      if (abs(Y[j] - X[i]) < D){\n        S.add_clause(i, true, j, false);\n      }\n      if (abs(X[j] - Y[i]) < D){\n        S.add_clause(i, false, j, true);\n      }\n      if (abs(Y[j] - Y[i]) < D){\n        S.add_clause(i, false, j, false);\n      }\n    }\n  }\n  if (!S.satisfiable()){\n    cout << \"No\" << endl;\n  } else {\n    cout << \"Yes\" << endl;\n    vector<bool> ans = S.answer();\n    for (int i = 0; i < N; i++){\n      if (ans[i]){\n        cout << Y[i] << endl;\n      } else {\n        cout << X[i] << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing P = pair<int,int>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\n\nint main() {\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    int n, d;\n    cin >> n >> d;\n    two_sat ts(n);\n    VVI p(n, VI(2));\n    rep(i, n) cin >> p[i][0] >> p[i][1];\n    rep(i, n) rep(j, i) {\n        rep(s, 2) rep(t, 2) {\n            if (abs(p[i][s] - p[j][t]) < d) {\n                ts.add_clause(i, !s, j, !t);\n            }\n        }\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        rep(i, ans.size()) cout << p[i][ans[i]] << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <atcoder/twosat>\n\n\nusing namespace std;\nusing namespace atcoder;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\n// edit\n\nvoid solve() {\n    int N;\n    cin >> N;\n\n    ll D;\n    cin >> D;\n    vector<pair<ll, ll>> xy(N);\n    REP(i, N) {\n        cin >> xy[i].first >> xy[i].second;\n    }\n\n    two_sat ts(2 * N);\n\n    for (int i = 0; i < N; ++i) {\n        ts.add_clause(2 * i, true, 2 * i + 1, true);\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            vector<pair<ll, ll>> tapu{{xy[i].first,  2 * i},\n                                      {xy[i].second, 2 * i + 1}};\n            vector<pair<ll, ll>> tapi{{xy[j].first,  2 * j},\n                                      {xy[j].second, 2 * j + 1}};\n            for (auto ei1333 : tapu) {\n                for (auto treeone79 : tapi) {\n                    if (abs(ei1333.first - treeone79.first) < D) {\n                        ts.add_clause(ei1333.second, false, treeone79.second, false);\n//                        cerr << ei1333.second << \" \" << treeone79.second << endl;\n                    }\n                }\n            }\n        }\n    }\n\n    bool f = ts.satisfiable();\n    if (f) {\n        cout << \"Yes\" << endl;\n        auto v = ts.answer();\n        for (int i = 0; i < N; ++i) {\n            if (v[2 * i]) {\n                cout << xy[i].first;\n            } else {\n                cout << xy[i].second;\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma warning(disable: 4244) // 最悪をします\n#include <atcoder/all>\n#include <atcoder/dsu.hpp>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// 辺がメンバに src と dst を持つ隣接リスト表記のグラフをダンプ(https://hello-world-494ec.firebaseapp.com/) に投げることを想定\ntemplate <typename T>\nvoid dump_graph(T G) {\n\tint V = G.size();\n\tint E = 0;\n\tostringstream os;\n\n\tfor (auto es : G) {\n\t\tfor (auto e : es) {\n\t\t\tE++;\n\t\t\tos << e.src << \" \" << e.dst << \"\\n\";\n\t\t}\n\t}\n\tcout << V << \" \" << E << \"\\n\";\n\tcout << os.str() << \"\\n\";\n}\n\n// グリッドからグラフを構築\n// @pre: gはノード数H*Wのグラフ\nvoid create_from_grid(Graph& g, int h, int w, vector<string>& mapData, char wall) {\n\t//グラフ構築 O(HW)\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tif (mapData[y][x] == wall) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint id = y * w + x;\n\t\t\t//右と下(変位が正)のみ見る(辺の重複を回避するため)\n\t\t\trep(i, 2) {\n\t\t\t\tint nx = x + dxp[i];\n\t\t\t\tint ny = y + dyp[i];\n\t\t\t\tint nid = ny * w + nx;\n\t\t\t\tif (nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mapData[ny][nx] != wall) {\n\t\t\t\t\tadd_edge(g, id, nid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// マスに重みが定義されるグリッドから重み付きグラフを構築、ダイクストラなどをするとき始点のこすとは入らないことに注意\n// @pre: gはノード数H*Wのグラフ\nvoid create_weighted_from_grid(Graph& g, int h, int w, vector<vector<int>>& mapData) {\n\t//グラフ構築 O(HW)\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tint id = y * w + x;\n\t\t\t// こんどは全方向見る(行きと帰りで重みが違うはず)\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nid = ny * w + nx;\n\t\t\t\tif (nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// 移動先のコストを足す\n\t\t\t\tadd_arc(g, id, nid, mapData[ny][nx]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// グリッドにおいて座標をグラフのノード番号に変換する\nint point_to_node_num(int x, int y, int W) {\n\treturn y * W + x;\n}\n\nstruct uf_tree {\n\tstd::vector<int> parent;\n\tint __size;\n\tuf_tree(int size_) : parent(size_, -1), __size(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif ((x = find(x)) != (y = find(y))) {\n\t\t\tif (parent[y] < parent[x]) std::swap(x, y);\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\t__size--;\n\t\t}\n\t}\n\tbool is_same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n\tint size(int x) { return -parent[find(x)]; }\n\tint size() { return __size; }\n};\n\n\n\n//!!!問題をちゃんと読む!!!\n//!!!問題をちゃんと読め!!!\n//!!!問題は読みましたか？!!!\n\ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(signed y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int& operator+=(const mod_int& rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator-=(const mod_int& rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator*=(const mod_int& rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int& operator/=(const mod_int& rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int& rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int& rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int& rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int& rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int& rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t}\n\t\telse {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * signed(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <signed M, unsigned F>\nstd::ostream& operator<<(std::ostream& os, const mod_int<M, F>& rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <signed M, unsigned F>\nstd::istream& operator >> (std::istream& is, mod_int<M, F>& rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nbool operator==(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst signed MF = 1000010;\nconst signed MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n\n//出典 http://beet-aizu.hatenablog.com/entry/2017/12/01/225955\n/*\nコンストラクタ引数説明\nint n_\n要素数。\nf\n2つの要素Tをマージするための関数。\n区間MAX区間更新の時: max\n区間Sum区間Addの時: +\ng\n1つの要素Tに作用素Eを適用するための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nh\n2つの作用素Eをマージするための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nT d1\n演算fの単位元。\n区間MAX区間更新の時: -INF　\n区間Sum区間Addの時: 0\nE d0,\ng, hの単位元。\n区間MAX区間更新の時: 定義域外のどこか\n区間Sum区間Addの時: 0\nvector<T> v = vector<T>()\nセグ木を構成するときのvector\nP p = [](E a, int b) {return a; }\n区間の長さbを引数に取り、区間の長さによって変化する作用素E'を返す関数。\n例えば、区間MAX区間Addの時なんかは区間長によって足すべき数が変化するので必要\n区間Sum区間Addの時: *\n\n//具体例\n//区間chmin, 区間min\nauto myMin = [](int a, int b) {return min(a, b); };\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間update、区間min\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間Add、区間Sum\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, plus<int>(), plus<int>(), plus<int>(), 0, 0, v, [](int a, int b) {return a * b; });\n//区間Add、区間Min\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, myMin, plus<int>(), plus<int>(), LL_HALFMAX, 0, v, [](int a, int b) {return a; });\n*/\n\ntemplate <typename T, typename E>\nstruct SegmentTree {\n\ttypedef function<T(T, T)> F;\n\ttypedef function<T(T, E)> G;\n\ttypedef function<E(E, E)> H;\n\ttypedef function<E(E, int)> P;\n\tint n;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT d1;\n\tE d0;\n\tvector<T> dat;\n\tvector<E> laz;\n\tSegmentTree(int n_, F f, G g, H h, T d1, E d0,\n\t\tvector<T> v = vector<T>(), P p = [](E a, int b) {return a; }) :\n\t\tf(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n\t\tinit(n_);\n\t\tif (n_ == (int)v.size()) build(n_, v);\n\t}\n\t//初期化。要素配列と遅延配列を2*n-1個にする\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, d1);\n\t\tlaz.clear();\n\t\tlaz.resize(2 * n - 1, d0);\n\t}\n\t//既存のvectorからセグ木を構築\n\tvoid build(int n_, vector<T> v) {\n\t\tfor (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tdat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\t//ノードを評価する。\n\tinline void eval(int len, int k) {\n\t\t//遅延配列に単位元が入ってたら評価済みなのでおしまい\n\t\tif (laz[k] == d0) return;\n\t\t//葉ノードでないなら遅延伝播する\n\t\tif (k * 2 + 1 < n * 2 - 1) {\n\t\t\t//h: 2つの作用素を引数に取り合成した作用素を返す関数\n\t\t\tlaz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n\t\t\tlaz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n\t\t}\n\t\t//p: このノードに対応する区間長と作用素を引数に取り、区間長に対応する作用素を返す関数\n\t\t//dat[k] にlaz に溜めていた作用素を適用(g: 要素型と作用素型を引数に取り、要素に作用素を作用させた結果を返す関数、ここでの作用素とは区間Sum区間Addなら (+ 3) とか)\n\t\tdat[k] = g(dat[k], p(laz[k], len));\n\t\t//適用し終わったので遅延配列をクリア\n\t\tlaz[k] = d0;\n\t}\n\t//[l,r)の区間を再帰的に見ながら0-indexedの[a, b)を更新する\n\tT update(int a, int b, E x, int k, int l, int r) {\n\t\t//先に評価\n\t\teval(r - l, k);\n\t\t//範囲外ならなにもしないでそのノードが持つ値を返す\n\t\tif (r <= a || b <= l) return dat[k];\n\t\t//完全被覆なら既に遅延配列に入っている作用素と追加したい作用素をマージした後にそれを要素に作用させた結果を返す、pは区間長に対応する作用素を得るための（ｒｙ\n\t\tif (a <= l && r <= b) {\n\t\t\tlaz[k] = h(laz[k], x);\n\t\t\treturn g(dat[k], p(laz[k], r - l));\n\t\t}\n\t\t//完全被覆でも範囲外でもないなら(中途半端にかぶっているなら)完全被覆と範囲外の境界が見えるまで木を潜って変化後の値を得る\n\t\treturn dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r));\n\t}\n\tT update(int a, int b, E x) {\n\t\treturn update(a, b, x, 0, 0, n);\n\t}\n\n\tT update(int a, E x) {\n\t\treturn update(a, a + 1, x);\n\t}\n\n\tT query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\t//範囲外なら単位元を返す\n\t\tif (r <= a || b <= l) return d1;\n\t\t//完全被覆ならそのまま返す\n\t\tif (a <= l && r <= b) return dat[k];\n\t\t//一部被覆なら完全被覆と範囲外に分かれるまで木を潜る\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn f(vl, vr);\n\t}\n\t//0-indexedで[a, b)の区間*を求める\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tT query(int a) {\n\t\treturn query(a, a + 1, 0, 0, n);\n\t}\n\n\tvoid debug_print(int num) {\n\t\tvector<T> v;\n\t\trep(i, num) {\n\t\t\tv.push_back(query(i));\n\t\t}\n\t\tcout << \"{\" << v << \"}\\n\";\n\t}\n};\n\n//座標圧縮\n\nclass compress {\npublic:\n\tmap<int, int> zip;\n\tvector<int> unzip;\n\n\tcompress(vector<int> x)\n\t{\n\t\tsort(x.begin(), x.end());\n\t\tx.erase(unique(x.begin(), x.end()), x.end());\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tzip[x[i]] = i;\n\t\t\tunzip.push_back(i);\n\t\t}\n\t}\n};\n\n\nint euclidean_gcd(int a, int b) {\n\twhile (1) {\n\t\tif (a < b) swap(a, b);\n\t\tif (!b) break;\n\t\ta %= b;\n\t}\n\treturn a;\n}\n\n//https://ei1333.github.io/luzhiled/snippets/dp/cumulative-sum-2d.html\ntemplate< class T >\nstruct CumulativeSum2D {\n\tvector< vector< T > > data;\n\n\tCumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0)) {}\n\n\tvoid add(int x, int y, T z) {\n\t\t++x, ++y;\n\t\tif (x >= data.size() || y >= data[0].size()) return;\n\t\tdata[x][y] += z;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tfor (int j = 1; j < data[i].size(); j++) {\n\t\t\t\tdata[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int sx, int sy, int gx, int gy) {\n\t\treturn (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n\t}\n};\n\n//lib\nint nC2(int n) {\n\treturn n * (n - 1) / 2;\n}\n\nclass node {\npublic:\n\tint depth;\n\tint num;\n\n\tnode(int d, int n) {\n\t\tdepth = d;\n\t\tnum = n;\n\t}\n};\n\ntemplate< class T >\nstruct CumulativeSum {\n\tvector< T > data;\n\n\tCumulativeSum(int sz) : data(sz, 0) {};\n\n\tvoid add(int k, T x) {\n\t\tdata[k] += x;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tdata[i] += data[i - 1];\n\t\t}\n\t}\n\n\tT query(int k) {\n\t\tif (k < 0) return (0);\n\t\treturn (data[min(k, (int)data.size() - 1)]);\n\t}\n\t//[left, right]の和\n\tT query(int left, int right) {\n\t\treturn query(right) - query(left - 1);\n\t}\n};\n\nstd::vector<int> eratosthenes_sieve(int n) {\n\tstd::vector<int> ps(n + 1);\n\tstd::iota(ps.begin() + 2, ps.end(), 2);\n\tfor (int i = 2; i * i <= n; ++i)\n\t\tif (ps[i])\n\t\t\tfor (int j = i * i; j <= n; j += i) ps[j] = 0;\n\treturn ps;\n}\n\nstd::vector<int> make_primes(int n) {\n\tstd::vector<int> ps = eratosthenes_sieve(n);\n\tps.erase(std::remove(ps.begin(), ps.end(), 0), ps.end());\n\treturn ps;\n}\n\n// 区間[a, b)の素数判定をする、is_prime[i]: a + i が素数 or not つまり is_prime[i-a] が true: iが素数\nstd::vector<bool> segment_eratosthenes_sieve(int a, int b) {\n\tvector<bool> is_prime(b - a, true);\n\tvector<bool> is_prime_small;\n\tfor (int i = 0; i*i < b; i++)is_prime_small.push_back(true);\n\n\tfor (int i = 2; i*i < b; i++) {\n\t\tif (is_prime_small[i]) {\n\t\t\tfor (int j = 2 * i; j*j < b; j += i) {\n\t\t\t\tis_prime_small[j] = false;\t// [2, sqrt(b))のふるい\n\t\t\t}\n\t\t\t// (a + i - 1LL) / i * i a以上の最小のiの倍数\n\t\t\tfor (int j = max(2LL, (a + i - 1LL) / i) * i; j < b; j += i) {\n\t\t\t\tis_prime[j - a] = false;\t// [a, b)のふるい\n\t\t\t}\n\t\t}\n\t}\n\treturn is_prime;\n}\n\nvector< int64_t > divisor(int64_t n) {\n\tvector< int64_t > ret;\n\tfor (int64_t i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\treturn (ret);\n}\n\n\n\n\n// 汎用的な二分探索のテンプレ(めぐる式)\nint binary_search(function<bool(int)> isOk, int ng, int ok) {\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1) {\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOk(mid)) ok = mid;\n\t\telse ng = mid;\n\t}\n\treturn ok;\n}\n\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t\t//n回以上更新されてたら負閉路がある\n\t\tif (i > n) {\n\t\t\tnegCycle = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//ゴールを指定して、それまでのパスに負閉路がなかったらOK(嘘修正済)\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s, int d) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\t// n回目の更新で d が更新されてたら問答無用で負閉路ありとしてNG\n\t\t\t\tif (i >= n - 1 && e.dst == d) {\n\t\t\t\t\tnegCycle = true;\n\t\t\t\t}\n\t\t\t\t// 終点以外に負閉路がある場合はそこの距離を十分小さい値に置き換える\n\t\t\t\telse if (i >= n - 1) {\n\t\t\t\t\tdist[e.dst] = -inf;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//R[i] == S[i] を中心とした極大回文長 なるvector Rを返す\nvector<int> Manachar(string S) {\n\tint len = S.length();\n\tvector<int> R(len);\n\n\tint i = 0, j = 0;\n\twhile (i < S.size()) {\n\t\twhile (i - j >= 0 && i + j < S.size() && S[i - j] == S[i + j]) ++j;\n\t\tR[i] = j;\n\t\tint k = 1;\n\t\twhile (i - k >= 0 && i + k < S.size() && k + R[i - k] < j) R[i + k] = R[i - k], ++k;\n\t\ti += k; j -= k;\n\t}\n\treturn R;\n}\n\nstd::vector<int> tsort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tstd::vector<int> ord(n), in(n);\n\tfor (auto &es : g)\n\t\tfor (auto &e : es) in[e.dst]++;\n\tstd::queue<int> q;\n\t//入次数0の点をキューに追加\n\tfor (int i = 0; i < n; ++i)\n\t\tif (in[i] == 0) q.push(i);\n\twhile (q.size()) {\n\t\tint v = q.front();\n\t\t//Sから node n を削除する\n\t\tq.pop();\n\t\t//L に n を追加する\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\t//選択した点から出てる辺を削除、0になったらキューに追加\n\t\t\tif (--in[e.dst] == 0) { \n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn *std::max_element(in.begin(), in.end()) == 0 ? ord : std::vector<int>();\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n\tconst Weight INF = std::numeric_limits<Weight>::max() / 8;\n\tusing state = std::tuple<Weight, int>;\n\tstd::priority_queue<state> q;\n\tstd::vector<Weight> dist(g.size(), INF);\n\tdist[s] = 0;\n\tq.emplace(0, s);\n\twhile (q.size()) {\n\t\tWeight d;\n\t\tint v;\n\t\tstd::tie(d, v) = q.top();\n\t\tq.pop();\n\t\td *= -1;\n\t\t/* if(v == t) return d; */\n\t\tif (dist[v] < d) continue;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (dist[e.dst] > dist[v] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[v] + e.weight;\n\t\t\t\tq.emplace(-dist[e.dst], e.dst);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nMatrix WarshallFloyd(const Graph &g) {\n\tauto const INF = std::numeric_limits<Weight>::max() / 8;\n\tint n = g.size();\n\tMatrix d(n, Array(n, INF));\n\trep(i, n) d[i][i] = 0;\n\trep(i, n) for (auto &e : g[i]) d[e.src][e.dst] = std::min(d[e.src][e.dst], e.weight);\n\trep(k, n) rep(i, n) rep(j, n) {\n\t\tif (d[i][k] != INF && d[k][j] != INF) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n\t}\n\treturn d;\n}\n\nstd::pair<std::vector<int>, std::vector<int>> prime_factor_decomp(int n) {\n\tstd::vector<int> p, e;\n\tint m = n;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (m % i != 0) continue;\n\t\tint c = 0;\n\t\twhile (m % i == 0) c++, m /= i;\n\t\tp.push_back(i);\n\t\te.push_back(c);\n\t}\n\tif (m > 1) {\n\t\tp.push_back(m);\n\t\te.push_back(1);\n\t}\n\treturn std::make_pair(p, e);\n}\n\nint extgcd(int a, int b, int &x, int &y) {\n\tint g = a;\n\tx = 1;\n\ty = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\n// 不定方程式 ax + by = c の一般整数解(pt + q, rt + s)を求める\n/*\n* exist: 解が存在するか否か\n* p, q, r, s: 存在するならば不定方程式の一般解(pt + q, rt + s)\n* ここで、式変形から、p > 0、 q < 0 となることに注意する。(解の条件を絞るときなどに必要になる)\n*/\nvoid IndeterminateEq(int a, int b, int c, bool& exist, int& p, int& q, int& r, int& s) {\n\tint X, Y;\n\n\tint g = euclidean_gcd(a, b);\n\n\t// c が最大公約数の整数倍でないならNG\n\tif (c % g != 0) {\n\t\texist = false;\n\t\treturn;\n\t}\n\texist = true;\n\n\t// 拡張ユークリッドの互除法で ax + by = gcd(a, b) なる (X, Y) を求める\n\textgcd(a, b, X, Y);\n\tint m = c / g;\n\n\t// ax + by = c の解にする\n\tX *= m;\n\tY *= m;\n\n\tint a2 = a / g;\n\tint b2 = b / g;\n\n\tp = b2;\n\tq = X;\n\tr = -a2;\n\ts = Y;\n}\n\n// x^n mod modulo を繰り返し二乗法で計算する \n// n を 2^k の和で表す -> n を二進表記したとき、kbit目(0-indexed)が立っているときだけx^kをかける\nint mod_pow(int x, int n, int modulo) {\n\tint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tres = res * x % modulo;\n\t\t}\n\t\tx = x * x % modulo;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint64_t popcnt(int64_t n)\n{\n\tint64_t c = 0;\n\tc = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\tc = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333);\n\tc = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f);\n\tc = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff);\n\tc = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff);\n\tc = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff);\n\treturn(c);\n}\n\n/*\n行列積と行列累乗\n行列積\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL)\n行列累乗\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL)\nT:\t\t\t考える集合(競プロにおいてはたぶんほぼ整数)\nl:\t\t\t左からかける行列\nr:\t\t\t右からかける行列\nplus:\t\t加法演算\nmultiple:\t乗法演算\neplus:\t\t加法の単位元\nemultiple:\t乗法の単位元\n*/\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL) {\n\tint rx = r[0].size();\n\tint ry = r.size();\n\tvector<vector<T> > ret;\n\n\tfor (int y = 0; y < ry; y++) {\n\t\tvector<T> add;\n\t\tfor (int x = 0; x < rx; x++) {\n\t\t\tT cell = eplus;\n\t\t\tfor (int i = 0; i < ry; i++) {\n\t\t\t\tT mul = multiple(l[y][i], r[i][x]);\n\t\t\t\tcell = plus(cell, mul);\n\t\t\t}\n\t\t\tadd.push_back(cell);\n\t\t}\n\t\tret.push_back(add);\n\t}\n\treturn ret;\n}\n\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL) {\n\tint k = m.size();\n\tif (n == 0) {\n\t\tvector<vector<T> > E;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\t// 単位行列は対角成分を乗法単位元、非対角成分をゼロ元で埋める\n\t\t\tvector<T> v(k, eplus);\n\t\t\tv[i] = emultiple;\n\t\t\tE.push_back(v);\n\t\t}\n\t\treturn E;\n\t}\n\tvector<vector<T>> ret = matrixPower(matrixMultiplies(m, m, plus, multiple, eplus), n / 2, plus, multiple, eplus, emultiple);\n\tif (n % 2 == 1) {\n\t\tret = matrixMultiplies(m, ret, plus, multiple);\n\t}\n\treturn ret;\n}\n\n// フロー系のアルゴリズム\n// 最大流\n/*\nFord-Fulkerson法(蟻本) O(F|E|)\nF: 最大流量\nE: 辺数\nコンストラクタ引数でノード数nを受け取り初期化し、add_edge で辺と逆辺を追加していく\n*/\nclass Ford_Fulkerson {\nprivate:\n\tstruct Edge {\n\t\tint src, dst;\n\n\t\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\t\tint rev;\n\t\tint cap;\n\t\tEdge(int s, int d, int c, int r) : src(s), dst(d), cap(c), rev(r) {}\n\t};\n\tvector<vector<Edge> > G;\n\tvector<bool> used;\npublic:\n\tFord_Fulkerson(int n) :\n\t\tG(n),\n\t\tused(n, false)\n\t{}\n\n\tvoid add_edge(int s, int d, int cap) {\n\t\tG[s].emplace_back(s, d, cap, G[d].size());\n\t\tG[d].emplace_back(d, s, 0, G[s].size() - 1);\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tused[v] = true;\n\t\tfor (Edge& e : G[v]) {\n\t\t\tif (!used[e.dst] && e.cap > 0) {\n\t\t\t\t// 流せる辺があったら流す\n\t\t\t\tint d = dfs(e.dst, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\t// 辺の残り容量を減らす\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\t// 逆辺の容量を増やす\n\t\t\t\t\tG[e.dst][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t にたどり着けなかったら0\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < used.size(); i++) {\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tint f = dfs(s, t, LL_HALFMAX);\n\t\t\tif (f == 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t}\n\n};\n\n/*\nDinic法 From libalgo O(V^2 * E)\ndinic::solve(s, t) : s -> t の最大流を求める\ndinic;;flow[u][v] : 辺(u, v)の流量\n*/\nstruct dinic {\n\tint n, s, t;\n\tstd::vector<int> level, prog, que;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tFlow inf;\n\tdinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tinf(std::numeric_limits<Flow>::max() / 8) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tFlow c = e.cap;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\t// 残りを求める\n\tinline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\n\t// 実際に最大流問題を解く\n\tFlow solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tFlow res = 0;\n\t\t// levelize() == false: bfs で s から t に到達できなかった\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\t// bfs でレベルグラフをつくる\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v]) {\n\t\t\t\t// まだレベルが決まっておらず、v -> dの辺に流せるならlevel[d] = level[v] + 1\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t に到達できるなら true を返す\n\t\treturn level[t] != -1;\n\t}\n\t// dfs で実際に流してみる\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif (v == t) return lim;\n\t\t// prog[v]: dfs において、vを展開する際、vの子の何番目まで展開したかを覚えておく\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\t// v -> d に流せない or v(流す側) の方がレベルが大きい(=深い)場合NG\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\t// 流せるなら、流せるだけ流す\n\t\t\tconst Flow aug = augment(d, std::min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\t// ノードvに来ている流量を使い切ったら終わり\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n/*\nPrimal-Dual法(蟻本版 / ベルマンフォード)\n*/\n\nclass Primal_Dual_BellmanFord {\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint src, dst;\n\n\t\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\t\tint rev;\n\t\tCost cost;\n\t\tFlow cap;\n\t\tEdge(int s, int d, int aRev, Cost aCost, Flow aCap) : src(s), dst(d), rev(aRev), cost(aCost), cap(aCap) {}\n\t};\n\n\tint V;\t\t\t\t\t\t\t//頂点数\n\tvector<vector<Edge>> G;\t\t\t// 隣接リスト\n\tvector<int> dist;\t\t\t\t// 最短距離\n\tvector<int> prevv;\t\t\t\t// 直前の頂点\n\tvector<int> preve;\t\t\t\t// 直前の辺\n\tconst int INF;\n\npublic:\n\t// 頂点数 n を引数にとって初期化\n\tPrimal_Dual_BellmanFord(int n) :\n\t\tV(n),\n\t\tG(n),\n\t\tdist(n, 0),\n\t\tprevv(n, 0),\n\t\tpreve(n, 0),\n\t\tINF(std::numeric_limits<int>::max() / 8) {}\n\tvoid add_edge(int src, int dst, int cap, int cost) {\n\t\t// cost は weight に入れる\n\t\tG[src].emplace_back(src, dst, G[dst].size(), cost, cap);\n\t\tG[dst].emplace_back(dst, src, G[src].size() - 1, -cost, 0);\n\t}\n\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\twhile (f > 0) {\n\t\t\t// ベルマンフォードによりs-t最短路をもとめる\n\t\t\tdist.assign(V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tEdge& e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.dst] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// これ以上流せない\n\t\t\tif (dist[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// 復元したs-t最短路に沿って流せるだけ流す\n\t\t\tint d = f;\n\t\t\t// 尻からprevvを辿っていき、流せる量を求める\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\t// 一つ手前に戻るための辺\n\t\t\t\tEdge &e = G[prevv[v]][preve[v]];\n\t\t\t\tchmin(d, e.cap);\n\t\t\t}\n\n\t\t\tf -= d;\n\n\t\t\t// ここでの dist はコスト和なので、それに流す量をかけると今回見つけた最短パスに流すコストとなる。\n\t\t\tres += d * dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n/*\nダイクストラ版 Primal-Dual\n出典: https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\n*/\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n\tconst cost_t INF;\n\n\tstruct edge {\n\t\tint to;\n\t\tflow_t cap;\n\t\tcost_t cost;\n\t\tint rev;\n\t\tbool isrev;\n\t\tedge(int aTo, flow_t aCap, cost_t aCost, int aRev, bool aIsRev) : to(aTo), cap(aCap), cost(aCost), rev(aRev), isrev(aIsRev) {}\n\t};\n\tvector< vector< edge > > graph;\n\tvector< cost_t > potential, min_cost;\n\tvector< int > prevv, preve;\n\n\tPrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n\tvoid add_edge(int from, int to, flow_t cap, cost_t cost) {\n\t\tgraph[from].emplace_back(to, cap, cost, (int)graph[to].size(), false);\n\t\tgraph[to].emplace_back(from, 0, -cost, (int)graph[from].size() - 1, true);\n\t}\n\n\tcost_t min_cost_flow(int s, int t, flow_t f) {\n\t\tint V = (int)graph.size();\n\t\tcost_t ret = 0;\n\t\tusing Pi = pair< cost_t, int >;\n\t\tpriority_queue< Pi, vector< Pi >, greater< Pi > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tque.emplace(0, s);\n\t\t\tmin_cost[s] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPi p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tcost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.emplace(min_cost[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tflow_t addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid output() {\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tif (e.isrev) continue;\n\t\t\t\tauto &rev_e = graph[e.to][e.rev];\n\t\t\t\tcout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass lca {\npublic:\n\tint n, segn;\n\tvector<int> path;\t\t// 蟻本の vs、オイラーツアーを保持\n\tvector<int> depth;\t\t// 蟻本の depth、path[i] であるノードの深さを保持\n\tvector<int> in_order;\t// 蟻本の id、ノードiがオイラーツアーで最初に出てくるインデックスを保持\n\tvector<pair<int, int>> dat;\n\tconst std::pair<int, int> INF = std::make_pair(1000000000, 1000000000);\n\n\tlca(const Graph& g, int root) : n(g.size()), path(n * 2 - 1), depth(n * 2 - 1), in_order(n) {\n\t\tint k = 0;\n\t\tdfs(g, root, -1, 0, k);\n\n\t\t// セグ木を構築、持つのはpair(depth, index) => depth が最小となる index がわかる \n\t\tfor (segn = 1; segn < n * 2 - 1; segn <<= 1);\n\n\t\tdat.assign(segn * 2, INF);\n\t\tfor (int i = 0; i < (int)depth.size(); ++i) dat[segn + i] = std::make_pair(depth[i], i);\n\t\tfor (int i = segn - 1; i >= 1; --i) dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n\t}\n\n\tint get(int u, int v) const {\n\t\tint l = std::min(in_order[u], in_order[v]);\n\t\tint r = std::max(in_order[u], in_order[v]) + 1;\n\t\treturn path[range_min(1, segn, l, r).second];\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d, int& k) {\n\t\t// k: オイラーツアーの何番目かを保持する変数\n\t\tin_order[v] = k;\n\t\tpath[k] = v;\n\t\tdepth[k++] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.dst != p) {\n\t\t\t\tdfs(g, e.dst, v, d + 1, k);\n\t\t\t\t// ここに来た時はノードvの子であるe.dstを展開し終わってvに戻ってきたときなので、再度 path と depth に記録する\n\t\t\t\tpath[k] = v;\n\t\t\t\tdepth[k++] = d;\n\t\t\t}\n\t\t}\n\t}\n\n\t// v : いまみてるノード、w: 今見てるノードに対応する区間長 l: ? r: ?\n\tpair<int, int> range_min(int v, int w, int l, int r) const {\n\t\tif (r <= l || w == 0) return INF;\n\t\tif (r - l == w)\n\t\t\treturn dat[v];\n\n\t\tint m = w / 2;\n\t\tauto rmin = range_min(v * 2, m, l, std::min(r, m));\n\t\tauto lmin = range_min(v * 2 + 1, m, std::max(0LL, l - m), r - m);\n\n\t\treturn min(rmin, lmin);\n\t}\n};\n\n// int における ceil と floor、負数対応(a / b の ceil, floor)\nint64_t intceil(int64_t a, int64_t b) {\n\tint sign_a = (a > 0) - (a < 0);\n\tint sign_b = (b > 0) - (b < 0);\n\n\tif (sign_a == sign_b) {\n\t\treturn (a + b - sign_b) / b;\n\t}\n\telse {\n\t\treturn a / b;\n\t}\n}\nint64_t intfloor(int64_t a, int64_t b) {\n\tint sign_a = (a > 0) - (a < 0);\n\tint sign_b = (b > 0) - (b < 0);\n\n\tif (sign_a == sign_b) {\n\t\treturn a / b;\n\t}\n\telse {\n\t\treturn (a - b + sign_b) / b;\n\t}\n}\n\nclass Point {\npublic:\n\tint y, x;\n\tPoint() { y = x = 0; }\n\tPoint(int y0, int x0) {\n\t\ty = y0;\n\t\tx = x0;\n\t}\n\tPoint operator+(const Point& p) const { return Point(y + p.y, x + p.x); }\n\tPoint operator-(const Point& p) const { return Point(y - p.y, x - p.x); }\n\tPoint operator*(int a) const { return Point(y * a, x * a); }\n\tlong long length2() const { return y * (long long)y + x * (long long)x; }\n\tlong long dist2(const Point& p) const {\n\t\treturn (y - p.y) * (long long)(y - p.y) + (x - p.x) * (long long)(x - p.x);\n\t}\n\tlong long dot(const Point& p) const {\n\t\treturn y * (long long)p.y + x * (long long)p.x;  // |a|*|b|*cosθ\n\t}\n\tlong long cross(const Point& p) const {\n\t\treturn x * (long long)p.y - y * (long long)p.x;  // |a|*|b|*sinθ\n\t}\n\n\tstatic bool Sorter(const Point& p1, const Point& p2) {\n\t\tbool a = p1.y > 0 || (p1.y == 0 && p1.x >= 0);\n\t\tbool b = p2.y > 0 || (p2.y == 0 && p2.x >= 0);\n\t\tif (a != b) return a;\n\t\tlong long c = p2.x * (long long)p1.y;\n\t\tlong long d = p1.x * (long long)p2.y;\n\t\tif (c != d) return c < d;\n\t\treturn p1.length2() < p2.length2();\n\t}\n};\n\n// ランレングス圧縮\ntemplate<typename T>\nvector<pair<T, int>> RunLength(vector<T> arr) {\n\tT now = arr[0];\n\tint len = arr.size();\n\n\tvector<pair<T, int>> res;\n\tint cnt = 0;\n\trep(i, len) {\n\t\tif (arr[i] != now) {\n\t\t\tres.emplace_back(now, cnt);\n\t\t\tnow = arr[i];\n\t\t\tcnt = 0;\n\t\t}\n\t\tcnt++;\n\t}\n\n\tres.push_back(mp(now, cnt));\n\treturn res;\n}\n\n\nvoid solve(ostringstream& aout, long long N, long long Q, std::vector<long long> t, std::vector<long long> u, std::vector<long long> v);\nvoid solve_TLE(ostringstream& aout, long long N, long long Q, std::vector<long long> t, std::vector<long long> u, std::vector<long long> v);\n\nclass StressTest {\nprivate:\n\tmt19937 m_RandEngine;\n\tbool judge_case(long long N, long long Q, std::vector<long long> t, std::vector<long long> u, std::vector<long long> v) {\n\t\tostringstream fast, tle;\n\t\tsolve(fast, N, Q, std::move(t), std::move(u), std::move(v));\n\t\tsolve_TLE(tle, N, Q, std::move(t), std::move(u), std::move(v));\n\t\tif (fast.str() == tle.str()) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// [l, l+1, ... r] の数列を生成し、シャッフルする\n\tvector<int> create_range_permutation(int l, int r) {\n\t\tvector<int> ret;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tret.push_back(i);\n\t\t}\n\t\tshuffle(ret.begin(), ret.end(), m_RandEngine);\n\t\treturn ret;\n\t}\n\t// [1, n] の順列を生成する\n\tvector<int> create_permutation(int n) {\n\t\tcreate_range_permutation(1, n);\n\t}\n\t// 範囲が[l, r] でサイズが n の数列を生成する\n\tvector<int> create_random_sequence(int l, int r, int n) {\n\t\tuniform_int_distribution<> randLR(l, r);\n\t\tvector<int> ret;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret.push_back(randLR(m_RandEngine));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数 n, 辺数 m で自己ループと多重辺のない無向グラフを生成\n\t* 慣習的に頂点番号が1-indexed な AtCoder で 1-n の頂点が使えるようにするため n+1 頂点のグラフを生成し、0番を無視することとする\n\t* weighted を true にすると重み付き、maxWeight で最大重みを指定\n\t* 連結でないグラフが出力される可能性があることに注意する\n\t*/\n\tGraph create_undirected_graph(int n, int m, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tset<pair<int, int>> used;\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\t\twhile (used.size() < m * 2) {\n\t\t\tint src = randNode(m_RandEngine);\n\t\t\tint dst = randNode(m_RandEngine);\n\n\t\t\t// 自己ループ、多重辺判定\n\t\t\tif (used.count(make_pair(src, dst)) == 0 && used.count(make_pair(dst, src)) == 0 && src != dst) {\n\t\t\t\tused.insert(make_pair(src, dst));\n\t\t\t\tused.insert(make_pair(dst, src));\n\t\t\t\tadd_edge(ret, src, dst, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数 n, 辺数 m で自己ループと多重辺のない有向グラフを生成\n\t* 慣習的に頂点番号が1-indexed な AtCoder で 1-n の頂点が使えるようにするため n+1 頂点のグラフを生成し、0番を無視することとする\n\t* weighted を true にすると重み付き、maxWeight で最大重みを指定\n\t* 連結でないグラフが出力される可能性があることに注意する\n\t*/\n\tGraph create_directed_graph(int n, int m, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tset<pair<int, int>> used;\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\t\twhile (used.size() < m) {\n\t\t\tint src = randNode(m_RandEngine);\n\t\t\tint dst = randNode(m_RandEngine);\n\n\t\t\t// 自己ループ、多重辺判定\n\t\t\tif (used.count(make_pair(src, dst)) == 0 && src != dst) {\n\t\t\t\tused.insert(make_pair(src, dst));\n\t\t\t\tadd_arc(ret, src, dst, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数nの木(無向)を生成します。\n\t*/\n\tGraph create_tree(int n, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tuf_tree uf(n + 1);\n\t\tint cnt = 0;\n\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\n\t\twhile (cnt < n - 1) {\n\t\t\tint n1 = randNode(m_RandEngine);\n\t\t\tint n2 = randNode(m_RandEngine);\n\t\t\tif (n1 != n2 && !uf.is_same(n1, n2)) {\n\t\t\t\tcnt++;\n\t\t\t\tadd_edge(ret, n1, n2, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tStressTest(int seed) :\n\t\tm_RandEngine(seed) {}\n\tvoid test() {\n\t\twhile (1) {\n\t\t\t// TODO: generate random case\n\t\t\t//if (!judge_case(N, Q, std::move(t), std::move(u), std::move(v))) {\n\t\t\t\t// TODO: output case\n\t\t\t\t//break;\n\t\t\t//}\n\t\t}\n\t}\n};\n\nvoid solve(ostringstream& aout, long long N, long long Q, std::vector<long long> t, std::vector<long long> u, std::vector<long long> v){\n\tatcoder::dsu uf(N);\n\n\trep(i, Q) {\n\t\tif (t[i] == 0) {\n\t\t\tuf.merge(u[i], v[i]);\n\t\t}\n\t\telse {\n\t\t\tif (uf.same(u[i], v[i])) {\n\t\t\t\tcout << 1 << \"\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 0 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve_TLE(ostringstream& aout, long long N, long long Q, std::vector<long long> t, std::vector<long long> u, std::vector<long long> v) {\n\n}\n\nsigned main() {\n\tint N, D;\n\tcin >> N >> D;\n\n\tvector<int> X(N), Y(N);\n\trep(i, N) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\n\tatcoder::two_sat ts(N * 2);\n\n\trep(i, N) {\n\t\tts.add_clause(i * 2, true, i * 2 + 1, true);\n\t}\n\n\trep(i, N) {\n\t\tREP(j, i+1, N) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tts.add_clause(i * 2, false, j * 2, false);\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tts.add_clause(i * 2, false, j * 2 + 1, false);\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tts.add_clause(i * 2 + 1, false, j * 2, false);\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tts.add_clause(i * 2 + 1, false, j * 2 + 1, false);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\\n\";\n\t}\n\telse {\n\t\tcout << \"No\\n\";\n\t\treturn 0;\n\t}\n\n\tauto ans = ts.answer();\n\trep(i, N) {\n\t\tif (ans[i * 2]) {\n\t\t\tcout << X[i] << \"\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << Y[i] << \"\\n\";\n\t\t}\n\t}\n\n\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, D, X[1010][2];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> D;\n\trep(i, 0, N) rep(j, 0, 2) cin >> X[i][j];\n\n\ttwo_sat ts(N);\n\trep(x1, 0, N) rep(b1, 0, 2) rep(x2, x1 + 1, N) rep(b2, 0, 2) {\n\t\tint d = abs(X[x1][b1] - X[x2][b2]);\n\t\tif (d < D) ts.add_clause(x1, b1, x2, b2);\n\t}\n\tbool ans = ts.satisfiable();\n\n\tif (!ans) {\n\t\tprintf(\"No\\n\");\n\t\treturn;\n\t}\n\n\tauto v = ts.answer();\n\n\tprintf(\"Yes\\n\");\n\trep(i, 0, N) printf(\"%d\\n\", X[i][v[i]]);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <cstdio>\n#define rep(i, j, n) for (int i = j; i < n; ++i)\n\nint n, d, x[1000], y[1000];\n\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  rep(i, 0, n) scanf(\"%d%d\", &x[i], &y[i]);\n  \n  atcoder::two_sat ts(n);\n  rep(i, 0, n) rep(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_clause(i, true, j, true);\n    if (abs(x[i] - y[j]) < d) ts.add_clause(i, true, j, false);\n    if (abs(y[i] - x[j]) < d) ts.add_clause(i, false, j, true);\n    if (abs(y[i] - y[j]) < d) ts.add_clause(i, false, j, false);\n  }\n  if (ts.satisfiable()) {\n    printf(\"Yes\\n\");\n    auto b = ts.answer();\n    rep(i, 0, n) printf(\"%d\\n\", b[i] ? y[i] : x[i]);\n  } else\n    printf(\"No\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define ALL(a) a.begin(),a.end()\n#define INIT(a,b) memset(a,b,sizeof(a))\nusing lint = long long int;\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n\n    vector<int> X(N), Y(N);\n    for_(i,0,N) cin >> X[i] >> Y[i];\n\n    two_sat ts(N);\n    for_(i,0,N) for_(j,i+1,N) {\n        if (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n        if (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n        if (abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n        if (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n    }\n\n    if (!ts.satisfiable()) {\n        puts(\"No\");\n        return 0;\n    }\n\n    puts(\"Yes\");\n    auto ans = ts.answer();\n    for_(i,0,N) cout << (ans[i] ? X[i] : Y[i]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\ntypedef long long lint;\nusing namespace std;\nusing namespace atcoder;\n\nint n, d;\nvector<int> x, y;\n\nint main() {\n    cin >> n >> d;\n    x.resize(n);\n    y.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    // ts[i]:true<=>x[i]を使う\n    two_sat ts(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto res = ts.answer();\n        for (int i = 0; i < n; i++) {\n            int ans = res[i] ? x[i] : y[i];\n            cout << ans << endl;\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// URL : https://atcoder.jp/contests/practice2/tasks/practice2_h\n#pragma region optimize\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma endregion\n#include <bits/stdc++.h>\nusing namespace std;\n#pragma region boost multiprecision\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using Bint       = boost::multiprecision::cpp_int;\n// using Bfloat32   = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>;\n// using Bfloat1024 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<1024>>;\n#pragma endregion\n// #define int long long\n// #define endl '\\n'\n#include <atcoder/all>\n\n#pragma region TEMPLATE\n// clang-format off\n/* TYPE */\ntypedef long long ll;       typedef long double ld;\ntypedef pair<int, int> pii; typedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;   typedef vector<pll> vpll;\ntypedef vector<int> vi;     typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb;\ntypedef vector<ld> vld;     typedef vector<vector<int>> vvi;\ntemplate<typename T, typename Cmp = less<>> using prique = priority_queue<T, vector<T>, Cmp>;\ntemplate<typename T> using prique_r = prique<T, greater<>>;\n/* CONSTANT */\n#define ln '\\n'\nconst int INF = 1 << 30;    const ll INFF = 1LL << 60;  const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 1e9 + 7;    const int MODD = 998244353; const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double EPS = 1e-9;    const ld PI = 3.14159265358979323846264338327950288;\nconst int dx[] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nconst int dy[] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n/* CONTAINER */\n#define PB              emplace_back\n#define ALL(v)          (v).begin(), (v).end()\n#define RALL(v)         (v).rbegin(), (v).rend()\n#define SORT(v)         sort(ALL(v))\n#define RSORT(v)        sort(RALL(v))\n#define LESS(x, val)    (lower_bound(x.begin(), x.end(), val) - x.begin())\n#define LEQ(x, val)     (upper_bound(x.begin(), x.end(), val) - x.begin())\n#define GREATER(x, val) (int)(x).size() - LEQ((x), (val))\n#define GEQ(x, val)     (int)(x).size() - LESS((x), (val))\n#define UNIQUE(v)       sort(ALL(v)); (v).erase(unique(ALL(v)), (v).end())\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value != 0> fill_v(U &u, const V... v) { u = U(v...); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value == 0> fill_v(U &u, const V... v) { for (auto &e : u) fill_v<T>(e, v...); }\n/* LOOP */\n#define _overload3(_1, _2, _3, name, ...) name\n#define _REP(i, n)      REPI(i, 0, n)\n#define REPI(i, a, b)   for (ll i = (ll)a; i < (ll)b; ++i)\n#define REP(...)        _overload3(__VA_ARGS__, REPI, _REP,)(__VA_ARGS__)\n#define _RREP(i, n)     RREPI(i, n, 0)\n#define RREPI(i, a, b)  for (ll i = (ll)a; i >= (ll)b; --i)\n#define RREP(...)       _overload3(__VA_ARGS__, RREPI, _RREP,)(__VA_ARGS__)\n#define EACH(e, v)      for (auto& e : v)\n#define PERM(v)         sort(ALL(v)); for (bool c##p = true; c##p; c##p = next_permutation(ALL(v)))\n/* INPUT */\ntemplate<typename T> void SSS(T& t) { cin >> t; }\ntemplate<typename Head, typename... Tail> void SSS(Head&& head, Tail&&... tail) { cin >> head; SSS(tail...); }\n#define SS(T, ...)      T __VA_ARGS__; SSS(__VA_ARGS__);\n#define SV(T, v, n)     vector<T> v(n); for (auto& i : v) cin >> i;\n#define SVV(T, v, n, m) vector<vector<T>> v(n, vector<T>(m)); for (auto& r : v) for (auto& i : r) cin >> i;\n/* OUTPUT */\n// Yes / No\ninline int YES(bool x) { cout << (x ? \"YES\"  : \"NO\") << endl; return 0; }\ninline int Yes(bool x) { cout << (x ? \"Yes\"  : \"No\") << endl; return 0; }\ninline int yes(bool x) { cout << (x ? \"yes\"  : \"no\") << endl; return 0; }\ninline int yES(bool x) { cout << (x ? \"yES\"  : \"nO\") << endl; return 0; }\ninline int Yay(bool x) { cout << (x ? \"Yay!\" : \":(\") << endl; return 0; }\n// PROTOTYPE DECLARATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j);\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t);\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)> = nullptr> ostream& operator<<(ostream &os, const C &c);\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j);\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j);\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j);\n// IMPLEMENTATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j) { return os << '{' << j.first << \", \" << j.second << '}'; }\ntemplate<size_t num = 0, typename... T> enable_if_t<num == sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) {}\ntemplate<size_t num = 0, typename... T> enable_if_t<num <  sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) { os << get<num>(t); if (num + 1 < sizeof...(T)) os << \", \"; PRINT_TUPLE<num + 1>(os, t); }\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { PRINT_TUPLE(os << '{', t); return os << '}'; }\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)>> ostream& operator<<(ostream &os, const C &c) { os << '{'; for (auto it = begin(c); it != end(c); it++) { if (begin(c) != it) os << \", \"; os << *it; } return os << '}'; }\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_back(c.front()); return os << d; }\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\n// OUTPUT FUNCTION\ntemplate<typename T> int PV(T &v) { int sz = v.size(); for (int i = 0; i < sz; ++i) cout << v[i] << \" \\n\"[i == sz - 1]; return 0; }\ninline int print() { cout << endl; return 0; }\ntemplate<typename Head> int print(Head&& head){ cout << head; return print(); }\ntemplate<typename Head, typename... Tail> int print(Head&& head, Tail&&... tail) { cout << head << \" \"; return print(forward<Tail>(tail)...); }\n#ifdef LOCAL\ninline void dump() { cerr << endl; }\ntemplate<typename Head> void dump(Head&& head) { cerr << head; dump(); }\ntemplate<typename Head, typename... Tail> void dump(Head&& head, Tail&&... tail) { cerr << head << \", \"; dump(forward<Tail>(tail)...); }\n#define debug(...) do {cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; dump(__VA_ARGS__); } while (false)\n#else\n#define dump(...)\n#define debug(...)\n#endif\n/* OTHER */\n#define fi              first\n#define se              second\n#define MP              make_pair\n#define MT              make_tuple\ntemplate<typename T, typename A, typename B> inline bool between(T x, A a, B b) { return ((a <= x) && (x < b)); }\ntemplate<typename A, typename B> inline bool chmax(A &a, const B &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename A, typename B> inline bool chmin(A &a, const B &b) { if (a > b) { a = b; return true; } return false; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ninline ll POW(ll a, ll b) { ll r = 1; do { if (b & 1)  r *= a; a *= a; } while (b >>= 1); return r; }\nstruct abracadabra {\n    abracadabra() {\n        cin.tie(nullptr); ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n        cerr << fixed << setprecision(5);\n    };\n} ABRACADABRA;\n// clang-format on\n#pragma endregion\n\nint solve();\n\nsigned main() {\n    // int _T; cin >> _T; for (int t = 1; t <= _T; ++t)\n    solve();\n}\n\nint solve() {\n    SS(int, N, D);\n    atcoder::two_sat ts(2 * N);\n\n    vector<pair<int, int>> XY(N);\n    REP (i, N)\n        cin >> XY[i].fi >> XY[i].se;\n\n    REP (i, N)\n        ts.add_clause(2 * i, true, 2 * i + 1, true);\n    REP (i, N) {\n        REP (j, N) {\n            if (i == j) continue;\n            auto [xi, yi] = XY[i];\n            auto [xj, yj] = XY[j];\n            if (abs(xi - xj) < D) ts.add_clause(2 * i, false, 2 * j, false);\n            if (abs(xi - yj) < D) ts.add_clause(2 * i, false, 2 * j + 1, false);\n            if (abs(yi - xj) < D) ts.add_clause(2 * i + 1, false, 2 * j, false);\n            if (abs(yi - yj) < D) ts.add_clause(2 * i + 1, false, 2 * j + 1, false);\n        }\n    }\n\n    if (not ts.satisfiable()) return Yes(0);\n    Yes(1);\n\n    auto ans = ts.answer();\n    REP (i, N) {\n        if (ans[2 * i])\n            print(XY[i].fi);\n        else\n            print(XY[i].se);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\n#define rep(i, s, t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i, s, t) for(ll i = (ll)(s - 1); (ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max() / 4;\nconstexpr ll n_max = 2e5 + 10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {\n    return '\"' + s + '\"';\n}\nstring to_string(const char *c) {\n    return to_string((string)c);\n}\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\nvoid debug_out() {\n    cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <class T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n, d;\n    cin >> n >> d;\n\n    atcoder::two_sat ts(n);\n    vector<ll> x(n), y(n);\n    rep(i, 0, n) {\n        cin >> x[i] >> y[i];\n    }\n\n    rep(i, 0, n) {\n        rep(j, i + 1, n) {\n            if(abs(x[i] - x[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if(!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto v = ts.answer();\n    rep(i, 0, n) {\n        if(v[i]) {\n            cout << x[i] << \"\\n\";\n        } else {\n            cout << y[i] << \"\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\n#define pp pair<int,int>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define ld long double\n#define al(a) (a).begin(),(a).end()\n#define mk make_pair\n#define check cout<<\"?\"<<endl;\n\nll MOD=1000000007;\nll mod=998244353;\nint inf=1000001000;\nll INF=1e18+5;\n\nint main(){\n    int n,d; cin>>n>>d;\n    vector<int> x(2*n,0);\n    rep(i,2*n) cin>>x[i];\n    two_sat ts{n};\n    for(int i=0;i<2*n-1;i++)for(int j=i+1;j<2*n;j++){\n        if(i/2==j/2) continue;\n        if(abs(x[i]-x[j])<d) ts.add_clause(i/2,i%2==0,j/2,j%2==0);\n    }\n    if(!(ts.satisfiable())){\n        printf(\"No\\n\");\n        return 0;\n    }\n    auto ans=ts.answer();\n    printf(\"Yes\\n\");\n    rep(i,n) printf(\"%d\\n\",x[2*i+ans[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long int\n#define vec vector<ll>\n#define mat vector<vector<ll>>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst ll mod=1000000007;\nconst ll inf=LONG_LONG_MAX;\nll dx4[4]={1,0,-1,0};\nll dy4[4]={0,-1,0,1};\nll dx8[8]={1,0,-1,1,-1,1,0,-1};\nll dy8[8]={1,1,1,0,0,-1,-1,-1};\n\nint main(){\n\n  ll n,d;\n  cin >> n >> d;\n  \n  vec x(n),y(n);\n  for(ll i=0;i<n;i++)cin >> x[i] >> y[i];\n\n  two_sat ts(n);\n\n  for(ll i=0;i<n;i++){\n    for(ll j=i+1;j<n;j++){\n      if (abs(x[i] - x[j]) < d) {\n        // cannot use both of x[i] and x[j]\n        ts.add_clause(i, false, j, false);\n      }\n      if (abs(x[i] - y[j]) < d) {\n        ts.add_clause(i, false, j, true);\n      }\n      if (abs(y[i] - x[j]) < d) {\n        ts.add_clause(i, true, j, false);\n      }\n      if (abs(y[i] - y[j]) < d) {\n        ts.add_clause(i, true, j, true); \n      }     \n    }\n  }\n\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  cout << \"Yes\" << endl;\n  auto answer = ts.answer();\n  for (int i = 0; i < n; i++) {\n    if (answer[i])\n      cout << x[i] << endl;\n    else\n      cout << y[i] << endl;\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    rep(i, N) cin >> X[i] >> Y[i];\n    two_sat ts(N * 2);\n    rep(i, N) {\n        ts.add_clause(i * 2, true, i * 2 + 1, true);\n    }\n    rep(i, N - 1) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i * 2, false, j * 2, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i * 2, false, j * 2 + 1, false);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i * 2 + 1, false, j * 2, false);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i * 2 + 1, false, j * 2 + 1, false);\n            }\n        }\n    }\n    if (ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        auto ans = ts.answer();\n        rep(i, N) {\n            if (i * 2) cout << X[i] << \"\\n\";\n            else cout << Y[i] << \"\\n\";\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, a) for (int i = (int)0; i < (int)a; ++i)\n#define rrep(i, a) for (int i = (int)a - 1; i >= 0; --i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define RREP(i, a, b) for (int i = (int)a - 1; i >= b; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define popcount __builtin_popcount\nusing ll = long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\n// #pragma GCC target(\"avx2\")\n// #pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"unroll-loops\")\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n\tif (a > b)\n\t{\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nll gcd(ll n, ll m)\n{\n\tll tmp;\n\twhile (m != 0)\n\t{\n\t\ttmp = n % m;\n\t\tn = m;\n\t\tm = tmp;\n\t}\n\treturn n;\n}\n\nll lcm(ll n, ll m)\n{\n\treturn abs(n) / gcd(n, m) * abs(m); //gl=xy\n}\n\nusing namespace std;\nusing namespace atcoder;\n\nvoid solve(){\n\tint n;\n\tll d;\n\tcin>>n>>d;\n\ttwo_sat ts(n);\n\tvector<ll>x(n),y(n);\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t//x:0,y:1\n\trep(i,n){\n\t\tREP(j,i+1,n){\n\t\t\tif(abs(x[i]-x[j])<d){\n\t\t\t\tts.add_clause(i,1,j,1);\n\t\t\t}\n\t\t\tif(abs(x[i]-y[j])<d){\n\t\t\t\tts.add_clause(i,1,j,0);\n\t\t\t}\n\t\t\tif(abs(y[i]-x[j])<d){\n\t\t\t\tts.add_clause(i,0,j,1);\n\t\t\t}\n\t\t\tif(abs(y[i]-y[j])<d){\n\t\t\t\tts.add_clause(i,0,j,0);\n\t\t\t}\n\t\t}\n\t}\n\tif(ts.satisfiable()){\n\t\tcout<<\"Yes\\n\";\n\t\tauto v=ts.answer();\n\t\trep(i,v.size()){\n\t\t\tif(v[i]==0){\n\t\t\t\tcout<<x[i]<<\"\\n\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<y[i]<<\"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tcout<<\"No\\n\";\n\t}\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <atcoder/twosat>\n\nusing namespace std;\n\nint main(){\n    int N, D; cin >> N >> D;\n    vector<int> p(2*N);\n    for(auto& t : p) cin >> t;\n    atcoder::two_sat ts(N);\n    for(int i=0;i<2*N;i++){\n        for(int j=2*(i/2+1);j<2*N;j++){\n            if(abs(p[i]-p[j]) >= D) continue;\n            ts.add_clause(i/2, !(i%2), j/2, !(j%2));\n        }\n    }\n    if(ts.satisfiable()){\n        cout << \"Yes\" << endl;\n        auto b = ts.answer();\n        for(int i=0;i<N;i++) cout << p[2*i+b[i]] << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n\nusing namespace std;\n#ifdef __DEBUG__\n    void debug_out() { cerr << endl; } \n    template <typename Head, typename... Tail>\n    void debug_out(Head H, Tail... T) {cerr << \" \" << H; debug_out(T...);}\n    #define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n    #define debug(...) \n#endif\n\nusing ll = long long int;\nusing pii = pair<int, int>;\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\n\nint N,D;\nvector<pii> X;\ninline void input(){\n    fast_io();\n    cin >> N >> D;\n    for (int i = 0; i < N; i++)\n    {\n        int x,y; cin >> x >> y;\n        X.emplace_back(x,y);\n    }\n}\n\ninline int solve(){\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            if(i==j) continue;\n            if(abs(X[i].first-X[j].first)<D) ts.add_clause(i,true,j,true);\n            if(abs(X[i].first-X[j].second)<D) ts.add_clause(i,true,j,false);\n            if(abs(X[i].second-X[j].first)<D) ts.add_clause(i,false,j,true);\n            if(abs(X[i].second-X[j].second)<D) ts.add_clause(i,false,j,false);\n        }\n    }\n    cout << (ts.satisfiable() ? \"Yes\" : \"No\") << endl;\n    if(ts.satisfiable()){\n        auto ans = ts.answer();\n        for (int i = 0; i < N; i++)\n        {\n            if(ans[i]) cout << X[i].first << \"\\n\";\n            else cout << X[i].second << \"\\n\";\n        }\n    }\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<61;\nint iinf=1<<30;\ndouble pi=3.14159265358979323846;\ndouble pi2=pi/2.0;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,0,-1,0};\nint dw[4]={0,1,0,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<0)a=-a;\n    if(b<0)b=-b;\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    // @return m\n    unsigned int umod() const { return _m; }\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  // namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}  // namespace internal\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}  // namespace atcoder\n#endif  // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n}  // namespace atcoder\n#endif  // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}  // namespace atcoder\n#endif  // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}  // namespace atcoder\n#endif  // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}  // namespace atcoder\n#endif  // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}  // namespace internal\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n}  // namespace atcoder\n#endif  // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satis() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n//dsu d(n) d.merge d.same d.leader d.size vector<vector<int>> d.groups()\n//fenwick_tree<ll> fw(n) fw.add(p,x) fw.sum(l,r)\n// pll crt(vector<ll> r,vector<ll> m)   x≡y (modz) {y,z}\n// floor_sum(n,m,a,b) Σi=0:i=n-1 floor((a*i+b)/m) O(log)\n// mf_graph<int/ll> graph(n) int graph.add_edge(from,to,cap) (the number of edge) graph.flow(s,t)\n//graph.flow(s,t,flow_limit) if(allcap==1) O(min(n^(2/3)m,m^(3/2)) else O(mnn)\n//graph.change_cap(i,new_cap,new_flow) (can change)\n//mf_graph<cap>::edge graph.get_edge(i) from,to,cap,flow\n//vector<mf_graph<cap>::edge> graph.edges()\n//mcf_graph<cap,cost> graph(n) int graph.add_edge(from,to,cap,cost) (the number of edge)\n//pair<cap,cost> graph.flow(s,t,(flow_limit)) vector<pair<cap,cost>> graph.slope(s,t) ??\n//O(FV^2)or O(FElogV)\n// using mint=static_modint<mod>;\n//my SCC\n//vector<ll> convolution<prime>(vector<ll> a,vector<ll> b)\n//vector<ll> convolution_ll(vector<ll> a,vector<ll> b) no mod\n//two_sat ts(n) ts.add(i,bool f,j,bool g)\n//bool ts.satis() vector<bool> ts.answer()\nusing namespace atcoder;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,d;cin>>n>>d;\n    two_sat ts(n);\n    int x[n],y[n];\n    rep(i,0,n)cin>>x[i]>>y[i];\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(abs(x[j]-x[i])<d)ts.add(i,false,j,false);\n            if(abs(x[j]-y[i])<d)ts.add(i,true,j,false);\n            if(abs(y[j]-x[i])<d)ts.add(i,false,j,true);\n            if(abs(y[j]-y[i])<d)ts.add(i,true,j,true);\n        }\n    }\n    bool u=ts.satis();\n    if(!u){\n        cout<<\"No\"<<endl;\n    }\n    else{\n        cout<<\"Yes\"<<endl;\n        vector<bool> v=ts.answer();\n        rep(i,0,n){\n            if(v[i])cout<<x[i]<<endl;\n            else cout<<y[i]<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll=long long;\ntemplate<class T,class U> inline bool chmin(T&x,U y){if(x>y){x=y;return true;}return false;}\ntemplate<class T,class U> inline bool chmax(T&x,U y){if(x<y){x=y;return true;}return false;}\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nvoid solve(){\n    int n,d;\n    cin>>n>>d;\n    two_sat ts(n);\n    vector<int> x(n),y(n);\n    fr(i,n) cin>>x[i]>>y[i];\n    fr(i,n) fr(j,i){\n        if(abs(x[i]-x[j])<d) ts.add_clause(i,false,j,false);\n        if(abs(x[i]-y[j])<d) ts.add_clause(i,false,j,true);\n        if(abs(y[i]-x[j])<d) ts.add_clause(i,true,j,false);\n        if(abs(y[i]-y[j])<d) ts.add_clause(i,true,j,true);\n    }\n    if(!ts.satisfiable()){\n        puts(\"No\");\n        return;\n    }\n    cout<<\"Yes\"<<'\\n';\n    auto ans=ts.answer();\n    fr(i,n) cout<<(ans[i]?x[i]:y[i])<<'\\n';\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\n\ntypedef long long ll;\ntypedef std::pair<ll, ll> P;\n\nconstexpr ll INF = 1e15;\nconstexpr ll mod = 1e9+7;\n\n#define rep(i,n) for(int i = 0; i < int(n); i++)\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n\nint main() {\n    ll n, d;\n    cin >> n >> d;\n    vector<P> ps(n);\n    rep(i, n) {\n        cin >> ps[i].first >> ps[i].second;\n    }\n    auto graph = atcoder::two_sat(n);\n    rep(i, n) {\n        rep(j, n) {\n            if (i == j) continue;\n            //条件を満たさない場合にノードをつなぐ\n            if (abs(ps[i].first - ps[j].first) < d) {\n                graph.add_clause(i, true, j, true);\n            }\n            if (abs(ps[i].first - ps[j].second) < d) {\n                graph.add_clause(i, true, j, false);\n            }\n            if (abs(ps[i].second - ps[j].first) < d) {\n                graph.add_clause(i, false, j, true);\n            }\n            if (abs(ps[i].second - ps[j].second) < d) {\n                graph.add_clause(i, false, j, false);\n            }\n        }\n    }\n    if (graph.satisfiable()) {\n        cout << \"Yes\" << endl;\n        auto ans = graph.answer();\n        rep(i, n) {\n            if (!ans[i]) {\n                cout << ps[i].first << endl;\n            }\n            else {\n                cout << ps[i].second << endl;\n            }\n        }\n        return 0;\n    }\n    cout << \"No\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i,n) for (int i = 0;i < (int)(n);i++)\nusing ll = long long;\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\nconst long long INF = 1LL << 60;\nconst double pi=acos(-1.0);\nint dx[9] = {1, 0, -1, 0, 1, 1, -1, -1, 0};\nint dy[9] = {0, 1, 0, -1, 1, -1, -1, 1, 0};\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\n\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  // cout << fixed << setprecision(15);\n  \n  ll N,D; cin>>N>>D;\n  vector<ll> x(N),y(N); rep(i,N) cin>>x[i]>>y[i];\n  \n  two_sat ts(N);\n  rep(i,N){\n    for(int j=i+1;j<N;j++){\n      if(abs(x[i]-x[j])<D) ts.add_clause(i,0,j,0);\n      if(abs(y[i]-y[j])<D) ts.add_clause(i,1,j,1);\n      if(abs(x[i]-y[j])<D) ts.add_clause(i,0,j,1);\n      if(abs(y[i]-x[j])<D) ts.add_clause(i,1,j,0);\n    }\n  }\n  \n  if(!ts.satisfiable()) {cout<<\"No\"<<'\\n'; return 0;}\n  else cout<<\"Yes\"<<'\\n';\n  \n  auto ans_vec=ts.answer();\n  \n  rep(i,N) cout<<(ans_vec[i]?x[i]:y[i])<<'\\n';\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nstruct TwoSatLight {\n  TwoSatLight(int n) : n(n), graph(n << 1), rev_graph(n << 1), used(n << 1, false), id(n << 1, -1) {}\n\n  int negate(int x) const { return (n + x) % (n << 1); }\n\n  void add_or(int x, int y) {\n    graph[negate(x)].emplace_back(y);\n    graph[negate(y)].emplace_back(x);\n    rev_graph[y].emplace_back(negate(x));\n    rev_graph[x].emplace_back(negate(y));\n  }\n\n  void add_if(int x, int y) { add_or(negate(x), y); }\n\n  void add_nand(int x, int y) { add_or(negate(x), negate(y)); }\n\n  void set_true(int x) { add_or(x, x); }\n\n  void set_false(int x) { set_true(negate(x)); }\n\n  vector<bool> build() {\n    REP(i, n << 1) {\n      if (!used[i]) dfs(i);\n    }\n    int now = 0;\n    for (int i = (n << 1) - 1; i >= 0; --i) {\n      if (id[order[i]] == -1) rev_dfs(order[i], now++);\n    }\n    vector<bool> res(n);\n    REP(i, n) {\n      if (id[i] == id[negate(i)]) return {};\n      res[i] = id[negate(i)] < id[i];\n    }\n    return res;\n  }\n\nprivate:\n  int n;\n  vector<vector<int>> graph, rev_graph;\n  vector<bool> used;\n  vector<int> id, order;\n\n  void dfs(int ver) {\n    used[ver] = true;\n    for (int e : graph[ver]) {\n      if (!used[e]) dfs(e);\n    }\n    order.emplace_back(ver);\n  }\n\n  void rev_dfs(int ver, int now) {\n    id[ver] = now;\n    for (int e : rev_graph[ver]) {\n      if (id[e] == -1) rev_dfs(e, now);\n    }\n  }\n};\n\nint main() {\n  int n, d; cin >> n >> d;\n  vector<int> x(n), y(n); REP(i, n) cin >> x[i] >> y[i];\n  TwoSatLight ts(n);\n  REP(i, n) FOR(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_nand(i, j);\n    if (abs(x[i] - y[j]) < d) ts.add_nand(i, ts.negate(j));\n    if (abs(y[i] - x[j]) < d) ts.add_nand(ts.negate(i), j);\n    if (abs(y[i] - y[j]) < d) ts.add_nand(ts.negate(i), ts.negate(j));\n  }\n  vector<bool> ans = ts.build();\n  if (ans.empty()) {\n    cout << \"No\\n\";\n    return 0;\n  }\n  cout << \"Yes\\n\";\n  REP(i, n) cout << (ans[i] ? x[i] : y[i]) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n#define F first\n#define S second\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 60;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nstruct Graph{\n  int n;\n  vector<vector<int>> edge;\n  vector<vector<int>> rev;\n  vector<bool> used;\n  vector<int> tn;\n  vector<int> id;\n  int cnt = 0;\n  vector<vector<int>> scc_edge;\n  Graph(){}\n  Graph(int n): n(n){\n    edge.resize(n);\n    rev.resize(n);\n    used.resize(n, false);\n    id.resize(n);\n  }\n  void adde(int from, int to){\n    edge[from].emplace_back(to);\n    rev[to].emplace_back(from);\n  }\n  void dfs(int i){\n    used[i] = true;\n    for(auto e: edge[i]){\n      if(!used[e])dfs(e);\n    }\n    tn.emplace_back(i);\n  }\n  void rev_dfs(int i, int cnt){\n    used[i] = true;\n    id[i] = cnt;\n    for(auto e: rev[i]){\n      if(!used[e]){\n        rev_dfs(e, cnt);\n      }\n    }\n  }\n  int kosaraju(){\n    tn.clear();\n    fill(used.begin(), used.end(), false);\n\n    for(int i = 0; i < n; i++){\n      if(!used[i])dfs(i);\n    }\n\n    fill(used.begin(), used.end(), false);\n\n    cnt = 0;\n    for(int i = n - 1; i >= 0; i--){\n      int v = tn[i];\n      if(!used[v]){\n        rev_dfs(v, cnt);\n        cnt++;\n      }\n    }\n    return cnt;\n  }\n  void compose(){\n    scc_edge.resize(cnt);\n    vector<set<int>> st(cnt);\n    for(int i = 0; i < n; i++){\n      for(auto e: edge[i]){\n        if(id[e] != id[i] && st[id[i]].find(id[e]) == st[id[i]].end()){\n          scc_edge[id[i]].emplace_back(id[e]);\n          st[id[i]].insert(id[e]);\n        }\n      }\n    }\n  }\n};\n\nstruct TwoSAT{\n  Graph graph;\n  int n;\n  TwoSAT(){}\n  TwoSAT(int n): n(n){\n    graph = Graph(2 * n);\n  }\n  int no_t(int i){\n    if(i < n)return i + n;\n    else return i - n;\n  }\n  void add_relation(int i, int j){\n    graph.adde(no_t(i), j);\n    graph.adde(no_t(j), i);\n  }\n  bool two_satisfiability(){\n    graph.kosaraju();\n    for(int i = 0; i < n; i++){\n      if(graph.id[i] == graph.id[no_t(i)])return false;\n    }\n    return true;\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  ll d; cin >> d;\n  vector<ll> x(n), y(n);\n  rep(i, n)cin >> x[i] >> y[i];\n  TwoSAT ts(n);\n  rep(i, n){\n    FOR(j, i + 1, n){\n      if(abs(x[i] - x[j]) < d)ts.add_relation(ts.no_t(i), ts.no_t(j));\n      if(abs(x[i] - y[j]) < d)ts.add_relation(ts.no_t(i), j);\n      if(abs(y[i] - x[j]) < d)ts.add_relation(i, ts.no_t(j));\n      if(abs(y[i] - y[j]) < d)ts.add_relation(i, j);\n    }\n  }\n  bool b = ts.two_satisfiability();\n  if(!b){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  rep(i, n){\n    if(ts.graph.id[i] > ts.graph.id[i+n])cout << x[i] << endl;\n    else cout << y[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nenum : int { M = (int)1e9 + 7 };\nenum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(printde) FUNC(printdbe) FUNC(printdwe) FUNC(printdu) FUNC(printe) FUNC(printe0);\n#endif\ntemplate <template <class T, class = std::allocator<T>> class V, class E>\nistream& operator >> (istream& in, V<E>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\n// #define NDEBUG\n#include \"atcoder/all\"\nusing namespace atcoder;\n\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, d;\n    cin >> n >> d;\n    two_sat ts(n);\n    vector<int> xs(n), ys(n);\n    for(int i = 0; i < n; i++){\n        cin >> xs[i] >> ys[i];\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == j){ continue; }\n            if(abs(xs[i] - xs[j]) < d){\n                // if(abs(xs[i] - ys[j]) < d){\n                // }\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(xs[i] - ys[j]) < d){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(ys[i] - xs[j]) < d){\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(ys[i] - ys[j]) < d){\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    // for(int i = 0; i < n; i++){\n    //     ts.add_clause(i, false, n + i, true);\n    //     // ts.add_clause(n + i, false, i, true);\n    // }\n    // for(int i = 0; i < n; i++){\n    //     int x = xs[i];\n    //     for(int j = 0; j < n; j++){\n    //         int y = ys[j];\n    //         if(i != j && abs(x - y) < d){\n    //             ts.add_clause(i, true, n + j, false);\n    //             ts.add_clause(n + j, true, i, false);\n    //         }\n    //     }\n    // }\n    bool satisfiable = ts.satisfiable();\n    cout << (satisfiable ? \"Yes\" : \"No\") << '\\n';\n    if(!satisfiable){\n        return 0;\n    }\n    auto ans = ts.answer();\n    printde(ans);\n    for(int i = 0; i < n; i++){\n        cout << (ans[i] ? xs[i] : ys[i]) << ' ';\n    }\n    cout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include<cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<iomanip>\n#include<complex>\n#include<assert.h>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\n//typedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, double> pid;\ntypedef pair<double, int> pdi;\ntypedef pair<double, double> pdd;\ntypedef vector< vector<int> > mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\n\nconst double EPS = 1e-9;\n\nstruct SCC {\n\tint V;\n\tvector<vector<int>> SC;\t\t//強連結成分リスト(トポロジカルソート)\n\tvector<int> SCID;\t\t\t//各頂点が属する連結成分ID\n\n\tvector<vector<int>> G, RG;\n\tvector<int> NUM;\n\tvector<bool> used;\n\n\tSCC(int V) :V(V)\n\t{\n\t\tSC.resize(V);\n\t\tSCID = vector<int>(V, -1);\n\t\tG = vector<vector<int>>(V);\n\t\tRG = vector<vector<int>>(V);\n\t\tused = vector<bool>(V, false);\n\t}\n\n\tvoid add_edge(int x, int y)\n\t{\n\t\tG[x].push_back(y);\n\t\tRG[y].push_back(x);\n\t}\n\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tfor (auto e : G[v])\n\t\t{\n\t\t\tif (!used[e])dfs(e);\n\t\t}\n\t\tNUM.push_back(v);\n\t}\n\n\tvoid revdfs(int v, int idx)\n\t{\n\t\tint i; \n\t\tused[v] = true;\n\t\tSCID[v] = idx;\n\t\tSC[idx].push_back(v); \n\t\tfor (auto e : RG[v])\n\t\t{\n\t\t\tif (!used[e])revdfs(e, idx);\n\t\t}\n\t}\n\n\tvoid scc()\n\t{\n\t\tint c = 0; \n\t\tfill(all(used), false);\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!used[i]) dfs(i);\n\t\t}\n\t\tfill(all(used), false);\n\t\tfor (int i = NUM.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (!used[NUM[i]]) \n\t\t\t{\n\t\t\t\trevdfs(NUM[i], c); \n\t\t\t\tsort(all(SC[c]));\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tSC.resize(c);\n\t}\n};\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, D;\n\tcin >> N >> D;\n\tSCC scc(2 * N);\n\n\tvector<pii> P(N);\n\trep(i, 0, N)cin >> P[i].first >> P[i].second;\n\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tif (i == j)continue;\n\n\t\t\tif (abs(P[i].first - P[j].first) < D)\n\t\t\t{\n\t\t\t\tscc.add_edge(2 * i, 2 * j + 1);\n\t\t\t\tscc.add_edge(2 * j, 2 * i + 1);\n\t\t\t}\n\t\t\tif (abs(P[i].first - P[j].second) < D)\n\t\t\t{\n\t\t\t\tscc.add_edge(2 * i, 2 * j);\n\t\t\t\tscc.add_edge(2 * j + 1, 2 * i + 1);\n\t\t\t}\n\t\t\tif (abs(P[i].second - P[j].first) < D)\n\t\t\t{\n\t\t\t\tscc.add_edge(2 * i + 1, 2 * j + 1);\n\t\t\t\tscc.add_edge(2 * j, 2 * i);\n\t\t\t}\n\t\t\tif (abs(P[i].second - P[j].second) < D)\n\t\t\t{\n\t\t\t\tscc.add_edge(2 * i + 1, 2 * j);\n\t\t\t\tscc.add_edge(2 * j + 1, 2 * i);\n\t\t\t}\n\t\t}\n\t}\n\n\tscc.scc();\n\n\tbool ok = true;\n\trep(i, 0, N)\n\t{\n\t\tif (scc.SCID[2 * i] == scc.SCID[2 * i + 1])\n\t\t{\n\t\t\tok = false;\n\t\t}\n\t}\n\n\tif (!ok)\n\t{\n\t\tcout << \"No\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Yes\" << endl;\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tif (scc.SCID[2 * i] < scc.SCID[2 * i + 1])\n\t\t\t{\n\t\t\t\tcout << P[i].second << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << P[i].first << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define rep2(i, a, b) for(int i = a; i <= b; ++i)\n#define ll long long\n#define eb emplace_back\n#define all(c) (c).begin(), (c).end()\n#define vi vector<int>\n\nint main() {\n\tint n, d;\n\tint x[1000];\n\tint y[1000];\n\tvector<bool>ans;\n\tcin >> n >> d;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\ttwo_sat a(n);\n\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\tif (abs(x[i] - x[j]) < d)a.add_clause(i, 1, j, 1);\n\t\t\tif (abs(x[i] - y[j]) < d)a.add_clause(i, 1, j, 0);\n\t\t\tif (abs(y[i] - x[j]) < d)a.add_clause(i, 0, j, 1);\n\t\t\tif (abs(y[i] - y[j]) < d)a.add_clause(i, 0, j, 0);\n\t\t}\n\t}\n\n\tif (a.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tans = a.answer();\n\t\trep(i, n) {\n\t\t\tif (ans[i])cout << y[i] << endl;\n\t\t\telse cout << x[i] << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define repit(it, li) for(auto it=li.begin(); it!=li.end(); it++)\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint main(){\n\tint n, d;\n\tcin>>n>>d;\n\tvector<vector<int>> x(n);\n\trep(i, n) x[i]=vector<int>(2);\n\trep(i, n) cin>>x[i][0]>>x[i][1];\n\n\ttwo_sat ts(n);\n\tfor(int i=0; i<n-1; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\trep(a, 2) rep(b, 2){\n\t\t\t\tif(abs(x[i][a]-x[j][b])<d) ts.add_clause(i, 1-a, j, 1-b);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=ts.satisfiable();\n\tif(ok){\n\t\tcout<<\"Yes\"<<endl;\n\t\tauto vb=ts.answer();\n\t\trep(i, n) cout<< x[i][vb[i]] <<endl;\n\t}\n\telse cout<<\"No\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS \n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\n/*\nHere starts the AtCoder STL.\n*/\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n    namespace internal {\n\n\n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n                });\n            return sa;\n        }\n\n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n\n        // SA-IS, linear-time suffix array construction\n        // Reference:\n        // G. Nong, S. Zhang, and W. H. Chan,\n        // Two Efficient Algorithms for Linear Time Suffix Array Construction\n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return { 0 };\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return { 0, 1 };\n                }\n                else {\n                    return { 1, 0 };\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n\n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                }\n                else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n\n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n\n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n\n            induce(lms);\n\n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    }\n                    else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n\n                auto rec_sa =\n                    sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n\n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n\n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n        // @param n `0 <= n`\n        // @return minimum non-negative `x` s.t. `n <= 2**x`\n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n\n        // @param n `1 <= n`\n        // @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n\n\n        // @param m `1 <= m`\n        // @return x mod m\n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n\n        // Fast moduler by barrett reduction\n        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n        // NOTE: reconsider after Ice Lake\n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n\n            // @param m `1 <= m`\n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n            // @return m\n            unsigned int umod() const { return _m; }\n\n            // @param a `0 <= a < m`\n            // @param b `0 <= b < m`\n            // @return `a * b % m`\n            unsigned int mul(unsigned int a, unsigned int b) const {\n                // [1] m = 1\n                // a = b = im = 0, so okay\n\n                // [2] m >= 2\n                // im = ceil(2^64 / m)\n                // -> im * m = 2^64 + r (0 <= r < m)\n                // let z = a*b = c*m + d (0 <= c, d < m)\n                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n                // ((ab * im) >> 64) == c or c + 1\n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n\n        // @param n `0 <= n`\n        // @param m `1 <= m`\n        // @return `(x ** n) % m`\n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n\n        // Reference:\n        // M. Forisek and J. Jancina,\n        // Fast Primality Testing for Integers That Fit into a Machine Word\n        // @param n `0 <= n`\n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            {\n                long long a = 2;\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            {\n                long long a = 7;\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            {\n                long long a = 61;\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n        // @param b `1 <= b`\n        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return { b, 0 };\n\n            // Contracts:\n            // [1] s - m0 * a = 0 (mod b)\n            // [2] t - m1 * a = 0 (mod b)\n            // [3] s * |m1| + t * |m0| <= b\n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n\n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n                // [3]:\n                // (s - t * u) * |m1| + t * |m0 - m1 * u|\n                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n                // = s * |m1| + t * |m0| <= b\n\n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            // by [3]: |m0| <= b/g\n            // by g != b: |m0| < b/g\n            if (m0 < 0) m0 += b / s;\n            return { s, m0 };\n        }\n\n        // Compile time primitive root\n        // @param m must be prime\n        // @return primitive root (and minimum in now)\n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n\n\n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n                : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n\n        // Reference:\n        // R. Tarjan,\n        // Depth-First Search and Linear Graph Algorithms\n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n\n            int num_vertices() { return _n; }\n\n            void add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n\n            // @return pair of (# of scc, scc id)\n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        }\n                        else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return { group_num, ids };\n            }\n\n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n\n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n\n\n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value ||\n            std::is_same<T, __int128>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using is_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __uint128_t>::value ||\n            std::is_same<T, unsigned __int128>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using make_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value,\n            __uint128_t,\n            unsigned __int128>;\n\n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n            is_signed_int128<T>::value ||\n            is_unsigned_int128<T>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value&&\n            std::is_signed<T>::value) ||\n            is_signed_int128<T>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<(is_integral<T>::value&&\n                std::is_unsigned<T>::value) ||\n            is_unsigned_int128<T>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using to_unsigned = typename std::conditional<\n            is_signed_int128<T>::value,\n            make_unsigned_int128<T>,\n            typename std::conditional<std::is_signed<T>::value,\n            std::make_unsigned<T>,\n            std::common_type<T>>::type>::type;\n\n#else\n\n        template <class T> using is_integral = typename std::is_integral<T>;\n\n        template <class T>\n        using is_signed_int =\n            typename std::conditional<is_integral<T>::value&& std::is_signed<T>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<is_integral<T>::value&&\n            std::is_unsigned<T>::value,\n            std::true_type,\n            std::false_type>::type;\n\n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n            std::make_unsigned<T>,\n            std::common_type<T>>::type;\n\n#endif\n\n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n\n    } \n\n\n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n\n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n\n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n        unsigned int val() const { return _v; }\n\n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++* this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --* this;\n            return result;\n        }\n\n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n\n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            }\n            else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n\n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n\n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n\n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n\n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n        unsigned int val() const { return _v; }\n\n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++* this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --* this;\n            return result;\n        }\n\n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n\n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n\n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    namespace internal {\n\n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n    };\n\n\n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n\n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n\n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n\n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n\n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                std::remove_if(result.begin(), result.end(),\n                    [&](const std::vector<int>& v) { return v.empty(); }),\n                result.end());\n            return result;\n        }\n\n    private:\n        int _n;\n        // root node: -1 * component size\n        // otherwise: parent\n        std::vector<int> parent_or_size;\n    };\n\n\n    // Reference: https://en.wikipedia.org/wiki/Fenwick_tree\n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n\n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n\n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n\n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n\n    private:\n        int _n;\n        std::vector<U> data;\n\n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n\n\n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n\n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n\n    // (rem, mod)\n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        // Contracts: 0 <= r0 < m0\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return { 0, 0 };\n                continue;\n            }\n            // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n            // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n            // r2 % m0 = r0\n            // r2 % m1 = r1\n            // -> (r0 + x*m0) % m1 = r1\n            // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n            // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n            // im = inv(u0) (mod u1) (0 <= im < u1)\n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n            long long u1 = (m1 / g);\n            // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n            if ((r1 - r0) % g) return { 0, 0 };\n\n            // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n            long long x = (r1 - r0) / g % u1 * im % u1;\n\n            // |r0| + |m0 * x|\n            // < m0 + m0 * (u1 - 1)\n            // = m0 + m0 * m1 / g - m0\n            // = lcm(m0, m1)\n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return { r0, m0 };\n    }\n\n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n\n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n\n\n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n\n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({ from, int(g[from].size()) });\n            g[from].push_back(_edge{ to, int(g[to].size()), cap });\n            g[to].push_back(_edge{ from, int(g[from].size()) - 1, 0 });\n            return m;\n        }\n\n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n\n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{ pos[i].first, _e.to, _e.cap + _re.cap, _re.cap };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n\n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n\n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n\n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                        self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n\n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n\n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n\n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n\n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n\n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n\n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n    private:\n        internal::scc_graph internal;\n    };\n\n\n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n\n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({ from, int(g[from].size()) });\n            g[from].push_back(_edge{ to, int(g[to].size()), cap, cost });\n            g[to].push_back(_edge{ from, int(g[from].size()) - 1, 0, -cost });\n            return m;\n        }\n\n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n\n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n\n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            // variants (C = maxcost):\n            // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n            // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                    std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{ 0, s });\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                    // dist[v] >= 0 (all reduced cost are positive)\n                    // dist[v] <= (n-1)C\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        // |-dual[e.to] + dual[v]| <= (n-1)C\n                        // cost <= C - -(n-1)C + 0 = nC\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{ dist[e.to], e.to });\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n\n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    // dual[v] = dual[v] - dist[t] + dist[v]\n                    //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                    //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                    //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({ flow, cost });\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({ flow, cost });\n                prev_cost = cost;\n            }\n            return result;\n        }\n\n    private:\n        int _n;\n\n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n\n\n    template <class S,\n        S(*op)(S, S),\n        S(*e)(),\n        class F,\n        S(*mapping)(F, S),\n        F(*composition)(F, F),\n        F(*id)()>\n        struct lazy_segtree {\n        public:\n            lazy_segtree() : lazy_segtree(0) {}\n            lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n            lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n                log = internal::ceil_pow2(_n);\n                size = 1 << log;\n                d = std::vector<S>(2 * size, e());\n                lz = std::vector<F>(size, id());\n                for (int i = 0; i < _n; i++) d[size + i] = v[i];\n                for (int i = size - 1; i >= 1; i--) {\n                    update(i);\n                }\n            }\n\n            void set(int p, S x) {\n                assert(0 <= p && p < _n);\n                p += size;\n                for (int i = log; i >= 1; i--) push(p >> i);\n                d[p] = x;\n                for (int i = 1; i <= log; i++) update(p >> i);\n            }\n\n            S get(int p) {\n                assert(0 <= p && p < _n);\n                p += size;\n                for (int i = log; i >= 1; i--) push(p >> i);\n                return d[p];\n            }\n\n            S prod(int l, int r) {\n                assert(0 <= l && l <= r && r <= _n);\n                if (l == r) return e();\n\n                l += size;\n                r += size;\n\n                for (int i = log; i >= 1; i--) {\n                    if (((l >> i) << i) != l) push(l >> i);\n                    if (((r >> i) << i) != r) push(r >> i);\n                }\n\n                S sml = e(), smr = e();\n                while (l < r) {\n                    if (l & 1) sml = op(sml, d[l++]);\n                    if (r & 1) smr = op(d[--r], smr);\n                    l >>= 1;\n                    r >>= 1;\n                }\n\n                return op(sml, smr);\n            }\n\n            S all_prod() { return d[1]; }\n\n            void apply(int p, F f) {\n                assert(0 <= p && p < _n);\n                p += size;\n                for (int i = log; i >= 1; i--) push(p >> i);\n                d[p] = mapping(f, d[p]);\n                for (int i = 1; i <= log; i++) update(p >> i);\n            }\n            void apply(int l, int r, F f) {\n                assert(0 <= l && l <= r && r <= _n);\n                if (l == r) return;\n\n                l += size;\n                r += size;\n\n                for (int i = log; i >= 1; i--) {\n                    if (((l >> i) << i) != l) push(l >> i);\n                    if (((r >> i) << i) != r) push((r - 1) >> i);\n                }\n\n                {\n                    int l2 = l, r2 = r;\n                    while (l < r) {\n                        if (l & 1) all_apply(l++, f);\n                        if (r & 1) all_apply(--r, f);\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    l = l2;\n                    r = r2;\n                }\n\n                for (int i = 1; i <= log; i++) {\n                    if (((l >> i) << i) != l) update(l >> i);\n                    if (((r >> i) << i) != r) update((r - 1) >> i);\n                }\n            }\n\n            template <bool (*g)(S)> int max_right(int l) {\n                return max_right(l, [](S x) { return g(x); });\n            }\n            template <class G> int max_right(int l, G g) {\n                assert(0 <= l && l <= _n);\n                assert(g(e()));\n                if (l == _n) return _n;\n                l += size;\n                for (int i = log; i >= 1; i--) push(l >> i);\n                S sm = e();\n                do {\n                    while (l % 2 == 0) l >>= 1;\n                    if (!g(op(sm, d[l]))) {\n                        while (l < size) {\n                            push(l);\n                            l = (2 * l);\n                            if (g(op(sm, d[l]))) {\n                                sm = op(sm, d[l]);\n                                l++;\n                            }\n                        }\n                        return l - size;\n                    }\n                    sm = op(sm, d[l]);\n                    l++;\n                } while ((l & -l) != l);\n                return _n;\n            }\n\n            template <bool (*g)(S)> int min_left(int r) {\n                return min_left(r, [](S x) { return g(x); });\n            }\n            template <class G> int min_left(int r, G g) {\n                assert(0 <= r && r <= _n);\n                assert(g(e()));\n                if (r == 0) return 0;\n                r += size;\n                for (int i = log; i >= 1; i--) push((r - 1) >> i);\n                S sm = e();\n                do {\n                    r--;\n                    while (r > 1 && (r % 2)) r >>= 1;\n                    if (!g(op(d[r], sm))) {\n                        while (r < size) {\n                            push(r);\n                            r = (2 * r + 1);\n                            if (g(op(d[r], sm))) {\n                                sm = op(d[r], sm);\n                                r--;\n                            }\n                        }\n                        return r + 1 - size;\n                    }\n                    sm = op(d[r], sm);\n                } while ((r & -r) != r);\n                return 0;\n            }\n\n        private:\n            int _n, size, log;\n            std::vector<S> d;\n            std::vector<F> lz;\n\n            void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n            void all_apply(int k, F f) {\n                d[k] = mapping(f, d[k]);\n                if (k < size) lz[k] = composition(f, lz[k]);\n            }\n            void push(int k) {\n                all_apply(2 * k, lz[k]);\n                all_apply(2 * k + 1, lz[k]);\n                lz[k] = id();\n            }\n    };\n\n\n    template <class S, S(*op)(S, S), S(*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n\n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n\n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n\n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n\n        S all_prod() { return d[1]; }\n\n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n\n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n\n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n\n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n\n\n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n\n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n\n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n\n    // Reference:\n    // T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    // Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    // Applications\n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n        const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n\n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n\n    // Reference:\n    // D. Gusfield,\n    // Algorithms on Strings, Trees, and Sequences: Computer Science and\n    // Computational Biology\n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n\n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n\n\n\n    namespace internal {\n\n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n\n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n\n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n\n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n\n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                            (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                            inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n    };\n\n\n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n\n    template <unsigned int mod = 998244353,\n        class T,\n        std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n        std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n\n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n\n\n\n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n        const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n\n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n        static constexpr unsigned long long i1 =\n            internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n            internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n            internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        \n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            // B = 2^63, -B <= x, r(real value) < B\n            // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n            // r = c1[i] (mod MOD1)\n            // focus on MOD1\n            // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n            // r = x,\n            //     x - M' + (0 or 2B),\n            //     x - 2M' + (0, 2B or 4B),\n            //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n            // (r - x) = 0, (0)\n            //           - M' + (0 or 2B), (1)\n            //           -2M' + (0 or 2B or 4B), (2)\n            //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n            // we checked that\n            //   ((1) mod MOD1) mod 5 = 2\n            //   ((2) mod MOD1) mod 5 = 3\n            //   ((3) mod MOD1) mod 5 = 4\n            long long diff =\n                c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 };\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n\n\n}\n\n#endif\n\n\n#define int ll\n\nusing namespace std;\nusing namespace atcoder;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n};\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = ((this->data[i][0]) * (obj.data[0][q]));\n                for (int t = 1; t < obj.data.size(); ++t) {\n                    hoge += ((this->data[i][t]) * obj.data[t][q]);\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        if (hoge != 0) {\n            c /= hoge;\n            d /= hoge;\n            if (d < 0 or (d == 0 and c < 0)) {\n                d *= -1;\n                c *= -1;\n            }\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        if (a < 0 and rhs.a > 0) return 1;\n        if (a > 0 and rhs.a < 0) return 0;\n        return a * rhs.b < rhs.a* b;\n    }\n    bool operator ==(Fraction rhs) const {\n        return a == rhs.a and b == rhs.b;\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve() {\n    int n, d;\n    cin >> n >> d;\n    vector<pair<int, int>> inputs;\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        inputs.push_back(mp(a, b));\n    }\n    two_sat go(n);\n    REP(i, n) {\n        for (int q = i + 1; q < n; ++q) {\n            if (abs(inputs[i].first - inputs[q].first) < d) {\n                go.add_clause(i, 1, q, 1);\n            }\n            if (abs(inputs[i].second - inputs[q].first) < d) {\n                go.add_clause(i, 0, q, 1);\n            }\n            if (abs(inputs[i].first - inputs[q].second) < d) {\n                go.add_clause(i, 1, q, 0);\n            }\n            if (abs(inputs[i].second - inputs[q].second) < d) {\n                go.add_clause(i, 0, q, 0);\n            }\n        }\n    }\n    if (go.satisfiable()) {\n        cout << \"Yes\" << endl;\n        int itr = 0;\n        for (auto x : go.answer()) {\n            if (x == false) {\n                cout << inputs[itr].first << endl;\n            }\n            else {\n                cout << inputs[itr].second << endl;\n            }\n            itr++;\n        }\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    int t = 1;\n    REP(tea, t)\n        solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#include <atcoder/all>\n#define popcount __builtin_popcount\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct SCC{\n    vector<vector<int>> g, gr;\n    int n, k;\n    vector<int> cmp, vs;\n    vector<bool> used;\n    void dfs(int x){\n        used[x]=1;\n        for(auto y:g[x]){\n            if(!used[y]) dfs(y);\n        }\n        vs.push_back(x);\n    }\n    void rdfs(int v, int k){\n        used[v]=1;\n        cmp[v]=k;\n        for(auto y:gr[v]){\n            if(!used[y]) rdfs(y, k);\n        }\n    }\n    SCC(const vector<vector<int>> &g):g(g), n(g.size()), cmp(n), used(n){\n        gr.resize(n);\n        for(int x=0; x<n; x++) for(auto y:g[x]) gr[y].push_back(x);\n        for(int i=0; i<n; i++){\n            if(!used[i]) dfs(i);\n        }\n        fill(used.begin(), used.end(), 0);\n        k=0;\n        for(int i=vs.size()-1; i>=0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n    }\n};\nint main()\n{\n    int n, d;\n\tscanf(\"%d %d\", &n, &d);\n\tint x[2][1010];\n\tfor(int i=0; i<n; i++) scanf(\"%d %d\", &x[0][i], &x[1][i]);\n\tvector<vector<int>> g(2*n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<i; j++){\n\t\t\tfor(int k=0; k<2; k++) for(int l=0; l<2; l++){\n\t\t\t\tif(abs(x[k][i]-x[l][j])<d){\n\t\t\t\t\tg[i+k*n].push_back(j+(l^1)*n);\n\t\t\t\t\tg[j+l*n].push_back(i+(k^1)*n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSCC scc(g);\n\tfor(int i=0; i<n; i++){\n\t\tif(scc.cmp[i]==scc.cmp[i+n]){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\tfor(int i=0; i<n; i++){\n\t\tif(scc.cmp[i]<scc.cmp[i+n]){\n\t\t\tprintf(\"%d\\n\", x[1][i]);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", x[0][i]);\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing namespace std;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector a(n, vector(2, 0));\n\trep(i, n) rep(j, 2) cin >> a[i][j];\n\n\tatcoder::two_sat t(n);\n\trep(i, n) for (int j = i + 1; j < n; ++j) rep(k, 4) {\n\t\tif (abs(a[i][k >> 1] - a[j][k & 1]) < d) t.add_clause(i, k >> 1, j, k & 1);\n\t}\n\tif (t.satisfiable()) {\n\t\tputs(\"Yes\");\n\t\tauto ans = t.answer();\n\t\trep(i, n) cout << a[i][!ans[i]] << endl;\n\t} else {\n\t\tputs(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#line 2 \"cpplib/util/template.hpp\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT__{__INIT__(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}}__INIT__;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define endl ('\\n')\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,...) for(auto i:range(__VA_ARGS__)) \n#define rrep(i,...) for(auto i:reversed(range(__VA_ARGS__)))\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\ninline vector<long long> range(long long n){if(n<=0)return vector<long long>();vector<long long>v(n);iota(v.begin(),v.end(),0LL);return v;}\ninline vector<long long> range(long long a,long long b){if(b<=a)return vector<long long>();vector<long long>v(b-a);iota(v.begin(),v.end(),a);return v;}\ninline vector<long long> range(long long a,long long b,long long c){if((b-a+c-1)/c<=0)return vector<long long>();vector<long long>v((b-a+c-1)/c);for(int i=0;i<(int)v.size();++i)v[i]=i?v[i-1]+c:a;return v;}\ntemplate<typename T>inline T reversed(T v){reverse(v.begin(),v.end());return v;}\n#define all(n) begin(n),end(n)\ntemplate<typename T,typename E>bool chmin(T& s,const E& t){bool res=s>t;s=min<T>(s,t);return res;}\ntemplate<typename T,typename E>bool chmax(T& s,const E& t){bool res=s<t;s=max<T>(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\ntemplate<typename T,typename ...Args>auto make_vector(T x,int arg,Args ...args){if constexpr(sizeof...(args)==0)return vector<T>(arg,x);else return vector(arg,make_vector<T>(x,args...));}\n#line 5 \"cpplib/graph_tree/graph_template.hpp\"\n/**\n * @brief グラフテンプレート\n */\n\nusing graph=std::vector<std::vector<int>>;\ntemplate<typename T>\nusing graph_w=std::vector<std::vector<std::pair<int,T>>>;\n\ngraph load_graph(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_digraph(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n    }\n    return g;\n}\ngraph load_graph0(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_digraph0(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n    }\n    return g;\n}\ngraph load_tree(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_tree0(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_treep(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int t;\n        std::cin>>t;\n        g[i+1].push_back(t);\n        g[t].push_back(i+1);\n    }\n    return g;\n}\n\ntemplate<typename T>\ngraph_w<T> load_graph_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_digraph_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_graph0_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_digraph0_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_tree_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_tree0_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_treep_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int t;\n        T u;\n        std::cin>>t>>u;\n        g[i+1].emplace_back(t,u);\n        g[t].emplace_back(i+1,u);\n    }\n    return g;\n}\n#line 2 \"code.cpp\"\n\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\nusing namespace atcoder;\n\nint main(){\n    lint n,d;\n    cin>>n>>d;\n    auto g=two_sat(n);\n    vec x(n),y(n);\n    rep(i,n){\n        cin>>x[i]>>y[i];\n    }\n    rep(i,n)rep(j,i){\n        if(abs(x[i]-x[j])<d){\n            g.add_clause(i,0,j,0);\n        }\n        if(abs(x[i]-y[j])<d){\n            g.add_clause(i,0,j,1);\n        }\n        if(abs(y[i]-x[j])<d){\n            g.add_clause(i,1,j,0);\n        }\n        if(abs(y[i]-y[j])<d){\n            g.add_clause(i,1,j,1);\n        }\n    }\n    if(g.satisfiable()==0){\n        cout<<\"No\"<<endl;\n    }else{\n        cout<<\"Yes\"<<endl;\n        auto e=g.answer();\n        rep(i,n){\n            if(e[i])cout<<x[i]<<endl;\n            else cout<<y[i]<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define F first\n#define S second\nusing namespace std;\nusing namespace atcoder;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\nint main() {\n  int N; cin >> N;\n  ll D; cin >> D;\n  ll Point[N][2];\n  two_sat S(N);\n  for (int i = 0; i < N; i++) {\n    cin >> Point[i][0] >> Point[i][1];\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < N; k++) {\n        if (i != k) {\n          for (int l = 0; l < 2; l++) {\n            if (abs(Point[i][j] - Point[k][l]) < D) {\n              S.add_clause(i,1-j,k,1-l);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (S.satisfiable()) {\n    cout << \"Yes\" << endl;\n    vector<bool> ans = S.answer();\n    for (int i = 0; i < N; i++) {\n      cout << Point[i][ans[i]] << endl;\n    }\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\n\n#pragma region Macros\nusing ll = long long;\n#define int ll\nusing pii = pair<int, int>;\nusing tiii = tuple<int, int, int>;\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\n#define IOS\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(0);\\\n    cout.tie(0);\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define SORT(name) sort(name.begin(), name.end())\n#define RSORT(name)\\\n    SORT(name);\\\n    reverse(all(name));\n#define ZERO(p) memset(p, 0, sizeof(p))\n#define MINUS(p) memset(p, -1, sizeof(p))\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\ntemplate<typename T1,typename T2> inline void chmin(T1 &a, T2 b){ if(a > b) a = b; }\ntemplate<typename T1,typename T2> inline void chmax(T1 &a, T2 b){ if(a < b) a = b; }\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst double DINF = std::numeric_limits<double>::infinity();\n#pragma endregion\n\n#if 1\n#  define DBG(fmt, ...) printf(fmt, ##__VA_ARGS__)\n#else\n#  define DBG(fmt, ...)\n#endif\n\nconst int MOD = 1000000007;\nconst int MAX_N = 100010;\n\nsigned main() {\n    IOS;\n\n    int N, D;\n    cin >> N >> D;\n    V<> X(N), Y(N);\n    REP(i, N) {\n        cin >> X[i] >> Y[i];\n    }\n    two_sat ts(N);\n    // X を選択 := true\n    // Y を選択 := false\n    REP(i, N) {\n        for(int j = i + 1; j < N; ++j) {\n            //if(i == j) { continue; }\n            if(abs(X[i] - X[j]) < D) {\n                // この 2 つは共存できない(両方 X はダメ)\n                // -> どちらか 1 つは必ず Y を選ばなければならない\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if(ts.satisfiable()) {\n        Yes(true);\n        auto ans = ts.answer();\n        REP(i, N) {\n            if(ans[i]) {\n                print(X[i]);\n            }\n            else {\n                print(Y[i]);\n            }\n        }\n    }\n    else {\n        Yes(false);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (ll i=(ll)from; i<(ll)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nstruct StrongConnectedComponent {\n  ll size, size_scc;\n  vector<vector<ll>> adj, radj, adj_scc, vertex_set;\n  vector<ll> vertex, vertex_scc, topo;\n  StrongConnectedComponent(ll N) {\n    size = N; \n    adj.resize(N); radj.resize(N);\n    vertex.resize(N); rep(i,N) vertex[i] = i;\n  }\n  void add_edge(ll from, ll to) { \n    adj[from].push_back(to);\n    radj[to].push_back(from);\n  }\n  void dfs_std(ll n, ll &o, vector<ll> &order) {\n    if (order[n]!=-1) return;\n    order[n] = LLINF;\n    for (auto x: adj[n]) if (order[x]==-1) dfs_std(x,o,order);\n    order[n] = o; o--;\n  }\n  void dfs_rev(ll n, ll v, vector<ll> &vid) {\n    vid[n] = v;\n    for (auto x: radj[n]) if (vid[x]==-1) dfs_rev(x,v,vid);\n  }\n  void restruct(ll v, vector<ll> &vid) {\n    size_scc = v;\n    adj_scc.resize(v); vertex_scc.resize(v,0); vertex_set.resize(v);\n    rep(i,size) {\n      for (auto x: adj[i]) if (vid[i]!=vid[x]) adj_scc[vid[i]].push_back(vid[x]);\n      vertex_scc[vid[i]] += vertex[i];\n      vertex_set[vid[i]].push_back(i);\n    }\n  }\n  void topo_sort() {\n    vector<ll> rnum(size_scc,0);\n    rep(i,size_scc) for (auto x: adj_scc[i]) rnum[x]++;\n    queue<ll> top; rep(i,size_scc) if (rnum[i]==0) top.push(i);\n    while (top.size()) {\n      ll now = top.front(); top.pop();\n      topo.push_back(now);\n      for (auto x: adj_scc[now]) { \n        rnum[x]--; \n        if (rnum[x]==0) top.push(x); \n      }\n    }\n  }\n  void calc() {\n    vector<ll> order(size,-1), revorder(size), vid(size,-1);\n    ll o = size-1, v = 0;\n    rep(i,size) dfs_std(i,o,order);\n    rep(i,size) revorder[order[i]] = i;\n    rep(i,size) if (vid[revorder[i]]==-1) { dfs_rev(revorder[i],v,vid); v++; }\n    restruct(v,vid);\n    topo_sort();\n  }\n  void output() {\n    cout << size_scc << endl;\n    for (auto x: topo) {\n      cout << vertex_set[x].size() << \" \";\n      debug(all(vertex_set[x]));\n    }\n  }\n};\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nint main() {\n  ll N, D; cin >> N >> D;\n  ll X[N], Y[N]; rep(i,N) cin >> X[i] >> Y[i];\n\n  StrongConnectedComponent scc(N*2);\n  rep(i,N) rep(j,N) {\n    if (i==j) continue;\n    if (abs(X[i]-X[j])<D) scc.add_edge(i,j+N);\n    if (abs(X[i]-Y[j])<D) scc.add_edge(i,j);\n    if (abs(Y[i]-X[j])<D) scc.add_edge(i+N,j+N);\n    if (abs(Y[i]-Y[j])<D) scc.add_edge(i+N,j);\n  }\n  scc.calc();\n\n  vector<ll> order = scc.topo; reverse(all(order));\n  ll pos[2*N]; rep(i,order.size()) for (auto x: scc.vertex_set[order[i]]) pos[x] = i;\n  bool ok = true; rep(i,N) ok &= pos[i]!=pos[i+N];\n  if (ok) {\n    cout << \"Yes\" << endl;\n    rep(i,N) cout << (pos[i]<pos[i+N] ? X[i] : Y[i]) << endl;\n  }\n  else cout << \"No\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define REPLL(i, n) for (ll i = 0; i < (ll)(n); i++)\nusing namespace std;\nusing namespace atcoder;\ntemplate<class T>inline bool chmax(T &a, const T &b){if(a < b){a = b; return 1;}return 0;}\ntemplate<class T>inline bool chmin(T &a, const T &b){if(a > b){a = b; return 1;}return 0;}\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N, D; cin >> N >> D;\n  two_sat ts(N);\n  vector<int> X(N), Y(N);\n  REP(i, N){\n    cin >> X[i] >> Y[i];\n  }\n  REP(i, N-1){\n    for(int j = i+1; j < N; j++){\n      if(abs(X[i]-X[j]) < D) ts.add_clause(i, false, j, false);\n      if(abs(X[i]-Y[j]) < D) ts.add_clause(i, false, j, true);\n      if(abs(Y[i]-X[j]) < D) ts.add_clause(i, true, j, false);\n      if(abs(Y[i]-Y[j]) < D) ts.add_clause(i, true, j, true);\n    }\n  }\n  if(ts.satisfiable()){\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n    REP(i, N){\n      if(ans[i]){\n        cout << X[i] << endl;\n      }else{\n        cout << Y[i] << endl;\n      }\n    }\n  }else{\n    cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long int\n#define vec vector<ll>\n#define mat vector<vector<ll>>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst ll mod=1000000007;\nconst ll inf=LONG_LONG_MAX;\nll dx4[4]={1,0,-1,0};\nll dy4[4]={0,-1,0,1};\nll dx8[8]={1,0,-1,1,-1,1,0,-1};\nll dy8[8]={1,1,1,0,0,-1,-1,-1};\n\nint main(){\n\n  ll n,d;\n  cin >> n >> d;\n  \n  vec x(n),y(n);\n  for(ll i=0;i<n;i++)cin >> x[i] >> y[i];\n\n  two_sat ts(n);\n\n  for(ll i=0;i<n;i++){\n    for(ll j=i+1;j<n;j++){\n      if (abs(x[i] - x[j]) < d) {\n        // cannot use both of x[i] and x[j]\n        ts.add_clause(i, false, j, false);\n      }\n      if (abs(x[i] - y[j]) < d) {\n        ts.add_clause(i, false, j, true);\n      }\n      if (abs(y[i] - x[j]) < d) {\n        ts.add_clause(i, true, j, false);\n      }\n      if (abs(y[i] - y[j]) < d) {\n        ts.add_clause(i, true, j, true);      \n    }\n  }\n\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  cout << \"Yes\" << endl;\n  auto answer = ts.answer();\n  for (int i = 0; i < n; i++) {\n    if (answer[i])\n      cout << x[i] << endl;\n    else\n      cout << y[i] << endl;\n  }\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast modular multiplication by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m < 2^31`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    constexpr long long bases[3] = {2, 7, 61};\n    for (long long a : bases) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i <= cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i <= cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to, to_id, cap});\n        g[to].push_back(_edge{from, from_id, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to, to_id, cap, cost});\n        g[to].push_back(_edge{from, from_id, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost_per_flow = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost_per_flow == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost_per_flow = d;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define REP(i,m,n) for(ll i = (m); i < (n); i++)\n#define rep(i,n) REP((i), 0, (n))\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    ll d;\n    cin >> n >> d;\n    ll ary[n][2];\n    rep(i,n) rep(j, 2) cin >> ary[i][j];\n\n    two_sat ts(n);\n    rep(i, n) REP(j,i+1,n)\n    {\n      if (abs(ary[i][0] - ary[j][0]) < d)\n      {\n        ts.add_clause(i, false, j, false);\n      }\n      if (abs(ary[i][0] - ary[j][1]) < d)\n      {\n        ts.add_clause(i, false, j, true);\n      }\n      if (abs(ary[i][1] - ary[j][1]) < d)\n      {\n        ts.add_clause(i, true, j, true);\n      }\n      if (abs(ary[i][1] - ary[j][0]) < d)\n      {\n        ts.add_clause(i, true, j, false);\n      }\n    }\n    if (ts.satisfiable())\n    {\n      cout << \"Yes\" << endl;\n      auto ans = ts.answer();\n      rep(i,n)\n      {\n        if (ans[i])\n        {\n          cout << ary[i][0] << endl;\n        }\n        else\n        {\n          cout << ary[i][1] << endl;\n        }\n      }\n    }\n    else\n    {\n      cout << \"No\" << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct SCC      //StronglyConnectedComponents\n{\n    int n;\n    int k;\n    vector<vector<int>> g, rg;\n    vector<bool> used;\n    vector<int> cmp;\n    vector<int> vs;\n    \n    void add_edge(int from, int to){\n        g[from].push_back(to);\n        rg[to].push_back(from);\n    }\n    \n    SCC(){}\n    \n    SCC(int n) : n(n){\n        g.resize(n);\n        rg.resize(n);\n        used.resize(n);\n        cmp.resize(n);\n        vs.resize(n);\n    }\n    \n    void dfs(int u, int &l){\n        used[u] = true;\n        for(int v : g[u]){\n            if(!used[v]) dfs(v, l);\n        }\n        vs[l] = u;\n        l++;\n    }\n    \n    void rdfs(int u, int k){\n        used[u] = true;\n        cmp[u] = k;\n        for(int v : rg[u]){\n            if(!used[v]) rdfs(v, k);\n        }\n    }\n    \n    int decomposition(){\n        int l = 0;\n        for(int i = 0; i < n; i++){\n            if(!used[i]) dfs(i, l);\n        }\n        fill(used.begin(), used.end(), false);\n        k = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(!used[vs[i]]){\n                rdfs(vs[i], k);\n                k++;\n            }\n        }\n        return k;\n    }\n};\n\nstruct TwoSAT\n{\n    int n;\n    SCC g;\n    vector<bool> f;\n    \n    TwoSAT(int n) : n(n){\n        g.n = n * 2;\n        g.g.resize(n * 2);\n        g.rg.resize(n * 2);\n        g.used.resize(n * 2);\n        g.cmp.resize(n * 2);\n        g.vs.resize(n * 2);\n        f.resize(n);\n    }\n    \n    void add_edge(int a, bool fa, int b, bool fb){\n        g.add_edge(a + int(!fa) * n, b + int(fb) * n);\n        g.add_edge(b + int(!fb) * n, a + int(fa) * n);\n    }\n    \n    bool judge(){\n        g.decomposition();\n        for(int i = 0; i < n; i++){\n            if(g.cmp[i] == g.cmp[i + n]) return false;\n            if(g.cmp[i] > g.cmp[i + n]) f[i] = false;\n            else f[i] = true;\n        }\n        return true;\n    }\n};\n\nint main()\n{\n    int n, d;\n    cin >> n >> d;\n    int x[1005], y[1005];   // x : false, y : true\n    for(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n    TwoSAT sat(n);\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n            if(abs(x[i] - x[j]) < d) sat.add_edge(i, true, j, true);\n            if(abs(x[i] - y[j]) < d) sat.add_edge(i, true, j, false);\n            if(abs(y[i] - x[j]) < d) sat.add_edge(i, false, j, true);\n            if(abs(y[i] - y[j]) < d) sat.add_edge(i, false, j, false);\n        }\n    }\n    if(!sat.judge()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    for(int i = 0; i < n; i++){\n        if(!sat.f[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    int n,d;\n    cin >> n >> d;\n    two_sat ts(n);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(abs(x[i]-x[j])<d){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(y[i]-y[j]<d)){\n                ts.add_clause(i,true,j,true);\n            }\n            if(abs(x[i]-y[j])<d){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(y[i]-x[j])<d){\n                ts.add_clause(i,true,j,false);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans=ts.answer();\n    rep(i,n){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param n `0 <= n`\n        // @return minimum non-negative `x` s.t. `n <= 2**x`\n        int ceil_pow2(int n)\n        {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n))\n                x++;\n            return x;\n        }\n        // @param n `1 <= n`\n        // @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\n        int bsf(unsigned int n)\n        {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder\n{\n    namespace internal\n    {\n        // @param m `1 <= m`\n        // @return x mod m\n        constexpr long long safe_mod(long long x, long long m)\n        {\n            x %= m;\n            if (x < 0)\n                x += m;\n            return x;\n        }\n        // Fast moduler by barrett reduction\n        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n        // NOTE: reconsider after Ice Lake\n        struct barrett\n        {\n            unsigned int _m;\n            unsigned long long im;\n            // @param m `1 <= m`\n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            // @return m\n            unsigned int umod() const { return _m; }\n            // @param a `0 <= a < m`\n            // @param b `0 <= b < m`\n            // @return `a * b % m`\n            unsigned int mul(unsigned int a, unsigned int b) const\n            {\n                // [1] m = 1\n                // a = b = im = 0, so okay\n                // [2] m >= 2\n                // im = ceil(2^64 / m)\n                // -> im * m = 2^64 + r (0 <= r < m)\n                // let z = a*b = c*m + d (0 <= c, d < m)\n                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n                // ((ab * im) >> 64) == c or c + 1\n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v)\n                    v += _m;\n                return v;\n            }\n        };\n        // @param n `0 <= n`\n        // @param m `1 <= m`\n        // @return `(x ** n) % m`\n        constexpr long long pow_mod_constexpr(long long x, long long n, int m)\n        {\n            if (m == 1)\n                return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n)\n            {\n                if (n & 1)\n                    r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        // Reference:\n        // M. Forisek and J. Jancina,\n        // Fast Primality Testing for Integers That Fit into a Machine Word\n        // @param n `0 <= n`\n        constexpr bool is_prime_constexpr(int n)\n        {\n            if (n <= 1)\n                return false;\n            if (n == 2 || n == 7 || n == 61)\n                return true;\n            if (n % 2 == 0)\n                return false;\n            long long d = n - 1;\n            while (d % 2 == 0)\n                d /= 2;\n            for (long long a : {2, 7, 61})\n            {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1)\n                {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n>\n        constexpr bool is_prime = is_prime_constexpr(n);\n        // @param b `1 <= b`\n        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)\n        {\n            a = safe_mod(a, b);\n            if (a == 0)\n                return {b, 0};\n            // Contracts:\n            // [1] s - m0 * a = 0 (mod b)\n            // [2] t - m1 * a = 0 (mod b)\n            // [3] s * |m1| + t * |m0| <= b\n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            while (t)\n            {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b\n                // [3]:\n                // (s - t * u) * |m1| + t * |m0 - m1 * u|\n                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n                // = s * |m1| + t * |m0| <= b\n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            // by [3]: |m0| <= b/g\n            // by g != b: |m0| < b/g\n            if (m0 < 0)\n                m0 += b / s;\n            return {s, m0};\n        }\n        // Compile time primitive root\n        // @param m must be prime\n        // @return primitive root (and minimum in now)\n        constexpr int primitive_root_constexpr(int m)\n        {\n            if (m == 2)\n                return 1;\n            if (m == 167772161)\n                return 3;\n            if (m == 469762049)\n                return 3;\n            if (m == 754974721)\n                return 11;\n            if (m == 998244353)\n                return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0)\n                x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    divs[cnt++] = i;\n                    while (x % i == 0)\n                    {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1)\n            {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++)\n            {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++)\n                {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    return g;\n            }\n        }\n        template <int m>\n        constexpr int primitive_root = primitive_root_constexpr(m);\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class T>\n        struct simple_queue\n        {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T &t) { payload.push_back(t); }\n            T &front() { return payload[pos]; }\n            void clear()\n            {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class E>\n        struct csr\n        {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>> &edges)\n                : start(n + 1), elist(edges.size())\n            {\n                for (auto e : edges)\n                {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++)\n                {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges)\n                {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        // Reference:\n        // R. Tarjan,\n        // Depth-First Search and Linear Graph Algorithms\n        struct scc_graph\n        {\n        public:\n            scc_graph(int n) : _n(n) {}\n            int num_vertices() { return _n; }\n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            // @return pair of (# of scc, scc id)\n            std::pair<int, std::vector<int>> scc_ids()\n            {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++)\n                    {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1)\n                        {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        }\n                        else\n                        {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v])\n                    {\n                        while (true)\n                        {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v)\n                                break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++)\n                {\n                    if (ord[i] == -1)\n                        dfs(dfs, i);\n                }\n                for (auto &x : ids)\n                {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            std::vector<std::vector<int>> scc()\n            {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second)\n                    counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++)\n                {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++)\n                {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n\n        private:\n            int _n;\n            struct edge\n            {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder\n{\n    namespace internal\n    {\n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                          std::is_same<T, __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                          std::is_same<T, unsigned __int128>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using make_unsigned_int128 =\n            typename std::conditional<std::is_same<T, __int128_t>::value,\n                                      __uint128_t,\n                                      unsigned __int128>;\n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                          is_signed_int128<T>::value ||\n                                                          is_unsigned_int128<T>::value,\n                                                      std::true_type,\n                                                      std::false_type>::type;\n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n                                                            is_signed_int128<T>::value,\n                                                        std::true_type,\n                                                        std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<(is_integral<T>::value &&\n                                       std::is_unsigned<T>::value) ||\n                                          is_unsigned_int128<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<\n            is_signed_int128<T>::value,\n            make_unsigned_int128<T>,\n            typename std::conditional<std::is_signed<T>::value,\n                                      std::make_unsigned<T>,\n                                      std::common_type<T>>::type>::type;\n#else\n        template <class T>\n        using is_integral = typename std::is_integral<T>;\n        template <class T>\n        using is_signed_int =\n            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using is_unsigned_int =\n            typename std::conditional<is_integral<T>::value &&\n                                          std::is_unsigned<T>::value,\n                                      std::true_type,\n                                      std::false_type>::type;\n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                                      std::make_unsigned<T>,\n                                                      std::common_type<T>>::type;\n#endif\n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        template <class T>\n        using to_unsigned_t = typename to_unsigned<T>::type;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder\n{\n    namespace internal\n    {\n        struct modint_base\n        {\n        };\n        struct static_modint_base : modint_base\n        {\n        };\n        template <class T>\n        using is_modint = std::is_base_of<modint_base, T>;\n        template <class T>\n        using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n    } // namespace internal\n    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>\n    struct static_modint : internal::static_modint_base\n    {\n        using mint = static_modint;\n\n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0)\n                x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        static_modint(T v)\n        {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v -= rhs._v;\n            if (_v >= umod())\n                _v += umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            if (prime)\n            {\n                assert(_v);\n                return pow(umod() - 2);\n            }\n            else\n            {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    template <int id>\n    struct dynamic_modint : internal::modint_base\n    {\n        using mint = dynamic_modint;\n\n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m)\n        {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v)\n        {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0)\n                x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T> * = nullptr>\n        dynamic_modint(T v)\n        {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        unsigned int val() const { return _v; }\n        mint &operator++()\n        {\n            _v++;\n            if (_v == umod())\n                _v = 0;\n            return *this;\n        }\n        mint &operator--()\n        {\n            if (_v == 0)\n                _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int)\n        {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int)\n        {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        mint &operator+=(const mint &rhs)\n        {\n            _v += rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator-=(const mint &rhs)\n        {\n            _v += mod() - rhs._v;\n            if (_v >= umod())\n                _v -= umod();\n            return *this;\n        }\n        mint &operator*=(const mint &rhs)\n        {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }\n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        mint pow(long long n) const\n        {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n)\n            {\n                if (n & 1)\n                    r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const\n        {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        friend mint operator+(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint &lhs, const mint &rhs)\n        {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint &lhs, const mint &rhs)\n        {\n            return lhs._v != rhs._v;\n        }\n\n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id>\n    internal::barrett dynamic_modint<id>::bt = 998244353;\n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    namespace internal\n    {\n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        template <class>\n        struct is_dynamic_modint : public std::false_type\n        {\n        };\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type\n        {\n        };\n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n    } // namespace internal\n} // namespace atcoder\n#endif // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_e[30]; // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n        void butterfly_inv(std::vector<mint> &a)\n        {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            static bool first = true;\n            static mint sum_ie[30]; // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first)\n            {\n                first = false;\n                mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--)\n                {\n                    // e^(2^i) == 1\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++)\n                {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            for (int ph = h; ph >= 1; ph--)\n            {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++)\n                {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++)\n                    {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                            (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                            inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n    } // namespace internal\n    template <class mint, internal::is_static_modint_t<mint> * = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        if (std::min(n, m) <= 60)\n        {\n            if (n < m)\n            {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++)\n        {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++)\n            a[i] *= iz;\n        return a;\n    }\n    template <unsigned int mod = 998244353,\n              class T,\n              std::enable_if_t<internal::is_integral<T>::value> * = nullptr>\n    std::vector<T> convolution(const std::vector<T> &a, const std::vector<T> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++)\n        {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++)\n        {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    std::vector<long long> convolution_ll(const std::vector<long long> &a,\n                                          const std::vector<long long> &b)\n    {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m)\n            return {};\n        static constexpr unsigned long long MOD1 = 754974721; // 2^24\n        static constexpr unsigned long long MOD2 = 167772161; // 2^25\n        static constexpr unsigned long long MOD3 = 469762049; // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        static constexpr unsigned long long i1 =\n            internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n            internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n            internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++)\n        {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            // B = 2^63, -B <= x, r(real value) < B\n            // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n            // r = c1[i] (mod MOD1)\n            // focus on MOD1\n            // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n            // r = x,\n            //     x - M' + (0 or 2B),\n            //     x - 2M' + (0, 2B or 4B),\n            //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n            // (r - x) = 0, (0)\n            //           - M' + (0 or 2B), (1)\n            //           -2M' + (0 or 2B or 4B), (2)\n            //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n            // we checked that\n            //   ((1) mod MOD1) mod 5 = 2\n            //   ((2) mod MOD1) mod 5 = 3\n            //   ((3) mod MOD1) mod 5 = 4\n            long long diff =\n                c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0)\n                diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        return c;\n    }\n} // namespace atcoder\n#endif // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Implement (union by size) + (path compression)\n    // Reference:\n    // Zvi Galil and Giuseppe F. Italiano,\n    // Data structures and algorithms for disjoint set union problems\n    struct dsu\n    {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        int merge(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y)\n                return x;\n            if (-parent_or_size[x] < -parent_or_size[y])\n                std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        bool same(int a, int b)\n        {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        int leader(int a)\n        {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0)\n                return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        int size(int a)\n        {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        std::vector<std::vector<int>> groups()\n        {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++)\n            {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++)\n            {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                std::remove_if(result.begin(), result.end(),\n                               [&](const std::vector<int> &v) { return v.empty(); }),\n                result.end());\n            return result;\n        }\n\n    private:\n        int _n;\n        // root node: -1 * component size\n        // otherwise: parent\n        std::vector<int> parent_or_size;\n    };\n} // namespace atcoder\n#endif // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference: https://en.wikipedia.org/wiki/Fenwick_tree\n    template <class T>\n    struct fenwick_tree\n    {\n        using U = internal::to_unsigned_t<T>;\n\n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        void add(int p, T x)\n        {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n)\n            {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        T sum(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n\n    private:\n        int _n;\n        std::vector<U> data;\n        U sum(int r)\n        {\n            U s = 0;\n            while (r > 0)\n            {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder\n{\n    template <class S,\n              S (*op)(S, S),\n              S (*e)(),\n              class F,\n              S (*mapping)(F, S),\n              F (*composition)(F, F),\n              F (*id)()>\n    struct lazy_segtree\n    {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            return d[p];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return e();\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push(r >> i);\n            }\n            S sml = e(), smr = e();\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        void apply(int p, F f)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--)\n                push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        void apply(int l, int r, F f)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r)\n                return;\n            l += size;\n            r += size;\n            for (int i = log; i >= 1; i--)\n            {\n                if (((l >> i) << i) != l)\n                    push(l >> i);\n                if (((r >> i) << i) != r)\n                    push((r - 1) >> i);\n            }\n            {\n                int l2 = l, r2 = r;\n                while (l < r)\n                {\n                    if (l & 1)\n                        all_apply(l++, f);\n                    if (r & 1)\n                        all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            for (int i = 1; i <= log; i++)\n            {\n                if (((l >> i) << i) != l)\n                    update(l >> i);\n                if (((r >> i) << i) != r)\n                    update((r - 1) >> i);\n            }\n        }\n        template <bool (*g)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G>\n        int max_right(int l, G g)\n        {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            for (int i = log; i >= 1; i--)\n                push(l >> i);\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!g(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*g)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G>\n        int min_left(int r, G g)\n        {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            for (int i = log; i >= 1; i--)\n                push((r - 1) >> i);\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!g(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f)\n        {\n            d[k] = mapping(f, d[k]);\n            if (k < size)\n                lz[k] = composition(f, lz[k]);\n        }\n        void push(int k)\n        {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n} // namespace atcoder\n#endif // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder\n{\n    long long pow_mod(long long x, long long n, int m)\n    {\n        assert(0 <= n && 1 <= m);\n        if (m == 1)\n            return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n)\n        {\n            if (n & 1)\n                r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    long long inv_mod(long long x, long long m)\n    {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    // (rem, mod)\n    std::pair<long long, long long> crt(const std::vector<long long> &r,\n                                        const std::vector<long long> &m)\n    {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        // Contracts: 0 <= r0 < m0\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++)\n        {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1)\n            {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0)\n            {\n                if (r0 % m1 != r1)\n                    return {0, 0};\n                continue;\n            }\n            // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n            // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n            // r2 % m0 = r0\n            // r2 % m1 = r1\n            // -> (r0 + x*m0) % m1 = r1\n            // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n            // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n            // im = inv(u0) (mod u1) (0 <= im < u1)\n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            long long u1 = (m1 / g);\n            // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n            if ((r1 - r0) % g)\n                return {0, 0};\n            // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n            long long x = (r1 - r0) / g % u1 * im % u1;\n            // |r0| + |m0 * x|\n            // < m0 + m0 * (u1 - 1)\n            // = m0 + m0 * m1 / g - m0\n            // = lcm(m0, m1)\n            r0 += x * m0;\n            m0 *= u1; // -> lcm(m0, m1)\n            if (r0 < 0)\n                r0 += m0;\n        }\n        return {r0, m0};\n    }\n    long long floor_sum(long long n, long long m, long long a, long long b)\n    {\n        long long ans = 0;\n        if (a >= m)\n        {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m)\n        {\n            ans += n * (b / m);\n            b %= m;\n        }\n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0)\n            return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n} // namespace atcoder\n#endif // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap>\n    struct mf_graph\n    {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++)\n            {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto &_e = g[pos[i].first][pos[i].second];\n            auto &_re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        Cap flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty())\n                {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v])\n                    {\n                        if (e.cap == 0 || level[e.to] >= 0)\n                            continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t)\n                            return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s)\n                    return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int &i = iter[v]; i < int(g[v].size()); i++)\n                {\n                    _edge &e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0)\n                        continue;\n                    Cap d =\n                        self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0)\n                        continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up)\n                        break;\n                }\n                return res;\n            };\n            Cap flow = 0;\n            while (flow < flow_limit)\n            {\n                bfs();\n                if (level[t] == -1)\n                    break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit)\n                {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f)\n                        break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        std::vector<bool> min_cut(int s)\n        {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty())\n            {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p])\n                {\n                    if (e.cap && !visited[e.to])\n                    {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder\n{\n    template <class Cap, class Cost>\n    struct mcf_graph\n    {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        int add_edge(int from, int to, Cap cap, Cost cost)\n        {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        struct edge\n        {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        edge get_edge(int i)\n        {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first,\n                _e.to,\n                _e.cap + _re.cap,\n                _re.cap,\n                _e.cost,\n            };\n        }\n        std::vector<edge> edges()\n        {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++)\n            {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        std::pair<Cap, Cost> flow(int s, int t)\n        {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit)\n        {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t)\n        {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit)\n        {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            // variants (C = maxcost):\n            // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n            // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q\n                {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty())\n                {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v])\n                        continue;\n                    vis[v] = true;\n                    if (v == t)\n                        break;\n                    // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                    // dist[v] >= 0 (all reduced cost are positive)\n                    // dist[v] <= (n-1)C\n                    for (int i = 0; i < int(g[v].size()); i++)\n                    {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap)\n                            continue;\n                        // |-dual[e.to] + dual[v]| <= (n-1)C\n                        // cost <= C - -(n-1)C + 0 = nC\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost)\n                        {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t])\n                {\n                    return false;\n                }\n                for (int v = 0; v < _n; v++)\n                {\n                    if (!vis[v])\n                        continue;\n                    // dual[v] = dual[v] - dist[t] + dist[v]\n                    //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                    //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                    //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit)\n            {\n                if (!dual_ref())\n                    break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v])\n                {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v])\n                {\n                    auto &e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d)\n                {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n\n    private:\n        int _n;\n        struct _edge\n        {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n} // namespace atcoder\n#endif // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    struct scc_graph\n    {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        void add_edge(int from, int to)\n        {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n    private:\n        internal::scc_graph internal;\n    };\n} // namespace atcoder\n#endif // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    template <class S, S (*op)(S, S), S (*e)()>\n    struct segtree\n    {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S> &v) : _n(int(v.size()))\n        {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++)\n                d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--)\n            {\n                update(i);\n            }\n        }\n        void set(int p, S x)\n        {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++)\n                update(p >> i);\n        }\n        S get(int p)\n        {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        S prod(int l, int r)\n        {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            while (l < r)\n            {\n                if (l & 1)\n                    sml = op(sml, d[l++]);\n                if (r & 1)\n                    smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        S all_prod() { return d[1]; }\n        template <bool (*f)(S)>\n        int max_right(int l)\n        {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F>\n        int max_right(int l, F f)\n        {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n)\n                return _n;\n            l += size;\n            S sm = e();\n            do\n            {\n                while (l % 2 == 0)\n                    l >>= 1;\n                if (!f(op(sm, d[l])))\n                {\n                    while (l < size)\n                    {\n                        l = (2 * l);\n                        if (f(op(sm, d[l])))\n                        {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        template <bool (*f)(S)>\n        int min_left(int r)\n        {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F>\n        int min_left(int r, F f)\n        {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0)\n                return 0;\n            r += size;\n            S sm = e();\n            do\n            {\n                r--;\n                while (r > 1 && (r % 2))\n                    r >>= 1;\n                if (!f(op(d[r], sm)))\n                {\n                    while (r < size)\n                    {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm)))\n                        {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n} // namespace atcoder\n#endif // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder\n{\n    namespace internal\n    {\n        std::vector<int> sa_naive(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r)\n                    return false;\n                while (l < n && r < n)\n                {\n                    if (s[l] != s[r])\n                        return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        std::vector<int> sa_doubling(const std::vector<int> &s)\n        {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2)\n            {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y])\n                        return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        // SA-IS, linear-time suffix array construction\n        // Reference:\n        // G. Nong, S. Zhang, and W. H. Chan,\n        // Two Efficient Algorithms for Linear Time Suffix Array Construction\n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int> &s, int upper)\n        {\n            int n = int(s.size());\n            if (n == 0)\n                return {};\n            if (n == 1)\n                return {0};\n            if (n == 2)\n            {\n                if (s[0] < s[1])\n                {\n                    return {0, 1};\n                }\n                else\n                {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE)\n            {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING)\n            {\n                return sa_doubling(s);\n            }\n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--)\n            {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++)\n            {\n                if (!ls[i])\n                {\n                    sum_s[s[i]]++;\n                }\n                else\n                {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++)\n            {\n                sum_s[i] += sum_l[i];\n                if (i < upper)\n                    sum_l[i + 1] += sum_s[i];\n            }\n            auto induce = [&](const std::vector<int> &lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms)\n                {\n                    if (d == n)\n                        continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1])\n                    {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--)\n                {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1])\n                    {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++)\n            {\n                if (!ls[i - 1] && ls[i])\n                {\n                    lms.push_back(i);\n                }\n            }\n            induce(lms);\n            if (m)\n            {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa)\n                {\n                    if (lms_map[v] != -1)\n                        sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++)\n                {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r)\n                    {\n                        same = false;\n                    }\n                    else\n                    {\n                        while (l < end_l)\n                        {\n                            if (s[l] != s[r])\n                            {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r])\n                            same = false;\n                    }\n                    if (!same)\n                        rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                auto rec_sa =\n                    sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                for (int i = 0; i < m; i++)\n                {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n    } // namespace internal\n    std::vector<int> suffix_array(const std::vector<int> &s, int upper)\n    {\n        assert(0 <= upper);\n        for (int d : s)\n        {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    template <class T>\n    std::vector<int> suffix_array(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (i && s[idx[i - 1]] != s[idx[i]])\n                now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    std::vector<int> suffix_array(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    // Reference:\n    // T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    // Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    // Applications\n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T> &s,\n                               const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++)\n        {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (h > 0)\n                h--;\n            if (rnk[i] == 0)\n                continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++)\n            {\n                if (s[j + h] != s[i + h])\n                    break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    std::vector<int> lcp_array(const std::string &s, const std::vector<int> &sa)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    // Reference:\n    // D. Gusfield,\n    // Algorithms on Strings, Trees, and Sequences: Computer Science and\n    // Computational Biology\n    template <class T>\n    std::vector<int> z_algorithm(const std::vector<T> &s)\n    {\n        int n = int(s.size());\n        if (n == 0)\n            return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++)\n        {\n            int &k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k])\n                k++;\n            if (j + z[j] < i + z[i])\n                j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    std::vector<int> z_algorithm(const std::string &s)\n    {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++)\n        {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n} // namespace atcoder\n#endif // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder\n{\n    // Reference:\n    // B. Aspvall, M. Plass, and R. Tarjan,\n    // A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n    // Formulas\n    struct two_sat\n    {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        void add_clause(int i, bool f, int j, bool g)\n        {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable()\n        {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++)\n            {\n                if (id[2 * i] == id[2 * i + 1])\n                    return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n\n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n} // namespace atcoder\n#endif // ATCODER_TWOSAT_HPP\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define endl '\\n'\n#define loop(i, n) for (unsigned int i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define modd 1000000007ll\n//#define modd 998244353ll\n#define flagcount(bit) __builtin_popcount(bit)\n#define flag(x) (1ll << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1ll << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define idx_lower(v, x) (distance(v.begin(), low2way(v, x)))  //配列vでx未満の要素数を返す\n#define idx_upper(v, x) (distance(v.begin(), high2way(v, x))) //配列vでx以下の要素数を返す\n#define idx_lower2(v, x) (v.size() - idx_lower(v, x))         //配列vでx以上の要素数を返す\n#define idx_upper2(v, x) (v.size() - idx_upper(v, x))         //配列vでxより大きい要素の数を返す\n#define putout(a) cout << a << '\\n'\n#define Sum(v) accumulate(all(v), 0ll)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return -1;\n}\ntemplate <typename T>\nstring make_string(T N)\n{\n    string ret;\n    T now = N;\n    while (now > 0)\n    {\n        T x = now % 10;\n        ret += (char)('0' + x);\n        now /= 10;\n    }\n    reverse(all(ret));\n    return ret;\n}\ntemplate <typename T>\nT gcd(T a, T b)\n{\n    if (a % b == 0)\n    {\n        return (b);\n    }\n    else\n    {\n        return (gcd(b, a % b));\n    }\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nbool chmax(T &a, const T &b)\n{\n    if (a < b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nbool chmin(T &a, const T &b)\n{\n    if (a > b)\n    {\n        a = b; // aをbで更新\n        return true;\n    }\n    return false;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//2次元配列の宣言\n//vector<vector<ll>> field(h, vector<ll>(w));\nclass FastIO\n{\n    static const int rdata_sz = (1 << 25), wdata_sz = (1 << 25);\n    char rdata[rdata_sz], wdata[wdata_sz], *rb, *wb;\n    char tmp_s[20];\n\npublic:\n    FastIO()\n    {\n        fread(rdata, 1, rdata_sz, stdin);\n        rb = rdata;\n        wb = wdata;\n    }\n    ~FastIO()\n    {\n        fwrite(wdata, 1, wb - wdata, stdout);\n    }\n\n    template <typename T>\n    inline void read(T &x)\n    {\n        bool neg = false;\n        x = 0;\n        while ((*rb < '0' || *rb > '9') && *rb != '-')\n            ++rb;\n        if (*rb == '-')\n        {\n            neg = true;\n            ++rb;\n        }\n        while ('0' <= *rb && *rb <= '9')\n        {\n            x = 10 * x + (*rb - '0');\n            ++rb;\n        }\n        if (neg)\n            x = -x;\n    }\n\n#define pc(x) *(wb++) = x\n    template <typename T>\n    inline void write(T x)\n    {\n        if (x == 0)\n        {\n            pc('0');\n            pc('\\n');\n            return;\n        }\n        if (x < 0)\n        {\n            pc('-');\n            x = -x;\n        }\n        char *t = tmp_s;\n        while (x)\n        {\n            T y = x / 10;\n            *(t++) = (x - y * 10) + '0';\n            x = y;\n        }\n        while (t != tmp_s)\n            pc(*(--t));\n        pc('\\n');\n    }\n#undef pc\n};\nint main()\n{\n    FastIO io;\n    unsigned int N, D;\n    io.read(N);\n    io.read(D);\n    vector<int> X(N), Y(N);\n    loop(i, N) cin >> X[i] >> Y[i];\n    two_sat ts(N);\n    loop(i, N)\n    {\n        Loop(j, i + 1, N)\n        {\n            if (abs(X[i] - X[j]) < D)\n                ts.add_clause(i, 0, j, 0);\n            if (abs(X[i] - Y[j]) < D)\n                ts.add_clause(i, 0, j, 1);\n            if (abs(Y[i] - X[j]) < D)\n                ts.add_clause(i, 1, j, 0);\n            if (abs(Y[i] - Y[j]) < D)\n                ts.add_clause(i, 1, j, 1);\n        }\n    }\n    if (!ts.satisfiable())\n    {\n        putout(\"No\");\n        return 0;\n    }\n    vector<bool> ans = ts.answer();\n    putout(\"Yes\");\n    loop(i, N)\n    {\n        if (ans[i])\n            io.write(X[i]);\n        else\n            io.write(Y[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"/workspaces/compro/lib/atcoder/twosat.hpp\"\n\n\n\n#line 1 \"/workspaces/compro/lib/atcoder/internal_scc.hpp\"\n\n\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#line 5 \"/workspaces/compro/lib/atcoder/twosat.hpp\"\n#include <cassert>\n#line 7 \"/workspaces/compro/lib/atcoder/twosat.hpp\"\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\npublic:\n  two_sat() : _n(0), scc(0) {}\n  two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n  void add_clause(int i, bool f, int j, bool g) {\n    assert(0 <= i && i < _n);\n    assert(0 <= j && j < _n);\n    scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n    scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n  }\n  bool satisfiable() {\n    auto id = scc.scc_ids().second;\n    for (int i = 0; i < _n; i++) {\n      if (id[2 * i] == id[2 * i + 1])\n        return false;\n      _answer[i] = id[2 * i] < id[2 * i + 1];\n    }\n    return true;\n  }\n  std::vector<bool> answer() { return _answer; }\n\nprivate:\n  int _n;\n  std::vector<bool> _answer;\n  internal::scc_graph scc;\n};\n\n} // namespace atcoder\n\n\n#line 1 \"/workspaces/compro/lib/template.hpp\"\n\n\n#line 1 \"/workspaces/compro/lib/io/vector.hpp\"\n#include <iostream>\n#line 3 \"/workspaces/compro/lib/io/vector.hpp\"\n\n#ifndef IO_VECTOR\n#define IO_VECTOR\n\ntemplate <class T> std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) {\n  int size = v.size();\n  for (int i = 0; i < size; i++) {\n    std::cout << v[i];\n    if (i != size - 1)\n      std::cout << \" \";\n  }\n  return out;\n}\n\ntemplate <class T> std::istream &operator>>(std::istream &in, std::vector<T> &v) {\n  for (auto &el : v) {\n    std::cin >> el;\n  }\n  return in;\n}\n\n#endif\n#line 4 \"/workspaces/compro/lib/template.hpp\"\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n#define MM << \" \" <<\n\nusing namespace std;\n\ntemplate <class T> void say(bool val, T yes, T no) { cout << (val ? yes : no) << \"\\n\"; }\n\nvoid say(bool val, string yes = \"Yes\", string no = \"No\") { say<string>(val, yes, no); }\n\ntemplate <class T> void chmin(T &a, T b) {\n  if (a > b)\n    a = b;\n}\n\ntemplate <class T> void chmax(T &a, T b) {\n  if (a < b)\n    a = b;\n}\n\n// C++ 17に完全移行したら消す\n// 最大公約数を求める\ntemplate <class T> T gcd(T n, T m) { return n ? gcd(m % n, n) : m; }\n\n// 最小公倍数を求める\ntemplate <class T> T lcm(T n, T m) {\n  int g = gcd(n, m);\n  return n * m / g;\n}\n\n// 重複を消す。計算量はO(NlogN)\ntemplate <class T> void unique(std::vector<T> &v) {\n  std::sort(v.begin(), v.end());\n  v.erase(std::unique(v.begin(), v.end()), v.end());\n}\n\n\n#line 3 \"main.cpp\"\n\nconst std::string YES = \"Yes\";\nconst std::string NO = \"No\";\n\n// generated by online-judge-template-generator v4.4.0 (https://github.com/kmyk/online-judge-template-generator)\nint main() {\n  int N;\n  int D;\n  std::cin >> N;\n  std::vector<int> X(N), Y(N);\n  std::cin >> D;\n  for (int i = 0; i < N; ++i) {\n    std::cin >> X[i] >> Y[i];\n  }\n\n  // p: 0, ..., N-1, q: N,..., 2N-1\n  atcoder::two_sat ts(2 * N);\n  REP(i, N) {\n    ts.add_clause(i, true, N + i, true);\n    ts.add_clause(i, false, N + i, false);\n  }\n\n  REP(i, N) {\n    FOR(j, i + 1, N) {\n      if (abs(X[i] - X[j]) < D) {\n        ts.add_clause(i, false, j, false);\n      }\n      if (abs(X[i] - Y[j]) < D) {\n        ts.add_clause(i, false, N + j, false);\n      }\n      if (abs(Y[i] - X[j]) < D) {\n        ts.add_clause(N + i, false, j, false);\n      }\n      if (abs(Y[i] - Y[j]) < D) {\n        ts.add_clause(N + i, false, N + j, false);\n      }\n    }\n  }\n\n  bool ok = ts.satisfiable();\n  if (!ok) {\n    cout << NO << endl;\n  } else {\n    cout << YES << endl;\n    auto v = ts.answer();\n    REP(i, N) {\n      if (v[i]) {\n        cout << X[i] << endl;\n      } else {\n        cout << Y[i] << endl;\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <atcoder/all>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) for(int sz=0;sz<int(vec.size());sz++) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, d; cin >> n >> d;\n    vll x(n), y(n);\n    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\n    atcoder::two_sat ts(2 * n);\n    for (int i = 0; i < n; i++) {\n        ts.add_clause(i, true, i + n, true);\n        ts.add_clause(i, false, i + n, false);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j + n, false);\n            if (abs(y[i] - y[j]) < d) ts.add_clause(i + n, false, j + n, false);\n        }\n    }\n\n    if (ts.satisfiable()) {\n        cout << \"Yes\\n\";\n        V<bool> ans = ts.answer();\n        for (int i = 0; i < n; i++) {\n            if (ans[i]) cout << x[i] << '\\n';\n            if (ans[i + n]) cout << y[i] << '\\n';\n        }\n    } else {\n        cout << \"No\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    long long N,D;\n    cin>>N>>D;\n    long long X[N],Y[N];\n    for(int i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n    }\n\n    two_sat ts(N);\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            long long pat1=abs(X[i]-X[j]);\n            long long pat2=abs(X[i]-Y[j]);\n            long long pat3=abs(Y[i]-X[j]);\n            long long pat4=abs(Y[i]-Y[j]);\n            //cout<<i<<\",\"<<j<<\"---\"<<pat1<<\",\"<<pat2<<\",\"<<pat3<<\",\"<<pat4<<\",\"<<D*D<<endl;\n            if(pat1<D) ts.add_clause(i,true,j,true);\n            if(pat2<D) ts.add_clause(i,true,j,false);\n            if(pat3<D) ts.add_clause(i,false,j,true);\n            if(pat4<D) ts.add_clause(i,false,j,false);\n        }\n    }\n\n    if(ts.satisfiable()){\n        cout<<\"Yes\"<<endl;\n        vector<bool> v=ts.answer();\n        for(int i=0;i<v.size();i++){\n            if(!v[i]) cout<<X[i]<<endl;\n            else cout<<Y[i]<<endl;\n        }\n    }\n    else cout<<\"No\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>; using vi = vector<int>; using vvi = vector<vi>; using vl = vector<ll>; using vvl = vector<vl>;\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#include <atcoder/all>\nusing namespace atcoder;\n\n// 旗iの座標をFiとする。\n// Fi=Xi or Fi=Yi である。\n// (Fi=Xi or Fj=Xj) は (Fi=Yi → Fj=Xj) と同値。\n// 対偶を取ると，Fj=Yj → Fi=Xi と更に同値。\n// i=0,1,...,N-1に対し，\n// (1)|Xi-Xj|<D のとき (Fi=Xi → Fj=Yj) i.e. (Fi=Yi or Fj=Yj) というクローズを加え，\n// (2)|Xi-Yj|<D のとき (Fi=Xi → Fj=Xj) i.e. (Fi=Yi or Fj=Xj) というクローズを加え，\n// (3)|Yi-Yj|<D のとき (Fi=Yi → Fj=Xj) i.e. (Fi=Xi or Fj=Xj) というクローズを加え，\n// (4)|Yi-Xj|<D のとき (Fi=Yi → Fj=Yj) i.e. (Fi=Xi or Fj=Yj) というクローズを加える。 ※(2)でカバー済\n// Fi=Xiであることをtrueで，Fi=Yiであることをfalseで表す。\n\nint main() {\n\tint N, D; cin >> N >> D;\n\tvi X(N), Y(N); rep(i, N) cin >> X[i] >> Y[i];\n\ttwo_sat ts(N);\n\trep(i, N - 1) rep2(j, i + 1, N) {\n\t\tif (abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n\t\tif (abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n\t\tif (abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n\t\tif (abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n\t}\n\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tvector<bool> v = ts.answer();\n\t\trep(i, N) cout << (v[i] ? X[i] : Y[i]) << endl;\n\t\t// for (auto e : ts.answer()) {\n\t\t// \tdbl(e);\n\t\t// }\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Strongly_Connected_Component {\n  int n, k;\n  vector<vector<int>> G, reverseG;\n  vector<int> vs, cmp;\n  vector<bool> used;\n  Strongly_Connected_Component(int newv = 1) {\n    n = newv;\n    G.resize(n);\n    reverseG.resize(n);\n    used.resize(n, 0);\n    cmp.resize(n);\n  }\n\n  bool add(int from, int to) {\n    G[from].push_back(to);\n    reverseG[to].push_back(from);\n    return 1;\n  }\n  void dfs(int v) {\n    used[v] = true;\n    for (auto to : G[v])\n      if (!used[to]) dfs(to);\n    vs.push_back(v);\n  }\n  void rdfs(int v) {\n    used[v] = true;\n    cmp[v] = k;\n    for (auto to : reverseG[v])\n      if (!used[to]) rdfs(to);\n  }\n  int solve() {\n    used.assign(n, 0);\n    vs.clear();\n    for (int v = 0; v < n; ++v)\n      if (!used[v]) dfs(v);\n    used.assign(n, 0);\n    k = 0;\n    for (int i = (int)vs.size() - 1; i >= 0; --i)\n      if (!used[vs[i]]) {\n        rdfs(vs[i]);\n        ++k;\n      }\n    return k;\n  }\n  vector<vector<int>> make_graph(bool dosolve = 1) {\n    if (dosolve) solve();\n    vector<vector<int>> res(k);\n    for (int i = 0; i < n; ++i)\n      for (int to : G[i])\n        if (!issame(i, to)) res[cmp[i]].push_back(cmp[to]);\n    for (auto& v : res) {\n      sort(v.begin(), v.end());\n      v.erase(unique(v.begin(), v.end()), v.end());\n    }\n    return res;\n  }\n  vector<vector<int>> make_list(bool dosolve = 1) {\n    if (dosolve) solve();\n    vector<vector<int>> res(k);\n    for (int i = 0; i < n; ++i) res[cmp[i]].push_back(i);\n    return res;\n  }\n  bool issame(int l, int r) { return cmp[l] == cmp[r]; }\n};\n\nstruct Two_SAT {\n  int n;\n  Strongly_Connected_Component scc;\n  Two_SAT(int _n = 1) : n(_n), scc(2 * _n) {}\n  // a v c : !a -> c && !c -> a\n  void add(int a, bool b, int c, bool d) {\n    scc.add(a + b * n, c + (!d) * n);\n    scc.add(c + d * n, a + (!b) * n);\n  }\n  bool solve() {\n    scc.solve();\n    for (int i = 0; i < n; ++i)\n      if (scc.cmp[i] == scc.cmp[i + n]) return 0;\n    return 1;\n  }\n  vector<bool> make_vec() {\n    vector<bool> res;\n    if (!solve()) return res;\n    res.assign(n, 0);\n    for (int i = 0; i < n; ++i) res[i] = scc.cmp[i] > scc.cmp[i + n];\n    return res;\n  }\n};\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n  Two_SAT ts(2 * n);\n  using P = pair<int, int>;\n  vector<P> v(n);\n  for (int i = 0; i < n; ++i) ts.add(i, 1, i + n, 1);\n  for (auto& p : v) cin >> p.first >> p.second;\n  for (int i = 0; i < n; ++i)\n    for (int j = i + 1; j < n; ++j) {\n      if (abs(v[i].first - v[j].first) < d) ts.add(i, 0, j, 0);\n      if (abs(v[i].first - v[j].second) < d) ts.add(i, 0, j + n, 0);\n      if (abs(v[i].second - v[j].first) < d) ts.add(i + n, 0, j, 0);\n      if (abs(v[i].second - v[j].second) < d) ts.add(i + n, 0, j + n, 0);\n    }\n  auto res = ts.make_vec();\n  if (res.size()) {\n    cout << \"Yes\" << endl;\n    for (int i = 0; i < n; ++i)\n      cout << (res[i] ? v[i].first : v[i].second) << endl;\n  } else\n    cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *   @FileName\ta.cpp\n *   @Author\tkanpurin\n *   @Created\t2020.09.08 17:35:29\n**/\n\n#include \"bits/stdc++.h\" \nusing namespace std; \ntypedef long long ll;\n\n\n\nstruct StronglyConnectedComponents {\nprivate:\n    vector<vector<int>> g, rg;\n    vector<int> order; \n    vector<bool> visited;\n    int V;\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (int u : g[v]) dfs(u);\n        order.push_back(v);\n    }\n    void rdfs(int v, int c) {\n        if (comp[v] != -1) return;\n        comp[v] = c;\n        for (int u : rg[v]) rdfs(u, c);\n    }\npublic:\n    vector<vector<int>> Graph; \n    vector<int> comp; \n    StronglyConnectedComponents(int v) : V(v) {\n        g.resize(v);\n        rg.resize(v);\n        visited.resize(v);\n        comp.resize(v);\n    }\n    void add_edge(int from, int to) {\n        g[from].push_back(to);\n        rg[to].push_back(from);\n    }\n    void build() {\n        Graph = vector<vector<int>>();\n        order = vector<int>();\n        visited.assign(V, false);\n        comp.assign(V, -1);\n        for (int i = 0; i < V; i++) dfs(i);\n        reverse(order.begin(), order.end());\n        int number = 0;\n        for (int i = 0; i < V; i++) {\n            if (comp[order[i]] == -1) {\n                rdfs(order[i], number++);\n            }\n        }\n        Graph.resize(number);\n        for (int i = 0; i < V; i++) {\n            for (int v : g[i]) {\n                if (comp[i] == comp[v]) continue;\n                Graph[comp[i]].push_back(comp[v]);\n            }\n        }\n    }\n};\nint main() {\n    int n,d;cin >> n >> d;\n    vector<int> x(n),y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    StronglyConnectedComponents scc(2 * n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                scc.add_edge(i,j+n);\n                scc.add_edge(j,i+n);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                scc.add_edge(i,j);\n                scc.add_edge(j+n,i+n);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                scc.add_edge(i+n,j+n);\n                scc.add_edge(j,i);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                scc.add_edge(i+n,j);\n                scc.add_edge(j+n,i);\n            }\n        }\n    }\n    scc.build();\n    bool ok = true;\n    vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (scc.comp[i] == scc.comp[i+n]) {\n            ok = false;\n            break;\n        }\n        else {\n            if (scc.comp[i] > scc.comp[i + n]) {\n                ans.push_back(x[i]);\n            }\n            else {\n                ans.push_back(y[i]);\n            }\n        }\n    }\n    if (ok) {\n        puts(\"Yes\");\n        for (int i = 0; i < n; i++) {\n            cout << ans[i] << endl;\n        }\n    }\n    else puts(\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << endl\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, d;\n    cin >> n >> d;\n    vector<P> v(n);\n    rep(i, n) cin >> v[i].first >> v[i].second;\n    two_sat g(n);\n    rep(i, n) rep(j, i) {\n        rep(ii, 2) {\n            rep(jj, 2) {\n                if (abs(v[i].first-v[j].first)<d) {\n                    g.add_clause(i, ii==0, j, jj==0);\n                }\n                swap(v[j].first, v[j].second);\n            }\n            swap(v[i].first, v[i].second);\n        }\n    }\n    bool ok = g.satisfiable();\n    if (!ok) {\n        pr(\"No\");\n        return 0;\n    }\n    pr(\"Yes\");\n    auto ans = g.answer();\n\n    rep(i, n) {\n        if (ans[i]) pr(v[i].first);\n        else pr(v[i].second);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define PI 3.14159265358979323846\n#define int long long\nconstexpr long long INF = numeric_limits<long long>::max() / 2;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\nusing Graph = vector<vector<int>>;\n\n\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N,D;\n    cin>>N>>D;\n    int X[N],Y[N];\n    rep(i,N){\n        cin>>X[i]>>Y[i];\n    }\n\n    two_sat ts(N);\n    rep(i,N){\n        for(int j=i+1;j<N;j++){\n            if(abs(X[i]-X[j])<D){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(X[i]-Y[j])<D){\n                ts.add_clause(i,false,j,true);\n            }\n            if(abs(Y[i]-X[j])<D){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(Y[i]-Y[j])<D){\n                ts.add_clause(i,true,j,true);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout<<\"No\"<<endl;\n        return 0;\n    }\n    cout<<\"Yes\"<<endl;\n    auto ans=ts.answer();\n    rep(i,N){\n        if(ans[i]){\n            cout<<X[i]<<endl;\n        }else{\n            cout<<Y[i]<<endl;\n        }\n    }\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld  = long double;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\nconst int INF=1e9+7;\nconst ll LINF=9223372036854775807;\nconst ll MOD=1e9+7;\nconst ld PI=acos(-1);\nconst ld EPS = 1e-10; //微調整用（EPSより小さいと0と判定など）\n\nint ii() { int x; if (scanf(\"%d\", &x)==1) return x; else return 0; }\nlong long il() { long long x; if (scanf(\"%lld\", &x)==1) return x; else return 0; }\nstring is() { string x; cin >> x; return x; }\nchar ic() { char x; cin >> x; return x; }\nvoid oi(int x) { printf(\"%d \", x); }\nvoid ol(long long x) { printf(\"%lld \", x); }\nvoid od_nosp(double x) { printf(\"%.15f\", x); } // 古い問題用\nvoid od(double x) { printf(\"%.15f \", x); }\nvoid os(const string &s) { printf(\"%s \", s.c_str()); }\nvoid oc(const char &c) { printf(\"%c \", c); }\n#define o_map(v){cerr << #v << endl; for(const auto& xxx: v){cout << xxx.first << \" \" << xxx.second << \"\\n\";}} //動作未確認\nvoid br() { putchar('\\n'); }\n\n// #define gcd __gcd //llは受け取らない C++17~のgcdと違うので注意\n// int lcm(int a, int b){return a / gcd(a, b) * b;}\n#define b_e(a) a.begin(),a.end() //sort(b_e(vec));\n#define REP(i,m,n) for(ll i=(ll)(m) ; i < (ll)(n) ; i++ )\n#define DREP(i,m,n) for(ll i=(ll)(m) ; i > (ll)(n) ; i-- )\n#define rep(i,n) REP(i,0,n)\n#define m_p(a,b) make_pair(a,b)\n#define p_b push_back\n#define SZ(x) ((ll)(x).size()) //size()がunsignedなのでエラー避けに\n#define endk '\\n'\n\n\n// coutによるpairの出力（空白区切り）\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {return s << \"(\" << p.first << \" \" << p.second << \")\";}\n// coutによるvectorの出力（空白区切り）\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \" \"; //\"\\t\"に変えるとTabで見やすく区切る\n  }\n  return s;\n}\n// coutによる多次元vectorの出力（空白区切り）\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) {\n    s << vv[i] << endl;\n  }\n  return s;\n}\n\n//最大値、最小値の更新。更新したor等しければtrueを返す\ntemplate<typename T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<typename T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n\n//4近傍（上下左右） rep(i, 2) にすると右・下だけに進む\nvector<int> dx_4 = {1, 0, -1, 0};\nvector<int> dy_4 = {0, 1, 0, -1};\n\n// -------- template end - //\n\n\n// - library ------------- //\n\n#include <atcoder/all>\nusing namespace atcoder;\n\n\n\n// --------- library end - //\n\n\n\nint main(){\n\n  ll N, D;\n  cin >> N >> D;\n\n  vector<pll> flags(N);\n  rep(i, N){\n    ll x = il();\n    ll y = il();\n    flags[i].first = x;\n    flags[i].second = y;\n  }\n\n  // false : X に配置、true : Y に配置 とする\n  two_sat ts(N);\n\n  rep(i, N) REP(j, i+1, N){\n    if (i == j) continue;\n\n    ll ix = flags[i].first;\n    ll iy = flags[i].second;\n    ll jx = flags[j].first;\n    ll jy = flags[j].second;\n    \n    // i を x に置いた場合\n    if (abs(ix-jx) < D){\n      // ix, jx つまり false, false は両立しない\n      ts.add_clause(i, true, j, true);\n    }\n    if (abs(ix-jy) < D){\n      // ix, jy つまり false, true は両立しない\n      ts.add_clause(i, true, j, false);\n    }\n\n    // i を y に置いた場合\n    if (abs(iy-jx) < D){\n      // iy, jx つまり true, false は両立しない\n      ts.add_clause(i, false, j, true);\n    }\n    if (abs(iy-jy) < D){\n      // iy, jy つまり true, true は両立しない\n      ts.add_clause(i, false, j, false);\n    }\n  }\n\n  if (!ts.satisfiable()){\n    cout << \"No\" << endk;\n  }\n  else{\n    cout << \"Yes\" << endk;\n    ll i = 0;\n    for (bool pos : ts.answer()){\n      cout << (pos ? flags[i].second : flags[i].first) << endk;\n      i++;\n    }\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <atcoder/twosat>\nusing namespace std;\nusing namespace atcoder;\n\nint n, d;\nint x[1000], y[1000];\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> d;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\ttwo_sat ts(n);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (!ts.satisfiable()) {\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << \"Yes\" << endl;\n\tauto answer = ts.answer();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (answer[i]) cout << x[i] << endl;\n\t\telse cout << y[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n\n\nusing namespace std;\nusing namespace atcoder;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\n// edit\n\nvoid solve() {\n    int N;\n    cin >> N;\n\n    ll D;\n    cin >> D;\n    vector<pair<ll, ll>> xy(N);\n    REP(i, N) {\n        cin >> xy[i].first >> xy[i].second;\n    }\n\n    two_sat ts(2 * N);\n\n    for (int i = 0; i < N; ++i) {\n        ts.add_clause(2 * i, true, 2 * i + 1, true);\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            vector<pair<ll, ll>> tapu{{xy[i].first,  2 * i},\n                                      {xy[i].second, 2 * i + 1}};\n            vector<pair<ll, ll>> tapi{{xy[j].first,  2 * j},\n                                      {xy[j].second, 2 * j + 1}};\n            for (auto ei1333 : tapu) {\n                for (auto treeone79 : tapi) {\n                    if (abs(ei1333.first - treeone79.first) < D) {\n                        ts.add_clause(ei1333.second, false, treeone79.second, false);\n//                        cerr << ei1333.second << \" \" << treeone79.second << endl;\n                    }\n                }\n            }\n        }\n    }\n\n    bool f = ts.satisfiable();\n    if (f) {\n        cout << \"Yes\" << endl;\n        auto v = ts.answer();\n        for (int i = 0; i < N; ++i) {\n            if (v[2 * i]) {\n                cout << xy[i].first;\n            } else {\n                cout << xy[i].second;\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <vector>\n\n#include <atcoder/twosat>\n\nint main() {\n  int n, d;\n  scanf(\"%d %d\", &n, &d);\n\n  std::vector<std::pair<int, int>> xy(n);\n  for (auto& [x, y]: xy) scanf(\"%d %d\", &x, &y);\n\n  atcoder::two_sat ts(2*n);\n  for (int i = 0; i < n; ++i) {\n    ts.add_clause(2*i, true, 2*i+1, true);\n    ts.add_clause(2*i, false, 2*i+1, false);\n    auto [xi, yi] = xy[i];\n    for (int j = 0; j < n; ++j) {\n      if (i == j) continue;\n      auto [xj, yj] = xy[j];\n      if (std::abs(xi-xj) < d) ts.add_clause(2*i, false, 2*j, false);\n      if (std::abs(xi-yj) < d) ts.add_clause(2*i, false, 2*j+1, false);\n      if (std::abs(yi-xj) < d) ts.add_clause(2*i+1, false, 2*j, false);\n      if (std::abs(yi-yj) < d) ts.add_clause(2*i+1, false, 2*j+1, false);\n    }\n  }\n\n  if (!ts.satisfiable())\n    return puts(\"No\"), 0;\n\n  puts(\"Yes\");\n  auto ans = ts.answer();\n  for (int i = 0; i < n; ++i)\n    printf(\"%d\\n\", ans[2*i]? xy[i].first: xy[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int v, vector<vector<int>> &adj, vector<bool> &visited, stack<int> &s) {\n\tvisited[v] = true;\n\t//cout << v << endl;\n\tfor(auto x : adj[v]) {\n\t\tif(!visited[x]) dfs(x, adj, visited, s);\n\t}\n\ts.push(v);\n}\n\nvoid dfs1(int v, vector<vector<int>> &adj, vector<int> &comp, int t) {\n\tcomp[v] = t;\n\tfor(auto x : adj[v]) {\n\t\tif(comp[x] == -1) dfs1(x, adj, comp, t);\n\t}\n}\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pair<int, int>> pt(n);\n\tfor(int i = 0; i < n; i++) cin >> pt[i].first >> pt[i].second;\n\tvector<vector<int>> adj(2*n), adjt(2*n);\n\tfor(int i = 0; i < n; i++) {\n\t\t//adj[2*i].first = pt[i].first;\n\t\t//adj[2*i+1].first = pt[i].second;\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(i != j) {\n\t\t\t\tif(abs(pt[i].first - pt[j].first) < d) { // cannot take both simultaneously\n\t\t\t\t\tadj[2*i].push_back(2*j+1);\n\t\t\t\t\tadjt[2*j+1].push_back(2*i);\n\t\t\t\t}\n\t\t\t\tif(abs(pt[i].first - pt[j].second) < d) { // cannot take both simultaneously\n\t\t\t\t\tadj[2*i].push_back(2*j);\n\t\t\t\t\tadjt[2*j].push_back(2*i);\n\t\t\t\t}\n\t\t\t\tif(abs(pt[i].second - pt[j].first) < d) { // cannot take both simultaneously\n\t\t\t\t\tadj[2*i+1].push_back(2*j+1);\n\t\t\t\t\tadjt[2*j+1].push_back(2*i+1);\n\t\t\t\t}\n\t\t\t\tif(abs(pt[i].second - pt[j].second) < d) { // cannot take both simultaneously\n\t\t\t\t\tadj[2*i+1].push_back(2*j);\n\t\t\t\t\tadjt[2*j].push_back(2*i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstack<int> s;\n\tvector<bool> visited(2*n, false);\n\tvector<int> comp(2*n, -1); \n\tfor(int i = 0; i < 2*n; i++) {\n\t\tif(!visited[i]) dfs(i, adj, visited, s);\n\t}\n\t//visited.assign(2*n, false);\n\tint j = 0;\n\twhile(!s.empty()) {\n\t\tint i = s.top();\n\t\ts.pop();\n\t\tif(comp[i] == -1) dfs1(i, adjt, comp, j++);\n\t}\n\tvector<int> ans(n);\n\tbool ispos = true;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(comp[2*i] == comp[2*i+1]) {\n\t\t\tispos = false;\n\t\t\tbreak;\n\t\t}\n\t\tans[i] = comp[2*i] < comp[2*i+1] ? pt[i].second : pt[i].first;\n\t}\n\tif(!ispos) cout << \"No\";\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t\tfor(auto x : ans) cout << x << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <fstream>\n#include <iterator>\n#include <random>\n#include <chrono>\n\n\n#define forr(i,start,count) for (int i = (start); i < (start)+(count); ++i)\n#define set_map_includes(set, elt) (set.find((elt)) != set.end())\n#define readint(i) int i; cin >> i\n#define readll(i) ll i; cin >> i\n#define readdouble(i) double i; cin >> i\n#define readstring(s) string s; cin >> s\n\ntypedef long long ll;\n\nusing namespace std;\n\nll modd = 1000 * 1000 * 1000 + 7;\n\ntemplate<class T>\nclass depth_first_search_iterator {\n  public:\n    stack<pair<T,T>> todo;\n    function<bool(T)> notvisited;\n    function<void(T)> mark_visited;\n    function<set<T>(T)> neighbors;\n\n    depth_first_search_iterator() {}\n\n    depth_first_search_iterator(T start, function<bool(T)> notv, function<void(T)> mark_v, function<set<T>(T)> neigh) :\n      notvisited(notv), mark_visited(mark_v), neighbors(neigh), end_(false), current(start), prev(start) {\n          todo.push(make_pair(start, start)); operator++();\n    }\n\n    void operator++() {\n        end_ = true;\n        while (!todo.empty()) {\n            current = todo.top().first; prev = todo.top().second; todo.pop();\n            if (notvisited(current)) {\n                mark_visited(current);\n                for (const T x : neighbors(current)) {  todo.push(make_pair(x, current));   }\n                end_ = false;\n                break;\n            }\n        }\n    }\n\n    T operator*() {     return current;    }\n\n    T previous() {  return prev;  }\n\n    bool end() {  return end_;  }\n\n  private:\n    T current; // contains current node\n    T prev;    // contains previous node\n    bool end_;\n};\n\ntemplate<class T>\nclass breadth_first_search_iterator {\n  public:\n    queue<pair<T,T>> todo;\n    function<bool(T)> notvisited;\n    function<void(T)> mark_visited;\n    function<set<T>(T)> neighbors;\n\n    breadth_first_search_iterator() {}\n\n    breadth_first_search_iterator(T start, function<bool(T)> notv, function<void(T)> mark_v, function<set<T>(T)> neigh) :\n      notvisited(notv), mark_visited(mark_v), neighbors(neigh), end_(false), current(start), prev(start) {\n          todo.push(make_pair(start, start)); operator++();\n    }\n\n    void operator++() {\n        end_ = true;\n        while (!todo.empty()) {\n            current = todo.front().first; prev = todo.front().second; todo.pop();\n            if (notvisited(current)) {\n                mark_visited(current);\n                for (const T x : neighbors(current)) {  todo.push(make_pair(x, current));   }\n                end_ = false;\n                break;\n            }\n        }\n    }\n\n    T operator*() {     return current;    }\n\n    T previous() {  return prev;  }\n\n    bool end() {  return end_;  }\n\n  private:\n    T current;   // current node\n    T prev;      // previous node\n    bool end_;\n};\n\n\ntemplate<class T>\nclass DirectedGraph {\n    // allows only single connection between two vertices\n    public:\n      vector<T> vertices;\n      vector<set<int>> neighbors;\n      depth_first_search_iterator<int> dfs_iterator;\n      breadth_first_search_iterator<int> bfs_iterator;\n      vector<bool> visited;\n\n      DirectedGraph() {}\n\n      DirectedGraph(int n, T default_val = 0) {  for (int i = 0; i < n; ++i) {  AddVertex(default_val);  }   }\n\n      bool EdgeExists(int i_from, int j_to) {\n          return (neighbors[i_from].find(j_to) != neighbors[i_from].end());\n      }\n\n      void AddVertex(T val) {\n          vertices.push_back(val);\n          neighbors.push_back(set<int>());      }\n\n      void AddEdge(int i_from, int j_to) {\n          if (!EdgeExists(i_from, j_to)) {     neighbors[i_from].insert(j_to);      }\n      }\n\n      T& operator[](int i) {      return vertices[i];      }\n\n      void RemoveEdge(int i_from, int j_to) {\n          if (EdgeExists(i_from, j_to)) {\n          neighbors[i_from].erase(find(neighbors[i_from].begin(), neighbors[i_from].end(), j_to));      } }\n\n      DirectedGraph<T> Transpose() {\n          DirectedGraph<T> ret;\n          for (auto x : vertices) {  ret.AddVertex(x);   }\n          for (int i_from = 0; i_from < vertices.size(); ++i_from) {\n              for (int j_to : neighbors[i_from]) {\n                  ret.AddEdge(j_to, i_from);\n              }\n          }\n          return ret;      }\n\n      int vertices_count() {   return vertices.size();  }\n\n      void dfs_init(int start) {\n          visited = vector<bool>(vertices.size(), false);\n          dfs_iterator = depth_first_search_iterator<int>(start, [this](int x){ return !visited[x]; }, [this](int x) { visited[x] = true;  },\n            [this](int x) {  return neighbors[x];  } );\n      }\n\n      void bfs_init(int start) {\n          visited = vector<bool>(vertices.size(), false);\n          bfs_iterator = breadth_first_search_iterator<int>(start, [this](int x){ return !visited[x]; }, [this](int x) { visited[x] = true;  },\n            [this](int x) {  return neighbors[x];  } );\n      }\n\n      void print_() {\n          forr(i, 0, vertices.size()) {\n              for (auto x : neighbors[i]) {\n                  cout << i << \"->\" << x << endl;\n              }\n          }\n      }\n\n};\n\nclass UnionFind {\n    public:\n      vector<int> parent;\n      vector<int> size;\n//      size[i] = number of nodes in tree rooted at i\n// Note: not necessarily correct if i is not a root node\n      set<int> roots;\n\n    UnionFind(int n) : parent(n), size(n) {\n        forr(i,0,n) { roots.insert(i); }\n        forr(i,0,n) {\n            parent[i] = i; size[i] = 1;\n        }\n    } \n\n    int Find(int p) {\n        int root = p;\n        while (root != parent[root]) {  root = parent[root]; }\n        while (p != root) {\n            int newp = parent[p];\n            parent[p] = root;\n            p = newp;\n        }\n        return root;\n    }\n\n    void Union(int p, int q) {\n        int rootP = Find(p);\n        int rootQ = Find(q);\n        if (rootP == rootQ) return;\n\n        if (size[rootP] < size[rootQ]) {\n            parent[rootP] = rootQ;\n            size[rootQ] += size[rootP];\n            roots.erase(rootP);\n        }\n        else {\n            parent[rootQ] = rootP;\n            size[rootP] += size[rootQ];\n            roots.erase(rootQ);\n        }\n    }\n\n};\n\n\nlong long time__;\n\ntemplate<class T>\nvoid SCCUtil(int u, vector<int>& disc, vector<int>& low, stack<int>& st, vector<bool>& stackMember, UnionFind& ret, DirectedGraph<T>& gr)   { \n  \n        disc[u] = low[u] = ++time__;\n        st.push(u);\n        stackMember[u] = true; \n\n        for (auto v : gr.neighbors[u])    {\n          if (disc[v] == -1)   { \n              SCCUtil<T>(v, disc, low, st, stackMember, ret, gr);\n              low[u]  = min(low[u], low[v]); \n          }\n          else if (stackMember[v])    { low[u]  = min(low[u], disc[v]); }   }\n  \n        int w = 0;\n        if (low[u] == disc[u])   {\n          stack<int> component;\n          while (st.top() != u)    { \n              w = (int) st.top();\n              component.push(w);\n              stackMember[w] = false; \n              st.pop(); \n          } \n          w = (int) st.top();\n          while (!component.empty())   {  ret.Union(w, component.top()); component.pop();   }\n\n          stackMember[w] = false;\n          st.pop(); \n        }\n};\n\ntemplate<class T>\nUnionFind SCC(DirectedGraph<T>& gr)  {\n        vector<int> disc(gr.vertices.size(), -1);\n        vector<int> low(gr.vertices.size(), -1); \n        vector<bool> stackMember(gr.vertices.size(), false);\n        stack<int> st;\n        UnionFind ret(gr.vertices.size());\n\n        time__ = 0;\n        for (int i = 0; i < gr.vertices.size(); i++)  {    if (disc[i] == -1) {     SCCUtil<T>(i, disc, low, st, stackMember, ret, gr); }        }\n        return ret;\n};\n\ntemplate<class T>\npair<DirectedGraph<int>, UnionFind> CondensedGraph(DirectedGraph<T>& gr) {\n    // returns condensed graph -- vertices are scc components, *value* (not index) of each vertex is index of root in unionfind\n    DirectedGraph<int> ret;\n    UnionFind ret_ = SCC<T>(gr);\n    map<int,int> dict;\n    int i = 0;\n    for (auto x : ret_.roots) {      ret.AddVertex(x); dict[x] = i; ++i;  }\n    for (int i_from = 0; i_from < gr.vertices.size(); ++i_from) {\n        for (int j_to : gr.neighbors[i_from]) {\n            int root_i = ret_.Find(i_from), root_j = ret_.Find(j_to);\n            if (root_i != root_j)  {      ret.AddEdge(dict[root_i], dict[root_j] );         }\n        }\n    }\n    return make_pair(ret, ret_);\n};\n\ntemplate<class T>\nvector<int> TopologicalOrder(DirectedGraph<T>& g) {\n    // returns indices, sorted topologically for acyclic directed graph\n\n    vector<int> ret;\n    vector<int> incoming(g.vertices.size(), 0);\n    forr(i, 0, g.vertices.size()) {\n        for (auto e : g.neighbors[i]) {\n            ++incoming[e];\n        }\n    }\n\n    set<pair<int,int>> next_vertex;\n    forr(i,0,incoming.size()) {  next_vertex.insert(make_pair(incoming[i], i));   }\n\n    while (!next_vertex.empty()) {\n        ret.push_back(next_vertex.begin()->second);\n        next_vertex.erase(next_vertex.begin());\n        for (auto e : g.neighbors[ret.back()]) {\n            if (incoming[e] > 0) {\n              next_vertex.erase(make_pair(incoming[e], e));\n              --incoming[e];\n              next_vertex.insert(make_pair(incoming[e], e));\n            }\n        }\n    }\n\n    return ret;\n};\n\n\npair<vector<bool>, bool> TwoSatisfiability(int n, vector<pair<int,int>>& clauses) {\n    // returns values for x_1, .. x_n which satisfies clauses, second is true id possible, false if not\n    // n is number of variables;  clauses is conjunction of : elt in clauses of form (i,j) for (x_i or x_j), (i,-j) for (x_i or not x_j) and so on\n    // (n >= i,j >= 1)\n    vector<bool> ret;\n    bool ret_possible = true;\n    DirectedGraph<int> g(2*n);\n    for (auto cl : clauses) {\n        int from = cl.first;\n        int to = -cl.second;\n        int ff = (from > 0) ? (from-1) : (2*n+from);\n        int tt = (to > 0) ? (to-1) : (2*n+to);\n        g.AddEdge(tt, ff);\n\n        from = -from; to = -to; swap(from, to);\n        ff = (from > 0) ? (from-1) : (2*n+from);\n        tt = (to > 0) ? (to-1) : (2*n+to);\n        g.AddEdge(tt, ff);\n    }\n    pair<DirectedGraph<int>, UnionFind> g_c = CondensedGraph<int>(g);\n    forr(i,0,n) {\n        ret_possible = (g_c.second.Find(i) != g_c.second.Find(2*n-1-i));\n        if (!ret_possible) { break; }\n    }\n    map<int, bool> assignments;\n    if (ret_possible) {\n        vector<int> ord = TopologicalOrder<int>(g_c.first);\n        for (int i = ord.size()-1; i >= 0; --i) {\n            if (  !set_map_includes(assignments, g_c.first.vertices[ord[i]]) ) {\n                assignments[g_c.first.vertices[ord[i]]] = true;\n                assignments[g_c.second.Find( 2 * n - 1 - g_c.first.vertices[ord[i]])] = false;\n            }\n        }\n        forr(i,0,n) {\n            ret.push_back(assignments[g_c.second.Find(i)]);\n        }\n    }\n\n    return make_pair(ret, ret_possible);\n};\n\n\nint main()   {\n\n      ios_base::sync_with_stdio(false);\n\n      cout.precision(17);\n      mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n      uniform_int_distribution<int> rand_gen(0, modd);   // rand_gen(rng) gets the rand no\n\n//    readint(test_cases);\n    int test_cases = 1;\n    forr(t, 1, test_cases) {\n        readint(n); readint(d);\n        vector<pair<int,int>> pos;\n        forr(i,0,n) {\n            readint(aa); readint(bb);\n            pos.push_back(make_pair(aa,bb));\n        }\n        vector<pair<int,int>> clauses;\n        forr(i,0,n) {\n            for(int j = i+1; j < n; j++) {\n                int d11 = abs(pos[i].first - pos[j].first);\n                int d12 = abs(pos[i].first - pos[j].second);\n                int d21 = abs(pos[i].second - pos[j].first);\n                int d22 = abs(pos[i].second - pos[j].second);\n                if (d11<d) {\n                    clauses.push_back(make_pair(-(i+1),-(j+1)));\n                }\n                if (d12<d) {\n                    clauses.push_back(make_pair(-(i+1),(j+1)));\n                }\n                if (d21<d) {\n                    clauses.push_back(make_pair((i+1),-(j+1)));\n                }\n                if (d22<d) {\n                    clauses.push_back(make_pair((i+1),(j+1)));\n                }\n            }\n        }\n        auto q = TwoSatisfiability(n, clauses);\n        if (q.second) {\n            cout << \"Yes\" << endl;\n            forr(i,0,n) {\n                cout << (q.first[i] ? pos[i].first : pos[i].second) << endl;\n            }\n        } else {\n            cout << \"No\" << endl;\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <functional>\n\n// AtCoder\n#include <atcoder/all>\nusing namespace atcoder;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...)\n#endif\n\n#define rep_(i, a_, b_, a, b, ...) for (int i = (a), i##_len = (b); i < i##_len; ++i)\n#define rep(i, ...) rep_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define reprev_(i, a_, b_, a, b, ...) for (int i = (b-1), i##_min = (a); i >= i##_min; --i)\n#define reprev(i, ...) reprev_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\ntemplate <class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fls(x) (64 - __builtin_clzll(x))\n#define pcnt(x) __builtin_popcountll(x)\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int,int> P;\ntypedef long double ld;\n\nint main (void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, d; cin >> n >> d;\n    vector<ll> x(n), y(n);\n    rep (i, n) cin >> x[i] >> y[i];\n\n    two_sat ts(n);\n    rep (i, n) {\n        rep (j, i + 1, n) {\n            if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n        }\n    }\n    if (!ts.satisfiable()) {\n        cout << \"No\\n\";\n        return 0;\n    }\n    cout << \"Yes\\n\";\n    auto ans = ts.answer();\n    rep (i, n) {\n        cout << (ans[i] ? x[i] : y[i]) << \"\\n\";\n    }\n    /***************************************************/\n    /* Submit this code from the browser if using ACL! */\n    /***************************************************/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nusing namespace std;\n\n#define visual\n\n#ifdef visual\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <assert.h>\n#include <functional>\n#include <math.h>\n#include <string>\n#include <ctime>\n#endif\n#ifndef visual\n#include <bits/stdc++.h>\n#endif\n\ntypedef long long ll;\n\n\nstruct twosat {\n\n\tvector<bool> vis = {};\n\tvector<int> cc, L;\n\tvector<vector<int> > G;\n\tvector<bool> ans;\n\tint n, cz;\n\n\tvoid visit(int v) {\n\t\tif (vis[v]) return;\n\t\tvis[v] = 1;\n\t\tfor (auto u : G[v])\n\t\t\tvisit(u);\n\t\tL.push_back(v);\n\t}\n\n\tinline void assign(int v, int r) {\n\t\tif (cc[v]) return;\n\t\tcc[v] = r;\n\t\tfor (auto u : G[v ^ 1])\n\t\t\tassign(u ^ 1, r);\n\t\tans[v / 2] = v & 1;\n\t}\n\n\ttwosat(int n) { this->n = n, cz = 0, G.resize(2 * n), ans.resize(n), vis.resize(2 * n), cc.resize(2 * n); }\n\n\tinline void either(int x1, bool v1, int x2, bool v2) {\n\t\tx1 = x1 << 1 | v1, x2 = x2 << 1 | v2;\n\t\tG[x1 ^ 1].push_back(x2);\n\t\tG[x2 ^ 1].push_back(x1);\n\t}\n\n\tinline void implies(int x1, bool v1, int x2, bool v2) {\n\t\teither(x1, false, x2, true);\n\t}\n\n\tvector<bool> solve() {\n\t\tint n = G.size() / 2;\n\n\n\t\tfor (int i = 0; i < 2 * n; ++i)\n\t\t\tvisit(i);\n\t\tvis = vector<bool>(n);\n\t\tfor (int i = L.size() - 1; i >= 0; --i) {\n\t\t\tif (!cc[L[i]])\n\t\t\t\tassign(L[i], ++cz);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (cc[2 * i] == cc[2 * i + 1])\n\t\t\t\treturn {};\n\t\treturn ans;\n\t}\n\n};\n\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n, d;\n\tcin >> n >> d;\n\ttwosat t(n);\n\n\tvector<pair<int, int>> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\n\t\t\tif (abs(v[i].first - v[j].first) < d) {\n\t\t\t\tt.either(i, true, j, true);\n\t\t\t}\n\t\t\tif (abs(v[i].second - v[j].first) < d) {\n\t\t\t\tt.either(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(v[i].first - v[j].second) < d) {\n\t\t\t\tt.either(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(v[i].second - v[j].second) < d) {\n\t\t\t\tt.either(i, false, j, false);\n\t\t\t}\n\t\t}\n\t}\n\tauto ans = t.solve();\n\tif (!ans.size()) {\n\t\tcout << \"No\";\n\t\treturn 0;\n\t}\n\tcout << \"Yes\" << endl;\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tif(ans[i]) cout << v[i].second << endl;\n\t\tif (!ans[i]) cout << v[i].first << endl;\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\n#define ll long long\n\n\nsigned main() {\n\tint N; ll D; cin >> N >> D;\n\tvector<ll>X(N), Y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\ttwo_sat ts(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tif (!ts.satisfiable()) {\n\t\tcout << \"No\" << endl; return 0;\n\t}\n\tcout << \"Yes\" << endl;\n\tauto ans = ts.answer();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (ans[i])cout << X[i] << endl;\n\t\telse cout << Y[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <iomanip>\n#include <cassert>\n#include <atcoder/twosat>\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\nint main()\n{\n   int N, D;\n   cin >> N >> D;\n   two_sat ts(N);\n   vector<pair<int, int>> v(N);\n   for (int i = 0; i < N; i++)\n   {\n      cin >> v[i].first >> v[i].second;\n   }\n   for (int i = 0; i < N; i++)\n   {\n      for (int j = i + 1; j < N; j++)\n      {\n\n         if (abs(v[i].first - v[j].first) < D)\n         {\n            ts.add_clause(i, false, j, false);\n         }\n         if (abs(v[i].second - v[j].second) < D)\n         {\n            ts.add_clause(i, true, j, true);\n         }\n\n         if (abs(v[i].first - v[j].second) < D)\n         {\n            ts.add_clause(i, false, j, true);\n         }\n         if (abs(v[i].second - v[j].first) < D)\n         {\n            ts.add_clause(i, true, j, false);\n         }\n      }\n   }\n   if (!ts.satisfiable())\n   {\n      cout << \"No\" << endl;\n      return 0;\n   }\n   else\n   {\n      cout << \"Yes\" << endl;\n      auto ans = ts.answer();\n      int i = 0;\n      for (int i = 0; i < ans.size(); i++)\n      {\n         cout << (ans[i] ? v[i].first : v[i].second) << endl;\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#pragma GCC diagnostic ignored \"-Wall\"\n#pragma GCC diagnostic ignored \"-Wextra\"\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\npublic:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\nprivate:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\nusing namespace atcoder;\n#pragma GCC diagnostic warning \"-Wall\"\n#pragma GCC diagnostic warning \"-Wextra\"\n#pragma GCC diagnostic warning \"-Wconversion\"\n#pragma GCC diagnostic warning \"-Wpedantic\"\n#include <bits/stdc++.h>\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) (((n) >> (k)) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int MOD = (int)1e9 + 7;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = true;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n//#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n\ntwo_sat ts;\nint N, D;\nint x[1010], y[1010];\n\nvoid solve() {\n    ts = two_sat{N};\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(x[i] - x[j]) < D)\n                ts.add_clause(i, false, j, false);\n            if (abs(x[i] - y[j]) < D)\n                ts.add_clause(i, false, j, true);\n            if (abs(y[i] - x[j]) < D)\n                ts.add_clause(i, true, j, false);\n            if (abs(y[i] - y[j]) < D)\n                ts.add_clause(i, true, j, true);\n        }\n    }\n    if (!ts.satisfiable()) {\n        No();\n        return;\n    }\n    Yes();\n\n    auto ans = ts.answer();\n    for (int i = 0; i < N; i++) {\n        cout << (ans[i] ? x[i] : y[i]) << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> D;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\n\nusing namespace std;\n#ifdef __DEBUG__\n    void debug_out() { cerr << endl; } \n    template <typename Head, typename... Tail>\n    void debug_out(Head H, Tail... T) {cerr << \" \" << H; debug_out(T...);}\n    #define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n    #define debug(...) \n#endif\n\nusing ll = long long int;\nusing pii = pair<int, int>;\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\n\nint N,D;\nvector<pii> X;\ninline void input(){\n    fast_io();\n    cin >> N >> D;\n    for (int i = 0; i < N; i++)\n    {\n        int x,y; cin >> x >> y;\n        X.emplace_back(x,y);\n    }\n}\n\ninline int solve(){\n    atcoder::two_sat ts(N);\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            if(abs(X[i].first-X[j].first)<D) ts.add_clause(i,true,j,!true);\n            if(abs(X[i].first-X[j].second)<D) ts.add_clause(i,true,j,!false);\n            if(abs(X[i].second-X[j].first)<D) ts.add_clause(i,false,j,!true);\n            if(abs(X[i].second-X[j].second)<D) ts.add_clause(i,false,j,!false);\n        }\n    }\n    cout << (ts.satisfiable() ? \"Yes\" : \"No\") << endl;\n    if(ts.satisfiable()){\n        auto ans = ts.answer();\n        for (int i = 0; i < N; i++)\n        {\n            if(ans[i]) cout << X[i].first << \"\\n\";\n            else cout << X[i].second << \"\\n\";\n        }\n    }\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n\tint n, d; cin >> n >> d;\n\ttwo_sat ts(n);\n\tvector<vector<int>> flags(n, vector<int>(2));\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> flags[i][0] >> flags[i][1];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i+1; j < n; ++j) {\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\tint f = k/2, g = k%2;\n\t\t\t\tif (abs(flags[i][f] - flags[j][g]) < d) {\n\t\t\t\t\tts.add_clause(i, f, j, g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!ts.satisfiable()) {\n\t\tcout << \"No\\n\";\n\t} else {\n\t\tcout << \"Yes\\n\";\n\t\tvector<bool> ans = ts.answer();\n\t\tfor (int i = 0; i < n; ++i) cout << flags[i][1^ans[i]] << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <numeric>\n#include <algorithm>\nusing namespace std;\n\n/*\n * @title StronglyConnectedComponents\n */\nclass StronglyConnectedComponents{\n\tint num,is_2sat,half,max_id;\n\tvector<vector<int>> edge,redge;\n\tvector<int> label,visited,order;\n\tinline void dfs(int curr){\n\t\tvisited[curr] = 1;\n\t\tfor(int next:edge[curr]) if(!visited[next]) dfs(next);\n\t\torder.push_back(curr);\n\t}\n\tinline void rdfs(int curr,int id){\n\t\tvisited[curr] = 1;\n\t\tlabel[curr] = id;\n\t\tfor(int next:redge[curr]) if(!visited[next]) rdfs(next,id);\n\t}\n\tinline int rev(int i) { return i < half ? i + half : i - half; }\npublic:\n\tStronglyConnectedComponents(const int n, bool is_2sat=0):num(n),max_id(0),is_2sat(is_2sat){\n\t\tif(is_2sat) num*=2;\n\t\tedge.resize(num);\n\t\tredge.resize(num);\n\t\tlabel.resize(num);\n\t\tvisited.resize(num);\n\t\thalf=num/2;\n\t}\n\tinline int operator[](int idx) {\n\t\treturn label[idx];\n\t}\n\tinline void make_edge(const int from,const int to) {\n\t\tedge[from].push_back(to);\n\t\tredge[to].push_back(from);\n\t}\n    //xがflg_xならばyがflg_y\n\tinline void make_condition(int x, bool flg_x, int y, bool flg_y) {\n\t\tif (!flg_x) x = rev(x);\n\t\tif (!flg_y) y = rev(y);\n\t\tmake_edge(x, y);\n\t\tmake_edge(rev(y), rev(x));\n\t}\n    //is_2sat=1のときに、2satを満たすかを返却する\n\tinline bool solve(void) {\n\t\tfor(int& e:visited) e = 0;\n\t\tfor(int i = 0; i < num; ++i) if(!visited[i]) dfs(i);\n\t\tfor(int& e:visited) e = 0;\n\t\treverse(order.begin(),order.end());\n\t\tfor(int i:order) if(!visited[i]) rdfs(i,max_id++);\n\t\tif(!is_2sat) return true;\n\t\tfor (int i = 0; i < num; ++i) if (label[i] == label[rev(i)]) return false;\n\t\treturn true;\n\t}\n    vector<vector<int>> topological_sort(void) {\n        vector<vector<int>> ret(max_id);\n        for(int i=0;i<num;++i) ret[label[i]].push_back(i);\n        return ret;\n    }\n\tint is_true(int i) {\n\t\treturn label[i] > label[rev(i)];\n\t}\n\tvoid print(void) {\n\t\tfor(auto id:label) cout << id << \" \";\n\t\tcout << endl;\n\t}\n};\n\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int N,M; cin >> N >> M;\n    StronglyConnectedComponents scc(N);\n    while(M--) {\n        int u,v; cin >> u >> v;\n        scc.make_edge(u,v);\n    }\n    scc.solve();\n    auto vv=scc.topological_sort();\n    cout << vv.size() << \"\\n\";\n    for(auto& v:vv) {\n        cout << v.size();\n        for(auto& e:v) cout << \" \" << e;\n        cout << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <atcoder/all>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\nusing namespace std;\nusing namespace atcoder;\n\nint main(){\n    int n,d;\n    cin >> n >> d;\n    two_sat ts(n);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n    }\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(abs(x[i]-x[j])<d){\n                ts.add_clause(i,false,j,false);\n            }\n            if(abs(y[i]-y[j]<d)){\n                ts.add_clause(i,true,j,true);\n            }\n            if(abs(x[i]-y[j])<d){\n                ts.add_clause(i,true,j,false);\n            }\n            if(abs(y[i]-x[j])<d){\n                ts.add_clause(i,false,j,true);\n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto ans=ts.answer();\n    rep(i,n){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <bits/stdc++.h>\nusing namespace atcoder;\nusing namespace std;\n\nint main()\n{\n\tint n, d;\n\tscanf(\"%d%d\", &n, &d);\n\ttwo_sat ts(n);\n\tint p[n][2];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", p[i], p[i]+1);\n\t}\n\tfor (int i = 0; i < n; ++i) for (int j = i+1; j < n; ++j) {\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tif (abs(p[i][k/2]-p[j][k%2]) < d) ts.add_clause(i, k/2, j, k%2);\n\t\t}\n\t}\n\tif (ts.satisfiable()) {\n\t\tputs(\"Yes\");\n\t\tauto ans = ts.answer();\n\t\tfor (int i = 0; i < n; ++i) printf(\"%d\\n\", p[i][!ans[i]]);\n\t}\n\telse {\n\t\tputs(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <charconv>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// #define USE_FREAD\n#ifdef USE_FREAD\nconstexpr size_t MAX_SIZE = 22020;\nchar buf[MAX_SIZE];\nstruct Input {\n\tsize_t i;\n\tInput() {\n\t\ti = 0;\n\t\tfread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\treturn buf[i++];\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void putui(int v) noexcept {\n\tchar buf[11]{};\n\tauto [ptr, e] = to_chars(begin(buf), end(buf), v);\n\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n}\ninline void putul(ll v) noexcept {\n\tchar buf[20]{};\n\tauto [ptr, e] = to_chars(begin(buf), end(buf), v);\n\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\n\n//StronglyConnectedCompoinent\nstruct scc_graph{\n    int n;\n    vector<vector<int>> graph;\n    vector<vector<int>> revgraph;\n    vector<int> postorder;\n    vector<int> seen;\n\n    scc_graph(int n):n(n),graph(n),revgraph(n),seen(n,-1){}\n\n    void add_edge(int from,int to){\n        graph[from].push_back(to);\n        revgraph[to].push_back(from);\n    }\n\n    vector<vector<int>> scc(){\n        fill(seen.begin(),seen.end(),-1);\n        for(int i=0;i<n;i++){\n            if(seen[i]<0) dfs(i);\n        }\n        fill(seen.begin(),seen.end(),-1);\n\n        int k = 0;\n        for(int i=(int)postorder.size()-1;i>=0;i--){\n            if(seen[postorder[i]]<0) revdfs(postorder[i],k++);\n        }\n\n        vector<vector<int>> scc_groups(k);\n        for(int i=0;i<n;i++){\n            scc_groups[seen[i]].push_back(i);\n        }\n\n        return scc_groups;\n    }\n\n    void dfs(int i){\n        seen[i] = 1;\n        for(int j:graph[i]){\n            if(seen[j]>=0) continue;\n            dfs(j);\n        }\n        postorder.push_back(i);\n    }\n\n    void revdfs(int i,int k){\n        seen[i] = k;\n        for(int j:revgraph[i]){\n            if(seen[j]>=0) continue;\n            revdfs(j,k);\n        }\n    }\n};\n\nstruct twosat{\n    int n;\n    scc_graph G;\n    vector<bool> answers;\n    twosat(int n):n(n),G(2*n),answers(n,false){}\n\n    void add_clause(int i,bool f,int j,bool g){\n        if(f&&g)  { G.add_edge(i+n,j); G.add_edge(j+n,i);  }\n        else if(g){ G.add_edge(i,j);   G.add_edge(j+n,i+n);}\n        else if(f){ G.add_edge(j,i);   G.add_edge(i+n,j+n);}\n        else      { G.add_edge(i,j+n); G.add_edge(j,i+n);  }\n    }\n\n    bool satisfable(){\n        G.scc();\n        rep(i,n){\n            if(G.seen[i] == G.seen[i+n]) return false;\n        }\n        rep(i,n){\n            if(G.seen[i] > G.seen[i+n]) answers[i] = true;\n        }\n        return true;\n    }\n\n    vector<bool> answer(){ return answers;}\n};\n\n\nint main(){\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    twosat ts(n);\n    rep(i,n)rep(j,i){\n        if(abs(x[i]-x[j])<d){\n            ts.add_clause(i,false,j,false);\n        }\n        if(abs(x[i]-y[j])<d){\n            ts.add_clause(i,false,j,true);\n        }\n        if(abs(y[i]-x[j])<d){\n            ts.add_clause(i,true,j,false);\n        }\n        if(abs(y[i]-y[j])<d){\n            ts.add_clause(i,true,j,true);\n        }\n    }\n\n    if(!ts.satisfable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n\n    for(int i=0;i<n;i++){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing H = pair<ll, ll>;\nusing P = pair<ll, H>;\nusing vi = vector<ll>;\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(ll i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define pb emplace_back\n#define siz(a) (int)(a).size()\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) (lower_bound(all(b),(i))-(b).begin())\n#define ssp(i,n) (i==(ll)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) for(int quetimes_=(n);quetimes_>0;quetimes_--)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n#define found(a,x) (a.find(x)!=a.end())\nconstexpr ll mod = (ll)1e9 + 7;\nconstexpr ll Mod = 998244353;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = (ll)3 * 1e18;\nconstexpr int Inf = (ll)15 * 1e8;\nconstexpr int dx[] = { -1,1,0,0 }, dy[] = { 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(short g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g == 1) u.fs--, u.sc--; if (g == 2) u.fs--; return u; }\nbool ina(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nbool ina(int t, int l, int r) { return l <= t && t < r; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll popcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\ntemplate<typename T>\nclass csum {\n    vec<T> v;\npublic:\n    csum(vec<T>& a) :v(a) { build(); }\n    csum() {}\n    void init(vec<T>& a) { v = a; build(); }\n    void build() {\n        for (int i = 1; i < v.size(); i++) v[i] += v[i - 1];\n    }\n    //[l,r]\n    T a(int l, int r) {\n        if (r < l) return 0;\n        return v[r] - (l == 0 ? 0 : v[l - 1]);\n    }\n    //[l,r)\n    T b(int l, int r) {\n        return a(l, r - 1);\n    }\n    T a(pair<int, int>t) {\n        return a(t.first, t.second);\n    }\n    T b(pair<int, int>t) {\n        return b(t.first, t.second);\n    }\n};\nclass mint {\npublic:ll v;\n      mint(ll v = 0) { s(v % mod + mod); }\n      constexpr static int mod = Mod;// (ll)1e9 + 7;\n      constexpr static int fn_ = (ll)2e6 + 5;\n      static mint fact[fn_], comp[fn_];\n      mint pow(int x) const {\n          mint b(v), c(1);\n          while (x) {\n              if (x & 1) c *= b;\n              b *= b;\n              x >>= 1;\n          }\n          return c;\n      }\n      inline mint& s(int vv) {\n          v = vv < mod ? vv : vv - mod;\n          return *this;\n      }\n      inline mint inv()const { return pow(mod - 2); }\n      inline mint operator-()const { return mint() - *this; }\n      inline mint& operator+=(const mint b) { return s(v + b.v); }\n      inline mint& operator-=(const mint b) { return s(v + mod - b.v); }\n      inline mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }\n      inline mint& operator/=(const mint b) { v = v * b.inv().v % mod; return *this; }\n      inline mint operator+(const mint b) const { return mint(v) += b; }\n      inline mint operator-(const mint b) const { return mint(v) -= b; }\n      inline mint operator*(const mint b) const { return mint(v) *= b; }\n      inline mint operator/(const mint b) const { return mint(v) /= b; }\n      friend ostream& operator<<(ostream& os, const mint& m) {\n          return os << m.v;\n      }\n      friend istream& operator>>(istream& is, mint& m) {\n          int x; is >> x; m = mint(x);\n          return is;\n      }\n      bool operator<(const mint& r)const { return v < r.v; }\n      bool operator>(const mint& r)const { return v > r.v; }\n      bool operator<=(const mint& r)const { return v <= r.v; }\n      bool operator>=(const mint& r)const { return v >= r.v; }\n      bool operator==(const mint& r)const { return v == r.v; }\n      bool operator!=(const mint& r)const { return v != r.v; }\n      explicit operator bool()const { return v; }\n      explicit operator int()const { return v; }\n      mint comb(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              if (k > * this - k) k = *this - k;\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp * comp[k.v];\n          }\n          return fact[v] * comp[k.v] * comp[v - k.v];\n      }//nCk\n      mint perm(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp;\n          }\n          return fact[v] * comp[v - k.v];\n      }//nPk\n      static void combinit() {\n          fact[0] = 1;\n          for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);\n          comp[fn_ - 1] = fact[fn_ - 1].inv();\n          for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);\n      }\n}; mint mint::fact[fn_], mint::comp[fn_];\n\n//--------------------------------------------------------------\n//--------------------------------------------------------------\n\n#include<atcoder/all>\nusing namespace atcoder;\n\nsigned main() {\n    int n, d; cin >> n >> d;\n    vi x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n    two_sat ts(n);\n    rep(i, n)rng(j, i + 1, n) {\n        if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n        if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n        if (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n        if (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n    }\n    if (!ts.satisfiable()) {\n        cno; return 0;\n    }\n    cyes;\n    auto ans = ts.answer();\n    rep(i, n) {\n        if (ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cassert>\n#include <atcoder/all>\n#define InfL 2000000000\n#define InfLL 4000000000000000000LL\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=(n-1);i>=0;i--)\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<db> vd;\n\nint main() {\n\tint N, D;\n\tcin >> N >> D;\n\tvector<vi> P(N);\n\trep(i, N) {\n\t\tP[i].resize(2);\n\t\tcin >> P[i][0] >> P[i][1];\n\t}\n\ttwo_sat ts(N);\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif (i >= j)\n\t\t\t\tcontinue;\n\t\t\trep(bi, 2) {\n\t\t\t\trep(bj, 2) {\n\t\t\t\t\tif (abs(P[i][bi] - P[j][bj]) < D)\n\t\t\t\t\t\tts.add_clause(i, !bi, j, !bj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstring ans = ts.satisfiable() ? \"Yes\" : \"No\";\n\tcout << ans << endl;\n\tif (ans == \"Yes\") {\n\t\tvb anslist = ts.answer();\n\t\trep(i, N)\n\t\t\tcout << P[i][anslist[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <cassert>\n#include <atcoder/all>\nusing namespace std;\n#define fast_io ios_base::sync_with_stdio (false) ; cin.tie(0) ; cout.tie(0) ;\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define MOD (long long int)(1e9+7)\n#define INF (int)(1e9)\n#define LINF (long long int)(1e18)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  if(n <= 1e7){\n    ret *= kaijo(n); ret %= MOD;\n    ret *= gyaku_kaijo(r); ret %= MOD;\n    ret *= gyaku_kaijo(n-r); ret %= MOD;\n  }else{\n    rep(i,r){\n      ret *= n-i; ret %= MOD;\n      ret *= mpow(r-i, MOD-2); ret %= MOD;\n    }\n  }\n  return ret;\n}\n\nvector<ll> yakusu(ll n){\n  vector<ll> ret;\n  for(ll p = 1; p*p <= n; p++){\n    if(n%p == 0){\n      ret.push_back(p);\n      if(p*p != n){\n        ret.push_back(n/p);\n      }\n    }\n  }\n  sort(all(ret));\n  return ret;\n}\n\nint main(void){\n  fast_io\n  cout<<fixed<<setprecision(15);\n\n  ll n,d;\n  cin>>n>>d;\n  atcoder::two_sat ts(n*2);\n  vector<ll> X(2*n), Y(n);\n  rep(i,n){\n    ll x,y;cin>>x>>y;\n    X[i] = x;\n    Y[i] = y;\n    ts.add_clause(i, true, i+n, true);\n    ts.add_clause(i, false, i+n, false);\n  }\n  rep(i,n){\n    X[i+n] = Y[i];\n  }\n  rep(i,2*n){\n    rep(j,2*n){\n      if(i>=j) continue;\n      if(abs(X[i]-X[j]) < d){\n        ts.add_clause(i,false,j,false);\n      }\n    }\n  }\n  bool sat = ts.satisfiable();\n  if(!sat){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  auto result = ts.answer();\n  rep(i,n){\n    if(result[i]){\n      cout<<X[i]<<endl;\n    }else{\n      cout<<X[i+n]<<endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\n#define REP(i, init, n) for(int i = (int)(init); i < (int)(n); i++)\n\n#define vi vector<int>\n#define vl vector<long>\n#define vvi vector<vector<int>>\n#define vvl vector<vector<long>>\n#define pint pair<int, int>\n#define plong pair<long, long>\n\nint main() {\n    int N, D;\n    cin>> N >> D;\n    vector<plong> P(N); \n    two_sat ts(N);\n    REP(i, 0, N){\n        int x, y;\n        cin >> x >> y;\n        P[i] = {x, y};\n    }\n    REP(i, 0, N){\n        REP(j, i + 1, N){\n            if(abs(P[i].first - P[j].first) < D){\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(P[i].first - P[j].second) < D){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(P[i].second - P[j].first) < D){\n                ts.add_clause(i, true, j, false);  \n            }\n            if(abs(P[i].second - P[j].second) < D){\n                ts.add_clause(i, true, j, true);    \n            }\n        }\n    }\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n    REP(i, 0, N){\n        if(ans[i]){\n            cout << P[i].first << endl;\n        }else{\n            cout << P[i].second << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"atcoder/all\"\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 2147483647 / 2;\nconst long long int llINF = 9223372036854775807 / 2;\n\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VV(T, a, b, c) vector<vector<T>>(a, vector<T>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define VVV(T, a, b, c, d)                                                     \\\n  vector<vector<vector<T>>>(a, vector<vector<T>>(b, vector<T>(c, d)))\n#define SP(a) fixed << setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ll N, D;\n  cin >> N >> D;\n  vl X(N), Y(N);\n  REP(i, N) cin >> X[i] >> Y[i];\n  two_sat ts(N);\n\n  REP(i, N) FOR(j, i + 1, N) {\n    if (abs(X[i] - X[j]) < D)\n      ts.add_clause(i, false, j, false);\n    if (abs(X[i] - Y[j]) < D)\n      ts.add_clause(i, false, j, true);\n    if (abs(Y[i] - X[j]) < D)\n      ts.add_clause(i, true, j, false);\n    if (abs(Y[i] - Y[j]) < D)\n      ts.add_clause(i, true, j, true);\n  }\n  if (!ts.satisfiable()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  auto answer = ts.answer();\n  REP(i, N) {\n    if (answer[i])\n      cout << X[i] << endl;\n    else\n      cout << Y[i] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<atcoder/twosat.hpp>\nusing namespace atcoder;\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<ll, ll, ll>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n// ============ template finished ============\n\nusing Clauses = vector<tuple<int, bool, int, bool>>;\nClauses make_clauses(const vector<pair<int, int>>& XY, const int D) {\n    vector<int> poss;\n    Clauses clauses;\n    for (const auto[X, Y] : XY) {\n        clauses.push_back(make_tuple(X, true, Y, true));\n        poss.push_back(X);\n        poss.push_back(Y);\n    }\n    rep(rIdx, poss.size())rep(lIdx, rIdx) {\n        int l = poss[lIdx], r = poss[rIdx];\n        if (abs(l - r) < D) {\n            clauses.push_back(make_tuple(l, false, r, false));\n        }\n    }\n    return clauses;\n}\n\nmap<int, int> make_parser(const set<int>& st) {\n    map<int, int> parser;\n    int count = 0;\n    for (const int num : st) {\n        parser[num] = count;\n        count++;\n    }\n    return parser;\n}\n\nmap<int, int> make_reverser(const map<int, int>& parser) {\n    map<int, int> reverser;\n    for (const auto[l, r] : parser)reverser[r] = l;\n    return reverser;\n}\n\nmap<int, int> compress(Clauses& clauses) {\n    set<int> vals;\n    for (const auto&[i, f, j, g] : clauses) {\n        vals.insert(i);\n        vals.insert(j);\n    }\n    auto parser = make_parser(vals);\n    auto reverser = make_reverser(parser);\n    for (auto&[i, f, j, g] : clauses) {\n        i = parser[i];\n        j = parser[j];\n    }\n    return reverser;\n}\n\nvector<int> act_two_sat(const Clauses& clauses, const map<int, int>& reverser) {\n    const int size = reverser.size();\n    two_sat ts(size);\n    for (const auto&[i, f, j, g] : clauses) {\n        ts.add_clause(i, f, j, g);\n    }\n    if (!ts.satisfiable()) {\n        return {};\n    }\n    auto bools = ts.answer();\n    vector<int> flags;\n    rep(i, size)if (bools[i])flags.push_back(reverser.at(i));\n    return flags;\n}\n\nint main()\n{\n    int N, D;\n    cin >> N >> D;\n    vector<pair<int, int>> XY(N);\n    rep(i, N)cin >> XY[i].first >> XY[i].second;\n\n    auto clauses = make_clauses(XY, D);\n    auto reverser = compress(clauses);\n    auto flags = act_two_sat(clauses, reverser);\n\n    if (flags.empty()) {\n        cout << \"No\" << endl;\n    }\n    else {\n        cout << \"Yes\" << endl;\n        for (auto flag : flags) {\n            cout << flag << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <cstddef>\n#include <algorithm>\n\nstruct strongly_connected_component {\n\tusing size_type = std::size_t;\nprivate :\n\tsize_type num;\n\tstd::vector<std::vector<size_type>> g, scc;\n\tstd::vector<size_type> low, order, index;\n\tstd::vector<bool> instack;\n\tstd::stack<size_type> sta;\n\n\tvoid chmin (size_type &a, const size_type &b) noexcept {\n\t\tif (a > b) a = b;\n\t}\n\n\tvoid dfs (size_type v) noexcept {\n\t\tlow[v] = order[v] = ++num;\n\t\tsta.push(v); instack[v] = true;\n\t\tfor (const size_type &u : g[v]) {\n\t\t\tif (order[u] == 0) {\n\t\t\t\tdfs(u);\n\t\t\t\tchmin(low[v], low[u]);\n\t\t\t} else if (instack[u]) {\n\t\t\t\tchmin(low[v], order[u]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == order[v]) {\n\t\t\tscc.push_back(std::vector<size_type>());\n\t\t\twhile (true) {\n\t\t\t\tconst size_type u = sta.top();\n\t\t\t\tsta.pop(); instack[u] = false;\n\t\t\t\tscc.back().push_back(u);\n\t\t\t\tif (u == v) break;\n\t\t\t}\n\t\t}\n\t}\n\npublic :\n\texplicit strongly_connected_component (size_type n)\n\tnoexcept : num(0), g(n), scc(), low(n, 0), order(n, 0), index(n), instack(n, false), sta() { }\n\n\tvoid add_edge (size_type v, size_type u) noexcept {\n\t\tg[v].push_back(u);\n\t}\n\n\tsize_type solve () noexcept {\n\t\tfor (size_type v = 0; v < g.size(); v++) if (not order[v]) dfs(v);\n\t\tstd::reverse(scc.begin(), scc.end());\n\t\tfor (size_type i = 0; i < scc.size(); i++) {\n\t\t\tfor (const size_type &v : scc[i]) index[v] = i;\n\t\t}\n\t\treturn scc.size();\n\t}\n\n\tconst std::vector<std::vector<size_type>> &get_scc () const noexcept {\n\t\treturn scc;\n\t}\n\n\tsize_type size () const noexcept {\n\t\treturn scc.size();\n\t}\n\n\tconst size_type &operator[] (size_type v) const noexcept {\n\t\treturn index[v];\n\t}\n\n};\n\n\n#include <vector>\n#include <cstddef>\n\nstruct two_sat {\n\tusing size_type = std::size_t;\nprivate :\n\tstrongly_connected_component scc;\n\tstd::vector<bool> answer;\n\npublic :\n\ttwo_sat (size_type n) noexcept : scc(n << 1), answer(n) { }\n\n\tvoid add_clause (size_type a, bool f, size_type b, bool g) noexcept {\n\t\tscc.add_edge(a << 1 | not f, b << 1 | g);\n\t\tscc.add_edge(b << 1 | not g, a << 1 | f);\n\t}\n\n\tbool satisfiable () noexcept {\n\t\tscc.solve();\n\t\tfor (size_type i = 0; i < answer.size(); i++) {\n\t\t\tif (scc[i << 1 | 0] == scc[i << 1 | 1]) return false;\n\t\t\tanswer[i] = (scc[i << 1 | 0] < scc[i << 1 | 1]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool get (const size_type i) const noexcept {\n\t\treturn answer[i];\n\t}\n\n};\n\n\n\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\tint n, d;\n\tstd::cin >> n >> d;\n\tstd::vector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> x[i] >> y[i];\n\t}\n\t\n\ttwo_sat sat(n);\n\t\n\tauto f = [&] (int a, int b) {\n\t\treturn std::abs(a - b) < d;\n\t};\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (f(x[i], x[j])) sat.add_clause(i, 1, j, 1);\n\t\t\tif (f(x[i], y[j])) sat.add_clause(i, 1, j, 0);\n\t\t\tif (f(y[i], x[j])) sat.add_clause(i, 0, j, 1);\n\t\t\tif (f(y[i], y[j])) sat.add_clause(i, 0, j, 0);\n\t\t}\n\t}\n\t\n\tif (sat.satisfiable()) {\n\t\tstd::cout << \"Yes\" << '\\n';\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::cout << (sat.get(i) ? y[i] : x[i]) << '\\n';\n\t\t}\n\t} else {\n\t\tstd::cout << \"No\" << '\\n';\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n\nint main() {\n\tint n, d; cin >> n >> d;\n\ttwo_sat ts(n);\n\tint x[n], y[n];\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\t// (x, y) := (true, false)\n\t// not (x and y) <=> (not x) or (not y)\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(abs(x[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif(abs(x[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif(abs(y[i] - x[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif(abs(y[i] - y[j]) < d) {\n\t\t\t\tts.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tif(ts.satisfiable()) {\n\t\tcout << \"Yes\" << '\\n';\n\t\tauto v = ts.answer();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcout << (v[i] ? x[i] : y[i]) << '\\n';\n\t\t}\n\t} else {\n\t\tcout << \"No\" << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\nusing namespace atcoder;\n// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) begin(x), end(x)\n#define allR(x) rbegin(x), rend(x)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\ni64 irand(i64 a, i64 b) { return rand<i64>(a,b); }\nu64 urand(u64 a, u64 b) { return rand<u64>(a,b); }\n// <<<\n\nint32_t main() {\n    int n,d; cin >> n >> d;\n    auto x = make_v<int,2>(2,n);\n    rep (i,n) rep (j,2) cin >> x[j][i];\n\n    two_sat ts(n);\n    rep (i,n) rep (j,n) if (i < j) {\n        rep (a,2) rep (b,2) {\n            if (abs(x[a][i]-x[b][j]) < d) {\n                ts.add_clause(i,a^1,j,b^1);\n            }\n        }\n    }\n\n    if (not ts.satisfiable()) quit(\"No\");\n\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    rep (i,n) cout << x[ans[i]][i] << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//By TheOneYouWant\n#pragma GCC optimize (\"-O2\")\n#include <bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define memreset(a) memset(a,0,sizeof(a))\n#define testcase(t) int t;cin>>t;while(t--)\n#define forstl(i,v) for(auto &i: v)\n#define forn(i,e) for(int i=0;i<e;++i)\n#define forsn(i,s,e) for(int i=s;i<e;++i)\n#define rforn(i,s) for(int i=s;i>=0;--i)\n#define rforsn(i,s,e) for(int i=s;i>=e;--i)\n#define bitcount(a) __builtin_popcount(a) // set bits (add ll)\n#define ln '\\n'\n#define getcurrtime() cerr<<\"Time = \"<<((double)clock()/CLOCKS_PER_SEC)<<endl\n#define dbgarr(v,s,e) cerr<<#v<<\" = \"; forsn(i,s,e) cerr<<v[i]<<\", \"; cerr<<endl\n#define inputfile freopen(\"input.txt\", \"r\", stdin)\n#define outputfile freopen(\"output.txt\", \"w\", stdout)\n#define dbg(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) { cerr<<endl; }\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \" = \" << a << \"\\t\"; err(++it, args...);\n}\ntemplate<typename T1,typename T2>\nostream& operator <<(ostream& c,pair<T1,T2> &v){\n\tc<<\"(\"<<v.fi<<\",\"<<v.se<<\")\"; return c;\n}\ntemplate <template <class...> class TT, class ...T>\nostream& operator<<(ostream& out,TT<T...>& c){\n    out<<\"{ \";\n    forstl(x,c) out<<x<<\" \";\n    out<<\"}\"; return out;\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> p64;\ntypedef pair<int,int> p32;\ntypedef pair<int,p32> p96;\ntypedef vector<ll> v64;\ntypedef vector<int> v32; \ntypedef vector<v32> vv32;\ntypedef vector<v64> vv64;\ntypedef vector<p32> vp32;\ntypedef vector<p64> vp64;\ntypedef vector<vp32> vvp32;\ntypedef map<int,int> m32;\nconst int LIM=2e5+5,MOD=1e9+7;\nconst ld EPS = 1e-9;\n\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=(xx<<3)+(xx<<1)+ch-'0';ch=getchar();}\n    return xx*ff;\n}\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nusing mint = modint;\n\nint main(){\n\tfastio;\n\tmint::set_mod(MOD);\n\n\tint n, d; cin>>n>>d;\n\tll x[n], y[n];\n\tforn(i,n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\ttwo_sat ts(2*n);\n\tforn(i,n){\n\t\tts.add_clause(2*i,1,2*i+1,1);\n\t}\n\tforn(i,n){\n\t\tforn(j,i){\n\t\t\tforn(l,2){\n\t\t\t\tforn(k,2){\n\t\t\t\t\tint pos1 = x[i];\n\t\t\t\t\tif(l == 1) pos1 = y[i];\n\t\t\t\t\tint pos2 = x[j];\n\t\t\t\t\tif(k == 1) pos2 = y[j];\n\t\t\t\t\tif(abs(pos1-pos2)<d){\n\t\t\t\t\t\tts.add_clause(2*i+l,0,2*j+k,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ts.satisfiable()){\n\t\tcout<<\"Yes\"<<ln;\n\t\tvector<bool> v = ts.answer();\n\t\tforn(i,n){\n\t\t\tif(v[2*i]){\n\t\t\t\tcout<<x[i]<<ln;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<y[i]<<ln;\n\t\t\t}\n\t\t}\n\t}\n\telse cout<<\"No\"<<ln;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\n#define ll long long\n#define ld long double\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define repo(i,n) for(int i = 1; i < (int)(n); i++)\n#define pb push_back\n#define mp make_pair\n#define np next_permutation\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n#define uniq(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define lb(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define ub(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\nusing Pair = pair<ll,pair<int,int>>;\n#define pq priority_queue<Pair, vector<Pair>, greater<Pair>> \nconst ll mod=1000000007;\n//const ll mod=998244353;\nconst ld pi=acos(-1.0);\nconst ll INF = 1LL<<61;\ntemplate<class T>bool chmax(T &a, const T &b) { \n  if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) {\n  if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\n//intの最大値2147483647 ≒ 2×10^9\n//long longの最大値9223372036854775807 ≒ 9×10^18\n//'大文字'+=32;    で小文字に\n//  cout << fixed << setprecision (20);   小数点以下2０桁まで\n//実行時間制約2秒では２×10^8回くらいまで計算できる\n\n\n\n\n//——————————————————Atcoder Library———————————————————\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    // @return m\n    unsigned int umod() const { return _m; }\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  // namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}  // namespace internal\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}  // namespace atcoder\n#endif  // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);    \n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n}  // namespace atcoder\n#endif  // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;  \n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}  // namespace atcoder\n#endif  // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}  // namespace atcoder\n#endif  // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}  // namespace atcoder\n#endif  // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}  // namespace internal\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n}  // namespace atcoder\n#endif  // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n\nusing namespace atcoder;\n\n//——————————————————Atcoder Library———————————————————\n\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  ll d;\n  cin>>n>>d;\n\n  two_sat ts(n);\n\n  vector<ll> p(n);\n  vector<ll> q(n);\n  rep(i,n){\n    cin>>p[i]>>q[i];\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i>=j) continue;\n      if(abs(p[i]-p[j])<d) ts.add_clause(i,false,j,false);\n      if(abs(p[i]-q[j])<d) ts.add_clause(i,false,j,true);\n      if(abs(q[i]-p[j])<d) ts.add_clause(i,true,j,false);\n      if(abs(q[i]-q[j])<d) ts.add_clause(i,true,j,true);\n    }\n  }\n\n  if(!ts.satisfiable()){\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  cout << \"Yes\" << endl;\n  vector<bool> ans=ts.answer();\n  rep(i,n){\n    if(ans[i]) cout << p[i] << endl;\n    else cout << q[i] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    // @return m\n    unsigned int umod() const { return _m; }\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_MATH_HPP\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_SCC_HPP\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}  // namespace internal\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}  // namespace internal\n}  // namespace atcoder\n#endif  // ATCODER_MODINT_HPP\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}  // namespace internal\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}  // namespace atcoder\n#endif  // ATCODER_CONVOLUTION_HPP\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);    \n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n}  // namespace atcoder\n#endif  // ATCODER_DSU_HPP\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_FENWICKTREE_HPP\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}  // namespace atcoder\n#endif  // ATCODER_LAZYSEGTREE_HPP\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;  \n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}  // namespace atcoder\n#endif  // ATCODER_MATH_HPP\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MAXFLOW_HPP\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}  // namespace atcoder\n#endif  // ATCODER_MINCOSTFLOW_HPP\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}  // namespace atcoder\n#endif  // ATCODER_SCC_HPP\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}  // namespace atcoder\n#endif  // ATCODER_SEGTREE_HPP\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}  // namespace internal\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n}  // namespace atcoder\n#endif  // ATCODER_STRING_HPP\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}  // namespace atcoder\n#endif  // ATCODER_TWOSAT_HPP\n\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <bitset>\n\nusing namespace atcoder;\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 998244353;\nconst ll inf = 1000000000;\n\n/*\n0 = X側に置く\n1 = Y側に置く\nとすれば、いい感じにtwo-satに落とし込める\n*/\n\nint main(){\n\n    int N,D;\n    cin >> N >> D;\n\n    vector<vector<int>> XY(N,vector<int> (2));\n    rep(i,0,N){\n        cin >> XY[i][0] >> XY[i][1];\n    }\n\n    two_sat ts = two_sat(N);\n\n    rep(i,0,N){\n        rep(j,0,i){\n            if (abs(XY[i][0]-XY[j][0]) < D) ts.add_clause(i,true,j,true);\n            if (abs(XY[i][0]-XY[j][1]) < D) ts.add_clause(i,true,j,false);\n            if (abs(XY[i][1]-XY[j][0]) < D) ts.add_clause(i,false,j,true);\n            if (abs(XY[i][1]-XY[j][1]) < D) ts.add_clause(i,false,j,false);\n        }\n    }\n\n    bool YN = ts.satisfiable();\n    if (YN){\n        cout << \"Yes\" << '\\n';\n        auto ans = ts.answer();\n        rep(i,0,N){\n            if (ans[i]) cout << XY[i][1] << '\\n';\n            else cout << XY[i][0] << '\\n';\n        }\n    }else{\n        cout << \"No\" << '\\n';\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n\n// 型定義\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n// forループ\n#define REP(i,n) for(ll i=0; i<(ll)(n); ++i)\n\n// 定数宣言\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// グラフ表現\nusing Graph = vector<vector<int>>;\n\n// グラフの辺表現\nusing Edge = map<pair<int,int>,int>;\n\n// n次元配列の初期化。第２引数の型のサイズごとに初期化していく。\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// 最大公約数\nll gcd(ll a,ll b){\n   if (a%b == 0) return(b);\n   else return(gcd(b, a%b));\n}\n\n// 最小公倍数\nll lcm(ll a, ll b){\n    return a/gcd(a, b) * b;\n}\n\nint main()\n{\n    cout << fixed << setprecision(15);\n    ll N, D;\n    cin >> N >> D;\n\n    vector<ll> X(N);\n    vector<ll> Y(N);\n\n    REP(i, N){\n        cin >> X[i] >> Y[i];\n    }\n\n    two_sat ts(N);\n\n    for(ll i=0; i<N; i++){\n        for(ll j=i+1; j<N; j++){\n            \n            // x同士を選んでは行けないとき\n            if(abs(X[i] - X[j]) < D){\n                // iかjのいずれかはfalseをとらなくてはならない\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(Y[i] - Y[j]) < D){\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if(ts.satisfiable()){\n        cout << \"Yes\" << endl;\n        auto ans = ts.answer();\n        ll count = 0;\n        for(auto a: ans){\n            // cout << a << endl;\n            if(a) cout << X[count] << endl;\n            else cout << Y[count] << endl;\n            count++;\n        }\n    }\n    else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_SCC_HPP\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_TWOSAT_HPP\n\n#include <boost/hana/functional/fix.hpp>\n\ntemplate <typename T, typename = void>\nstruct is_iterable : std::false_type {};\ntemplate <typename T>\nstruct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),\n                                  decltype(std::end(std::declval<T>()))>>\n    : std::true_type {};\n\ntemplate <typename T, typename = void>\nstruct is_pair : std::false_type {};\ntemplate <typename T>\nstruct is_pair<T, std::void_t<decltype(std::declval<T>().first),\n                              decltype(std::declval<T>().second)>>\n    : std::true_type {};\n\ntemplate <typename T>\nvoid debug(const T& v) {\n  if constexpr (is_pair<T>::value) {\n    std::cerr << \"{\";\n    debug(v.first);\n    std::cerr << \", \";\n    debug(v.second);\n    std::cerr << \"}\";\n  } else if constexpr (is_iterable<T>::value &&\n                       !std::is_same<T, std::string>::value) {\n    std::cerr << \"{\";\n    for (auto it = std::begin(v); it != std::end(v); ++it) {\n      if (it != std::begin(v)) std::cerr << \", \";\n      debug(*it);\n    }\n    std::cerr << \"}\";\n  } else {\n    std::cerr << v;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid debug(const T& value, const Ts&... args) {\n  debug(value);\n  std::cerr << \", \";\n  debug(args...);\n}\n#if DEBUG\n#define dbg(...)                        \\\n  do {                                  \\\n    cerr << #__VA_ARGS__ << \": \";       \\\n    debug(__VA_ARGS__);                 \\\n    cerr << \" (L\" << __LINE__ << \")\\n\"; \\\n  } while (0)\n#else\n#define dbg(...)\n#endif\n\nvoid read_from_cin() {}\ntemplate <typename T, typename... Ts>\nvoid read_from_cin(T& value, Ts&... args) {\n  std::cin >> value;\n  read_from_cin(args...);\n}\n#define rd(type, ...) \\\n  type __VA_ARGS__;   \\\n  read_from_cin(__VA_ARGS__);\n#define ints(...) rd(int, __VA_ARGS__);\n#define strings(...) rd(string, __VA_ARGS__);\n\ntemplate <typename T>\nvoid write_to_cout(const T& value) {\n  if constexpr (std::is_same<T, bool>::value) {\n    std::cout << (value ? \"Yes\" : \"No\");\n  } else {\n    std::cout << value;\n  }\n}\ntemplate <typename T, typename... Ts>\nvoid write_to_cout(const T& value, const Ts&... args) {\n  write_to_cout(value);\n  std::cout << ' ';\n  write_to_cout(args...);\n}\n#define wt(...)                 \\\n  do {                          \\\n    write_to_cout(__VA_ARGS__); \\\n    cout << '\\n';               \\\n  } while (0)\n\n#define all(x) (x).begin(), (x).end()\n\n#define rep_dispatch(_1, _2, _3, name, ...) name\n\n#define rep3(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep1(n) rep2(_loop_variable_, n)\n#define rep(...) rep_dispatch(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)\n\n#define rrep3(i, a, b) for (int i = (int)(b)-1; i >= a; --i)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep1(n) rrep2(_loop_variable_, n)\n#define rrep(...) rep_dispatch(__VA_ARGS__, rrep3, rrep2, rrep1)(__VA_ARGS__)\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n  for (T& vi : v) is >> vi;\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T, typename U>\nbool chmax(T& a, U b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nbool chmin(T& a, U b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T, typename U>\nT max(T a, U b) {\n  return a > b ? a : b;\n}\n\ntemplate <typename T, typename U>\nT mix(T a, U b) {\n  return a < b ? a : b;\n}\n\ntemplate <typename T>\nint sz(const T& v) {\n  return v.size();\n}\n\ntemplate <typename T>\nint popcount(T i) {\n  return std::bitset<std::numeric_limits<T>::digits>(i).count();\n}\n\nusing i64 = std::int64_t;\nusing i32 = std::int32_t;\n\ntemplate <typename T>\nusing low_priority_queue =\n    std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <typename T>\nusing V = std::vector<T>;\ntemplate <typename T>\nusing VV = V<V<T>>;\n\nvoid Main();\n\nint main() {\n  Main();\n  return 0;\n}\n\nconst auto& Fix = boost::hana::fix;\n\nusing namespace std;\n\n#define int i64\n\nvoid Main() {\n  ints(n, d);\n  V<int> x(n), y(n);\n  rep(i, n) cin >> x[i] >> y[i];\n\n  atcoder::two_sat ts(n);\n  rep(i, n - 1) rep(j, i + 1, n) {\n    if (abs(x[i] - x[j]) < d) ts.add_clause(i, false, j, false);\n    if (abs(x[i] - y[j]) < d) ts.add_clause(i, false, j, true);\n    if (abs(y[i] - x[j]) < d) ts.add_clause(i, true, j, false);\n    if (abs(y[i] - y[j]) < d) ts.add_clause(i, true, j, true);\n  }\n\n  bool ok = ts.satisfiable();\n  wt(ok);\n  if (ok) {\n    V<bool> ans = ts.answer();\n    rep(i, n) wt((ans[i] ? x : y)[i]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\n#define debug_value(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << #x << \"=\" << x << endl;\n#define debug(x) cerr << \"line\" << __LINE__ << \":<\" << __func__ << \">:\" << x << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N_MAX = 200000;\nint N;\nbool used[N_MAX];\nint idx[N_MAX];\nvector<int> vs;\nvector<int> buf;\nvector<int> G[N_MAX];\nvector<int> G_inv[N_MAX];\nvector<vector<int>> ans;\n\nvoid clear(){\n    for(int i = 0; i < N; i++) used[i] = false;\n}\n\nvoid dfs1(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        if(!used[G[v][i]]) dfs1(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid dfs2(int v, int k){\n    used[v] = true;\n    idx[v] = k;\n    for(int i = 0; i < G_inv[v].size(); i++){\n        if(!used[G_inv[v][i]]) dfs2(G_inv[v][i], k);\n    }\n    buf.push_back(v);\n}\n\nvoid scc(){\n    for(int i = 0; i < N; i++){\n        if(!used[i]) dfs1(i);\n    }\n    clear();\n    int cur = 0;\n    for(int i = vs.size()-1; i >= 0; i--){\n        if(!used[vs[i]]) {\n            dfs2(vs[i], cur);\n            cur++;\n            ans.push_back(buf);\n            buf.clear();\n        }\n    }\n}\n\nll X[1000], Y[1000];\nll D;\n\nint scc_idx[2000];\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int n; cin >> n >> D;\n    N = 2*n;\n    for(int i = 0; i < n; i++) cin >> X[i] >> Y[i];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == j) continue;\n            ll d1 = abs(X[i]-X[j]);\n            ll d2 = abs(X[i]-Y[j]);\n            \n            if(d1 < D && d2 < D) {\n                G[i].push_back(n+i);\n                G_inv[n+i].push_back(i);\n            }else if(d1 < D){\n                G[i].push_back(j+n);\n                G_inv[j+n].push_back(i);\n            }else if(d2 < D){\n                G[i].push_back(j);\n                G_inv[j].push_back(i);\n            }\n\n            ll d3 = abs(Y[i]-X[j]);\n            ll d4 = abs(Y[i]-Y[j]);\n            if(d3 < D && d4 < D) {\n                G[n+i].push_back(i);\n                G_inv[i].push_back(n+i);\n            }else if(d3 < D){\n                G[n+i].push_back(j+n);\n                G_inv[j+n].push_back(n+i);\n            }else if(d4 < D){\n                G[n+i].push_back(j);\n                G_inv[j].push_back(n+i);\n            }\n        }\n    }\n    scc();\n    for(int idx = 0; idx < ans.size(); idx++){\n        for(int i : ans[idx]){\n            scc_idx[i] = idx;\n            cout << i << ' ';\n        }\n        cout << endl;\n    }\n    for(int i = 0; i < n; i++){\n        if(scc_idx[i] == scc_idx[i+n]){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    for(int i = 0; i < n; i++){\n        if(scc_idx[i] < scc_idx[i+n]){\n            cout << Y[i] << endl;\n        }else{\n            cout << X[i] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\nnamespace Ruby {\n\ttemplate <class F> struct Callable {\n\t\tF func;\n\t\tCallable(const F& f) : func(f) {}\n\t};\n\ttemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\t\treturn c.func(v);\n\t}\n\n\tstruct Sort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(begin(v), end(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Sort;\n\tstruct RSort_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\t\tsort(rbegin(v), rend(v));\n\t\t\treturn v;\n\t\t}\n\t} RSort;\n\tstruct Reverse_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\t\treverse(begin(v), end(v));\n\t\t\treturn v;\n\t\t}\n\t} Reverse;\n\tstruct Unique_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Unique;\n\tstruct Uniq_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\t\tsort(begin(v), end(v));\n\t\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\t\treturn v;\n\t\t}\n\t} Uniq;\n\tstruct Rotate_impl {\n\t\ttemplate <class F> auto operator()(int left) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} Rotate;\n\tstruct Max_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\t\treturn *max_element(begin(v), end(v));\n\t\t}\n\t} Max;\n\tstruct Min_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\t\treturn *min_element(begin(v), end(v));\n\t\t}\n\t} Min;\n\tstruct MaxPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MaxPos;\n\tstruct MinPos_impl {\n\t\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t\t}\n\t} MinPos;\n\tstruct MaxBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_it = begin(v);\n\t\t\t\tauto max_val = f(*max_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_it = it;\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *max_it;\n\t\t\t});\n\t\t}\n\t} MaxBy;\n\tstruct MinBy_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_it = begin(v);\n\t\t\t\tauto min_val = f(*min_it);\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_it = it;\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *min_it;\n\t\t\t});\n\t\t}\n\t} MinBy;\n\tstruct MaxOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto max_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max_val;\n\t\t\t});\n\t\t}\n\t} MaxOf;\n\tstruct MinOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tauto min_val = f(*begin(v));\n\t\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\t\tmin_val = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn min_val;\n\t\t\t});\n\t\t}\n\t} MinOf;\n\tstruct Count_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count(begin(v), end(v), val);\n\t\t\t});\n\t\t}\n\t} Count;\n\tstruct CountIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn count_if(begin(v), end(v), f);\n\t\t\t});\n\t\t}\n\t} CountIf;\n\tstruct Index_impl {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} Index;\n\tstruct IndexIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t\t});\n\t\t}\n\t} IndexIf;\n\tstruct FindIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t\t});\n\t\t}\n\t} FindIf;\n\tstruct Sum_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\t\treturn a + f(b);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t\t}\n\t} Sum;\n\tstruct Includes {\n\t\ttemplate <class V> auto operator()(const V& val) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t\t});\n\t\t}\n\t} Includes;\n\tstruct IncludesIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t\t});\n\t\t}\n\t} IncludesIf;\n\tstruct RemoveIf_impl {\n\t\ttemplate <class F> auto operator()(const F& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t} RemoveIf;\n\tstruct Each_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tf(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} Each;\n\tstruct Select_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\t\tvector<value_type> res;\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Select;\n\tstruct Map_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\t\tvector<result_type> res;\n\t\t\t\tres.reserve(size(v));\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tres.push_back(f(i));\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\t} Map;\n\tstruct Indexed_impl {\n\t\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\t\tusing value_type = typename T::value_type;\n\t\t\tvector<pair<value_type, int>> res;\n\t\t\tres.reserve(size(v));\n\t\t\tint index = 0;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.emplace_back(i, index++);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} Indexed;\n\tstruct AllOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (!f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} AllOf;\n\tstruct AnyOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t} AnyOf;\n\tstruct NoneOf_impl {\n\t\ttemplate <class F> auto operator()(F&& f) {\n\t\t\treturn Callable([&](auto v) {\n\t\t\t\tfor (const auto& i : v) {\n\t\t\t\t\tif (f(i)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t} NoneOf;\n};  // namespace Ruby\nusing namespace Ruby;\n\n// --- functions --- //\nnamespace Functions {\n\ttemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i) res += s;\n\t\treturn res;\n\t}\n\ttemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2));\n\t\treturn v;\n\t}\n\ttemplate <class T> inline T Ceil(T n, T m) {\n\t\treturn (n + m - 1) / m;\n\t}\n\ttemplate <class T> inline T Ceil2(T n, T m) {\n\t\treturn Ceil(n, m) * m;\n\t}\n\ttemplate <class T> inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate <class T> inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate <class T> inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\ttemplate <class T> inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate <class T> inline bool isSquere(T n) {\n\t\tT s = sqrt(n);\n\t\treturn s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate <class T = long long> inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n\t}\n\ttemplate <class T> inline T Pow(T a, T n) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) r *= a;\n\t\t\ta *= a;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1)\n\t\t\t\tr = r * a % m, n--;\n\t\t\telse\n\t\t\t\ta = a * a % m, n /= 2;\n\t\t}\n\t\treturn r;\n\t}\n}  // namespace Functions\nusing namespace Functions;\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\n#include <atcoder/all>\nint main() {\n\tini(n, d);\n\tatcoder::two_sat t(n);\n\tvector<int> x(n), y(n);\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tt.add_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tt.add_clause(i, false, j, false);\n\t\t}\n\t}\n\tif (t.satisfiable()) {\n\t\tout(true);\n\t\tauto ans = t.answer();\n\t\trep(i, n) out(ans[i] ? y[i] : x[i]);\n\t} else {\n\t\tout(false);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#include <numeric>\n#include <atcoder/dsu>\n#include <atcoder/fenwicktree>\n#include <atcoder/math>\n#include <atcoder/maxflow>\n#include <atcoder/mincostflow>\n#include <atcoder/convolution>\n#include <atcoder/scc>\n#include <atcoder/twosat>\n#define IINF 1000000000\n#define INF 3223372036854775807\n#define MOD 1000000007\n#define mod 1000000007\n#define INT_MAX_ 2147483647\n#define EPS (1e-10)\n#define REP(i, a, n) fo-r (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n//#define rep(i,n)for (ll i = 0; i < (ll)(n); i++)\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\n#define me memset\n#define bit(n,k) ((n>>k)&1)\n#define lg length()\nusing namespace std;\nusing namespace atcoder;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\ntemplate<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define invp(a,p)pom(a,p-2,p)\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp1(pair<Pll,ll> a,pair<Pll,ll> b){\n        return a.fi.se>b.fi.se;\n}\nll cmp2(pair<ll,ll> a,pair<ll,ll> b){\n    if(a.fi!=b.fi)\n        return  a.se<b.se;\n    else\n        return a.se>b.se;\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\nint main(int argc, char * argv[]){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_t=clock();\n    //freopen(\"big.txt\", \"r\", stdin);\n    //freopen(\"out3.txt\", \"w\", stdout);\n    //------------------------------\n    ll n,d;cin>>n>>d;\n    V<ll>x(n),y(n);\n    for(ll i=0;i<n;i++){\n        cin>>x[i]>>y[i];\n    }\n    two_sat ts(n);\n    for(ll i=0;i<n;i++){\n        for(ll j=i+1;j<n;j++){\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n    //------------------------------\n    //fclose(stdin);\n    //fclose(stdout);\n    //ll end_t=clock();cout<<\"time=\"<<end_t-begin_t<<\"ms\"<<endl;\n    //------------------------------- \n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\n#include <atcoder/all>\nusing namespace atcoder;\n\n\nint main(){\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    two_sat ts(n);\n    rep(i,n)rep(j,i){\n        if(abs(x[i]-x[j])<d){\n            ts.add_clause(i,false,j,false);\n        }\n        if(abs(x[i]-y[j])<d){\n            ts.add_clause(i,false,j,true);\n        }\n        if(abs(y[i]-x[j])<d){\n            ts.add_clause(i,true,j,false);\n        }\n        if(abs(y[i]-y[j])<d){\n            ts.add_clause(i,true,j,true);\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n\n    for(int i=0;i<n;i++){\n        if(ans[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\n#include <atcoder/twosat>\n//python3 ac-library/expander.py sol.cpp\n\nint main(){\n   int n,d; cin>>n>>d;\n   vector<int> x(n),y(n);\n   rep(i,0,n)cin>>x[i]>>y[i];\n   atcoder::two_sat g(n*2);\n   rep(i,0,n)g.add_clause(i,1,i+n,1);\n   rep(i,0,n)rep(j,0,n)if(i!=j){\n      if(abs(x[i]-x[j])<d){\n         g.add_clause(i,0,j,0);\n      }\n      if(abs(y[j]-y[i])<d){\n         g.add_clause(j+n,0,i+n,0);\n      }\n      if(abs(x[j]-y[i])<d){\n         g.add_clause(j,0,i+n,0);\n      }\n      if(abs(y[j]-x[i])<d){\n         g.add_clause(j+n,0,i,0);\n      }\n   }\n   bool can=g.satisfiable();\n   if(can){\n      puts(\"Yes\");\n      auto res=g.answer();\n      rep(i,0,n){\n         if(res[i])cout<<x[i]<<endl;\n         else cout<<y[i]<<endl;\n      }\n   }\n   else puts(\"No\");\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nconst string YES = \"Yes\";\nconst string NO = \"No\";\n\nint main(){\n    ll n, d;\n    cin >> n >> d;\n    vector<ll> x(n), y(n);\n    REP(i, n){\n        cin >> x.at(i) >> y.at(i);\n    }\n\n    two_sat ts(n);\n\n    REP(i, n){\n        for(ll j = i + 1; j < n; ++j){\n            // xi, xj\n            if(abs(x.at(i) - x.at(j)) < d){\n                ts.add_clause(i, true, j, true);\n            }\n            // xi, yj\n            if(abs(x.at(i) - y.at(j)) < d){\n                ts.add_clause(i, true, j, false);\n            }\n            // yi, xj\n            if(abs(y.at(i) - x.at(j)) < d){\n                ts.add_clause(i, false, j, true);\n            }\n            // yi, yj;\n            if(abs(y.at(i) - y.at(j)) < d){\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if(!ts.satisfiable()){\n        cout << NO << endl;\n        return 0;\n    }\n    cout << YES << endl;\n\n    vector<bool> ans = ts.answer();\n    REP(i, n){\n        if(ans.at(i)){\n            cout << y.at(i) << endl;\n        }else{\n            cout << x.at(i) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing lint = long long;\n#define rep(i, n) for(lint i = 0; i < lint(n); i++)\n#define repu(i, a, b, s) for(lint i = lint(a); i < lint(b); i += lint(s))\n#define repd(i, a, b, s) for(lint i = lint(a); i > lint(b); i += lint(s))\n#define endl \"\\n\"\nconstexpr lint INF = 2e18;\nconstexpr lint MOD = 1e9 + 7;\n\nvoid solve() {\n    lint N, D;\n    cin >> N >> D;\n    two_sat ts(N);\n\n    vector<lint> x(N), y(N);\n    rep(i, N) { cin >> x[i] >> y[i]; }\n\n    rep(i, N) {\n        repu(j, i + 1, N, 1) {\n            if(abs(x[i] - x[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if(abs(x[i] - y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if(abs(y[i] - x[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if(abs(y[i] - y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if(!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        exit(0);\n    }\n\n    cout << \"Yes\" << endl;\n    auto ans = ts.answer();\n    rep(i, N) {\n        if(ans[i]) {\n            cout << x[i] << endl;\n        } else {\n            cout << y[i] << endl;\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(15);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for(int i = 0; i < N; ++i)  cin >> X[i] >> Y[i];\n\n    vector<vector<int>> graph(N * 2), rev(N * 2);\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < i; ++j){\n            if(abs(X[i] - X[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2 + 1);\n            }\n            if(abs(X[i] - Y[j]) < D){\n                graph[i * 2 + 1].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2);\n                rev[i * 2].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2 + 1);\n            }\n            if(abs(Y[i] - X[j]) < D){\n                graph[i * 2].emplace_back(j * 2);\n                graph[j * 2 + 1].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2 + 1);\n                rev[j * 2].emplace_back(i * 2);\n            }\n            if(abs(Y[i] - Y[j]) < D){\n                graph[i * 2].emplace_back(j * 2 + 1);\n                graph[j * 2].emplace_back(i * 2 + 1);\n                rev[i * 2 + 1].emplace_back(j * 2);\n                rev[j * 2 + 1].emplace_back(i * 2);\n            }\n        }\n    }\n\n    vector<int> vs;\n    vector<bool> used(N, false);\n    auto dfs = [&](auto&& self, int cur) -> void {\n        used[cur] = true;\n        for(int nxt : graph[cur]){\n            if(!used[nxt])  self(self, nxt);\n        }\n        vs.emplace_back(cur);\n    };\n    for(int v = 0; v < N * 2; ++v){\n        if(!used[v])    dfs(dfs, v);\n    }\n    reverse(vs.begin(), vs.end());\n\n    vector<int> scc_id(N * 2, -1);\n    int K = 0;\n    auto rdfs = [&](auto&& self, int cur) -> void {\n        scc_id[cur] = K;\n        for(int nxt : rev[cur]){\n            if(scc_id[nxt] == -1)   self(self, nxt);\n        }\n    };\n    for(int v : vs){\n        if(scc_id[v] == -1){\n            rdfs(rdfs, v);\n            ++K;\n        }\n    }\n\n    vector<bool> ans(N);\n    for(int i = 0; i < N; ++i){\n        if(scc_id[i * 2] == scc_id[i * 2 + 1]){\n            cout << \"No\\n\";\n            return 0;\n        }\n        ans[i] = scc_id[i * 2] < scc_id[i * 2 + 1];\n    }\n\n    cout << \"Yes\\n\";\n    for(int i = 0; i < N; ++i)  cout << ((ans[i] ? X[i] : Y[i])) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n#define ll long long\n#define BIT(n) (1LL << (n))\n#define BITF(n, i) (((n) >> (i)) & 1)\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\n#define REPI(i, x) for (ll i = 1; i <= x; i++)\n#define FORI(i, m, n) for (ll i = m; i <= n; i++)\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\n#define REPZ(i, x) for (ll i = 0; i <= x; i++)\n#define FORA(i, n) for (auto &&i : n)\n#define POW(a, b) ((ll)(pow(a, b) + .5))\n#define MODULO(a, b) (((a) % (b)) < 0 ? (a) % (b) + (b) : (a) % (b))\n#define DUMPOUT cerr\n// vector\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) {\n  for (T &x : vec) is >> x;\n  return is;\n}\n// pair\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n  os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n  return os;\n}\n// vector\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {\n  os << \"{\";\n  REP(i, (ll)vec.size())\n  os << vec[i] << (i + 1 == (ll)vec.size() ? \"\" : \", \");\n  os << \"}\";\n  return os;\n}\n// map\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &map_var) {\n  os << \"{\";\n  FORA(itr, map_var) {\n    os << *itr;\n    itr++;\n    if (itr != map_var.end()) os << \", \";\n    itr--;\n  }\n  os << \"}\";\n  return os;\n}\n// set\ntemplate <typename T> ostream &operator<<(ostream &os, set<T> &set_var) {\n  os << \"{\";\n  FORA(itr, set_var) {\n    os << *itr;\n    itr++;\n    if (itr != set_var.end()) os << \", \";\n    itr--;\n  }\n  os << \"}\";\n  return os;\n}\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head &&head, Tail &&... tail) {\n  DUMPOUT << head;\n  if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n  dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define DUMP(...)                                                             \\\n  DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                             \\\n          << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" << endl \\\n          << \"    \",                                                          \\\n      dump_func(__VA_ARGS__)\n#define PRINTARR(x, y)                                     \\\n  cerr << #x << \"=\\n\";                                     \\\n  for (auto itr = x; itr != y; itr++) cerr << *itr << \" \"; \\\n  cerr << endl;\n#define PRINTARR2(x, i0, i1)                                      \\\n  cerr << #x << \"=\\n\";                                            \\\n  for (ll ii0 = 0; ii0 < i0; ii0++) {                             \\\n    for (ll ii1 = 0; ii1 < i1; ii1++) cerr << x[ii0][ii1] << \" \"; \\\n    cerr << endl;                                                 \\\n  }\n#else\n#define DEB if (false)\n#define DUMP(...)\n#define PRINTARR(x, y)\n#define PRINTARR2(x, i0, i1)\n#endif\n#define ALL(v) v.begin(), v.end()\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\n#define epb emplace_back\n#define pint pair<ll, ll>\n#define pdouble pair<double, double>\n#define ld long double\nusing namespace std;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> void print(const T &x) { cout << x << \"\\n\"; }\nconst ll MOD = 1000000007, INF0 = 1061109567, INF = INF0 * INF0;\nconst double EPS = 1e-7, PI = acos(-1.0);\nconst ll dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n/*\n[&] { return; }();下のスラッシュを2つ追加しただけ.上のスラッシュを2つにすれば外れる.\n//*/\n#define MAXN 1110\nll xy[MAXN][2];\nsigned main() {\n  cin.tie(0), ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  ll N, D;\n  cin >> N >> D;\n  two_sat ts(N);\n  REP(i, N) { cin >> xy[i][0] >> xy[i][1]; }\n  REP(i, N) {\n    REP(j, i) {\n      REP(k, 4) {\n        if (abs(xy[i][k / 2] - xy[j][k % 2]) < D) {\n          ts.add_clause(i, 1 - k / 2, j, 1 - k % 2);\n        }\n      }\n    }\n  }\n  if (ts.satisfiable()) {\n    print(\"Yes\");\n    vec<bool> ans = ts.answer();\n    REP(i, N) print(xy[i][ans[i]]);\n  } else {\n    print(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iomanip>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <tuple>\n#include <numeric>\n#include <functional>\nusing namespace std; using ll = long long; using ld = long double;  using pll = pair<ll, ll>;\nusing vl = vector<ll>; using vll = vector<vl>; using vlll = vector<vll>; using vpll = vector<pll>;\nusing vs = vector<string>; using tll = tuple<ll, ll, ll>; using vtll = vector<tll>;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nconst ld PI = 3.1415926535897932;\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define co(i) cout << i << endl;\n#define co2(i,j) cout << i << \" \" << j << endl;\n#define co3(i) cout << i << \" \";\n#define po(i) cout << i.first << \" \" << i.second << endl;\nvoid in() {}\nvoid debug_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head h, Tail... t) {\n\tcerr << \" \" << h;\n\tif (sizeof...(t) > 0) cerr << \" :\";\n\tdebug_out(t...);\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> vec) {\n\tfor (size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n\treturn os;\n}\nll ctoi(char c) {\n\tswitch (c) {\n\tcase '0': return 0; case '1': return 1; case '2': return 2;\n\tcase '3': return 3; case '4': return 4; case '5': return 5;\n\tcase '6': return 6; case '7': return 7; case '8': return 8;\n\tcase '9': return 9;  default: return 0;\n\t}\n}\nbool pairCompare(const pll firstElof, pll secondElof)\n{\n\treturn firstElof.second < secondElof.second;\n}\n//AtCoder以外ではコメントアウトを忘れずに！\n#include <atcoder/all>\nusing namespace atcoder;\n//**Snippetリスト**//\n//rep, vin, all, iteLoop, bitSearch, bitList, nod, LIS, digitDP, treeDP, Rerooting//\n//gcdlcm, isPrime, eratos, primeFactorize, Npow, combination, divisor, modinv, doubling//\n//dfs, bfs, dijkstra, WarshallFloyd, BellmanFord, UnionFind, Kruskal, RMQ, LCA, FordFulkerson//\nll i, j, k, l; ll N, M, K, H, W, L, X, Y, Z, R, Q, T;\nll MOD = 1000000007, INF = 1LL << 60, ans = 0, z = 0, o = 1;\nvll flag, D; vector<vpll> path; vs S;\nint main() {\n\tll N, D;\n\tcin >> N >> D;\n\tvl X(N), Y(N);\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\ttwo_sat TS(N);\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = i+1; j < N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\t// cannot use both of x[i] and x[j]\n\t\t\t\tTS.add_clause(i, false, j, false);\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tTS.add_clause(i, false, j, true);\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tTS.add_clause(i, true, j, false);\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tTS.add_clause(i, true, j, true);\n\t\t\t}\n\t\t}\n\t}\n\tif (!TS.satisfiable()) {\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"Yes\" << endl;\n\tauto ans = TS.answer();\n\tfor (i = 0; i < N; i++) {\n\t\tcout << (ans[i] ? X[i] : Y[i]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<complex>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \n#include <numeric>\nusing namespace std;\nusing Complex = complex<double>;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\nconst double EPS = 1e-10;\ndouble PI = acos(-1.0);\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\nconst int MAX_N = 505050;\nvector<int>e[MAX_N], er[MAX_N];\nint fin[MAX_N], cmp[MAX_N], state[MAX_N];\nint cnt = 0;\nint num = 0;\nvoid dfs1(int now) {\n\tstate[now] = 1;\n\tfore(x, e[now]) {\n\t\tif (state[x] == 0) {\n\t\t\tcnt++;\n\t\t\tdfs1(x);\n\t\t}\n\t}\n\tcnt++;\n\tfin[now] = cnt;\n}\nvoid dfs2(int now, int num) {\n\tstate[now] = 1;\n\tcmp[now] = num;\n\tfore(x, er[now]) {\n\t\tif (state[x] == 0)dfs2(x, num);\n\t}\n}\nvoid scc(int N) {\n\t//各頂点について終了時間を計算\n\tfor (int i = 0; i < N; i++) {\n\t\tif (state[i] == 0)dfs1(i);\n\t}\n\t//逆辺を計算\n\tfor (int i = 0; i < N; i++) {\n\t\tfore(x, e[i])er[x].pb(i);\n\t}\n\n\tfor (int i = 0; i < N; i++)state[i] = 0;\n\n\t//終了時間の降順でdfsをしていく\n\tvector<pair<int, int>>finli;\n\tfor (int i = 0; i < N; i++) {\n\t\tfinli.pb({ fin[i],i });\n\t}\n\tsort(all(finli));\n\treverse(all(finli));\n\tfor (int i = 0; i < N; i++) {\n\t\tint v = finli[i].second;\n\t\tif (state[v] == 0) {\n\t\t\tdfs2(v, num);\n\t\t\tnum++;\n\t\t}\n\t}\n}\n\nvoid add_edges(int x, int y,int sz) {\n\te[(x+sz)%(2*sz)].pb(y%(2*sz));\n\te[(y+sz)%(2*sz)].pb(x%(2*sz));\n}\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint N, D;\n\tcin >> N >> D;\n\tvector<int>zahyou;\n\tvector<pair<int,int>>li;\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tli.pb({ x,y });\n\t\tzahyou.pb(x);\n\t\tzahyou.pb(y);\n\t}\n\tsort(all(zahyou));\n\tzahyou.erase(unique(all(zahyou)), zahyou.end());\n\n\tint sz = zahyou.size();\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = li[i].first;\n\t\tint y = li[i].second;\n\t\tli[i].first = lower_bound(all(zahyou), x) - zahyou.begin();\n\t\tli[i].second = lower_bound(all(zahyou), y) - zahyou.begin();\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint xidx = li[i].first;\n\t\tint yidx = li[i].second;\n\t\tadd_edges(xidx,yidx,sz);\n\t\tadd_edges(xidx+sz,yidx+sz,sz);\n\t}\n\n\n\tfor (int i = 0; i < sz; i++) {\n\t\tfor (int j = i + 1; j < sz; j++) {\n\t\t\tif (zahyou[j] - zahyou[i] >= D)continue;\n\t\t\tadd_edges(i+sz,j+sz,sz);\n\t\t}\n\t}\n\n\tscc(2*sz);\n\n\t//check\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (cmp[i] == cmp[i + sz]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tputs(\"Yes\");\n\tfor (int i = 0; i < N; i++) {\n\t\tint xidx = li[i].first;\n\t\tint yidx = li[i].second;\n\t\tif (cmp[xidx + sz] < cmp[xidx])puts(zahyou[xidx]);\n\t\telse puts(zahyou[yidx]);\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <atcoder/twosat>\n\nnamespace ac = atcoder;\n\nvoid solve() {\n    int n, d;\n    std::cin >> n >> d;\n\n    std::vector<int> xs(n * 2);\n    for (auto& x : xs) std::cin >> x;\n\n    ac::two_sat ts(n * 2);\n    for (int i = 0; i < n * 2; i += 2) {\n        ts.add_clause(i, true, i + 1, true);\n        ts.add_clause(i, false, i + 1, false);\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (std::abs(xs[i] - xs[j]) < d) {\n                ts.add_clause(i, false, j, false);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        std::cout << \"No\\n\";\n        return;\n    }\n\n    std::cout << \"Yes\\n\";\n    auto ans = ts.answer();\n    for (int i = 0; i < n * 2; ++i) {\n        if (ans[i]) std::cout << xs[i] << \"\\n\";\n    }\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//To compile : type \"$     g++ test.cpp -std=c++14 -I .    \"\n#include <atcoder/twosat>\n#include <bits/stdc++.h>\n//#include <chrono>\n//#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nusing namespace atcoder;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,Q,K,A,B;\nstring S;\ntypedef pair<ll, ll> P;\nconst ll INF = (1LL<<60);\n\nint main() {\n    cin >> N >> K;\n    vec x(N * 2);\n\ttwo_sat ts(N);\n    rep(i, N) cin>>x[i]>>x[i + N];\n    rep(i, N * 2){\n        rep(j, i) {\n            if(abs(x[i] - x[j]) < K) {\n\t\t\t\tts.add_clause(i%N, i >= N, j%N, j >= N);\n            }\n        }\n    }\n    bool ok = ts.satisfiable();\n    cout<<(ok ? \"Yes\" : \"No\")<<endl;\n    if(ok){\n\t\tauto ans = ts.answer();\n        rep(i, N){\n            cout<<(ans[i] ? x[i] : x[i + N])<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T> T sq(T x) { return x * x; }\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nsigned main() {\n    int N, D;\n    cin >> N >> D;\n    vint X(N), Y(N);\n    rep(i, N) { cin >> X[i] >> Y[i]; }\n    two_sat ts(N);\n    rep(i, N) {\n        rep(j, i) {\n            if (abs(X[i] - X[j]) < D) { ts.add_clause(i, 1, j, 1); }\n            if (abs(X[i] - Y[j]) < D) { ts.add_clause(i, 1, j, 0); }\n            if (abs(Y[i] - X[j]) < D) { ts.add_clause(i, 0, j, 1); }\n            if (abs(Y[i] - Y[j]) < D) { ts.add_clause(i, 0, j, 0); }\n        }\n    }\n    if (ts.satisfiable()) { cout << \"Yes\" << endl; }\n    else { fin(\"No\"); }\n    auto ans = ts.answer();\n    rep(i, N) {\n        if (ans[i]) { cout << Y[i] << endl; }\n        else { cout << X[i] << endl; }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/twosat>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for(int i=0; i<N; i++) cin >> X[i] >> Y[i];\n\n    atcoder::two_sat ts(N);\n    for(int i=0; i<N; i++)\n    {\n        for(int j=i+1; j<N; j++)\n        {\n            if(abs(X[i] - X[j]) < D) ts.add_clause(i, false, j, false);\n            if(abs(X[i] - Y[j]) < D) ts.add_clause(i, false, j, true);\n            if(abs(Y[i] - X[j]) < D) ts.add_clause(i, true, j, false);\n            if(abs(Y[i] - Y[j]) < D) ts.add_clause(i, true, j, true);\n        }\n    }\n\n    if(ts.satisfiable())\n    {\n        cout << \"Yes\\n\";\n        auto ans = ts.answer();\n        for(int i=0; i<N; i++)\n        {\n            if(ans[i]) cout << X[i] << '\\n';\n            else cout << Y[i] << '\\n';\n        }\n    }\n    else cout << \"No\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ld = long double;\n\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\n#define e_b emplace_back\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) ((x).erase(unique(all(x)),(x).end()))\n#define sz(x) ((int)(x).size())\n\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n\n#ifdef LOCAL//compile with -DLOCAL\n#define debug(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \"<<(x)<<endl\n#define debug_vec(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \";\\\n  rep(i,sz(x)){cerr<<x[i]<<\" \";}cerr<<endl\n#define debug_mat(x) cerr<<\"LINE\"<<__LINE__<<\" : \"<<#x<<\" = \"<<endl;\\\n  rep(i,sz(x)){rep(j,sz(x[i])){cerr<<x[i][j]<<\" \";}cerr<<endl;}cerr<<endl\n#else\n#define debug(x) void(0)\n#define debug_vec(x) void(0)\n#define debug_mat(x) void(0)\n#endif\n\ntemplate<class T> bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);cin.tie(0);\n  int N,D;\n  cin >> N >> D;\n  vector<ll> X(N),Y(N);\n  rep(i,N)  cin >> X.at(i) >> Y.at(i);\n\n  two_sat ts(N);\n  rep(i,N){\n    REP(j,i+1,N){\n      if(abs(X.at(i)-X.at(j)) < D)  ts.add_clause(i, false, j, false);\n      if(abs(X.at(i)-Y.at(j)) < D)  ts.add_clause(i, false, j, true);\n      if(abs(Y.at(i)-X.at(j)) < D)  ts.add_clause(i, true, j, false);\n      if(abs(Y.at(i)-Y.at(j)) < D)  ts.add_clause(i, true, j, true);\n    }\n  }\n\n  if(!ts.satisfiable()){\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n\n  vector<bool> ans = ts.answer();\n  rep(i,N){\n    if(ans.at(i)) cout << X.at(i) << endl;\n    else  cout << Y.at(i) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 2 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/other/template.hpp\"\n#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx2\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef unsigned int uint;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef std::pair<int, int> P;\ntypedef std::pair<lint, lint> LP;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, lint b) {\n\tT res(1);\n\twhile(b){\n\t\tif(b&1)res*=a;\n\t\ta*=a;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nlint modpow(lint a, lint b, lint m) {\n\tlint res(1);\n\twhile(b){\n\t\tif(b&1){\n\t\t\tres*=a;res%=m;\n\t\t}\n\t\ta*=a;a%=m;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size()){\n\t\tstd::cout << vec[i];\n\t\tstd::cout<<(i==(int)vec.size()-1?\"\\n\":\" \");\n\t}\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = std::prev(r);\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nLP extGcd(lint a,lint b) {\n\tif(b==0)return {1,0};\n\tLP s=extGcd(b,a%b);\n\tstd::swap(s.first,s.second);\n\ts.second-=a/b*s.first;\n\treturn s;\n}\nLP ChineseRem(const lint& b1,const lint& m1,const lint& b2,const lint& m2) {\n\tlint p=extGcd(m1,m2).first;\n\tlint tmp=(b2-b1)*p%m2;\n\tlint r=(b1+m1*tmp+m1*m2)%(m1*m2);\n\treturn std::make_pair(r,m1*m2);\n}\ntemplate<typename F>\ninline constexpr decltype(auto) lambda_fix(F&& f){\n\treturn [f=std::forward<F>(f)](auto&&... args){\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}\n#line 3 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/graph/StronglyConnectedComponents.hpp\"\nclass StronglyConnectedComponents{\n\tint N;\n\tstd::vector<std::vector<int>> vec,rvec;\npublic:\n\tStronglyConnectedComponents(int N_):N(N_){\n\t\tvec.resize(N);rvec.resize(N);\n\t}\n\tvoid add_edge(int from,int to){\n\t\tvec[from].emplace_back(to);\n\t\trvec[to].emplace_back(from);\n\t}\n\tstd::vector<std::vector<int>> get_scc(){\n\t\tstd::vector<bool> used(N);\n\t\tstd::vector<int> vs;\n\t\tstd::vector<std::vector<int>> res;\n\t\tauto dfs=lambda_fix([&](auto self,int node)->void{\n\t\t\tused[node]=true;\n\t\t\tfor(const int& i:vec[node]){\n\t\t\t\tif(!used[i])self(self,i);\n\t\t\t}\n\t\t\tvs.emplace_back(node);\n\t\t});\n\t\tauto rdfs=lambda_fix([&](auto self,int node)->void{\n\t\t\tused[node]=true;\n\t\t\tres.back().emplace_back(node);\n\t\t\tfor(const int& i:rvec[node]){\n\t\t\t\tif(!used[i])self(self,i);\n\t\t\t}\n\t\t});\n\t\trep(i,N){\n\t\t\tif(!used[i])dfs(i);\n\t\t}\n\t\tused.assign(N,false);\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\tif(!used[vs[i]]){\n\t\t\t\tres.emplace_back();\n\t\t\t\trdfs(vs[i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<int> get_ids(){\n\t\tauto vec=get_scc();\n\t\tstd::vector<int> res(N);\n\t\trep(i,vec.size()){\n\t\t\tfor(const auto& j:vec[i])res[j]=i;\n\t\t}\n\t\treturn res;\n\t}\n};\n#line 4 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/graph/TwoSat.hpp\"\nclass TwoSat{\n\tint N;\n\tStronglyConnectedComponents scc;\n\tstd::vector<int> ans;\npublic:\n\tTwoSat(int N_):N(N_),scc(2*N_),ans(N_){}\n\tvoid add_clause(int i,bool f,int j,bool g){\n\t\tscc.add_edge(2*i+int(!f),2*j+int(g));\n\t\tscc.add_edge(2*j+int(!g),2*i+int(f));\n\t}\n\tbool satisfiable(){\n\t\tauto ids=scc.get_ids();\n\t\trep(i,N){\n\t\t\tif(ids[2*i]==ids[2*i+1])return false;\n\t\t\tans[i]=ids[2*i]<ids[2*i+1];\n\t\t}\n\t\treturn true;\n\t}\n\tstd::vector<int> answer(){return ans;}\n};\n#line 3 \"main.cpp\"\nint N,D,X[1010],Y[1010];\nint main(){\n\tstd::cin>>N>>D;\n\tTwoSat ts(2*N);\n\trep(i,N)std::cin>>X[i]>>Y[i];\n\trep(i,N){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tif(std::abs(X[i]-X[j])<D)ts.add_clause(i,true,j,true);\n\t\t\tif(std::abs(X[i]-Y[j])<D)ts.add_clause(i,true,j,false);\n\t\t\tif(std::abs(Y[i]-X[j])<D)ts.add_clause(i,false,j,true);\n\t\t\tif(std::abs(Y[i]-Y[j])<D)ts.add_clause(i,false,j,false);\n\t\t}\n\t}\n\tif(!ts.satisfiable()){\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n\tauto vec=ts.answer();\n\trep(i,N){\n\t\tif(!vec[i])std::cout<<X[i]<<std::endl;\n\t\telse std::cout<<Y[i]<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SCC {\n  struct csr {\n    vector<int> start, elist;\n    csr(int n, const vector<pair<int, int>> &edges)\n      : start(n+1), elist(edges.size()) {\n        for(pair<int, int> e:edges) {\n          start[e.first+1]++;\n        }\n        for(int i = 1; i <= n; i++) {\n          start[i] += start[i-1];\n        }\n        vector<int> counter = start;\n        for(pair<int, int> e:edges) {\n          elist[counter[e.first]++] = e.second;\n        }\n    }\n  };\n  int n;\n  vector<pair<int, int>> edges;\n  SCC(int n_) : n(n_) {}\n  void add(int from, int to) {edges.emplace_back(from, to);}\n  pair<int, vector<int>> scc_ids() {\n    csr g(n, edges);\n    int now_ord = 0, group_num = 0;\n    vector<int> used, low(n), ord(n, -1), ids(n);\n    used.reserve(n);\n    auto dfs = [&](auto self, int v)->void {\n      low[v] = ord[v] = now_ord++;\n      used.push_back(v);\n      for(int i = g.start[v]; i < g.start[v+1]; i++) {\n        int to = g.elist[i];\n        if(ord[to] == -1) {\n          self(self, to);\n          low[v] = min(low[v], low[to]);\n        }\n        else {\n          low[v] = min(low[v], ord[to]);\n        }\n      }\n      if(low[v] == ord[v]) {\n        while(true) {\n          int u = used.back();\n          used.pop_back();\n          ord[u] = n;\n          ids[u] = group_num;\n          if(u == v) break;\n        }\n        group_num++;\n      }\n    };\n    for(int i = 0; i < n; i++) {\n      if(ord[i] == -1) dfs(dfs, i);\n    }\n    for(int &x:ids) {\n      x = group_num - 1 - x;\n    }\n    return {group_num, ids};\n  }\n  vector<vector<int>> scc() {\n    pair<int, vector<int>> ids = scc_ids();\n    int group_num = ids.first;\n    vector<int> counts(group_num);\n    for(int x:ids.second) counts[x]++;\n    vector<vector<int>> groups(group_num);\n    for(int i = 0; i < group_num; i++) {\n      groups[i].reserve(counts[i]);\n    }\n    for(int i = 0; i < n; i++) {\n      groups[ids.second[i]].push_back(i);\n    }\n    return groups;\n  }\n};\n\n//scc is needed\n\nstruct two_sat {\n  int n;\n  vector<bool> boolean_val;\n  SCC scc;\n  two_sat():n(0), scc(0) {}\n  two_sat(int n_):n(n_), boolean_val(n_), scc(n_<<1) {}\n\n  void add(int i, bool ii, int j, bool jj) {\n    scc.add(i + (ii?0:n), j + (jj?n:0));\n    scc.add(j + (jj?0:n), i + (ii?n:0));\n  }\n  bool satisfiable() {\n    vector<int> id = scc.scc_ids().second;\n    for(int i = 0; i < n; i++) {\n      if(id[i] == id[i+n]) return false;\n      boolean_val[i] = id[i] < id[i+n];\n    }\n    return true;\n  }\n};\n\n\n#define N 1010\n\n\nint n, d;\nint x[2][N];\n\nint main() {\n  scanf(\"%d%d\", &n, &d);\n  two_sat TS(n);\n  for(int i = 0; i < n; i++) scanf(\"%d%d\", x[0]+i, x[1]+i);\n  for(int i = 0; i < n; i++) for(int k = 0; k < 2; k++) {\n    for(int j = 0; j < i; j++) for(int l = 0; l < 2; l++) {\n      if(abs(x[k][i] - x[l][j]) < d) {\n        TS.add(i, !k, j, !l);\n      }\n    }\n  }\n  if(TS.satisfiable()) {\n    vector<bool> &u = TS.boolean_val;\n    printf(\"Yes\\n\");\n    for(int i = 0; i < n; i++) {\n      printf(\"%d\\n\", x[(int)u[i]][i]);\n    }\n  }\n  else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize (\"Ofast\")\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\nusing ll = long long;\n\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fread_unlocked _fread_nolock\n#endif\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define USE_FREAD\n#ifdef USE_FREAD\nstruct Input {\n\tstatic constexpr size_t MAX_SIZE = 22020;\n\tchar buf[MAX_SIZE];\n\tsize_t i, end;\n\tInput() {\n\t\ti = 0;\n\t\tend = fread_unlocked(buf, 1, MAX_SIZE, stdin);\n\t}\n\tinline int gc() {\n\t\treturn buf[i++];\n\t}\n} in;\n#define gc in.gc\n#else\n#define gc getchar_unlocked\n#endif  // USE_FREAD\n\n// #define USE_FWRITE\n#ifdef USE_FWRITE\nstruct Output {\n\tstatic constexpr size_t MAX_SIZE = 4000009;\n\tchar buf[MAX_SIZE];\n\tsize_t i = 0;\n\tvoid pc(int c) {\n\t\tbuf[i++] = c;\n\t}\n\t~Output() {\n\t\tfwrite_unlocked(buf, 1, i, stdout);\n\t}\n} out;\n#define pc out.pc\n#else\n#define pc putchar_unlocked\n#endif  // USE_FWRITE\n\ninline void ini(int& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inui(int& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void inl(ll& v) noexcept {\n\tv = 0;\n\tchar c = gc();\n\tbool f = false;\n\tif (c == '-') {\n\t\tf = true;\n\t\tc = gc();\n\t}\n\tfor (; '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n\tif (f) v = -v;\n}\ninline void inul(ll& v) noexcept {\n\tv = 0;\n\tfor (char c = gc(); '0' <= c && c <= '9'; c = gc()) v = v * 10 + (c - '0');\n}\ninline void ins(char* c, int n) noexcept {\n\twhile (n--) {\n\t\t*c = gc();\n\t\t++c;\n\t}\n}\ninline void puti(int v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putui(int v) noexcept {\n\tchar b[10];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putl(ll v) noexcept {\n\tif (v < 0) pc('-'), v = -v;\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\ninline void putul(ll v) noexcept {\n\tchar b[20];\n\tint n = 0;\n\twhile (v) b[n++] = '0' + v % 10, v /= 10;\n\tif (!n) b[n++] = '0';\n\twhile (n--) pc(b[n]);\n}\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tinui(n);\n\tinui(d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) {\n\t\tinui(x[i]);\n\t\tinui(y[i]);\n\t};\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tpc('N');\n\t\t\tpc('o');\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpc('Y');\n\tpc('e');\n\tpc('s');\n\tpc('\\n');\n\trep(i, n) {\n\t\tputui(id[2 * i] < id[2 * i + 1] ? y[i] : x[i]);\n\t\tpc('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nstruct SCC{\n  ll n;\n  vector<vector<ll>>&G,Gr;\n  vector<ll>index;//各ノードが属する強連結成分の番号\n  vector<ll>ret;//dfsに使う\n  SCC(vector<vector<ll>>&g):G(g),n(g.size()){\n    index.assign(n,-1LL);\n    build();\n  }\n  void build(){\n    Gr.assign(n,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        Gr[G[i][j]].push_back(i);\n      }\n    }\n    for(ll i=0;i<n;i++)if(index[i]==-1)dfs1(i);\n    fill(ALL(index),-1);\n    ll cnt=0;\n    reverse(ALL(ret));\n    for(ll i=0;i<n;i++){\n      if(index[ret[i]]==-1){\n        dfs2(ret[i],cnt);\n        cnt++;\n      }\n    }\n  }\n  void dfs1(ll k){\n    index[k]=1;\n    for(ll i=0;i<G[k].size();i++){\n      if(index[G[k][i]]==-1)dfs1(G[k][i]);\n    }\n    ret.push_back(k);\n  }\n  void dfs2(ll k, ll idx){\n    index[k]=idx;\n    for(ll i=0;i<Gr[k].size();i++){\n      if(index[Gr[k][i]]==-1)dfs2(Gr[k][i],idx);\n    }\n  }\n  vector<vector<ll>>edges;\n  void build_edges(){\n    edges.assign(*max_element(ALL(index))+1,vector<ll>());\n    for(ll i=0;i<n;i++){\n      for(ll j=0;j<G[i].size();j++){\n        if(index[i]!=index[G[i][j]]){\n          edges[index[i]].push_back(index[G[i][j]]);\n        }\n      }\n    }\n  }\n  vector<ll>output(){return index;};\n};\n\nstruct TwoSat{\n  ll n;\n  vector<vector<ll>>g;\n  TwoSat(ll N):n(N){\n    g.assign(2*n,vector<ll>());\n  }\n  void add_or(ll x,bool tx,ll y,bool ty){//x:true x+n:false\n    g[x+tx*n].PB(y+!tx*n);\n    g[y+tx*n].PB(x+!ty*n);\n  }\n  vector<bool>ans;\n  bool solve(bool isConstruct = false){\n    SCC scc(g);\n    for(ll i=0;i<n;i++)if(scc.index[i]==scc.index[i+n])return false;\n    if(isConstruct){\n      ans.assign(n,false);\n      for(ll i=0;i<n;i++)ans[i]=(scc.index[i] > scc.index[i+n]);\n    }\n    return true;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,d;cin>>n>>d;\n  auto v=vec(n,2,0LL);\n  rep(i,0,n)cin>>v[i][0]>>v[i][1];\n  TwoSat sat(n);\n  rep(i,0,n)rep(ti,0,2)rep(j,i+1,n)rep(tj,0,2){\n    if(abs(v[i][ti]-v[j][tj])<d){\n      sat.add_or(i,!ti,j,!tj);\n    }\n  }\n  judge=sat.solve(true);\n  ans1(judge);\n  if(judge){\n    rep(i,0,n)cout<<v[i][sat.ans[i]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ONLINE_JUDGE\n#define DEBUG 1\n#if DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#endif\n#include <algorithm>\n#include <atcoder/all>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pll = pair<ll, ll>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing tll = tuple<ll, ll, ll>;\nusing vtll = vector<tll>;\nusing vvtll = vector<vtll>;\nconst ll mod = 1000000007LL;\nusing mint = atcoder::modint1000000007;  // modint998244353\n#define all(v) (v).begin(), (v).end()\n#define for1(i, n) for (ll i = 0; i < (n); i++)\n#define for2(i, m, n) for (ll i = (m); i < (n); i++)\n#define for3(i, m, n, d) for (ll i = (m); i < (n); i += (d))\n#define rfor2(i, m, n) for (ll i = (m); i > (n); i--)\n#define rfor3(i, m, n, d) for (ll i = (m); i > (n); i += (d))\n#define PI 3.1415926535897932384626433832795028841971693993751L\n#define INF 1111111111111111111LL\n#define print(...) print_1(__VA_ARGS__)\n#define in(...) in_1(__VA_ARGS__)\n#if DEBUG\n#define dump(...) dump_1(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\ntemplate <typename Head>\nvoid dump_1(const char* str, Head&& h)\n{\n    cerr << str << \": \" << h << '\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid dump_1(const char* str, Head&& h, Tail&&... t)\n{\n    while (*str != ',') {\n        cerr << *str++;\n    }\n    cerr << \": \" << h << ' ';\n    dump_1(str + 1, t...);\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& v)\n{\n    os << v.first << ' ' << v.second;\n    return os;\n}\ntemplate <typename T1, typename T2, typename T3>\nostream& operator<<(ostream& os, const tuple<T1, T2, T3>& v)\n{\n    os << get<0>(v) << ' ' << get<1>(v) << ' ' << get<2>(v);\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    for (auto it = v.begin(); it != v.end(); it++) {\n        if (it != v.begin()) {\n            os << ' ';\n        }\n        os << *it;\n    }\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& v)\n{\n    for (auto it = v.begin(); it != v.end(); it++) {\n        if (it != v.begin()) {\n            os << ' ';\n        }\n        os << *it;\n    }\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const multiset<T>& v)\n{\n    for (auto it = v.begin(); it != v.end(); it++) {\n        if (it != v.begin()) {\n            os << ' ';\n        }\n        os << *it;\n    }\n    return os;\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const map<T1, T2>& v)\n{\n    os << '{';\n    for (auto it = v.begin(); it != v.end(); it++) {\n        if (it != v.begin()) {\n            os << \", \";\n        }\n        os << it->first << ':' << it->second;\n    }\n    os << '}';\n    return os;\n}\nll divup(ll nume, ll deno)\n{\n    assert(nume >= 0);\n    assert(deno > 0);\n    return (nume + deno - 1) / deno;\n}\nvoid Yes(void) { cout << \"Yes\\n\"; }\nvoid No(void) { cout << \"No\\n\"; }\nvoid YES(void) { cout << \"YES\\n\"; }\nvoid NO(void) { cout << \"NO\\n\"; }\ntemplate <typename T>\nbool chmax(T& a, const T& b)\n{\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nbool chmin(T& a, const T& b)\n{\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nvoid vin(vector<T>& v)\n{\n    ll len = v.size();\n    for1 (i, len) {\n        cin >> v[i];\n    }\n}\ntemplate <typename Head>\nvoid in_1(Head& h)\n{\n    cin >> h;\n}\ntemplate <typename Head, typename... Tail>\nvoid in_1(Head& h, Tail&... t)\n{\n    cin >> h;\n    in_1(t...);\n}\ntemplate <typename Head>\nvoid print_1(Head&& h)\n{\n    cout << h << '\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid print_1(Head&& h, Tail&&... t)\n{\n    cout << h << ' ';\n    print_1(t...);\n}\n//---------------------------------------------------------\n//---------------------------------------------------------\nstruct mintcomb {\n    vector<mint> fact, ifact;\n    mintcomb(int n) : fact(n + 1), ifact(n + 1)\n    {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i - 1] * i;\n        }\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) {\n            ifact[i - 1] = ifact[i] * i;\n        }\n    }\n    mint permutation(int n, int k)\n    {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[n - k];\n    }\n    mint combination(int n, int k)\n    {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\n//---------------------------------------------------------\nvoid solve()\n{\n    ll N, D;\n    in(N, D);\n    vll X(N);\n    vll Y(N);\n    atcoder::two_sat ts(N);\n    for1 (i, N) {\n        in(X[i], Y[i]);\n    }\n    for1 (i, N) {\n        for2 (j, i + 1, N) {\n            if (abs(X[i] - X[j]) < D) {\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if (!ts.satisfiable()) {\n        No();\n        return;\n    }\n    Yes();\n    auto ans = ts.answer();\n    for1 (i, N) {\n        if (ans[i]) {\n            print(X[i]);\n        }\n        else {\n            print(Y[i]);\n        }\n    }\n}\n//---------------------------------------------------------\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(16);\n    cerr << fixed << setprecision(16);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << endl\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, d;\n    cin >> n >> d;\n    vector<P> v(n);\n    rep(i, n) cin >> v[i].first >> v[i].second;\n    two_sat g(n);\n    rep(i, n) rep(j, i) {\n        rep(ii, 2) {\n            rep(jj, 2) {\n                if (abs(v[i].first-v[j].first)<d) {\n                    g.add_clause(i, ii==0, j, jj==0);\n                }\n                swap(v[j].first, v[j].second);\n            }\n            swap(v[i].first, v[i].second);\n        }\n    }\n    bool ok = g.satisfiable();\n    if (!ok) {\n        pr(\"No\");\n        return 0;\n    }\n    pr(\"Yes\");\n    auto ans = g.answer();\n\n    rep(i, n) {\n        if (ans[i]) pr(v[i].first);\n        else pr(v[i].second);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll solve() {\n    ll N, D, x, y;\n    cin >> N >> D;\n    vector<ll> X(N), Y(N);\n    for ( int i = 0; i < N; i++ ) {\n        cin >> X[i] >> Y[i];\n    }\n    atcoder::two_sat ts(N);\n    for ( int i = 0; i < N; i++ ) {\n        for ( int j = i+1; j < N; j++ ) {\n            if ( abs(X[i]-X[j]) < D ) {\n                ts.add_clause(i,true,j,true);\n            }\n            if ( abs(X[i]-Y[j]) < D ) {\n                ts.add_clause(i,true,j,false);\n            }\n            if ( abs(Y[i]-X[j]) < D ) {\n                ts.add_clause(i,false,j,true);\n            }\n            if ( abs(Y[i]-Y[j]) < D ) {\n                ts.add_clause(i,false,j,false);\n            }\n        }\n    }\n    if ( !ts.satisfiable() ) {\n        cout << \"No\" << \"\\n\";\n    } else {\n        cout << \"Yes\" << \"\\n\";\n        auto vs = ts.answer();\n        for ( int i = 0; i < N; i++ ) {\n            cout << (vs[i] ? Y[i] : X[i]) << \"\\n\";\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct SCC {\npublic:\n    SCC(vector<vector<int>>& G) : G(G), comp(G.size(), -1), visited(G.size()), G_rev(G.size()) {\n        for (int u = 0; u < G.size(); u++) {\n            for (int v : G[u]) G_rev[v].push_back(u);\n        }\n\n        for (int v = 0; v < G.size(); v++) dfs(v);\n        reverse(order.begin(), order.end());\n        int c = 0;\n        for (int v : order) if (comp[v] == -1) rdfs(v, c++);\n    }\n\n    int operator[](int k) const {\n        return comp[k];\n    }\n\nprivate:\n    vector<vector<int>> G, G_rev;\n    vector<int> comp, order;\n    vector<bool> visited;\n\n    void dfs(int u) {\n        if (visited[u]) return;\n        visited[u] = true;\n        for (int v : G[u]) dfs(v);\n        order.push_back(u);\n    }\n\n    void rdfs(int u, int c) {\n        if (comp[u] != -1) return;\n        comp[u] = c;\n        for (int v : G_rev[u]) rdfs(v, c);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) cin >> X[i] >> Y[i];\n    vector<vector<int>> G(2*N);\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (abs(X[i] - X[j]) < D) {\n                G[i].push_back(N + j);\n                G[j].push_back(N + i);\n            }\n            if (abs(X[i] - Y[j]) < D) {\n                G[i].push_back(j);\n                G[N + j].push_back(N + i);\n            }\n            if (abs(Y[i] - X[j]) < D) {\n                G[N + i].push_back(N + j);\n                G[j].push_back(i);\n            }\n            if (abs(Y[i] - Y[j]) < D) {\n                G[N + i].push_back(j);\n                G[N + j].push_back(i);\n            }\n        }\n    }\n    SCC scc(G);\n    for (int i = 0; i < N; i++) {\n        if (Y[i] - X[i] < D || scc[i] == scc[N + i]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n    for (int i = 0; i < N; i++) {\n        if (scc[i] > scc[N + i]) cout << X[i];\n        else cout << Y[i];\n        cout << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n#include <deque>\n#include <complex>\n#include <bitset>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<long long, long long> pll;\ntypedef vector<pll> vpll;\n\ntypedef long double ld;\ntypedef vector<ld> vld;\n\ntypedef vector<bool> vb;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, n) for (ll i = 1; i <= (n); i++)\n#define rrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, n) for (ll i = (n); i >= 1; i--)\n#define all(v) (v).begin(), (v).end()\n\ntemplate <class T> void chmin(T& a, T b) { a = min(a, b);}\ntemplate <class T> void chmax(T& a, T b) { a = max(a, b);}\n\nconstexpr int INF = 1 << 30;\nconstexpr ll INFL = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-12;\nld PI = acos(-1.0);\n\nvoid solve() {\n    int n, d;\n    cin >> n >> d;\n    vll x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n\n    two_sat ts(n);\n    rep(i, n) rep(j, n) {\n        if(i != j) {\n            if(abs(x[i]-y[j]) < d) ts.add_clause(i, false, j, true);\n        }\n        if(i < j) {\n            if(abs(x[i]-x[j]) < d) ts.add_clause(i, false, j, false);\n            if(abs(y[i]-y[j]) < d) ts.add_clause(i, true, j, true);\n        }\n    }\n    bool ans = ts.satisfiable();\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n    if(!ans) return;\n    auto vb = ts.answer();\n    for(int i = 0; i < n; ++i) {\n        if(vb[i]) cout << x[i] << endl;\n        else cout << y[i] << endl;\n    }\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\nstruct StronglyConnectedComponents{\n    vector<vector<int>> g;\n    vector<vector<int>> to,from;\n    vector<int> comp,order,used;\n    StronglyConnectedComponents(vector<vector<int>> &g):\n    g(g),to(g.size()),from(g.size()),comp(g.size(),-1),used(g.size()){\n        for(int i=0;i<g.size();i++){\n            for(auto x:g[i]){\n                to[i].push_back(x);\n                from[x].push_back(i);\n            }\n        }\n    }\n    int operator[](int k){\n        return comp[k];\n    }\n    void dfs(int now){\n        if(used[now]) return ;\n        used[now]=true;\n        for(int x:to[now])dfs(x);\n        order.push_back(now);\n    }\n    void rdfs(int now,int cnt){\n        if(comp[now]!=-1) return ;\n        comp[now]=cnt;\n        for(int x:from[now]) rdfs(x,cnt);\n    }\n    vector<vector<int>> build(){\n        vector<vector<int>> t;\n        for(int i=0;i<to.size();i++) dfs(i);\n        reverse(order.begin(),order.end());\n        int ptr=0;\n        for(int i:order)if(comp[i]==-1)rdfs(i,ptr),ptr++;\n \n        t.resize(ptr);\n        for(int i=0;i<g.size();i++){\n            for(auto v:to[i]){\n                int x=comp[i],y=comp[v];\n                if(x==y) continue;\n                t[x].push_back(y);\n            }\n        }\n        return t;\n    }\n};\n \n// need SCC\nstruct TwoSat{\n    int sz;\n    vector<vector<int>> g;\n    TwoSat(int v):sz(v),g(2*v){}\n    // !x\n    inline int rev(int x){\n        if(x>=sz) return x-sz;\n        else return x+sz;\n    }\n    // u->v <=> !v->!u 2つ同時に張る\n    void add_if(int u,int v){\n        g[u].push_back(v);\n        g[rev(v)].push_back(rev(u));\n    }\n    // u+v <=> !u->v and !v->u\n    void add_or(int u,int v){\n        add_if(rev(u),v);\n    }\n    // not(u*v) <=> u->!v and v->!u\n    void add_nand(int u,int v){\n        add_if(u,rev(v));\n    }\n    // u <=> !u->u \n    void set_true(int u){\n        g[rev(u)].push_back(u);\n    }\n    // !u <=> u->!u\n    void set_false(int u){\n        g[u].push_back(rev(u));\n    }\n \n    vector<int> build(){\n        StronglyConnectedComponents scc(g);\n        auto t=scc.build();\n        vector<int> ret(sz);\n        for(int i=0;i<sz;i++){\n            if(scc[i]==scc[rev(i)]) return vector<int>();\n            ret[i]=(scc[i]>scc[rev(i)]);\n        }\n        return ret;\n    }\n};\n\n\nsigned main(){\n    int n;ll d;cin>>n>>d;\n    ll x[n],y[n];\n    rep(i,n) cin>>x[i]>>y[i];\n\n    TwoSat ts(n);\n\n    rep(i,n)rep(j,n)if(i!=j){\n        if(abs(x[i]-x[j])<d) ts.add_if(ts.rev(i),j);\n        if(abs(x[i]-y[j])<d) ts.add_if(ts.rev(i),ts.rev(j));\n        if(abs(y[i]-x[j])<d) ts.add_if(i,j);\n        if(abs(y[i]-y[j])<d) ts.add_if(i,ts.rev(j));\n    }\n    auto res=ts.build();\n    if(res.empty()) cout<<\"No\"<<endl;\n    else{\n        cout<<\"Yes\"<<endl;\n        rep(i,n){\n            if(res[i]) cout<<y[i]<<endl;\n            else cout<<x[i]<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nint main(){\n  int n, d;\n  cin >> n >> d;\n  int x[n][2];\n  rep(i,n) rep(j,2) cin >> x[i][j];\n  two_sat ts(n);\n  rep(i,n) {\n    for(int j = i+1; j < n; j++) {\n      rep(k,2) {\n        rep(l,2) {\n          if(abs(x[i][k]-x[j][l]) < d) ts.add_clause(i,!k,j,!l);\n        }\n      }\n    }\n  }\n  if(!ts.satisfiable()) cout << \"No\" << endl;\n  else {\n    cout << \"Yes\" << endl;\n    vector<bool> ans = ts.answer();\n    rep(i,n) cout << x[i][ans[i]] << endl; \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\nint main() {\n\tint N, D;\n\tcin >> N >> D;\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; ++ i) cin >> X[i] >> Y[i];\n\n\tvector<pair<int,int>> a;\n\tfor (int i = 0; i < N; ++ i) {\n\t\ta.push_back({X[i], i});\n\t\ta.push_back({Y[i], i+N});\n\t}\n\tsort(a.begin(), a.end());\n\n\ttwo_sat ts(2*N);\n\tfor (int i = 0; i < N; ++ i) ts.add_clause(i, true, i+N, true);\n\tfor (int i = 0; i < 2*N; ++ i) {\n\t\tfor (int j = i+1; j < 2*N && a[j].first - a[i].first < D; ++ j) {\n\t\t\tts.add_clause(a[i].second, false, a[j].second, false);\n\t\t}\n\t}\n\tif (ts.satisfiable()) {\n\t\tcout << \"Yes\" << endl;\n\t\tauto b = ts.answer();\n\t\tfor (int i = 0; i < N; ++ i) {\n\t\t\tcout << (b[i] ? X[i] : Y[i]) << endl;\n\t\t}\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <atcoder/modint>\n\n#include <atcoder/math>\n#include <atcoder/fenwicktree>\n#include <atcoder/convolution>\n#include <atcoder/scc>\n#include <atcoder/twosat>\n\n#include <cstdio>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n\nusing namespace std;\ntypedef long long ll;\n\nusing namespace atcoder;\n\nll mod2 = 998244353;\n\nint main()\n{\n    int n, d;\n    scanf(\"%d %d\", &n, &d);\n\n    vector<int> x(n), y(n);\n    FOR (i, 0, n) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat TS(n);\n\n    FOR (i, 0, n) {\n        FOR (j, i + 1, n) {\n            if (abs(x[i] - x[j]) < d) {\n                TS.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                TS.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                TS.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                TS.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!TS.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = TS.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i]) {\n            printf(\"%d\\n\", x[i]);\n        } else {\n            printf(\"%d\\n\", y[i]);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma region template\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\ttemplate <size_t N = 0, class T> static void input_tuple(T& v) {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\ti(get<N>(v));\n\t\t\tinput_tuple<N + 1>(v);\n\t\t}\n\t}\n\ttemplate <class... T> static void i(tuple<T...>& v) {\n\t\tinput_tuple(v);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string read_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n\nprivate:\n\ttemplate <template <class...> class, class...> struct Multiple;\n\ttemplate <template <class...> class V, class Head, class... Tail> struct Multiple<V, Head, Tail...> {\n\t\ttemplate <class... Args> using vec = V<vector<Head>, Args...>;\n\t\tusing type = typename Multiple<vec, Tail...>::type;\n\t};\n\ttemplate <template <class...> class V> struct Multiple<V> { using type = V<>; };\n\ttemplate <class... T> using multiple_t = typename Multiple<tuple, T...>::type;\n\ttemplate <size_t N = 0, class T> void in_multiple(T& t) const {\n\t\tif constexpr (N < tuple_size_v<T>) {\n\t\t\tauto& vec = get<N>(t);\n\t\t\tusing V = typename remove_reference_t<decltype(vec)>::value_type;\n\t\t\tvec.push_back(in<V>());\n\t\t\tin_multiple<N + 1>(t);\n\t\t}\n\t}\n\npublic:\n\ttemplate <class... T> auto multiple(int H) const {\n\t\tmultiple_t<T...> res;\n\t\twhile (H--) in_multiple(res);\n\t\treturn res;\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tchar buf[12]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(long long v) const {\n\t\tchar buf[21]{};\n\t\tif (auto [ptr, e] = to_chars(begin(buf), end(buf), v); e == errc{}) {\n\t\t\tfwrite(buf, sizeof(char), ptr - buf, stdout);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T size() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T size() const {\n\t\treturn be.size();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * size() + step() * (size() * (size() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(size());\n\t\tfor (auto i : *this) {\n\t\t\tres.push_back(i);\n\t\t}\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- Ruby --- //\ntemplate <class F> struct Callable {\n\tF func;\n\tCallable(const F& f) : func(f) {}\n};\ntemplate <class T, class F> auto operator|(const T& v, const Callable<F>& c) {\n\treturn c.func(v);\n}\n\nstruct Sort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(begin(v), end(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sort_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\treturn v;\n\t}\n} Sort;\nstruct RSort_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tsort(rbegin(v), rend(v), f);\n\t\t\treturn v;\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const RSort_impl& c) {\n\t\tsort(rbegin(v), rend(v));\n\t\treturn v;\n\t}\n} RSort;\nstruct Reverse_impl {\n\ttemplate <class T> friend auto operator|(T v, const Reverse_impl& c) {\n\t\treverse(begin(v), end(v));\n\t\treturn v;\n\t}\n} Reverse;\nstruct Unique_impl {\n\ttemplate <class T> friend auto operator|(T v, const Unique_impl& c) {\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Unique;\nstruct Uniq_impl {\n\ttemplate <class T> friend auto operator|(T v, const Uniq_impl& c) {\n\t\tsort(begin(v), end(v));\n\t\tv.erase(unique(begin(v), end(v), end(v)));\n\t\treturn v;\n\t}\n} Uniq;\nstruct Rotate_impl {\n\ttemplate <class F> auto operator()(int left) {\n\t\treturn Callable([&](auto v) {\n\t\t\trotate(begin(v), begin(v) + left, end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} Rotate;\nstruct Max_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *max_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Max_impl& c) {\n\t\treturn *max_element(begin(v), end(v));\n\t}\n} Max;\nstruct Min_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn *min_element(begin(v), end(v), f);\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Min_impl& c) {\n\t\treturn *min_element(begin(v), end(v));\n\t}\n} Min;\nstruct MaxPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MaxPos_impl& c) {\n\t\treturn max_element(begin(v), end(v)) - begin(v);\n\t}\n} MaxPos;\nstruct MinPos_impl {\n\ttemplate <class T> friend auto operator|(T v, const MinPos_impl& c) {\n\t\treturn min_element(begin(v), end(v)) - begin(v);\n\t}\n} MinPos;\nstruct MaxBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_it = begin(v);\n\t\t\tauto max_val = f(*max_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_it = it;\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *max_it;\n\t\t});\n\t}\n} MaxBy;\nstruct MinBy_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_it = begin(v);\n\t\t\tauto min_val = f(*min_it);\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_it = it;\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn *min_it;\n\t\t});\n\t}\n} MinBy;\nstruct MaxOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto max_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); max_val < val) {\n\t\t\t\t\tmax_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_val;\n\t\t});\n\t}\n} MaxOf;\nstruct MinOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tauto min_val = f(*begin(v));\n\t\t\tfor (auto it = next(begin(v)); it != end(v); ++it) {\n\t\t\t\tif (auto val = f(*it); min_val > val) {\n\t\t\t\t\tmin_val = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min_val;\n\t\t});\n\t}\n} MinOf;\nstruct Count_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count(begin(v), end(v), val);\n\t\t});\n\t}\n} Count;\nstruct CountIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn count_if(begin(v), end(v), f);\n\t\t});\n\t}\n} CountIf;\nstruct Index_impl {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find(begin(v), end(v), val);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} Index;\nstruct IndexIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<int> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(res - begin(v)) : nullopt;\n\t\t});\n\t}\n} IndexIf;\nstruct FindIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) -> optional<typename decltype(v)::value_type> {\n\t\t\tauto res = find_if(begin(v), end(v), f);\n\t\t\treturn res != end(v) ? optional(*res) : nullopt;\n\t\t});\n\t}\n} FindIf;\nstruct Sum_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn accumulate(next(begin(v)), end(v), f(*begin(v)), [&](const auto& a, const auto& b) {\n\t\t\t\treturn a + f(b);\n\t\t\t});\n\t\t});\n\t}\n\ttemplate <class T> friend auto operator|(T v, const Sum_impl& c) {\n\t\treturn accumulate(begin(v), end(v), typename T::value_type());\n\t}\n} Sum;\nstruct Includes {\n\ttemplate <class V> auto operator()(const V& val) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find(begin(v), end(v), val) != end(v);\n\t\t});\n\t}\n} Includes;\nstruct IncludesIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\treturn find_if(begin(v), end(v), f) != end(v);\n\t\t});\n\t}\n} IncludesIf;\nstruct RemoveIf_impl {\n\ttemplate <class F> auto operator()(const F& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tv.erase(remove_if(begin(v), end(v), f), end(v));\n\t\t\treturn v;\n\t\t});\n\t}\n} RemoveIf;\nstruct Each_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tf(i);\n\t\t\t}\n\t\t});\n\t}\n} Each;\nstruct Select_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing value_type = typename decltype(v)::value_type;\n\t\t\tvector<value_type> res;\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) res.push_back(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Select;\nstruct Map_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tusing result_type = invoke_result_t<F, typename decltype(v)::value_type>;\n\t\t\tvector<result_type> res;\n\t\t\tres.reserve(size(v));\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tres.push_back(f(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\t}\n} Map;\nstruct Indexed_impl {\n\ttemplate <class T> friend auto operator|(const T& v, Indexed_impl& c) {\n\t\tusing value_type = typename T::value_type;\n\t\tvector<pair<value_type, int>> res;\n\t\tres.reserve(size(v));\n\t\tint index = 0;\n\t\tfor (const auto& i : v) {\n\t\t\tres.emplace_back(i, index++);\n\t\t}\n\t\treturn res;\n\t}\n} Indexed;\nstruct AllOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (!f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} AllOf;\nstruct AnyOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n} AnyOf;\nstruct NoneOf_impl {\n\ttemplate <class F> auto operator()(F&& f) {\n\t\treturn Callable([&](auto v) {\n\t\t\tfor (const auto& i : v) {\n\t\t\t\tif (f(i)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n} NoneOf;\n\n// --- functions --- //\ntemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\treturn lower_bound(all(a), v) - a.begin();\n}\ntemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\treturn upper_bound(all(a), v) - a.begin();\n}\ntemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n}\ninline auto operator*(string s, size_t n) {\n\tstring res;\n\tfor (size_t i = 0; i < n; ++i) res += s;\n\treturn res;\n}\ntemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\tv.insert(v.end(), all(v2));\n\treturn v;\n}\ntemplate <class T> inline T Ceil(T n, T m) {\n\treturn (n + m - 1) / m;\n}\ntemplate <class T> inline T Ceil2(T n, T m) {\n\treturn Ceil(n, m) * m;\n}\ntemplate <class T> inline T Tri(T n) {\n\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n}\ntemplate <class T> inline T nC2(T n) {\n\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n}\ntemplate <class T> inline T Mid(const T& l, const T& r) {\n\treturn l + (r - l) / 2;\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool chmin(T& a, const T& b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\treturn min <= v && v < max;\n}\ntemplate <class T> inline bool isSquere(T n) {\n\tT s = sqrt(n);\n\treturn s * s == n || (s + 1) * (s + 1) == n;\n}\ntemplate <class T = long long> inline T BIT(int b) {\n\treturn T(1) << b;\n}\ntemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), gcd<U, U>);\n}\ntemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), lcm<U, U>);\n}\ntemplate <class T> inline T Pow(T a, T n) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) r *= a;\n\t\ta *= a;\n\t\tn /= 2;\n\t}\n\treturn r;\n}\ntemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\tT r = 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tr = r * a % m, n--;\n\t\telse\n\t\t\ta = a * a % m, n /= 2;\n\t}\n\treturn r;\n}\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n#pragma endregion\n\n// ---------------------------------------------------------------- //\n\nnamespace atcoder {\n\tnamespace internal {\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges) : start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() {\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\tvoid add_edge(int from, int to) {\n\t\t\t\tedges.push_back({from, {to}});\n\t\t\t}\n\n\t\t\t// @return pair of (# of scc, scc id)\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn {group_num, ids};\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\t}  // namespace internal\n}  // namespace atcoder\n\nint n, d;\nint x[1001], y[1001];\n\nint main() {\n\tin(n, d);\n\n\tatcoder::internal::scc_graph scc(2 * n);\n\tauto add_clause = [&](int i, bool f, int j, bool g) {\n\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t};\n\n\trep(i, n) in(x[i], y[i]);\n\trep(i, n) FOR(j, i + 1, n) {\n\t\tif (abs(x[i] - x[j]) < d) {\n\t\t\tadd_clause(i, true, j, true);\n\t\t}\n\t\tif (abs(x[i] - y[j]) < d) {\n\t\t\tadd_clause(i, true, j, false);\n\t\t}\n\t\tif (abs(y[i] - x[j]) < d) {\n\t\t\tadd_clause(i, false, j, true);\n\t\t}\n\t\tif (abs(y[i] - y[j]) < d) {\n\t\t\tadd_clause(i, false, j, false);\n\t\t}\n\t}\n\n\tauto id = scc.scc_ids().second;\n\tbitset<1001> ans;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\tout.exit(false);\n\t\t}\n\t\tif (id[2 * i] < id[2 * i + 1]) ans.set(i);\n\t}\n\n\tout(true);\n\trep(i, n) out(ans.test(i) ? y[i] : x[i]);\n}"
  },
  {
    "language": "Lua",
    "code": "local mab = math.abs\nlocal n, d = io.read(\"*n\", \"*n\")\nlocal edge = {}\nlocal edge_asked = {}\nlocal invedge = {}\nlocal invedge_asked = {}\nfor i = 1, 2 * n do\n  edge[i] = {}\n  edge_asked[i] = 0\n  invedge[i] = {}\n  invedge_asked[i] = 0\nend\nlocal edgeinfo = {}\nlocal xs, ys = {}, {}\nfor i = 1, n do\n  xs[i], ys[i] = io.read(\"*n\", \"*n\")\nend\nlocal function addedge(src, dst)\n  table.insert(edgeinfo, {src, dst})\n  table.insert(edge[src], dst)\n  table.insert(invedge[dst], src)\nend\nfor i = 1, n - 1 do\n  for j = i + 1, n do\n    f1 = mab(xs[i] - xs[j]) < d\n    f2 = mab(xs[i] - ys[j]) < d\n    f3 = mab(ys[i] - xs[j]) < d\n    f4 = mab(ys[i] - ys[j]) < d\n    if f1 and not f2 then addedge(i, n + j) end\n    if f2 and not f1 then addedge(i, j) end\n    if f3 and not f4 then addedge(n + i, n + j) end\n    if f4 and not f3 then addedge(n + i, j) end\n    if f1 and not f3 then addedge(j, n + i) end\n    if f3 and not f1 then addedge(j, i) end\n    if f2 and not f4 then addedge(n + j, n + i) end\n    if f4 and not f2 then addedge(n + j, i) end\n\n    if f1 and f2 then addedge(i, n + i) end\n    if f3 and f4 then addedge(n + i, i) end\n    if f1 and f3 then addedge(j, n + j) end\n    if f2 and f4 then addedge(n + j, j) end\n  end\nend\nlocal rawn = n\nn = n * 2\n\nlocal asked = {}\nlocal sccd_root = {}\nfor i = 1, n do\n  asked[i] = false\n  sccd_root[i] = 0\nend\n\nlocal function SCCD_dfs(spos, dfs_way)\n  local tasks = {spos}\n  while 0 < #tasks do\n    local src = tasks[#tasks]\n    asked[src] = true\n    table.remove(tasks)\n    if edge_asked[src] == #edge[src] then\n      table.insert(dfs_way, src)\n    else\n      table.insert(tasks, src)\n      edge_asked[src] = edge_asked[src] + 1\n      local dst = edge[src][edge_asked[src]]\n      if not asked[dst] then\n        table.insert(tasks, dst)\n      end\n    end\n  end\nend\n\nlocal function SCCD_invdfs(spos, rootid)\n  local tasks = {spos}\n  while 0 < #tasks do\n    local src = tasks[#tasks]\n    sccd_root[src] = rootid\n    table.remove(tasks)\n    while invedge_asked[src] < #invedge[src] do\n      invedge_asked[src] = invedge_asked[src] + 1\n      local dst = invedge[src][invedge_asked[src]]\n      if asked[dst] and sccd_root[dst] == 0 then\n        table.insert(tasks, src)\n        table.insert(tasks, dst)\n        break\n      end\n    end\n  end\nend\n\nlocal function SCCD_categorize()\n  for src = 1, n do\n    if not asked[src] then\n      local dfs_way = {}\n      SCCD_dfs(src, dfs_way)\n      for i = #dfs_way, 1, -1 do\n        local src = dfs_way[i]\n        if sccd_root[src] == 0 then\n          SCCD_invdfs(src, src)\n        end\n      end\n    end\n  end\nend\n\nlocal gsize = {}\nlocal gedge, ginvedge = {}, {}\nlocal glen = {}\nlocal gmember = {}\n\nlocal function SCCD_make_group_graph()\n  for i = 1, n do\n    gsize[i] = 0\n    gedge[i], ginvedge[i] = {}, {}\n    glen[i] = 0\n    gmember[i] = {}\n  end\n  for i = 1, n do\n    local r = sccd_root[i]\n    gsize[r] = gsize[r] + 1\n    table.insert(gmember[r], i)\n  end\n  for i = 1, #edgeinfo do\n    local a, b = edgeinfo[i][1], edgeinfo[i][2]\n    local ra, rb = sccd_root[a], sccd_root[b]\n    if ra ~= rb then\n      table.insert(gedge[ra], rb)\n      table.insert(ginvedge[rb], ra)\n    end\n  end\nend\n\nlocal function SCCD_toposort()\n  local topo_tasks = {}\n  local topo_asked_cnt = {}\n  for i = 1, n do\n    topo_asked_cnt[i] = 0\n    if 0 < gsize[i] and #ginvedge[i] == 0 then\n      table.insert(topo_tasks, i)\n    end\n  end\n  local topoary = {}\n  local topo_done = 0\n  while topo_done < #topo_tasks do\n    topo_done = topo_done + 1\n    local g = topo_tasks[topo_done]\n    topoary[topo_done] = g\n    for i = 1, #gedge[g] do\n      local dst = gedge[g][i]\n      topo_asked_cnt[dst] = topo_asked_cnt[dst] + 1\n      if topo_asked_cnt[dst] == #ginvedge[dst] then\n        table.insert(topo_tasks, dst)\n      end\n    end\n  end\n  return topoary\nend\n\nSCCD_categorize()\nSCCD_make_group_graph()\n\nfor i = 1, rawn do\n  if sccd_root[i] == sccd_root[i + rawn] then\n    print(\"No\") os.exit()\n  end\nend\nprint(\"Yes\")\nlocal determined = {}\nlocal retpos = {}\nfor i = 1, rawn do\n  determined[i] = false\n  retpos[i] = -1\nend\n\nlocal topoary = SCCD_toposort()\nfor i = 1, #topoary do\n  local g = topoary[i]\n  for j = 1, #gmember[g] do\n    local idx = gmember[g][j]\n    if idx <= rawn then\n      if not determined[idx] then\n        retpos[idx] = ys[idx]\n        determined[idx] = true\n      end\n    else\n      if not determined[idx - rawn] then\n        retpos[idx - rawn] = xs[idx - rawn]\n        determined[idx - rawn] = true\n      end\n    end\n  end\nend\nprint(table.concat(retpos, \"\\n\"))\n"
  },
  {
    "language": "Lua",
    "code": "local mab = math.abs\nlocal n, d = io.read(\"*n\", \"*n\")\nlocal edge = {}\nlocal edge_asked = {}\nlocal invedge = {}\nlocal invedge_asked = {}\nfor i = 1, 2 * n do\n  edge[i] = {}\n  edge_asked[i] = 0\n  invedge[i] = {}\n  invedge_asked[i] = 0\nend\nlocal edgeinfo = {}\nlocal xs, ys = {}, {}\nfor i = 1, n do\n  xs[i], ys[i] = io.read(\"*n\", \"*n\")\nend\nlocal function addedge(src, dst)\n  table.insert(edgeinfo, {src, dst})\n  table.insert(edge[src], dst)\n  table.insert(invedge[dst], src)\nend\nfor i = 1, n - 1 do\n  for j = i + 1, n do\n    f1 = mab(xs[i] - xs[j]) < d\n    f2 = mab(xs[i] - ys[j]) < d\n    f3 = mab(ys[i] - xs[j]) < d\n    f4 = mab(ys[i] - ys[j]) < d\n    if f1 and f2 and f3 and f4 then print(\"No\") os.exit() end\n    if f1 and not f2 then addedge(i, n + j) end\n    if f2 and not f1 then addedge(i, j) end\n    if f3 and not f4 then addedge(n + i, n + j) end\n    if f4 and not f3 then addedge(n + i, j) end\n    if f1 and not f3 then addedge(j, n + i) end\n    if f3 and not f1 then addedge(j, i) end\n    if f2 and not f4 then addedge(n + j, n + i) end\n    if f4 and not f2 then addedge(n + j, i) end\n  end\nend\nlocal rawn = n\nn = n * 2\n\nlocal asked = {}\nlocal sccd_root = {}\nfor i = 1, n do\n  asked[i] = false\n  sccd_root[i] = 0\nend\n\nlocal function SCCD_dfs(spos, dfs_way)\n  local tasks = {spos}\n  while 0 < #tasks do\n    local src = tasks[#tasks]\n    asked[src] = true\n    table.remove(tasks)\n    if edge_asked[src] == #edge[src] then\n      table.insert(dfs_way, src)\n    else\n      table.insert(tasks, src)\n      edge_asked[src] = edge_asked[src] + 1\n      local dst = edge[src][edge_asked[src]]\n      if not asked[dst] then\n        table.insert(tasks, dst)\n      end\n    end\n  end\nend\n\nlocal function SCCD_invdfs(spos, rootid)\n  local tasks = {spos}\n  while 0 < #tasks do\n    local src = tasks[#tasks]\n    sccd_root[src] = rootid\n    table.remove(tasks)\n    while invedge_asked[src] < #invedge[src] do\n      invedge_asked[src] = invedge_asked[src] + 1\n      local dst = invedge[src][invedge_asked[src]]\n      if asked[dst] and sccd_root[dst] == 0 then\n        table.insert(tasks, src)\n        table.insert(tasks, dst)\n        break\n      end\n    end\n  end\nend\n\nlocal function SCCD_categorize()\n  for src = 1, n do\n    if not asked[src] then\n      local dfs_way = {}\n      SCCD_dfs(src, dfs_way)\n      for i = #dfs_way, 1, -1 do\n        local src = dfs_way[i]\n        if sccd_root[src] == 0 then\n          SCCD_invdfs(src, src)\n        end\n      end\n    end\n  end\nend\n\nlocal gsize = {}\nlocal gedge, ginvedge = {}, {}\nlocal glen = {}\nlocal gmember = {}\n\nlocal function SCCD_make_group_graph()\n  for i = 1, n do\n    gsize[i] = 0\n    gedge[i], ginvedge[i] = {}, {}\n    glen[i] = 0\n    gmember[i] = {}\n  end\n  for i = 1, n do\n    local r = sccd_root[i]\n    gsize[r] = gsize[r] + 1\n    table.insert(gmember[r], i)\n  end\n  for i = 1, #edgeinfo do\n    local a, b = edgeinfo[i][1], edgeinfo[i][2]\n    local ra, rb = sccd_root[a], sccd_root[b]\n    if ra ~= rb then\n      table.insert(gedge[ra], rb)\n      table.insert(ginvedge[rb], ra)\n    end\n  end\nend\n\nlocal function SCCD_toposort()\n  local topo_tasks = {}\n  local topo_asked_cnt = {}\n  for i = 1, n do\n    topo_asked_cnt[i] = 0\n    if 0 < gsize[i] and #ginvedge[i] == 0 then\n      table.insert(topo_tasks, i)\n    end\n  end\n  local topoary = {}\n  local topo_done = 0\n  while topo_done < #topo_tasks do\n    topo_done = topo_done + 1\n    local g = topo_tasks[topo_done]\n    topoary[topo_done] = g\n    for i = 1, #gedge[g] do\n      local dst = gedge[g][i]\n      topo_asked_cnt[dst] = topo_asked_cnt[dst] + 1\n      if topo_asked_cnt[dst] == #ginvedge[dst] then\n        table.insert(topo_tasks, dst)\n      end\n    end\n  end\n  return topoary\nend\n\nSCCD_categorize()\nSCCD_make_group_graph()\n\nfor i = 1, rawn do\n  if sccd_root[i] == sccd_root[i + rawn] then\n    print(\"No\") os.exit()\n  end\nend\nprint(\"Yes\")\nlocal determined = {}\nlocal retpos = {}\nfor i = 1, rawn do\n  determined[i] = false\n  retpos[i] = -1\nend\n\nlocal topoary = SCCD_toposort()\nfor i = 1, #topoary do\n  local g = topoary[i]\n  for j = 1, #gmember[g] do\n    local idx = gmember[g][j]\n    if idx <= rawn then\n      if not determined[idx] then\n        retpos[idx] = ys[idx]\n        determined[idx] = true\n      end\n    else\n      if not determined[idx - rawn] then\n        retpos[idx - rawn] = xs[idx - rawn]\n        determined[idx - rawn] = true\n      end\n    end\n  end\nend\nprint(table.concat(retpos, \"\\n\"))\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns, BinaryLiterals, CPP, DerivingStrategies  #-}\n{-# LANGUAGE DerivingVia, FlexibleContexts, FlexibleInstances       #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving, KindSignatures, LambdaCase #-}\n{-# LANGUAGE MagicHash, MultiParamTypeClasses, MultiWayIf           #-}\n{-# LANGUAGE NumericUnderscores, OverloadedStrings, PatternSynonyms #-}\n{-# LANGUAGE RankNTypes, RecordWildCards, ScopedTypeVariables       #-}\n{-# LANGUAGE StandaloneDeriving, TupleSections, TypeApplications    #-}\n{-# LANGUAGE TypeFamilies, TypeInType, UnboxedTuples, ViewPatterns  #-}\n\nimport           Control.Applicative\nimport           Control.Exception\nimport           Control.Monad\nimport           Control.Monad.Primitive\nimport           Control.Monad.Reader\nimport           Control.Monad.ST\nimport           Control.Monad.State.Strict\nimport           Data.Bifunctor\nimport           Data.Bool\nimport qualified Data.ByteString                   as B\nimport qualified Data.ByteString.Builder           as B\nimport qualified Data.ByteString.Char8             as C\nimport qualified Data.ByteString.Internal          as B\nimport qualified Data.ByteString.Unsafe            as B\nimport           Data.Char\nimport qualified Data.Foldable                     as F\nimport           Data.Function\nimport           Data.Functor.Identity\nimport qualified Data.IntMap.Strict                as IM\nimport qualified Data.IntSet                       as IS\nimport qualified Data.List                         as L\nimport qualified Data.Map.Strict                   as M\nimport           Data.Monoid\nimport           Data.Ord\nimport           Data.Primitive\nimport           Data.Proxy\nimport           Data.Ratio\nimport           Data.Semigroup\nimport qualified Data.Set                          as S\nimport           Data.Tuple\nimport qualified Data.Vector                       as V\nimport qualified Data.Vector.Algorithms.Intro      as Intro\nimport qualified Data.Vector.Fusion.Stream.Monadic as MS\nimport qualified Data.Vector.Fusion.Bundle.Monadic as MB\nimport           Data.Vector.Fusion.Util\nimport qualified Data.Vector.Generic               as G\nimport qualified Data.Vector.Generic.Mutable       as GM\nimport qualified Data.Vector.Mutable               as VM\nimport qualified Data.Vector.Primitive             as P\nimport qualified Data.Vector.Primitive.Mutable     as PM\nimport qualified Data.Vector.Unboxed               as U\nimport qualified Data.Vector.Unboxed.Mutable       as UM\nimport           Debug.Trace\nimport           Foreign                           hiding (void)\nimport           GHC.Exts\nimport           GHC.TypeLits\nimport           System.IO\nimport           Unsafe.Coerce\n\n#define MOD 1000000007\n\nmain :: IO ()\nmain = do\n    [n, d] <- map read.words <$> getLine\n    xys <- U.unfoldrN n (runParser $ (,) <$> int <*> int) <$> C.getContents\n    case solve n d xys of\n        Just res -> do\n            putStrLn \"Yes\"\n            putStrLn.unlines.map show.U.toList $ res\n        Nothing -> putStrLn \"No\"\n\n-- True: x, False: y\nsolve :: Int -> Int -> U.Vector (Int, Int) -> Maybe (U.Vector Int)\nsolve n d xys = fmap (U.zipWith answer xys) $ twoSat n $ \\builder -> do\n    rep n $ \\i -> do\n        flip MS.mapM_ (stream (i + 1) n) $ \\j -> do\n            let (xi, yi) = xys U.! i\n                (xj, yj) = xys U.! j\n            when (abs (xi - xj) < d) $ do\n                addClauseCNF builder (i, not True) (j, False)\n            when (abs (xi - yj) < d) $ do\n                addClauseCNF builder (i, not True) (j, True)\n            when (abs (yi - xj) < d) $ do\n                addClauseCNF builder (i, not False) (j, False)\n            when (abs (yi - yj) < d) $ do\n                addClauseCNF builder (i, not False) (j, True)\n  where\n    answer (x, y) True = x\n    answer (x, y) False = y\n\ntwoSat :: Int -> (forall s.CNFBuilder s () -> ST s ()) -> Maybe (U.Vector Bool)\ntwoSat n run\n    | satisfiable = Just $ U.generate n (\\i -> comp U.! i > comp U.! (i + offset))\n    | otherwise = Nothing\n  where\n    satisfiable = U.and $ U.generate n (\\i -> comp U.! i /= comp U.! (i + offset))\n    gr = buildSparseGraph (2 * n) run\n    offset = n\n    scc = stronglyConnectedComponents gr\n    !comp = U.create $ do\n        cs <- UM.unsafeNew (2 * n)\n        forM_ (zip[(0::Int)..]scc) $ \\(i, c) -> do\n            U.forM_ c $ \\x -> UM.unsafeWrite cs x i\n        return cs\n\ntype CNFBuilder s w = SparseGraphBuilder s w\n\naddClauseCNF :: (PrimMonad m) => CNFBuilder (PrimState m) ()\n    -> (Int, Bool) -> (Int, Bool) -> m ()\naddClauseCNF builder (i, f) (j, g) = do\n    let !offset = quot (numVerticesSGB builder) 2\n    case (f, g) of\n        (True, True) -> do\n            addDirectedEdge_ builder (i + offset, j)\n            addDirectedEdge_ builder (j + offset, i)\n        (True, False) -> do\n            addDirectedEdge_ builder (i + offset, j + offset)\n            addDirectedEdge_ builder (j, i)\n        (False, True) -> do\n            addDirectedEdge_ builder (i, j)\n            addDirectedEdge_ builder (j + offset, i + offset)\n        (False, False) -> do\n            addDirectedEdge_ builder (i, j + offset)\n            addDirectedEdge_ builder (j, i + offset)\n\nnothingSCC :: Int\nnothingSCC = -1\n\nstronglyConnectedComponents :: SparseGraph w -> [U.Vector Vertex]\nstronglyConnectedComponents gr = runST $ do\n    let numV = numVerticesCSR gr\n    low <- UM.replicate numV nothingSCC\n    preord <- UM.replicate numV nothingSCC\n    stack <- newVecStack numV\n    onStack <- UM.replicate numV False\n    num <- newMutVar 0\n    components <- newMutVar []\n\n    rep numV $ \\root -> do\n        rootOrd <- UM.unsafeRead preord root\n        when (rootOrd == nothingSCC) $ do\n            flip fix root $ \\dfs v -> do\n                pord <- readMutVar num <* modifyMutVar' num (+1)\n                UM.unsafeWrite preord v pord >> UM.unsafeWrite low v pord\n\n                pushVS v stack >> UM.unsafeWrite onStack v True\n\n                U.forM_ (adj gr v) $ \\u -> do\n                    isVisited <- (/= nothingSCC) <$> UM.unsafeRead preord u\n                    if isVisited\n                    then do\n                        onS <- UM.unsafeRead onStack u\n                        when onS $ do\n                            uOrd <- UM.unsafeRead preord u\n                            UM.unsafeModify low (min uOrd) v\n                    else do\n                        dfs u\n                        uLow <- UM.unsafeRead low u\n                        UM.unsafeModify low (min uLow) v\n\n                isRoot <- (==)\n                    <$> UM.unsafeRead low v\n                    <*> UM.unsafeRead preord v\n                when isRoot $ do\n                    flip fix 1 $ \\loop !i -> do\n                        popVS stack >>= \\case\n                            Just x\n                                | x /= v -> loop (i + 1)\n                                | otherwise -> do\n                                    o <- UM.unsafeRead (intVarsVS stack) _sizeVS\n                                    component <- U.freeze $ UM.slice o i (internalVecStack stack)\n                                    U.mapM_ (flip (UM.unsafeWrite onStack) False) component\n                                    modifyMutVar' components (component:)\n                            Nothing -> undefined\n    readMutVar components\n\n-------------------------------------------------------------------------------\n-- Utils\n-------------------------------------------------------------------------------\nrep :: (Monad m) => Int -> (Int -> m ()) -> m ()\nrep n = flip MS.mapM_ (stream 0 n)\n{-# INLINE rep #-}\nrev :: (Monad m) => Int -> (Int -> m ()) -> m ()\nrev !n = flip MS.mapM_ (streamR 0 n)\n{-# INLINE rev #-}\nstream :: (Monad m) => Int -> Int -> MS.Stream m Int\nstream !l !r = MS.Stream step l where { step x | x < r = return $ MS.Yield x (x + 1) | otherwise = return MS.Done; {-# INLINE [0] step #-}}\n{-# INLINE [1] stream #-}\nstreamR :: (Monad m) => Int -> Int -> MS.Stream m Int\nstreamR !l !r = MS.Stream step (r - 1) where { step x | x >= l = return $ MS.Yield x (x - 1) | otherwise = return MS.Done; {-# INLINE [0] step #-}}\n{-# INLINE [1] streamR #-}\nstream' :: (Monad m) => Int -> Int -> Int -> MS.Stream m Int\nstream' !l !r !d = MS.Stream step l where { step x | x < r = return $ MS.Yield x (x + d) | otherwise = return MS.Done; {-# INLINE [0] step #-}}\n{-# INLINE [1] stream' #-}\ninfixl 8 `shiftRL`, `unsafeShiftRL`\nshiftRL :: Int -> Int -> Int\nshiftRL = unsafeShiftRL\n{-# INLINE shiftRL #-}\nunsafeShiftRL :: Int -> Int -> Int\nunsafeShiftRL (I# x#) (I# i#) = I# (uncheckedIShiftRL# x# i#)\n{-# INLINE unsafeShiftRL #-}\ntype Parser a = StateT C.ByteString Maybe a\nrunParser :: Parser a -> C.ByteString -> Maybe (a, C.ByteString)\nrunParser = runStateT\n{-# INLINE runParser #-}\nint :: Parser Int\nint = coerce $ C.readInt . C.dropWhile isSpace\n{-# INLINE int #-}\nint1 :: Parser Int\nint1 = fmap (subtract 1) int\n{-# INLINE int1 #-}\nchar :: Parser Char\nchar = coerce C.uncons\n{-# INLINE char #-}\nbyte :: Parser Word8\nbyte = coerce B.uncons\n{-# INLINE byte #-}\nskipSpaces :: Parser ()\nskipSpaces = modify' (C.dropWhile isSpace)\n{-# INLINE skipSpaces #-}\nlowerBoundM :: (Monad m) => Int -> Int -> (Int -> m Bool) -> m Int\nlowerBoundM low high p = go low high where { go !low !high | high <= low = return high | otherwise = p mid >>= bool (go (mid + 1) high) (go low mid) where { mid = low + unsafeShiftRL (high - low) 1}}\n{-# INLINE lowerBoundM #-}\nupperBoundM :: (Monad m) => Int -> Int -> (Int -> m Bool) -> m Int\nupperBoundM low high p = do { flg <- p high; if flg then return high else subtract 1 <$!> lowerBoundM low high (fmap not . p)}\n{-# INLINE upperBoundM #-}\nlowerBound :: Int -> Int -> (Int -> Bool) -> Int\nlowerBound low high p = runIdentity (lowerBoundM low high (return . p))\n{-# INLINE lowerBound #-}\nupperBound :: Int -> Int -> (Int -> Bool) -> Int\nupperBound low high p = runIdentity (upperBoundM low high (return . p))\n{-# INLINE upperBound #-}\n-------------------------------------------------------------------------------\n-- Data.VecQueue\n-------------------------------------------------------------------------------\ndata VecQueue s a = VecQueue{intVarsVQ :: !(UM.MVector s Int), internalVecQueue :: !(UM.MVector s a)}\n_dequeueCount :: Int\n_dequeueCount = 0\n{-# INLINE _dequeueCount #-}\n_enqueueCount :: Int\n_enqueueCount = 1\n{-# INLINE _enqueueCount #-}\nnewVecQueue :: (PrimMonad m, UM.Unbox a) => Int -> m (VecQueue (PrimState m) a)\nnewVecQueue n = VecQueue <$> UM.replicate 2 0 <*> UM.unsafeNew n\ndefaultVecQueueSize :: Int\ndefaultVecQueueSize = 1024 * 1024\nlengthVQ :: (PrimMonad m, UM.Unbox a) => VecQueue (PrimState m) a -> m Int\nlengthVQ (VecQueue info _) = (-) <$> UM.unsafeRead info _enqueueCount <*> UM.unsafeRead info _dequeueCount\n{-# INLINE lengthVQ #-}\ndequeueVQ :: (PrimMonad m, UM.Unbox a) => VecQueue (PrimState m) a -> m (Maybe a)\ndequeueVQ (VecQueue info q) = do { f <- UM.unsafeRead info _dequeueCount; r <- UM.unsafeRead info _enqueueCount; if f < r then do { UM.unsafeWrite info _dequeueCount (f + 1); pure <$> UM.unsafeRead q f} else return Nothing}\n{-# INLINE dequeueVQ #-}\nenqueueVQ :: (PrimMonad m, UM.Unbox a) => a -> VecQueue (PrimState m) a -> m ()\nenqueueVQ x (VecQueue info q) = do { r <- UM.unsafeRead info _enqueueCount; UM.unsafeWrite q r x; UM.unsafeWrite info _enqueueCount (r + 1)}\n{-# INLINE enqueueVQ #-}\nenqueuesVQ :: (PrimMonad m, UM.Unbox a) => U.Vector a -> VecQueue (PrimState m) a -> m ()\nenqueuesVQ vec (VecQueue info q) = do { r <- UM.unsafeRead info _enqueueCount; UM.unsafeWrite info _enqueueCount (r + U.length vec); U.unsafeCopy (UM.unsafeSlice r (U.length vec) q) vec}\n{-# INLINE enqueuesVQ #-}\nclearVQ :: (UM.Unbox a, PrimMonad m) => VecQueue (PrimState m) a -> m ()\nclearVQ (VecQueue info _) = do { UM.unsafeWrite info _dequeueCount 0; UM.unsafeWrite info _enqueueCount 0}\nfreezeVecQueue :: (PrimMonad m, UM.Unbox a) => VecQueue (PrimState m) a -> m (U.Vector a)\nfreezeVecQueue (VecQueue info q) = do { f <- UM.unsafeRead info _dequeueCount; r <- UM.unsafeRead info _enqueueCount; U.unsafeFreeze $ UM.unsafeSlice f (r - f) q}\n-------------------------------------------------------------------------------\n-- Data.VecStack\n-------------------------------------------------------------------------------\ndata VecStack s a = VecStack{intVarsVS :: !(UM.MVector s Int), internalVecStack :: !(UM.MVector s a)}\n_sizeVS :: Int\n_sizeVS = 0\n{-# INLINE _sizeVS #-}\nnewVecStack :: (PrimMonad m, UM.Unbox a) => Int -> m (VecStack (PrimState m) a)\nnewVecStack n = VecStack <$> UM.replicate 1 0 <*> UM.unsafeNew n\ndefaultVecStackSize :: Int\ndefaultVecStackSize = 1024 * 1024\npopVS :: (PrimMonad m, UM.Unbox a) => VecStack (PrimState m) a -> m (Maybe a)\npopVS (VecStack info s) = do { len <- UM.unsafeRead info _sizeVS; if len > 0 then do { UM.unsafeWrite info _sizeVS (len - 1); pure <$> UM.unsafeRead s (len - 1)} else return Nothing}\n{-# INLINE popVS #-}\npushVS :: (PrimMonad m, UM.Unbox a) => a -> VecStack (PrimState m) a -> m ()\npushVS x (VecStack info s) = do { len <- UM.unsafeRead info _sizeVS; UM.unsafeWrite s len x; UM.unsafeWrite info _sizeVS (len + 1)}\n{-# INLINE pushVS #-}\npushesVS :: (PrimMonad m, UM.Unbox a) => U.Vector a -> VecStack (PrimState m) a -> m ()\npushesVS vec (VecStack info s) = do { len <- UM.unsafeRead info _sizeVS; UM.unsafeWrite info _sizeVS (len + U.length vec); U.unsafeCopy (UM.unsafeSlice len (U.length vec) s) vec}\n{-# INLINE pushesVS #-}\nfreezeVecStack :: (PrimMonad m, U.Unbox a) => VecStack (PrimState m) a -> m (U.Vector a)\nfreezeVecStack (VecStack info s) = do { l <- UM.unsafeRead info _sizeVS; U.unsafeFreeze $ UM.take l s}\n{-# INLINE freezeVecStack #-}\n-------------------------------------------------------------------------------\n-- Data.Graph.Sparse\n-------------------------------------------------------------------------------\ntype Vertex = Int\ntype Edge = (Vertex, Vertex)\ntype EdgeWith w = (Vertex, Vertex, w)\ntype EdgeId = Int\ndata SparseGraph w = CSR{numVerticesCSR :: !Int, numEdgesCSR :: !Int, offsetCSR :: !(U.Vector Int), adjacentCSR :: !(U.Vector Vertex), edgeCtxCSR :: !(U.Vector w)}\ndata SparseGraphBuilder s w = SparseGraphBuilder{numVerticesSGB :: !Int, queueSGB :: VecQueue s (EdgeWith w), outDegSGB :: UM.MVector s Int}\nbuildSparseGraph :: (U.Unbox w) => Int -> (forall s . SparseGraphBuilder s w -> ST s ()) -> SparseGraph w\nbuildSparseGraph numVerticesCSR run = runST $ do { queueSGB <- newVecQueue (4 * 1024 * 1024); outDegSGB <- UM.replicate numVerticesCSR 0; run SparseGraphBuilder{numVerticesSGB = numVerticesCSR, ..}; numEdgesCSR <- lengthVQ queueSGB; offsetCSR <- U.scanl' (+) 0 <$> U.unsafeFreeze outDegSGB; moffset <- U.thaw offsetCSR; madj <- UM.unsafeNew numEdgesCSR; mectx <- UM.unsafeNew numEdgesCSR; edges <- freezeVecQueue queueSGB; U.forM_ edges $ \\ (src, dst, w) -> do { pos <- UM.unsafeRead moffset src; UM.unsafeWrite moffset src (pos + 1); UM.unsafeWrite madj pos dst; UM.unsafeWrite mectx pos w}; adjacentCSR <- U.unsafeFreeze madj; edgeCtxCSR <- U.unsafeFreeze mectx; return CSR{..}}\n{-# INLINE buildSparseGraph #-}\naddDirectedEdge :: (U.Unbox w, PrimMonad m) => SparseGraphBuilder (PrimState m) w -> EdgeWith w -> m ()\naddDirectedEdge SparseGraphBuilder{..} (src, dst, w) = do { enqueueVQ (src, dst, w) queueSGB; UM.unsafeModify outDegSGB (+ 1) src}\n{-# INLINE addDirectedEdge #-}\naddUndirectedEdge :: (U.Unbox w, PrimMonad m) => SparseGraphBuilder (PrimState m) w -> EdgeWith w -> m ()\naddUndirectedEdge SparseGraphBuilder{..} (src, dst, w) = do { enqueueVQ (src, dst, w) queueSGB; enqueueVQ (dst, src, w) queueSGB; UM.unsafeModify outDegSGB (+ 1) src; UM.unsafeModify outDegSGB (+ 1) dst}\n{-# INLINE addUndirectedEdge #-}\naddDirectedEdge_ :: (PrimMonad m) => SparseGraphBuilder (PrimState m) () -> Edge -> m ()\naddDirectedEdge_ SparseGraphBuilder{..} (src, dst) = do { enqueueVQ (src, dst, ()) queueSGB; UM.unsafeModify outDegSGB (+ 1) src}\n{-# INLINE addDirectedEdge_ #-}\naddUndirectedEdge_ :: (PrimMonad m) => SparseGraphBuilder (PrimState m) () -> Edge -> m ()\naddUndirectedEdge_ SparseGraphBuilder{..} (src, dst) = do { enqueueVQ (src, dst, ()) queueSGB; enqueueVQ (dst, src, ()) queueSGB; UM.unsafeModify outDegSGB (+ 1) src; UM.unsafeModify outDegSGB (+ 1) dst}\n{-# INLINE addUndirectedEdge_ #-}\nbuildDirectedGraph :: Int -> U.Vector Edge -> SparseGraph ()\nbuildDirectedGraph numVerticesCSR edges = buildSparseGraph numVerticesCSR $ \\ builder -> do { U.mapM_ (addDirectedEdge_ builder) edges}\nbuildUndirectedGraph :: Int -> U.Vector Edge -> SparseGraph ()\nbuildUndirectedGraph numVerticesCSR edges = buildSparseGraph numVerticesCSR $ \\ builder -> do { U.mapM_ (addUndirectedEdge_ builder) edges}\nbuildDirectedGraphW :: (U.Unbox w) => Int -> U.Vector (EdgeWith w) -> SparseGraph w\nbuildDirectedGraphW numVerticesCSR edges = buildSparseGraph numVerticesCSR $ \\ builder -> do { U.mapM_ (addDirectedEdge builder) edges}\nbuildUndirectedGraphW :: (U.Unbox w) => Int -> U.Vector (EdgeWith w) -> SparseGraph w\nbuildUndirectedGraphW numVerticesCSR edges = buildSparseGraph numVerticesCSR $ \\ builder -> do { U.mapM_ (addUndirectedEdge builder) edges}\nadj :: SparseGraph w -> Vertex -> U.Vector Vertex\nadj CSR{..} v = U.unsafeSlice o (o' - o) adjacentCSR where { o = U.unsafeIndex offsetCSR v; o' = U.unsafeIndex offsetCSR (v + 1)}\n{-# INLINE adj #-}\niadj :: SparseGraph w -> Vertex -> U.Vector (EdgeId, Vertex)\niadj CSR{..} v = U.imap ((,) . (+ o)) $ U.unsafeSlice o (o' - o) adjacentCSR where { o = U.unsafeIndex offsetCSR v; o' = U.unsafeIndex offsetCSR (v + 1)}\n{-# INLINE iadj #-}\nadjW :: (U.Unbox w) => SparseGraph w -> Vertex -> U.Vector (Vertex, w)\nadjW CSR{..} v = U.zip (U.unsafeSlice o (o' - o) adjacentCSR) (U.unsafeSlice o (o' - o) edgeCtxCSR) where { o = U.unsafeIndex offsetCSR v; o' = U.unsafeIndex offsetCSR (v + 1)}\n{-# INLINE adjW #-}\niadjW :: (U.Unbox w) => SparseGraph w -> Vertex -> U.Vector (EdgeId, Vertex, w)\niadjW CSR{..} v = U.izipWith (\\ i u w -> (i + o, u, w)) (U.unsafeSlice o (o' - o) adjacentCSR) (U.unsafeSlice o (o' - o) edgeCtxCSR) where { o = U.unsafeIndex offsetCSR v; o' = U.unsafeIndex offsetCSR (v + 1)}\n{-# INLINE iadjW #-}\noutEdges :: SparseGraph w -> Vertex -> U.Vector EdgeId\noutEdges CSR{..} v = U.generate (o' - o) (+ o) where { o = U.unsafeIndex offsetCSR v; o' = U.unsafeIndex offsetCSR (v + 1)}\n{-# INLINE outEdges #-}\noutDegree :: SparseGraph w -> Vertex -> Int\noutDegree CSR{..} v = U.unsafeIndex offsetCSR (v + 1) - U.unsafeIndex offsetCSR v\n{-# INLINE outDegree #-}\noutDegrees :: SparseGraph w -> U.Vector Int\noutDegrees CSR{..} = U.zipWith (-) offsetCSR $ U.tail offsetCSR\n{-# INLINE outDegrees #-}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list d[])\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * (N * 2 + 1)), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) break;\n\tif (i <= N) {\n\t\tfree(_adj);\n\t\tfree(_adj_inv);\n\t\tfree(e);\n\t\tfree(q);\n\t\tfree(sc);\n\t\tfree(_d);\n\t\tfree(_label);\n\t\treturn 0;\n\t}\n\t\n\tint *deg = (int*)malloc(sizeof(int) * k);\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\treturn 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[1000001], y[1000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\treturn 0;\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) break;\n\tif (i <= N) {\n\t\tfree(_adj);\n\t\tfree(_adj_inv);\n\t\tfree(e);\n\t\tfree(q);\n\t\tfree(sc);\n\t\tfree(_d);\n\t\tfree(_label);\n\t\treturn 0;\n\t}\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\treturn 0;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\treturn 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\treturn 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) return 0;\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\treturn 0;\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct List {\n\tstruct List *next;\n\tint v;\n} list;\n\nvoid DFS1(int u, list** adj, int label[], int q[])\n{\n\tif (label[u] != 0) return;\n\telse label[u] = 1;\n\t\n\tlist *p;\n\tfor (p = adj[u]; p != NULL; p = p->next) DFS1(p->v, adj, label, q);\n\tq[label[0]++] = u;\n}\n\nvoid DFS2(int u, list** adj_inv, int label[], list** sc, list* d)\n{\n\tif (label[u] != 0) return;\n\telse {\n\t\tlabel[u] = label[0];\n\t\td[u].v = u;\n\t\td[u].next = sc[label[0]];\n\t\tsc[label[0]] = &(d[u]);\n\t}\n\t\n\tlist *p;\n\tfor (p = adj_inv[u]; p != NULL; p = p->next) DFS2(p->v, adj_inv, label, sc, d);\n}\n\nint two_SAT(int N, int M, int x[], int y[], int ans[])\n{\n\tint i;\n\tlist **_adj = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj = &(_adj[N]), **_adj_inv = (list**)malloc(sizeof(list*) * (N * 2 + 1)), **adj_inv = &(_adj_inv[N]), *e = (list*)malloc(sizeof(list) * M * 4);\n\tfor (i = 1; i <= N; i++) {\n\t\tadj[i] = NULL;\n\t\tadj[-i] = NULL;\n\t\tadj_inv[i] = NULL;\n\t\tadj_inv[-i] = NULL;\n\t}\n\tfor (i = 0; i < M; i++) {\n\t\te[i*4].v = y[i+1];\n\t\te[i*4+1].v = x[i+1];\n\t\te[i*4+2].v = -x[i+1];\n\t\te[i*4+3].v = -y[i+1];\n\t\te[i*4].next = adj[-x[i+1]];\n\t\te[i*4+1].next = adj[-y[i+1]];\n\t\te[i*4+2].next = adj_inv[y[i+1]];\n\t\te[i*4+3].next = adj_inv[x[i+1]];\n\t\tadj[-x[i+1]] = &(e[i*4]);\n\t\tadj[-y[i+1]] = &(e[i*4+1]);\n\t\tadj_inv[y[i+1]] = &(e[i*4+2]);\n\t\tadj_inv[x[i+1]] = &(e[i*4+3]);\n\t}\n\t\n\tint k, u, *q = (int*)malloc(sizeof(int) * N * 2), *_label = (int*)malloc(sizeof(int) * (N * 2 + 1)), *label = &(_label[N]);\n\tfor (i = 1, label[0] = 0; i <= N; i++) {\n\t\tDFS1(i, adj, label, q);\n\t\tDFS1(-i, adj, label, q);\n\t}\n\tfor (i = -N; i <= N; i++) label[i] = 0;\n\t\n\tlist **sc = (list**)malloc(sizeof(list*) * (N * 2 + 1)), *_d = (list*)malloc(sizeof(list) * (N * 2 + 1)), *d = &(_d[N]);\n\tfor (i = N * 2 - 1, k = 1; i >= 0; i--) {\n\t\tif (label[q[i]] == 0) {\n\t\t\tlabel[0] = k++;\n\t\t\tDFS2(q[i], adj_inv, label, sc, d);\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) if (label[i] == label[-i]) break;\n\tif (i <= N) {\n\t\tfree(_adj);\n\t\tfree(_adj_inv);\n\t\tfree(e);\n\t\tfree(q);\n\t\tfree(sc);\n\t\tfree(_d);\n\t\tfree(_label);\n\t\treturn 0;\n\t}\n\t\n\tint *deg = (int*)malloc(sizeof(int) * (N + 1));\n\tlist *p, **sc_adj = (list**)malloc(sizeof(list*) * k), *f = (list*)malloc(sizeof(list) * M * 2);\n\tfor (u = 1, i = 0; u <= N; u++) {\n\t\tfor (p = adj_inv[u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[u]];\n\t\t\tsc_adj[label[u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t\tfor (p = adj_inv[-u]; p != NULL; p = p->next) {\n\t\t\tif (label[p->v] == label[-u]) continue;\n\t\t\tf[i].v = label[p->v];\n\t\t\tf[i].next = sc_adj[label[-u]];\n\t\t\tsc_adj[label[-u]] = &(f[i++]);\n\t\t\tdeg[label[p->v]]++;\n\t\t}\n\t}\n\t\n\tint *qq = (int*)malloc(sizeof(int) * k), head[2], tail[2];\n\tfor (i = 1; i <= N; i++) ans[i] = -1;\n\tfor (i = 1, tail[0] = 0; i < k; i++) if (deg[i] == 0) qq[tail[0]++] = i;\n\tfor (head[0] = 0; head[0] < tail[0]; head[0]++) {\n\t\ti = qq[head[0]];\n\t\tu = sc[i]->v;\n\t\tif (ans[abs(u)] == -1) {\n\t\t\tif (u > 0) ans[u] = 1;\n\t\t\telse ans[-u] = 0;\n\t\t\tq[0] = u;\n\t\t\tfor (head[1] = 0, tail[1] = 1; head[1] < tail[1]; head[1]++) {\n\t\t\t\tu = q[head[1]];\n\t\t\t\tfor (p = adj[u]; p != NULL; p = p->next) {\n\t\t\t\t\tif (ans[abs(p->v)] == -1) {\n\t\t\t\t\t\tif (p->v > 0) ans[p->v] = 1;\n\t\t\t\t\t\telse ans[-(p->v)] = 0;\n\t\t\t\t\t\tq[tail[1]++] = p->v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (p = sc_adj[i]; p != NULL; p = p->next) {\n\t\t\tdeg[p->v]--;\n\t\t\tif (deg[p->v] == 0) qq[tail[0]++] = p->v;\n\t\t}\n\t}\n\treturn 0;\n\t\n\tfree(_adj);\n\tfree(_adj_inv);\n\tfree(e);\n\tfree(q);\n\tfree(sc);\n\tfree(_d);\n\tfree(_label);\n\tfree(deg);\n\tfree(sc_adj);\n\tfree(f);\n\tfree(qq);\n\treturn 1;\n}\n\nint main()\n{\n\tint i, N, D, X[1001], Y[1001];\n\tscanf(\"%d %d\", &N, &D);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d\", &(X[i]), &(Y[i]));\n\t\n\tint j, M, x[2000001], y[2000001];\n\tfor (i = 1, M = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tif (abs(X[i] - X[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(X[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - X[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = j;\n\t\t\t}\n\t\t\tif (abs(Y[i] - Y[j]) < D) {\n\t\t\t\tx[++M] = -i;\n\t\t\t\ty[M] = -j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans[1001], tmp = two_SAT(N, M, x, y, ans);\n\tif (tmp == 0) printf(\"No\\n\");\n\telse {\n\t\tprintf(\"Yes\\n\");\n\t\tfor (i = 1; i <= N; i++) printf(\"%d\\n\", (ans[i] == 0)? X[i]: Y[i]);\n\t}\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "Julia",
    "code": "include(\"scc.jl\")\n\nmutable struct two_sat\n    n::Int\n    answer::Array{Bool}\n    sg::scc_graph\n\n    two_sat() = new(0, Array{Bool, 1}(), scc_graph(0))\n    two_sat(n) = new(n, [false for i = 1:n], scc_graph(2 * n))\nend\n\nfunction add_clause!(ts::two_sat, i::Int, f::Bool, j::Int, g::Bool)\n    add_edge!(ts.sg, 2 * i + (f ? 0 : 1) - 1, 2 * j + (g ? 1 : 0) - 1)\n    add_edge!(ts.sg, 2 * j + (g ? 0 : 1) - 1, 2 * i + (f ? 1 : 0) - 1) \nend\n\nfunction satisfiable(ts::two_sat)::Bool\n    id = scc_ids(ts.sg)[2]\n    for i = 1:ts.n\n        if id[2 * i - 1] == id[2 * i]\n            return false\n        end\n        ts.answer[i] = id[2 * i - 1] < id[2 * i]\n    end\n    true\nend\n\nanswer(ts::two_sat) = ts.answer\n\nparseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\nIFL(x) = Int(floor(x))\n\nfunction main()\n    N,D = readline() |> split |> parseMap\n    ts = two_sat(N)\n    p = [[0,0] for i=1:N]\n    for i=1:N\n        a,b = readline() |> split |> parseMap\n        p[i][1] = a\n        p[i][2] = b\n    end\n\n    for i = 1:N\n        for j = i+1:N\n            for k = 0:3\n                if abs(p[i][IFL(k/2) + 1] - p[j][k%2 + 1]) < D\n                    add_clause!(ts, i, Bool(IFL(k/2)), j, Bool(k%2))\n                end\n            end\n        end\n    end\n\n    if satisfiable(ts)\n        println(\"Yes\")\n        for i = 1:N\n            ans = answer(ts)\n            println(p[i][Int(~ans[i]) + 1])\n        end\n    else\n        println(\"No\")\n    end\nend\n\nmain()"
  },
  {
    "language": "Julia",
    "code": "struct csr{E}\n    start::Array{Int}\n    elist::Array{E}\n\n    function csr{E}(n::Int, edges::Array{Pair{Int, E}}) where E\n        start = zeros(Int, n + 1)\n        elist = Array{E}(undef, length(edges))\n                \n        for e in edges\n            start[e[1] + 1] += 1\n        end\n        \n        for i = 2:n+1\n            start[i] += start[i - 1]\n        end\n\n        counter::Array{Int} = copy(start)\n        for e in edges\n            elist[counter[e[1]] + 1] = e[2] \n            counter[e[1]] += 1\n        end\n\n        new{E}(start, elist)\n    end\nend\n\nstruct edge\n    to::Int\nend\n\nmutable struct scc_graph\n    n::Int\n    edges::Array{Pair{Int, edge}}\n\n    scc_graph(n::Int) = new(n, Array{Pair{Int, edge},1}())\nend\n\nnum_vertices(sg::scc_graph)::Int = sg.n\n\nfunction add_edge!(sg::scc_graph, from::Int, to::Int)\n    new_edge = Pair{Int, edge}(from, edge(to))\n    push!(sg.edges, new_edge)\nend\n\nfunction dfs_for_scc!(v::Int, g::csr{edge}, ord_group::Array{Int},\n    visited::Array{Int}, low::Array{Int}, ord::Array{Int},\n    ids::Array{Int}, sg::scc_graph)\n    low[v] = ord_group[1]\n    ord[v] = ord_group[1]\n    ord_group[1] += 1\n    push!(visited, v)\n    for i = g.start[v] + 1:g.start[v + 1]\n        to = g.elist[i].to\n        if ord[to] == -1\n            dfs_for_scc!(to, g, ord_group, visited, low, ord, ids, sg)\n            low[v] = min(low[v], low[to])\n        else\n            low[v] = min(low[v], ord[to])\n        end\n    end\n\n    if low[v] == ord[v]\n        while true\n            u = pop!(visited)\n            ord[u] = sg.n\n            ids[u] = ord_group[2]\n            if u == v\n                break\n            end\n        end\n        ord_group[2] += 1\n    end\nend\n\nfunction scc_ids(sg::scc_graph)::Pair{Int, Array{Int}}\n    g = csr{edge}(sg.n, sg.edges)\n    ord_group = [1, 0] \n    visited = Array{Int,1}()\n    low = zeros(Int, sg.n)\n    ord = [-1 for i = 1:sg.n]\n    ids = zeros(Int, sg.n)\n\n    for i = 1:sg.n\n        if ord[i] == -1\n            dfs_for_scc!(i, g, ord_group, visited, low, ord, ids, sg)\n        end\n    end\n\n    for i = 1:sg.n\n        ids[i] = ord_group[2] - ids[i]\n    end\n\n    Pair{Int, Array{Int}}(ord_group[2], ids)\nend\n\nfunction scc(sg::scc_graph)\n    ids = scc_ids(sg)\n    group_num = ids[1]\n    counts = zeros(Int, group_num)\n    for x in ids[2]\n        counts[x] += 1\n    end\n    groups = [Array{Int, 1}() for i = 1:group_num]\n    for i = 1:sg.n\n        push!(groups[ids[2][i]], i)\n    end\n\n    groups\nend\n\nmutable struct two_sat\n    n::Int\n    answer::Array{Bool}\n    sg::scc_graph\n\n    two_sat() = new(0, Array{Bool, 1}(), scc_graph(0))\n    two_sat(n) = new(n, [false for i = 1:n], scc_graph(2 * n))\nend\n\nfunction add_clause!(ts::two_sat, i::Int, f::Bool, j::Int, g::Bool)\n    add_edge!(ts.sg, 2 * i + (f ? 0 : 1) + 1, 2 * j + (g ? 1 : 0) + 1)\n    add_edge!(ts.sg, 2 * j + (g ? 0 : 1) + 1, 2 * i + (f ? 1 : 0) + 1) \nend\n\nfunction satisfiable(ts::two_sat)::Bool\n    id = scc_ids(ts.sg)[2]\n    for i = 1:ts.n\n        if id[2 * i - 1] == id[2 * i]\n            return false\n        end\n        ts.answer[i] = id[2 * i - 1] < id[2 * i]\n    end\n    true\nend\n\nanswer(ts::two_sat) = ts.answer\n\nparseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\nIFL(x) = Int(floor(x))\n\nfunction main()\n    N,D = readline() |> split |> parseMap\n    ts = two_sat(N)\n    p = [[0,0] for i=1:N]\n    for i=1:N\n        a,b = readline() |> split |> parseMap\n        p[i][1] = a\n        p[i][2] = b\n    end\n\n    for i = 0:N-1\n        for j = i+1:N-1\n            for k = 0:3\n                if abs(p[i+1][IFL(k/2)+1] - p[j+1][k%2+1]) < D\n                    add_clause!(ts, i, Bool(IFL(k/2)), j, Bool(k%2))\n                end\n            end\n        end\n    end\n\n    if satisfiable(ts)\n        println(\"Yes\")\n        for i = 1:N\n            ans = answer(ts)\n            println(p[i][Int(~ans[i]) + 1])\n        end\n    else\n        println(\"No\")\n    end\nend\n\nmain()"
  },
  {
    "language": "Julia",
    "code": "struct csr{E}\n    start::Array{Int}\n    elist::Array{E}\n\n    function csr{E}(n::Int, edges::Array{Pair{Int, E}}) where E\n        start = zeros(Int, n + 1)\n        elist = Array{E}(undef, length(edges))\n                \n        for e in edges\n            start[e[1] + 1] += 1\n        end\n        \n        for i = 2:n+1\n            start[i] += start[i - 1]\n        end\n\n        counter::Array{Int} = copy(start)\n        for e in edges\n            elist[counter[e[1]] + 1] = e[2] \n            counter[e[1]] += 1\n        end\n\n        new{E}(start, elist)\n    end\nend\n\nstruct edge\n    to::Int\nend\n\nmutable struct scc_graph\n    n::Int\n    edges::Array{Pair{Int, edge}}\n\n    scc_graph(n::Int) = new(n, Array{Pair{Int, edge},1}())\nend\n\nnum_vertices(sg::scc_graph)::Int = sg.n\n\nfunction add_edge!(sg::scc_graph, from::Int, to::Int)\n    new_edge = Pair{Int, edge}(from, edge(to))\n    push!(sg.edges, new_edge)\nend\n\nfunction dfs_for_scc!(v::Int, g::csr{edge}, ord_group::Array{Int},\n    visited::Array{Int}, low::Array{Int}, ord::Array{Int},\n    ids::Array{Int}, sg::scc_graph)\n    low[v] = ord_group[1]\n    ord[v] = ord_group[1]\n    ord_group[1] += 1\n    push!(visited, v)\n    for i = g.start[v] + 1:g.start[v + 1]\n        to = g.elist[i].to\n        if ord[to] == -1\n            dfs_for_scc!(to, g, ord_group, visited, low, ord, ids, sg)\n            low[v] = min(low[v], low[to])\n        else\n            low[v] = min(low[v], ord[to])\n        end\n    end\n\n    if low[v] == ord[v]\n        while true\n            u = pop!(visited)\n            ord[u] = sg.n\n            ids[u] = ord_group[2]\n            if u == v\n                break\n            end\n        end\n        ord_group[2] += 1\n    end\nend\n\nfunction scc_ids(sg::scc_graph)::Pair{Int, Array{Int}}\n    g = csr{edge}(sg.n, sg.edges)\n    ord_group = [1, 0] \n    visited = Array{Int,1}()\n    low = zeros(Int, sg.n)\n    ord = [-1 for i = 1:sg.n]\n    ids = zeros(Int, sg.n)\n\n    for i = 1:sg.n\n        if ord[i] == -1\n            dfs_for_scc!(i, g, ord_group, visited, low, ord, ids, sg)\n        end\n    end\n\n    for i = 1:sg.n\n        ids[i] = ord_group[2] - ids[i]\n    end\n\n    Pair{Int, Array{Int}}(ord_group[2], ids)\nend\n\nfunction scc(sg::scc_graph)\n    ids = scc_ids(sg)\n    group_num = ids[1]\n    counts = zeros(Int, group_num)\n    for x in ids[2]\n        counts[x] += 1\n    end\n    groups = [Array{Int, 1}() for i = 1:group_num]\n    for i = 1:sg.n\n        push!(groups[ids[2][i]], i)\n    end\n\n    groups\nend\n\nmutable struct two_sat\n    n::Int\n    answer::Array{Bool}\n    sg::scc_graph\n\n    two_sat() = new(0, Array{Bool, 1}(), scc_graph(0))\n    two_sat(n) = new(n, [false for i = 1:n], scc_graph(2 * n))\nend\n\nfunction add_clause!(ts::two_sat, i::Int, f::Bool, j::Int, g::Bool)\n    add_edge!(ts.sg, 2 * i + (f ? 0 : 1) - 1, 2 * j + (g ? 1 : 0) - 1)\n    add_edge!(ts.sg, 2 * j + (g ? 0 : 1) - 1, 2 * i + (f ? 1 : 0) - 1) \nend\n\nfunction satisfiable(ts::two_sat)::Bool\n    id = scc_ids(ts.sg)[2]\n    for i = 1:ts.n\n        if id[2 * i - 1] == id[2 * i]\n            return false\n        end\n        ts.answer[i] = id[2 * i - 1] < id[2 * i]\n    end\n    true\nend\n\nanswer(ts::two_sat) = ts.answer\n\nparseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\nIFL(x) = Int(floor(x))\n\nfunction main()\n    N,D = readline() |> split |> parseMap\n    ts = two_sat(N)\n    p = [[0,0] for i=1:N]\n    for i=1:N\n        a,b = readline() |> split |> parseMap\n        p[i][1] = a\n        p[i][2] = b\n    end\n\n    for i = 1:N\n        for j = i+1:N\n            for k = 0:3\n                if abs(p[i][IFL(k/2) + 1] - p[j][k%2 + 1]) < D\n                    add_clause!(ts, i, Bool(IFL(k/2)), j, Bool(k%2))\n                end\n            end\n        end\n    end\n\n    if satisfiable(ts)\n        println(\"Yes\")\n        for i = 1:N\n            ans = answer(ts)\n            println(p[i][Int(~ans[i]) + 1])\n        end\n    else\n        println(\"No\")\n    end\nend\n\nmain()"
  },
  {
    "language": "Kotlin",
    "code": "@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\")\n//@file:OptIn(ExperimentalStdlibApi::class)\n\nimport java.io.PrintWriter\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n\n/** @author Spheniscine */\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n//    val startTime = System.nanoTime()\n\n    val numCases = 1//readInt()\n    case@ for(case in 1..numCases) {\n//        print(\"Case #$case: \")\n\n        val n = readInt()\n        val d = readInt()\n        val n2 = n+n\n        val A = IntArray(n2)\n        for(i in 0 until n) {\n            val j = n2 + i.inv()\n            A[i] = readInt()\n            A[j] = readInt()\n        }\n\n        val S = TwoSat(n)\n        for(i in 0 until n2) {\n            for(j in i+1 until n2) {\n                if(abs(A[i] - A[j]) < d) {\n                    S.or(i.inv(), j.inv())\n                }\n            }\n        }\n\n        val ans = S.solve()\n\n        if(ans == null) println(\"No\")\n        else {\n            println(\"Yes\")\n            for(i in 0 until n) {\n                println(if(ans[i]) A[i] else A[n2 + i.inv()])\n            }\n        }\n    }\n\n//    iprintln(\"Time: ${(System.nanoTime() - startTime) / 1000000} ms\")\n}\n\nclass TwoSat(val n: Int) {\n    private val n2 = n+n\n    private val G = SCC(n2)\n\n    private fun norm(i: Int) = i + (i shr 31 and n2)\n\n    private fun imply(x: Int, y: Int) { G.addEdge(norm(x), norm(y)) }\n\n    fun or(x: Int, y: Int) {\n        // x or y must be true\n        imply(x.inv(), y)\n        imply(y.inv(), x)\n    }\n\n    fun set(x: Int) {\n        // x must be true\n        imply(x.inv(), x)\n    }\n\n    fun xor(x: Int, y: Int) {\n        // exactly one of x, y is true\n        or(x, y)\n        or(x.inv(), y.inv())\n    }\n\n    fun eq(x: Int, y: Int) {\n        // both or none of x and y are true, x == y\n        or(x, y.inv())\n        or(x.inv(), y)\n    }\n\n    fun solve(): BooleanArray? {\n        val scc = G.scc()\n\n        val pos = IntArray(n2)\n        for(i in scc.indices) {\n            for(u in scc[i]) {\n                pos[u] = i\n            }\n        }\n\n        return BooleanArray(n) { u ->\n            val t = pos[u]\n            val f = pos[n2 + u.inv()]\n\n            if(t == f) return null\n            f < t\n        }\n    }\n}\n\nclass SCC(val n: Int) {\n    val G = Array(n) { IntList() }\n    fun addEdge(u: Int, v: Int) {\n        G[u].add(v)\n    }\n\n    fun scc(): List<IntArray> {\n        val res = mutableListOf<IntArray>()\n        val S = IntList()\n        val P = IntList()\n        val depth = IntArray(n)\n\n        val stack = IntList(n) { it }\n        while(stack.isNotEmpty()) {\n            val u = stack.pop()\n            when {\n                u < 0 -> {\n                    val d = depth[u.inv()] - 1\n                    if(P.last() > d) {\n                        val comp = IntArray(S.size - d) { S[d+it] }\n                        res.add(comp)\n                        S.popToSize(d)\n                        P.pop()\n                        for(v in comp) depth[v] = -1\n                    }\n                }\n                depth[u] > 0 -> {\n                    while(P.last() > depth[u]) P.pop()\n                }\n                depth[u] == 0 -> {\n                    S.add(u)\n                    P.add(S.size)\n                    depth[u] = S.size\n                    stack.add(u.inv())\n                    for(v in G[u]) stack.add(v)\n                }\n            }\n        }\n\n        res.reverse() // output will have components topologically ordered relative to each other\n        return res\n    }\n}\n\nclass IntList(initialCapacity: Int = 12) {\n    private var _arr = IntArray(initialCapacity)\n    private val capacity get() = _arr.size\n    var size = 0\n        private set\n    inline val lastIndex get() = size - 1\n    inline val indices get() = 0 until size\n\n    constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(_arr); size = copyFrom.size }\n    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { _arr = copyFrom.toIntArray(); size = copyFrom.size }\n\n    fun contentEquals(other: IntList): Boolean {\n        return this === other || size == other.size && indices.all { this[it] == other[it] }\n    }\n\n    private fun grow(minCapacity: Int = 8) {\n        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))\n        _arr = _arr.copyOf(newCapacity)\n    }\n\n    fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }\n\n    operator fun get(index: Int): Int {\n        require(index in 0 until size)\n        return _arr[index]\n    }\n\n    operator fun set(index: Int, value: Int) {\n        require(index in 0 until size)\n        _arr[index] = value\n    }\n\n    fun add(value: Int) {\n        if(size == capacity) grow()\n        _arr[size++] = value\n    }\n\n    fun addAll(list: IntList) {\n        ensureCapacity(size + list.size)\n        list._arr.copyInto(_arr, size, 0, list.size)\n        size += list.size\n    }\n\n    fun add(index: Int, element: Int) {\n        if(size == capacity) grow()\n        _arr.copyInto(_arr, index + 1, index, size)\n        size++\n        set(index, element)\n    }\n\n    fun clear() { size = 0 }\n\n    fun removeAt(index: Int): Int {\n        val e = get(index)\n        _arr.copyInto(_arr, index, index + 1, size)\n        size--\n        return e\n    }\n\n    fun indexOf(e: Int): Int {\n        for(i in 0 until size) if(this[i] == e) return i\n        return -1\n    }\n\n    fun remove(e: Int): Boolean {\n        val i = indexOf(e)\n        if(i == -1) return false\n        removeAt(i)\n        return true\n    }\n\n    operator fun iterator() = object: IntIterator() {\n        private var pos = 0\n        override fun hasNext() = pos < size\n        override fun nextInt() = get(pos++)\n    }\n\n    inline fun isEmpty() = size == 0\n    inline fun isNotEmpty() = size != 0\n\n    fun pop() = _arr[--size]\n\n    fun popToSize(s: Int) {\n        require(s >= 0)\n        if(s < size) size = s\n    }\n\n    fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }\n    fun reverse() {\n        for(i in 0 until size / 2) swap(i, lastIndex - i)\n    }\n\n    fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }\n    fun sort() { shuffle(); _arr._sort(0, size) }\n    fun sortDescending() { sort(); reverse() }\n\n    fun joinToString(separator: CharSequence) = if(size == 0) \"\" else let {\n        buildString {\n            append(it[0])\n            for (i in 1 until size) {\n                append(separator).append(it[i])\n            }\n        }\n    }\n\n    override fun toString() = \"[\" + joinToString(\", \") + \"]\"\n\n    fun toIntArray() = _arr.copyOf(size)\n    fun toList() = List(size, ::get)\n\n    inline fun first() = get(0)\n    inline fun last() = get(lastIndex)\n}\n\ninline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {\n    for(i in 0 until size) { add(init(i)) }\n}\ninline fun IntArray.toIntList() = IntList(this)\ninline fun Collection<Int>.toIntList() = IntList(this)\ninline fun intListOf(vararg values: Int) = IntList(values)\n\nfun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }\nfun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }\nfun IntList.getOrNull(i: Int) = if(i in indices) get(i) else null\ninline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }\nfun IntList.copyOf() = IntList(size, ::get)\n\n/** IO */\n//@JvmField val INPUT = File(\"input.txt\").inputStream()\n//@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\nconst val _BUFFER_SIZE = 1 shl 16\n@JvmField val _buffer = ByteArray(_BUFFER_SIZE)\n@JvmField var _bufferPt = 0\n@JvmField var _bytesRead = 0\n\ntailrec fun readChar(): Char {\n    if(_bufferPt == _bytesRead) {\n        _bufferPt = 0\n        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)\n    }\n    return if(_bytesRead < 0) Char.MIN_VALUE\n    else {\n        val c = _buffer[_bufferPt++].toChar()\n        if (c == '\\r') readChar()\n        else c\n    }\n}\n\nfun readLine(): String? {\n    var c = readChar()\n    return if(c == Char.MIN_VALUE) null\n    else buildString {\n        while(c != '\\n' && c != Char.MIN_VALUE) {\n            append(c)\n            c = readChar()\n        }\n    }\n}\nfun readLn() = readLine()!!\n\nfun read() = buildString {\n    var c = readChar()\n    while(c <= ' ') {\n        if(c == Char.MIN_VALUE) return@buildString\n        c = readChar()\n    }\n    do {\n        append(c)\n        c = readChar()\n    } while(c > ' ')\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n/** shuffles and sort overrides to avoid quicksort attacks */\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    // Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }\n\n/** additional commons */\ninline fun <T> Iterable<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\nfun IntArray.sumLong() = fold(0L, Long::plus)\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();long D = in.nextLong();\n        long[][] p = new long[N][];\n        for(int i = 0; i< N; i++)\n            p[i] = new long[]{in.nextLong(), in.nextLong()};\n        int[] from = new int[8*N], to = new int[8*N];\n        int cnt = 0;\n        for(int i = 0; i< N; i++){\n            for(int j = i+1; j< N; j++){\n                for(int u = 0; u< 2; u++)\n                    for(int v = 0; v< 2; v++){\n                        if(Math.abs(p[i][u]-p[j][v]) < D){\n                            from[cnt] = (i<<1)|u;\n                            to[cnt] = (j<<1)|v^1;\n                            cnt++;\n                            from[cnt] = (j<<1)|v;;\n                            to[cnt] = (i<<1)|u^1;\n                            cnt++;\n                        }\n                    }\n            }\n        }\n        int[][] g = make(2*N, cnt, from, to), gt = make(2*N, cnt, to, from);\n        int[] scc = new StronglyConnectedComponents().scc(2*N, g, gt);\n        for(int i = 0; i< N; i++)if(scc[i<<1] == scc[i<<1|1]){\n            System.out.println(\"No\");\n            return;\n        }\n        System.out.println(\"Yes\");\n        TreeMap<Integer, Integer> mp = new TreeMap<>();\n        int c = 0;\n        for(int i:scc)c = Math.max(c, i+1);\n        int[] ff = new int[cnt], tt = new int[cnt];\n        int cc = 0;\n        for(int i = 0; i< cnt; i++){\n            if(scc[from[i]] != scc[to[i]]){\n                ff[cc] = scc[from[i]];\n                tt[cc] = scc[to[i]];\n                cc++;\n            }\n        }\n        int[][] gg = make(c, cc, ff, tt);\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        int[] indeg = new int[c];\n        for(int i = 0; i< cc; i++)indeg[tt[i]]++;\n        for(int i = 0; i< c; i++)if(indeg[i] == 0)set.add(i);\n        int[] ord = new int[c];\n        for(int i = 0; i< c; i++){\n            ord[i] = set.pollFirst();\n            for(int v:gg[ord[i]]){\n                indeg[v]--;\n                if(indeg[v] == 0)set.add(v);\n            }\n        }\n        \n        for(int i = 0; i< N; i++){\n            if(ord[scc[i<<1]] > ord[scc[i<<1|1]])System.out.println(p[i][0]);\n            else System.out.println(p[i][1]);\n        }\n    }\n    static int[][] make(int N, int M, int[] from, int[] to){\n        int[][] g = new int[N][];int[] cnt = new int[N];\n        for(int i = 0; i< M; i++)cnt[from[i]]++;\n        for(int i = 0; i< N; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< M; i++)g[from[i]][--cnt[from[i]]] = to[i];\n        return g;\n    }\n}\nclass StronglyConnectedComponents {\n    public int[] scc(int n, int[][] g, int[][] gt){\n        Stack<Integer> st = new Stack<>();\n        boolean[] vis = new boolean[n];\n        for(int i = 0; i< n; i++)if(!vis[i])fillOrder(g, st, vis, i);\n        Arrays.fill(vis, false);\n        int[] scc = new int[n];\n        int id = 0;\n        while(!st.isEmpty()){\n            int u = st.pop();\n            if(!vis[u]){assignSCC(gt, scc, vis, u, id++);}\n        }\n        return scc;\n    }\n    private void assignSCC(int[][] gt, int[] scc, boolean[] vis, int u, int id){\n        vis[u] = true;\n        scc[u] = id;\n        for(int v:gt[u])if(!vis[v])assignSCC(gt, scc, vis, v, id);\n    }\n    private void fillOrder(int[][] g, Stack<Integer> s, boolean[] vis, int u){\n        vis[u] = true;\n        for(int v:g[u])if(!vis[v])fillOrder(g, s, vis, v);\n        s.push(u);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\n\n\nimport java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable {\n\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t *\n\t\t * 考察メモ\n\t\t * ライブラリの使い方確認\n\t\t */\n\t\tio.setAutoFlush(false);\n\t\tio.setAutoOutFlush(false);\n\t\tint N = io.nextInt(), D = io.nextInt();\n\t\tACL.TwoSAT sat = new ACL.TwoSAT(N);\n\t\tPoint[] p = io.nextPoint(N);\n\t\tfor (int i = 0;i < N;++ i) {\n\t\t\tfor (int j = i + 1;j < N;++ j) {\n\t\t\t\tif (Math.abs(p[i].x - p[j].x) < D) sat.addClause(i, true, j, true);\n\t\t\t\tif (Math.abs(p[i].x - p[j].y) < D) sat.addClause(i, true, j, false);\n\t\t\t\tif (Math.abs(p[i].y - p[j].x) < D) sat.addClause(i, false, j, true);\n\t\t\t\tif (Math.abs(p[i].y - p[j].y) < D) sat.addClause(i, false, j, false);\n\t\t\t}\n\t\t}\n\t\tif (sat.satisfiable()) {\n\t\t\tio.println(\"Yes\");\n\t\t\tboolean[] ans = sat.answer();\n\t\t\tfor (int i = 0;i < N;++ i) io.println(ans[i] ? p[i].y : p[i].x);\n\t\t} else {\n\t\t\tio.println(\"No\");\n\t\t}\n\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB) */\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t\tThread.setDefaultUncaughtExceptionHandler((t, e) -> {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t});\n\t\tnew Thread(null, new Main(args), \"\", MEMORY * 1048576L).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 指数表記の値を整数で返します。\n\t *\n\t * @param n 仮数部\n\t * @param e 指数部\n\t * @return n * 10^e\n\t */\n\tpublic static int exponent10(int n, int e) {\n\t\treturn n * pow(10, e);\n\t}\n\n\t/**\n\t * 指数表記の値を整数で返します。\n\t *\n\t * @param n 仮数部\n\t * @param e 指数部\n\t * @return n * 10^e\n\t */\n\tpublic static long exponent10L(int n, int e) {\n\t\treturn n * pow(10L, e);\n\t}\n\n\t/**\n\t * aのb乗を返します。\n\t *\n\t * @param a 整数\n\t * @param b 整数\n\t * @return aのb乗\n\t */\n\tpublic static int pow(int a, int b) {\n\t\tint ans = 1;\n\t\tfor (int mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\t/**\n\t * aのb乗をmodを法として計算したものを返します。\n\t *\n\t * @param a   整数\n\t * @param b   整数\n\t * @param mod 法\n\t * @return aのb乗をmodを法として計算したもの\n\t */\n\tpublic static int pow(int a, int b, int mod) {\n\t\ta %= mod;\n\t\tif (a < 0) a += mod;\n\t\tb %= mod;\n\t\tif (b < 0) b += mod - 1;\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul = mul * mul % mod)\n\t\t\tif ((b & 1) != 0) ans = ans * mul % mod;\n\t\treturn (int)ans;\n\t}\n\n\t/**\n\t * aのb乗を返します。\n\t *\n\t * @param a 整数\n\t * @param b 整数\n\t * @return aのb乗\n\t */\n\tpublic static long pow(long a, long b) {\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\t/**\n\t * aのb乗をmodを法として計算したものを返します。\n\t *\n\t * @param a   整数\n\t * @param b   整数\n\t * @param mod 法\n\t * @return aのb乗をmodを法として計算したもの\n\t */\n\tpublic static int pow(long a, long b, int mod) {\n\t\ta %= mod;\n\t\tif (a < 0) a += mod;\n\t\tb %= mod;\n\t\tif (b < 0) b += mod - 1;\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul = mul * mul % mod)\n\t\t\tif ((b & 1) != 0) ans = ans * mul % mod;\n\t\treturn (int)ans;\n\t}\n\n\t/**\n\t * 高速な入出力を提供します。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable {\n\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++ ];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read]))\n\t\t\t\tread++ ;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0; i < ret.length; ++i)\n\t\t\t\tret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1; i <= height; ++i)\n\t\t\t\tret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo\n\t\t\t\tsb.append(nextChar());\n\t\t\twhile (hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!readNewLine())\n\t\t\t\tsb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo\n\t\t\t\t\tn = n * 10 + b - '0';\n\t\t\t\twhile (isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo\n\t\t\t\t\tn = n * 10 + b - '0';\n\t\t\t\twhile (isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0; i < width; ++i)\n\t\t\t\tret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0; i < ret.length; ++i)\n\t\t\t\tret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0; i < width; ++i)\n\t\t\t\tret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0; i < ret.length; ++i)\n\t\t\t\tret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j; i < height; ++i)\n\t\t\t\tfor (j = 0; j < width; ++j)\n\t\t\t\t\tret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j; i < height; ++i)\n\t\t\t\tfor (j = 0; j < width; ++j)\n\t\t\t\t\tret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0; i < ret.length; ++i)\n\t\t\t\tret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0; i < ret.length; ++i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0; j < ret[i].length; ++j)\n\t\t\t\t\tret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0; i < width; ++i)\n\t\t\t\tret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0; i < length; ++i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1; i < args.length; ++i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0; i < length; ++i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[])array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1; i < obj.length; ++i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1; i < args.length; ++i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable {\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null,\n\t\t\t\t\t\tBoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null,\n\t\t\t\t\t\tBoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) --compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) --compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t *\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t *\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t *\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t *\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t *\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values)\n\t\t\t\tif (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t *\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t *\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) { return new Range<C>(lower, lowerType, upper, upperType); }\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t *\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t *\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>)object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper,\n\t\t\t\t\t\tcomp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower\n\t\t\t\t\t.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C> {\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType,\n\t\t\t\tUnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null,\n\t\t\t\t\tBoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\n\t\t\tC now;\n\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer> {\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++lower;\n\t\t\tif (upperType == BoundType.OPEN) --upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++lower;\n\t\t\tif (upperType == BoundType.OPEN) --upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\n\t\t\tint now;\n\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++ ;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\n\t\t\tint now;\n\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t *\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T> {\n\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t *\n\t\t * @param element 演算する値\n\t\t * @param repeat  繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t--repeat;\n\t\t\tfor (T mul = element; repeat > 0; repeat >>= 1, mul = apply(mul, mul))\n\t\t\t\tif ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T> {\n\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T> {\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T> {\n\n\t\t/**\n\t\t * 単位元を返します。\n\t\t *\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T> {\n\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t *\n\t\t * @param element 演算する値\n\t\t * @param repeat  繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element; repeat > 0; repeat >>= 1, mul = apply(mul, mul))\n\t\t\t\t\tif ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element; repeat > 0; repeat >>= 1, mul = apply(mul, mul))\n\t\t\t\tif ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t *\n\t\t * @param element 演算する値\n\t\t * @param repeat  繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element; repeat > 0; repeat >>= 1, mul = apply(mul, mul))\n\t\t\t\tif ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\n\t\tpublic A getAddition();\n\n\t\tpublic M getMultiplication();\n\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M> {\n\n\t\tpublic boolean isDivisible(T left, T right);\n\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M> {\n\n\t\tpublic T gcd(T left, T right);\n\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\n\t\tpublic final T element;\n\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E> {\n\n\t\tpublic int add(E element, int occurrences);\n\n\t\tpublic int count(Object element);\n\n\t\tpublic Set<E> elementSet();\n\n\t\tpublic boolean remove(Object element, int occurrences);\n\n\t\tpublic int setCount(E element, int count);\n\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M> {\n\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M> {\n\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M> {\n\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable {\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements)\n\t\t\t\tret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t--count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet())\n\t\t\t\tArrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c)\n\t\t\t\tret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c)\n\t\t\t\tret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c)\n\t\t\t\tret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E)element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>> {\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile (n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9; k <= n; i += 2, k += j += 8)\n\t\t\t\tif (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2; i < min; ++i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t *\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t *\n\t\t * @param mod  法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t *\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2; i < calc; ++i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t *\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t *\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t *\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tt = m / n;\n\t\t\t\t\tm -= t * n;\n\t\t\t\t\tu -= t * v;\n\t\t\t\t\tif (m != 0) {\n\t\t\t\t\t\tt = n / m;\n\t\t\t\t\t\tn -= t * m;\n\t\t\t\t\t\tv -= t * u;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv %= mod;\n\t\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tu %= mod;\n\t\t\t\tif (u < 0) u += mod;\n\t\t\t\treturn u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t *\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length; i <= n; ++i)\n\t\t\t\t\tret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1; i <= n; ++i)\n\t\t\t\tret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile (n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1; i <= n; ++i)\n\t\t\t\tret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>\n\t\t * ]\n\t\t * 計算量はO(n)です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t *\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2; i <= k; ++i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++ ] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s; j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k; ++j)\n\t\t\t\t\tsieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s; i <= k; ++i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i,\n\t\t\t\t\t\tn) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2; i <= k; ++i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++ ] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s; j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k; ++j)\n\t\t\t\t\tsieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s; i <= k; ++i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i,\n\t\t\t\t\t\tn) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t *\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t *\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k); j <= l; ++j)\n\t\t\t\t\tpertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i; j < k; ++j)\n\t\t\t\t\tpertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t *\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tfor (int j = 1, t; (t = i - (j * (3 * j - 1) >> 1)) >= 0; ++j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t; (t = i - (j * (3 * j + 1) >> 1)) >= 0; ++j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t *\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t *\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t *\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t *\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2; i * i <= n; ++i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet())\n\t\t\t\tret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t *\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t *\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1; i < f.length; ++i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(\n\t\t\t\t\t\tinv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t *\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t *\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t *\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile (n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number {\n\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t *\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t *\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet())\n\t\t\t\tprimeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t *\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet())\n\t\t\t\tret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t *\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet())\n\t\t\t\tprimeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t *\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet())\n\t\t\t\tret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p; n > 0; n >>= 1, mul *= mul)\n\t\t\t\tif ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p; n > 0; n >>= 1, mul *= mul)\n\t\t\t\tif ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet())\n\t\t\t\tret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet())\n\t\t\t\tret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet())\n\t\t\t\tret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet())\n\t\t\t\tret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet())\n\t\t\t\tret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number {\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while (pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0; r < s; ++r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t *\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t *\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0; i < sqrt; ++i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2; j < divisor.length; j += p)\n\t\t\t\t\tdivisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt; i < divisor.length; ++i)\n\t\t\t\tif (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t *\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif ((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1; (x & 1) == 0; x >>= 1)\n\t\t\t\t\t++c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif (x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3; x % 3 == 0; x /= 3)\n\t\t\t\t\t++c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif (x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5; x % 5 == 0; x /= 5)\n\t\t\t\t\t++c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif (x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7; x % 7 == 0; x /= 7)\n\t\t\t\t\t++c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0; i * i <= x; i += wheel[ ++j % wheel.length]) {\n\t\t\t\t\twhile (x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile (x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x; !checkPrime(p); p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p; x % p == 0; x /= p)\n\t\t\t\t\t\t++count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0)\n\t\t\t\tif ((m %= n) != 0) n %= m;\n\t\t\t\telse return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif ( ++i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while ((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess {\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++ );\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable {\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t *\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t *\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t *\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t *\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>> {\n\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index++ + start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>> {\n\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++ );\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t *\n\t\t * @param       <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t *\n\t\t * @param       <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t *\n\t\t * @param      <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t *\n\t\t * @param       <E> Iteratorの型\n\t\t * @param iter  Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n\nclass ACL {\n\n\tpublic static final class Input extends java.io.InputStream {\n\n\t\tprivate final java.io.InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\n\t\tpublic Input(java.io.InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\t@Override\n\t\tpublic int available() {\n\t\t\ttry {\n\t\t\t\treturn in.available();\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tin.close();\n\t\t\t\tread = length = 0;\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int read() {\n\t\t\tif (hasNextByte()) return nextByte();\n\t\t\treturn 0;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read]))\n\t\t\t\tread++ ;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic boolean nextBoolean() {\n\t\t\treturn Boolean.valueOf(next());\n\t\t}\n\n\t\tpublic byte nextByte() {\n\t\t\tif (hasNextByte()) return buffer[read++ ];\n\t\t\tthrow new java.util.NoSuchElementException();\n\t\t}\n\n\t\tpublic short nextShort() {\n\t\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\t\tshort n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = nextByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile (isNumber(b = nextByte()))\n\t\t\t\t\t\tn = (short)(n * 10 + '0' - b);\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo\n\t\t\t\t\tn = (short)(n * 10 + b - '0');\n\t\t\t\twhile (isNumber(b = nextByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (java.util.NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = nextByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile (isNumber(b = nextByte()))\n\t\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo\n\t\t\t\t\tn = n * 10 + b - '0';\n\t\t\t\twhile (isNumber(b = nextByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (java.util.NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = nextByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile (isNumber(b = nextByte()))\n\t\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo\n\t\t\t\t\tn = n * 10 + b - '0';\n\t\t\t\twhile (isNumber(b = nextByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (java.util.NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic float nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tbyte b = nextByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (nextByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (nextByte() & 0x3F) << 6 | (nextByte() & 0x3F));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo\n\t\t\t\tsb.append(nextChar());\n\t\t\twhile (hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!readNewLine())\n\t\t\t\tsb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t}\n\n\tpublic static final class Output extends java.io.OutputStream {\n\n\t\tprivate final java.io.OutputStream out;\n\t\tprivate final byte[] buffer = new byte[1 << 16];\n\t\tprivate int read = 0;\n\t\tprivate boolean autoFlush = true;\n\t\tprivate static final int READ_STRING_TO_BYTE_ARRAY;\n\n\t\tpublic Output(java.io.OutputStream out) {\n\t\t\tthis.out = out;\n\t\t}\n\n\t\tpublic void setAutoFlush(boolean autoFlush) {\n\t\t\tthis.autoFlush = autoFlush;\n\t\t}\n\n\t\tstatic {\n\t\t\tint flag = -1;\n\t\t\ttry {\n\t\t\t\tString test = \"test\";\n\t\t\t\tjava.lang.reflect.Field strValueField = test.getClass().getDeclaredField(\"value\");\n\t\t\t\tstrValueField.setAccessible(true);\n\t\t\t\tObject value = strValueField.get(test);\n\t\t\t\tstrValueField.setAccessible(false);\n\t\t\t\tif (value instanceof byte[]) flag = 0;\n\t\t\t\telse flag = 1;\n\t\t\t} catch (Exception e) {}\n\t\t\tREAD_STRING_TO_BYTE_ARRAY = flag;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tflush();\n\t\t\t\tout.close();\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void flush() {\n\t\t\ttry {\n\t\t\t\twrite();\n\t\t\t\tout.flush();\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(byte[] b) {\n\t\t\ttry {\n\t\t\t\tout.write(b);\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(byte[] b, int off, int len) {\n\t\t\ttry {\n\t\t\t\tout.write(b, off, len);\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(int b) {\n\t\t\ttry {\n\t\t\t\tout.write(b);\n\t\t\t} catch (java.io.IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tprivate void write() {\n\t\t\twrite(buffer, 0, read);\n\t\t\tread = 0;\n\t\t}\n\n\t\tpublic void print(boolean b) {\n\t\t\tif (b) {\n\t\t\t\tprint((byte)'t');\n\t\t\t\tprint((byte)'r');\n\t\t\t\tprint((byte)'u');\n\t\t\t\tprint((byte)'e');\n\t\t\t} else {\n\t\t\t\tprint((byte)'f');\n\t\t\t\tprint((byte)'a');\n\t\t\t\tprint((byte)'l');\n\t\t\t\tprint((byte)'s');\n\t\t\t\tprint((byte)'e');\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(byte b) {\n\t\t\tif (read == buffer.length) write();\n\t\t\tbuffer[read++ ] = b;\n\t\t}\n\n\t\tpublic void print(short s) {\n\t\t\tif (s < 0) {\n\t\t\t\tprint((byte)'-');\n\t\t\t\tif (s == -32768) {\n\t\t\t\t\tprint((byte)'3');\n\t\t\t\t\tprint((byte)'2');\n\t\t\t\t\tprint((byte)'7');\n\t\t\t\t\tprint((byte)'6');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ts = (short)-s;\n\t\t\t}\n\t\t\tif (s >= 100) {\n\t\t\t\tif (s >= 1000) {\n\t\t\t\t\tif (s >= 10000) {\n\t\t\t\t\t\tprint((byte)(s / 10000 % 10 + '0'));\n\t\t\t\t\t}\n\t\t\t\t\tprint((byte)(s / 1000 % 10 + '0'));\n\t\t\t\t}\n\t\t\t\tprint((byte)(s / 100 % 10 + '0'));\n\t\t\t\tprint((byte)(s / 10 % 10 + '0'));\n\t\t\t} else {\n\t\t\t\tif (s >= 10) print((byte)(s / 10 % 10 + '0'));\n\t\t\t}\n\t\t\tprint((byte)(s % 10 + '0'));\n\t\t}\n\n\t\tpublic void print(int i) {\n\t\t\tif (i < 0) {\n\t\t\t\tprint((byte)'-');\n\t\t\t\tif (i == -2147483648) {\n\t\t\t\t\tprint((byte)'2');\n\t\t\t\t\tprint((byte)'1');\n\t\t\t\t\tprint((byte)'4');\n\t\t\t\t\tprint((byte)'7');\n\t\t\t\t\tprint((byte)'4');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\tprint((byte)'3');\n\t\t\t\t\tprint((byte)'6');\n\t\t\t\t\tprint((byte)'4');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ti = -i;\n\t\t\t}\n\t\t\tif (i >= 1000000000) print((byte)(i / 1000000000 % 10 + '0'));\n\t\t\tif (i >= 100000000) print((byte)(i / 100000000 % 10 + '0'));\n\t\t\tif (i >= 10000000) print((byte)(i / 10000000 % 10 + '0'));\n\t\t\tif (i >= 1000000) print((byte)(i / 1000000 % 10 + '0'));\n\t\t\tif (i >= 100000) print((byte)(i / 100000 % 10 + '0'));\n\t\t\tif (i >= 10000) print((byte)(i / 10000 % 10 + '0'));\n\t\t\tif (i >= 1000) print((byte)(i / 1000 % 10 + '0'));\n\t\t\tif (i >= 100) print((byte)(i / 100 % 10 + '0'));\n\t\t\tif (i >= 10) print((byte)(i / 10 % 10 + '0'));\n\t\t\tprint((byte)(i % 10 + '0'));\n\t\t}\n\n\t\tpublic void print(long l) {\n\t\t\tif (l < 0) {\n\t\t\t\tprint((byte)'-');\n\t\t\t\tif (l == -9223372036854775808L) {\n\t\t\t\t\tprint((byte)'9');\n\t\t\t\t\tprint((byte)'2');\n\t\t\t\t\tprint((byte)'2');\n\t\t\t\t\tprint((byte)'3');\n\t\t\t\t\tprint((byte)'3');\n\t\t\t\t\tprint((byte)'7');\n\t\t\t\t\tprint((byte)'2');\n\t\t\t\t\tprint((byte)'0');\n\t\t\t\t\tprint((byte)'3');\n\t\t\t\t\tprint((byte)'6');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\tprint((byte)'5');\n\t\t\t\t\tprint((byte)'4');\n\t\t\t\t\tprint((byte)'7');\n\t\t\t\t\tprint((byte)'7');\n\t\t\t\t\tprint((byte)'5');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\tprint((byte)'0');\n\t\t\t\t\tprint((byte)'8');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tl = -l;\n\t\t\t}\n\t\t\tif (l >= 1000000000000000000L) print((byte)(l / 1000000000000000000L % 10 + '0'));\n\t\t\tif (l >= 100000000000000000L) print((byte)(l / 100000000000000000L % 10 + '0'));\n\t\t\tif (l >= 10000000000000000L) print((byte)(l / 10000000000000000L % 10 + '0'));\n\t\t\tif (l >= 1000000000000000L) print((byte)(l / 1000000000000000L % 10 + '0'));\n\t\t\tif (l >= 100000000000000L) print((byte)(l / 100000000000000L % 10 + '0'));\n\t\t\tif (l >= 10000000000000L) print((byte)(l / 10000000000000L % 10 + '0'));\n\t\t\tif (l >= 1000000000000L) print((byte)(l / 1000000000000L % 10 + '0'));\n\t\t\tif (l >= 100000000000L) print((byte)(l / 100000000000L % 10 + '0'));\n\t\t\tif (l >= 10000000000L) print((byte)(l / 10000000000L % 10 + '0'));\n\t\t\tif (l >= 1000000000L) print((byte)(l / 1000000000L % 10 + '0'));\n\t\t\tif (l >= 100000000L) print((byte)(l / 100000000L % 10 + '0'));\n\t\t\tif (l >= 10000000L) print((byte)(l / 10000000L % 10 + '0'));\n\t\t\tif (l >= 1000000L) print((byte)(l / 1000000L % 10 + '0'));\n\t\t\tif (l >= 100000L) print((byte)(l / 100000L % 10 + '0'));\n\t\t\tif (l >= 10000L) print((byte)(l / 10000L % 10 + '0'));\n\t\t\tif (l >= 1000L) print((byte)(l / 1000L % 10 + '0'));\n\t\t\tif (l >= 100L) print((byte)(l / 100L % 10 + '0'));\n\t\t\tif (l >= 10L) print((byte)(l / 10L % 10 + '0'));\n\t\t\tprint((byte)(l % 10 + '0'));\n\t\t}\n\n\t\tpublic void print(float f) {\n\t\t\tprint(Float.toString(f));\n\t\t}\n\n\t\tpublic void print(double d) {\n\t\t\tprint(Double.toString(d));\n\t\t}\n\n\t\tpublic void print(double d, int n) {\n\t\t\tif (d < 0) {\n\t\t\t\tprint((byte)'-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -n) / 2;\n\t\t\tlong l = (long)d;\n\t\t\tprint(l);\n\t\t\tprint((byte)'.');\n\t\t\td -= l;\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\td *= 10;\n\t\t\t\tint in = (int)d;\n\t\t\t\tprint((byte)(in + '0'));\n\t\t\t\td -= in;\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(char c) {\n\t\t\tif (c < 0x80) {\n\t\t\t\tprint((byte)c);\n\t\t\t} else if (c < 0x07FF) {\n\t\t\t\tprint((byte)(c >> 6 & 0x3F | 0x80));\n\t\t\t\tprint((byte)(c & 0x3F | 0x80));\n\t\t\t} else {\n\t\t\t\tprint((byte)(c >> 12 & 0xF | 0xE0));\n\t\t\t\tprint((byte)(c >> 6 & 0x3F | 0x80));\n\t\t\t\tprint((byte)(c & 0x3F | 0x80));\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(char[] s) {\n\t\t\tfor (char i : s)\n\t\t\t\tprint(i);\n\t\t}\n\n\t\tpublic void print(String s) {\n\t\t\ttry {\n\t\t\t\tif (READ_STRING_TO_BYTE_ARRAY == 0) {\n\t\t\t\t\tjava.lang.reflect.Field strValueField = s.getClass().getDeclaredField(\"value\");\n\t\t\t\t\tstrValueField.setAccessible(true);\n\t\t\t\t\tbyte[] c = (byte[])strValueField.get(s);\n\t\t\t\t\tstrValueField.setAccessible(false);\n\t\t\t\t\tstrValueField = s.getClass().getDeclaredField(\"coder\");\n\t\t\t\t\tstrValueField.setAccessible(true);\n\t\t\t\t\tbyte coder = (byte)strValueField.get(s);\n\t\t\t\t\tstrValueField.setAccessible(false);\n\t\t\t\t\tif (coder == 0) {\n\t\t\t\t\t\tfor (byte b : c)\n\t\t\t\t\t\t\tprint(b);\n\t\t\t\t\t} else if (coder == 1) {\n\t\t\t\t\t\tfor (int i = 0; i < c.length; i += 2)\n\t\t\t\t\t\t\tprint((char)(c[i] | c[i + 1] << 8));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprint(s.toCharArray());\n\t\t\t\t\t}\n\t\t\t\t} else if (READ_STRING_TO_BYTE_ARRAY == 1) {\n\t\t\t\t\tjava.lang.reflect.Field strValueField = s.getClass().getDeclaredField(\"value\");\n\t\t\t\t\tstrValueField.setAccessible(true);\n\t\t\t\t\tprint((char[])strValueField.get(s));\n\t\t\t\t\tstrValueField.setAccessible(false);\n\t\t\t\t} else {\n\t\t\t\t\tprint(s.toCharArray());\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tprint(s.toCharArray());\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(Object o) {\n\t\t\tprint(o.toString());\n\t\t}\n\n\t\tpublic void printf(java.util.Locale l, String format, Object... args) {\n\t\t\tprint(String.format(l, format, args));\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tprint(String.format(format, args));\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tprint((byte)'\\n');\n\t\t\tif (autoFlush) flush();\n\t\t}\n\n\t\tpublic void println(boolean b) {\n\t\t\tprint(b);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(byte b) {\n\t\t\tprint(b);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(short s) {\n\t\t\tprint(s);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tprint(i);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tprint(l);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(float f) {\n\t\t\tprint(f);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(double d) {\n\t\t\tprint(d);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(double d, int n) {\n\t\t\tprint(d, n);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(char c) {\n\t\t\tprint(c);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(char[] s) {\n\t\t\tprint(s);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tprint(s);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println(Object o) {\n\t\t\tprint(o);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic Output append(char c) {\n\t\t\tprint(c);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Output append(CharSequence csq) {\n\t\t\tif (csq == null) csq = \"null\";\n\t\t\tprint(csq.toString());\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Output append(CharSequence csq, int start, int end) {\n\t\t\tif (csq == null) csq = \"null\";\n\t\t\tprint(csq.subSequence(start, end).toString());\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tpublic static final class DisjointSetUnion {\n\n\t\tprivate final int[] parent;\n\n\t\tprivate DisjointSetUnion(int n) {\n\t\t\tparent = new int[n];\n\t\t\tjava.util.Arrays.fill(parent, -1);\n\t\t}\n\n\t\tpublic static DisjointSetUnion create(int n) {\n\t\t\treturn new DisjointSetUnion(n);\n\t\t}\n\n\t\tpublic int getLeader(int a) {\n\t\t\tint p1, p2;\n\t\t\twhile ((p1 = parent[a]) >= 0) {\n\t\t\t\tif ((p2 = parent[p1]) >= 0) a = parent[a] = p2;\n\t\t\t\telse return p1;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int merge(int a, int b) {\n\t\t\ta = getLeader(a);\n\t\t\tb = getLeader(b);\n\t\t\tif (a == b) return a;\n\t\t\tif (parent[a] < parent[b]) {\n\t\t\t\tparent[b] += parent[a];\n\t\t\t\tparent[a] = b;\n\t\t\t\treturn b;\n\t\t\t}\n\t\t\tparent[a] += parent[b];\n\t\t\tparent[b] = a;\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean isSame(int a, int b) {\n\t\t\treturn getLeader(a) == getLeader(b);\n\t\t}\n\n\t\tpublic int getSize(int a) {\n\t\t\treturn -parent[getLeader(a)];\n\t\t}\n\n\t\tpublic java.util.ArrayList<java.util.ArrayList<Integer>> getGroups() {\n\t\t\tObject[] group = new Object[parent.length];\n\t\t\tjava.util.ArrayList<java.util.ArrayList<Integer>> ret = new java.util.ArrayList<>();\n\t\t\tfor (int i = 0; i < parent.length; ++i) {\n\t\t\t\tint leader = getLeader(i);\n\t\t\t\tObject put = group[leader];\n\t\t\t\tif (put == null) {\n\t\t\t\t\tjava.util.ArrayList<Integer> list = new java.util.ArrayList<>();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tret.add(list);\n\t\t\t\t\tgroup[leader] = list;\n\t\t\t\t} else {\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tjava.util.ArrayList<Integer> list = (java.util.ArrayList<Integer>)put;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getGroups().toString();\n\t\t}\n\t}\n\n\tpublic static final class IntFenwickTree {\n\n\t\tprivate final int[] array;\n\n\t\tprivate IntFenwickTree(int n) {\n\t\t\tarray = new int[n + 1];\n\t\t}\n\n\t\tprivate IntFenwickTree(int[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 1, array.length);\n\t\t\tfor (int i = 1; i < this.array.length; ++i)\n\t\t\t\tif (i + (i & -i) < this.array.length) this.array[i + (i & -i)] += this.array[i];\n\t\t}\n\n\t\tpublic static IntFenwickTree create(int n) {\n\t\t\treturn new IntFenwickTree(n);\n\t\t}\n\n\t\tpublic static IntFenwickTree create(int[] array) {\n\t\t\treturn new IntFenwickTree(array);\n\t\t}\n\n\t\tpublic void add(int index, int add) {\n\t\t\t++index;\n\t\t\twhile (index < array.length) {\n\t\t\t\tarray[index] += add;\n\t\t\t\tindex += index & -index;\n\t\t\t}\n\t\t}\n\n\t\tprivate int sum(int index) {\n\t\t\tint sum = 0;\n\t\t\twhile (index > 0) {\n\t\t\t\tsum += array[index];\n\t\t\t\tindex -= index & -index;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\n\t\tpublic int sum(int l, int r) {\n\t\t\treturn sum(r) - sum(l);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn java.util.stream.IntStream.range(0, array.length - 1).mapToObj(i -> String.valueOf(sum(i + 1) - sum(i))).collect(\n\t\t\t\t\tjava.util.stream.Collectors.joining(\", \", \"[\", \"]\"));\n\t\t}\n\t}\n\n\tpublic static final class LongFenwickTree {\n\n\t\tprivate final long[] array;\n\n\t\tprivate LongFenwickTree(int n) {\n\t\t\tarray = new long[n + 1];\n\t\t}\n\n\t\tprivate LongFenwickTree(long[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 1, array.length);\n\t\t\tfor (int i = 1; i < this.array.length; ++i)\n\t\t\t\tif (i + (i & -i) < this.array.length) this.array[i + (i & -i)] += this.array[i];\n\t\t}\n\n\t\tpublic static LongFenwickTree create(int n) {\n\t\t\treturn new LongFenwickTree(n);\n\t\t}\n\n\t\tpublic static LongFenwickTree create(long[] array) {\n\t\t\treturn new LongFenwickTree(array);\n\t\t}\n\n\t\tpublic void add(int index, long add) {\n\t\t\t++index;\n\t\t\twhile (index < array.length) {\n\t\t\t\tarray[index] += add;\n\t\t\t\tindex += index & -index;\n\t\t\t}\n\t\t}\n\n\t\tprivate long sum(int index) {\n\t\t\tlong sum = 0;\n\t\t\twhile (index > 0) {\n\t\t\t\tsum += array[index];\n\t\t\t\tindex -= index & -index;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\n\t\tpublic long sum(int l, int r) {\n\t\t\treturn sum(r) - sum(l);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn java.util.stream.IntStream.range(0, array.length - 1).mapToObj(i -> String.valueOf(sum(i + 1) - sum(i))).collect(\n\t\t\t\t\tjava.util.stream.Collectors.joining(\", \", \"[\", \"]\"));\n\t\t}\n\t}\n\n\tpublic static final class MathLib {\n\n\t\tprivate static long safe_mod(long x, long m) {\n\t\t\tx %= m;\n\t\t\tif (x < 0) x += m;\n\t\t\treturn x;\n\t\t}\n\n\t\tprivate static long[] inv_gcd(long a, long b) {\n\t\t\ta = safe_mod(a, b);\n\t\t\tif (a == 0) return new long[]{b, 0};\n\n\t\t\tlong s = b, t = a;\n\t\t\tlong m0 = 0, m1 = 1;\n\t\t\twhile (t > 0) {\n\t\t\t\tlong u = s / t;\n\t\t\t\ts -= t * u;\n\t\t\t\tm0 -= m1 * u;\n\t\t\t\tlong tmp = s;\n\t\t\t\ts = t;\n\t\t\t\tt = tmp;\n\t\t\t\ttmp = m0;\n\t\t\t\tm0 = m1;\n\t\t\t\tm1 = tmp;\n\t\t\t}\n\t\t\tif (m0 < 0) m0 += b / s;\n\t\t\treturn new long[]{s, m0};\n\t\t}\n\n\t\tpublic static long pow_mod(long x, long n, long m) {\n\t\t\tassert (n >= 0 && m >= 1);\n\t\t\tlong ans = 1;\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 == 1) ans = (ans * x) % m;\n\t\t\t\tx = (x * x) % m;\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic static long[] crt(long[] r, long[] m) {\n\t\t\tassert (r.length == m.length);\n\t\t\tint n = r.length;\n\n\t\t\tlong r0 = 0, m0 = 1;\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tassert (1 <= m[i]);\n\t\t\t\tlong r1 = safe_mod(r[i], m[i]), m1 = m[i];\n\t\t\t\tif (m0 < m1) {\n\t\t\t\t\tlong tmp = r0;\n\t\t\t\t\tr0 = r1;\n\t\t\t\t\tr1 = tmp;\n\t\t\t\t\ttmp = m0;\n\t\t\t\t\tm0 = m1;\n\t\t\t\t\tm1 = tmp;\n\t\t\t\t}\n\t\t\t\tif (m0 % m1 == 0) {\n\t\t\t\t\tif (r0 % m1 != r1) return new long[]{0, 0};\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlong[] ig = inv_gcd(m0, m1);\n\t\t\t\tlong g = ig[0], im = ig[1];\n\n\t\t\t\tlong u1 = m1 / g;\n\t\t\t\tif ((r1 - r0) % g != 0) return new long[]{0, 0};\n\n\t\t\t\tlong x = (r1 - r0) / g % u1 * im % u1;\n\n\t\t\t\tr0 += x * m0;\n\t\t\t\tm0 *= u1;\n\t\t\t\tif (r0 < 0) r0 += m0;\n\t\t\t\t//System.err.printf(\"%d %d\\n\", r0, m0);\n\t\t\t}\n\t\t\treturn new long[]{r0, m0};\n\t\t}\n\n\t\tpublic static long floor_sum(long n, long m, long a, long b) {\n\t\t\tlong ans = 0;\n\t\t\tif (a >= m) {\n\t\t\t\tans += (n - 1) * n * (a / m) / 2;\n\t\t\t\ta %= m;\n\t\t\t}\n\t\t\tif (b >= m) {\n\t\t\t\tans += n * (b / m);\n\t\t\t\tb %= m;\n\t\t\t}\n\n\t\t\tlong y_max = (a * n + b) / m;\n\t\t\tlong x_max = y_max * m - b;\n\t\t\tif (y_max == 0) return ans;\n\t\t\tans += (n - (x_max + a - 1) / a) * y_max;\n\t\t\tans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t/**\n\t * @verified https://atcoder.jp/contests/practice2/tasks/practice2_d\n\t */\n\tpublic static final class MaxFlow {\n\n\t\tpublic class CapEdge {\n\n\t\t\tprivate final int from, to;\n\t\t\tprivate long cap;\n\t\t\tprivate final int rev;\n\n\t\t\tCapEdge(int from, int to, long cap, int rev) {\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\n\t\t\tpublic int getFrom() {\n\t\t\t\treturn from;\n\t\t\t}\n\n\t\t\tpublic int getTo() {\n\t\t\t\treturn to;\n\t\t\t}\n\n\t\t\tpublic long getCap() {\n\t\t\t\treturn cap;\n\t\t\t}\n\n\t\t\tpublic long getFlow() {\n\t\t\t\treturn g[to][rev].cap;\n\t\t\t}\n\t\t}\n\n\t\tprivate static final long INF = Long.MAX_VALUE;\n\n\t\tprivate final int n;\n\t\tprivate int m;\n\t\tprivate final java.util.ArrayList<CapEdge> edges;\n\t\tprivate final int[] count;\n\t\tprivate final CapEdge[][] g;\n\n\t\tpublic MaxFlow(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.edges = new java.util.ArrayList<>();\n\t\t\tthis.count = new int[n];\n\t\t\tthis.g = new CapEdge[n][];\n\t\t}\n\n\t\tpublic int addEdge(int from, int to, long cap) {\n\t\t\trangeCheck(from, 0, n);\n\t\t\trangeCheck(to, 0, n);\n\t\t\tnonNegativeCheck(cap, \"Capacity\");\n\t\t\tCapEdge e = new CapEdge(from, to, cap, count[to]);\n\t\t\tcount[from]++ ;\n\t\t\tcount[to]++ ;\n\t\t\tedges.add(e);\n\t\t\treturn m++ ;\n\t\t}\n\n\t\tpublic CapEdge getEdge(int i) {\n\t\t\trangeCheck(i, 0, m);\n\t\t\treturn edges.get(i);\n\t\t}\n\n\t\tpublic java.util.ArrayList<CapEdge> getEdges() {\n\t\t\treturn edges;\n\t\t}\n\n\t\tpublic void changeEdge(int i, long newCap, long newFlow) {\n\t\t\trangeCheck(i, 0, m);\n\t\t\tnonNegativeCheck(newCap, \"Capacity\");\n\t\t\tif (newFlow > newCap) {\n\t\t\t\tthrow new IllegalArgumentException(String.format(\"Flow %d is greater than capacity %d.\", newCap, newFlow));\n\t\t\t}\n\t\t\tCapEdge e = edges.get(i);\n\t\t\tCapEdge er = g[e.to][e.rev];\n\t\t\te.cap = newCap - newFlow;\n\t\t\ter.cap = newFlow;\n\t\t}\n\n\t\tprivate void buildGraph() {\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tg[i] = new CapEdge[count[i]];\n\t\t\t}\n\t\t\tint[] idx = new int[n];\n\t\t\tfor (CapEdge e : edges) {\n\t\t\t\tg[e.to][idx[e.to]++ ] = new CapEdge(e.to, e.from, 0, idx[e.from]);\n\t\t\t\tg[e.from][idx[e.from]++ ] = e;\n\t\t\t}\n\t\t}\n\n\t\tpublic long maxFlow(int s, int t) {\n\t\t\treturn flow(s, t, INF);\n\t\t}\n\n\t\tpublic long flow(int s, int t, long flowLimit) {\n\t\t\trangeCheck(s, 0, n);\n\t\t\trangeCheck(t, 0, n);\n\t\t\tbuildGraph();\n\t\t\tlong flow = 0;\n\t\t\tint[] level = new int[n];\n\t\t\tint[] que = new int[n];\n\t\t\tint[] iter = new int[n];\n\t\t\twhile (true) {\n\t\t\t\tjava.util.Arrays.fill(level, -1);\n\t\t\t\tdinicBFS(s, t, level, que);\n\t\t\t\tif (level[t] < 0) return flow;\n\t\t\t\tjava.util.Arrays.fill(iter, 0);\n\t\t\t\twhile (true) {\n\t\t\t\t\tlong d = dinicDFS(t, s, flowLimit - flow, iter, level);\n\t\t\t\t\tif (d <= 0) break;\n\t\t\t\t\tflow += d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void dinicBFS(int s, int t, int[] level, int[] que) {\n\t\t\tint hd = 0, tl = 0;\n\t\t\tque[tl++ ] = s;\n\t\t\tlevel[s] = 0;\n\t\t\twhile (tl > hd) {\n\t\t\t\tint u = que[hd++ ];\n\t\t\t\tfor (CapEdge e : g[u]) {\n\t\t\t\t\tint v = e.to;\n\t\t\t\t\tif (e.cap <= 0 || level[v] >= 0) continue;\n\t\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\t\tif (v == t) return;\n\t\t\t\t\tque[tl++ ] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate long dinicDFS(int cur, int s, long f, int[] iter, int[] level) {\n\t\t\tif (cur == s) return f;\n\t\t\tlong res = 0;\n\t\t\twhile (iter[cur] < count[cur]) {\n\t\t\t\tCapEdge er = g[cur][iter[cur]++ ];\n\t\t\t\tint u = er.to;\n\t\t\t\tCapEdge e = g[u][er.rev];\n\t\t\t\tif (level[u] >= level[cur] || e.cap <= 0) continue;\n\t\t\t\tlong d = dinicDFS(u, s, Math.min(f - res, e.cap), iter, level);\n\t\t\t\tif (d <= 0) continue;\n\t\t\t\te.cap -= d;\n\t\t\t\ter.cap += d;\n\t\t\t\tres += d;\n\t\t\t\tif (res == f) break;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long fordFulkersonMaxFlow(int s, int t) {\n\t\t\treturn fordFulkersonFlow(s, t, INF);\n\t\t}\n\n\t\tpublic long fordFulkersonFlow(int s, int t, long flowLimit) {\n\t\t\trangeCheck(s, 0, n);\n\t\t\trangeCheck(t, 0, n);\n\t\t\tbuildGraph();\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tlong flow = 0;\n\t\t\twhile (true) {\n\t\t\t\tjava.util.Arrays.fill(used, false);\n\t\t\t\tlong f = fordFulkersonDFS(s, t, flowLimit - flow, used);\n\t\t\t\tif (f <= 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\n\t\tprivate long fordFulkersonDFS(int cur, int t, long f, boolean[] used) {\n\t\t\tif (cur == t) return f;\n\t\t\tused[cur] = true;\n\t\t\tfor (CapEdge e : g[cur]) {\n\t\t\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\t\t\tlong d = fordFulkersonDFS(e.to, t, Math.min(f, e.cap), used);\n\t\t\t\tif (d <= 0) continue;\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic boolean[] minCut(int s) {\n\t\t\trangeCheck(s, 0, n);\n\t\t\tboolean[] reachable = new boolean[n];\n\t\t\tint[] stack = new int[n];\n\t\t\tint ptr = 0;\n\t\t\tstack[ptr++ ] = s;\n\t\t\treachable[s] = true;\n\t\t\twhile (ptr > 0) {\n\t\t\t\tint u = stack[ --ptr];\n\t\t\t\tfor (CapEdge e : g[u]) {\n\t\t\t\t\tint v = e.to;\n\t\t\t\t\tif (reachable[v] || e.cap <= 0) continue;\n\t\t\t\t\treachable[v] = true;\n\t\t\t\t\tstack[ptr++ ] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reachable;\n\t\t}\n\n\t\tprivate static void rangeCheck(int i, int minInlusive, int maxExclusive) {\n\t\t\tif (i < 0 || i >= maxExclusive) {\n\t\t\t\tthrow new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for length %d\", i, maxExclusive));\n\t\t\t}\n\t\t}\n\n\t\tprivate static void nonNegativeCheck(long cap, java.lang.String attribute) {\n\t\t\tif (cap < 0) { throw new IllegalArgumentException(String.format(\"%s %d is negative.\", attribute, cap)); }\n\t\t}\n\t}\n\n\t/**\n\t * @verified\n\t * \t\t- https://atcoder.jp/contests/practice2/tasks/practice2_e\n\t *           - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B\n\t */\n\tpublic static final class MinCostFlow {\n\n\t\tpublic class WeightedCapEdge {\n\n\t\t\tprivate final int from, to;\n\t\t\tprivate long cap;\n\t\t\tprivate long cost;\n\t\t\tprivate final int rev;\n\n\t\t\tWeightedCapEdge(int from, int to, long cap, long cost, int rev) {\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t\tthis.cost = cost;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\n\t\t\tpublic int getFrom() {\n\t\t\t\treturn from;\n\t\t\t}\n\n\t\t\tpublic int getTo() {\n\t\t\t\treturn to;\n\t\t\t}\n\n\t\t\tpublic long getCap() {\n\t\t\t\treturn cap;\n\t\t\t}\n\n\t\t\tpublic long getCost() {\n\t\t\t\treturn cost;\n\t\t\t}\n\n\t\t\tpublic long getFlow() {\n\t\t\t\treturn g[to][rev].cap;\n\t\t\t}\n\t\t}\n\n\t\tprivate static final long INF = Long.MAX_VALUE;\n\n\t\tprivate final int n;\n\t\tprivate int m;\n\t\tprivate final java.util.ArrayList<WeightedCapEdge> edges;\n\t\tprivate final int[] count;\n\t\tprivate final WeightedCapEdge[][] g;\n\t\tprivate final long[] potential;\n\n\t\tprivate final long[] dist;\n\t\tprivate final WeightedCapEdge[] prev;\n\n\t\tpublic MinCostFlow(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.edges = new java.util.ArrayList<>();\n\t\t\tthis.count = new int[n];\n\t\t\tthis.g = new WeightedCapEdge[n][];\n\t\t\tthis.potential = new long[n];\n\t\t\tthis.dist = new long[n];\n\t\t\tthis.prev = new WeightedCapEdge[n];\n\t\t}\n\n\t\tpublic int addEdge(int from, int to, long cap, long cost) {\n\t\t\trangeCheck(from, 0, n);\n\t\t\trangeCheck(to, 0, n);\n\t\t\tnonNegativeCheck(cap, \"Capacity\");\n\t\t\tnonNegativeCheck(cost, \"Cost\");\n\t\t\tWeightedCapEdge e = new WeightedCapEdge(from, to, cap, cost, count[to]);\n\t\t\tcount[from]++ ;\n\t\t\tcount[to]++ ;\n\t\t\tedges.add(e);\n\t\t\treturn m++ ;\n\t\t}\n\n\t\tprivate void buildGraph() {\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tg[i] = new WeightedCapEdge[count[i]];\n\t\t\t}\n\t\t\tint[] idx = new int[n];\n\t\t\tfor (WeightedCapEdge e : edges) {\n\t\t\t\tg[e.to][idx[e.to]++ ] = new WeightedCapEdge(e.to, e.from, 0, -e.cost, idx[e.from]);\n\t\t\t\tg[e.from][idx[e.from]++ ] = e;\n\t\t\t}\n\t\t}\n\n\t\tprivate long addFlow;\n\t\tprivate long addCost;\n\n\t\tpublic long[] minCostMaxFlow(int s, int t) {\n\t\t\treturn minCostFlow(s, t, INF);\n\t\t}\n\n\t\tpublic long[] minCostFlow(int s, int t, long flowLimit) {\n\t\t\trangeCheck(s, 0, n);\n\t\t\trangeCheck(t, 0, n);\n\t\t\tif (s == t) { throw new IllegalArgumentException(String.format(\"s = t = %d\", s)); }\n\t\t\tnonNegativeCheck(flowLimit, \"Flow\");\n\t\t\tbuildGraph();\n\t\t\tlong flow = 0;\n\t\t\tlong cost = 0;\n\t\t\twhile (true) {\n\t\t\t\tdijkstra(s, t, flowLimit - flow);\n\t\t\t\tif (addFlow == 0) break;\n\t\t\t\tflow += addFlow;\n\t\t\t\tcost += addFlow * addCost;\n\t\t\t}\n\t\t\treturn new long[]{flow, cost};\n\t\t}\n\n\t\tpublic java.util.ArrayList<long[]> minCostSlope(int s, int t) {\n\t\t\treturn minCostSlope(s, t, INF);\n\t\t}\n\n\t\tpublic java.util.ArrayList<long[]> minCostSlope(int s, int t, long flowLimit) {\n\t\t\trangeCheck(s, 0, n);\n\t\t\trangeCheck(t, 0, n);\n\t\t\tif (s == t) { throw new IllegalArgumentException(String.format(\"s = t = %d\", s)); }\n\t\t\tnonNegativeCheck(flowLimit, \"Flow\");\n\t\t\tbuildGraph();\n\t\t\tjava.util.ArrayList<long[]> slope = new java.util.ArrayList<>();\n\t\t\tlong prevCost = -1;\n\t\t\tlong flow = 0;\n\t\t\tlong cost = 0;\n\t\t\twhile (true) {\n\t\t\t\tslope.add(new long[]{flow, cost});\n\t\t\t\tdijkstra(s, t, flowLimit - flow);\n\t\t\t\tif (addFlow == 0) return slope;\n\t\t\t\tflow += addFlow;\n\t\t\t\tcost += addFlow * addCost;\n\t\t\t\tif (addCost == prevCost) {\n\t\t\t\t\tslope.remove(slope.size() - 1);\n\t\t\t\t}\n\t\t\t\tprevCost = addCost;\n\t\t\t}\n\t\t}\n\n\t\tprivate void dijkstra(int s, int t, long maxFlow) {\n\t\t\tfinal class State implements Comparable<State> {\n\n\t\t\t\tfinal int v;\n\t\t\t\tfinal long d;\n\n\t\t\t\tState(int v, long d) {\n\t\t\t\t\tthis.v = v;\n\t\t\t\t\tthis.d = d;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compareTo(State s) {\n\t\t\t\t\treturn d == s.d ? v - s.v : d > s.d ? 1 : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tjava.util.Arrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tjava.util.PriorityQueue<State> pq = new java.util.PriorityQueue<>();\n\t\t\tpq.add(new State(s, 0l));\n\t\t\twhile (pq.size() > 0) {\n\t\t\t\tState st = pq.poll();\n\t\t\t\tint u = st.v;\n\t\t\t\tif (st.d != dist[u]) continue;\n\t\t\t\tfor (WeightedCapEdge e : g[u]) {\n\t\t\t\t\tif (e.cap <= 0) continue;\n\t\t\t\t\tint v = e.to;\n\t\t\t\t\tlong nextCost = dist[u] + e.cost + potential[u] - potential[v];\n\t\t\t\t\tif (nextCost < dist[v]) {\n\t\t\t\t\t\tdist[v] = nextCost;\n\t\t\t\t\t\tprev[v] = e;\n\t\t\t\t\t\tpq.add(new State(v, dist[v]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) {\n\t\t\t\taddFlow = 0;\n\t\t\t\taddCost = INF;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tpotential[i] += dist[i];\n\t\t\t}\n\t\t\taddCost = 0;\n\t\t\taddFlow = maxFlow;\n\t\t\tfor (int v = t; v != s;) {\n\t\t\t\tWeightedCapEdge e = prev[v];\n\t\t\t\taddCost += e.cost;\n\t\t\t\taddFlow = java.lang.Math.min(addFlow, e.cap);\n\t\t\t\tv = e.from;\n\t\t\t}\n\t\t\tfor (int v = t; v != s;) {\n\t\t\t\tWeightedCapEdge e = prev[v];\n\t\t\t\te.cap -= addFlow;\n\t\t\t\tg[v][e.rev].cap += addFlow;\n\t\t\t\tv = e.from;\n\t\t\t}\n\t\t}\n\n\t\tpublic void clearFlow() {\n\t\t\tjava.util.Arrays.fill(potential, 0);\n\t\t\tfor (WeightedCapEdge e : edges) {\n\t\t\t\tlong flow = e.getFlow();\n\t\t\t\te.cap += flow;\n\t\t\t\tg[e.to][e.rev].cap -= flow;\n\t\t\t}\n\t\t}\n\n\t\tpublic WeightedCapEdge getEdge(int i) {\n\t\t\trangeCheck(i, 0, m);\n\t\t\treturn edges.get(i);\n\t\t}\n\n\t\tpublic java.util.ArrayList<WeightedCapEdge> getEdges() {\n\t\t\treturn edges;\n\t\t}\n\n\t\tprivate static void rangeCheck(int i, int minInlusive, int maxExclusive) {\n\t\t\tif (i < 0 || i >= maxExclusive) {\n\t\t\t\tthrow new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for length %d\", i, maxExclusive));\n\t\t\t}\n\t\t}\n\n\t\tprivate static void nonNegativeCheck(long cap, java.lang.String attribute) {\n\t\t\tif (cap < 0) { throw new IllegalArgumentException(String.format(\"%s %d is negative.\", attribute, cap)); }\n\t\t}\n\t}\n\n\t/**\n\t * @verified\n\t *           <ul>\n\t *           <li>https://atcoder.jp/contests/arc050/tasks/arc050_c\n\t *           <li>https://atcoder.jp/contests/abc129/tasks/abc129_f\n\t *           </ul>\n\t */\n\tpublic static final class ModIntFactory {\n\n\t\tprivate final ModArithmetic ma;\n\t\tprivate final int mod;\n\n\t\tpublic ModIntFactory(int mod) {\n\t\t\tthis.ma = ModArithmetic.of(mod);\n\t\t\tthis.mod = mod;\n\t\t}\n\n\t\tpublic ModInt create(long value) {\n\t\t\tif ((value %= mod) < 0) value += mod;\n\t\t\tif (ma instanceof ModArithmetic.ModArithmeticMontgomery) {\n\t\t\t\treturn new ModInt(((ModArithmetic.ModArithmeticMontgomery)ma).generate(value));\n\t\t\t}\n\t\t\treturn new ModInt((int)value);\n\t\t}\n\n\t\tclass ModInt {\n\n\t\t\tprivate int value;\n\n\t\t\tprivate ModInt(int value) {\n\t\t\t\tthis.value = value;\n\t\t\t}\n\n\t\t\tpublic int mod() {\n\t\t\t\treturn mod;\n\t\t\t}\n\n\t\t\tpublic int value() {\n\t\t\t\tif (ma instanceof ModArithmetic.ModArithmeticMontgomery) {\n\t\t\t\t\treturn ((ModArithmetic.ModArithmeticMontgomery)ma).reduce(value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tpublic ModInt add(ModInt mi) {\n\t\t\t\treturn new ModInt(ma.add(value, mi.value));\n\t\t\t}\n\n\t\t\tpublic ModInt add(ModInt mi1, ModInt mi2) {\n\t\t\t\treturn new ModInt(ma.add(value, mi1.value)).addAsg(mi2);\n\t\t\t}\n\n\t\t\tpublic ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {\n\t\t\t\treturn new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);\n\t\t\t}\n\n\t\t\tpublic ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n\t\t\t\treturn new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);\n\t\t\t}\n\n\t\t\tpublic ModInt add(ModInt mi1, ModInt... mis) {\n\t\t\t\tModInt mi = add(mi1);\n\t\t\t\tfor (ModInt m : mis)\n\t\t\t\t\tmi.addAsg(m);\n\t\t\t\treturn mi;\n\t\t\t}\n\n\t\t\tpublic ModInt add(long mi) {\n\t\t\t\treturn new ModInt(ma.add(value, ma.remainder(mi)));\n\t\t\t}\n\n\t\t\tpublic ModInt sub(ModInt mi) {\n\t\t\t\treturn new ModInt(ma.sub(value, mi.value));\n\t\t\t}\n\n\t\t\tpublic ModInt sub(long mi) {\n\t\t\t\treturn new ModInt(ma.sub(value, ma.remainder(mi)));\n\t\t\t}\n\n\t\t\tpublic ModInt mul(ModInt mi) {\n\t\t\t\treturn new ModInt(ma.mul(value, mi.value));\n\t\t\t}\n\n\t\t\tpublic ModInt mul(ModInt mi1, ModInt mi2) {\n\t\t\t\treturn new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);\n\t\t\t}\n\n\t\t\tpublic ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {\n\t\t\t\treturn new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);\n\t\t\t}\n\n\t\t\tpublic ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n\t\t\t\treturn new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);\n\t\t\t}\n\n\t\t\tpublic ModInt mul(ModInt mi1, ModInt... mis) {\n\t\t\t\tModInt mi = mul(mi1);\n\t\t\t\tfor (ModInt m : mis)\n\t\t\t\t\tmi.mulAsg(m);\n\t\t\t\treturn mi;\n\t\t\t}\n\n\t\t\tpublic ModInt mul(long mi) {\n\t\t\t\treturn new ModInt(ma.mul(value, ma.remainder(mi)));\n\t\t\t}\n\n\t\t\tpublic ModInt div(ModInt mi) {\n\t\t\t\treturn new ModInt(ma.div(value, mi.value));\n\t\t\t}\n\n\t\t\tpublic ModInt div(long mi) {\n\t\t\t\treturn new ModInt(ma.div(value, ma.remainder(mi)));\n\t\t\t}\n\n\t\t\tpublic ModInt inv() {\n\t\t\t\treturn new ModInt(ma.inv(value));\n\t\t\t}\n\n\t\t\tpublic ModInt pow(long b) {\n\t\t\t\treturn new ModInt(ma.pow(value, b));\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(ModInt mi) {\n\t\t\t\tthis.value = ma.add(value, mi.value);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(ModInt mi1, ModInt mi2) {\n\t\t\t\treturn addAsg(mi1).addAsg(mi2);\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {\n\t\t\t\treturn addAsg(mi1).addAsg(mi2).addAsg(mi3);\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n\t\t\t\treturn addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(ModInt... mis) {\n\t\t\t\tfor (ModInt m : mis)\n\t\t\t\t\taddAsg(m);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt addAsg(long mi) {\n\t\t\t\tthis.value = ma.add(value, ma.remainder(mi));\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt subAsg(ModInt mi) {\n\t\t\t\tthis.value = ma.sub(value, mi.value);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt subAsg(long mi) {\n\t\t\t\tthis.value = ma.sub(value, ma.remainder(mi));\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(ModInt mi) {\n\t\t\t\tthis.value = ma.mul(value, mi.value);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(ModInt mi1, ModInt mi2) {\n\t\t\t\treturn mulAsg(mi1).mulAsg(mi2);\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {\n\t\t\t\treturn mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {\n\t\t\t\treturn mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(ModInt... mis) {\n\t\t\t\tfor (ModInt m : mis)\n\t\t\t\t\tmulAsg(m);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt mulAsg(long mi) {\n\t\t\t\tthis.value = ma.mul(value, ma.remainder(mi));\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt divAsg(ModInt mi) {\n\t\t\t\tthis.value = ma.div(value, mi.value);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tpublic ModInt divAsg(long mi) {\n\t\t\t\tthis.value = ma.div(value, ma.remainder(mi));\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn String.valueOf(value());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object o) {\n\t\t\t\tif (o instanceof ModInt) {\n\t\t\t\t\tModInt mi = (ModInt)o;\n\t\t\t\t\treturn mod() == mi.mod() && value() == mi.value();\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\treturn (1 * 37 + mod()) * 37 + value();\n\t\t\t}\n\t\t}\n\n\t\tprivate interface ModArithmetic {\n\n\t\t\tpublic int mod();\n\n\t\t\tpublic int remainder(long value);\n\n\t\t\tpublic int add(int a, int b);\n\n\t\t\tpublic int sub(int a, int b);\n\n\t\t\tpublic int mul(int a, int b);\n\n\t\t\tpublic default int div(int a, int b) {\n\t\t\t\treturn mul(a, inv(b));\n\t\t\t}\n\n\t\t\tpublic int inv(int a);\n\n\t\t\tpublic int pow(int a, long b);\n\n\t\t\tpublic static ModArithmetic of(int mod) {\n\t\t\t\tif (mod <= 0) {\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t} else if (mod == 1) {\n\t\t\t\t\treturn new ModArithmetic1();\n\t\t\t\t} else if (mod == 2) {\n\t\t\t\t\treturn new ModArithmetic2();\n\t\t\t\t} else if (mod == 998244353) {\n\t\t\t\t\treturn new ModArithmetic998244353();\n\t\t\t\t} else if (mod == 1000000007) {\n\t\t\t\t\treturn new ModArithmetic1000000007();\n\t\t\t\t} else if ((mod & 1) == 1) {\n\t\t\t\t\treturn new ModArithmeticMontgomery(mod);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ModArithmeticBarrett(mod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmetic1 implements ModArithmetic {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mod() {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int add(int a, int b) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int sub(int a, int b) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\tthrow new ArithmeticException(\"divide by zero\");\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmetic2 implements ModArithmetic {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mod() {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn (int)(value & 1);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int add(int a, int b) {\n\t\t\t\t\treturn a ^ b;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int sub(int a, int b) {\n\t\t\t\t\treturn a ^ b;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn a & b;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\tif (a == 0) throw new ArithmeticException(\"divide by zero\");\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\tif (b == 0) return 1;\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmetic998244353 implements ModArithmetic {\n\n\t\t\t\tprivate final int mod = 998244353;\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mod() {\n\t\t\t\t\treturn mod;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn (int)((value %= mod) < 0 ? value + mod : value);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int add(int a, int b) {\n\t\t\t\t\tint res = a + b;\n\t\t\t\t\treturn res >= mod ? res - mod : res;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int sub(int a, int b) {\n\t\t\t\t\tint res = a - b;\n\t\t\t\t\treturn res < 0 ? res + mod : res;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn (int)(((long)a * b) % mod);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\tint b = mod;\n\t\t\t\t\tlong u = 1, v = 0;\n\t\t\t\t\twhile (b >= 1) {\n\t\t\t\t\t\tlong t = a / b;\n\t\t\t\t\t\ta -= t * b;\n\t\t\t\t\t\tint tmp1 = a;\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t\tb = tmp1;\n\t\t\t\t\t\tu -= t * v;\n\t\t\t\t\t\tlong tmp2 = u;\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tv = tmp2;\n\t\t\t\t\t}\n\t\t\t\t\tu %= mod;\n\t\t\t\t\tif (a != 1) { throw new ArithmeticException(\"divide by zero\"); }\n\t\t\t\t\treturn (int)(u < 0 ? u + mod : u);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\tif (b < 0) throw new ArithmeticException(\"negative power\");\n\t\t\t\t\tlong res = 1;\n\t\t\t\t\tlong pow2 = a;\n\t\t\t\t\tlong idx = 1;\n\t\t\t\t\twhile (b > 0) {\n\t\t\t\t\t\tlong lsb = b & -b;\n\t\t\t\t\t\tfor (; lsb != idx; idx <<= 1) {\n\t\t\t\t\t\t\tpow2 = (pow2 * pow2) % mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = (res * pow2) % mod;\n\t\t\t\t\t\tb ^= lsb;\n\t\t\t\t\t}\n\t\t\t\t\treturn (int)res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmetic1000000007 implements ModArithmetic {\n\n\t\t\t\tprivate final int mod = 1000000007;\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mod() {\n\t\t\t\t\treturn mod;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn (int)((value %= mod) < 0 ? value + mod : value);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int add(int a, int b) {\n\t\t\t\t\tint res = a + b;\n\t\t\t\t\treturn res >= mod ? res - mod : res;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int sub(int a, int b) {\n\t\t\t\t\tint res = a - b;\n\t\t\t\t\treturn res < 0 ? res + mod : res;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn (int)(((long)a * b) % mod);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int div(int a, int b) {\n\t\t\t\t\treturn mul(a, inv(b));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\tint b = mod;\n\t\t\t\t\tlong u = 1, v = 0;\n\t\t\t\t\twhile (b >= 1) {\n\t\t\t\t\t\tlong t = a / b;\n\t\t\t\t\t\ta -= t * b;\n\t\t\t\t\t\tint tmp1 = a;\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t\tb = tmp1;\n\t\t\t\t\t\tu -= t * v;\n\t\t\t\t\t\tlong tmp2 = u;\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tv = tmp2;\n\t\t\t\t\t}\n\t\t\t\t\tu %= mod;\n\t\t\t\t\tif (a != 1) { throw new ArithmeticException(\"divide by zero\"); }\n\t\t\t\t\treturn (int)(u < 0 ? u + mod : u);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\tif (b < 0) throw new ArithmeticException(\"negative power\");\n\t\t\t\t\tlong res = 1;\n\t\t\t\t\tlong pow2 = a;\n\t\t\t\t\tlong idx = 1;\n\t\t\t\t\twhile (b > 0) {\n\t\t\t\t\t\tlong lsb = b & -b;\n\t\t\t\t\t\tfor (; lsb != idx; idx <<= 1) {\n\t\t\t\t\t\t\tpow2 = (pow2 * pow2) % mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = (res * pow2) % mod;\n\t\t\t\t\t\tb ^= lsb;\n\t\t\t\t\t}\n\t\t\t\t\treturn (int)res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmeticMontgomery extends ModArithmeticDynamic {\n\n\t\t\t\tprivate final long negInv;\n\t\t\t\tprivate final long r2, r3;\n\n\t\t\t\tprivate ModArithmeticMontgomery(int mod) {\n\t\t\t\t\tsuper(mod);\n\t\t\t\t\tlong inv = 0;\n\t\t\t\t\tlong s = 1, t = 0;\n\t\t\t\t\tfor (int i = 0; i < 32; i++ ) {\n\t\t\t\t\t\tif ((t & 1) == 0) {\n\t\t\t\t\t\t\tt += mod;\n\t\t\t\t\t\t\tinv += s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt >>= 1;\n\t\t\t\t\t\ts <<= 1;\n\t\t\t\t\t}\n\t\t\t\t\tlong r = (1l << 32) % mod;\n\t\t\t\t\tthis.negInv = inv;\n\t\t\t\t\tthis.r2 = (r * r) % mod;\n\t\t\t\t\tthis.r3 = (r2 * r) % mod;\n\t\t\t\t}\n\n\t\t\t\tprivate int generate(long x) {\n\t\t\t\t\treturn reduce(x * r2);\n\t\t\t\t}\n\n\t\t\t\tprivate int reduce(long x) {\n\t\t\t\t\tx = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;\n\t\t\t\t\treturn (int)(x < mod ? x : x - mod);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn generate((value %= mod) < 0 ? value + mod : value);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn reduce((long)a * b);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\ta = super.inv(a);\n\t\t\t\t\treturn reduce(a * r3);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\treturn generate(super.pow(a, b));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic final class ModArithmeticBarrett extends ModArithmeticDynamic {\n\n\t\t\t\tprivate static final long mask = 0xffff_ffffl;\n\t\t\t\tprivate final long mh;\n\t\t\t\tprivate final long ml;\n\n\t\t\t\tprivate ModArithmeticBarrett(int mod) {\n\t\t\t\t\tsuper(mod);\n\t\t\t\t\t/**\n\t\t\t\t\t * m = floor(2^64/mod)\n\t\t\t\t\t * 2^64 = p*mod + q, 2^32 = a*mod + b\n\t\t\t\t\t * => (a*mod + b)^2 = p*mod + q\n\t\t\t\t\t * => p = mod*a^2 + 2ab + floor(b^2/mod)\n\t\t\t\t\t */\n\t\t\t\t\tlong a = (1l << 32) / mod;\n\t\t\t\t\tlong b = (1l << 32) % mod;\n\t\t\t\t\tlong m = a * a * mod + 2 * a * b + (b * b) / mod;\n\t\t\t\t\tmh = m >>> 32;\n\t\t\t\t\tml = m & mask;\n\t\t\t\t}\n\n\t\t\t\tprivate int reduce(long x) {\n\t\t\t\t\tlong z = (x & mask) * ml;\n\t\t\t\t\tz = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);\n\t\t\t\t\tz = (x >>> 32) * mh + (z >>> 32);\n\t\t\t\t\tx -= z * mod;\n\t\t\t\t\treturn (int)(x < mod ? x : x - mod);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn (int)((value %= mod) < 0 ? value + mod : value);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn reduce((long)a * b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class ModArithmeticDynamic implements ModArithmetic {\n\n\t\t\t\tfinal int mod;\n\n\t\t\t\tpublic ModArithmeticDynamic(int mod) {\n\t\t\t\t\tthis.mod = mod;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mod() {\n\t\t\t\t\treturn mod;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int remainder(long value) {\n\t\t\t\t\treturn (int)((value %= mod) < 0 ? value + mod : value);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int add(int a, int b) {\n\t\t\t\t\tint sum = a + b;\n\t\t\t\t\treturn sum >= mod ? sum - mod : sum;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int sub(int a, int b) {\n\t\t\t\t\tint sum = a - b;\n\t\t\t\t\treturn sum < 0 ? sum + mod : sum;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int mul(int a, int b) {\n\t\t\t\t\treturn (int)(((long)a * b) % mod);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int inv(int a) {\n\t\t\t\t\tint b = mod;\n\t\t\t\t\tlong u = 1, v = 0;\n\t\t\t\t\twhile (b >= 1) {\n\t\t\t\t\t\tlong t = a / b;\n\t\t\t\t\t\ta -= t * b;\n\t\t\t\t\t\tint tmp1 = a;\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t\tb = tmp1;\n\t\t\t\t\t\tu -= t * v;\n\t\t\t\t\t\tlong tmp2 = u;\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tv = tmp2;\n\t\t\t\t\t}\n\t\t\t\t\tu %= mod;\n\t\t\t\t\tif (a != 1) { throw new ArithmeticException(\"divide by zero\"); }\n\t\t\t\t\treturn (int)(u < 0 ? u + mod : u);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int pow(int a, long b) {\n\t\t\t\t\tif (b < 0) throw new ArithmeticException(\"negative power\");\n\t\t\t\t\tint res = 1;\n\t\t\t\t\tint pow2 = a;\n\t\t\t\t\tlong idx = 1;\n\t\t\t\t\twhile (b > 0) {\n\t\t\t\t\t\tlong lsb = b & -b;\n\t\t\t\t\t\tfor (; lsb != idx; idx <<= 1) {\n\t\t\t\t\t\t\tpow2 = mul(pow2, pow2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = mul(res, pow2);\n\t\t\t\t\t\tb ^= lsb;\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Convolution.\n\t *\n\t * @verified https://atcoder.jp/contests/practice2/tasks/practice2_f\n\t * @verified https://judge.yosupo.jp/problem/convolution_mod_1000000007\n\t */\n\tpublic static final class Convolution {\n\n\t\t/**\n\t\t * Find a primitive root.\n\t\t *\n\t\t * @param m A prime number.\n\t\t * @return Primitive root.\n\t\t */\n\t\tprivate static int primitiveRoot(int m) {\n\t\t\tif (m == 2) return 1;\n\t\t\tif (m == 167772161) return 3;\n\t\t\tif (m == 469762049) return 3;\n\t\t\tif (m == 754974721) return 11;\n\t\t\tif (m == 998244353) return 3;\n\n\t\t\tint[] divs = new int[20];\n\t\t\tdivs[0] = 2;\n\t\t\tint cnt = 1;\n\t\t\tint x = (m - 1) / 2;\n\t\t\twhile (x % 2 == 0)\n\t\t\t\tx /= 2;\n\t\t\tfor (int i = 3; (long)(i) * i <= x; i += 2) {\n\t\t\t\tif (x % i == 0) {\n\t\t\t\t\tdivs[cnt++ ] = i;\n\t\t\t\t\twhile (x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 1) {\n\t\t\t\tdivs[cnt++ ] = x;\n\t\t\t}\n\t\t\tfor (int g = 2;; g++ ) {\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int i = 0; i < cnt; i++ ) {\n\t\t\t\t\tif (pow(g, (m - 1) / divs[i], m) == 1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return g;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Power.\n\t\t *\n\t\t * @param x Parameter x.\n\t\t * @param n Parameter n.\n\t\t * @param m Mod.\n\t\t * @return n-th power of x mod m.\n\t\t */\n\t\tprivate static long pow(long x, long n, int m) {\n\t\t\tif (m == 1) return 0;\n\t\t\tlong r = 1;\n\t\t\tlong y = x % m;\n\t\t\twhile (n > 0) {\n\t\t\t\tif ((n & 1) != 0) r = (r * y) % m;\n\t\t\t\ty = (y * y) % m;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\t/**\n\t\t * Ceil of power 2.\n\t\t *\n\t\t * @param n Value.\n\t\t * @return Ceil of power 2.\n\t\t */\n\t\tprivate static int ceilPow2(int n) {\n\t\t\tint x = 0;\n\t\t\twhile ((1L << x) < n)\n\t\t\t\tx++ ;\n\t\t\treturn x;\n\t\t}\n\n\t\t/**\n\t\t * Garner's algorithm.\n\t\t *\n\t\t * @param c    Mod convolution results.\n\t\t * @param mods Mods.\n\t\t * @return Result.\n\t\t */\n\t\tprivate static long garner(long[] c, int[] mods) {\n\t\t\tint n = c.length + 1;\n\t\t\tlong[] cnst = new long[n];\n\t\t\tlong[] coef = new long[n];\n\t\t\tjava.util.Arrays.fill(coef, 1);\n\t\t\tfor (int i = 0; i < n - 1; i++ ) {\n\t\t\t\tint m1 = mods[i];\n\t\t\t\tlong v = (c[i] - cnst[i] + m1) % m1;\n\t\t\t\tv = v * pow(coef[i], m1 - 2, m1) % m1;\n\n\t\t\t\tfor (int j = i + 1; j < n; j++ ) {\n\t\t\t\t\tlong m2 = mods[j];\n\t\t\t\t\tcnst[j] = (cnst[j] + coef[j] * v) % m2;\n\t\t\t\t\tcoef[j] = (coef[j] * m1) % m2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cnst[n - 1];\n\t\t}\n\n\t\t/**\n\t\t * Pre-calculation for NTT.\n\t\t *\n\t\t * @param mod NTT Prime.\n\t\t * @param g   Primitive root of mod.\n\t\t * @return Pre-calculation table.\n\t\t */\n\t\tprivate static long[] sumE(int mod, int g) {\n\t\t\tlong[] sum_e = new long[30];\n\t\t\tlong[] es = new long[30];\n\t\t\tlong[] ies = new long[30];\n\t\t\tint cnt2 = Integer.numberOfTrailingZeros(mod - 1);\n\t\t\tlong e = pow(g, (mod - 1) >> cnt2, mod);\n\t\t\tlong ie = pow(e, mod - 2, mod);\n\t\t\tfor (int i = cnt2; i >= 2; i-- ) {\n\t\t\t\tes[i - 2] = e;\n\t\t\t\ties[i - 2] = ie;\n\t\t\t\te = e * e % mod;\n\t\t\t\tie = ie * ie % mod;\n\t\t\t}\n\t\t\tlong now = 1;\n\t\t\tfor (int i = 0; i < cnt2 - 2; i++ ) {\n\t\t\t\tsum_e[i] = es[i] * now % mod;\n\t\t\t\tnow = now * ies[i] % mod;\n\t\t\t}\n\t\t\treturn sum_e;\n\t\t}\n\n\t\t/**\n\t\t * Pre-calculation for inverse NTT.\n\t\t *\n\t\t * @param mod Mod.\n\t\t * @param g   Primitive root of mod.\n\t\t * @return Pre-calculation table.\n\t\t */\n\t\tprivate static long[] sumIE(int mod, int g) {\n\t\t\tlong[] sum_ie = new long[30];\n\t\t\tlong[] es = new long[30];\n\t\t\tlong[] ies = new long[30];\n\n\t\t\tint cnt2 = Integer.numberOfTrailingZeros(mod - 1);\n\t\t\tlong e = pow(g, (mod - 1) >> cnt2, mod);\n\t\t\tlong ie = pow(e, mod - 2, mod);\n\t\t\tfor (int i = cnt2; i >= 2; i-- ) {\n\t\t\t\tes[i - 2] = e;\n\t\t\t\ties[i - 2] = ie;\n\t\t\t\te = e * e % mod;\n\t\t\t\tie = ie * ie % mod;\n\t\t\t}\n\t\t\tlong now = 1;\n\t\t\tfor (int i = 0; i < cnt2 - 2; i++ ) {\n\t\t\t\tsum_ie[i] = ies[i] * now % mod;\n\t\t\t\tnow = now * es[i] % mod;\n\t\t\t}\n\t\t\treturn sum_ie;\n\t\t}\n\n\t\t/**\n\t\t * Inverse NTT.\n\t\t *\n\t\t * @param a     Target array.\n\t\t * @param sumIE Pre-calculation table.\n\t\t * @param mod   NTT Prime.\n\t\t */\n\t\tprivate static void butterflyInv(long[] a, long[] sumIE, int mod) {\n\t\t\tint n = a.length;\n\t\t\tint h = ceilPow2(n);\n\n\t\t\tfor (int ph = h; ph >= 1; ph-- ) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tlong inow = 1;\n\t\t\t\tfor (int s = 0; s < w; s++ ) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++ ) {\n\t\t\t\t\t\tlong l = a[i + offset];\n\t\t\t\t\t\tlong r = a[i + offset + p];\n\t\t\t\t\t\ta[i + offset] = (l + r) % mod;\n\t\t\t\t\t\ta[i + offset + p] = (mod + l - r) * inow % mod;\n\t\t\t\t\t}\n\t\t\t\t\tint x = Integer.numberOfTrailingZeros(~s);\n\t\t\t\t\tinow = inow * sumIE[x] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Inverse NTT.\n\t\t *\n\t\t * @param a    Target array.\n\t\t * @param sumE Pre-calculation table.\n\t\t * @param mod  NTT Prime.\n\t\t */\n\t\tprivate static void butterfly(long[] a, long[] sumE, int mod) {\n\t\t\tint n = a.length;\n\t\t\tint h = ceilPow2(n);\n\n\t\t\tfor (int ph = 1; ph <= h; ph++ ) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tlong now = 1;\n\t\t\t\tfor (int s = 0; s < w; s++ ) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++ ) {\n\t\t\t\t\t\tlong l = a[i + offset];\n\t\t\t\t\t\tlong r = a[i + offset + p] * now % mod;\n\t\t\t\t\t\ta[i + offset] = (l + r) % mod;\n\t\t\t\t\t\ta[i + offset + p] = (l - r + mod) % mod;\n\t\t\t\t\t}\n\t\t\t\t\tint x = Integer.numberOfTrailingZeros(~s);\n\t\t\t\t\tnow = now * sumE[x] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Convolution.\n\t\t *\n\t\t * @param a   Target array 1.\n\t\t * @param b   Target array 2.\n\t\t * @param mod NTT Prime.\n\t\t * @return Answer.\n\t\t */\n\t\tpublic static long[] convolution(long[] a, long[] b, int mod) {\n\t\t\tint n = a.length;\n\t\t\tint m = b.length;\n\t\t\tif (n == 0 || m == 0) return new long[0];\n\n\t\t\tint z = 1 << ceilPow2(n + m - 1);\n\t\t\t{\n\t\t\t\tlong[] na = new long[z];\n\t\t\t\tlong[] nb = new long[z];\n\t\t\t\tSystem.arraycopy(a, 0, na, 0, n);\n\t\t\t\tSystem.arraycopy(b, 0, nb, 0, m);\n\t\t\t\ta = na;\n\t\t\t\tb = nb;\n\t\t\t}\n\n\t\t\tint g = primitiveRoot(mod);\n\t\t\tlong[] sume = sumE(mod, g);\n\t\t\tlong[] sumie = sumIE(mod, g);\n\n\t\t\tbutterfly(a, sume, mod);\n\t\t\tbutterfly(b, sume, mod);\n\t\t\tfor (int i = 0; i < z; i++ ) {\n\t\t\t\ta[i] = a[i] * b[i] % mod;\n\t\t\t}\n\t\t\tbutterflyInv(a, sumie, mod);\n\t\t\ta = java.util.Arrays.copyOf(a, n + m - 1);\n\n\t\t\tlong iz = pow(z, mod - 2, mod);\n\t\t\tfor (int i = 0; i < n + m - 1; i++ )\n\t\t\t\ta[i] = a[i] * iz % mod;\n\t\t\treturn a;\n\t\t}\n\n\t\t/**\n\t\t * Convolution.\n\t\t *\n\t\t * @param a   Target array 1.\n\t\t * @param b   Target array 2.\n\t\t * @param mod Any mod.\n\t\t * @return Answer.\n\t\t */\n\t\tpublic static long[] convolutionLL(long[] a, long[] b, int mod) {\n\t\t\tint n = a.length;\n\t\t\tint m = b.length;\n\t\t\tif (n == 0 || m == 0) return new long[0];\n\n\t\t\tint mod1 = 754974721;\n\t\t\tint mod2 = 167772161;\n\t\t\tint mod3 = 469762049;\n\n\t\t\tlong[] c1 = convolution(a, b, mod1);\n\t\t\tlong[] c2 = convolution(a, b, mod2);\n\t\t\tlong[] c3 = convolution(a, b, mod3);\n\n\t\t\tint retSize = c1.length;\n\t\t\tlong[] ret = new long[retSize];\n\t\t\tint[] mods = {mod1, mod2, mod3, mod};\n\t\t\tfor (int i = 0; i < retSize; ++i) {\n\t\t\t\tret[i] = garner(new long[]{c1[i], c2[i], c3[i]}, mods);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * Convolution by ModInt.\n\t\t *\n\t\t * @param a Target array 1.\n\t\t * @param b Target array 2.\n\t\t * @return Answer.\n\t\t */\n\t\tpublic static java.util.List<ModIntFactory.ModInt> convolution(java.util.List<ModIntFactory.ModInt> a,\n\t\t\t\tjava.util.List<ModIntFactory.ModInt> b) {\n\t\t\tint mod = a.get(0).mod();\n\t\t\tlong[] va = a.stream().mapToLong(ModIntFactory.ModInt::value).toArray();\n\t\t\tlong[] vb = b.stream().mapToLong(ModIntFactory.ModInt::value).toArray();\n\t\t\tlong[] c = convolutionLL(va, vb, mod);\n\n\t\t\tModIntFactory factory = new ModIntFactory(mod);\n\t\t\treturn java.util.Arrays.stream(c).mapToObj(factory::create).collect(java.util.stream.Collectors.toList());\n\t\t}\n\n\t\t/**\n\t\t * Naive convolution. (Complexity is O(N^2)!!)\n\t\t *\n\t\t * @param a   Target array 1.\n\t\t * @param b   Target array 2.\n\t\t * @param mod Mod.\n\t\t * @return Answer.\n\t\t */\n\t\tpublic static long[] convolutionNaive(long[] a, long[] b, int mod) {\n\t\t\tint n = a.length;\n\t\t\tint m = b.length;\n\t\t\tint k = n + m - 1;\n\t\t\tlong[] ret = new long[k];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tfor (int j = 0; j < m; j++ ) {\n\t\t\t\t\tret[i + j] += a[i] * b[j] % mod;\n\t\t\t\t\tret[i + j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * @verified https://atcoder.jp/contests/practice2/tasks/practice2_g\n\t */\n\tpublic static final class SCC {\n\n\t\tstatic class Edge {\n\n\t\t\tint from, to;\n\n\t\t\tpublic Edge(int from, int to) {\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t}\n\t\t}\n\n\t\tfinal int n;\n\t\tint m;\n\t\tfinal java.util.ArrayList<Edge> unorderedEdges;\n\t\tfinal int[] start;\n\t\tfinal int[] ids;\n\t\tboolean hasBuilt = false;\n\n\t\tpublic SCC(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.unorderedEdges = new java.util.ArrayList<>();\n\t\t\tthis.start = new int[n + 1];\n\t\t\tthis.ids = new int[n];\n\t\t}\n\n\t\tpublic void addEdge(int from, int to) {\n\t\t\trangeCheck(from);\n\t\t\trangeCheck(to);\n\t\t\tunorderedEdges.add(new Edge(from, to));\n\t\t\tstart[from + 1]++ ;\n\t\t\tthis.m++ ;\n\t\t}\n\n\t\tpublic int id(int i) {\n\t\t\tif (!hasBuilt) { throw new UnsupportedOperationException(\"Graph hasn't been built.\"); }\n\t\t\trangeCheck(i);\n\t\t\treturn ids[i];\n\t\t}\n\n\t\tpublic int[][] build() {\n\t\t\tfor (int i = 1; i <= n; i++ ) {\n\t\t\t\tstart[i] += start[i - 1];\n\t\t\t}\n\t\t\tEdge[] orderedEdges = new Edge[m];\n\t\t\tint[] count = new int[n + 1];\n\t\t\tSystem.arraycopy(start, 0, count, 0, n + 1);\n\t\t\tfor (Edge e : unorderedEdges) {\n\t\t\t\torderedEdges[count[e.from]++ ] = e;\n\t\t\t}\n\t\t\tint nowOrd = 0;\n\t\t\tint groupNum = 0;\n\t\t\tint k = 0;\n\t\t\t// parent\n\t\t\tint[] par = new int[n];\n\t\t\tint[] vis = new int[n];\n\t\t\tint[] low = new int[n];\n\t\t\tint[] ord = new int[n];\n\t\t\tjava.util.Arrays.fill(ord, -1);\n\t\t\t// u = lower32(stack[i]) : visiting vertex\n\t\t\t// j = upper32(stack[i]) : jth child\n\t\t\tlong[] stack = new long[n];\n\t\t\t// size of stack\n\t\t\tint ptr = 0;\n\t\t\t// non-recursional DFS\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tif (ord[i] >= 0) continue;\n\t\t\t\tpar[i] = -1;\n\t\t\t\t// vertex i, 0th child.\n\t\t\t\tstack[ptr++ ] = 0l << 32 | i;\n\t\t\t\t// stack is not empty\n\t\t\t\twhile (ptr > 0) {\n\t\t\t\t\t// last element\n\t\t\t\t\tlong p = stack[ --ptr];\n\t\t\t\t\t// vertex\n\t\t\t\t\tint u = (int)(p & 0xffff_ffffl);\n\t\t\t\t\t// jth child\n\t\t\t\t\tint j = (int)(p >>> 32);\n\t\t\t\t\tif (j == 0) { // first visit\n\t\t\t\t\t\tlow[u] = ord[u] = nowOrd++ ;\n\t\t\t\t\t\tvis[k++ ] = u;\n\t\t\t\t\t}\n\t\t\t\t\tif (start[u] + j < count[u]) { // there are more children\n\t\t\t\t\t\t// jth child\n\t\t\t\t\t\tint to = orderedEdges[start[u] + j].to;\n\t\t\t\t\t\t// incr children counter\n\t\t\t\t\t\tstack[ptr++ ] += 1l << 32;\n\t\t\t\t\t\tif (ord[to] == -1) { // new vertex\n\t\t\t\t\t\t\tstack[ptr++ ] = 0l << 32 | to;\n\t\t\t\t\t\t\tpar[to] = u;\n\t\t\t\t\t\t} else { // backward edge\n\t\t\t\t\t\t\tlow[u] = Math.min(low[u], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // no more children (leaving)\n\t\t\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\t\t\tint to = orderedEdges[start[u] + j].to;\n\t\t\t\t\t\t\t// update lowlink\n\t\t\t\t\t\t\tif (par[to] == u) low[u] = Math.min(low[u], low[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (low[u] == ord[u]) { // root of a component\n\t\t\t\t\t\t\twhile (true) { // gathering verticies\n\t\t\t\t\t\t\t\tint v = vis[ --k];\n\t\t\t\t\t\t\t\tord[v] = n;\n\t\t\t\t\t\t\t\tids[v] = groupNum;\n\t\t\t\t\t\t\t\tif (v == u) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgroupNum++ ; // incr the number of components\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tids[i] = groupNum - 1 - ids[i];\n\t\t\t}\n\n\t\t\tint[] counts = new int[groupNum];\n\t\t\tfor (int x : ids)\n\t\t\t\tcounts[x]++ ;\n\t\t\tint[][] groups = new int[groupNum][];\n\t\t\tfor (int i = 0; i < groupNum; i++ ) {\n\t\t\t\tgroups[i] = new int[counts[i]];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tint cmp = ids[i];\n\t\t\t\tgroups[cmp][ --counts[cmp]] = i;\n\t\t\t}\n\t\t\thasBuilt = true;\n\t\t\treturn groups;\n\t\t}\n\n\t\tprivate void rangeCheck(int i) {\n\t\t\tif (i < 0 || i >= n) { throw new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for length %d\", i, n)); }\n\t\t}\n\t}\n\n\t/**\n\t * @verified https://atcoder.jp/contests/practice2/submissions/16647102\n\t */\n\tpublic static final class TwoSAT {\n\n\t\tprivate final int n;\n\t\tprivate final InternalSCC scc;\n\t\tprivate final boolean[] answer;\n\n\t\tprivate boolean hasCalledSatisfiable = false;\n\t\tprivate boolean existsAnswer = false;\n\n\t\tpublic TwoSAT(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.scc = new InternalSCC(2 * n);\n\t\t\tthis.answer = new boolean[n];\n\t\t}\n\n\t\tpublic void addClause(int x, boolean f, int y, boolean g) {\n\t\t\trangeCheck(x);\n\t\t\trangeCheck(y);\n\t\t\tscc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n\t\t\tscc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n\t\t}\n\n\t\tpublic void addImplication(int x, boolean f, int y, boolean g) {\n\t\t\taddClause(x, !f, y, g);\n\t\t}\n\n\t\tpublic void addNand(int x, boolean f, int y, boolean g) {\n\t\t\taddClause(x, !f, y, !g);\n\t\t}\n\n\t\tpublic boolean satisfiable() {\n\t\t\thasCalledSatisfiable = true;\n\t\t\tint[] ids = scc.ids();\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tif (ids[i << 1 | 0] == ids[i << 1 | 1]) return existsAnswer = false;\n\t\t\t\tanswer[i] = ids[i << 1 | 0] < ids[i << 1 | 1];\n\t\t\t}\n\t\t\treturn existsAnswer = true;\n\t\t}\n\n\t\tpublic boolean[] answer() {\n\t\t\tif (!hasCalledSatisfiable) {\n\t\t\t\tthrow new UnsupportedOperationException(\"Call TwoSAT#satisfiable at least once before TwoSAT#answer.\");\n\t\t\t}\n\t\t\tif (existsAnswer) return answer;\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate void rangeCheck(int x) {\n\t\t\tif (0 > x || x >= n) { throw new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for length %d\", x, n)); }\n\t\t}\n\n\t\tprivate static final class EdgeList {\n\n\t\t\tlong[] a;\n\t\t\tint ptr = 0;\n\n\t\t\tEdgeList(int cap) {\n\t\t\t\ta = new long[cap];\n\t\t\t}\n\n\t\t\tvoid add(int upper, int lower) {\n\t\t\t\tif (ptr == a.length) grow();\n\t\t\t\ta[ptr++ ] = (long)upper << 32 | lower;\n\t\t\t}\n\n\t\t\tvoid grow() {\n\t\t\t\tlong[] b = new long[a.length << 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t}\n\n\t\tprivate static final class InternalSCC {\n\n\t\t\tfinal int n;\n\t\t\tint m;\n\t\t\tfinal EdgeList unorderedEdges;\n\t\t\tfinal int[] start;\n\n\t\t\tInternalSCC(int n) {\n\t\t\t\tthis.n = n;\n\t\t\t\tthis.unorderedEdges = new EdgeList(n);\n\t\t\t\tthis.start = new int[n + 1];\n\t\t\t}\n\n\t\t\tvoid addEdge(int from, int to) {\n\t\t\t\tunorderedEdges.add(from, to);\n\t\t\t\tstart[from + 1]++ ;\n\t\t\t\tthis.m++ ;\n\t\t\t}\n\n\t\t\tstatic final long mask = 0xffff_ffffl;\n\n\t\t\tint[] ids() {\n\t\t\t\tfor (int i = 1; i <= n; i++ ) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tint[] orderedEdges = new int[m];\n\t\t\t\tint[] count = new int[n + 1];\n\t\t\t\tSystem.arraycopy(start, 0, count, 0, n + 1);\n\t\t\t\tfor (int i = 0; i < m; i++ ) {\n\t\t\t\t\tlong e = unorderedEdges.a[i];\n\t\t\t\t\torderedEdges[count[(int)(e >>> 32)]++ ] = (int)(e & mask);\n\t\t\t\t}\n\t\t\t\tint nowOrd = 0;\n\t\t\t\tint groupNum = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tint[] par = new int[n];\n\t\t\t\tint[] vis = new int[n];\n\t\t\t\tint[] low = new int[n];\n\t\t\t\tint[] ord = new int[n];\n\t\t\t\tjava.util.Arrays.fill(ord, -1);\n\t\t\t\tint[] ids = new int[n];\n\t\t\t\tlong[] stack = new long[n];\n\t\t\t\tint ptr = 0;\n\n\t\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\t\tif (ord[i] >= 0) continue;\n\t\t\t\t\tpar[i] = -1;\n\t\t\t\t\tstack[ptr++ ] = i;\n\t\t\t\t\twhile (ptr > 0) {\n\t\t\t\t\t\tlong p = stack[ --ptr];\n\t\t\t\t\t\tint u = (int)(p & mask);\n\t\t\t\t\t\tint j = (int)(p >>> 32);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tlow[u] = ord[u] = nowOrd++ ;\n\t\t\t\t\t\t\tvis[k++ ] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (start[u] + j < count[u]) {\n\t\t\t\t\t\t\tint to = orderedEdges[start[u] + j];\n\t\t\t\t\t\t\tstack[ptr++ ] += 1l << 32;\n\t\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\t\tstack[ptr++ ] = to;\n\t\t\t\t\t\t\t\tpar[to] = u;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlow[u] = Math.min(low[u], ord[to]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\t\t\t\tint to = orderedEdges[start[u] + j];\n\t\t\t\t\t\t\t\tif (par[to] == u) low[u] = Math.min(low[u], low[to]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (low[u] == ord[u]) {\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tint v = vis[ --k];\n\t\t\t\t\t\t\t\t\tord[v] = n;\n\t\t\t\t\t\t\t\t\tids[v] = groupNum;\n\t\t\t\t\t\t\t\t\tif (v == u) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgroupNum++ ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\t\tids[i] = groupNum - 1 - ids[i];\n\t\t\t\t}\n\t\t\t\treturn ids;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static final class StringAlgorithm {\n\n\t\tprivate static int[] saNaive(int[] s) {\n\t\t\tint n = s.length;\n\t\t\tInteger[] _sa = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\t_sa[i] = i;\n\t\t\t}\n\t\t\tjava.util.Arrays.sort(_sa, (l, r) -> {\n\t\t\t\twhile (l < n && r < n) {\n\t\t\t\t\tif (s[l] != s[r]) return s[l] - s[r];\n\t\t\t\t\tl++ ;\n\t\t\t\t\tr++ ;\n\t\t\t\t}\n\t\t\t\treturn -(l - r);\n\t\t\t});\n\t\t\tint[] sa = new int[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tsa[i] = _sa[i];\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\tprivate static int[] saDoubling(int[] s) {\n\t\t\tint n = s.length;\n\t\t\tInteger[] _sa = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\t_sa[i] = i;\n\t\t\t}\n\t\t\tint[] rnk = s;\n\t\t\tint[] tmp = new int[n];\n\n\t\t\tfor (int k = 1; k < n; k *= 2) {\n\t\t\t\tfinal int _k = k;\n\t\t\t\tfinal int[] _rnk = rnk;\n\t\t\t\tjava.util.Comparator<Integer> cmp = (x, y) -> {\n\t\t\t\t\tif (_rnk[x] != _rnk[y]) return _rnk[x] - _rnk[y];\n\t\t\t\t\tint rx = x + _k < n ? _rnk[x + _k] : -1;\n\t\t\t\t\tint ry = y + _k < n ? _rnk[y + _k] : -1;\n\t\t\t\t\treturn rx - ry;\n\t\t\t\t};\n\t\t\t\tjava.util.Arrays.sort(_sa, cmp);\n\t\t\t\ttmp[_sa[0]] = 0;\n\t\t\t\tfor (int i = 1; i < n; i++ ) {\n\t\t\t\t\ttmp[_sa[i]] = tmp[_sa[i - 1]] + (cmp.compare(_sa[i - 1], _sa[i]) < 0 ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tint[] buf = tmp;\n\t\t\t\ttmp = rnk;\n\t\t\t\trnk = buf;\n\t\t\t}\n\n\t\t\tint[] sa = new int[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tsa[i] = _sa[i];\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\tprivate static final int THRESHOLD_NAIVE = 10;\n\t\tprivate static final int THRESHOLD_DOUBLING = 40;\n\n\t\tprivate static int[] sais(int[] s, int upper) {\n\t\t\tint n = s.length;\n\t\t\tif (n == 0) return new int[0];\n\t\t\tif (n == 1) return new int[]{0};\n\t\t\tif (n == 2) {\n\t\t\t\treturn s[0] < s[1] ? new int[]{0, 1} : new int[] {1, 0};\n\t\t\t}\n\t\t\tif (n < THRESHOLD_NAIVE) { return saNaive(s); }\n\t\t\tif (n < THRESHOLD_DOUBLING) { return saDoubling(s); }\n\n\t\t\tint[] sa = new int[n];\n\t\t\tboolean[] ls = new boolean[n];\n\t\t\tfor (int i = n - 2; i >= 0; i-- ) {\n\t\t\t\tls[i] = s[i] == s[i + 1] ? ls[i + 1] : s[i] < s[i + 1];\n\t\t\t}\n\n\t\t\tint[] sumL = new int[upper + 1];\n\t\t\tint[] sumS = new int[upper + 1];\n\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tif (ls[i]) {\n\t\t\t\t\tsumL[s[i] + 1]++ ;\n\t\t\t\t} else {\n\t\t\t\t\tsumS[s[i]]++ ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= upper; i++ ) {\n\t\t\t\tsumS[i] += sumL[i];\n\t\t\t\tif (i < upper) sumL[i + 1] += sumS[i];\n\t\t\t}\n\n\t\t\tjava.util.function.Consumer<int[]> induce = lms -> {\n\t\t\t\tjava.util.Arrays.fill(sa, -1);\n\t\t\t\tint[] buf = new int[upper + 1];\n\t\t\t\tSystem.arraycopy(sumS, 0, buf, 0, upper + 1);\n\t\t\t\tfor (int d : lms) {\n\t\t\t\t\tif (d == n) continue;\n\t\t\t\t\tsa[buf[s[d]]++ ] = d;\n\t\t\t\t}\n\t\t\t\tSystem.arraycopy(sumL, 0, buf, 0, upper + 1);\n\t\t\t\tsa[buf[s[n - 1]]++ ] = n - 1;\n\t\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && !ls[v - 1]) {\n\t\t\t\t\t\tsa[buf[s[v - 1]]++ ] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.arraycopy(sumL, 0, buf, 0, upper + 1);\n\t\t\t\tfor (int i = n - 1; i >= 0; i-- ) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && ls[v - 1]) {\n\t\t\t\t\t\tsa[ --buf[s[v - 1] + 1]] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tint[] lmsMap = new int[n + 1];\n\t\t\tjava.util.Arrays.fill(lmsMap, -1);\n\t\t\tint m = 0;\n\t\t\tfor (int i = 1; i < n; i++ ) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlmsMap[i] = m++ ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] lms = new int[m];\n\t\t\t{\n\t\t\t\tint p = 0;\n\t\t\t\tfor (int i = 1; i < n; i++ ) {\n\t\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\t\tlms[p++ ] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinduce.accept(lms);\n\n\t\t\tif (m > 0) {\n\t\t\t\tint[] sortedLms = new int[m];\n\t\t\t\t{\n\t\t\t\t\tint p = 0;\n\t\t\t\t\tfor (int v : sa) {\n\t\t\t\t\t\tif (lmsMap[v] != -1) {\n\t\t\t\t\t\t\tsortedLms[p++ ] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[] recS = new int[m];\n\t\t\t\tint recUpper = 0;\n\t\t\t\trecS[lmsMap[sortedLms[0]]] = 0;\n\t\t\t\tfor (int i = 1; i < m; i++ ) {\n\t\t\t\t\tint l = sortedLms[i - 1], r = sortedLms[i];\n\t\t\t\t\tint endL = (lmsMap[l] + 1 < m) ? lms[lmsMap[l] + 1] : n;\n\t\t\t\t\tint endR = (lmsMap[r] + 1 < m) ? lms[lmsMap[r] + 1] : n;\n\t\t\t\t\tboolean same = true;\n\t\t\t\t\tif (endL - l != endR - r) {\n\t\t\t\t\t\tsame = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (l < endL && s[l] == s[r]) {\n\t\t\t\t\t\t\tl++ ;\n\t\t\t\t\t\t\tr++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (l == n || s[l] != s[r]) same = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!same) {\n\t\t\t\t\t\trecUpper++ ;\n\t\t\t\t\t}\n\t\t\t\t\trecS[lmsMap[sortedLms[i]]] = recUpper;\n\t\t\t\t}\n\n\t\t\t\tint[] recSA = sais(recS, recUpper);\n\n\t\t\t\tfor (int i = 0; i < m; i++ ) {\n\t\t\t\t\tsortedLms[i] = lms[recSA[i]];\n\t\t\t\t}\n\t\t\t\tinduce.accept(sortedLms);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\tpublic static int[] suffixArray(int[] s, int upper) {\n\t\t\tassert (0 <= upper);\n\t\t\tfor (int d : s) {\n\t\t\t\tassert (0 <= d && d <= upper);\n\t\t\t}\n\t\t\treturn sais(s, upper);\n\t\t}\n\n\t\tpublic static int[] suffixArray(int[] s) {\n\t\t\tint n = s.length;\n\t\t\tInteger[] idx = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tidx[i] = i;\n\t\t\t}\n\t\t\tjava.util.Arrays.sort(idx, (l, r) -> s[l] - s[r]);\n\t\t\tint[] s2 = new int[n];\n\t\t\tint now = 0;\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tif (i > 0 && s[idx[i - 1]] != s[idx[i]]) {\n\t\t\t\t\tnow++ ;\n\t\t\t\t}\n\t\t\t\ts2[idx[i]] = now;\n\t\t\t}\n\t\t\treturn sais(s2, now);\n\t\t}\n\n\t\tpublic static int[] suffixArray(char[] s) {\n\t\t\tint n = s.length;\n\t\t\tint[] s2 = new int[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\ts2[i] = s[i];\n\t\t\t}\n\t\t\treturn sais(s2, 255);\n\t\t}\n\n\t\tpublic static int[] suffixArray(java.lang.String s) {\n\t\t\treturn suffixArray(s.toCharArray());\n\t\t}\n\n\t\tpublic static int[] lcpArray(int[] s, int[] sa) {\n\t\t\tint n = s.length;\n\t\t\tassert (n >= 1);\n\t\t\tint[] rnk = new int[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\trnk[sa[i]] = i;\n\t\t\t}\n\t\t\tint[] lcp = new int[n - 1];\n\t\t\tint h = 0;\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\tif (h > 0) h-- ;\n\t\t\t\tif (rnk[i] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint j = sa[rnk[i] - 1];\n\t\t\t\tfor (; j + h < n && i + h < n; h++ ) {\n\t\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t\t}\n\t\t\t\tlcp[rnk[i] - 1] = h;\n\t\t\t}\n\t\t\treturn lcp;\n\t\t}\n\n\t\tpublic static int[] lcpArray(char[] s, int[] sa) {\n\t\t\tint n = s.length;\n\t\t\tint[] s2 = new int[n];\n\t\t\tfor (int i = 0; i < n; i++ ) {\n\t\t\t\ts2[i] = s[i];\n\t\t\t}\n\t\t\treturn lcpArray(s2, sa);\n\t\t}\n\n\t\tpublic static int[] lcpArray(java.lang.String s, int[] sa) {\n\t\t\treturn lcpArray(s.toCharArray(), sa);\n\t\t}\n\n\t\tpublic static int[] zAlgorithm(int[] s) {\n\t\t\tint n = s.length;\n\t\t\tif (n == 0) return new int[0];\n\t\t\tint[] z = new int[n];\n\t\t\tfor (int i = 1, j = 0; i < n; i++ ) {\n\t\t\t\tint k = j + z[j] <= i ? 0 : Math.min(j + z[j] - i, z[i - j]);\n\t\t\t\twhile (i + k < n && s[k] == s[i + k])\n\t\t\t\t\tk++ ;\n\t\t\t\tz[i] = k;\n\t\t\t\tif (j + z[j] < i + z[i]) j = i;\n\t\t\t}\n\t\t\tz[0] = n;\n\t\t\treturn z;\n\t\t}\n\n\t\tpublic static int[] zAlgorithm(char[] s) {\n\t\t\tint n = s.length;\n\t\t\tif (n == 0) return new int[0];\n\t\t\tint[] z = new int[n];\n\t\t\tfor (int i = 1, j = 0; i < n; i++ ) {\n\t\t\t\tint k = j + z[j] <= i ? 0 : Math.min(j + z[j] - i, z[i - j]);\n\t\t\t\twhile (i + k < n && s[k] == s[i + k])\n\t\t\t\t\tk++ ;\n\t\t\t\tz[i] = k;\n\t\t\t\tif (j + z[j] < i + z[i]) j = i;\n\t\t\t}\n\t\t\tz[0] = n;\n\t\t\treturn z;\n\t\t}\n\n\t\tpublic static int[] zAlgorithm(String s) {\n\t\t\treturn zAlgorithm(s.toCharArray());\n\t\t}\n\t}\n\n\t/**\n\t * @verified https://atcoder.jp/contests/practice2/tasks/practice2_j\n\t */\n\tpublic static final class SegTree<S> {\n\n\t\tfinal int MAX;\n\n\t\tfinal int N;\n\t\tfinal java.util.function.BinaryOperator<S> op;\n\t\tfinal S E;\n\n\t\tfinal S[] data;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic SegTree(int n, java.util.function.BinaryOperator<S> op, S e) {\n\t\t\tthis.MAX = n;\n\t\t\tint k = 1;\n\t\t\twhile (k < n)\n\t\t\t\tk <<= 1;\n\t\t\tthis.N = k;\n\t\t\tthis.E = e;\n\t\t\tthis.op = op;\n\t\t\tthis.data = (S[])new Object[N << 1];\n\t\t\tjava.util.Arrays.fill(data, E);\n\t\t}\n\n\t\tpublic SegTree(S[] dat, java.util.function.BinaryOperator<S> op, S e) {\n\t\t\tthis(dat.length, op, e);\n\t\t\tbuild(dat);\n\t\t}\n\n\t\tprivate void build(S[] dat) {\n\t\t\tint l = dat.length;\n\t\t\tSystem.arraycopy(dat, 0, data, N, l);\n\t\t\tfor (int i = N - 1; i > 0; i-- ) {\n\t\t\t\tdata[i] = op.apply(data[i << 1 | 0], data[i << 1 | 1]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void set(int p, S x) {\n\t\t\texclusiveRangeCheck(p);\n\t\t\tdata[p += N] = x;\n\t\t\tp >>= 1;\n\t\t\twhile (p > 0) {\n\t\t\t\tdata[p] = op.apply(data[p << 1 | 0], data[p << 1 | 1]);\n\t\t\t\tp >>= 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic S get(int p) {\n\t\t\texclusiveRangeCheck(p);\n\t\t\treturn data[p + N];\n\t\t}\n\n\t\tpublic S prod(int l, int r) {\n\t\t\tif (l > r) { throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r)); }\n\t\t\tinclusiveRangeCheck(l);\n\t\t\tinclusiveRangeCheck(r);\n\t\t\tS sumLeft = E;\n\t\t\tS sumRight = E;\n\t\t\tl += N;\n\t\t\tr += N;\n\t\t\twhile (l < r) {\n\t\t\t\tif ((l & 1) == 1) sumLeft = op.apply(sumLeft, data[l++ ]);\n\t\t\t\tif ((r & 1) == 1) sumRight = op.apply(data[ --r], sumRight);\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\treturn op.apply(sumLeft, sumRight);\n\t\t}\n\n\t\tpublic S allProd() {\n\t\t\treturn data[1];\n\t\t}\n\n\t\tpublic int maxRight(int l, java.util.function.Predicate<S> f) {\n\t\t\tinclusiveRangeCheck(l);\n\t\t\tif (!f.test(E)) { throw new IllegalArgumentException(\"Identity element must satisfy the condition.\"); }\n\t\t\tif (l == MAX) return MAX;\n\t\t\tl += N;\n\t\t\tS sum = E;\n\t\t\tdo {\n\t\t\t\tl >>= Integer.numberOfTrailingZeros(l);\n\t\t\t\tif (!f.test(op.apply(sum, data[l]))) {\n\t\t\t\t\twhile (l < N) {\n\t\t\t\t\t\tl = l << 1;\n\t\t\t\t\t\tif (f.test(op.apply(sum, data[l]))) {\n\t\t\t\t\t\t\tsum = op.apply(sum, data[l]);\n\t\t\t\t\t\t\tl++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn l - N;\n\t\t\t\t}\n\t\t\t\tsum = op.apply(sum, data[l]);\n\t\t\t\tl++ ;\n\t\t\t} while ((l & -l) != l);\n\t\t\treturn MAX;\n\t\t}\n\n\t\tpublic int minLeft(int r, java.util.function.Predicate<S> f) {\n\t\t\tinclusiveRangeCheck(r);\n\t\t\tif (!f.test(E)) { throw new IllegalArgumentException(\"Identity element must satisfy the condition.\"); }\n\t\t\tif (r == 0) return 0;\n\t\t\tr += N;\n\t\t\tS sum = E;\n\t\t\tdo {\n\t\t\t\tr-- ;\n\t\t\t\twhile (r > 1 && (r & 1) == 1)\n\t\t\t\t\tr >>= 1;\n\t\t\t\tif (!f.test(op.apply(data[r], sum))) {\n\t\t\t\t\twhile (r < N) {\n\t\t\t\t\t\tr = r << 1 | 1;\n\t\t\t\t\t\tif (f.test(op.apply(data[r], sum))) {\n\t\t\t\t\t\t\tsum = op.apply(data[r], sum);\n\t\t\t\t\t\t\tr-- ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r + 1 - N;\n\t\t\t\t}\n\t\t\t\tsum = op.apply(data[r], sum);\n\t\t\t} while ((r & -r) != r);\n\t\t\treturn 0;\n\t\t}\n\n\t\tprivate void exclusiveRangeCheck(int p) {\n\t\t\tif (p < 0 || p >= MAX) {\n\t\t\t\tthrow new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for the range [%d, %d).\", p, 0, MAX));\n\t\t\t}\n\t\t}\n\n\t\tprivate void inclusiveRangeCheck(int p) {\n\t\t\tif (p < 0 || p > MAX) {\n\t\t\t\tthrow new IndexOutOfBoundsException(String.format(\"Index %d out of bounds for the range [%d, %d].\", p, 0, MAX));\n\t\t\t}\n\t\t}\n\n\t\t// **************** DEBUG **************** //\n\n\t\tprivate int indent = 6;\n\n\t\tpublic void setIndent(int newIndent) {\n\t\t\tthis.indent = newIndent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn toString(1, 0);\n\t\t}\n\n\t\tprivate String toString(int k, int sp) {\n\t\t\tif (k >= N) return indent(sp) + data[k];\n\t\t\tString s = \"\";\n\t\t\ts += toString(k << 1 | 1, sp + indent);\n\t\t\ts += \"\\n\";\n\t\t\ts += indent(sp) + data[k];\n\t\t\ts += \"\\n\";\n\t\t\ts += toString(k << 1 | 0, sp + indent);\n\t\t\treturn s;\n\t\t}\n\n\t\tprivate static String indent(int n) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (n-- > 0)\n\t\t\t\tsb.append(' ');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\t/**\n\t * TODO: verify {@link LazySegTree#maxRight} and {@link LazySegTree#minLeft}\n\t *\n\t * @verified https://atcoder.jp/contests/practice2/tasks/practice2_k\n\t */\n\n\tpublic static final class LazySegTree<S, F> {\n\n\t\tfinal int MAX;\n\n\t\tfinal int N;\n\t\tfinal int Log;\n\t\tfinal java.util.function.BinaryOperator<S> Op;\n\t\tfinal S E;\n\t\tfinal java.util.function.BiFunction<F, S, S> Mapping;\n\t\tfinal java.util.function.BinaryOperator<F> Composition;\n\t\tfinal F Id;\n\n\t\tfinal S[] Dat;\n\t\tfinal F[] Laz;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic LazySegTree(int n, java.util.function.BinaryOperator<S> op, S e, java.util.function.BiFunction<F, S, S> mapping,\n\t\t\t\tjava.util.function.BinaryOperator<F> composition, F id) {\n\t\t\tthis.MAX = n;\n\t\t\tint k = 1;\n\t\t\twhile (k < n)\n\t\t\t\tk <<= 1;\n\t\t\tthis.N = k;\n\t\t\tthis.Log = Integer.numberOfTrailingZeros(N);\n\t\t\tthis.Op = op;\n\t\t\tthis.E = e;\n\t\t\tthis.Mapping = mapping;\n\t\t\tthis.Composition = composition;\n\t\t\tthis.Id = id;\n\t\t\tthis.Dat = (S[])new Object[N << 1];\n\t\t\tthis.Laz = (F[])new Object[N];\n\t\t\tjava.util.Arrays.fill(Dat, E);\n\t\t\tjava.util.Arrays.fill(Laz, Id);\n\t\t}\n\n\t\tpublic LazySegTree(S[] dat, java.util.function.BinaryOperator<S> op, S e, java.util.function.BiFunction<F, S, S> mapping,\n\t\t\t\tjava.util.function.BinaryOperator<F> composition, F id) {\n\t\t\tthis(dat.length, op, e, mapping, composition, id);\n\t\t\tbuild(dat);\n\t\t}\n\n\t\tprivate void build(S[] dat) {\n\t\t\tint l = dat.length;\n\t\t\tSystem.arraycopy(dat, 0, Dat, N, l);\n\t\t\tfor (int i = N - 1; i > 0; i-- ) {\n\t\t\t\tDat[i] = Op.apply(Dat[i << 1 | 0], Dat[i << 1 | 1]);\n\t\t\t}\n\t\t}\n\n\t\tprivate void push(int k) {\n\t\t\tif (Laz[k] == Id) return;\n\t\t\tint lk = k << 1 | 0, rk = k << 1 | 1;\n\t\t\tDat[lk] = Mapping.apply(Laz[k], Dat[lk]);\n\t\t\tDat[rk] = Mapping.apply(Laz[k], Dat[rk]);\n\t\t\tif (lk < N) Laz[lk] = Composition.apply(Laz[k], Laz[lk]);\n\t\t\tif (rk < N) Laz[rk] = Composition.apply(Laz[k], Laz[rk]);\n\t\t\tLaz[k] = Id;\n\t\t}\n\n\t\tprivate void pushTo(int k) {\n\t\t\tfor (int i = Log; i > 0; i-- )\n\t\t\t\tpush(k >> i);\n\t\t}\n\n\t\tprivate void pushTo(int lk, int rk) {\n\t\t\tfor (int i = Log; i > 0; i-- ) {\n\t\t\t\tif (((lk >> i) << i) != lk) push(lk >> i);\n\t\t\t\tif (((rk >> i) << i) != rk) push(rk >> i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateFrom(int k) {\n\t\t\tk >>= 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tDat[k] = Op.apply(Dat[k << 1 | 0], Dat[k << 1 | 1]);\n\t\t\t\tk >>= 1;\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateFrom(int lk, int rk) {\n\t\t\tfor (int i = 1; i <= Log; i++ ) {\n\t\t\t\tif (((lk >> i) << i) != lk) {\n\t\t\t\t\tint lki = lk >> i;\n\t\t\t\t\tDat[lki] = Op.apply(Dat[lki << 1 | 0], Dat[lki << 1 | 1]);\n\t\t\t\t}\n\t\t\t\tif (((rk >> i) << i) != rk) {\n\t\t\t\t\tint rki = (rk - 1) >> i;\n\t\t\t\t\tDat[rki] = Op.apply(Dat[rki << 1 | 0], Dat[rki << 1 | 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void set(int p, S x) {\n\t\t\texclusiveRangeCheck(p);\n\t\t\tp += N;\n\t\t\tpushTo(p);\n\t\t\tDat[p] = x;\n\t\t\tupdateFrom(p);\n\t\t}\n\n\t\tpublic S get(int p) {\n\t\t\texclusiveRangeCheck(p);\n\t\t\tp += N;\n\t\t\tpushTo(p);\n\t\t\treturn Dat[p];\n\t\t}\n\n\t\tpublic S prod(int l, int r) {\n\t\t\tif (l > r) { throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r)); }\n\t\t\tinclusiveRangeCheck(l);\n\t\t\tinclusiveRangeCheck(r);\n\t\t\tif (l == r) return E;\n\t\t\tl += N;\n\t\t\tr += N;\n\t\t\tpushTo(l, r);\n\t\t\tS sumLeft = E, sumRight = E;\n\t\t\twhile (l < r) {\n\t\t\t\tif ((l & 1) == 1) sumLeft = Op.apply(sumLeft, Dat[l++ ]);\n\t\t\t\tif ((r & 1) == 1) sumRight = Op.apply(Dat[ --r], sumRight);\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\treturn Op.apply(sumLeft, sumRight);\n\t\t}\n\n\t\tpublic S allProd() {\n\t\t\treturn Dat[1];\n\t\t}\n\n\t\tpublic void apply(int p, F f) {\n\t\t\texclusiveRangeCheck(p);\n\t\t\tp += N;\n\t\t\tpushTo(p);\n\t\t\tDat[p] = Mapping.apply(f, Dat[p]);\n\t\t\tupdateFrom(p);\n\t\t}\n\n\t\tpublic void apply(int l, int r, F f) {\n\t\t\tif (l > r) { throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r)); }\n\t\t\tinclusiveRangeCheck(l);\n\t\t\tinclusiveRangeCheck(r);\n\t\t\tif (l == r) return;\n\t\t\tl += N;\n\t\t\tr += N;\n\t\t\tpushTo(l, r);\n\t\t\tfor (int l2 = l, r2 = r; l2 < r2;) {\n\t\t\t\tif ((l2 & 1) == 1) {\n\t\t\t\t\tDat[l2] = Mapping.apply(f, Dat[l2]);\n\t\t\t\t\tif (l2 < N) Laz[l2] = Composition.apply(f, Laz[l2]);\n\t\t\t\t\tl2++ ;\n\t\t\t\t}\n\t\t\t\tif ((r2 & 1) == 1) {\n\t\t\t\t\tr2-- ;\n\t\t\t\t\tDat[r2] = Mapping.apply(f, Dat[r2]);\n\t\t\t\t\tif (r2 < N) Laz[r2] = Composition.apply(f, Laz[r2]);\n\t\t\t\t}\n\t\t\t\tl2 >>= 1;\n\t\t\t\tr2 >>= 1;\n\t\t\t}\n\t\t\tupdateFrom(l, r);\n\t\t}\n\n\t\tpublic int maxRight(int l, java.util.function.Predicate<S> g) {\n\t\t\tinclusiveRangeCheck(l);\n\t\t\tif (!g.test(E)) { throw new IllegalArgumentException(\"Identity element must satisfy the condition.\"); }\n\t\t\tif (l == MAX) return MAX;\n\t\t\tl += N;\n\t\t\tpushTo(l);\n\t\t\tS sum = E;\n\t\t\tdo {\n\t\t\t\tl >>= Integer.numberOfTrailingZeros(l);\n\t\t\t\tif (!g.test(Op.apply(sum, Dat[l]))) {\n\t\t\t\t\twhile (l < N) {\n\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\tl = l << 1;\n\t\t\t\t\t\tif (g.test(Op.apply(sum, Dat[l]))) {\n\t\t\t\t\t\t\tsum = Op.apply(sum, Dat[l]);\n\t\t\t\t\t\t\tl++ ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn l - N;\n\t\t\t\t}\n\t\t\t\tsum = Op.apply(sum, Dat[l]);\n\t\t\t\tl++ ;\n\t\t\t} while ((l & -l) != l);\n\t\t\treturn MAX;\n\t\t}\n\n\t\tpublic int minLeft(int r, java.util.function.Predicate<S> g) {\n\t\t\tinclusiveRangeCheck(r);\n\t\t\tif (!g.test(E)) { throw new IllegalArgumentException(\"Identity element must satisfy the condition.\"); }\n\t\t\tif (r == 0) return 0;\n\t\t\tr += N;\n\t\t\tpushTo(r - 1);\n\t\t\tS sum = E;\n\t\t\tdo {\n\t\t\t\tr-- ;\n\t\t\t\twhile (r > 1 && (r & 1) == 1)\n\t\t\t\t\tr >>= 1;\n\t\t\t\tif (!g.test(Op.apply(Dat[r], sum))) {\n\t\t\t\t\twhile (r < N) {\n\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\tr = r << 1 | 1;\n\t\t\t\t\t\tif (g.test(Op.apply(Dat[r], sum))) {\n\t\t\t\t\t\t\tsum = Op.apply(Dat[r], sum);\n\t\t\t\t\t\t\tr-- ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r + 1 - N;\n\t\t\t\t}\n\t\t\t\tsum = Op.apply(Dat[r], sum);\n\t\t\t} while ((r & -r) != r);\n\t\t\treturn 0;\n\t\t}\n\n\t\tprivate void exclusiveRangeCheck(int p) {\n\t\t\tif (p < 0 || p >= MAX) { throw new IndexOutOfBoundsException(String.format(\"Index %d is not in [%d, %d).\", p, 0, MAX)); }\n\t\t}\n\n\t\tprivate void inclusiveRangeCheck(int p) {\n\t\t\tif (p < 0 || p > MAX) { throw new IndexOutOfBoundsException(String.format(\"Index %d is not in [%d, %d].\", p, 0, MAX)); }\n\t\t}\n\n\t\t// **************** DEBUG **************** //\n\n\t\tprivate int indent = 6;\n\n\t\tpublic void setIndent(int newIndent) {\n\t\t\tthis.indent = newIndent;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn toString(1, 0);\n\t\t}\n\n\t\tprivate String toString(int k, int sp) {\n\t\t\tif (k >= N) return indent(sp) + Dat[k];\n\t\t\tString s = \"\";\n\t\t\ts += toString(k << 1 | 1, sp + indent);\n\t\t\ts += \"\\n\";\n\t\t\ts += indent(sp) + Dat[k] + \"/\" + Laz[k];\n\t\t\ts += \"\\n\";\n\t\t\ts += toString(k << 1 | 0, sp + indent);\n\t\t\treturn s;\n\t\t}\n\n\t\tprivate static String indent(int n) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (n-- > 0)\n\t\t\t\tsb.append(' ');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tpublic static final class MultiSet<T> extends java.util.TreeMap<T, Long> {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic MultiSet() {\n\t\t\tsuper();\n\t\t}\n\n\t\tpublic MultiSet(java.util.List<T> list) {\n\t\t\tsuper();\n\t\t\tfor (T e : list)\n\t\t\t\tthis.addOne(e);\n\t\t}\n\n\t\tpublic long count(Object elm) {\n\t\t\treturn getOrDefault(elm, 0L);\n\t\t}\n\n\t\tpublic void add(T elm, long amount) {\n\t\t\tif (!this.containsKey(elm)) put(elm, amount);\n\t\t\telse replace(elm, get(elm) + amount);\n\t\t\tif (this.count(elm) == 0) this.remove(elm);\n\t\t}\n\n\t\tpublic void addOne(T elm) {\n\t\t\tthis.add(elm, 1);\n\t\t}\n\n\t\tpublic void removeOne(T elm) {\n\t\t\tthis.add(elm, -1);\n\t\t}\n\n\t\tpublic void removeAll(T elm) {\n\t\t\tthis.add(elm, -this.count(elm));\n\t\t}\n\n\t\tpublic static <T> MultiSet<T> merge(MultiSet<T> a, MultiSet<T> b) {\n\t\t\tMultiSet<T> c = new MultiSet<>();\n\t\t\tfor (T x : a.keySet())\n\t\t\t\tc.add(x, a.count(x));\n\t\t\tfor (T y : b.keySet())\n\t\t\t\tc.add(y, b.count(y));\n\t\t\treturn c;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        var sc = new FastScanner();\n        var ps = new FastPrintStream();\n        solve(sc, ps);\n        sc.close();\n        ps.flush();\n        ps.close();\n    }\n    public static void solve(FastScanner sc, FastPrintStream ps) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addCaluse(i, true , j, true);\n                if (d01 < d) twosat.addCaluse(i, true , j, false);\n                if (d10 < d) twosat.addCaluse(i, false, j, true);\n                if (d11 < d) twosat.addCaluse(i, false, j, false);\n            }\n        }\n        var bitset = twosat.solve();\n        if (bitset == null) {\n            ps.println(\"No\");\n            return;\n        }\n        ps.println(\"Yes\");\n        for (int i = 0; i < n; i++) {\n            ps.println(bitset.get(i) ? y[i] : x[i]);\n        }\n    }\n\n    static class TwoSAT {\n        private final int n;\n        private InternalSCC scc;\n    \n        public TwoSAT (int n) {\n            this.n = n;\n            this.scc = new InternalSCC(2 * n);\n        }\n    \n        public void addCaluse(int x, boolean f, int y, boolean g) {\n            scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n            scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n        }\n    \n        public java.util.BitSet solve() {\n            int[] ids = scc.ids();\n            java.util.BitSet answer = new java.util.BitSet(n);\n            for (int i = 0; i < n; i++) {\n                if (ids[i << 1 | 0] == ids[i << 1 | 1]) return null;\n                answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n            }\n            return answer;\n        }\n    \n        private static final class EdgeList {\n            long[] a;\n            int ptr = 0;\n            EdgeList(int cap) {a = new long[cap];}\n            void add(int upper, int lower) {\n                if (ptr == a.length) grow();\n                a[ptr++] = (long) upper << 32 | lower;\n            }\n            void grow() {\n                long[] b = new long[a.length << 1];\n                System.arraycopy(a, 0, b, 0, a.length);\n                a = b;\n            }\n        }\n    \n        private static final class InternalSCC {\n            final int n;\n            int m;\n            final EdgeList unorderedEdges;\n            final int[] start;\n            InternalSCC(int n) {\n                this.n = n;\n                this.unorderedEdges = new EdgeList(n);\n                this.start = new int[n + 1];\n            }\n            void addEdge(int from, int to) {\n                unorderedEdges.add(from, to);\n                start[from + 1]++;\n                this.m++;\n            }\n            private static final long mask = 0xffff_ffffl;\n            int[] ids() {\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                int[] orderedEdges = new int[m];\n                int[] count = new int[n + 1];\n                System.arraycopy(start, 0, count, 0, n + 1);\n                for (int i = 0; i < m; i++) {\n                    long e = unorderedEdges.a[i];\n                    orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n                }\n                int nowOrd = 0;\n                int groupNum = 0;\n                int k = 0;\n                int[] par = new int[n];\n                int[] visited = new int[n];\n                int[] low = new int[n];\n                int[] ord = new int[n];\n                java.util.Arrays.fill(ord, -1);\n                int[] ids = new int[n];\n                long[] stack = new long[n];\n                int ptr = 0;\n                \n                for (int i = 0; i < n; i++) {\n                    if (ord[i] >= 0) continue;\n                    par[i] = -1;\n                    stack[ptr++] = i;\n                    while (ptr > 0) {\n                        long p = stack[--ptr];\n                        int u = (int) (p & mask);\n                        int j = (int) (p >>> 32);\n                        if (j == 0) {\n                            low[u] = ord[u] = nowOrd++;\n                            visited[k++] = u;\n                        }\n                        if (start[u] + j < count[u]) {\n                            int to = orderedEdges[start[u] + j];\n                            stack[ptr++] += 1l << 32;\n                            if (ord[to] == -1) {\n                                stack[ptr++] = to;\n                                par[to] = u;\n                            } else {\n                                low[u] = Math.min(low[u], ord[to]);\n                            }\n                        } else {\n                            while (j --> 0) {\n                                int to = orderedEdges[start[u] + j];\n                                if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                            }\n                            if (low[u] == ord[u]) {\n                                while (true) {\n                                    int v = visited[--k];\n                                    ord[v] = n;\n                                    ids[v] = groupNum;\n                                    if (v == u) break;\n                                }\n                                groupNum++;\n                            }\n                        }\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    ids[i] = groupNum - 1 - ids[i];\n                }\n                return ids;\n            }\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final java.io.InputStream in;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private int buflen = 0;\n    \n        public FastScanner(java.io.InputStream in) {\n            this.in = in;\n        }\n    \n        public FastScanner() {\n            this(System.in);\n        }\n    \n        private boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            ptr = 0;\n            try {\n                buflen = in.read(buf);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buflen > 0;\n        }\n    \n        private int readByte() {\n            return hasNextByte() ? buf[ptr++] : -1;\n        }\n    \n        public boolean hasNext() {\n            while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n            return hasNextByte();\n        }\n    \n        private StringBuilder nextSequence() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n                sb.appendCodePoint(b);\n            }\n            return sb;\n        }\n    \n        public String next() {\n            return nextSequence().toString();\n        }\n    \n        public String next(int len) {\n            return new String(nextChars(len));\n        }\n    \n        public char nextChar() {\n            if (!hasNextByte()) throw new java.util.NoSuchElementException();\n            return (char) readByte();\n        }\n    \n        public char[] nextChars() {\n            StringBuilder sb = nextSequence();\n            int l = sb.length();\n            char[] dst = new char[l];\n            sb.getChars(0, l, dst, 0);\n            return dst;\n        }\n        public char[] nextChars(int len) {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (32 < b && b < 127 && i < len) {\n                s[i++] = (char) b; b = readByte();\n            }\n            if (i != len) {\n                throw new java.util.NoSuchElementException(\n                    String.format(\"Next token has smaller length than expected.\", len)\n                );\n            }\n            return s;\n        }\n        public long nextLong() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n = n * 10 + b - '0';\n                } else if (b == -1 || !(32 < b && b < 127)) {\n                    return minus ? -n : n;\n                } else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n        public int nextInt() {\n            return Math.toIntExact(nextLong());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public void close() {\n            try {\n                in.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    static class FastPrintStream implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private final java.lang.reflect.Field strField;\n        private final java.nio.charset.CharsetEncoder encoder;\n    \n        private java.io.OutputStream out;\n    \n        public FastPrintStream(java.io.OutputStream out) {\n            this.out = out;\n            java.lang.reflect.Field f;\n            try {\n                f = java.lang.String.class.getDeclaredField(\"value\");\n                f.setAccessible(true);\n            } catch (NoSuchFieldException | SecurityException e) {\n                f = null;\n            }\n            this.strField = f;\n            this.encoder = java.nio.charset.StandardCharsets.UTF_8.newEncoder();\n        }\n    \n        public FastPrintStream(java.io.File file) throws java.io.IOException {\n            this(new java.io.FileOutputStream(file));\n        }\n    \n        public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n            this(new java.io.File(filename));\n        }\n    \n        public FastPrintStream() {\n            this(System.out);\n            try {\n                java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n                f.setAccessible(true);\n                f.set(System.out, false);\n            } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n                // ignore\n            }\n        }\n    \n        public FastPrintStream println() {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) '\\n';\n            return this;\n        }\n    \n        public FastPrintStream println(java.lang.Object o) {\n            return print(o).println();\n        }\n    \n        public FastPrintStream println(java.lang.String s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char[] s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char c) {\n            return print(c).println();\n        }\n    \n        public FastPrintStream println(int x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(long x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(double d, int precision) {\n            return print(d, precision).println();\n        }\n    \n        private FastPrintStream print(byte[] bytes) {\n            int n = bytes.length;\n            if (ptr + n > BUF_SIZE) {\n                internalFlush();\n                try {\n                    out.write(bytes);\n                } catch (java.io.IOException e) {\n                    throw new RuntimeException();\n                }\n            } else {\n                System.arraycopy(bytes, 0, buf, ptr, n);\n                ptr += n;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(java.lang.Object o) {\n            return print(o.toString());\n        }\n    \n        public FastPrintStream print(java.lang.String s) {\n            if (strField == null) {\n                return print(s.getBytes());\n            } else {\n                try {\n                    return print((byte[]) strField.get(s));\n                } catch (IllegalAccessException e) {\n                    return print(s.getBytes());\n                }\n            }\n        }\n    \n        public FastPrintStream print(char[] s) {\n            try {\n                return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n            } catch (java.nio.charset.CharacterCodingException e) {\n                byte[] bytes = new byte[s.length];\n                for (int i = 0; 9 < s.length; i++) {\n                    bytes[i] = (byte) s[i];\n                }\n                return print(bytes);\n            }\n        }\n    \n        public FastPrintStream print(char c) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) c;\n            return this;\n        }\n    \n        public FastPrintStream print(int x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(long x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(double d, int precision) {\n            if (d < 0) {\n                print('-');\n                d = -d;\n            }\n            d += Math.pow(10, -d) / 2;\n            print((long) d).print('.');\n            d -= (long) d;\n            for(int i = 0; i < precision; i++){\n                d *= 10;\n                print((int) d);\n                d -= (int) d;\n            }\n            return this;\n        }\n    \n        private void internalFlush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void flush() {\n            try {\n                out.write(buf, 0, ptr);\n                out.flush();\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void close() {\n            try {\n                out.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        private static int len(int x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            int p = -10;\n            for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n            return 10 + d;\n        }\n    \n        private static int len(long x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            long p = -10;\n            for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n            return 19 + d;\n        }\n    }\n\n    static int[] nextInts(int n, FastScanner sc) {\n        var dat = new int[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextInt());\n        return dat;\n    }\n\n    static long[] nextLongs(int n, FastScanner sc) {\n        var dat = new long[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextLong());\n        return dat;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) throws Exception {\n        var sc = new FastScanner();\n        var pw = new FastPrintStream();\n        solve(sc, pw);\n        sc.close();\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(FastScanner sc, FastPrintStream pw) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addClause(i, true , j, true );\n                if (d01 < d) twosat.addClause(i, true , j, false);\n                if (d10 < d) twosat.addClause(i, false, j, true );\n                if (d11 < d) twosat.addClause(i, false, j, false);\n            }\n        }\n        boolean exists = twosat.satisfiable();\n        if (!exists) {\n            pw.println(\"No\");\n            return;\n        }\n        pw.println(\"Yes\");\n        var bitset = twosat.answer();\n        for (int i = 0; i < n; i++) {\n            pw.println(bitset.get(i) ? y[i] : x[i]);\n        }\n    }\n}\n\nclass TwoSAT {\n    private final int n;\n    private final InternalSCC scc;\n    private final java.util.BitSet answer;\n\n    private boolean hasCalledSatisfiable = false;\n    private boolean existsAnswer = false;\n\n    public TwoSAT(int n) {\n        this.n = n;\n        this.scc = new InternalSCC(2 * n);\n        this.answer = new java.util.BitSet(n);\n    }\n\n    public void addClause(int x, boolean f, int y, boolean g) {\n        scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n        scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n    }\n\n    public void addImplication(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, g);\n    }\n\n    public void addNand(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, !g);\n    }\n\n    public boolean satisfiable() {\n        hasCalledSatisfiable = true;\n        int[] ids = scc.ids();\n        for (int i = 0; i < n; i++) {\n            if (ids[i << 1 | 0] == ids[i << 1 | 1]) return existsAnswer = false;\n            answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n        }\n        return existsAnswer = true;\n    }\n\n    public java.util.BitSet answer() {\n        if (!hasCalledSatisfiable) {\n            throw new UnsupportedOperationException(\n                \"Call TwoSAT#satisfiable at least once before TwoSAT#answer.\"\n            );\n        }\n        if (existsAnswer) return answer;\n        return null;\n    }\n\n    private static final class EdgeList {\n        long[] a;\n        int ptr = 0;\n        EdgeList(int cap) {a = new long[cap];}\n        void add(int upper, int lower) {\n            if (ptr == a.length) grow();\n            a[ptr++] = (long) upper << 32 | lower;\n        }\n        void grow() {\n            long[] b = new long[a.length << 1];\n            System.arraycopy(a, 0, b, 0, a.length);\n            a = b;\n        }\n    }\n\n    private static final class InternalSCC {\n        final int n;\n        int m;\n        final EdgeList unorderedEdges;\n        final int[] start;\n        InternalSCC(int n) {\n            this.n = n;\n            this.unorderedEdges = new EdgeList(n);\n            this.start = new int[n + 1];\n        }\n        void addEdge(int from, int to) {\n            unorderedEdges.add(from, to);\n            start[from + 1]++;\n            this.m++;\n        }\n        static final long mask = 0xffff_ffffl;\n        int[] ids() {\n            for (int i = 1; i <= n; i++) {\n                start[i] += start[i - 1];\n            }\n            int[] orderedEdges = new int[m];\n            int[] count = new int[n + 1];\n            System.arraycopy(start, 0, count, 0, n + 1);\n            for (int i = 0; i < m; i++) {\n                long e = unorderedEdges.a[i];\n                orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n            }\n            int nowOrd = 0;\n            int groupNum = 0;\n            int k = 0;\n            int[] par = new int[n];\n            int[] vis = new int[n];\n            int[] low = new int[n];\n            int[] ord = new int[n];\n            java.util.Arrays.fill(ord, -1);\n            int[] ids = new int[n];\n            long[] stack = new long[n];\n            int ptr = 0;\n            \n            for (int i = 0; i < n; i++) {\n                if (ord[i] >= 0) continue;\n                par[i] = -1;\n                stack[ptr++] = i;\n                while (ptr > 0) {\n                    long p = stack[--ptr];\n                    int u = (int) (p & mask);\n                    int j = (int) (p >>> 32);\n                    if (j == 0) {\n                        low[u] = ord[u] = nowOrd++;\n                        vis[k++] = u;\n                    }\n                    if (start[u] + j < count[u]) {\n                        int to = orderedEdges[start[u] + j];\n                        stack[ptr++] += 1l << 32;\n                        if (ord[to] == -1) {\n                            stack[ptr++] = to;\n                            par[to] = u;\n                        } else {\n                            low[u] = Math.min(low[u], ord[to]);\n                        }\n                    } else {\n                        while (j --> 0) {\n                            int to = orderedEdges[start[u] + j];\n                            if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                        }\n                        if (low[u] == ord[u]) {\n                            while (true) {\n                                int v = vis[--k];\n                                ord[v] = n;\n                                ids[v] = groupNum;\n                                if (v == u) break;\n                            }\n                            groupNum++;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                ids[i] = groupNum - 1 - ids[i];\n            }\n            return ids;\n        }\n    }\n}\n\nclass FastPrintStream implements AutoCloseable {\n    private static final int BUF_SIZE = 1 << 15;\n    private final byte[] buf = new byte[BUF_SIZE];\n    private int ptr = 0;\n    private final java.lang.reflect.Field strField;\n    private final java.nio.charset.CharsetEncoder encoder;\n\n    private java.io.OutputStream out;\n\n    public FastPrintStream(java.io.OutputStream out) {\n        this.out = out;\n        java.lang.reflect.Field f;\n        try {\n            f = java.lang.String.class.getDeclaredField(\"value\");\n            f.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e) {\n            f = null;\n        }\n        this.strField = f;\n        this.encoder = java.nio.charset.StandardCharsets.US_ASCII.newEncoder();\n    }\n\n    public FastPrintStream(java.io.File file) throws java.io.IOException {\n        this(new java.io.FileOutputStream(file));\n    }\n\n    public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n        this(new java.io.File(filename));\n    }\n\n    public FastPrintStream() {\n        this(System.out);\n        try {\n            java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n            f.setAccessible(true);\n            f.set(System.out, false);\n        } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n            // ignore\n        }\n    }\n\n    public FastPrintStream println() {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) '\\n';\n        return this;\n    }\n\n    public FastPrintStream println(java.lang.Object o) {\n        return print(o).println();\n    }\n\n    public FastPrintStream println(java.lang.String s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char[] s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char c) {\n        return print(c).println();\n    }\n\n    public FastPrintStream println(int x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(long x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(double d, int precision) {\n        return print(d, precision).println();\n    }\n\n    private FastPrintStream print(byte[] bytes) {\n        int n = bytes.length;\n        if (ptr + n > BUF_SIZE) {\n            internalFlush();\n            try {\n                out.write(bytes);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException();\n            }\n        } else {\n            System.arraycopy(bytes, 0, buf, ptr, n);\n            ptr += n;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(java.lang.Object o) {\n        return print(o.toString());\n    }\n\n    public FastPrintStream print(java.lang.String s) {\n        if (strField == null) {\n            return print(s.getBytes());\n        } else {\n            try {\n                return print((byte[]) strField.get(s));\n            } catch (IllegalAccessException e) {\n                return print(s.getBytes());\n            }\n        }\n    }\n\n    public FastPrintStream print(char[] s) {\n        try {\n            return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n        } catch (java.nio.charset.CharacterCodingException e) {\n            byte[] bytes = new byte[s.length];\n            for (int i = 0; i < s.length; i++) {\n                bytes[i] = (byte) s[i];\n            }\n            return print(bytes);\n        }\n    }\n\n    public FastPrintStream print(char c) {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public FastPrintStream print(int x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(long x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(double d, int precision) {\n        if (d < 0) {\n            print('-');\n            d = -d;\n        }\n        d += Math.pow(10, -d) / 2;\n        print((long) d).print('.');\n        d -= (long) d;\n        for(int i = 0; i < precision; i++){\n            d *= 10;\n            print((int) d);\n            d -= (int) d;\n        }\n        return this;\n    }\n\n    private void internalFlush() {\n        try {\n            out.write(buf, 0, ptr);\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            out.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static int len(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n\n    private static int len(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n}\n\nclass FastScanner implements AutoCloseable {\n    private final java.io.InputStream in;\n    private final byte[] buf = new byte[2048];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(java.io.InputStream in) {\n        this.in = in;\n    }\n\n    public FastScanner() {\n        this(System.in);\n    }\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {\n            buflen = in.read(buf);\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n        return buflen > 0;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buf[ptr++] : -1;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n        return hasNextByte();\n    }\n\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n            sb.appendCodePoint(b);\n        }\n        return sb;\n    }\n\n    public String next() {\n        return nextSequence().toString();\n    }\n\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n\n    public char nextChar() {\n        if (!hasNextByte()) throw new java.util.NoSuchElementException();\n        return (char) readByte();\n    }\n\n    public char[] nextChars() {\n        StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (32 < b && b < 127 && i < len) {\n            s[i++] = (char) b; b = readByte();\n        }\n        if (i != len) {\n            throw new java.util.NoSuchElementException(\n                String.format(\"Next token has smaller length than expected.\", len)\n            );\n        }\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n = n * 10 + b - '0';\n            } else if (b == -1 || !(32 < b && b < 127)) {\n                return minus ? -n : n;\n            } else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        return Math.toIntExact(nextLong());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    public void close() {\n        try {\n            in.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass TwoSAT {\n    private final int n;\n    private final InternalSCC scc;\n    private final java.util.BitSet answer;\n\n    private boolean hasCalledSatisfiable = false;\n    private boolean existsAnswer = false;\n\n    public TwoSAT(int n) {\n        this.n = n;\n        this.scc = new InternalSCC(2 * n);\n        this.answer = new java.util.BitSet(n);\n    }\n\n    public void addClause(int x, boolean f, int y, boolean g) {\n        scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n        scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n    }\n\n    public void addImplication(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, g);\n    }\n\n    public void addNand(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, !g);\n    }\n\n    public boolean satisfiable() {\n        hasCalledSatisfiable = true;\n        int[] ids = scc.ids();\n        for (int i = 0; i < n; i++) {\n            if (ids[i << 1 | 0] == ids[i << 1 | 1]) return existsAnswer = false;\n            answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n        }\n        return existsAnswer = true;\n    }\n\n    public java.util.BitSet answer() {\n        if (!hasCalledSatisfiable) {\n            throw new UnsupportedOperationException(\n                \"Call TwoSAT#satisfiable at least once before TwoSAT#answer.\"\n            );\n        }\n        if (existsAnswer) return answer;\n        return null;\n    }\n\n    private static final class EdgeList {\n        long[] a;\n        int ptr = 0;\n        EdgeList(int cap) {a = new long[cap];}\n        void add(int upper, int lower) {\n            if (ptr == a.length) grow();\n            a[ptr++] = (long) upper << 32 | lower;\n        }\n        void grow() {\n            long[] b = new long[a.length << 1];\n            System.arraycopy(a, 0, b, 0, a.length);\n            a = b;\n        }\n    }\n\n    private static final class InternalSCC {\n        final int n;\n        int m;\n        final EdgeList unorderedEdges;\n        final int[] start;\n        InternalSCC(int n) {\n            this.n = n;\n            this.unorderedEdges = new EdgeList(n);\n            this.start = new int[n + 1];\n        }\n        void addEdge(int from, int to) {\n            unorderedEdges.add(from, to);\n            start[from + 1]++;\n            this.m++;\n        }\n        static final long mask = 0xffff_ffffl;\n        int[] ids() {\n            for (int i = 1; i <= n; i++) {\n                start[i] += start[i - 1];\n            }\n            int[] orderedEdges = new int[m];\n            int[] count = new int[n + 1];\n            System.arraycopy(start, 0, count, 0, n + 1);\n            for (int i = 0; i < m; i++) {\n                long e = unorderedEdges.a[i];\n                orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n            }\n            int nowOrd = 0;\n            int groupNum = 0;\n            int k = 0;\n            int[] par = new int[n];\n            int[] vis = new int[n];\n            int[] low = new int[n];\n            int[] ord = new int[n];\n            java.util.Arrays.fill(ord, -1);\n            int[] ids = new int[n];\n            long[] stack = new long[n];\n            int ptr = 0;\n            \n            for (int i = 0; i < n; i++) {\n                if (ord[i] >= 0) continue;\n                par[i] = -1;\n                stack[ptr++] = i;\n                while (ptr > 0) {\n                    long p = stack[--ptr];\n                    int u = (int) (p & mask);\n                    int j = (int) (p >>> 32);\n                    if (j == 0) {\n                        low[u] = ord[u] = nowOrd++;\n                        vis[k++] = u;\n                    }\n                    if (start[u] + j < count[u]) {\n                        int to = orderedEdges[start[u] + j];\n                        stack[ptr++] += 1l << 32;\n                        if (ord[to] == -1) {\n                            stack[ptr++] = to;\n                            par[to] = u;\n                        } else {\n                            low[u] = Math.min(low[u], ord[to]);\n                        }\n                    } else {\n                        while (j --> 0) {\n                            int to = orderedEdges[start[u] + j];\n                            if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                        }\n                        if (low[u] == ord[u]) {\n                            while (true) {\n                                int v = vis[--k];\n                                ord[v] = n;\n                                ids[v] = groupNum;\n                                if (v == u) break;\n                            }\n                            groupNum++;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                ids[i] = groupNum - 1 - ids[i];\n            }\n            return ids;\n        }\n    }\n}\n\npublic class Main {\n    static final long BIG = 1_000_000_000;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long D = sc.nextLong();\n        long[] x = new long[N], y = new long[N];\n        for(int n=0; n<N; n++){\n            x[n] = sc.nextLong();\n            y[n] = sc.nextLong();\n        }\n        \n        TwoSAT sat = new TwoSAT(N);\n\n        for(int i=0; i<N; i++) for(int j=i+1; j<N; j++){\n            if(Math.abs(x[i] - x[j]) < D) sat.addNand(i, true, j, true);\n            if(Math.abs(x[i] - y[j]) < D) sat.addNand(i, true, j, false);\n            if(Math.abs(y[i] - x[j]) < D) sat.addNand(i, false, j, true);\n            if(Math.abs(y[i] - y[j]) < D) sat.addNand(i, false, j, false);\n        }\n\n        if(sat.satisfiable()){\n            System.out.println(\"Yes\");\n            BitSet ans = sat.answer();\n            for(int n=0; n<N; n++){\n                System.out.println(ans.get(n) ? x[n] : y[n]);\n            }\n        }else{\n            System.out.println(\"No\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        FastPrintStream pw = new FastPrintStream();\n        solve(sc, pw);\n        sc.close();\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(FastScanner sc, FastPrintStream pw) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addClause(i, true , j, true );\n                if (d01 < d) twosat.addClause(i, true , j, false);\n                if (d10 < d) twosat.addClause(i, false, j, true );\n                if (d11 < d) twosat.addClause(i, false, j, false);\n            }\n        }\n        boolean exists = twosat.satisfiable();\n        if (!exists) {\n            pw.println(\"No\");\n            return;\n        }\n        pw.println(\"Yes\");\n        var asg = twosat.answer();\n        for (int i = 0; i < n; i++) {\n            pw.println(asg[i] ? y[i] : x[i]);\n        }\n    }\n}\n\n/**\n * @verified https://atcoder.jp/contests/practice2/submissions/16603939\n */\nclass TwoSAT {\n    private final int n;\n    private final InternalSCC scc;\n    private final boolean[] answer;\n\n    private boolean hasCalledSatisfiable = false;\n    private boolean existsAnswer = false;\n\n    public TwoSAT(int n) {\n        this.n = n;\n        this.scc = new InternalSCC(2 * n);\n        this.answer = new boolean[n];\n    }\n\n    public void addClause(int x, boolean f, int y, boolean g) {\n        scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n        scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n    }\n\n    public void addImplication(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, g);\n    }\n\n    public void addNand(int x, boolean f, int y, boolean g) {\n        addClause(x, !f, y, !g);\n    }\n\n    public boolean satisfiable() {\n        hasCalledSatisfiable = true;\n        int[] ids = scc.ids();\n        for (int i = 0; i < n; i++) {\n            if (ids[i << 1 | 0] == ids[i << 1 | 1]) return existsAnswer = false;\n            answer[i] = ids[i << 1 | 0] < ids[i << 1 | 1];\n        }\n        return existsAnswer = true;\n    }\n\n    public boolean[] answer() {\n        if (!hasCalledSatisfiable) {\n            throw new UnsupportedOperationException(\n                \"Call TwoSAT#satisfiable at least once before TwoSAT#answer.\"\n            );\n        }\n        if (existsAnswer) return answer;\n        return null;\n    }\n\n    private static final class EdgeList {\n        long[] a;\n        int ptr = 0;\n        EdgeList(int cap) {a = new long[cap];}\n        void add(int upper, int lower) {\n            if (ptr == a.length) grow();\n            a[ptr++] = (long) upper << 32 | lower;\n        }\n        void grow() {\n            long[] b = new long[a.length << 1];\n            System.arraycopy(a, 0, b, 0, a.length);\n            a = b;\n        }\n    }\n\n    private static final class InternalSCC {\n        final int n;\n        int m;\n        final EdgeList unorderedEdges;\n        final int[] start;\n        InternalSCC(int n) {\n            this.n = n;\n            this.unorderedEdges = new EdgeList(n);\n            this.start = new int[n + 1];\n        }\n        void addEdge(int from, int to) {\n            unorderedEdges.add(from, to);\n            start[from + 1]++;\n            this.m++;\n        }\n        static final long mask = 0xffff_ffffl;\n        int[] ids() {\n            for (int i = 1; i <= n; i++) {\n                start[i] += start[i - 1];\n            }\n            int[] orderedEdges = new int[m];\n            int[] count = new int[n + 1];\n            System.arraycopy(start, 0, count, 0, n + 1);\n            for (int i = 0; i < m; i++) {\n                long e = unorderedEdges.a[i];\n                orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n            }\n            int nowOrd = 0;\n            int groupNum = 0;\n            int k = 0;\n            int[] par = new int[n];\n            int[] vis = new int[n];\n            int[] low = new int[n];\n            int[] ord = new int[n];\n            java.util.Arrays.fill(ord, -1);\n            int[] ids = new int[n];\n            long[] stack = new long[n];\n            int ptr = 0;\n            \n            for (int i = 0; i < n; i++) {\n                if (ord[i] >= 0) continue;\n                par[i] = -1;\n                stack[ptr++] = i;\n                while (ptr > 0) {\n                    long p = stack[--ptr];\n                    int u = (int) (p & mask);\n                    int j = (int) (p >>> 32);\n                    if (j == 0) {\n                        low[u] = ord[u] = nowOrd++;\n                        vis[k++] = u;\n                    }\n                    if (start[u] + j < count[u]) {\n                        int to = orderedEdges[start[u] + j];\n                        stack[ptr++] += 1l << 32;\n                        if (ord[to] == -1) {\n                            stack[ptr++] = to;\n                            par[to] = u;\n                        } else {\n                            low[u] = Math.min(low[u], ord[to]);\n                        }\n                    } else {\n                        while (j --> 0) {\n                            int to = orderedEdges[start[u] + j];\n                            if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                        }\n                        if (low[u] == ord[u]) {\n                            while (true) {\n                                int v = vis[--k];\n                                ord[v] = n;\n                                ids[v] = groupNum;\n                                if (v == u) break;\n                            }\n                            groupNum++;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                ids[i] = groupNum - 1 - ids[i];\n            }\n            return ids;\n        }\n    }\n}\n\n\nclass FastPrintStream implements AutoCloseable {\n    private static final int BUF_SIZE = 1 << 15;\n    private final byte[] buf = new byte[BUF_SIZE];\n    private int ptr = 0;\n    private final java.lang.reflect.Field strField;\n    private final java.nio.charset.CharsetEncoder encoder;\n\n    private java.io.OutputStream out;\n\n    public FastPrintStream(java.io.OutputStream out) {\n        this.out = out;\n        java.lang.reflect.Field f;\n        try {\n            f = java.lang.String.class.getDeclaredField(\"value\");\n            f.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e) {\n            f = null;\n        }\n        this.strField = f;\n        this.encoder = java.nio.charset.StandardCharsets.US_ASCII.newEncoder();\n    }\n\n    public FastPrintStream(java.io.File file) throws java.io.IOException {\n        this(new java.io.FileOutputStream(file));\n    }\n\n    public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n        this(new java.io.File(filename));\n    }\n\n    public FastPrintStream() {\n        this(System.out);\n        try {\n            java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n            f.setAccessible(true);\n            f.set(System.out, false);\n        } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n            // ignore\n        }\n    }\n\n    public FastPrintStream println() {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) '\\n';\n        return this;\n    }\n\n    public FastPrintStream println(java.lang.Object o) {\n        return print(o).println();\n    }\n\n    public FastPrintStream println(java.lang.String s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char[] s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char c) {\n        return print(c).println();\n    }\n\n    public FastPrintStream println(int x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(long x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(double d, int precision) {\n        return print(d, precision).println();\n    }\n\n    private FastPrintStream print(byte[] bytes) {\n        int n = bytes.length;\n        if (ptr + n > BUF_SIZE) {\n            internalFlush();\n            try {\n                out.write(bytes);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException();\n            }\n        } else {\n            System.arraycopy(bytes, 0, buf, ptr, n);\n            ptr += n;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(java.lang.Object o) {\n        return print(o.toString());\n    }\n\n    public FastPrintStream print(java.lang.String s) {\n        if (strField == null) {\n            return print(s.getBytes());\n        } else {\n            try {\n                return print((byte[]) strField.get(s));\n            } catch (IllegalAccessException e) {\n                return print(s.getBytes());\n            }\n        }\n    }\n\n    public FastPrintStream print(char[] s) {\n        try {\n            return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n        } catch (java.nio.charset.CharacterCodingException e) {\n            byte[] bytes = new byte[s.length];\n            for (int i = 0; i < s.length; i++) {\n                bytes[i] = (byte) s[i];\n            }\n            return print(bytes);\n        }\n    }\n\n    public FastPrintStream print(char c) {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public FastPrintStream print(int x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(long x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(double d, int precision) {\n        if (d < 0) {\n            print('-');\n            d = -d;\n        }\n        d += Math.pow(10, -d) / 2;\n        print((long) d).print('.');\n        d -= (long) d;\n        for(int i = 0; i < precision; i++){\n            d *= 10;\n            print((int) d);\n            d -= (int) d;\n        }\n        return this;\n    }\n\n    private void internalFlush() {\n        try {\n            out.write(buf, 0, ptr);\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            out.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static int len(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n\n    private static int len(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n}\n\nclass FastScanner implements AutoCloseable {\n    private final java.io.InputStream in;\n    private final byte[] buf = new byte[2048];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(java.io.InputStream in) {\n        this.in = in;\n    }\n\n    public FastScanner() {\n        this(System.in);\n    }\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {\n            buflen = in.read(buf);\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n        return buflen > 0;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buf[ptr++] : -1;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n        return hasNextByte();\n    }\n\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n            sb.appendCodePoint(b);\n        }\n        return sb;\n    }\n\n    public String next() {\n        return nextSequence().toString();\n    }\n\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n\n    public char nextChar() {\n        if (!hasNextByte()) throw new java.util.NoSuchElementException();\n        return (char) readByte();\n    }\n\n    public char[] nextChars() {\n        StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (32 < b && b < 127 && i < len) {\n            s[i++] = (char) b; b = readByte();\n        }\n        if (i != len) {\n            throw new java.util.NoSuchElementException(\n                String.format(\"Next token has smaller length than expected.\", len)\n            );\n        }\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n = n * 10 + b - '0';\n            } else if (b == -1 || !(32 < b && b < 127)) {\n                return minus ? -n : n;\n            } else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        return Math.toIntExact(nextLong());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    public void close() {\n        try {\n            in.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n\tpublic static void main(String[] args){\n    \tSystem.out.println(\"No\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        var sc = new FastScanner();\n        var ps = new FastPrintStream();\n        solve(sc, ps);\n        sc.close();\n        ps.flush();\n        ps.close();\n    }\n    public static void solve(FastScanner sc, FastPrintStream ps) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addImplication(i, false, j, true );\n                if (d01 < d) twosat.addImplication(i, false, j, false);\n                if (d10 < d) twosat.addImplication(i, true , j, true );\n                if (d11 < d) twosat.addImplication(i, true , j, false);\n            }\n        }\n        var bitset = twosat.solve();\n        if (bitset == null) {\n            ps.println(\"No\");\n            return;\n        }\n        ps.println(\"Yes\");\n        for (int i = 0; i < n; i++) {\n            ps.println(bitset.get(i) ? y[i] : x[i]);\n        }\n    }\n\n    static class TwoSAT {\n        private final int n;\n        private InternalSCC scc;\n    \n        public TwoSAT (int n) {\n            this.n = n;\n            this.scc = new InternalSCC(2 * n);\n        }\n    \n        public void addCaluse(int x, boolean f, int y, boolean g) {\n            scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n            scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n        }\n\n        public void addImplication(int x, boolean f, int y, boolean g) {\n            addCaluse(x, !f, y, g);\n        }\n    \n        public java.util.BitSet solve() {\n            int[] ids = scc.ids();\n            java.util.BitSet answer = new java.util.BitSet(n);\n            for (int i = 0; i < n; i++) {\n                if (ids[i << 1 | 0] == ids[i << 1 | 1]) return null;\n                answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n            }\n            return answer;\n        }\n    \n        private static final class EdgeList {\n            long[] a;\n            int ptr = 0;\n            EdgeList(int cap) {a = new long[cap];}\n            void add(int upper, int lower) {\n                if (ptr == a.length) grow();\n                a[ptr++] = (long) upper << 32 | lower;\n            }\n            void grow() {\n                long[] b = new long[a.length << 1];\n                System.arraycopy(a, 0, b, 0, a.length);\n                a = b;\n            }\n        }\n    \n        private static final class InternalSCC {\n            final int n;\n            int m;\n            final EdgeList unorderedEdges;\n            final int[] start;\n            InternalSCC(int n) {\n                this.n = n;\n                this.unorderedEdges = new EdgeList(n);\n                this.start = new int[n + 1];\n            }\n            void addEdge(int from, int to) {\n                unorderedEdges.add(from, to);\n                start[from + 1]++;\n                this.m++;\n            }\n            private static final long mask = 0xffff_ffffl;\n            int[] ids() {\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                int[] orderedEdges = new int[m];\n                int[] count = new int[n + 1];\n                System.arraycopy(start, 0, count, 0, n + 1);\n                for (int i = 0; i < m; i++) {\n                    long e = unorderedEdges.a[i];\n                    orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n                }\n                int nowOrd = 0;\n                int groupNum = 0;\n                int k = 0;\n                int[] par = new int[n];\n                int[] visited = new int[n];\n                int[] low = new int[n];\n                int[] ord = new int[n];\n                java.util.Arrays.fill(ord, -1);\n                int[] ids = new int[n];\n                long[] stack = new long[n];\n                int ptr = 0;\n                \n                for (int i = 0; i < n; i++) {\n                    if (ord[i] >= 0) continue;\n                    par[i] = -1;\n                    stack[ptr++] = i;\n                    while (ptr > 0) {\n                        long p = stack[--ptr];\n                        int u = (int) (p & mask);\n                        int j = (int) (p >>> 32);\n                        if (j == 0) {\n                            low[u] = ord[u] = nowOrd++;\n                            visited[k++] = u;\n                        }\n                        if (start[u] + j < count[u]) {\n                            int to = orderedEdges[start[u] + j];\n                            stack[ptr++] += 1l << 32;\n                            if (ord[to] == -1) {\n                                stack[ptr++] = to;\n                                par[to] = u;\n                            } else {\n                                low[u] = Math.min(low[u], ord[to]);\n                            }\n                        } else {\n                            while (j --> 0) {\n                                int to = orderedEdges[start[u] + j];\n                                if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                            }\n                            if (low[u] == ord[u]) {\n                                while (true) {\n                                    int v = visited[--k];\n                                    ord[v] = n;\n                                    ids[v] = groupNum;\n                                    if (v == u) break;\n                                }\n                                groupNum++;\n                            }\n                        }\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    ids[i] = groupNum - 1 - ids[i];\n                }\n                return ids;\n            }\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final java.io.InputStream in;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private int buflen = 0;\n    \n        public FastScanner(java.io.InputStream in) {\n            this.in = in;\n        }\n    \n        public FastScanner() {\n            this(System.in);\n        }\n    \n        private boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            ptr = 0;\n            try {\n                buflen = in.read(buf);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buflen > 0;\n        }\n    \n        private int readByte() {\n            return hasNextByte() ? buf[ptr++] : -1;\n        }\n    \n        public boolean hasNext() {\n            while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n            return hasNextByte();\n        }\n    \n        private StringBuilder nextSequence() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n                sb.appendCodePoint(b);\n            }\n            return sb;\n        }\n    \n        public String next() {\n            return nextSequence().toString();\n        }\n    \n        public String next(int len) {\n            return new String(nextChars(len));\n        }\n    \n        public char nextChar() {\n            if (!hasNextByte()) throw new java.util.NoSuchElementException();\n            return (char) readByte();\n        }\n    \n        public char[] nextChars() {\n            StringBuilder sb = nextSequence();\n            int l = sb.length();\n            char[] dst = new char[l];\n            sb.getChars(0, l, dst, 0);\n            return dst;\n        }\n        public char[] nextChars(int len) {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (32 < b && b < 127 && i < len) {\n                s[i++] = (char) b; b = readByte();\n            }\n            if (i != len) {\n                throw new java.util.NoSuchElementException(\n                    String.format(\"Next token has smaller length than expected.\", len)\n                );\n            }\n            return s;\n        }\n        public long nextLong() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n = n * 10 + b - '0';\n                } else if (b == -1 || !(32 < b && b < 127)) {\n                    return minus ? -n : n;\n                } else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n        public int nextInt() {\n            return Math.toIntExact(nextLong());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public void close() {\n            try {\n                in.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    static class FastPrintStream implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private final java.lang.reflect.Field strField;\n        private final java.nio.charset.CharsetEncoder encoder;\n    \n        private java.io.OutputStream out;\n    \n        public FastPrintStream(java.io.OutputStream out) {\n            this.out = out;\n            java.lang.reflect.Field f;\n            try {\n                f = java.lang.String.class.getDeclaredField(\"value\");\n                f.setAccessible(true);\n            } catch (NoSuchFieldException | SecurityException e) {\n                f = null;\n            }\n            this.strField = f;\n            this.encoder = java.nio.charset.StandardCharsets.UTF_8.newEncoder();\n        }\n    \n        public FastPrintStream(java.io.File file) throws java.io.IOException {\n            this(new java.io.FileOutputStream(file));\n        }\n    \n        public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n            this(new java.io.File(filename));\n        }\n    \n        public FastPrintStream() {\n            this(System.out);\n            try {\n                java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n                f.setAccessible(true);\n                f.set(System.out, false);\n            } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n                // ignore\n            }\n        }\n    \n        public FastPrintStream println() {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) '\\n';\n            return this;\n        }\n    \n        public FastPrintStream println(java.lang.Object o) {\n            return print(o).println();\n        }\n    \n        public FastPrintStream println(java.lang.String s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char[] s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char c) {\n            return print(c).println();\n        }\n    \n        public FastPrintStream println(int x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(long x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(double d, int precision) {\n            return print(d, precision).println();\n        }\n    \n        private FastPrintStream print(byte[] bytes) {\n            int n = bytes.length;\n            if (ptr + n > BUF_SIZE) {\n                internalFlush();\n                try {\n                    out.write(bytes);\n                } catch (java.io.IOException e) {\n                    throw new RuntimeException();\n                }\n            } else {\n                System.arraycopy(bytes, 0, buf, ptr, n);\n                ptr += n;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(java.lang.Object o) {\n            return print(o.toString());\n        }\n    \n        public FastPrintStream print(java.lang.String s) {\n            if (strField == null) {\n                return print(s.getBytes());\n            } else {\n                try {\n                    return print((byte[]) strField.get(s));\n                } catch (IllegalAccessException e) {\n                    return print(s.getBytes());\n                }\n            }\n        }\n    \n        public FastPrintStream print(char[] s) {\n            try {\n                return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n            } catch (java.nio.charset.CharacterCodingException e) {\n                byte[] bytes = new byte[s.length];\n                for (int i = 0; 9 < s.length; i++) {\n                    bytes[i] = (byte) s[i];\n                }\n                return print(bytes);\n            }\n        }\n    \n        public FastPrintStream print(char c) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) c;\n            return this;\n        }\n    \n        public FastPrintStream print(int x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(long x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(double d, int precision) {\n            if (d < 0) {\n                print('-');\n                d = -d;\n            }\n            d += Math.pow(10, -d) / 2;\n            print((long) d).print('.');\n            d -= (long) d;\n            for(int i = 0; i < precision; i++){\n                d *= 10;\n                print((int) d);\n                d -= (int) d;\n            }\n            return this;\n        }\n    \n        private void internalFlush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void flush() {\n            try {\n                out.write(buf, 0, ptr);\n                out.flush();\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void close() {\n            try {\n                out.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        private static int len(int x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            int p = -10;\n            for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n            return 10 + d;\n        }\n    \n        private static int len(long x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            long p = -10;\n            for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n            return 19 + d;\n        }\n    }\n\n    static int[] nextInts(int n, FastScanner sc) {\n        var dat = new int[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextInt());\n        return dat;\n    }\n\n    static long[] nextLongs(int n, FastScanner sc) {\n        var dat = new long[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextLong());\n        return dat;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        var sc = new FastScanner();\n        var ps = new FastPrintStream();\n        solve(sc, ps);\n        sc.close();\n        ps.flush();\n        ps.close();\n    }\n\n    public static void solve(FastScanner sc, FastPrintStream ps) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addClause(i, true , j, true );\n                if (d01 < d) twosat.addClause(i, true , j, false);\n                if (d10 < d) twosat.addClause(i, false, j, true );\n                if (d11 < d) twosat.addClause(i, false, j, false);\n            }\n        }\n        boolean exists = twosat.satisfiable();\n        if (!exists) {\n            ps.println(\"No\");\n            return;\n        }\n        ps.println(\"Yes\");\n        var bitset = twosat.answer();\n        for (int i = 0; i < n; i++) {\n            ps.println(bitset.get(i) ? y[i] : x[i]);\n        }\n    }\n\n    static class TwoSAT {\n        private final int n;\n        private final InternalSCC scc;\n        private final java.util.BitSet answer;\n    \n        private boolean hasCalledSatisfiable = false;\n        private boolean existsAnswer = false;\n    \n        public TwoSAT(int n) {\n            this.n = n;\n            this.scc = new InternalSCC(2 * n);\n            this.answer = new java.util.BitSet(n);\n        }\n    \n        public void addClause(int x, boolean f, int y, boolean g) {\n            scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n            scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n        }\n    \n        public void addImplication(int x, boolean f, int y, boolean g) {\n            addClause(x, !f, y, g);\n        }\n    \n        public void addNand(int x, boolean f, int y, boolean g) {\n            addClause(x, !f, y, !g);\n        }\n    \n        public boolean satisfiable() {\n            hasCalledSatisfiable = true;\n            int[] ids = scc.ids();\n            for (int i = 0; i < n; i++) {\n                if (ids[i << 1 | 0] == ids[i << 1 | 1]) return existsAnswer = false;\n                answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n            }\n            return existsAnswer = true;\n        }\n    \n        public java.util.BitSet answer() {\n            if (!hasCalledSatisfiable) {\n                throw new UnsupportedOperationException(\n                    \"Call TwoSAT#satisfiable at least once before TwoSAT#answer.\"\n                );\n            }\n            if (existsAnswer) return answer;\n            return null;\n        }\n    \n        private static final class EdgeList {\n            long[] a;\n            int ptr = 0;\n            EdgeList(int cap) {a = new long[cap];}\n            void add(int upper, int lower) {\n                if (ptr == a.length) grow();\n                a[ptr++] = (long) upper << 32 | lower;\n            }\n            void grow() {\n                long[] b = new long[a.length << 1];\n                System.arraycopy(a, 0, b, 0, a.length);\n                a = b;\n            }\n        }\n    \n        private static final class InternalSCC {\n            final int n;\n            int m;\n            final EdgeList unorderedEdges;\n            final int[] start;\n            InternalSCC(int n) {\n                this.n = n;\n                this.unorderedEdges = new EdgeList(n);\n                this.start = new int[n + 1];\n            }\n            void addEdge(int from, int to) {\n                unorderedEdges.add(from, to);\n                start[from + 1]++;\n                this.m++;\n            }\n            static final long mask = 0xffff_ffffl;\n            int[] ids() {\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                int[] orderedEdges = new int[m];\n                int[] count = new int[n + 1];\n                System.arraycopy(start, 0, count, 0, n + 1);\n                for (int i = 0; i < m; i++) {\n                    long e = unorderedEdges.a[i];\n                    orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n                }\n                int nowOrd = 0;\n                int groupNum = 0;\n                int k = 0;\n                int[] par = new int[n];\n                int[] vis = new int[n];\n                int[] low = new int[n];\n                int[] ord = new int[n];\n                java.util.Arrays.fill(ord, -1);\n                int[] ids = new int[n];\n                long[] stack = new long[n];\n                int ptr = 0;\n                \n                for (int i = 0; i < n; i++) {\n                    if (ord[i] >= 0) continue;\n                    par[i] = -1;\n                    stack[ptr++] = i;\n                    while (ptr > 0) {\n                        long p = stack[--ptr];\n                        int u = (int) (p & mask);\n                        int j = (int) (p >>> 32);\n                        if (j == 0) {\n                            low[u] = ord[u] = nowOrd++;\n                            vis[k++] = u;\n                        }\n                        if (start[u] + j < count[u]) {\n                            int to = orderedEdges[start[u] + j];\n                            stack[ptr++] += 1l << 32;\n                            if (ord[to] == -1) {\n                                stack[ptr++] = to;\n                                par[to] = u;\n                            } else {\n                                low[u] = Math.min(low[u], ord[to]);\n                            }\n                        } else {\n                            while (j --> 0) {\n                                int to = orderedEdges[start[u] + j];\n                                if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                            }\n                            if (low[u] == ord[u]) {\n                                while (true) {\n                                    int v = vis[--k];\n                                    ord[v] = n;\n                                    ids[v] = groupNum;\n                                    if (v == u) break;\n                                }\n                                groupNum++;\n                            }\n                        }\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    ids[i] = groupNum - 1 - ids[i];\n                }\n                return ids;\n            }\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final java.io.InputStream in;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private int buflen = 0;\n    \n        public FastScanner(java.io.InputStream in) {\n            this.in = in;\n        }\n    \n        public FastScanner() {\n            this(System.in);\n        }\n    \n        private boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            ptr = 0;\n            try {\n                buflen = in.read(buf);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buflen > 0;\n        }\n    \n        private int readByte() {\n            return hasNextByte() ? buf[ptr++] : -1;\n        }\n    \n        public boolean hasNext() {\n            while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n            return hasNextByte();\n        }\n    \n        private StringBuilder nextSequence() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n                sb.appendCodePoint(b);\n            }\n            return sb;\n        }\n    \n        public String next() {\n            return nextSequence().toString();\n        }\n    \n        public String next(int len) {\n            return new String(nextChars(len));\n        }\n    \n        public char nextChar() {\n            if (!hasNextByte()) throw new java.util.NoSuchElementException();\n            return (char) readByte();\n        }\n    \n        public char[] nextChars() {\n            StringBuilder sb = nextSequence();\n            int l = sb.length();\n            char[] dst = new char[l];\n            sb.getChars(0, l, dst, 0);\n            return dst;\n        }\n        public char[] nextChars(int len) {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (32 < b && b < 127 && i < len) {\n                s[i++] = (char) b; b = readByte();\n            }\n            if (i != len) {\n                throw new java.util.NoSuchElementException(\n                    String.format(\"Next token has smaller length than expected.\", len)\n                );\n            }\n            return s;\n        }\n        public long nextLong() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n = n * 10 + b - '0';\n                } else if (b == -1 || !(32 < b && b < 127)) {\n                    return minus ? -n : n;\n                } else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n        public int nextInt() {\n            return Math.toIntExact(nextLong());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public void close() {\n            try {\n                in.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    static class FastPrintStream implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private final java.lang.reflect.Field strField;\n        private final java.nio.charset.CharsetEncoder encoder;\n    \n        private java.io.OutputStream out;\n    \n        public FastPrintStream(java.io.OutputStream out) {\n            this.out = out;\n            java.lang.reflect.Field f;\n            try {\n                f = java.lang.String.class.getDeclaredField(\"value\");\n                f.setAccessible(true);\n            } catch (NoSuchFieldException | SecurityException e) {\n                f = null;\n            }\n            this.strField = f;\n            this.encoder = java.nio.charset.StandardCharsets.UTF_8.newEncoder();\n        }\n    \n        public FastPrintStream(java.io.File file) throws java.io.IOException {\n            this(new java.io.FileOutputStream(file));\n        }\n    \n        public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n            this(new java.io.File(filename));\n        }\n    \n        public FastPrintStream() {\n            this(System.out);\n            try {\n                java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n                f.setAccessible(true);\n                f.set(System.out, false);\n            } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n                // ignore\n            }\n        }\n    \n        public FastPrintStream println() {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) '\\n';\n            return this;\n        }\n    \n        public FastPrintStream println(java.lang.Object o) {\n            return print(o).println();\n        }\n    \n        public FastPrintStream println(java.lang.String s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char[] s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char c) {\n            return print(c).println();\n        }\n    \n        public FastPrintStream println(int x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(long x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(double d, int precision) {\n            return print(d, precision).println();\n        }\n    \n        private FastPrintStream print(byte[] bytes) {\n            int n = bytes.length;\n            if (ptr + n > BUF_SIZE) {\n                internalFlush();\n                try {\n                    out.write(bytes);\n                } catch (java.io.IOException e) {\n                    throw new RuntimeException();\n                }\n            } else {\n                System.arraycopy(bytes, 0, buf, ptr, n);\n                ptr += n;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(java.lang.Object o) {\n            return print(o.toString());\n        }\n    \n        public FastPrintStream print(java.lang.String s) {\n            if (strField == null) {\n                return print(s.getBytes());\n            } else {\n                try {\n                    return print((byte[]) strField.get(s));\n                } catch (IllegalAccessException e) {\n                    return print(s.getBytes());\n                }\n            }\n        }\n    \n        public FastPrintStream print(char[] s) {\n            try {\n                return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n            } catch (java.nio.charset.CharacterCodingException e) {\n                byte[] bytes = new byte[s.length];\n                for (int i = 0; 9 < s.length; i++) {\n                    bytes[i] = (byte) s[i];\n                }\n                return print(bytes);\n            }\n        }\n    \n        public FastPrintStream print(char c) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) c;\n            return this;\n        }\n    \n        public FastPrintStream print(int x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(long x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(double d, int precision) {\n            if (d < 0) {\n                print('-');\n                d = -d;\n            }\n            d += Math.pow(10, -d) / 2;\n            print((long) d).print('.');\n            d -= (long) d;\n            for(int i = 0; i < precision; i++){\n                d *= 10;\n                print((int) d);\n                d -= (int) d;\n            }\n            return this;\n        }\n    \n        private void internalFlush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void flush() {\n            try {\n                out.write(buf, 0, ptr);\n                out.flush();\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void close() {\n            try {\n                out.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        private static int len(int x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            int p = -10;\n            for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n            return 10 + d;\n        }\n    \n        private static int len(long x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            long p = -10;\n            for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n            return 19 + d;\n        }\n    }\n\n    static int[] nextInts(int n, FastScanner sc) {\n        var dat = new int[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextInt());\n        return dat;\n    }\n\n    static long[] nextLongs(int n, FastScanner sc) {\n        var dat = new long[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextLong());\n        return dat;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        var sc = new FastScanner();\n        var ps = new FastPrintStream();\n        solve(sc, ps);\n        sc.close();\n        ps.flush();\n        ps.close();\n    }\n    public static void solve(FastScanner sc, FastPrintStream ps) {\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        var twosat = new TwoSAT(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int d00 = Math.abs(x[i] - x[j]);\n                int d01 = Math.abs(x[i] - y[j]);\n                int d10 = Math.abs(y[i] - x[j]);\n                int d11 = Math.abs(y[i] - y[j]);\n                if (d00 < d) twosat.addNand(i, false, j, false);\n                if (d01 < d) twosat.addNand(i, false, j, true );\n                if (d10 < d) twosat.addNand(i, true , j, false);\n                if (d11 < d) twosat.addNand(i, true , j, true );\n            }\n        }\n        var bitset = twosat.solve();\n        if (bitset == null) {\n            ps.println(\"No\");\n            return;\n        }\n        ps.println(\"Yes\");\n        for (int i = 0; i < n; i++) {\n            ps.println(bitset.get(i) ? y[i] : x[i]);\n        }\n    }\n\n    static class TwoSAT {\n        private final int n;\n        private InternalSCC scc;\n    \n        public TwoSAT (int n) {\n            this.n = n;\n            this.scc = new InternalSCC(2 * n);\n        }\n    \n        public void addCaluse(int x, boolean f, int y, boolean g) {\n            scc.addEdge(x << 1 | (f ? 0 : 1), y << 1 | (g ? 1 : 0));\n            scc.addEdge(y << 1 | (g ? 0 : 1), x << 1 | (f ? 1 : 0));\n        }\n\n        public void addImplication(int x, boolean f, int y, boolean g) {\n            addCaluse(x, !f, y, g);\n        }\n\n        public void addNand(int x, boolean f, int y, boolean g) {\n            addCaluse(x, !f, y, !g);\n        }\n    \n        public java.util.BitSet solve() {\n            int[] ids = scc.ids();\n            java.util.BitSet answer = new java.util.BitSet(n);\n            for (int i = 0; i < n; i++) {\n                if (ids[i << 1 | 0] == ids[i << 1 | 1]) return null;\n                answer.set(i, ids[i << 1 | 0] < ids[i << 1 | 1]);\n            }\n            return answer;\n        }\n    \n        private static final class EdgeList {\n            long[] a;\n            int ptr = 0;\n            EdgeList(int cap) {a = new long[cap];}\n            void add(int upper, int lower) {\n                if (ptr == a.length) grow();\n                a[ptr++] = (long) upper << 32 | lower;\n            }\n            void grow() {\n                long[] b = new long[a.length << 1];\n                System.arraycopy(a, 0, b, 0, a.length);\n                a = b;\n            }\n        }\n    \n        private static final class InternalSCC {\n            final int n;\n            int m;\n            final EdgeList unorderedEdges;\n            final int[] start;\n            InternalSCC(int n) {\n                this.n = n;\n                this.unorderedEdges = new EdgeList(n);\n                this.start = new int[n + 1];\n            }\n            void addEdge(int from, int to) {\n                unorderedEdges.add(from, to);\n                start[from + 1]++;\n                this.m++;\n            }\n            private static final long mask = 0xffff_ffffl;\n            int[] ids() {\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                int[] orderedEdges = new int[m];\n                int[] count = new int[n + 1];\n                System.arraycopy(start, 0, count, 0, n + 1);\n                for (int i = 0; i < m; i++) {\n                    long e = unorderedEdges.a[i];\n                    orderedEdges[count[(int) (e >>> 32)]++] = (int) (e & mask);\n                }\n                int nowOrd = 0;\n                int groupNum = 0;\n                int k = 0;\n                int[] par = new int[n];\n                int[] visited = new int[n];\n                int[] low = new int[n];\n                int[] ord = new int[n];\n                java.util.Arrays.fill(ord, -1);\n                int[] ids = new int[n];\n                long[] stack = new long[n];\n                int ptr = 0;\n                \n                for (int i = 0; i < n; i++) {\n                    if (ord[i] >= 0) continue;\n                    par[i] = -1;\n                    stack[ptr++] = i;\n                    while (ptr > 0) {\n                        long p = stack[--ptr];\n                        int u = (int) (p & mask);\n                        int j = (int) (p >>> 32);\n                        if (j == 0) {\n                            low[u] = ord[u] = nowOrd++;\n                            visited[k++] = u;\n                        }\n                        if (start[u] + j < count[u]) {\n                            int to = orderedEdges[start[u] + j];\n                            stack[ptr++] += 1l << 32;\n                            if (ord[to] == -1) {\n                                stack[ptr++] = to;\n                                par[to] = u;\n                            } else {\n                                low[u] = Math.min(low[u], ord[to]);\n                            }\n                        } else {\n                            while (j --> 0) {\n                                int to = orderedEdges[start[u] + j];\n                                if (par[to] == u) low[u] = Math.min(low[u], low[to]);\n                            }\n                            if (low[u] == ord[u]) {\n                                while (true) {\n                                    int v = visited[--k];\n                                    ord[v] = n;\n                                    ids[v] = groupNum;\n                                    if (v == u) break;\n                                }\n                                groupNum++;\n                            }\n                        }\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    ids[i] = groupNum - 1 - ids[i];\n                }\n                return ids;\n            }\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final java.io.InputStream in;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private int buflen = 0;\n    \n        public FastScanner(java.io.InputStream in) {\n            this.in = in;\n        }\n    \n        public FastScanner() {\n            this(System.in);\n        }\n    \n        private boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            ptr = 0;\n            try {\n                buflen = in.read(buf);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buflen > 0;\n        }\n    \n        private int readByte() {\n            return hasNextByte() ? buf[ptr++] : -1;\n        }\n    \n        public boolean hasNext() {\n            while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n            return hasNextByte();\n        }\n    \n        private StringBuilder nextSequence() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n                sb.appendCodePoint(b);\n            }\n            return sb;\n        }\n    \n        public String next() {\n            return nextSequence().toString();\n        }\n    \n        public String next(int len) {\n            return new String(nextChars(len));\n        }\n    \n        public char nextChar() {\n            if (!hasNextByte()) throw new java.util.NoSuchElementException();\n            return (char) readByte();\n        }\n    \n        public char[] nextChars() {\n            StringBuilder sb = nextSequence();\n            int l = sb.length();\n            char[] dst = new char[l];\n            sb.getChars(0, l, dst, 0);\n            return dst;\n        }\n        public char[] nextChars(int len) {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (32 < b && b < 127 && i < len) {\n                s[i++] = (char) b; b = readByte();\n            }\n            if (i != len) {\n                throw new java.util.NoSuchElementException(\n                    String.format(\"Next token has smaller length than expected.\", len)\n                );\n            }\n            return s;\n        }\n        public long nextLong() {\n            if (!hasNext()) throw new java.util.NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n = n * 10 + b - '0';\n                } else if (b == -1 || !(32 < b && b < 127)) {\n                    return minus ? -n : n;\n                } else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n        public int nextInt() {\n            return Math.toIntExact(nextLong());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public void close() {\n            try {\n                in.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    static class FastPrintStream implements AutoCloseable {\n        private static final int BUF_SIZE = 1 << 15;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr = 0;\n        private final java.lang.reflect.Field strField;\n        private final java.nio.charset.CharsetEncoder encoder;\n    \n        private java.io.OutputStream out;\n    \n        public FastPrintStream(java.io.OutputStream out) {\n            this.out = out;\n            java.lang.reflect.Field f;\n            try {\n                f = java.lang.String.class.getDeclaredField(\"value\");\n                f.setAccessible(true);\n            } catch (NoSuchFieldException | SecurityException e) {\n                f = null;\n            }\n            this.strField = f;\n            this.encoder = java.nio.charset.StandardCharsets.UTF_8.newEncoder();\n        }\n    \n        public FastPrintStream(java.io.File file) throws java.io.IOException {\n            this(new java.io.FileOutputStream(file));\n        }\n    \n        public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n            this(new java.io.File(filename));\n        }\n    \n        public FastPrintStream() {\n            this(System.out);\n            try {\n                java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n                f.setAccessible(true);\n                f.set(System.out, false);\n            } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n                // ignore\n            }\n        }\n    \n        public FastPrintStream println() {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) '\\n';\n            return this;\n        }\n    \n        public FastPrintStream println(java.lang.Object o) {\n            return print(o).println();\n        }\n    \n        public FastPrintStream println(java.lang.String s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char[] s) {\n            return print(s).println();\n        }\n    \n        public FastPrintStream println(char c) {\n            return print(c).println();\n        }\n    \n        public FastPrintStream println(int x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(long x) {\n            return print(x).println();\n        }\n    \n        public FastPrintStream println(double d, int precision) {\n            return print(d, precision).println();\n        }\n    \n        private FastPrintStream print(byte[] bytes) {\n            int n = bytes.length;\n            if (ptr + n > BUF_SIZE) {\n                internalFlush();\n                try {\n                    out.write(bytes);\n                } catch (java.io.IOException e) {\n                    throw new RuntimeException();\n                }\n            } else {\n                System.arraycopy(bytes, 0, buf, ptr, n);\n                ptr += n;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(java.lang.Object o) {\n            return print(o.toString());\n        }\n    \n        public FastPrintStream print(java.lang.String s) {\n            if (strField == null) {\n                return print(s.getBytes());\n            } else {\n                try {\n                    return print((byte[]) strField.get(s));\n                } catch (IllegalAccessException e) {\n                    return print(s.getBytes());\n                }\n            }\n        }\n    \n        public FastPrintStream print(char[] s) {\n            try {\n                return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n            } catch (java.nio.charset.CharacterCodingException e) {\n                byte[] bytes = new byte[s.length];\n                for (int i = 0; 9 < s.length; i++) {\n                    bytes[i] = (byte) s[i];\n                }\n                return print(bytes);\n            }\n        }\n    \n        public FastPrintStream print(char c) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = (byte) c;\n            return this;\n        }\n    \n        public FastPrintStream print(int x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(long x) {\n            if (x == 0) {\n                if (ptr == BUF_SIZE) internalFlush();\n                buf[ptr++] = '0';\n                return this;\n            }\n            int d = len(x);\n            if (ptr + d > BUF_SIZE) internalFlush();\n            if (x < 0) {\n                buf[ptr++] = '-';\n                x = -x;\n                d--;\n            }\n            int j = ptr += d; \n            while (x > 0) {\n                buf[--j] = (byte) ('0' + (x % 10));\n                x /= 10;\n            }\n            return this;\n        }\n    \n        public FastPrintStream print(double d, int precision) {\n            if (d < 0) {\n                print('-');\n                d = -d;\n            }\n            d += Math.pow(10, -d) / 2;\n            print((long) d).print('.');\n            d -= (long) d;\n            for(int i = 0; i < precision; i++){\n                d *= 10;\n                print((int) d);\n                d -= (int) d;\n            }\n            return this;\n        }\n    \n        private void internalFlush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void flush() {\n            try {\n                out.write(buf, 0, ptr);\n                out.flush();\n                ptr = 0;\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        public void close() {\n            try {\n                out.close();\n            } catch (java.io.IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    \n        private static int len(int x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            int p = -10;\n            for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n            return 10 + d;\n        }\n    \n        private static int len(long x) {\n            int d = 1;\n            if (x >= 0) {d = 0; x = -x;}\n            long p = -10;\n            for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n            return 19 + d;\n        }\n    }\n\n    static int[] nextInts(int n, FastScanner sc) {\n        var dat = new int[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextInt());\n        return dat;\n    }\n\n    static long[] nextLongs(int n, FastScanner sc) {\n        var dat = new long[n];\n        java.util.Arrays.setAll(dat, i -> sc.nextLong());\n        return dat;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.OptionalInt;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.nio.charset.Charset;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.util.stream.LongStream;\nimport java.util.Iterator;\nimport java.nio.CharBuffer;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.nio.charset.CharsetDecoder;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.security.AccessControlException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper reloaded plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner2 in = new LightScanner2(inputStream);\n        LightWriter2 out = new LightWriter2(outputStream);\n        HTwoSAT solver = new HTwoSAT();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HTwoSAT {\n        public void solve(int testNumber, LightScanner2 in, LightWriter2 out) {\n            int n = in.ints();\n            long d = in.longs();\n            long[] x = new long[n], y = new long[n], z = new long[2 * n];\n            in.longs(x, y);\n            // 座標圧縮\n            System.arraycopy(x, 0, z, 0, n);\n            System.arraycopy(y, 0, z, n, n);\n            OrderedCompressor cmp = new OrderedCompressor(z);\n            // 2-SAT\n            int m = cmp.size();\n            TwoSat sat = new TwoSat(m);\n            for (int i = 0; i < n; i++) sat.or(cmp.map(x[i]) + 1, cmp.map(y[i]) + 1);\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (cmp.unmap(i) - cmp.unmap(j) >= d) continue;\n                    sat.or(-1 - i, -1 - j);\n                }\n            }\n            boolean[] res = sat.solve();\n            if (res == null) {\n                out.noln();\n                return;\n            }\n            out.yesln();\n            for (int i = 0; i < n; i++) {\n                out.ans(res[cmp.map(x[i])] ? x[i] : y[i]).ln();\n            }\n        }\n\n    }\n\n    static abstract class LightScannerAdapter implements AutoCloseable {\n        public abstract String string();\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n\n        public final void longs(long[]... arrays) {\n            int l = Arrays.stream(arrays).mapToInt(a -> a.length).min().orElse(0);\n            for (int i = 0; i < l; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = longs();\n                }\n            }\n        }\n\n        public abstract void close();\n\n    }\n\n    static class LightWriter2 implements AutoCloseable {\n        private static final int BUF_SIZE = 32 * 1024;\n        private static final int BUF_THRESHOLD = 1024;\n        private final OutputStream out;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr;\n        private final Field fastStringAccess;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n        private LightWriter2.BoolLabel boolLabel = LightWriter2.BoolLabel.YES_NO_FIRST_UP;\n\n        public LightWriter2(OutputStream out) {\n            this.out = out;\n            Field f;\n            try {\n                f = String.class.getDeclaredField(\"value\");\n                f.setAccessible(true);\n                if (f.getType() != byte[].class) f = null;\n            } catch (ReflectiveOperationException | AccessControlException ignored) {\n                f = null;\n            }\n            this.fastStringAccess = f;\n        }\n\n        public LightWriter2(Writer out) {\n            this.out = new LightWriter2.WriterOutputStream(out);\n            this.fastStringAccess = null;\n        }\n\n        private void allocate(int n) {\n            if (ptr + n <= BUF_SIZE) return;\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            if (BUF_SIZE < n) throw new IllegalArgumentException(\"Internal buffer exceeded\");\n        }\n\n        public void close() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n                out.flush();\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n        public LightWriter2 print(char c) {\n            allocate(1);\n            buf[ptr++] = (byte) c;\n            breaked = false;\n            return this;\n        }\n\n        public LightWriter2 print(String s) {\n            byte[] bytes;\n            if (this.fastStringAccess == null) bytes = s.getBytes();\n            else {\n                try {\n                    bytes = (byte[]) fastStringAccess.get(s);\n                } catch (IllegalAccessException ignored) {\n                    bytes = s.getBytes();\n                }\n            }\n            int n = bytes.length;\n            if (n <= BUF_THRESHOLD) {\n                allocate(n);\n                System.arraycopy(bytes, 0, buf, ptr, n);\n                ptr += n;\n                return this;\n            }\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n                out.write(bytes);\n                out.flush();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter2 ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            breaked = false;\n            return print(s);\n        }\n\n        public LightWriter2 ans(long l) {\n            if (!breaked) {\n                print(' ');\n            }\n            breaked = false;\n            if (l == 0) return print('0');\n            if (l < 0) {\n                print('-');\n                l = -l;\n            }\n            int n = 0;\n            long t = l;\n            while (t > 0) {\n                t /= 10;\n                n++;\n            }\n            allocate(n);\n            for (int i = 1; i <= n; i++) {\n                buf[ptr + n - i] = (byte) (l % 10 + '0');\n                l /= 10;\n            }\n            ptr += n;\n            return this;\n        }\n\n        public LightWriter2 ans(boolean b) {\n            return ans(boolLabel.transfer(b));\n        }\n\n        public LightWriter2 yesln() {\n            return ans(true).ln();\n        }\n\n        public LightWriter2 noln() {\n            return ans(false).ln();\n        }\n\n        public LightWriter2 ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public enum BoolLabel {\n            YES_NO_FIRST_UP(\"Yes\", \"No\"),\n            YES_NO_ALL_UP(\"YES\", \"NO\"),\n            YES_NO_ALL_DOWN(\"yes\", \"no\"),\n            Y_N_ALL_UP(\"Y\", \"N\"),\n            POSSIBLE_IMPOSSIBLE_FIRST_UP(\"Possible\", \"Impossible\"),\n            POSSIBLE_IMPOSSIBLE_ALL_UP(\"POSSIBLE\", \"IMPOSSIBLE\"),\n            POSSIBLE_IMPOSSIBLE_ALL_DOWN(\"possible\", \"impossible\"),\n            FIRST_SECOND_FIRST_UP(\"First\", \"Second\"),\n            FIRST_SECOND_ALL_UP(\"FIRST\", \"SECOND\"),\n            FIRST_SECOND_ALL_DOWN(\"first\", \"second\"),\n            ALICE_BOB_FIRST_UP(\"Alice\", \"Bob\"),\n            ALICE_BOB_ALL_UP(\"ALICE\", \"BOB\"),\n            ALICE_BOB_ALL_DOWN(\"alice\", \"bob\"),\n            ;\n            private final String positive;\n            private final String negative;\n\n            BoolLabel(String positive, String negative) {\n                this.positive = positive;\n                this.negative = negative;\n            }\n\n            private String transfer(boolean f) {\n                return f ? positive : negative;\n            }\n\n        }\n\n        private static class WriterOutputStream extends OutputStream {\n            final Writer writer;\n            final CharsetDecoder decoder;\n\n            WriterOutputStream(Writer writer) {\n                this.writer = writer;\n                this.decoder = StandardCharsets.UTF_8.newDecoder();\n            }\n\n            public void write(int b) throws IOException {\n                writer.write(b);\n            }\n\n            public void write(byte[] b) throws IOException {\n                writer.write(decoder.decode(ByteBuffer.wrap(b)).array());\n            }\n\n            public void write(byte[] b, int off, int len) throws IOException {\n                writer.write(decoder.decode(ByteBuffer.wrap(b, off, len)).array());\n            }\n\n            public void flush() throws IOException {\n                writer.flush();\n            }\n\n            public void close() throws IOException {\n                writer.close();\n            }\n\n        }\n\n    }\n\n    static interface Verified {\n    }\n\n    static class LightScanner2 extends LightScannerAdapter {\n        private static final int BUF_SIZE = 32 * 1024;\n        private final InputStream stream;\n        private final StringBuilder builder = new StringBuilder();\n        private final byte[] buf = new byte[BUF_SIZE];\n        private int ptr;\n        private int len;\n\n        public LightScanner2(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            if (ptr < len) return buf[ptr++];\n            try {\n                ptr = 0;\n                len = stream.read(buf);\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            if (len == -1) return -1;\n            return buf[ptr++];\n        }\n\n        private void skip() {\n            int b;\n            while (isTokenSeparator(b = read()) && b != -1) ;\n            if (b == -1) throw new NoSuchElementException(\"EOF\");\n            ptr--;\n        }\n\n        private void loadToken() {\n            builder.setLength(0);\n            skip();\n            for (int b = read(); !isTokenSeparator(b); b = read()) {\n                builder.appendCodePoint(b);\n            }\n        }\n\n        public String string() {\n            loadToken();\n            return builder.toString();\n        }\n\n        public int ints() {\n            long x = longs();\n            if (x < Integer.MIN_VALUE || Integer.MAX_VALUE < x) throw new NumberFormatException(\"Overflow\");\n            return (int) x;\n        }\n\n        public long longs() {\n            skip();\n            int b = read();\n            boolean negate;\n            if (b == '-') {\n                negate = true;\n                b = read();\n            } else negate = false;\n            long x = 0;\n            for (; !isTokenSeparator(b); b = read()) {\n                if ('0' <= b && b <= '9') x = x * 10 + b - '0';\n                else throw new NumberFormatException(\"Unexpected character '\" + b + \"'\");\n            }\n            return negate ? -x : x;\n        }\n\n        public void close() {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        private static boolean isTokenSeparator(int b) {\n            return b < 33 || 126 < b;\n        }\n\n    }\n\n    static class OrderedCompressor implements Iterable<Long> {\n        private final Map<Long, Integer> natural = new HashMap<>();\n        private final long[] reverse;\n\n        public OrderedCompressor(long... values) {\n            int n = values.length, counter = 0;\n            long[] tmp = new long[n];\n            IntroSort.sort(values);\n            for (int i = 0; i < n; i++) {\n                if (i != 0 && values[i - 1] == values[i]) continue;\n                natural.put(values[i], counter);\n                tmp[counter++] = values[i];\n            }\n            this.reverse = Arrays.copyOf(tmp, counter);\n        }\n\n        public OrderedCompressor(Collection<Long> values) {\n            this(values.stream().mapToLong(x -> x).toArray());\n        }\n\n        public int map(long x) {\n            return natural.get(x);\n        }\n\n        public long unmap(int x) {\n            return reverse[x];\n        }\n\n        public int size() {\n            return reverse.length;\n        }\n\n        public Iterator<Long> iterator() {\n            return new Iterator<>() {\n                int pos = 0;\n\n                public boolean hasNext() {\n                    return pos < reverse.length;\n                }\n\n                public Long next() {\n                    return reverse[pos++];\n                }\n            };\n        }\n\n    }\n\n    static class QuickSort {\n        private QuickSort() {\n        }\n\n        private static void med(long[] a, int low, int x, int y, int z) {\n            if (a[z] < a[x]) {\n                ArrayUtil.swap(a, low, x);\n            } else if (a[y] < a[z]) {\n                ArrayUtil.swap(a, low, y);\n            } else {\n                ArrayUtil.swap(a, low, z);\n            }\n        }\n\n        static int step(long[] a, int low, int high) {\n            int x = low + 1, y = low + (high - low) / 2, z = high - 1;\n            if (a[x] < a[y]) {\n                med(a, low, x, y, z);\n            } else {\n                med(a, low, y, x, z);\n            }\n\n            int lb = low + 1, ub = high;\n            while (true) {\n                while (a[lb] < a[low]) {\n                    lb++;\n                }\n                ub--;\n                while (a[low] < a[ub]) {\n                    ub--;\n                }\n                if (lb >= ub) {\n                    return lb;\n                }\n                ArrayUtil.swap(a, lb, ub);\n                lb++;\n            }\n        }\n\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {\n        }\n\n        public static void swap(long[] a, int x, int y) {\n            long t = a[x];\n            a[x] = a[y];\n            a[y] = t;\n        }\n\n    }\n\n    static class SCCDecomposer {\n        private SCCDecomposer() {\n            throw new UnsupportedOperationException();\n        }\n\n        public static <T extends NodeLike<T>> List<? extends Collection<T>> decompose(T... nodes) {\n            return decompose(Arrays.asList(nodes));\n        }\n\n        public static <T extends NodeLike<T>> List<? extends Collection<T>> decompose(List<T> nodes) {\n            int n = nodes.size(), allocated = 0;\n            boolean[] visited = new boolean[n];\n            int[] counter = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (visited[i]) continue;\n                allocated = allocate(nodes.get(i), allocated, counter, visited);\n            }\n            int[] order = new int[n];\n            for (int i = 0; i < n; i++) order[n - counter[i] - 1] = i;\n            List<List<T>> result = new ArrayList<>();\n            for (int i : order) {\n                if (counter[i] == -1) continue;\n                List<T> group = new ArrayList<>();\n                makeGroup(nodes.get(i), counter, group);\n                result.add(group);\n            }\n            return result;\n        }\n\n        private static int allocate(NodeLike<?> node, int allocated, int[] counter, boolean[] visited) {\n            visited[node.getIndex()] = true;\n            for (NodeLike<?> next : node.getNextNodes()) {\n                if (visited[next.getIndex()]) continue;\n                allocated = allocate(next, allocated, counter, visited);\n            }\n            counter[node.getIndex()] = allocated;\n            return allocated + 1;\n        }\n\n        private static <T extends NodeLike<T>> void makeGroup(T node, int[] counter, List<T> group) {\n            counter[node.getIndex()] = -1;\n            group.add(node);\n            for (T next : node.getPrevNodes()) {\n                if (counter[next.getIndex()] == -1) continue;\n                makeGroup(next, counter, group);\n            }\n        }\n\n    }\n\n    static class HeapSort {\n        private HeapSort() {\n        }\n\n        private static void heapfy(long[] a, int low, int high, int i, long val) {\n            int child = 2 * i - low + 1;\n            while (child < high) {\n                if (child + 1 < high && a[child] < a[child + 1]) {\n                    child++;\n                }\n                if (val >= a[child]) {\n                    break;\n                }\n                a[i] = a[child];\n                i = child;\n                child = 2 * i - low + 1;\n            }\n            a[i] = val;\n        }\n\n        static void sort(long[] a, int low, int high) {\n            for (int p = (high + low) / 2 - 1; p >= low; p--) {\n                heapfy(a, low, high, p, a[p]);\n            }\n            while (high > low) {\n                high--;\n                long pval = a[high];\n                a[high] = a[low];\n                heapfy(a, low, high, low, pval);\n            }\n        }\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int count(int v) {\n            return Integer.bitCount(v);\n        }\n\n        public static int msb(int v) {\n            if (v == 0) {\n                throw new IllegalArgumentException(\"Bit not found\");\n            }\n            v |= (v >> 1);\n            v |= (v >> 2);\n            v |= (v >> 4);\n            v |= (v >> 8);\n            v |= (v >> 16);\n            return count(v) - 1;\n        }\n\n    }\n\n    static interface NodeLike<T extends NodeLike<T>> {\n        int getIndex();\n\n        Collection<T> getNextNodes();\n\n        default Collection<T> getPrevNodes() {\n            // default implementation for an *undirected* graph\n            return getNextNodes();\n        }\n\n    }\n\n    static class TwoSat {\n        private final int n;\n        private final TwoSat.Node[] nodes;\n\n        public TwoSat(int n) {\n            this.n = n;\n            this.nodes = new TwoSat.Node[2 * n];\n            for (int i = 0; i < 2 * n; i++) nodes[i] = new TwoSat.Node(i);\n        }\n\n        private int encodeIndex(int x) {\n            if (0 < x) {\n                if (n < x) throw new IllegalArgumentException();\n                return x - 1;\n            } else if (x < 0) {\n                if (x < -n) throw new IllegalArgumentException();\n                return n - x - 1;\n            } else throw new IllegalArgumentException();\n        }\n\n        public void implies(int x, int y) {\n            x = encodeIndex(x);\n            y = encodeIndex(y);\n            nodes[x].next.add(nodes[y]);\n            nodes[y].prev.add(nodes[x]);\n        }\n\n        public void or(int x, int y) {\n            implies(-x, y);\n            implies(-y, x);\n        }\n\n        public boolean[] solve() {\n            List<? extends Collection<TwoSat.Node>> groups = SCCDecomposer.decompose(nodes);\n            int m = groups.size();\n            int[] ord = new int[2 * n];\n            for (int i = 0; i < m; i++) {\n                for (TwoSat.Node node : groups.get(i)) ord[node.index] = i;\n            }\n            //System.out.println(m + \"/\" + Arrays.toString(ord));\n            boolean[] result = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (ord[i] == ord[n + i]) return null;\n                result[i] = ord[i] > ord[n + i];\n            }\n            return result;\n        }\n\n        private static class Node implements NodeLike<TwoSat.Node> {\n            final int index;\n            final List<TwoSat.Node> next = new ArrayList<>();\n            final List<TwoSat.Node> prev = new ArrayList<>();\n\n            Node(int index) {\n                this.index = index;\n            }\n\n            public int getIndex() {\n                return index;\n            }\n\n            public Collection<TwoSat.Node> getNextNodes() {\n                return next;\n            }\n\n            public Collection<TwoSat.Node> getPrevNodes() {\n                return prev;\n            }\n\n        }\n\n    }\n\n    static class InsertionSort {\n        private InsertionSort() {\n        }\n\n        static void sort(long[] a, int low, int high) {\n            for (int i = low; i < high; i++) {\n                for (int j = i; j > low && a[j - 1] > a[j]; j--) {\n                    ArrayUtil.swap(a, j - 1, j);\n                }\n            }\n        }\n\n    }\n\n    static class IntroSort {\n        private static int INSERTIONSORT_THRESHOLD = 16;\n\n        private IntroSort() {\n        }\n\n        static void sort(long[] a, int low, int high, int maxDepth) {\n            while (high - low > INSERTIONSORT_THRESHOLD) {\n                if (maxDepth-- == 0) {\n                    HeapSort.sort(a, low, high);\n                    return;\n                }\n                int cut = QuickSort.step(a, low, high);\n                sort(a, cut, high, maxDepth);\n                high = cut;\n            }\n            InsertionSort.sort(a, low, high);\n        }\n\n        public static void sort(long[] a) {\n            if (a.length <= INSERTIONSORT_THRESHOLD) {\n                InsertionSort.sort(a, 0, a.length);\n            } else {\n                sort(a, 0, a.length, 2 * BitMath.msb(a.length));\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.function.*;\npublic class Main implements Runnable {\n\tstatic boolean DEBUG;\n\tpublic static void main(String[] args) {\n\t\tDEBUG = args.length > 0 && args[0].equals(\"-DEBUG\");\n\t\tThread.setDefaultUncaughtExceptionHandler((t, e) -> { e.printStackTrace(); System.exit(1); });\n\t\tnew Thread(null, new Main(), \"\", 1 << 31).start();\n\t}\n\n\tpublic void run() {\n\t\tSolver solver = new Solver();\n\t\tsolver.solve();\n\t\tsolver.exit();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int pointer = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif(pointer < buflen) return true;\n\t\t\telse {\n\t\t\t\tpointer = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn buflen > 0;\n\t\t\t}\n\t\t}\n\t\tprivate int readByte() { if(hasNextByte()) return buffer[pointer ++]; else return -1; }\n\t\tprivate boolean isPrintableChar(int c) { return isPrintableChar(c, false); }\n\t\tprivate boolean isPrintableChar(int c, boolean includingSpace) { return (includingSpace ? 32 : 33) <= c && c <= 126; }\n\t\tprivate void skipUnprintable() { skipUnprintable(false); }\n\t\tprivate void skipUnprintable(boolean includingSpace) { while(hasNextByte() && !isPrintableChar(buffer[pointer], includingSpace)) pointer++; }\n\t\tprivate boolean hasNext() { return hasNext(false); }\n\t\tprivate boolean hasNext(boolean includingSpace) { skipUnprintable(includingSpace); return hasNextByte(); }\n\t\tprivate StringBuilder sb = new StringBuilder();\n\t\tpublic String next() { return next(false); }\n\t\tpublic String next(boolean includingSpace) {\n\t\t\tif(!hasNext(includingSpace)) throw new NoSuchElementException();\n\t\t\tsb.setLength(0);\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b, includingSpace)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif(!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif(b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif(b < '0' || '9' < b) throw new NumberFormatException();\n\t\t\twhile(true) {\n\t\t\t\tif('0' <= b && b <= '9') n = n * 10 + b - '0';\n\t\t\t\telse if(b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Solver {\n\t\tFastScanner sc = new FastScanner();\n\t\tpublic Solver() { }\n\n\t\tString ns() { return ns(false); }\n\t\tString ns(boolean includingSpace) { return sc.next(includingSpace); }\n\t\tString[] ns(int n) { return ns(n, false); }\n\t\tString[] ns(int n, boolean includingSpace) {\n\t\t\tString a[] = new String[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = ns(includingSpace);\n\t\t\treturn a;\n\t\t}\n\t\tString[][] ns(int n, int m) { return ns(n, m, false); }\n\t\tString[][] ns(int n, int m, boolean includingSpace) {\n\t\t\tString a[][] = new String[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = ns(m, includingSpace);\n\t\t\treturn a;\n\t\t}\n\t\tchar nc() { return ns().charAt(0); }\n\t\tchar[] nc(int n) {\n\t\t\tString str = ns();\n\t\t\tif(n < 0) n = str.length();\n\t\t\tchar a[] = new char[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = str.charAt(i);\n\t\t\treturn a;\n\t\t}\n\t\tchar[][] nc(int n, int m) {\n\t\t\tchar a[][] = new char[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nc(m);\n\t\t\treturn a;\n\t\t}\n\t\tboolean[] nb(int n, char t) {\n\t\t\tchar c[] = nc(-1);\n\t\t\tif(n < 0) n = c.length;\n\t\t\tboolean a[] = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = c[i] == t;\n\t\t\treturn a;\n\t\t}\n\t\tboolean[][] nb(int n, int m, char t) {\n\t\t\tboolean a[][] = new boolean[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nb(m, t);\n\t\t\treturn a;\n\t\t}\n\t\tint ni() { return Math.toIntExact(sc.nextLong()); }\n\t\tint[] ni(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = ni();\n\t\t\treturn a;\n\t\t}\n\t\tint[][] ni(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = ni(m);\n\t\t\treturn a;\n\t\t}\n\t\tlong nl() { return sc.nextLong(); }\n\t\tlong[] nl(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nl();\n\t\t\treturn a;\n\t\t}\n\t\tlong[][] nl(int n, int m) {\n\t\t\tlong a[][] = new long[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nl(m);\n\t\t\treturn a;\n\t\t}\n\t\tdouble nd() { return Double.parseDouble(sc.next()); }\n\t\tdouble[] nd(int n) {\n\t\t\tdouble a[] = new double[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nd();\n\t\t\treturn a;\n\t\t}\n\t\tdouble[][] nd(int n, int m) {\n\t\t\tdouble a[][] = new double[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = nd(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairII npii() { return new PairII(ni(), ni()); }\n\t\tPairII[] npii(int n) {\n\t\t\tPairII a[] = new PairII[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npii();\n\t\t\treturn a;\n\t\t}\n\t\tPairII[][] npii(int n, int m) {\n\t\t\tPairII a[][] = new PairII[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npii(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairIL npil() { return new PairIL(ni(), nl()); }\n\t\tPairIL[] npil(int n) {\n\t\t\tPairIL a[] = new PairIL[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npil();\n\t\t\treturn a;\n\t\t}\n\t\tPairIL[][] npil(int n, int m) {\n\t\t\tPairIL a[][] = new PairIL[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npil(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairID npid() { return new PairID(ni(), nd()); }\n\t\tPairID[] npid(int n) {\n\t\t\tPairID a[] = new PairID[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npid();\n\t\t\treturn a;\n\t\t}\n\t\tPairID[][] npid(int n, int m) {\n\t\t\tPairID a[][] = new PairID[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npid(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairLI npli() { return new PairLI(nl(), ni()); }\n\t\tPairLI[] npli(int n) {\n\t\t\tPairLI a[] = new PairLI[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npli();\n\t\t\treturn a;\n\t\t}\n\t\tPairLI[][] npli(int n, int m) {\n\t\t\tPairLI a[][] = new PairLI[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npli(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairLL npll() { return new PairLL(nl(), nl()); }\n\t\tPairLL[] npll(int n) {\n\t\t\tPairLL a[] = new PairLL[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npll();\n\t\t\treturn a;\n\t\t}\n\t\tPairLL[][] npll(int n, int m) {\n\t\t\tPairLL a[][] = new PairLL[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npll(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairLD npld() { return new PairLD(nl(), nd()); }\n\t\tPairLD[] npld(int n) {\n\t\t\tPairLD a[] = new PairLD[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npld();\n\t\t\treturn a;\n\t\t}\n\t\tPairLD[][] npld(int n, int m) {\n\t\t\tPairLD a[][] = new PairLD[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npld(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairDI npdi() { return new PairDI(nd(), ni()); }\n\t\tPairDI[] npdi(int n) {\n\t\t\tPairDI a[] = new PairDI[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdi();\n\t\t\treturn a;\n\t\t}\n\t\tPairDI[][] npdi(int n, int m) {\n\t\t\tPairDI a[][] = new PairDI[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdi(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairDL npdl() { return new PairDL(nd(), nl()); }\n\t\tPairDL[] npdl(int n) {\n\t\t\tPairDL a[] = new PairDL[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdl();\n\t\t\treturn a;\n\t\t}\n\t\tPairDL[][] npdl(int n, int m) {\n\t\t\tPairDL a[][] = new PairDL[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdl(m);\n\t\t\treturn a;\n\t\t}\n\t\tPairDD npdd() { return new PairDD(nd(), nd()); }\n\t\tPairDD[] npdd(int n) {\n\t\t\tPairDD a[] = new PairDD[n];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdd();\n\t\t\treturn a;\n\t\t}\n\t\tPairDD[][] npdd(int n, int m) {\n\t\t\tPairDD a[][] = new PairDD[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = npdd(m);\n\t\t\treturn a;\n\t\t}\n\n\t\tString booleanToString(boolean b) { return b ? \"#\" : \".\"; }\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tPrintWriter err = new PrintWriter(System.err);\n\t\tStringBuilder sb4prtln = new StringBuilder();\n\t\tvoid prt() { out.print(\"\"); }\n\t\t<T> void prt(T a) { out.print(a); }\n\t\tvoid prtln() { out.println(\"\"); }\n\t\t<T> void prtln(T a) { out.println(a); }\n\t\tvoid prtln(int... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(int element : a) sb4prtln.append(element+\" \");\n\t\t\tprtln(sb4prtln.toString().trim());\n\t\t}\n\t\tvoid prtln(long... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(long element : a) sb4prtln.append(element+\" \");\n\t\t\tprtln(sb4prtln.toString().trim());\n\t\t}\n\t\tvoid prtln(double... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(double element : a) sb4prtln.append(element+\" \");\n\t\t\tprtln(sb4prtln.toString().trim());\n\t\t}\n\t\tvoid prtln(String... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(String element : a) sb4prtln.append(element+\" \");\n\t\t\tprtln(sb4prtln.toString().trim());\n\t\t}\n\t\tvoid prtln(char... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(char element : a) sb4prtln.append(element);\n\t\t\tprtln(sb4prtln.toString());\n\t\t}\n\t\tvoid prtln(boolean... a) {\n\t\t\tsb4prtln.setLength(0);\n\t\t\tfor(boolean element : a) sb4prtln.append(booleanToString(element));\n\t\t\tprtln(sb4prtln.toString());\n\t\t}\n\t\tvoid prtln(int[][] a) { for(int[] element : a) prtln(element); }\n\t\tvoid prtln(long[][] a) { for(long[] element : a) prtln(element); }\n\t\tvoid prtln(double[][] a) { for(double[] element : a) prtln(element); }\n\t\tvoid prtln(String[][] a) { for(String[] element : a) prtln(element); }\n\t\tvoid prtln(char[][] a) { for(char[] element : a) prtln(element); }\n\t\tvoid prtln(boolean[][] a) { for(boolean[] element : a) prtln(element); }\n\n\t\tString errconvert(int a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tString errconvert(long a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tvoid errprt(int a) { if(DEBUG) err.print(errconvert(a)); }\n\t\tvoid errprt(long a) { if(DEBUG) err.print(errconvert(a)); }\n\t\tvoid errprt() { if(DEBUG) err.print(\"\"); }\n\t\t<T> void errprt(T a) { if(DEBUG) err.print(a); }\n\t\tvoid errprt(boolean a) { if(DEBUG) errprt(booleanToString(a)); }\n\t\tvoid errprtln() { if(DEBUG) err.println(\"\"); }\n\t\tvoid errprtln(int a) { if(DEBUG) err.println(errconvert(a)); }\n\t\tvoid errprtln(long a) { if(DEBUG) err.println(errconvert(a)); }\n\t\t<T> void errprtln(T a) { if(DEBUG) err.println(a); }\n\t\tvoid errprtln(boolean a) { if(DEBUG) errprtln(booleanToString(a)); }\n\t\tvoid errprtln(int... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(int element : a) sb4prtln.append(errconvert(element)+\" \");\n\t\t\t\terrprtln(sb4prtln.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(long... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(long element : a) sb4prtln.append(errconvert(element)+\" \");\n\t\t\t\terrprtln(sb4prtln.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(double... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(double element : a) sb4prtln.append(element+\" \");\n\t\t\t\terrprtln(sb4prtln.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(String... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(String element : a) sb4prtln.append(element+\" \");\n\t\t\t\terrprtln(sb4prtln.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(char... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(char element : a) sb4prtln.append(element);\n\t\t\t\terrprtln(sb4prtln.toString());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(boolean... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tsb4prtln.setLength(0);\n\t\t\t\tfor(boolean element : a) sb4prtln.append(booleanToString(element));\n\t\t\t\terrprtln(sb4prtln.toString());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(Object[] a) { if(DEBUG) for(Object element : a) errprtln(element); }\n\t\tvoid errprtln(int[][] a) { if(DEBUG) for(int[] element : a) errprtln(element); }\n\t\tvoid errprtln(long[][] a) { if(DEBUG) for(long[] element : a) errprtln(element); }\n\t\tvoid errprtln(double[][] a) { if(DEBUG) for(double[] element : a) errprtln(element); }\n\t\tvoid errprtln(String[][] a) { if(DEBUG) for(String[] element : a) errprtln(element); }\n\t\tvoid errprtln(char[][] a) { if(DEBUG) for(char[] element : a) errprtln(element); }\n\t\tvoid errprtln(boolean[][] a) { if(DEBUG) for(boolean[] element : a) errprtln(element); }\n\t\tvoid errprtln(Object[][] a) { if(DEBUG) for(Object element : a) { errprtln(element); errprtln(); } }\n\n\t\tvoid reply(boolean b) { prtln(b ? \"Yes\" : \"No\"); }\n\t\tvoid REPLY(boolean b) { prtln(b ? \"YES\" : \"NO\"); }\n\n\t\tvoid flush() { out.flush(); if(DEBUG) err.flush(); }\n\t\tvoid assertion(boolean b) { if(!b) { flush(); throw new AssertionError(); } }\n\n\t\tvoid exit() { flush(); System.exit(0); }\n\t\t<T> void exit(T a) { prtln(a); exit(); }\n\t\tvoid exit(int... a) { prtln(a); exit(); }\n\t\tvoid exit(long... a) { prtln(a); exit(); }\n\t\tvoid exit(double... a) { prtln(a); exit(); }\n\t\tvoid exit(String... a) { prtln(a); exit(); }\n\t\tvoid exit(char... a) { prtln(a); exit(); }\n\t\tvoid exit(boolean... a) { prtln(a); exit(); }\n\t\tvoid exit(int[][] a) { prtln(a); exit(); }\n\t\tvoid exit(long[][] a) { prtln(a); exit(); }\n\t\tvoid exit(double[][] a) { prtln(a); exit(); }\n\t\tvoid exit(String[][] a) { prtln(a); exit(); }\n\t\tvoid exit(char[][] a) { prtln(a); exit(); }\n\t\tvoid exit(boolean[][] a) { prtln(a); exit(); }\n\n\n\t\tfinal long INF = (long)1e18 + 7;\n\t\tboolean isPlusINF(long a) { return a > INF / 10; }\n\t\tboolean isMinusINF(long a) { return isPlusINF(- a); }\n\t\tboolean isINF(long a) { return isPlusINF(a) || isMinusINF(a); }\n\t\tfinal int I_INF = (int)1e9 + 7;\n\t\tboolean isPlusINF(int a) { return a > I_INF / 10; }\n\t\tboolean isMinusINF(int a) { return isPlusINF(- a); }\n\t\tboolean isINF(int a) { return isPlusINF(a) || isMinusINF(a); }\n\n\n\t\tint min(int a, int b) { return Math.min(a, b); }\n\t\tlong min(long a, long b) { return Math.min(a, b); }\n\t\tdouble min(double a, double b) { return Math.min(a, b); }\n\t\t<T extends Comparable<T>> T min(T a, T b) { return a.compareTo(b) <= 0 ? a : b; }\n\t\tint min(int... x) {\n\t\t\tint min = x[0];\n\t\t\tfor(int val : x) min = min(min, val);\n\t\t\treturn min;\n\t\t}\n\t\tlong min(long... x) {\n\t\t\tlong min = x[0];\n\t\t\tfor(long val : x) min = min(min, val);\n\t\t\treturn min;\n\t\t}\n\t\tdouble min(double... x) {\n\t\t\tdouble min = x[0];\n\t\t\tfor(double val : x) min = min(min, val);\n\t\t\treturn min;\n\t\t}\n\t\tint max(int a, int b) { return Math.max(a, b); }\n\t\tlong max(long a, long b) { return Math.max(a, b); }\n\t\tdouble max(double a, double b) { return Math.max(a, b); }\n\t\t<T extends Comparable<T>> T max(T a, T b) { return a.compareTo(b) >= 0 ? a : b; }\n\t\tint max(int... x) {\n\t\t\tint max = x[0];\n\t\t\tfor(int val : x) max = max(max, val);\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long... x) {\n\t\t\tlong max = x[0];\n\t\t\tfor(long val : x) max = max(max, val);\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double... x) {\n\t\t\tdouble max = x[0];\n\t\t\tfor(double val : x) max = max(max, val);\n\t\t\treturn max;\n\t\t}\n\t\t<T extends Comparable<T>> T max(T[] x) {\n\t\t\tT max = x[0];\n\t\t\tfor(T val : x) max = max(max, val);\n\t\t\treturn max;\n\t\t}\n\t\tint max(int[][] a) {\n\t\t\tint max = a[0][0];\n\t\t\tfor(int[] ele : a) max = max(max, max(ele));\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long[][] a) {\n\t\t\tlong max = a[0][0];\n\t\t\tfor(long[] ele : a) max = max(max, max(ele));\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double[][] a) {\n\t\t\tdouble max = a[0][0];\n\t\t\tfor(double[] ele : a) max = max(max, max(ele));\n\t\t\treturn max;\n\t\t}\n\t\t<T extends Comparable<T>> T max(T[][] a) {\n\t\t\tT max = a[0][0];\n\t\t\tfor(T[] ele : a) max = max(max, max(ele));\n\t\t\treturn max;\n\t\t}\n\t\tlong sum(int... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(int element : a) sum += element;\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(long... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(long element : a) sum += element;\n\t\t\treturn sum;\n\t\t}\n\t\tdouble sum(double... a) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(double element : a) sum += element;\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(boolean... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(boolean element : a) sum += element ? 1 : 0;\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(int[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) sum[i + 1] = sum[i] + a[i];\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(long[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) sum[i + 1] = sum[i] + a[i];\n\t\t\treturn sum;\n\t\t}\n\t\tdouble[] sums(double[] a) {\n\t\t\tdouble sum[] = new double[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) sum[i + 1] = sum[i] + a[i];\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(boolean[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) sum[i + 1] = sum[i] + (a[i] ? 1 : 0);\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(int[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(long[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tdouble[][] sums(double[][] a) {\n\t\t\tdouble sum[][] = new double[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(boolean[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + (a[i][j] ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tint constrain(int x, int l, int r) { return min(max(x, min(l, r)), max(l, r)); }\n\t\tlong constrain(long x, long l, long r) { return min(max(x, min(l, r)), max(l, r)); }\n\t\tdouble constrain(double x, double l, double r) { return min(max(x, min(l, r)), max(l, r)); }\n\t\tint abs(int x) { return x >= 0 ? x : - x; }\n\t\tlong abs(long x) { return x >= 0 ? x : - x; }\n\t\tdouble abs(double x) { return x >= 0 ? x : - x; }\n\t\tint signum(int x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tint signum(long x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tint signum(double x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tlong round(double x) { return Math.round(x); }\n\t\tlong floor(double x) { return (long)Math.floor(x); }\n\t\tint divfloor(int a, int b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }\n\t\tlong divfloor(long a, long b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }\n\t\tlong ceil(double x) { return (long)Math.ceil(x); }\n\t\tint divceil(int a, int b) { return a >= 0 && b > 0 ? (a + b - 1) / b\n\t\t\t\t\t\t\t\t\t\t\t: a < 0 && b < 0 ? divceil(abs(a), abs(b))\n\t\t\t\t\t\t\t\t\t\t\t: - divfloor(abs(a), abs(b)); }\n\t\tlong divceil(long a, long b) { return a >= 0 && b > 0 ? (a + b - 1) / b\n\t\t\t\t\t\t\t\t\t\t\t: a < 0 && b < 0 ? divceil(abs(a), abs(b))\n\t\t\t\t\t\t\t\t\t\t\t: - divfloor(abs(a), abs(b)); }\n\t\tdouble sqrt(int x) { return Math.sqrt((double)x); }\n\t\tdouble sqrt(long x) { return Math.sqrt((double)x); }\n\t\tdouble sqrt(double x) { return Math.sqrt(x); }\n\t\tlong fact(int n) {\n\t\t\tlong ans = 1;\n\t\t\tfor(int i = 1; i <= n; i ++) ans = Math.multiplyExact(ans, i);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble pow(double x, double y) { return Math.pow(x, y); }\n\t\tlong pow(long x, long y) {\n\t\t\tlong ans = 1;\n\t\t\twhile(true) {\n\t\t\t\tif(y % 2 != 0) ans = Math.multiplyExact(ans, x);\n\t\t\t\ty /= 2;\n\t\t\t\tif(y <= 0) return ans;\n\t\t\t\tx = Math.multiplyExact(x, x);\n\t\t\t}\n\t\t}\n\t\tint gcd(int a, int b) {\n\t\t\twhile(true) {\n\t\t\t\tif(b == 0) return a;\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp % b;\n\t\t\t}\n\t\t}\n\t\tlong gcd(long a, long b) {\n\t\t\twhile(true) {\n\t\t\t\tif(b == 0) return a;\n\t\t\t\tlong tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp % b;\n\t\t\t}\n\t\t}\n\t\tlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\t\tint gcd(int... a) {\n\t\t\tint gcd = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) gcd = gcd(gcd, a[i]);\n\t\t\treturn gcd;\n\t\t}\n\t\tlong gcd(long... a) {\n\t\t\tlong gcd = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) gcd = gcd(gcd, a[i]);\n\t\t\treturn gcd;\n\t\t}\n\t\tdouble random() { return Math.random(); }\n\t\tint random(int max) { return (int)floor(random() * max); }\n\t\tlong random(long max) { return floor(random() * max); }\n\t\tdouble random(double max) { return random() * max; }\n\t\tint random(int min, int max) { return random(max - min) + min; }\n\t\tlong random(long min, long max) { return random(max - min) + min; }\n\t\tdouble random(double min, double max) { return random(max - min) + min; }\n\n\t\tboolean isUpper(char a) { return a >= 'A' && a <= 'Z'; }\n\t\tboolean isLower(char a) { return a >= 'a' && a <= 'z'; }\n\t\tint upperToInt(char a) { return a - 'A'; }\n\t\tint lowerToInt(char a) { return a - 'a'; }\n\t\tint numToInt(char a) { return a - '0'; }\n\t\tint charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }\n\t\tchar intToUpper(int a) { return (char)(a + 'A'); }\n\t\tchar intToLower(int a) { return (char)(a + 'a'); }\n\t\tchar intToNum(int a) { return (char)(a + '0'); }\n\t\tint[] charToInt(char[] a) {\n\t\t\tint array[] = new int[a.length];\n\t\t\tfor(int i = 0; i < a.length; i ++) array[i] = charToInt(a[i]);\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[] div(long a) {\n\t\t\tList<Long> divList = new ArrayList<>();\n\t\t\tfor(long i = 1; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tdivList.add(i);\n\t\t\t\t\tif(i * i != a) divList.add(a / i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong div[] = new long[divList.size()];\n\t\t\tfor(int i = 0; i < divList.size(); i ++) div[i] = divList.get(i);\n\t\t\tArrays.sort(div);\n\t\t\treturn div;\n\t\t}\n\n\t\tPairLL[] factor(long a) {\n\t\t\tList<PairLL> factorList = new ArrayList<>();\n\t\t\tfor(long i = 2; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tlong cnt = 0;\n\t\t\t\t\twhile(a % i == 0) { a /= i; cnt ++; }\n\t\t\t\t\tfactorList.add(new PairLL(i, cnt));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a > 1) factorList.add(new PairLL(a, 1));\n\t\t\tPairLL factor[] = new PairLL[factorList.size()];\n\t\t\tfor(int i = 0; i < factorList.size(); i ++) factor[i] = factorList.get(i);\n\t\t\tArrays.sort(factor);\n\t\t\treturn factor;\n\t\t}\n\n\t\tboolean isPrime(long x) {\n\t\t\tboolean ok = x > 1;\n\t\t\tfor(long i = 2; i * i <= x; i ++) {\n\t\t\t\tok &= x % i != 0;\n\t\t\t\tif(!ok) return ok;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\tboolean[] prime(int num) {\n\t\t\tboolean prime[] = new boolean[num];\n\t\t\tfill(prime, true);\n\t\t\tif(num > 0) prime[0] = false;\n\t\t\tif(num > 1) prime[1] = false;\n\t\t\tfor(int i = 2; i < num; i ++) if(prime[i]) for(int j = 2; i * j < num; j ++) prime[i * j] = false;\n\t\t\treturn prime;\n\t\t}\n\n\t\tlong[][] countElements(long[] a, boolean sort) {\n\t\t\tint len = a.length;\n\t\t\tlong array[] = new long[len];\n\t\t\tfor(int i = 0; i < len; i ++) array[i] = a[i];\n\t\t\tif(sort) Arrays.sort(array);\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add(array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else tmp ++;\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\t\tlong[][] countElements(String str, boolean sort) {\n\t\t\tint len = str.length();\n\t\t\tchar array[] = str.toCharArray();\n\t\t\tif(sort) Arrays.sort(array);\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add((long)array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else tmp ++;\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\n\t\tint[] baseConvert(long x, int n, int len) {\n\t\t\tint digit[] = new int[len];\n\t\t\tint i = 0;\n\t\t\tlong tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tint[] baseConvert(long x, int n) {\n\t\t\tlong tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\t\tint[] baseConvert(int x, int n, int len) {\n\t\t\tint digit[] = new int[len];\n\t\t\tint i = 0;\n\t\t\tint tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tint[] baseConvert(int x, int n) {\n\t\t\tint tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\t\tlong[] baseConvert(long x, long n, int len) {\n\t\t\tlong digit[] = new long[len];\n\t\t\tint i = 0;\n\t\t\tlong tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = tmp % n; tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tlong[] baseConvert(long x, long n) {\n\t\t\tlong tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\n\t\tint numDigits(long a) { return Long.toString(a).length(); }\n\t\tlong bitFlag(int a) { return 1L << (long)a; }\n\t\tboolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }\n\n\t\tlong countString(String str, String a) { return (str.length() - str.replace(a, \"\").length()) / a.length(); }\n\t\tlong countStringAll(String str, String a) { return str.length() - str.replaceAll(a, \"\").length(); }\n\n\n\t\tString reverse(String str) { return (new StringBuilder(str)).reverse().toString(); }\n\t\tvoid reverse(String[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid reverse(int[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid reverse(long[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid reverse(double[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid reverse(char[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid reverse(boolean[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\t<T> void reverse(T[] array) { for(int i = 0; i < array.length / 2; i ++) swap(array, i, array.length - i - 1); }\n\t\tvoid fill(int[] array, int x) { Arrays.fill(array, x); }\n\t\tvoid fill(long[] array, long x) { Arrays.fill(array, x); }\n\t\tvoid fill(double[] array, double x) { Arrays.fill(array, x); }\n\t\tvoid fill(char[] array, char x) { Arrays.fill(array, x); }\n\t\tvoid fill(boolean[] array, boolean x) { Arrays.fill(array, x); }\n\t\tvoid fill(int[][] array, int x) { for(int[] a : array) fill(a, x); }\n\t\tvoid fill(long[][] array, long x) { for(long[] a : array) fill(a, x); }\n\t\tvoid fill(double[][] array, double x) { for(double[] a : array) fill(a, x); }\n\t\tvoid fill(char[][] array, char x) { for(char[] a : array) fill(a, x); }\n\t\tvoid fill(boolean[][] array, boolean x) { for(boolean[] a : array) fill(a, x); }\n\t\tvoid fill(int[][][] array, int x) { for(int[][] a : array) fill(a, x); }\n\t\tvoid fill(long[][][] array, long x) { for(long[][] a : array) fill(a, x); }\n\t\tvoid fill(double[][][] array, double x) { for(double[][] a : array) fill(a, x); }\n\t\tvoid fill(char[][][] array, char x) { for(char[][] a : array) fill(a, x); }\n\t\tvoid fill(boolean[][][] array, boolean x) { for(boolean[][] a : array) fill(a, x); }\n\n\t\tint[] resize(int[] array, int m, int x) {\n\t\t\tint resized[] = new int[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\t\tlong[] resize(long[] array, int m, int x) {\n\t\t\tlong resized[] = new long[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\t\tdouble[] resize(double[] array, int m, int x) {\n\t\t\tdouble resized[] = new double[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\t\tchar[] resize(char[] array, int m, int x) {\n\t\t\tchar resized[] = new char[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\t\tboolean[] resize(boolean[] array, int m, int x) {\n\t\t\tboolean resized[] = new boolean[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\t\tObject[] resize(Object[] array, int m, int x) {\n\t\t\tObject resized[] = new Object[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) resized[i + x] = array[i];\n\t\t\treturn resized;\n\t\t}\n\n\t\tvoid shuffleArray(int[] array){\n\t\t\tfor(int i = 0; i < array.length; i ++){\n\t\t\t\tint tmp = array[i];\n\t\t\t\tint randomPos = random(i, array.length);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\t\tvoid shuffleArray(long[] array){\n\t\t\tfor(int i = 0; i < array.length; i ++){\n\t\t\t\tlong tmp = array[i];\n\t\t\t\tint randomPos = random(i, array.length);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\t\tvoid shuffleArray(double[] array){\n\t\t\tfor(int i = 0; i < array.length; i ++){\n\t\t\t\tdouble tmp = array[i];\n\t\t\t\tint randomPos = random(i, array.length);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\t\tint[] randomi(int num, int max){\n\t\t\tint array[] = new int[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(max);\n\t\t\treturn array;\n\t\t}\n\t\tlong[] randoml(int num, long max){\n\t\t\tlong array[] = new long[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(max);\n\t\t\treturn array;\n\t\t}\n\t\tdouble[] randomd(int num, double max){\n\t\t\tdouble array[] = new double[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(max);\n\t\t\treturn array;\n\t\t}\n\t\tint[] randomi(int num, int min, int max){\n\t\t\tint array[] = new int[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(min, max);\n\t\t\treturn array;\n\t\t}\n\t\tlong[] randoml(int num, long min, long max){\n\t\t\tlong array[] = new long[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(min, max);\n\t\t\treturn array;\n\t\t}\n\t\tdouble[] randomd(int num, double min, double max){\n\t\t\tdouble array[] = new double[num];\n\t\t\tfor(int i = 0; i < num; i ++) array[i] = random(min, max);\n\t\t\treturn array;\n\t\t}\n\n\t\tvoid swap(String[] array, int i, int j) {\n\t\t\tString tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(int[] array, int i, int j) {\n\t\t\tint tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(long[] array, int i, int j) {\n\t\t\tlong tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(double[] array, int i, int j) {\n\t\t\tdouble tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(char[] array, int i, int j) {\n\t\t\tchar tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(boolean[] array, int i, int j) {\n\t\t\tboolean tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\t<T> void swap(T[] array, int i, int j) {\n\t\t\tT tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\n\t\tint[] compress(int[] a) {\n\t\t\tint num = a.length;\n\t\t\tSet<Integer> ss = new TreeSet<>();\n\t\t\tfor(int i = 0; i < num; i ++) ss.add(a[i]);\n\t\t\tint compressed[] = new int[ss.size()];\n\t\t\tint j = 0;\n\t\t\tfor(Integer x : ss) compressed[j ++] = x;\n\t\t\tfor(int i = 0; i < num; i ++) a[i] = lowerBound(compressed, a[i]);\n\t\t\treturn compressed;\n\t\t}\n\t\tlong[] compress(long[] a) {\n\t\t\tint num = a.length;\n\t\t\tSet<Long> ss = new TreeSet<>();\n\t\t\tfor(int i = 0; i < num; i ++) ss.add(a[i]);\n\t\t\tlong compressed[] = new long[ss.size()];\n\t\t\tint j = 0;\n\t\t\tfor(Long x : ss) compressed[j ++] = x;\n\t\t\tfor(int i = 0; i < num; i ++) a[i] = lowerBound(compressed, a[i]);\n\t\t\treturn compressed;\n\t\t}\n\t\tdouble[] compress(double[] a) {\n\t\t\tint num = a.length;\n\t\t\tSet<Double> ss = new TreeSet<>();\n\t\t\tfor(int i = 0; i < num; i ++) ss.add(a[i]);\n\t\t\tdouble compressed[] = new double[ss.size()];\n\t\t\tint j = 0;\n\t\t\tfor(Double x : ss) compressed[j ++] = x;\n\t\t\tfor(int i = 0; i < num; i ++) a[i] = lowerBound(compressed, a[i]);\n\t\t\treturn compressed;\n\t\t}\n\n\n\t\tint lowerBound(int[] array, int key) {\n\t\t\treturn BS(array, key, true, true, true);\n\t\t}\n\t\tint lowerBound(int[] array, int key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok);\n\t\t}\n\t\tint upperBound(int[] array, int key) {\n\t\t\treturn BS(array, key, true, true, false);\n\t\t}\n\t\tint upperBound(int[] array, int key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok);\n\t\t}\n\t\tint cntBS(int[] array, int key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true);\n\t\t}\n\t\tint cntBS(int[] array, int key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok);\n\t\t}\n\t\tint BS(int[] array, int key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false);\n\t\t}\n\t\tint BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok);\n\t\t}\n\t\tint BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, boolean count) {\n\t\t\tint ng = ascending ^ greater ? array.length : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.length;\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok);\n\t\t}\n\t\tint BS(int[] array, int key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\tint binarySearch(int[] array, int key, boolean greater, boolean equals, int ng, int ok) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\tboolean isOKforBinarySearch(int[] array, int index, int key, boolean greater, boolean equals) {\n\t\t\treturn (array[index] > key && greater) || (array[index] < key && !greater) || (array[index] == key && equals);\n\t\t}\n\t\tint lowerBound(long[] array, long key) {\n\t\t\treturn BS(array, key, true, true, true);\n\t\t}\n\t\tint lowerBound(long[] array, long key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok);\n\t\t}\n\t\tint upperBound(long[] array, long key) {\n\t\t\treturn BS(array, key, true, true, false);\n\t\t}\n\t\tint upperBound(long[] array, long key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok);\n\t\t}\n\t\tint cntBS(long[] array, long key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true);\n\t\t}\n\t\tint cntBS(long[] array, long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok);\n\t\t}\n\t\tint BS(long[] array, long key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false);\n\t\t}\n\t\tint BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok);\n\t\t}\n\t\tint BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, boolean count) {\n\t\t\tint ng = ascending ^ greater ? array.length : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.length;\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok);\n\t\t}\n\t\tint BS(long[] array, long key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\tint binarySearch(long[] array, long key, boolean greater, boolean equals, int ng, int ok) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\tboolean isOKforBinarySearch(long[] array, int index, long key, boolean greater, boolean equals) {\n\t\t\treturn (array[index] > key && greater) || (array[index] < key && !greater) || (array[index] == key && equals);\n\t\t}\n\t\tint lowerBound(double[] array, double key) {\n\t\t\treturn BS(array, key, true, true, true);\n\t\t}\n\t\tint lowerBound(double[] array, double key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok);\n\t\t}\n\t\tint upperBound(double[] array, double key) {\n\t\t\treturn BS(array, key, true, true, false);\n\t\t}\n\t\tint upperBound(double[] array, double key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok);\n\t\t}\n\t\tint cntBS(double[] array, double key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true);\n\t\t}\n\t\tint cntBS(double[] array, double key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok);\n\t\t}\n\t\tint BS(double[] array, double key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false);\n\t\t}\n\t\tint BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok);\n\t\t}\n\t\tint BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, boolean count) {\n\t\t\tint ng = ascending ^ greater ? array.length : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.length;\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok);\n\t\t}\n\t\tint BS(double[] array, double key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\tint binarySearch(double[] array, double key, boolean greater, boolean equals, int ng, int ok) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\tboolean isOKforBinarySearch(double[] array, int index, double key, boolean greater, boolean equals) {\n\t\t\treturn (array[index] > key && greater) || (array[index] < key && !greater) || (array[index] == key && equals);\n\t\t}\n\t\t<T extends Comparable<? super T>> int lowerBound(T[] array, T key) {\n\t\t\treturn BS(array, key, true, true, true);\n\t\t}\n\t\t<T extends Comparable<? super T>> int lowerBound(T[] array, T key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int upperBound(T[] array, T key) {\n\t\t\treturn BS(array, key, true, true, false);\n\t\t}\n\t\t<T extends Comparable<? super T>> int upperBound(T[] array, T key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true);\n\t\t}\n\t\t<T extends Comparable<? super T>> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count) {\n\t\t\tint ng = ascending ^ greater ? array.length : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.length;\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\t<T extends Comparable<? super T>> int binarySearch(T[] array, T key, boolean greater, boolean equals, int ng, int ok) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\t<T extends Comparable<? super T>> boolean isOKforBinarySearch(T[] array, int index, T key, boolean greater, boolean equals) {\n\t\t\tint compare = array[index].compareTo(key);\n\t\t\treturn (compare > 0 && greater) || (compare < 0 && !greater) || (compare == 0 && equals);\n\t\t}\n\t\t<T> int lowerBound(T[] array, T key, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, true, c);\n\t\t}\n\t\t<T> int lowerBound(T[] array, T key, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok, c);\n\t\t}\n\t\t<T> int upperBound(T[] array, T key, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, false, c);\n\t\t}\n\t\t<T> int upperBound(T[] array, T key, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok, c);\n\t\t}\n\t\t<T> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, c);\n\t\t}\n\t\t<T> int cntBS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok, c);\n\t\t}\n\t\t<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, c);\n\t\t}\n\t\t<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok, c);\n\t\t}\n\t\t<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count, Comparator<? super T> c) {\n\t\t\tint ng = ascending ^ greater ? array.length : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.length;\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok, c);\n\t\t}\n\t\t<T> int BS(T[] array, T key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok, Comparator<? super T> c) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok, c);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\t<T> int binarySearch(T[] array, T key, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals, c)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\t<T> boolean isOKforBinarySearch(T[] array, int index, T key, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\tint compare = c.compare(array[index], key);\n\t\t\treturn (compare > 0 && greater) || (compare < 0 && !greater) || (compare == 0 && equals);\n\t\t}\n\t\t<T extends Comparable<? super T>> int lowerBound(List<T> array, T key) {\n\t\t\treturn BS(array, key, true, true, true);\n\t\t}\n\t\t<T extends Comparable<? super T>> int lowerBound(List<T> array, T key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int upperBound(List<T> array, T key) {\n\t\t\treturn BS(array, key, true, true, false);\n\t\t}\n\t\t<T extends Comparable<? super T>> int upperBound(List<T> array, T key, int ng, int ok) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int cntBS(List<T> array, T key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true);\n\t\t}\n\t\t<T extends Comparable<? super T>> int cntBS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, boolean count) {\n\t\t\tint ng = ascending ^ greater ? array.size() : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.size();\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok);\n\t\t}\n\t\t<T extends Comparable<? super T>> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\t<T extends Comparable<? super T>> int binarySearch(List<T> array, T key, boolean greater, boolean equals, int ng, int ok) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\t<T extends Comparable<? super T>> boolean isOKforBinarySearch(List<T> array, int index, T key, boolean greater, boolean equals) {\n\t\t\tint compare = array.get(index).compareTo(key);\n\t\t\treturn (compare > 0 && greater) || (compare < 0 && !greater) || (compare == 0 && equals);\n\t\t}\n\t\t<T> int lowerBound(List<T> array, T key, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, true, c);\n\t\t}\n\t\t<T> int lowerBound(List<T> array, T key, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, true, ng, ok, c);\n\t\t}\n\t\t<T> int upperBound(List<T> array, T key, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, false, c);\n\t\t}\n\t\t<T> int upperBound(List<T> array, T key, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, true, true, false, ng, ok, c);\n\t\t}\n\t\t<T> int cntBS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, c);\n\t\t}\n\t\t<T> int cntBS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, true, ng, ok, c);\n\t\t}\n\t\t<T> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, c);\n\t\t}\n\t\t<T> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\treturn BS(array, key, ascending, greater, equals, false, ng, ok, c);\n\t\t}\n\t\t<T> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, boolean count, Comparator<? super T> c) {\n\t\t\tint ng = ascending ^ greater ? array.size() : -1;\n\t\t\tint ok = ascending ^ greater ? -1 : array.size();\n\t\t\treturn BS(array, key, ascending, greater, equals, count, ng, ok, c);\n\t\t}\n\t\t<T> int BS(List<T> array, T key, boolean ascending, boolean greater, boolean equals, boolean count, int ng, int ok, Comparator<? super T> c) {\n\t\t\tint index = binarySearch(array, key, greater, equals, ng, ok, c);\n\t\t\treturn count ? (int)abs(ok - index) : index;\n\t\t}\n\t\t<T> int binarySearch(List<T> array, T key, boolean greater, boolean equals, int ng, int ok, Comparator<? super T> c) {\n\t\t\twhile (abs(ok - ng) > 1) {\n\t\t\t\tint mid = (ok + ng) / 2;\n\t\t\t\tif(isOKforBinarySearch(array, mid, key, greater, equals, c)) ok = mid; else ng = mid;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\t<T> boolean isOKforBinarySearch(List<T> array, int index, T key, boolean greater, boolean equals, Comparator<? super T> c) {\n\t\t\tint compare = c.compare(array.get(index), key);\n\t\t\treturn (compare > 0 && greater) || (compare < 0 && !greater) || (compare == 0 && equals);\n\t\t}\n\n\t\tPairLL binaryRangeSearch(long left, long right, UnaryOperator<Long> op, boolean minimize) {\n\t\t\tlong ok1 = right, ng1 = left;\n\t\t\twhile(abs(ok1 - ng1) > 1) {\n\t\t\t\tlong mid = (ok1 + ng1) / 2;\n\t\t\t\tboolean isOK = (op.apply(mid + 1) - op.apply(mid)) * (minimize ? 1 : -1) >= 0;\n\t\t\t\tif(isOK) ok1 = mid; else ng1 = mid;\n\t\t\t}\n\t\t\tlong ok2 = left, ng2 = right;\n\t\t\twhile(abs(ok2 - ng2) > 1) {\n\t\t\t\tlong mid = (ok2 + ng2) / 2;\n\t\t\t\tboolean isOK = (op.apply(mid - 1) - op.apply(mid)) * (minimize ? 1 : -1) >= 0;\n\t\t\t\tif(isOK) ok2 = mid; else ng2 = mid;\n\t\t\t}\n\t\t\treturn new PairLL(ok1, ok2); //[l, r]\n\t\t}\n\n\t\tdouble ternarySearch(double left, double right, UnaryOperator<Double> op, boolean minimize, int loop) {\n\t\t\tfor(int cnt = 0; cnt < loop; cnt ++) {\n\t\t\t\tdouble m1 = (left * 2 + right) / 3.0;\n\t\t\t\tdouble m2 = (left + right * 2) / 3.0;\n\t\t\t\tif(op.apply(m1) > op.apply(m2) ^ minimize) right = m2; else left = m1;\n\t\t\t}\n\t\t\treturn (left + right) / 2.0;\n\t\t}\n\n\n\t\t// mods\n\t\tfinal long MOD = (long)1e9 + 7; // 998244353;\n\t\tlong mod(long x) { x %= MOD; return x + (x < 0 ? MOD : 0); }\n\t\tvoid mod(long[] a) { for(int i = 0; i < a.length; i ++) a[i] = mod(a[i]); }\n\t\tvoid mod(long[][] a) { for(int i = 0; i < a.length; i ++) mod(a[i]); }\n\t\tvoid mod(long[][][] a) { for(int i = 0; i < a.length; i ++) mod(a[i]); }\n\n\t\tlong pow_m(long x, long y) {\n\t\t\tx = mod(x);\n\t\t\tlong ans = 1;\n\t\t\tfor(; y > 0; y /= 2) {\n\t\t\t\tif(y % 2 != 0) ans = mod(ans * x);\n\t\t\t\tx = mod(x * x);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tlong[] pows_m(long x, int max) {\n\t\t\tlong pow[] = new long[max + 1];\n\t\t\tpow[0] = 1;\n\t\t\tfor(int i = 0; i < max; i ++) pow[i + 1] = mod(pow[i] * x);\n\t\t\treturn pow;\n\t\t}\n\t\tlong fact_m(int n) {\n\t\t\tlong ans = 1;\n\t\t\tfor(int i = 1; i <= n; i ++) ans = mod(ans * i);\n\t\t\treturn ans;\n\t\t}\n\n\t\tfinal int MAX_INV_SIZE = 100_100;\n\t\tMap<Long, Long> invMap = new HashMap<>();\n\t\tlong inv(long x) {\n\t\t\tx = mod(x);\n\t\t\tif(invMap.containsKey(x)) return invMap.get(x);\n\t\t\tif(invMap.size() >= MAX_INV_SIZE) return calInv(x);\n\t\t\tinvMap.put(x, calInv(x));\n\t\t\treturn invMap.get(x);\n\t\t}\n\t\tlong calInv(long x) { return pow_m(x, MOD - 2); }\n\n\t\tfinal int MAX_FACT = 5_000_100;\n\t\tlong fact[];\n\t\tlong invFact[];\n\t\tboolean isFactPrepared = false;\n\t\tMap<Integer, long[]> factMap;\n\t\tvoid prepareFact() {\n\t\t\tfact = new long[MAX_FACT];\n\t\t\tfill(fact, 0);\n\t\t\tinvFact = new long[MAX_FACT];\n\t\t\tfill(invFact, 0);\n\t\t\tfact[0] = 1;\n\t\t\tint maxIndex = min(MAX_FACT, (int)MOD);\n\t\t\tfor(int i = 1; i < maxIndex; i ++) fact[i] = mod(fact[i - 1] * i);\n\t\t\tinvFact[maxIndex - 1] = inv(fact[maxIndex - 1]);\n\t\t\tfor(int i = maxIndex - 1; i > 0; i --) invFact[i - 1] = mod(invFact[i] * i);\n\n\t\t\tfactMap = new HashMap<>();\n\t\t\tisFactPrepared = true;\n\t\t}\n\n\t\tlong P(int n, int r) {\n\t\t\tif(!isFactPrepared) { prepareFact(); }\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\tif(n >= MAX_FACT) {\n\t\t\t\tif(!factMap.containsKey(n)) {\n\t\t\t\t\tlong largeFact[] = new long[MAX_FACT];\n\t\t\t\t\tfactMap.put(n, largeFact);\n\t\t\t\t\tfill(largeFact, -INF);\n\t\t\t\t\tlargeFact[0] = 1;\n\t\t\t\t}\n\t\t\t\tlong largeFact[] = factMap.get(n);\n\t\t\t\tint i = r;\n\t\t\t\twhile(isINF(largeFact[i])) i --;\n\t\t\t\tfor(; i < r; i ++) largeFact[i + 1] = mod(largeFact[i] * (n - i));\n\t\t\t\treturn largeFact[r];\n\t\t\t}\n\t\t\treturn mod(fact[n] * invFact[n - r]);\n\t\t}\n\t\tlong C(int n, int r) {\n\t\t\tif(!isFactPrepared) prepareFact();\n\t\t\tif(n < 0 || r < 0 || n < r) return 0;\n\t\t\treturn mod(P(n, r) * invFact[r]);\n\t\t}\n\t\tlong H(int n, int r) { return C((n - 1) + r, r); }\n\n\n\t\t// grid\n\t\tclass Grids {\n\t\t\tint h;\n\t\t\tint w;\n\t\t\tGrid[][] gs;\n\t\t\tGrid[] gi;\n\t\t\tGrids(int h, int w) {\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t\tgs = new Grid[h][w];\n\t\t\t\tgi = new Grid[h * w];\n\t\t\t\tfor(int i = 0; i < h; i ++) {\n\t\t\t\t\tfor(int j = 0; j < w; j ++) {\n\t\t\t\t\t\tgs[i][j] = new Grid(i, j, h, w);\n\t\t\t\t\t\tgi[gs[i][j].i] = gs[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid init(boolean[][] b) {\n\t\t\t\tfor(int i = 0; i < h; i ++) for(int j = 0; j < w; j ++) gs[i][j].b = b[i][j];\n\t\t\t}\n\t\t\tvoid init(long[][] val) {\n\t\t\t\tfor(int i = 0; i < h; i ++) for(int j = 0; j < w; j ++) gs[i][j].val = val[i][j];\n\t\t\t}\n\n\t\t\tGrid get(int x, int y) { return isValid(x, y, h, w) ? gs[x][y] : null; }\n\t\t\tGrid get(int i) { return get(i / w, i % w); }\n\n\t\t\tint dx[] = {0, -1, 1, 0, 0, -1, 1, -1, 1};\n\t\t\tint dy[] = {0, 0, 0, -1, 1, -1, -1, 1, 1};\n\t\t\tGrid next(int x, int y, int i) { return next(gs[x][y], i); }\n\t\t\tGrid next(Grid g, int i) {\n\t\t\t\treturn isValid(g.x + dx[i], g.y + dy[i], g.h, g.w)\n\t\t\t\t\t? gs[g.x + dx[i]][g.y + dy[i]]\n\t\t\t\t\t: null;\n\t\t\t}\n\t\t}\n\t\tclass Grid implements Comparable<Grid> {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint h;\n\t\t\tint w;\n\t\t\tint i;\n\t\t\tboolean b;\n\t\t\tlong val;\n\n\t\t\tGrid() {  }\n\t\t\tGrid(int x, int y, int h, int w) { init(x, y, h, w, false, 0); }\n\t\t\tGrid(int x, int y, int h, int w, boolean b) { init(x, y, h, w, b, 0); }\n\t\t\tGrid(int x, int y, int h, int w, long val) { init(x, y, h, w, false, val); }\n\t\t\tGrid(int x, int y, int h, int w, boolean b, long val) { init(x, y, h, w, b, val); }\n\n\t\t\tvoid init(int x, int y, int h, int w, boolean b, long val) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.b = b;\n\t\t\t\tthis.val = val;\n\t\t\t\tthis.i = x * w + y;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() { return \"(\"+x+\", \"+y+\")\"+\" \"+booleanToString(b)+\" \"+val; }\n\t\t\t@Override\n\t\t\tpublic int hashCode() { return Objects.hash(x, y, h, w, b, val); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tGrid that = (Grid) obj;\n\t\t\t\tif(this.x != that.x) return false;\n\t\t\t\tif(this.y != that.y) return false;\n\t\t\t\tif(this.h != that.h) return false;\n\t\t\t\tif(this.w != that.w) return false;\n\t\t\t\tif(this.b != that.b) return false;\n\t\t\t\tif(this.val != that.val) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Grid that) {\n\t\t\t\tint c = Long.compare(this.val, that.val);\n\t\t\t\tif(c == 0) c = Integer.compare(this.x, that.x);\n\t\t\t\tif(c == 0) c = Integer.compare(this.y, that.y);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\n\t\tboolean isValid(int x, int y, int h, int w) { return x >= 0 && x < h && y >= 0 && y < w; }\n\t\tboolean isValid(Grid g) { return isValid(g.x, g.y, g.h, g.w); }\n\n\t\t// graph\n\t\tclass Graph {\n\t\t\tint numNode;\n\t\t\tint numEdge;\n\t\t\tboolean directed;\n\t\t\tSet<Edge> edges = new HashSet<>();\n\t\t\tNode nodes[];\n\t\t\tNode reversedNodes[];\n\n\t\t\tGraph(int numNode, int numEdge, boolean directed) {\n\t\t\t\tthis.numNode = numNode;\n\t\t\t\tthis.numEdge = numEdge;\n\t\t\t\tthis.directed = directed;\n\t\t\t\tnodes = new Node[numNode];\n\t\t\t\treversedNodes = new Node[numNode];\n\t\t\t\tfor(int i = 0; i < numNode; i ++) {\n\t\t\t\t\tnodes[i] = new Node(i);\n\t\t\t\t\treversedNodes[i] = new Node(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid init(Set<Edge> edges) {\n\t\t\t\tthis.edges = edges;\n\t\t\t\tfor(Edge e : edges) add(e);\n\t\t\t}\n\n\t\t\tvoid add(Edge e) {\n\t\t\t\tedges.add(e);\n\t\t\t\tnodes[e.source].add(e.target, e.cost);\n\t\t\t\tif(directed) reversedNodes[e.target].add(e.source, e.cost);\n\t\t\t\telse nodes[e.target].add(e.source, e.cost);\n\t\t\t}\n\n\t\t\tvoid remove(Edge e) {\n\t\t\t\tedges.remove(e);\n\t\t\t\tnodes[e.source].remove(e.target, e.cost);\n\t\t\t\tif(directed) reversedNodes[e.target].remove(e.source, e.cost);\n\t\t\t\telse nodes[e.target].remove(e.source, e.cost);\n\t\t\t}\n\n\t\t\tvoid update(Edge e, long cost) {\n\t\t\t\tnodes[e.source].update(e.target, cost);\n\t\t\t\tif(directed) reversedNodes[e.target].update(e.source, cost);\n\t\t\t\telse nodes[e.target].update(e.source, cost);\n\t\t\t\te.cost = cost;\n\t\t\t}\n\t\t\tvoid update(int source, int target, long cost) { update(new Edge(source, target, cost), cost); }\n\n\t\t\tvoid clearNodes() {\n\t\t\t\tfor(Node n : nodes) n.clear();\n\t\t\t\tfor(Node n : reversedNodes) n.clear();\n\t\t\t}\n\t\t}\n\n\t\tclass Node extends HashSet<Edge> {\n\t\t\tint id;\n\n\t\t\tNode(int id) { this.id = id; }\n\t\t\tvoid add(int target, long cost) { add(new Edge(id, target, cost)); }\n\t\t\tvoid remove(int target, long cost) { remove(new Edge(id, target, cost)); }\n\t\t\tvoid update(int target, long cost) { remove(target, cost); add(target, cost); }\n\t\t}\n\n\t\tclass Edge implements Comparable<Edge> {\n\t\t\tint source;\n\t\t\tint target;\n\t\t\tlong cost;\n\t\t\tEdge(int source, int target, long cost) {\n\t\t\t\tthis.source = source;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic String toString() { return source+\" - \"+cost+\" -> \"+target; }\n\t\t\t@Override\n\t\t\tpublic int hashCode() { return Objects.hash(source, target); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tEdge that = (Edge) obj;\n\t\t\t\tif(this.source != that.source) return false;\n\t\t\t\tif(this.target != that.target) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Edge that) {\n\t\t\t\tint c = Long.compare(this.cost, that.cost);\n\t\t\t\tif(c == 0) c = Integer.compare(this.source, that.source);\n\t\t\t\tif(c == 0) c = Integer.compare(this.target, that.target);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\n\t\t// Pair, Tuple\n\t\tclass Pair<T extends Comparable<? super T>, U extends Comparable<? super U>> implements Comparable<Pair<T, U>> {\n\t\t\tT a;\n\t\t\tU b;\n\t\t\tPair() { }\n\t\t\tPair(T a, U b) {\n\t\t\t\tthis.a = a;\n\t\t\t\tthis.b = b;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() { return \"(\"+a.toString()+\", \"+b.toString()+\")\"; }\n\t\t\t@Override\n\t\t\tpublic int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPair that = (Pair) obj;\n\t\t\t\tif(this.a.getClass() != that.a.getClass()) return false;\n\t\t\t\tif(this.b.getClass() != that.b.getClass()) return false;\n\t\t\t\tif(!this.a.equals(that.a)) return false;\n\t\t\t\tif(!this.b.equals(that.b)) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(Pair<T, U> that) {\n\t\t\t\tint c = (this.a).compareTo(that.a);\n\t\t\t\tif(c == 0) c = (this.b).compareTo(that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairII implements Comparable<PairII> {\n\t\t\tint a; int b;\n\t\t\tPairII() { }\n\t\t\tPairII(int a, int b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairII that = (PairII) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairII that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairIL implements Comparable<PairIL> {\n\t\t\tint a; long b;\n\t\t\tPairIL() { }\n\t\t\tPairIL(int a, long b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairIL that = (PairIL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairIL that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairID implements Comparable<PairID> {\n\t\t\tint a; double b;\n\t\t\tPairID() { }\n\t\t\tPairID(int a, double b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairID that = (PairID) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairID that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairLI implements Comparable<PairLI> {\n\t\t\tlong a; int b;\n\t\t\tPairLI() { }\n\t\t\tPairLI(long a, int b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairLI that = (PairLI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairLI that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairLL implements Comparable<PairLL> {\n\t\t\tlong a; long b;\n\t\t\tPairLL() { }\n\t\t\tPairLL(long a, long b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairLL that = (PairLL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairLL that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairLD implements Comparable<PairLD> {\n\t\t\tlong a; double b;\n\t\t\tPairLD() { }\n\t\t\tPairLD(long a, double b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairLD that = (PairLD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairLD that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairDI implements Comparable<PairDI> {\n\t\t\tdouble a; int b;\n\t\t\tPairDI() { }\n\t\t\tPairDI(double a, int b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairDI that = (PairDI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairDI that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairDL implements Comparable<PairDL> {\n\t\t\tdouble a; long b;\n\t\t\tPairDL() { }\n\t\t\tPairDL(double a, long b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairDL that = (PairDL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairDL that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass PairDD implements Comparable<PairDD> {\n\t\t\tdouble a; double b;\n\t\t\tPairDD() { }\n\t\t\tPairDD(double a, double b) { this.a = a; this.b = b; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tPairDD that = (PairDD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(PairDD that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\n\t\tinterface ITuple {\n\t\t\tpublic StringBuilder toStringBuilder();\n\t\t\t@Override\n\t\t\tpublic String toString();\n\t\t\t@Override\n\t\t\tpublic int hashCode();\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj);\n\t\t}\n\t\tclass BasicTuple<T extends ITuple & Comparable<? super T>, V extends Comparable<? super V>> implements Comparable<BasicTuple> {\n\t\t\tT t;\n\t\t\tV a;\n\t\t\tBasicTuple() {  }\n\n\t\t\tStringBuilder sbTuple = new StringBuilder();\n\t\t\tpublic StringBuilder toStringBuilder() {\n\t\t\t\tsbTuple.setLength(0);\n\t\t\t\treturn sbTuple.append(t.toStringBuilder()).append(\", \").append(a);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() { return \"(\"+toStringBuilder().toString()+\")\"; }\n\t\t\t@Override\n\t\t\tpublic int hashCode() { return Objects.hash(t, a); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tBasicTuple that = (BasicTuple) obj;\n\t\t\t\tif(this.t.getClass() != that.t.getClass()) return false;\n\t\t\t\tif(this.a.getClass() != that.a.getClass()) return false;\n\t\t\t\tif(!this.t.equals(that.t)) return false;\n\t\t\t\tif(!this.a.equals(that.a)) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tpublic int compareTo(BasicTuple that) {\n\t\t\t\tint c = (this.t).compareTo((T) (Object) that.t);\n\t\t\t\tif(c == 0) c = (this.a).compareTo((V) (Object) that.a);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass UniqueTuple<V extends Comparable<? super V>> implements ITuple, Comparable<UniqueTuple> {\n\t\t\tV a;\n\t\t\tUniqueTuple() {  }\n\n\t\t\tStringBuilder sbTuple = new StringBuilder();\n\t\t\tpublic StringBuilder toStringBuilder() {\n\t\t\t\tsbTuple.setLength(0);\n\t\t\t\treturn sbTuple.append(a);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() { return \"(\"+toStringBuilder().toString()+\")\"; }\n\t\t\t@Override\n\t\t\tpublic int hashCode() { return Objects.hash(a); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null) return false;\n\t\t\t\tif(this.getClass() != obj.getClass()) return false;\n\t\t\t\tUniqueTuple that = (UniqueTuple) obj;\n\t\t\t\tif(this.a.getClass() != that.a.getClass()) return false;\n\t\t\t\tif(!this.a.equals(that.a)) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tpublic int compareTo(UniqueTuple that) {\n\t\t\t\treturn (this.a).compareTo((V) (Object) that.a);\n\t\t\t}\n\t\t}\n\n\t\tclass Tuple1<T0 extends Comparable<? super T0>> extends UniqueTuple<T0> implements ITuple {\n\t\t\tTuple1() { super(); }\n\t\t\tTuple1(T0 a0) {\n\t\t\t\tsuper();\n\t\t\t\tthis.a = a0;\n\t\t\t}\n\t\t\tT0 get0() { return a; }\n\t\t\tvoid set0(T0 x) { a = x; }\n\t\t}\n\t\tclass Tuple2<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>>\n\t\t\t\textends BasicTuple<Tuple1<T0>, T1> implements ITuple {\n\t\t\tTuple2() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple2(T0 a0, T1 a1) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple1(a0);\n\t\t\t\tthis.a = a1;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { a = x; }\n\t\t}\n\t\tclass Tuple3<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>>\n\t\t\t\textends BasicTuple<Tuple2<T0, T1>, T2> implements ITuple {\n\t\t\tTuple3() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple3(T0 a0, T1 a1, T2 a2) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple2(a0, a1);\n\t\t\t\tthis.a = a2;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { a = x; }\n\t\t}\n\t\tclass Tuple4<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>,\n\t\t\t\tT3 extends Comparable<? super T3>>\n\t\t\t\textends BasicTuple<Tuple3<T0, T1, T2>, T3> implements ITuple {\n\t\t\tTuple4() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple4(T0 a0, T1 a1, T2 a2, T3 a3) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple3(a0, a1, a2);\n\t\t\t\tthis.a = a3;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return t.get2(); }\n\t\t\tT3 get3() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { t.set2(x); }\n\t\t\tvoid set3(T3 x) { a = x; }\n\t\t}\n\t\tclass Tuple5<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>,\n\t\t\t\tT3 extends Comparable<? super T3>,\n\t\t\t\tT4 extends Comparable<? super T4>>\n\t\t\t\textends BasicTuple<Tuple4<T0, T1, T2, T3>, T4> implements ITuple {\n\t\t\tTuple5() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple5(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple4(a0, a1, a2, a3);\n\t\t\t\tthis.a = a4;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return t.get2(); }\n\t\t\tT3 get3() { return t.get3(); }\n\t\t\tT4 get4() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { t.set2(x); }\n\t\t\tvoid set3(T3 x) { t.set3(x); }\n\t\t\tvoid set4(T4 x) { a = x; }\n\t\t}\n\t\tclass Tuple6<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>,\n\t\t\t\tT3 extends Comparable<? super T3>,\n\t\t\t\tT4 extends Comparable<? super T4>,\n\t\t\t\tT5 extends Comparable<? super T5>>\n\t\t\t\textends BasicTuple<Tuple5<T0, T1, T2, T3, T4>, T5> implements ITuple {\n\t\t\tTuple6() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple6(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple5(a0, a1, a2, a3, a4);\n\t\t\t\tthis.a = a5;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return t.get2(); }\n\t\t\tT3 get3() { return t.get3(); }\n\t\t\tT4 get4() { return t.get4(); }\n\t\t\tT5 get5() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { t.set2(x); }\n\t\t\tvoid set3(T3 x) { t.set3(x); }\n\t\t\tvoid set4(T4 x) { t.set4(x); }\n\t\t\tvoid set5(T5 x) { a = x; }\n\t\t}\n\t\tclass Tuple7<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>,\n\t\t\t\tT3 extends Comparable<? super T3>,\n\t\t\t\tT4 extends Comparable<? super T4>,\n\t\t\t\tT5 extends Comparable<? super T5>,\n\t\t\t\tT6 extends Comparable<? super T6>>\n\t\t\t\textends BasicTuple<Tuple6<T0, T1, T2, T3, T4, T5>, T6> implements ITuple {\n\t\t\tTuple7() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple7(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple6(a0, a1, a2, a3, a4, a5);\n\t\t\t\tthis.a = a6;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return t.get2(); }\n\t\t\tT3 get3() { return t.get3(); }\n\t\t\tT4 get4() { return t.get4(); }\n\t\t\tT5 get5() { return t.get5(); }\n\t\t\tT6 get6() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { t.set2(x); }\n\t\t\tvoid set3(T3 x) { t.set3(x); }\n\t\t\tvoid set4(T4 x) { t.set4(x); }\n\t\t\tvoid set5(T5 x) { t.set5(x); }\n\t\t\tvoid set6(T6 x) { a = x; }\n\t\t}\n\t\tclass Tuple8<\n\t\t\t\tT0 extends Comparable<? super T0>,\n\t\t\t\tT1 extends Comparable<? super T1>,\n\t\t\t\tT2 extends Comparable<? super T2>,\n\t\t\t\tT3 extends Comparable<? super T3>,\n\t\t\t\tT4 extends Comparable<? super T4>,\n\t\t\t\tT5 extends Comparable<? super T5>,\n\t\t\t\tT6 extends Comparable<? super T6>,\n\t\t\t\tT7 extends Comparable<? super T7>>\n\t\t\t\textends BasicTuple<Tuple7<T0, T1, T2, T3, T4, T5, T6>, T7> implements ITuple {\n\t\t\tTuple8() { super(); }\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tTuple8(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) {\n\t\t\t\tsuper();\n\t\t\t\tthis.t = new Tuple7(a0, a1, a2, a3, a4, a5, a6);\n\t\t\t\tthis.a = a7;\n\t\t\t}\n\t\t\tT0 get0() { return t.get0(); }\n\t\t\tT1 get1() { return t.get1(); }\n\t\t\tT2 get2() { return t.get2(); }\n\t\t\tT3 get3() { return t.get3(); }\n\t\t\tT4 get4() { return t.get4(); }\n\t\t\tT5 get5() { return t.get5(); }\n\t\t\tT6 get6() { return t.get6(); }\n\t\t\tT7 get7() { return a; }\n\t\t\tvoid set0(T0 x) { t.set0(x); }\n\t\t\tvoid set1(T1 x) { t.set1(x); }\n\t\t\tvoid set2(T2 x) { t.set2(x); }\n\t\t\tvoid set3(T3 x) { t.set3(x); }\n\t\t\tvoid set4(T4 x) { t.set4(x); }\n\t\t\tvoid set5(T5 x) { t.set5(x); }\n\t\t\tvoid set6(T6 x) { t.set6(x); }\n\t\t\tvoid set7(T7 x) { a = x; }\n\t\t}\n\n\t\tclass TupleIII implements Comparable<TupleIII> {\n\t\t\tint a; int b; int c;\n\t\t\tTupleIII() {  }\n\t\t\tTupleIII(int a, int b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIII that = (TupleIII) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIII that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleIIL implements Comparable<TupleIIL> {\n\t\t\tint a; int b; long c;\n\t\t\tTupleIIL() {  }\n\t\t\tTupleIIL(int a, int b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIIL that = (TupleIIL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIIL that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleIID implements Comparable<TupleIID> {\n\t\t\tint a; int b; double c;\n\t\t\tTupleIID() {  }\n\t\t\tTupleIID(int a, int b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIID that = (TupleIID) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIID that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleILI implements Comparable<TupleILI> {\n\t\t\tint a; long b; int c;\n\t\t\tTupleILI() {  }\n\t\t\tTupleILI(int a, long b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleILI that = (TupleILI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleILI that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleILL implements Comparable<TupleILL> {\n\t\t\tint a; long b; long c;\n\t\t\tTupleILL() {  }\n\t\t\tTupleILL(int a, long b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleILL that = (TupleILL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleILL that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleILD implements Comparable<TupleILD> {\n\t\t\tint a; long b; double c;\n\t\t\tTupleILD() {  }\n\t\t\tTupleILD(int a, long b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleILD that = (TupleILD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleILD that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleIDI implements Comparable<TupleIDI> {\n\t\t\tint a; double b; int c;\n\t\t\tTupleIDI() {  }\n\t\t\tTupleIDI(int a, double b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIDI that = (TupleIDI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIDI that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleIDL implements Comparable<TupleIDL> {\n\t\t\tint a; double b; long c;\n\t\t\tTupleIDL() {  }\n\t\t\tTupleIDL(int a, double b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIDL that = (TupleIDL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIDL that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleIDD implements Comparable<TupleIDD> {\n\t\t\tint a; double b; double c;\n\t\t\tTupleIDD() {  }\n\t\t\tTupleIDD(int a, double b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleIDD that = (TupleIDD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleIDD that) {\n\t\t\t\tint c = Integer.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLII implements Comparable<TupleLII> {\n\t\t\tlong a; int b; int c;\n\t\t\tTupleLII() {  }\n\t\t\tTupleLII(long a, int b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLII that = (TupleLII) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLII that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLIL implements Comparable<TupleLIL> {\n\t\t\tlong a; int b; long c;\n\t\t\tTupleLIL() {  }\n\t\t\tTupleLIL(long a, int b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLIL that = (TupleLIL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLIL that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLID implements Comparable<TupleLID> {\n\t\t\tlong a; int b; double c;\n\t\t\tTupleLID() {  }\n\t\t\tTupleLID(long a, int b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLID that = (TupleLID) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLID that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLLI implements Comparable<TupleLLI> {\n\t\t\tlong a; long b; int c;\n\t\t\tTupleLLI() {  }\n\t\t\tTupleLLI(long a, long b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLLI that = (TupleLLI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLLI that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLLL implements Comparable<TupleLLL> {\n\t\t\tlong a; long b; long c;\n\t\t\tTupleLLL() {  }\n\t\t\tTupleLLL(long a, long b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLLL that = (TupleLLL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLLL that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLLD implements Comparable<TupleLLD> {\n\t\t\tlong a; long b; double c;\n\t\t\tTupleLLD() {  }\n\t\t\tTupleLLD(long a, long b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLLD that = (TupleLLD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLLD that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLDI implements Comparable<TupleLDI> {\n\t\t\tlong a; double b; int c;\n\t\t\tTupleLDI() {  }\n\t\t\tTupleLDI(long a, double b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLDI that = (TupleLDI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLDI that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLDL implements Comparable<TupleLDL> {\n\t\t\tlong a; double b; long c;\n\t\t\tTupleLDL() {  }\n\t\t\tTupleLDL(long a, double b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLDL that = (TupleLDL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLDL that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleLDD implements Comparable<TupleLDD> {\n\t\t\tlong a; double b; double c;\n\t\t\tTupleLDD() {  }\n\t\t\tTupleLDD(long a, double b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleLDD that = (TupleLDD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleLDD that) {\n\t\t\t\tint c = Long.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDII implements Comparable<TupleDII> {\n\t\t\tdouble a; int b; int c;\n\t\t\tTupleDII() {  }\n\t\t\tTupleDII(double a, int b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDII that = (TupleDII) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDII that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDIL implements Comparable<TupleDIL> {\n\t\t\tdouble a; int b; long c;\n\t\t\tTupleDIL() {  }\n\t\t\tTupleDIL(double a, int b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDIL that = (TupleDIL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDIL that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDID implements Comparable<TupleDID> {\n\t\t\tdouble a; int b; double c;\n\t\t\tTupleDID() {  }\n\t\t\tTupleDID(double a, int b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDID that = (TupleDID) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDID that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Integer.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDLI implements Comparable<TupleDLI> {\n\t\t\tdouble a; long b; int c;\n\t\t\tTupleDLI() {  }\n\t\t\tTupleDLI(double a, long b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDLI that = (TupleDLI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDLI that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDLL implements Comparable<TupleDLL> {\n\t\t\tdouble a; long b; long c;\n\t\t\tTupleDLL() {  }\n\t\t\tTupleDLL(double a, long b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDLL that = (TupleDLL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDLL that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDLD implements Comparable<TupleDLD> {\n\t\t\tdouble a; long b; double c;\n\t\t\tTupleDLD() {  }\n\t\t\tTupleDLD(double a, long b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDLD that = (TupleDLD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDLD that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Long.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDDI implements Comparable<TupleDDI> {\n\t\t\tdouble a; double b; int c;\n\t\t\tTupleDDI() {  }\n\t\t\tTupleDDI(double a, double b, int c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDDI that = (TupleDDI) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDDI that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Integer.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDDL implements Comparable<TupleDDL> {\n\t\t\tdouble a; double b; long c;\n\t\t\tTupleDDL() {  }\n\t\t\tTupleDDL(double a, double b, long c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDDL that = (TupleDDL) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDDL that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Long.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tclass TupleDDD implements Comparable<TupleDDD> {\n\t\t\tdouble a; double b; double c;\n\t\t\tTupleDDD() {  }\n\t\t\tTupleDDD(double a, double b, double c) { this.a = a; this.b = b; this.c = c; }\n\t\t\t@Override public String toString() { return \"(\"+a+\", \"+b+\", \"+c+\")\"; }\n\t\t\t@Override public int hashCode() { return Objects.hash(a, b, c); }\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif(this == obj) return true;\n\t\t\t\tif(obj == null || this.getClass() != obj.getClass()) return false;\n\t\t\t\tTupleDDD that = (TupleDDD) obj;\n\t\t\t\tif(this.a != that.a || this.b != that.b || this.c != that.c) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int compareTo(TupleDDD that) {\n\t\t\t\tint c = Double.compare(this.a, that.a);\n\t\t\t\tif(c == 0) c = Double.compare(this.b, that.b);\n\t\t\t\tif(c == 0) c = Double.compare(this.c, that.c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\npublic void solve() {\n\tint num = ni();\n\tlong d = nl();\n\tPairLL p[] = npll(num);\n\n\tTwoSat ts = new TwoSat(num);\n\tfor(int i = 0; i < num; i ++) {\n\t\tfor(int j = i + 1; j < num; j ++) {\n\t\t\tif(abs(p[i].a - p[j].a) < d) ts.addNand(i, false, j, false);\n\t\t\tif(abs(p[i].a - p[j].b) < d) ts.addNand(i, false, j, true);\n\t\t\tif(abs(p[i].b - p[j].a) < d) ts.addNand(i, true, j, false);\n\t\t\tif(abs(p[i].b - p[j].b) < d) ts.addNand(i, true, j, true);\n\t\t}\n\t}\n\tboolean exists = ts.satisfiable();\n\treply(exists);\n\tif(exists) for(int i = 0; i < num; i ++) prtln(ts.answer[i] ? p[i].b : p[i].a);\n}\n\nclass TwoSat extends Scc {\n\tboolean answer[];\n\tint num;\n\n\tTwoSat(int num) { super(num * 2, 0, true); this.num = num; init(); } // O(V)\n\tTwoSat(int num, int numEdge) { super(num * 2, numEdge, true); this.num = num; init(); } // O(V)\n\tTwoSat(int num, boolean directed) { super(num * 2, 0, directed); this.num = num; init(); } // O(V)\n\tTwoSat(int num, int numEdge, boolean directed) { super(num * 2, numEdge, directed); this.num = num; init(); }  // O(V)\n\n\tvoid init() { answer = new boolean[num]; super.init(); }\n\tvoid addClause(int i, boolean f, int j, boolean g) { // O(1)\n\t\tadd(new Edge(i * 2 + (f ? 0 : 1), j * 2 + (g ? 1 : 0), 1));\n\t\tadd(new Edge(j * 2 + (g ? 0 : 1), i * 2 + (f ? 1 : 0), 1));\n\t}\n\tvoid addImplication(int i, boolean f, int j, boolean g) { addClause(i, !f, j, g); }\n\tvoid addNand(int i, boolean f, int j, boolean g) { addClause(i, !f, j, !g); }\n\n\tboolean satisfiable() {\n\t\tid();\n\t\tfor(int i = 0; i < num; i++) {\n\t\t\tif(id[i * 2] == id[i * 2 + 1]) return false;\n\t\t\tanswer[i] = id[i * 2] < id[i * 2 + 1];\n\t\t}\n\t\treturn true;\n\t}\n\tboolean[] answer() { satisfiable(); return answer; }\n}\n\nclass Scc extends Graph { // V=numNode, E=numEdge\n\tint id[];\n\tint low[];\n\tint ord[];\n\tDeque<Integer> visited;\n\tint crtOrd;\n\tint numGroup;\n\tint[][] groups;\n\n\tScc(int numNode) { super(numNode, 0, true); init(); } // O(V)\n\tScc(int numNode, int numEdge) { super(numNode, numEdge, true); init(); } // O(V)\n\tScc(int numNode, boolean directed) { super(numNode, 0, directed); init(); } // O(V)\n\tScc(int numNode, int numEdge, boolean directed) { super(numNode, numEdge, directed); init(); }  // O(V)\n\tvoid init() { // (V)\n\t\tid = new int[numNode];\n\t\tlow = new int[numNode];\n\t\tord = new int[numNode];\n\t\tfill(ord, -1);\n\t\tvisited = new ArrayDeque<>();\n\t}\n\n\tint[][] scc() { // O(V+E)\n\t\tid();\n\t\tint len[] = new int[numGroup];\n\t\tfor(int x : id) len[x] ++;\n\t\tgroups = new int[numGroup][];\n\t\tfor(int i = 0; i < numGroup; i ++) groups[i] = new int[len[i]];\n\t\tfill(len, 0);\n\t\tfor(int i = 0; i < nodes.length; i ++) groups[id[i]][len[id[i]] ++] = i;\n\t\treturn groups;\n\t}\n\n\tint[] id() { // O(V+E)\n\t\tfill(ord, -1);\n\t\tfor(int i = 0; i < numNode; i ++) if(ord[i] < 0) dfs(i);\n\t\tfor(int i = 0; i < numNode; i ++) id[i] = numGroup - id[i] - 1;\n\t\treturn id;\n\t}\n\n\tvoid dfs(int v) { // O(V+E)\n\t\tlow[v] = crtOrd;\n\t\tord[v] = crtOrd;\n\t\tcrtOrd ++;\n\t\tvisited.addLast(v);\n\t\tfor(Edge e : nodes[v]) {\n\t\t\tif(ord[e.target] < 0) {\n\t\t\t\tdfs(e.target);\n\t\t\t\tlow[v] = min(low[v], low[e.target]);\n\t\t\t}else {\n\t\t\t\tlow[v] = min(low[v], ord[e.target]);\n\t\t\t}\n\t\t}\n\t\tif(low[v] == ord[v]) {\n\t\t\twhile(true) {\n\t\t\t\tint u = visited.removeLast();\n\t\t\t\tord[u] = nodes.length;\n\t\t\t\tid[u] = numGroup;\n\t\t\t\tif(u == v) break;\n\t\t\t}\n\t\t\tnumGroup ++;\n\t\t}\n\t}\n}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();long D = in.nextLong();\n        long[][] p = new long[N][];\n        for(int i = 0; i< N; i++)\n            p[i] = new long[]{in.nextLong(), in.nextLong()};\n        int[] from = new int[8*N], to = new int[8*N];\n        int cnt = 0;\n        for(int i = 0; i< N; i++){\n            for(int j = i+1; j< N; j++){\n                for(int u = 0; u< 2; u++)\n                    for(int v = 0; v< 2; v++){\n                        if(Math.abs(p[i][u]-p[j][v]) < D){\n                            from[cnt] = (i<<1)|u;\n                            to[cnt] = (j<<1)|v^1;\n                            cnt++;\n                            from[cnt] = (j<<1)|v;;\n                            to[cnt] = (i<<1)|u^1;\n                            cnt++;\n                        }\n                    }\n            }\n        }\n        int[][] g = make(2*N, cnt, from, to), gt = make(2*N, cnt, to, from);\n        int[] scc = new StronglyConnectedComponents().scc(2*N, g, gt);\n        for(int i = 0; i< N; i++)if(scc[i<<1] == scc[i<<1|1]){\n            System.out.println(\"No\");\n            return;\n        }\n        System.out.println(\"Yes\");\n        TreeMap<Integer, Integer> mp = new TreeMap<>();\n        int c = 0;\n        for(int i = 0; i< 2*N; i++)if(!mp.containsKey(scc[i]))mp.put(scc[i], c++);\n        for(int i = 0; i< 2*N; i++)scc[i] = mp.get(scc[i]);\n        \n        int[] ff = new int[cnt], tt = new int[cnt];\n        int cc = 0;\n        for(int i = 0; i< cnt; i++){\n            if(scc[from[i]] != scc[to[i]]){\n                ff[cc] = scc[from[i]];\n                tt[cc] = scc[to[i]];\n                cc++;\n            }\n        }\n        int[][] gg = make(c, cc, ff, tt);\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        int[] indeg = new int[c];\n        for(int i = 0; i< cc; i++)indeg[tt[i]]++;\n        for(int i = 0; i< c; i++)if(indeg[i] == 0)set.add(i);\n        int[] ord = new int[c];\n        for(int i = 0; i< c; i++){\n            ord[i] = set.pollFirst();\n            for(int v:gg[ord[i]]){\n                indeg[v]--;\n                if(indeg[v] == 0)set.add(v);\n            }\n        }\n        \n        for(int i = 0; i< N; i++){\n            if(ord[scc[i<<1]] > ord[scc[i<<1|1]])System.out.println(p[i][0]);\n            else System.out.println(p[i][1]);\n        }\n    }\n    static int[][] make(int N, int M, int[] from, int[] to){\n        int[][] g = new int[N][];int[] cnt = new int[N];\n        for(int i = 0; i< M; i++)cnt[from[i]]++;\n        for(int i = 0; i< N; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< M; i++)g[from[i]][--cnt[from[i]]] = to[i];\n        return g;\n    }\n}\nclass StronglyConnectedComponents {\n    public int[] scc(int n, int[][] g, int[][] gt){\n        Stack<Integer> st = new Stack<>();\n        boolean[] vis = new boolean[n];\n        for(int i = 0; i< n; i++)if(!vis[i])fillOrder(g, st, vis, i);\n        Arrays.fill(vis, false);\n        int[] scc = new int[n];\n        int id = 0;\n        while(!st.isEmpty()){\n            int u = st.pop();\n            if(!vis[u]){assignSCC(gt, scc, vis, u, id++);}\n        }\n        return scc;\n    }\n    private void assignSCC(int[][] gt, int[] scc, boolean[] vis, int u, int id){\n        vis[u] = true;\n        scc[u] = id;\n        for(int v:gt[u])if(!vis[v])assignSCC(gt, scc, vis, v, id);\n    }\n    private void fillOrder(int[][] g, Stack<Integer> s, boolean[] vis, int u){\n        vis[u] = true;\n        for(int v:g[u])if(!vis[v])fillOrder(g, s, vis, v);\n        s.push(u);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D) twosat.AddClause(i, false, j, false);\n                    if (Abs(XYList[i].X - XYList[j].Y) < D) twosat.AddClause(i, false, j, true);\n                    if (Abs(XYList[i].Y - XYList[j].X) < D) twosat.AddClause(i, true, j, false);\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D) twosat.AddClause(i, true, j, true);\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_BitUtil\n    {\n        public static readonly ulong[] BitMask;\n        static LIB_BitUtil()\n        {\n            BitMask = new ulong[64];\n            BitMask[0] = 1;\n            for (var i = 1; i < 64; i++) BitMask[i] = BitMask[i - 1] << 1;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public IEnumerable<long> ScanOne(long value)\n        {\n            for (; value > 0; value &= value - 1) yield return value & -value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(ulong value)\n        {\n            value = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n            value = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n            value = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n            value = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n            value = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n            value = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n            return (long)value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(long value) => PopCount((ulong)value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(ulong value, int idx) => (value & BitMask[idx]) != 0;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(long value, int idx) => IsSet((ulong)value, idx);\n    }\n    class LIB_SCC\n    {\n        int n;\n        List<long> edges;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_SCC(long n)\n        {\n            this.n = (int)n;\n            edges = new List<long>();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddPath(long from, long to) => edges.Add((from << 30) | to);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        protected (int, int[]) SCCIDs()\n        {\n            var start = new int[n + 1];\n            var elist = new int[edges.Count];\n            foreach (var e in edges) ++start[(e >> 30) + 1];\n            for (var i = 1; i < start.Length; ++i) start[i] += start[i - 1];\n            var counter = new int[n + 1];\n            for (var i = 0; i < counter.Length; i++) counter[i] = start[i];\n            foreach (var e in edges) elist[counter[e >> 30]++] = (int)(e & 1073741823);\n            var nowOrd = -1;\n            var groupNum = 0;\n            var visitedIdx = -1;\n            var visited = new int[n];\n            var low = new int[n];\n            var ord = new int[n];\n            var ids = new int[n];\n            for (var i = 0; i < ord.Length; i++) ord[i] = -1;\n            Action<int> dfs = null;\n            dfs = v =>\n            {\n                low[v] = ord[v] = ++nowOrd;\n                visited[++visitedIdx] = v;\n                for (var i = start[v]; i < start[v + 1]; ++i)\n                {\n                    var to = elist[i];\n                    if (ord[to] == -1)\n                    {\n                        dfs(to);\n                        low[v] = Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = Math.Min(low[v], ord[to]);\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = visited[visitedIdx];\n                        --visitedIdx;\n                        ord[u] = n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n                    ++groupNum;\n                }\n            };\n            for (var i = 0; i < ord.Length; ++i)\n            {\n                if (ord[i] == -1) dfs(i);\n            }\n            for (var i = 0; i < ids.Length; i++) ids[i] = groupNum - 1 - ids[i];\n            return (groupNum, ids);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int[][] SCC()\n        {\n            var ids = SCCIDs();\n            var counts = new int[ids.Item1];\n            var groups = new int[ids.Item1][];\n            foreach (var x in ids.Item2) ++counts[x];\n            for (var i = 0; i < groups.Length; ++i) groups[i] = new int[counts[i]];\n            for (var i = 0; i < ids.Item2.Length; i++) groups[ids.Item2[i]][--counts[ids.Item2[i]]] = i;\n            return groups;\n        }\n    }\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_TwoSAT : LIB_SCC\n    {\n        // use LIB_SCC\n        int n;\n        public LIB_Bitset Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new LIB_Bitset(n);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath((i << 1) + (f ? 0 : 1), (j << 1) + (g ? 1 : 0));\n            base.AddPath((j << 1) + (g ? 0 : 1), (i << 1) + (f ? 1 : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < id.Length; i += 2)\n            {\n                if (id[i] == id[i + 1]) return false;\n                Answer[i >> 1] = id[i] < id[i + 1];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n    class LIB_Bitset : IEquatable<LIB_Bitset>\n    {\n        long n;\n        ulong[] ary;\n        static readonly ulong[] ceil;\n        static LIB_Bitset()\n        {\n            ceil = new ulong[64];\n            ceil[0] = 0xffffffffffffffff;\n            ceil[1] = 1;\n            for (var i = 2; i < 64; i++)\n            {\n                ceil[i] = (ceil[i - 1] << 1) | 1;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_Bitset(long size)\n        {\n            if (size <= 0) throw new Exception();\n            n = size;\n            ary = new ulong[((n - 1) >> 6) + 1];\n        }\n        public long Count => n;\n        public long PopCount => ary.Sum(e => LIB_BitUtil.PopCount(e));\n        public bool this[int idx]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return LIB_BitUtil.IsSet(ary[idx >> 6], idx & 63); }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (value) ary[idx >> 6] |= LIB_BitUtil.BitMask[idx & 63];\n                else ary[idx >> 6] &= ~LIB_BitUtil.BitMask[idx & 63];\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] &= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] |= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] ^= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] &= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] |= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] ^= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Flip()\n        {\n            for (var i = 0; i < ary.Length; i++) ary[i] = ~ary[i];\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ~(LIB_Bitset x)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = ~x.ary[i];\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftLeft(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ary.Length - 1; i >= moveCnt; i--)\n            {\n                ary[i] = ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ary[i] |= ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator <<(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ret.ary.Length - 1; i >= moveCnt; i--)\n            {\n                ret.ary[i] = x.ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ret.ary[i] |= x.ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftRight(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ary[i] = ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ary[i] |= ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator >>(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ret.ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ret.ary[i] = x.ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ret.ary[i] |= x.ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator ==(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var i = 0;\n            for (; i < y.ary.Length; i++) if (x.ary[i] != y.ary[i]) return false;\n            for (; i < x.ary.Length; i++) if (x.ary[i] != 0) return false;\n            return true;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator !=(LIB_Bitset x, LIB_Bitset y) => !(x == y);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Equals(LIB_Bitset x) => x == this;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override bool Equals(object x) => x == null ? false : Equals((LIB_Bitset)x);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override int GetHashCode()\n        {\n            var t = ary.Aggregate((a, x) => a ^ x);\n            return (int)(((t >> 32) ^ t) & 0x00000000ffffffff);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Text;\n\nnamespace AtCoder\n{\n\tpublic class Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tusing var cin = new Scanner();\n\t\t\tvar (n, d) = cin.Int2();\n\t\t\tvar xy = new (int x, int y)[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txy[i] = cin.Int2();\n\t\t\t}\n\n\t\t\tvar ts = new StronglyConnectedComponent.TwoSat(n, n * n * 4);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (Math.Abs(xy[i].x - xy[j].x) < d) {\n\t\t\t\t\t\tts.AddClause(i, false, j, false);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Math.Abs(xy[i].x - xy[j].y) < d) {\n\t\t\t\t\t\tts.AddClause(i, false, j, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Math.Abs(xy[i].y - xy[j].x) < d) {\n\t\t\t\t\t\tts.AddClause(i, true, j, false);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Math.Abs(xy[i].y - xy[j].y) < d) {\n\t\t\t\t\t\tts.AddClause(i, true, j, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ret = ts.JudgeSatisfiable();\n\t\t\tif (ret.satisfied == false) {\n\t\t\t\tConsole.WriteLine(\"No\");\n\t\t\t} else {\n\t\t\t\tConsole.WriteLine(\"Yes\");\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ret.answer[i]) {\n\t\t\t\t\t\tConsole.WriteLine(xy[i].x);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.WriteLine(xy[i].y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//original: ttps://github.com/key-moon/ac-library-cs\n\tpublic class StronglyConnectedComponent\n\t{\n\t\tprivate readonly int n_;\n\t\tprivate readonly List<Edge> edges_;\n\n\t\tpublic int VertexCount => n_;\n\n\t\tpublic StronglyConnectedComponent(int n, int m = 100000)\n\t\t{\n\t\t\tn_ = n;\n\t\t\tedges_ = new List<Edge>(m);\n\t\t}\n\n\t\tpublic void AddEdge(int from, int to) => edges_.Add(new Edge(from, to));\n\n\t\tpublic (int groupCount, int[] ids) CalculateSccID()\n\t\t{\n\t\t\tvar cumulatedFromCount = new int[n_ + 1];\n\t\t\tvar to = new int[edges_.Count];\n\t\t\tforeach (var e in edges_) {\n\t\t\t\tcumulatedFromCount[e.From + 1]++;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n_; i++) {\n\t\t\t\tcumulatedFromCount[i] += cumulatedFromCount[i - 1];\n\t\t\t}\n\n\t\t\tvar counter = new int[cumulatedFromCount.Length];\n\t\t\tcumulatedFromCount.CopyTo(counter, 0);\n\t\t\tforeach (var e in edges_) {\n\t\t\t\tto[counter[e.From]] = e.To;\n\t\t\t\tcounter[e.From]++;\n\t\t\t}\n\n\t\t\tint currentOrder = 0;\n\t\t\tint groupCount = 0;\n\t\t\tvar visited = new Stack<int>(n_);\n\t\t\tvar lowestOrdersInGroup = new int[n_];\n\t\t\tvar orders = new int[n_];\n\t\t\torders.AsSpan().Fill(-1);\n\t\t\tvar ids = new int[n_];\n\n\t\t\tvoid Dfs(int v)\n\t\t\t{\n\t\t\t\tlowestOrdersInGroup[v] = currentOrder;\n\t\t\t\torders[v] = currentOrder;\n\t\t\t\tcurrentOrder++;\n\t\t\t\tvisited.Push(v);\n\n\t\t\t\tfor (int i = cumulatedFromCount[v]; i < cumulatedFromCount[v + 1]; i++) {\n\t\t\t\t\tint next = to[i];\n\t\t\t\t\tif (orders[next] == -1) {\n\t\t\t\t\t\tDfs(next);\n\t\t\t\t\t\tlowestOrdersInGroup[v] = Math.Min(lowestOrdersInGroup[v], lowestOrdersInGroup[next]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlowestOrdersInGroup[v] = Math.Min(lowestOrdersInGroup[v], orders[next]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lowestOrdersInGroup[v] == orders[v]) {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint u = visited.Pop();\n\t\t\t\t\t\torders[u] = n_;\n\t\t\t\t\t\tids[u] = groupCount;\n\n\t\t\t\t\t\tif (u == v) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgroupCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < orders.Length; i++) {\n\t\t\t\tif (orders[i] == -1) {\n\t\t\t\t\tDfs(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < ids.Length; i++) {\n\t\t\t\tids[i] = groupCount - 1 - ids[i];\n\t\t\t}\n\n\t\t\treturn (groupCount, ids);\n\t\t}\n\n\t\tpublic List<int>[] Decompose()\n\t\t{\n\t\t\tvar (groupNum, ids) = CalculateSccID();\n\t\t\tvar counts = new int[groupNum];\n\n\t\t\tforeach (var x in ids) {\n\t\t\t\tcounts[x]++;\n\t\t\t}\n\n\t\t\tvar groups = new List<int>[groupNum];\n\t\t\tfor (int i = 0; i < groupNum; i++) {\n\t\t\t\tgroups[i] = new List<int>(counts[i]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < ids.Length; i++) {\n\t\t\t\tgroups[ids[i]].Add(i);\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t}\n\n\t\t[DebuggerDisplay(\"From = {From}, To = {To}\")]\n\t\tprivate readonly struct Edge\n\t\t{\n\t\t\tpublic int From { get; }\n\t\t\tpublic int To { get; }\n\n\t\t\tpublic Edge(int from, int to)\n\t\t\t{\n\t\t\t\tFrom = from;\n\t\t\t\tTo = to;\n\t\t\t}\n\t\t}\n\n\t\tpublic class TwoSat\n\t\t{\n\t\t\treadonly int n_;\n\t\t\treadonly private bool[] answer_;\n\t\t\treadonly private StronglyConnectedComponent scc_;\n\t\t\tpublic TwoSat(int n, int m = 100000)\n\t\t\t{\n\t\t\t\tn_ = n;\n\t\t\t\tanswer_ = new bool[n];\n\t\t\t\tscc_ = new StronglyConnectedComponent(2 * n, m);\n\t\t\t}\n\n\t\t\tpublic void AddClause(int x, bool truthX, int y, bool truthY)\n\t\t\t{\n\t\t\t\tscc_.AddEdge(2 * x + (truthX ? 0 : 1), 2 * y + (truthY ? 1 : 0));\n\t\t\t\tscc_.AddEdge(2 * y + (truthY ? 0 : 1), 2 * x + (truthX ? 1 : 0));\n\t\t\t}\n\n\t\t\tpublic (bool satisfied, IReadOnlyList<bool> answer) JudgeSatisfiable()\n\t\t\t{\n\t\t\t\tvar sccs = scc_.Decompose();\n\t\t\t\tvar id = new int[2 * n_];\n\n\t\t\t\tfor (int i = 0; i < sccs.Length; i++) {\n\t\t\t\t\tforeach (var v in sccs[i]) {\n\t\t\t\t\t\tid[v] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < n_; i++) {\n\t\t\t\t\tif (id[2 * i] == id[2 * i + 1]) {\n\t\t\t\t\t\treturn (false, answer_);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanswer_[i] = id[2 * i] < id[2 * i + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn (true, answer_);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic class HashMap<TKey, TValue> : Dictionary<TKey, TValue>\n\t{\n\t\tprivate readonly Func<TKey, TValue> initialzier_;\n\t\tpublic HashMap(Func<TKey, TValue> initialzier)\n\t\t\t: base()\n\t\t{\n\t\t\tinitialzier_ = initialzier;\n\t\t}\n\n\t\tpublic HashMap(Func<TKey, TValue> initialzier, int capacity)\n\t\t\t: base(capacity)\n\t\t{\n\t\t\tinitialzier_ = initialzier;\n\t\t}\n\n\t\tnew public TValue this[TKey key]\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (ContainsKey(key) == false) {\n\t\t\t\t\tbase[key] = initialzier_(key);\n\t\t\t\t}\n\n\t\t\t\treturn base[key];\n\t\t\t}\n\n\t\t\tset { base[key] = value; }\n\t\t}\n\t}\n\n\tpublic struct ModInt\n\t{\n\t\tpublic const long P = 1000000007;\n\t\t//public const long P = 998244353;\n\n\t\tpublic static ModInt Inverse(ModInt value) => Pow(value, P - 2);\n\t\tpublic static ModInt Pow(ModInt value, long k) => Pow(value.value_, k);\n\t\tpublic static ModInt Pow(long value, long k)\n\t\t{\n\t\t\tlong ret = 1;\n\t\t\tfor (k %= P - 1; k > 0; k >>= 1, value = value * value % P) {\n\t\t\t\tif ((k & 1) == 1) {\n\t\t\t\t\tret = ret * value % P;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ModInt(ret);\n\t\t}\n\n\t\tprivate long value_;\n\n\t\tpublic ModInt(long value)\n\t\t\t=> value_ = value;\n\t\tpublic ModInt(long value, bool mods)\n\t\t{\n\t\t\tif (mods) {\n\t\t\t\tvalue %= P;\n\t\t\t\tif (value < 0) {\n\t\t\t\t\tvalue += P;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalue_ = value;\n\t\t}\n\n\t\tpublic static ModInt operator +(ModInt lhs, ModInt rhs)\n\t\t{\n\t\t\tlhs.value_ = (lhs.value_ + rhs.value_) % P;\n\t\t\treturn lhs;\n\t\t}\n\t\tpublic static ModInt operator +(long lhs, ModInt rhs)\n\t\t{\n\t\t\trhs.value_ = (lhs + rhs.value_) % P;\n\t\t\treturn rhs;\n\t\t}\n\t\tpublic static ModInt operator +(ModInt lhs, long rhs)\n\t\t{\n\t\t\tlhs.value_ = (lhs.value_ + rhs) % P;\n\t\t\treturn lhs;\n\t\t}\n\n\t\tpublic static ModInt operator -(ModInt lhs, ModInt rhs)\n\t\t{\n\t\t\tlhs.value_ = (P + lhs.value_ - rhs.value_) % P;\n\t\t\treturn lhs;\n\t\t}\n\t\tpublic static ModInt operator -(long lhs, ModInt rhs)\n\t\t{\n\t\t\trhs.value_ = (P + lhs - rhs.value_) % P;\n\t\t\treturn rhs;\n\t\t}\n\t\tpublic static ModInt operator -(ModInt lhs, long rhs)\n\t\t{\n\t\t\tlhs.value_ = (P + lhs.value_ - rhs) % P;\n\t\t\treturn lhs;\n\t\t}\n\n\t\tpublic static ModInt operator *(ModInt lhs, ModInt rhs)\n\t\t{\n\t\t\tlhs.value_ = lhs.value_ * rhs.value_ % P;\n\t\t\treturn lhs;\n\t\t}\n\t\tpublic static ModInt operator *(long lhs, ModInt rhs)\n\t\t{\n\t\t\trhs.value_ = lhs * rhs.value_ % P;\n\t\t\treturn rhs;\n\t\t}\n\t\tpublic static ModInt operator *(ModInt lhs, long rhs)\n\t\t{\n\t\t\tlhs.value_ = lhs.value_ * rhs % P;\n\t\t\treturn lhs;\n\t\t}\n\n\t\tpublic static ModInt operator /(ModInt lhs, ModInt rhs)\n\t\t{\n\t\t\tlong exp = P - 2;\n\t\t\twhile (exp > 0) {\n\t\t\t\tif (exp % 2 > 0) {\n\t\t\t\t\tlhs *= rhs;\n\t\t\t\t}\n\n\t\t\t\trhs *= rhs;\n\t\t\t\texp /= 2;\n\t\t\t}\n\n\t\t\treturn lhs;\n\t\t}\n\n\t\tpublic static implicit operator ModInt(long n) => new ModInt(n, true);\n\t\tpublic long ToLong() => value_;\n\t\tpublic override string ToString() => value_.ToString();\n\t}\n\n\tpublic static class Helper\n\t{\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void UpdateMin<T>(ref T target, T value) where T : IComparable<T>\n\t\t\t=> target = target.CompareTo(value) > 0 ? value : target;\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void UpdateMin<T>(ref T target, T value, Action<T> onUpdated) where T : IComparable<T>\n\t\t{\n\t\t\tif (target.CompareTo(value) > 0) {\n\t\t\t\ttarget = value;\n\t\t\t\tonUpdated(value);\n\t\t\t}\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void UpdateMax<T>(ref T target, T value) where T : IComparable<T>\n\t\t\t=> target = target.CompareTo(value) < 0 ? value : target;\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void UpdateMax<T>(ref T target, T value, Action<T> onUpdated) where T : IComparable<T>\n\t\t{\n\t\t\tif (target.CompareTo(value) < 0) {\n\t\t\t\ttarget = value;\n\t\t\t\tonUpdated(value);\n\t\t\t}\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static T[] Array<T>(int n, Func<int, T> init)\n\t\t\t=> Enumerable.Range(0, n).Select(x => init(x)).ToArray();\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static List<T> List<T>(int n, Func<int, T> init)\n\t\t\t=> Enumerable.Range(0, n).Select(x => init(x)).ToList();\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static T[,] Array2<T>(int n, int m, T init)\n\t\t\twhere T : struct\n\t\t{\n\t\t\tvar array = new T[n, m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tarray[i, j] = init;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static T[,] Array2<T>(int n, int m, Func<int, int, T> initializer)\n\t\t{\n\t\t\tvar array = new T[n, m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tarray[i, j] = initializer(i, j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static T[,,] Array3<T>(int n1, int n2, int n3, T init)\n\t\t\twhere T : struct\n\t\t{\n\t\t\tvar array = new T[n1, n2, n3];\n\t\t\tfor (int i1 = 0; i1 < n1; i1++) {\n\t\t\t\tfor (int i2 = 0; i2 < n2; i2++) {\n\t\t\t\t\tfor (int i3 = 0; i3 < n3; i3++) {\n\t\t\t\t\t\tarray[i1, i2, i3] = init;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static T[,,,] Array4<T>(int n1, int n2, int n3, int n4, T init)\n\t\t\twhere T : struct\n\t\t{\n\t\t\tvar array = new T[n1, n2, n3, n4];\n\t\t\tfor (int i1 = 0; i1 < n1; i1++) {\n\t\t\t\tfor (int i2 = 0; i2 < n2; i2++) {\n\t\t\t\t\tfor (int i3 = 0; i3 < n3; i3++) {\n\t\t\t\t\t\tfor (int i4 = 0; i4 < n4; i4++) {\n\t\t\t\t\t\t\tarray[i1, i2, i3, i4] = init;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate static readonly int[] delta4_ = { 1, 0, -1, 0, 1 };\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void DoAt4(int i, int j, int imax, int jmax, Action<int, int> action)\n\t\t{\n\t\t\tfor (int dn = 0; dn < 4; dn++) {\n\t\t\t\tint d4i = i + delta4_[dn];\n\t\t\t\tint d4j = j + delta4_[dn + 1];\n\t\t\t\tif ((uint)d4i < (uint)imax && (uint)d4j < (uint)jmax) {\n\t\t\t\t\taction(d4i, d4j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static readonly int[] delta8_ = { 1, 0, -1, 0, 1, 1, -1, -1, 1 };\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void DoAt8(int i, int j, int imax, int jmax, Action<int, int> action)\n\t\t{\n\t\t\tfor (int dn = 0; dn < 8; dn++) {\n\t\t\t\tint d8i = i + delta8_[dn];\n\t\t\t\tint d8j = j + delta8_[dn + 1];\n\t\t\t\tif ((uint)d8i < (uint)imax && (uint)d8j < (uint)jmax) {\n\t\t\t\t\taction(d8i, d8j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static void ForEachSubBit(int bit, Action<int> action)\n\t\t{\n\t\t\tfor (int sub = bit; sub >= 0; sub--) {\n\t\t\t\tsub &= bit;\n\t\t\t\taction(sub);\n\t\t\t}\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static string Reverse(string src)\n\t\t{\n\t\t\tvar chars = src.ToCharArray();\n\t\t\tfor (int i = 0, j = chars.Length - 1; i < j; i++, j--) {\n\t\t\t\tvar tmp = chars[i];\n\t\t\t\tchars[i] = chars[j];\n\t\t\t\tchars[j] = tmp;\n\t\t\t}\n\t\t\treturn new string(chars);\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic static string Join<T>(this IEnumerable<T> values, string separator = \"\")\n\t\t\t=> string.Join(separator, values);\n\t}\n\n\tpublic class Scanner : IDisposable\n\t{\n\t\tprivate const int BUFFER_SIZE = 1024;\n\t\tprivate const int ASCII_CHAR_BEGIN = 33;\n\t\tprivate const int ASCII_CHAR_END = 126;\n\t\tprivate readonly string filePath_;\n\t\tprivate readonly Stream stream_;\n\t\tprivate readonly byte[] buf_ = new byte[BUFFER_SIZE];\n\t\tprivate int length_ = 0;\n\t\tprivate int index_ = 0;\n\t\tprivate bool isEof_ = false;\n\n\t\tpublic Scanner(string file = \"\")\n\t\t{\n\t\t\tif (string.IsNullOrWhiteSpace(file)) {\n\t\t\t\tstream_ = Console.OpenStandardInput();\n\t\t\t} else {\n\t\t\t\tfilePath_ = file;\n\t\t\t\tstream_ = new FileStream(file, FileMode.Open);\n\t\t\t}\n\n\t\t\tConsole.SetOut(new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush = false\n\t\t\t});\n\t\t}\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tConsole.Out.Flush();\n\t\t\tstream_.Dispose();\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic char Char()\n\t\t{\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = Read();\n\t\t\t} while (b < ASCII_CHAR_BEGIN || ASCII_CHAR_END < b);\n\n\t\t\treturn (char)b;\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic string Next()\n\t\t{\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= ASCII_CHAR_BEGIN && b <= ASCII_CHAR_END; b = (char)Read()) {\n\t\t\t\tsb.Append(b);\n\t\t\t}\n\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic int Int() => (int)Long();\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic int Int(int offset) => Int() + offset;\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (int, int) Int2(int offset = 0)\n\t\t\t=> (Int(offset), Int(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (int, int, int) Int3(int offset = 0)\n\t\t\t=> (Int(offset), Int(offset), Int(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (int, int, int, int) Int4(int offset = 0)\n\t\t\t=> (Int(offset), Int(offset), Int(offset), Int(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic int[] ArrayInt(int length, int offset = 0)\n\t\t{\n\t\t\tint[] Array = new int[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tArray[i] = Int(offset);\n\t\t\t}\n\t\t\treturn Array;\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic long Long()\n\t\t{\n\t\t\tlong ret = 0;\n\t\t\tbyte b;\n\t\t\tbool ng = false;\n\t\t\tdo {\n\t\t\t\tb = Read();\n\t\t\t} while (b != '-' && (b < '0' || '9' < b));\n\n\t\t\tif (b == '-') {\n\t\t\t\tng = true;\n\t\t\t\tb = Read();\n\t\t\t}\n\n\t\t\tfor (; true; b = Read()) {\n\t\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\t\treturn ng ? -ret : ret;\n\t\t\t\t} else {\n\t\t\t\t\tret = ret * 10 + b - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic long Long(long offset) => Long() + offset;\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (long, long) Long2(long offset = 0)\n\t\t\t=> (Long(offset), Long(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (long, long, long) Long3(long offset = 0)\n\t\t\t=> (Long(offset), Long(offset), Long(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (long, long, long, long) Long4(long offset = 0)\n\t\t\t=> (Long(offset), Long(offset), Long(offset), Long(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic long[] ArrayLong(int length, long offset = 0)\n\t\t{\n\t\t\tlong[] Array = new long[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tArray[i] = Long(offset);\n\t\t\t}\n\t\t\treturn Array;\n\t\t}\n\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic double Double() => double.Parse(Next(), CultureInfo.InvariantCulture);\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic double Double(double offset) => Double() + offset;\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (double, double) Double2(double offset = 0)\n\t\t\t=> (Double(offset), Double(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (double, double, double) Double3(double offset = 0)\n\t\t\t=> (Double(offset), Double(offset), Double(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic (double, double, double, double) Double4(double offset = 0)\n\t\t\t=> (Double(offset), Double(offset), Double(offset), Double(offset));\n\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]\n\t\tpublic double[] ArrayDouble(int length, double offset = 0)\n\t\t{\n\t\t\tdouble[] Array = new double[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tArray[i] = Double(offset);\n\t\t\t}\n\t\t\treturn Array;\n\t\t}\n\n\t\tprivate byte Read()\n\t\t{\n\t\t\tif (isEof_) {\n\t\t\t\tthrow new EndOfStreamException();\n\t\t\t}\n\n\t\t\tif (index_ >= length_) {\n\t\t\t\tindex_ = 0;\n\t\t\t\tif ((length_ = stream_.Read(buf_, 0, BUFFER_SIZE)) <= 0) {\n\t\t\t\t\tisEof_ = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buf_[index_++];\n\t\t}\n\n\t\tpublic void Save(string text)\n\t\t{\n\t\t\tif (string.IsNullOrWhiteSpace(filePath_)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFile.WriteAllText(filePath_ + \"_output.txt\", text);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tconst double eps=1e-11;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0];\n\t\tvar h=new int[n][];\n\t\tvar sat=new Tsat(n);\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\th[i]=sc.Ia;\n\t\t\tfor(int j = i-1;j>=0;j--) {\n\t\t\t\tif(Abs(h[i][0]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][0]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,0);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsat.Scc();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sat.Ck(i);\n\t\t\tif(e==-1){\n\t\t\t\tConsole.WriteLine(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{sb.Append(h[i][e]+\"\\n\");}\n\t\t}\n\t\tConsole.WriteLine(\"Yes\");\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Tsat{\n\tprivate List<int>[] li;\n\tprivate int[] h;\n\tprivate int n;\n\tpublic Tsat(int n){\n\t\tthis.n=n<<1;\n\t\tli=new List<int>[this.n];\n\t\tfor(int i=0;i<this.n;i++){li[i]=new List<int>();}\n\t}\n\tpublic void Edge(int a,int b){\n\t\tli[a].Add(b);\n\t}\n\tpublic void Edge(int a,int c,int b,int d){\n\t\ta=(a<<1)+c;b=(b<<1)+d;\n\t\tli[a].Add(b);\n\t}\n\tpublic int Ck(int a){\n\t\ta<<=1;\n\t\treturn h[a]==h[a+1]?-1:(h[a]<h[a+1]?0:1);\n\t}\n\tpublic void Scc(){\n\t\tint n=li.Length,p=1;\n\t\tvar b=new bool[n];\n\t\tvar b2=new bool[n];\n\t\tvar b3=new bool[n];\n\t\tvar low=new int[n];\n\t\th=new int[n];\n\t\tvar sk=new Stack<int>();\n\t\tvar lid=new List<List<int>>();\n\t\tfor(int i = 0;i<n;i++) {if(!b[i]){Fud(i);}}\n\t\tvoid Fud(int a){\n\t\t\tb[a]=true;\n\t\t\tlow[a]=p++;\n\t\t\tsk.Push(a);\n\t\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\t\tif(b2[li[a][i]]){continue;}\n\t\t\t\tif(!b[li[a][i]]){Fud(li[a][i]);}\n\t\t\t\tif(low[a]>low[li[a][i]]){\n\t\t\t\t\tlow[a]=low[li[a][i]];\n\t\t\t\t\tb3[a]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b3[a]){return;}\n\t\t\tint v=-1;\n\t\t\tlid.Add(new List<int>());\n\t\t\twhile(v!=a){\n\t\t\t\tv=sk.Pop();\n\t\t\t\tlid[lid.Count-1].Add(v);\n\t\t\t\tb2[v]=true;\n\t\t\t\th[v]=lid.Count-1;\n\t\t\t}\n\t\t}\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),int.Parse);}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),long.Parse);}\n\tpublic long[] La3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing static Template;\nusing SC = FastScanner;\n\npublic partial class Solver\n{\n    public void Solve()\n    {\n        int N = sc.Int, D = sc.Int;\n        var ts = new TwoSat(N);\n        int[] X=new int[N], Y=new int[N];\n        for(int i = 0; i < N; i++)\n        {\n            X[i] = sc.Int;Y[i] = sc.Int;\n            for(int j = 0; j < i; j++)\n            {\n                if (Abs(X[i] - X[j]) < D)\n                {\n                    ts.AddClosure(i, false, j, false);\n                }\n                if (Abs(Y[i] - Y[j]) < D)\n                {\n                    ts.AddClosure(i, true, j, true);\n                }\n                if (Abs(X[i] - Y[j]) < D)\n                {\n                    ts.AddClosure(i, false, j, true);\n                }\n                if (Abs(Y[i] - X[j]) < D)\n                {\n                    ts.AddClosure(i, true, j, false);\n                }\n            }\n        }\n        if (!ts.Execute()) Fail(\"No\");\n        Console.WriteLine(\"Yes\");\n        for (int i = 0; i < ts.Answer.Length; i++)\n            if (ts.Answer[i]) Console.WriteLine(X[i]);\n            else Console.WriteLine(Y[i]);\n\n    }\n}\nclass TwoSat\n{\n    StronglyConnectedComponents scc;\n    public bool[] Answer { get; private set; }\n    public TwoSat(int N)\n    {\n        scc = new StronglyConnectedComponents(N << 1);\n        Answer = new bool[N];\n    }\n    //(x_i=f)V(x_j=g) <-> !(x_i=f)->(x_j=g) <-> !(x_j=g)->(x_i=f)の追加\n    public void AddClosure(int i, bool f, int j, bool g)\n    {\n        scc.AddEdge((i << 1) | (f ? 0 : 1), (j << 1) | (g ? 1 : 0));\n        scc.AddEdge((j << 1) | (g ? 0 : 1), (i << 1) | (f ? 1 : 0));\n    }\n    public bool Execute()\n    {\n        scc.Execute();\n        var gp = scc.Group;\n        var len = gp.Length >> 1;\n        for (int i = 0; i < len; i++)\n        {\n            if (gp[i << 1] == gp[(i << 1) | 1]) return false;\n            Answer[i] = gp[i<<1] < gp[(i<<1)|1];//DAG\n        }\n        return true;\n    }\n}\n\npublic class StronglyConnectedComponents\n{\n    int size;\n    List<Edge> edges;\n    private int[][] scc;\n    public int Count { get; private set; }\n    public int[] Group { get; private set; }\n    public int[] GroupAt(int k) => scc[k];\n    public StronglyConnectedComponents(int count)\n    {\n        size = count;\n        edges = new List<Edge>();\n    }\n    public void AddEdge(int from, int to)\n    {\n        edges.Add(new Edge(from, to));\n    }\n    /// <summary>\n    /// O(V+E)\n    /// </summary>\n    /// <returns>scc[i]:i番目の強連結成分の頂点</returns>\n    public int[][] Execute()\n    {\n        //e.fromでe.toをソート\n        var start = new int[size + 1];\n        var toList = new int[edges.Count];\n        foreach (var e in edges) start[e.from + 1]++;\n        for (int i = 0; i < start.Length - 1; i++) start[i + 1] += start[i];\n        var count = start.ToArray();\n        foreach (var e in edges) toList[count[e.from]++] = e.to;\n        //lowlink\n        int nowOrd = 0;\n        int[] low = new int[size], ord = new int[size];\n        Group = new int[size];\n        var stack = new Stack<int>(size);\n        for (int i = 0; i < ord.Length; i++) ord[i] = -1;\n        Action<int> dfs = null;\n        dfs = v =>\n        {\n            low[v] = ord[v] = nowOrd++;\n            stack.Push(v);\n            for (int i = start[v]; i < start[v + 1]; i++)\n            {\n                var to = toList[i];\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = Min(low[v], low[to]);\n                }\n                else low[v] = Min(low[v], ord[to]);\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    var u = stack.Pop();\n                    ord[u] = size;\n                    Group[u] = Count;\n                    if (u == v) break;\n                }\n                Count++;\n            }\n        };\n        for (int i = 0; i < ord.Length; i++)\n        {\n            if (ord[i] == -1) dfs(i);\n        }\n        for (int i = 0; i < Group.Length; i++)\n        {\n            Group[i] = Count - 1 - Group[i];\n            count[i] = 0;\n        }\n        scc = new int[Count][];\n        foreach (var g in Group) count[g]++;\n        for (int i = 0; i < scc.Length; i++) scc[i] = new int[count[i]];\n        for (int i = 0; i < Group.Length; i++) scc[Group[i]][--count[Group[i]]] = i;\n        return scc;\n    }\n    struct Edge { public int from, to; public Edge(int f, int t) { from = f; to = t; } }\n}\n\npublic class FastScanner\n{\n    //0x0a:LF 0x20:SPC 0x2d:- 0x30 ~ 0x39: 0 ~ 9\n    static System.IO.Stream str = System.Console.OpenStandardInput();\n    const int size = 1 << 10;\n    static byte[] buffer = new byte[size];\n    static int ptr;\n    static int len;\n    public int Int\n    {\n        get\n        {\n            var c = Read();\n            while (c < 0x21)\n            {\n                c = Read();\n            }\n            var n = false;\n            if (c == '-')\n            {\n                n = true;\n                c = Read();\n            }\n            var ret = 0;\n            while (c >= 0x30)\n            {\n                ret = ret * 10 + (c & 15);\n                c = Read();\n            }\n            return n ? -ret : ret;\n        }\n    }\n    public long Long\n    {\n        get\n        {\n            var c = Read();\n            while (c < 0x21)\n            {\n                c = Read();\n            }\n            var n = false;\n            if (c == '-')\n            {\n                n = true;\n                c = Read();\n            }\n            var ret = 0L;\n            while (c >= 0x30)\n            {\n                ret = ret * 10 + (c & 15);\n                c = Read();\n            }\n            return n ? -ret : ret;\n        }\n    }\n    byte Read()\n    {\n        if (ptr == len)\n        {\n            len = str.Read(buffer, 0, size);\n            if (len == 0) return 0;\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n}\n#region Template\npublic partial class Solver\n{\n    public SC sc = new SC();\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var sol = new Solver();\n        int testcase = 1;\n        //testcase = sol.sc.Int;\n        //var th = new Thread(sol.Solve, 1 << 26);th.Start();th.Join();\n        while (testcase-- > 0)\n            sol.Solve();\n        Console.Out.Flush();\n    }\n}\npublic static class Template\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) > 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(this IList<T> A, int i, int j) { var t = A[i]; A[i] = A[j]; A[j] = t; }\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static void Out<T>(this IList<T> A, out T a) => a = A[0];\n    public static void Out<T>(this IList<T> A, out T a, out T b) { a = A[0]; b = A[1]; }\n    public static void Out<T>(this IList<T> A, out T a, out T b, out T c) { A.Out(out a, out b); c = A[2]; }\n    public static void Out<T>(this IList<T> A, out T a, out T b, out T c, out T d) { A.Out(out a, out b, out c); d = A[3]; }\n    public static string Concat<T>(this IEnumerable<T> A, string sp) => string.Join(sp, A);\n    public static char ToChar(this int s, char begin = '0') => (char)(s + begin);\n    public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> A) => A.OrderBy(v => Guid.NewGuid());\n    public static int CompareTo<T>(this T[] A, T[] B, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; for (var i = 0; i < Min(A.Length, B.Length); i++) { int c = cmp(A[i], B[i]); if (c > 0) return 1; else if (c < 0) return -1; } if (A.Length == B.Length) return 0; if (A.Length > B.Length) return 1; else return -1; }\n    public static string ToStr<T>(this T[][] A) => A.Select(a => a.Concat(\" \")).Concat(\"\\n\");\n    public static int ArgMax<T>(this IList<T> A, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; T max = A[0]; int rt = 0; for (int i = 1; i < A.Count; i++) if (cmp(max, A[i]) < 0) { max = A[i]; rt = i; } return rt; }\n    public static T PopBack<T>(this List<T> A) { var v = A[A.Count - 1]; A.RemoveAt(A.Count - 1); return v; }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    public void Make<T1, T2, T3, T4, T5, T6, T7>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6, out T7 v7) { Make(out v1, out v2, out v3, out v4, out v5, out v6); v7 = Next<T7>(); }\n    public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tconst double eps=1e-11;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0];\n\t\tvar h=new int[n][];\n\t\tvar sat=new Tsat(n);\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\th[i]=sc.Ia;\n\t\t\tfor(int j = i-1;j>=0;j--) {\n\t\t\t\tif(Abs(h[i][0]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][0]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,0);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsat.Scc();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sat.Ck(i);\n\t\t\tif(e==-1){\n\t\t\t\tConsole.WriteLine(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{sb.Append(h[i][e]+\"\\n\");}\n\t\t}\n\t\tConsole.WriteLine(\"Yes\");\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Tsat{\n\tpublic List<int>[] li,lim;\n\tpublic int[] h;\n\tprivate int n;\n\tpublic Tsat(int n){\n\t\tthis.n=n<<1;\n\t\tlim=new List<int>[this.n];\n\t\tfor(int i=0;i<this.n;i++){lim[i]=new List<int>();}\n\t}\n\tpublic void Edge(int a,int b){\n\t\tlim[a].Add(b);\n\t}\n\tpublic void Edge(int a,int c,int b,int d){\n\t\ta=(a<<1)+c;b=(b<<1)+d;\n\t\tlim[a].Add(b);\n\t}\n\tpublic int Ck(int a){\n\t\ta<<=1;\n\t\treturn h[a]==h[a+1]?-1:(h[a]<h[a+1]?0:1);\n\t}\n\tpublic void Scc(){\n\t\tint n=lim.Length,p=1;\n\t\tvar b=new bool[n];\n\t\tvar b2=new bool[n];\n\t\tvar b3=new bool[n];\n\t\tvar low=new int[n];\n\t\th=new int[n];\n\t\tvar sk=new Stack<int>();\n\t\tvar lid=new List<List<int>>();\n\t\tfor(int i = 0;i<n;i++) {if(!b[i]){Fud(i);}}\n\t\tvoid Fud(int a){\n\t\t\tb[a]=true;\n\t\t\tlow[a]=p++;\n\t\t\tsk.Push(a);\n\t\t\tfor(int i=0;i<lim[a].Count;i++){\n\t\t\t\tif(b2[lim[a][i]]){continue;}\n\t\t\t\tif(!b[lim[a][i]]){Fud(lim[a][i]);}\n\t\t\t\tif(low[a]>low[lim[a][i]]){\n\t\t\t\t\tlow[a]=low[lim[a][i]];\n\t\t\t\t\tb3[a]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b3[a]){return;}\n\t\t\tint v=-1;\n\t\t\tlid.Add(new List<int>());\n\t\t\twhile(v!=a){\n\t\t\t\tv=sk.Pop();\n\t\t\t\tlid[lid.Count-1].Add(v);\n\t\t\t\tb2[v]=true;\n\t\t\t\th[v]=lid.Count-1;\n\t\t\t}\n\t\t}\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),int.Parse);}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),long.Parse);}\n\tpublic long[] La3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D) twosat.AddClause(i, false, j, false);\n                    if (Abs(XYList[i].X - XYList[j].Y) < D) twosat.AddClause(i, false, j, true);\n                    if (Abs(XYList[i].Y - XYList[j].X) < D) twosat.AddClause(i, true, j, false);\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D) twosat.AddClause(i, true, j, true);\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_TwoSAT : LIB_SCC\n    {\n        // use LIB_SCC\n        int n;\n        public LIB_Bitset Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new LIB_Bitset(n);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath(i + (f ? 0 : n), j + (g ? n : 0));\n            base.AddPath(j + (g ? 0 : n), i + (f ? n : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < n; ++i)\n            {\n                if (id[i] == id[i + n]) return false;\n                Answer[i] = id[i] < id[i + n];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_Bitset : IEquatable<LIB_Bitset>\n    {\n        long n;\n        ulong[] ary;\n        static readonly ulong[] ceil;\n        static LIB_Bitset()\n        {\n            ceil = new ulong[64];\n            ceil[0] = 0xffffffffffffffff;\n            ceil[1] = 1;\n            for (var i = 2; i < 64; i++)\n            {\n                ceil[i] = (ceil[i - 1] << 1) | 1;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_Bitset(long size)\n        {\n            if (size <= 0) throw new Exception();\n            n = size;\n            ary = new ulong[((n - 1) >> 6) + 1];\n        }\n        public long Count => n;\n        public long PopCount => ary.Sum(e => LIB_BitUtil.PopCount(e));\n        public bool this[int idx]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return LIB_BitUtil.IsSet(ary[idx >> 6], idx & 63); }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (value) ary[idx >> 6] |= LIB_BitUtil.BitMask[idx & 63];\n                else ary[idx >> 6] &= ~LIB_BitUtil.BitMask[idx & 63];\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] &= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] |= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] ^= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] &= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] |= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] ^= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Flip()\n        {\n            for (var i = 0; i < ary.Length; i++) ary[i] = ~ary[i];\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ~(LIB_Bitset x)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = ~x.ary[i];\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftLeft(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ary.Length - 1; i >= moveCnt; i--)\n            {\n                ary[i] = ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ary[i] |= ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator <<(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ret.ary.Length - 1; i >= moveCnt; i--)\n            {\n                ret.ary[i] = x.ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ret.ary[i] |= x.ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftRight(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ary[i] = ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ary[i] |= ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator >>(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ret.ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ret.ary[i] = x.ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ret.ary[i] |= x.ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator ==(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var i = 0;\n            for (; i < y.ary.Length; i++) if (x.ary[i] != y.ary[i]) return false;\n            for (; i < x.ary.Length; i++) if (x.ary[i] != 0) return false;\n            return true;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator !=(LIB_Bitset x, LIB_Bitset y) => !(x == y);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Equals(LIB_Bitset x) => x == this;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override bool Equals(object x) => x == null ? false : Equals((LIB_Bitset)x);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override int GetHashCode()\n        {\n            var t = ary.Aggregate((a, x) => a ^ x);\n            return (int)(((t >> 32) ^ t) & 0x00000000ffffffff);\n        }\n    }\n    class LIB_BitUtil\n    {\n        public static readonly ulong[] BitMask;\n        static LIB_BitUtil()\n        {\n            BitMask = new ulong[64];\n            BitMask[0] = 1;\n            for (var i = 1; i < 64; i++) BitMask[i] = BitMask[i - 1] << 1;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public IEnumerable<long> ScanOne(long value)\n        {\n            for (; value > 0; value &= value - 1) yield return value & -value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(ulong value)\n        {\n            value = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n            value = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n            value = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n            value = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n            value = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n            value = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n            return (long)value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(long value) => PopCount((ulong)value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(ulong value, int idx) => (value & BitMask[idx]) != 0;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(long value, int idx) => IsSet((ulong)value, idx);\n    }\n    class LIB_SCC\n    {\n        int n;\n        List<long> edges;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_SCC(long n)\n        {\n            this.n = (int)n;\n            edges = new List<long>();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddPath(long from, long to) => edges.Add((from << 30) | to);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        protected (int, int[]) SCCIDs()\n        {\n            var start = new int[n + 1];\n            var elist = new int[edges.Count];\n            foreach (var e in edges) ++start[(e >> 30) + 1];\n            for (var i = 1; i < start.Length; ++i) start[i] += start[i - 1];\n            var counter = new int[start.Length];\n            for (var i = 0; i < counter.Length; i++) counter[i] = start[i];\n            foreach (var e in edges) elist[counter[e >> 30]++] = (int)(e & 1073741823);\n            var nowOrd = -1;\n            var groupNum = 0;\n            var visitedIdx = -1;\n            var visited = new int[n];\n            var low = new int[n];\n            var ord = new int[n];\n            var ids = new int[n];\n            for (var i = 0; i < ord.Length; i++) ord[i] = -1;\n            Action<int> dfs = null;\n            dfs = v =>\n            {\n                low[v] = ord[v] = ++nowOrd;\n                visited[++visitedIdx] = v;\n                for (var i = start[v]; i < start[v + 1]; ++i)\n                {\n                    var to = elist[i];\n                    if (ord[to] == -1)\n                    {\n                        dfs(to);\n                        low[v] = Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = Math.Min(low[v], ord[to]);\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = visited[visitedIdx];\n                        --visitedIdx;\n                        ord[u] = n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n                    ++groupNum;\n                }\n            };\n            for (var i = 0; i < ord.Length; ++i)\n            {\n                if (ord[i] == -1) dfs(i);\n            }\n            for (var i = 0; i < ids.Length; i++) ids[i] = groupNum - 1 - ids[i];\n            return (groupNum, ids);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int[][] SCC()\n        {\n            var ids = SCCIDs();\n            var counts = new int[ids.Item1];\n            var groups = new int[ids.Item1][];\n            foreach (var x in ids.Item2) ++counts[x];\n            for (var i = 0; i < groups.Length; ++i) groups[i] = new int[counts[i]];\n            for (var i = 0; i < ids.Item2.Length; i++) groups[ids.Item2[i]][--counts[ids.Item2[i]]] = i;\n            return groups;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing CompLib.Util;\n\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing CompLib.Graph;\nusing System.Text;\nusing CompLib.Mathematics;\n\npublic class Program\n{\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        int n = sc.NextInt();\n        int d = sc.NextInt();\n\n        var twoSat = new TwoSAT(n);\n        int[] x, y;\n        x = new int[n];\n        y = new int[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            x[i] = sc.NextInt();\n            y[i] = sc.NextInt();\n        }\n\n        // yに建てる false xに建てる true\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                if (Math.Abs(x[i] - x[j]) < d)\n                {\n                    // 両方falseはダメ\n                    twoSat.AddClause(i, true, j, true);\n                }\n                if (Math.Abs(y[i] - y[j]) < d)\n                {\n                    // 両方trueはダメ\n                    twoSat.AddClause(i, false, j, false);\n                }\n\n                if (Math.Abs(x[i] - y[j]) < d)\n                {\n                    // iがfalseかつjがtrueはダメ\n                    twoSat.AddClause(i, true, j, false);\n                }\n                if (Math.Abs(y[i] - x[j]) < d)\n                {\n                    // iがtrue, jがfalse\n                    twoSat.AddClause(i, false, j, true);\n                }\n            }\n        }\n\n        if (twoSat.Satisfiable())\n        {\n            Console.WriteLine(\"Yes\");\n            var ans = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                ans[i] = twoSat.Answer()[i] ? y[i] : x[i];\n            }\n            Console.WriteLine(string.Join(\"\\n\", ans));\n        }\n        else\n        {\n            Console.WriteLine(\"No\");\n        }\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n    // public static void Main(string[] args) => new Thread(new Program().Solve, 1 << 27).Start();\n}\n\nnamespace CompLib.Mathematics\n{\n    class TwoSAT\n    {\n        private readonly int _n;\n        private readonly bool[] _answer;\n        private readonly SCC scc;\n\n        public TwoSAT(int n)\n        {\n            _n = n;\n            _answer = new bool[_n];\n            scc = new SCC(2 * _n);\n        }\n\n        /// <summary>\n        /// 条件(クロージャ) (i = f) ∨ (j = g)を追加します\n        /// </summary>\n        /// <param name=\"i\"></param>\n        /// <param name=\"f\"></param>\n        /// <param name=\"j\"></param>\n        /// <param name=\"g\"></param>\n        public void AddClause(int i, bool f, int j, bool g)\n        {\n            Debug.Assert(0 <= i && i < _n);\n            Debug.Assert(0 <= j && j < _n);\n            scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n\n        /// <summary>\n        /// 条件を満たすリテラルが存在するか?\n        /// </summary>\n        public bool Satisfiable()\n        {\n            scc.Execute();\n            for (int i = 0; i < _n; i++)\n            {\n                if (scc.GetId(2 * i) == scc.GetId(2 * i + 1)) return false;\n                _answer[i] = scc.GetId(2 * i) < scc.GetId(2 * i + 1);\n            }\n            return true;\n        }\n        /// <summary>\n        /// 条件を満たすリテラルの一例を返す\n        /// </summary>\n        /// <remarks>\n        /// Satisfiable() してtrueを返したら呼んでください\n        /// </remarks>\n        /// <returns></returns>\n        public bool[] Answer()\n        {\n            return _answer;\n        }\n    }\n}\n\n\n\nnamespace CompLib.Graph\n{\n    class SCC\n    {\n        //\n        private readonly int _n;\n        private readonly List<(int f, int t)> _edges;\n\n        // start[i+1] - start[i] iから生える辺の本数\n        // eList[start[i]] ~ eList[start[i+1]-1]がiから生える辺の行き先 \n        private int[] _start;\n        private int[] _eList;\n\n\n        // 行きがけ順現在地, 強連結成分の個数\n        private int _nowOrd, _groupNum;\n        List<int> _visited;\n\n        // iから行ける頂点のordの最小値 ,行きがけ順, iが含まれるトポロジカル順序\n        int[] _low, _ord, _ids;\n\n        public SCC(int n)\n        {\n            _n = n;\n            _edges = new List<(int f, int t)>();\n        }\n\n        /// <summary>\n        /// fromからtoへ有向辺を追加します\n        /// </summary>\n        /// <param name=\"from\"></param>\n        /// <param name=\"to\"></param>\n        public void AddEdge(int from, int to)\n        {\n            Debug.Assert(0 <= from && from < _n);\n            Debug.Assert(0 <= to && to < _n);\n            _edges.Add((from, to));\n        }\n\n        /// <summary>\n        /// 強連結成分分解して、トポロジカル順序で返します\n        /// </summary>\n        /// <remarks>内部でExecute()します</remarks>\n        /// <returns></returns>\n        public List<int>[] GetSCCs()\n        {\n            Execute();\n\n            // ACLだとvec.reserveしてるけどいる?\n            List<int>[] groups = new List<int>[_groupNum];\n            for (int i = 0; i < _groupNum; i++)\n            {\n                groups[i] = new List<int>();\n            }\n\n            for (int i = 0; i < _n; i++)\n            {\n                groups[_ids[i]].Add(i);\n            }\n\n            return groups;\n        }\n\n        /// <summary>\n        /// 強連結成分分解をします\n        /// </summary>\n        public void Execute()\n        {\n            Build();\n            _nowOrd = 0;\n            _groupNum = 0;\n            _visited = new List<int>(_n);\n            _low = new int[_n];\n            _ord = new int[_n];\n\n            // CodeforcesだとArrayにFill()が無い\n            for (int i = 0; i < _n; i++)\n            {\n                _ord[i] = -1;\n            }\n            _ids = new int[_n];\n\n            for (int i = 0; i < _n; i++)\n            {\n                if (_ord[i] == -1) Go(i);\n            }\n\n            for (int i = 0; i < _n; i++)\n            {\n                _ids[i] = _groupNum - 1 - _ids[i];\n            }\n        }\n\n        /// <summary>\n        /// 強連結成分の個数\n        /// </summary>\n        /// <remarks>\n        /// Execute()してから呼んでください\n        /// </remarks>\n        public int GroupCount\n        {\n            get\n            {\n                return _groupNum;\n            }\n        }\n\n        /// <summary>\n        /// vが含まれる強連結成分のトポロジカル順序\n        /// </summary>\n        /// <param name=\"v\"></param>\n        /// <remarks>\n        /// Execute()してから呼んでください\n        /// </remarks>\n        /// <returns></returns>\n        public int GetId(int v)\n        {\n            return _ids[v];\n        }\n\n        void Go(int v)\n        {\n            _low[v] = _ord[v] = _nowOrd++;\n            _visited.Add(v);\n            for (int i = _start[v]; i < _start[v + 1]; i++)\n            {\n                int to = _eList[i];\n                if (_ord[to] == -1)\n                {\n                    Go(to);\n                    _low[v] = Math.Min(_low[v], _low[to]);\n                }\n                else\n                {\n                    _low[v] = Math.Min(_low[v], _ord[to]);\n                }\n            }\n\n            if (_low[v] == _ord[v])\n            {\n                while (true)\n                {\n                    int u = _visited[_visited.Count - 1];\n                    _visited.RemoveAt(_visited.Count - 1);\n                    _ord[u] = _n;\n                    _ids[u] = _groupNum;\n                    if (u == v) break;\n                }\n                _groupNum++;\n            }\n        }\n\n        private void Build()\n        {\n            _start = new int[_n + 1];\n            _eList = new int[_edges.Count];\n\n            foreach (var e in _edges)\n            {\n                _start[e.f + 1]++;\n            }\n\n            for (int i = 1; i <= _n; i++)\n            {\n                _start[i] += _start[i - 1];\n            }\n\n            var counter = new int[_n + 1];\n            Array.Copy(_start, counter, _n + 1);\n\n            foreach (var e in _edges)\n            {\n                _eList[counter[e.f]++] = e.t;\n            }\n        }\n    }\n}\n\n\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N * 2);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D)\n                    {\n                        twosat.AddClause(i, false, j, false);\n                        twosat.AddClause(i, true, j, true);\n                    }\n                    if (Abs(XYList[i].X - XYList[j].Y) < D)\n                    {\n                        twosat.AddClause(i, false, j + N, false);\n                        twosat.AddClause(i, true, j + N, true);\n                    }\n                    if (Abs(XYList[i].Y - XYList[j].X) < D)\n                    {\n                        twosat.AddClause(i + N, false, j, false);\n                        twosat.AddClause(i + N, true, j, true);\n                    }\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D)\n                    {\n                        twosat.AddClause(i + N, false, j + N, false);\n                        twosat.AddClause(i + N, true, j + N, true);\n                    }\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_Bitset : IEquatable<LIB_Bitset>\n    {\n        long n;\n        ulong[] ary;\n        static readonly ulong[] ceil;\n        static LIB_Bitset()\n        {\n            ceil = new ulong[64];\n            ceil[0] = 0xffffffffffffffff;\n            ceil[1] = 1;\n            for (var i = 2; i < 64; i++)\n            {\n                ceil[i] = (ceil[i - 1] << 1) | 1;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_Bitset(long size)\n        {\n            if (size <= 0) throw new Exception();\n            n = size;\n            ary = new ulong[((n - 1) >> 6) + 1];\n        }\n        public long Count => n;\n        public long PopCount => ary.Sum(e => LIB_BitUtil.PopCount(e));\n        public bool this[int idx]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return LIB_BitUtil.IsSet(ary[idx >> 6], idx & 63); }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (value) ary[idx >> 6] |= LIB_BitUtil.BitMask[idx & 63];\n                else ary[idx >> 6] &= ~LIB_BitUtil.BitMask[idx & 63];\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] &= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] |= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] ^= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] &= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] |= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] ^= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Flip()\n        {\n            for (var i = 0; i < ary.Length; i++) ary[i] = ~ary[i];\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ~(LIB_Bitset x)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = ~x.ary[i];\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftLeft(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ary.Length - 1; i >= moveCnt; i--)\n            {\n                ary[i] = ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ary[i] |= ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator <<(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ret.ary.Length - 1; i >= moveCnt; i--)\n            {\n                ret.ary[i] = x.ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ret.ary[i] |= x.ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftRight(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ary[i] = ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ary[i] |= ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator >>(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ret.ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ret.ary[i] = x.ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ret.ary[i] |= x.ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator ==(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var i = 0;\n            for (; i < y.ary.Length; i++) if (x.ary[i] != y.ary[i]) return false;\n            for (; i < x.ary.Length; i++) if (x.ary[i] != 0) return false;\n            return true;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator !=(LIB_Bitset x, LIB_Bitset y) => !(x == y);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Equals(LIB_Bitset x) => x == this;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override bool Equals(object x) => x == null ? false : Equals((LIB_Bitset)x);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override int GetHashCode()\n        {\n            var t = ary.Aggregate((a, x) => a ^ x);\n            return (int)(((t >> 32) ^ t) & 0x00000000ffffffff);\n        }\n    }\n    class LIB_SCC\n    {\n        int n;\n        List<long> edges;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_SCC(long n)\n        {\n            this.n = (int)n;\n            edges = new List<long>();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddPath(long from, long to) => edges.Add((from << 30) | to);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        protected (int, int[]) SCCIDs()\n        {\n            var start = new int[n + 1];\n            var elist = new int[edges.Count];\n            foreach (var e in edges) ++start[(e >> 30) + 1];\n            for (var i = 1; i < start.Length; ++i) start[i] += start[i - 1];\n            var counter = new int[n + 1];\n            for (var i = 0; i < counter.Length; i++) counter[i] = start[i];\n            foreach (var e in edges) elist[counter[e >> 30]++] = (int)(e & 1073741823);\n            var nowOrd = -1;\n            var groupNum = 0;\n            var visitedIdx = -1;\n            var visited = new int[n];\n            var low = new int[n];\n            var ord = new int[n];\n            var ids = new int[n];\n            for (var i = 0; i < ord.Length; i++) ord[i] = -1;\n            Action<int> dfs = null;\n            dfs = v =>\n            {\n                low[v] = ord[v] = ++nowOrd;\n                visited[++visitedIdx] = v;\n                for (var i = start[v]; i < start[v + 1]; ++i)\n                {\n                    var to = elist[i];\n                    if (ord[to] == -1)\n                    {\n                        dfs(to);\n                        low[v] = Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = Math.Min(low[v], ord[to]);\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = visited[visitedIdx];\n                        --visitedIdx;\n                        ord[u] = n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n                    ++groupNum;\n                }\n            };\n            for (var i = 0; i < ord.Length; ++i)\n            {\n                if (ord[i] == -1) dfs(i);\n            }\n            for (var i = 0; i < ids.Length; i++) ids[i] = groupNum - 1 - ids[i];\n            return (groupNum, ids);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int[][] SCC()\n        {\n            var ids = SCCIDs();\n            var counts = new int[ids.Item1];\n            var groups = new int[ids.Item1][];\n            foreach (var x in ids.Item2) ++counts[x];\n            for (var i = 0; i < groups.Length; ++i) groups[i] = new int[counts[i]];\n            for (var i = 0; i < ids.Item2.Length; i++) groups[ids.Item2[i]][--counts[ids.Item2[i]]] = i;\n            return groups;\n        }\n    }\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_TwoSAT : LIB_SCC\n    {\n        // use LIB_SCC\n        int n;\n        public LIB_Bitset Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new LIB_Bitset(n);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath((i << 1) + (f ? 0 : 1), (j << 1) + (g ? 1 : 0));\n            base.AddPath((j << 1) + (g ? 0 : 1), (i << 1) + (f ? 1 : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < id.Length; i += 2)\n            {\n                if (id[i] == id[i + 1]) return false;\n                Answer[i >> 1] = id[i] < id[i + 1];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n    class LIB_BitUtil\n    {\n        public static readonly ulong[] BitMask;\n        static LIB_BitUtil()\n        {\n            BitMask = new ulong[64];\n            BitMask[0] = 1;\n            for (var i = 1; i < 64; i++) BitMask[i] = BitMask[i - 1] << 1;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public IEnumerable<long> ScanOne(long value)\n        {\n            for (; value > 0; value &= value - 1) yield return value & -value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(ulong value)\n        {\n            value = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n            value = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n            value = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n            value = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n            value = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n            value = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n            return (long)value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(long value) => PopCount((ulong)value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(ulong value, int idx) => (value & BitMask[idx]) != 0;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(long value, int idx) => IsSet((ulong)value, idx);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D) twosat.AddClause(i, false, j, false);\n                    if (Abs(XYList[i].X - XYList[j].Y) < D) twosat.AddClause(i, false, j, true);\n                    if (Abs(XYList[i].Y - XYList[j].X) < D) twosat.AddClause(i, true, j, false);\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D) twosat.AddClause(i, true, j, true);\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_Bitset : IEquatable<LIB_Bitset>\n    {\n        long n;\n        ulong[] ary;\n        static readonly ulong[] ceil;\n        static LIB_Bitset()\n        {\n            ceil = new ulong[64];\n            ceil[0] = 0xffffffffffffffff;\n            ceil[1] = 1;\n            for (var i = 2; i < 64; i++)\n            {\n                ceil[i] = (ceil[i - 1] << 1) | 1;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_Bitset(long size)\n        {\n            if (size <= 0) throw new Exception();\n            n = size;\n            ary = new ulong[((n - 1) >> 6) + 1];\n        }\n        public long Count => n;\n        public long PopCount => ary.Sum(e => LIB_BitUtil.PopCount(e));\n        public bool this[int idx]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return LIB_BitUtil.IsSet(ary[idx >> 6], idx & 63); }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (value) ary[idx >> 6] |= LIB_BitUtil.BitMask[idx & 63];\n                else ary[idx >> 6] &= ~LIB_BitUtil.BitMask[idx & 63];\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] &= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] |= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] ^= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] &= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] |= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] ^= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Flip()\n        {\n            for (var i = 0; i < ary.Length; i++) ary[i] = ~ary[i];\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ~(LIB_Bitset x)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = ~x.ary[i];\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftLeft(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ary.Length - 1; i >= moveCnt; i--)\n            {\n                ary[i] = ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ary[i] |= ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator <<(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ret.ary.Length - 1; i >= moveCnt; i--)\n            {\n                ret.ary[i] = x.ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ret.ary[i] |= x.ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftRight(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ary[i] = ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ary[i] |= ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator >>(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ret.ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ret.ary[i] = x.ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ret.ary[i] |= x.ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator ==(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var i = 0;\n            for (; i < y.ary.Length; i++) if (x.ary[i] != y.ary[i]) return false;\n            for (; i < x.ary.Length; i++) if (x.ary[i] != 0) return false;\n            return true;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator !=(LIB_Bitset x, LIB_Bitset y) => !(x == y);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Equals(LIB_Bitset x) => x == this;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override bool Equals(object x) => x == null ? false : Equals((LIB_Bitset)x);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override int GetHashCode()\n        {\n            var t = ary.Aggregate((a, x) => a ^ x);\n            return (int)(((t >> 32) ^ t) & 0x00000000ffffffff);\n        }\n    }\n    class LIB_BitUtil\n    {\n        public static readonly ulong[] BitMask;\n        static LIB_BitUtil()\n        {\n            BitMask = new ulong[64];\n            BitMask[0] = 1;\n            for (var i = 1; i < 64; i++) BitMask[i] = BitMask[i - 1] << 1;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public IEnumerable<long> ScanOne(long value)\n        {\n            for (; value > 0; value &= value - 1) yield return value & -value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(ulong value)\n        {\n            value = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n            value = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n            value = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n            value = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n            value = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n            value = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n            return (long)value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(long value) => PopCount((ulong)value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(ulong value, int idx) => (value & BitMask[idx]) != 0;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(long value, int idx) => IsSet((ulong)value, idx);\n    }\n    class LIB_SCC\n    {\n        int n;\n        List<long> edges;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_SCC(long n)\n        {\n            this.n = (int)n;\n            edges = new List<long>();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddPath(long from, long to) => edges.Add((from << 30) | to);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        protected (int, int[]) SCCIDs()\n        {\n            var start = new int[n + 1];\n            var elist = new int[edges.Count];\n            foreach (var e in edges) ++start[(e >> 30) + 1];\n            for (var i = 1; i < start.Length; ++i) start[i] += start[i - 1];\n            var counter = new int[n + 1];\n            for (var i = 0; i < counter.Length; i++) counter[i] = start[i];\n            foreach (var e in edges) elist[counter[e >> 30]++] = (int)(e & 1073741823);\n            var nowOrd = -1;\n            var groupNum = 0;\n            var visitedIdx = -1;\n            var visited = new int[n];\n            var low = new int[n];\n            var ord = new int[n];\n            var ids = new int[n];\n            for (var i = 0; i < ord.Length; i++) ord[i] = -1;\n            Action<int> dfs = null;\n            dfs = v =>\n            {\n                low[v] = ord[v] = ++nowOrd;\n                visited[++visitedIdx] = v;\n                for (var i = start[v]; i < start[v + 1]; ++i)\n                {\n                    var to = elist[i];\n                    if (ord[to] == -1)\n                    {\n                        dfs(to);\n                        low[v] = Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = Math.Min(low[v], ord[to]);\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = visited[visitedIdx];\n                        --visitedIdx;\n                        ord[u] = n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n                    ++groupNum;\n                }\n            };\n            for (var i = 0; i < ord.Length; ++i)\n            {\n                if (ord[i] == -1) dfs(i);\n            }\n            for (var i = 0; i < ids.Length; i++) ids[i] = groupNum - 1 - ids[i];\n            return (groupNum, ids);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int[][] SCC()\n        {\n            var ids = SCCIDs();\n            var counts = new int[ids.Item1];\n            var groups = new int[ids.Item1][];\n            foreach (var x in ids.Item2) ++counts[x];\n            for (var i = 0; i < groups.Length; ++i) groups[i] = new int[counts[i]];\n            for (var i = 0; i < ids.Item2.Length; i++) groups[ids.Item2[i]][--counts[ids.Item2[i]]] = i;\n            return groups;\n        }\n    }\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_TwoSAT : LIB_SCC\n    {\n        // use LIB_SCC\n        int n;\n        public LIB_Bitset Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new LIB_Bitset(n);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath((i << 1) + (f ? 0 : 1), (j << 1) + (g ? 1 : 0));\n            base.AddPath((j << 1) + (g ? 0 : 1), (i << 1) + (f ? 1 : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < n; ++i)\n            {\n                if (id[i << 1] == id[(i << 1) | 1]) return false;\n                Answer[i] = id[i << 1] < id[(i << 1) | 1];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing Training20200909.Algorithms;\nusing Training20200909.Collections;\nusing Training20200909.Extensions;\nusing Training20200909.Numerics;\nusing Training20200909.Questions;\nusing System.Diagnostics;\nusing AtCoder;\n\nnamespace Training20200909.Questions\n{\n    /// <summary>\n    /// https://atcoder.jp/contests/practice2/tasks/practice2_h\n    /// </summary>\n    public class QuestionB : AtCoderQuestionBase\n    {\n        public override IEnumerable<object> Solve(TextReader inputStream)\n        {\n            var (n, d) = inputStream.ReadValue<int, int>();\n            var flags = new Flag[n];\n            var twoSat = new TwoSat(n);\n\n            for (int i = 0; i < flags.Length; i++)\n            {\n                var (x, y) = inputStream.ReadValue<int, int>();\n                flags[i] = new Flag(x, y);\n            }\n\n            for (int i = 0; i < flags.Length; i++)\n            {\n                for (int j = i + 1; j < flags.Length; j++)\n                {\n                    if (Math.Abs(flags[i].X - flags[j].X) < d)\n                    {\n                        twoSat.AddClause(i, false, j, false);\n                    }\n                    if (Math.Abs(flags[i].X - flags[j].Y) < d)\n                    {\n                        twoSat.AddClause(i, false, j, true);\n                    }\n                    if (Math.Abs(flags[i].Y - flags[j].X) < d)\n                    {\n                        twoSat.AddClause(i, true, j, false);\n                    }\n                    if (Math.Abs(flags[i].Y - flags[j].Y) < d)\n                    {\n                        twoSat.AddClause(i, true, j, true);\n                    }\n                }\n            }\n\n            var canPlace = twoSat.Satisfiable();\n\n            if (canPlace)\n            {\n                yield return \"Yes\";\n                var results = twoSat.Answer();\n                for (int i = 0; i < results.Length; i++)\n                {\n                    yield return results[i] ? flags[i].X : flags[i].Y;\n                }\n            }\n            else\n            {\n                yield return \"No\";\n            }\n        }\n\n        [StructLayout(LayoutKind.Auto)]\n        readonly struct Flag\n        {\n            public int X { get; }\n            public int Y { get; }\n\n            public Flag(int x, int y)\n            {\n                X = x;\n                Y = y;\n            }\n\n            public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n            public override string ToString() => $\"{nameof(X)}: {X}, {nameof(Y)}: {Y}\";\n        }\n    }\n}\n\n\nnamespace AtCoder\n{\n    /// <summary>\n    /// 有向グラフを強連結成分分解します。\n    /// </summary>\n    [DebuggerDisplay(\"Vertices = {VerticesCount}, Edges = {edges.Count}\")]\n    public class SCCGraph\n    {\n        // ひとまず C++ 版 ACL に合わせ、自動プロパティは使用しない。\n        private readonly int _n;\n        private readonly List<Edge> edges;\n\n        /// <summary>\n        /// 有向グラフの頂点数を取得します。\n        /// </summary>\n        public int VerticesCount => _n;\n\n        /// <summary>\n        /// <see cref=\"SCCGraph\"/> クラスの新しいインスタンスを、<paramref name=\"n\"/> 頂点 0 辺の有向グラフとして初期化します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"n\"/>≤10^8</para>\n        /// <para>計算量: O(<paramref name=\"n\"/>)</para>\n        /// </remarks>\n        public SCCGraph(int n)\n        {\n            Debug.Assert(unchecked((uint)n <= 100_000_000));\n            _n = n;\n            edges = new List<Edge>();\n        }\n\n        /// <summary>\n        /// 頂点 <paramref name=\"from\"/> から頂点 <paramref name=\"to\"/> へ有向辺を追加します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"from\"/>, <paramref name=\"to\"/>&lt;n</para>\n        /// <para>計算量: ならしO(1)</para>\n        /// </remarks>\n        public void AddEdge(int from, int to)\n        {\n            Debug.Assert(unchecked((uint)from < _n));\n            Debug.Assert(unchecked((uint)to < _n));\n            edges.Add(new Edge(from, to));\n        }\n\n        /// <summary>\n        /// 強連結成分分解の結果である「頂点のリスト」のリストを取得します。\n        /// </summary>\n        /// <remarks>\n        /// <para>- 全ての頂点がちょうど1つずつ、どれかのリストに含まれます。</para>\n        /// <para>- 内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。</para>\n        /// <para>- リストはトポロジカルソートされています。異なる強連結成分の頂点 u, v について、u から v に到達できる時、u の属するリストは v の属するリストよりも前です。</para>\n        /// <para>計算量: 追加された辺の本数を m として O(n+m)</para>\n        /// </remarks>\n        public List<List<int>> SCC()\n        {\n            // R. Tarjan のアルゴリズム\n            var g = new CSR(_n, edges);\n            int nowOrd = 0;\n            var visited = new Stack<int>(_n);\n            var low = new int[_n];\n            var ord = Enumerable.Repeat(-1, _n).ToArray();\n\n            // 強連結成分分解結果\n            var sccs = new Stack<List<int>>();\n\n            for (int i = 0; i < ord.Length; i++)\n            {\n                if (ord[i] == -1)\n                {\n                    DFS(i);\n                }\n            }\n\n            // トポロジカル順序にするには逆順にする必要がある。\n            return sccs.ToList();\n\n            void DFS(int v)\n            {\n                low[v] = nowOrd;\n                ord[v] = nowOrd++;\n                visited.Push(v);\n\n                // 頂点 v から伸びる有向辺を探索する。\n                for (int i = g.Start[v]; i < g.Start[v + 1]; i++)\n                {\n                    int to = g.EList[i];\n                    if (ord[to] == -1)\n                    {\n                        DFS(to);\n                        low[v] = System.Math.Min(low[v], low[to]);\n                    }\n                    else\n                    {\n                        low[v] = System.Math.Min(low[v], ord[to]);\n                    }\n                }\n\n                // v がSCCの根である場合、強連結成分を List に詰める。\n                if (low[v] == ord[v])\n                {\n                    var scc = new List<int>();\n\n                    while (true)\n                    {\n                        int u = visited.Pop();\n                        ord[u] = _n;\n                        scc.Add(u);\n\n                        if (u == v)\n                        {\n                            break;\n                        }\n                    }\n\n                    sccs.Push(scc);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 有向グラフの辺集合を表します。\n        /// </summary>\n        /// <example>\n        /// <code>\n        /// for (int i = graph.Starts[v]; i < graph.Starts[v + 1]; i++)\n        /// {\n        ///     int to = graph.Edges[i];\n        /// }\n        /// </code>\n        /// </example>\n        private class CSR\n        {\n            /// <summary>\n            /// 各頂点から伸びる有向辺数の累積和を取得します。\n            /// </summary>\n            public int[] Start { get; }\n\n            /// <summary>\n            /// 有向辺の終点の配列を取得します。\n            /// </summary>\n            public int[] EList { get; }\n\n            public CSR(int n, List<Edge> edges)\n            {\n                // 本家 C++ 版 ACL を参考に実装。通常の隣接リストと比較して高速か否かは未検証。\n                Start = new int[n + 1];\n                EList = new int[edges.Count];\n\n                foreach (var e in edges)\n                {\n                    Start[e.From + 1]++;\n                }\n\n                for (int i = 1; i <= n; i++)\n                {\n                    Start[i] += Start[i - 1];\n                }\n\n                var counter = new int[Start.Length];\n                Start.CopyTo(counter, 0);\n                foreach (var e in edges)\n                {\n                    EList[counter[e.From]++] = e.To;\n                }\n            }\n        }\n\n        [DebuggerDisplay(\"From:{From}, To:{To}\")]\n        private readonly struct Edge\n        {\n            public int From { get; }\n            public int To { get; }\n\n            public Edge(int from, int to)\n            {\n                From = from;\n                To = to;\n            }\n        }\n    }\n\n    /// <summary>\n    /// 2-SATを解きます。 \n    /// <para>\n    /// 変数 x_0, x_1,…, x_{n-1} に関して (x_i=f)∨(x_j=g) というクローズを足し、これをすべて満たす変数の割当があるかを解きます。\n    /// </para>\n    /// </summary>\n    [DebuggerDisplay(\"Count = {_n}\")]\n    public class TwoSat\n    {\n        readonly int _n;\n        readonly private bool[] _answer;\n        readonly private SCCGraph scc;\n\n        /// <summary>\n        /// <see cref=\"TwoSat\"/> クラスの新しいインスタンスを、<paramref name=\"n\"/> 変数の 2-SAT として初期化します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約 : 0≤<paramref name=\"n\"/>≤10^8</para>\n        /// </remarks>\n        public TwoSat(int n)\n        {\n            Debug.Assert(unchecked((uint)n <= 100_000_000));\n            _n = n;\n            _answer = new bool[n];\n            scc = new SCCGraph(2 * n);\n        }\n\n        /// <summary>\n        /// (x_<paramref name=\"i\"/>=<paramref name=\"f\"/>)∨(x_<paramref name=\"j\"/>=<paramref name=\"g\"/>) というクローズを追加します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"i\"/>&lt;n, 0≤<paramref name=\"j\"/>&lt;n</para>\n        /// <para>計算量: ならし O(1)</para>\n        /// </remarks>\n        public void AddClause(int i, bool f, int j, bool g)\n        {\n            Debug.Assert(unchecked((uint)i < _n));\n            Debug.Assert(unchecked((uint)j < _n));\n            scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n\n        /// <summary>\n        /// 条件を満たす割当が存在するかどうかを判定します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 複数回呼ぶことも可能。</para>\n        /// <para>計算量: 足した制約の個数を m として O(n+m)</para>\n        /// </remarks>\n        /// <returns>割当が存在するならば <c>true</c>、そうでないなら <c>false</c>。</returns>\n        public bool Satisfiable()\n        {\n            var sccs = scc.SCC();\n            var id = new int[2 * _n];\n\n            // 強連結成分のリストを id として展開。\n            for (int i = 0; i < sccs.Count; i++)\n            {\n                foreach (var v in sccs[i])\n                {\n                    id[v] = i;\n                }\n            }\n\n            for (int i = 0; i < _n; i++)\n            {\n                if (id[2 * i] == id[2 * i + 1])\n                {\n                    return false;\n                }\n                else\n                {\n                    _answer[i] = id[2 * i] < id[2 * i + 1];\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// 最後に実行した <see cref=\"Satisfiable\"/> の、クローズを満たす割当を返します。実行前や、割当が存在しなかった場合は中身が未定義の長さ n の配列を返します。\n        /// </summary>\n        /// <remarks>\n        /// <para>計算量: O(n)</para>\n        /// </remarks>\n        /// <returns>最後に呼んだ <see cref=\"Satisfiable\"/> の、クローズを満たす割当の配列。</returns>\n        public bool[] Answer() => _answer;\n    }\n}\nnamespace Training20200909\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IAtCoderQuestion question = new QuestionB();\n            var answers = question.Solve(Console.In);\n\n            var writer = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(writer);\n            foreach (var answer in answers)\n            {\n                Console.WriteLine(answer);\n            }\n            Console.Out.Flush();\n        }\n    }\n}\n\n#region Base Class\n\nnamespace Training20200909.Questions\n{\n\n    public interface IAtCoderQuestion\n    {\n        IEnumerable<object> Solve(string input);\n        IEnumerable<object> Solve(TextReader inputStream);\n    }\n\n    public abstract class AtCoderQuestionBase : IAtCoderQuestion\n    {\n        public IEnumerable<object> Solve(string input)\n        {\n            var stream = new MemoryStream(Encoding.Unicode.GetBytes(input));\n            var reader = new StreamReader(stream, Encoding.Unicode);\n\n            return Solve(reader);\n        }\n\n        public abstract IEnumerable<object> Solve(TextReader inputStream);\n    }\n}\n\n#endregion\n\n#region Algorithm\n\nnamespace Training20200909.Numerics\n{\n    public static class NumericalAlgorithms\n    {\n        public static long Gcd(long a, long b)\n        {\n            if (a < b)\n            {\n                (a, b) = (b, a);\n            }\n\n            if (b > 0)\n            {\n                return Gcd(b, a % b);\n            }\n            else if (b == 0)\n            {\n                return a;\n            }\n            else\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(a)}, {nameof(b)}は0以上の整数である必要があります。\");\n            }\n        }\n\n        public static long Lcm(long a, long b)\n        {\n            if (a < 0 || b < 0)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(a)}, {nameof(b)}は0以上の整数である必要があります。\");\n            }\n\n            return a / Gcd(a, b) * b;\n        }\n\n        public static long Factorial(int n)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{n}は0以上の整数でなければなりません。\");\n            }\n\n            long result = 1;\n            for (int i = 2; i <= n; i++)\n            {\n                result *= i;\n            }\n            return result;\n        }\n\n        public static long Permutation(int n, int r)\n        {\n            CheckNR(n, r);\n            long result = 1;\n            for (int i = 0; i < r; i++)\n            {\n                result *= n - i;\n            }\n            return result;\n        }\n\n        public static long Combination(int n, int r)\n        {\n            CheckNR(n, r);\n            r = Math.Min(r, n - r);\n\n            // See https://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations\n            long result = 1;\n            for (int i = 1; i <= r; i++)\n            {\n                result *= n--;\n                result /= i;\n            }\n            return result;\n        }\n\n        public static long CombinationWithRepetition(int n, int r) => Combination(n + r - 1, r);\n\n        public static IEnumerable<(int prime, int count)> PrimeFactorization(int n)\n        {\n            if (n <= 1)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{n}は2以上の整数でなければなりません。\");\n            }\n\n            var dictionary = new Dictionary<int, int>();\n            for (int i = 2; i * i <= n; i++)\n            {\n                while (n % i == 0)\n                {\n                    if (dictionary.ContainsKey(i))\n                    {\n                        dictionary[i]++;\n                    }\n                    else\n                    {\n                        dictionary[i] = 1;\n                    }\n\n                    n /= i;\n                }\n            }\n\n            if (n > 1)\n            {\n                dictionary[n] = 1;\n            }\n\n            return dictionary.Select(p => (p.Key, p.Value));\n        }\n\n        private static void CheckNR(int n, int r)\n        {\n            if (n <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は正の整数でなければなりません。\");\n            }\n            if (r < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(r), $\"{nameof(r)}は0以上の整数でなければなりません。\");\n            }\n            if (n < r)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(n)},{nameof(r)}\", $\"{nameof(r)}は{nameof(n)}以下でなければなりません。\");\n            }\n        }\n    }\n\n    public readonly struct Modular : IEquatable<Modular>, IComparable<Modular>\n    {\n        private const int DefaultMod = 1000000007;\n        public int Value { get; }\n        public static int Mod { get; set; } = DefaultMod;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public Modular(long value)\n        {\n            if (unchecked((ulong)value) < unchecked((ulong)Mod))\n            {\n                Value = (int)value;\n            }\n            else\n            {\n                Value = (int)(value % Mod);\n                if (Value < 0)\n                {\n                    Value += Mod;\n                }\n            }\n        }\n\n        private Modular(int value) => Value = value;\n        public static Modular Zero => new Modular(0);\n        public static Modular One => new Modular(1);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator +(Modular a, Modular b)\n        {\n            var result = a.Value + b.Value;\n            if (result >= Mod)\n            {\n                result -= Mod;    // 剰余演算を避ける\n            }\n            return new Modular(result);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator -(Modular a, Modular b)\n        {\n            var result = a.Value - b.Value;\n            if (result < 0)\n            {\n                result += Mod;    // 剰余演算を避ける\n            }\n            return new Modular(result);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator *(Modular a, Modular b) => new Modular((long)a.Value * b.Value);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator /(Modular a, Modular b) => a * Pow(b.Value, Mod - 2);\n\n        // 需要は不明だけど一応\n        public static bool operator ==(Modular left, Modular right) => left.Equals(right);\n        public static bool operator !=(Modular left, Modular right) => !(left == right);\n        public static bool operator <(Modular left, Modular right) => left.CompareTo(right) < 0;\n        public static bool operator <=(Modular left, Modular right) => left.CompareTo(right) <= 0;\n        public static bool operator >(Modular left, Modular right) => left.CompareTo(right) > 0;\n        public static bool operator >=(Modular left, Modular right) => left.CompareTo(right) >= 0;\n\n        public static implicit operator Modular(long a) => new Modular(a);\n        public static explicit operator int(Modular a) => a.Value;\n        public static explicit operator long(Modular a) => a.Value;\n\n        public static Modular Pow(int a, int n)\n        {\n            if (n == 0)\n            {\n                return Modular.One;\n            }\n            else if (n == 1)\n            {\n                return a;\n            }\n            else if (n > 0)\n            {\n                var p = Pow(a, n >> 1);             // m / 2\n                return p * p * Pow(a, n & 0x01);    // m % 2\n            }\n            else\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"べき指数{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n        }\n\n        private static List<int> _factorialCache;\n        private static List<int> FactorialCache => _factorialCache ??= new List<int>() { 1 };\n        private static int[] FactorialInverseCache { get; set; }\n        const int defaultMaxFactorial = 1000000;\n\n        public static Modular Factorial(int n)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n\n            for (int i = FactorialCache.Count; i <= n; i++)  // Countが1（0!までキャッシュ済み）のとき1!～n!まで計算\n            {\n                FactorialCache.Add((int)((long)FactorialCache[i - 1] * i % Mod));\n            }\n            return new Modular(FactorialCache[n]);\n        }\n\n        public static Modular Permutation(int n, int r)\n        {\n            CheckNR(n, r);\n            return Factorial(n) / Factorial(n - r);\n        }\n\n        public static Modular Combination(int n, int r)\n        {\n            CheckNR(n, r);\n            r = Math.Min(r, n - r);\n            try\n            {\n                return new Modular(FactorialCache[n]) * new Modular(FactorialInverseCache[r]) * new Modular(FactorialInverseCache[n - r]);\n            }\n            catch (Exception ex) when (ex is NullReferenceException || ex is ArgumentOutOfRangeException)\n            {\n                throw new InvalidOperationException($\"{nameof(Combination)}を呼び出す前に{nameof(InitializeCombinationTable)}により前計算を行う必要があります。\", ex);\n            }\n        }\n\n        public static void InitializeCombinationTable(int max = defaultMaxFactorial)\n        {\n            Factorial(max);\n            FactorialInverseCache = new int[max + 1];\n\n            var fInv = (Modular.One / Factorial(max)).Value;\n            FactorialInverseCache[max] = fInv;\n            for (int i = max - 1; i >= 0; i--)\n            {\n                fInv = (int)((long)fInv * (i + 1) % Mod);\n                FactorialInverseCache[i] = fInv;\n            }\n        }\n\n        public static Modular CombinationWithRepetition(int n, int r) => Combination(n + r - 1, r);\n\n        private static void CheckNR(int n, int r)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n            if (r < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(r), $\"{nameof(r)}は0以上の整数でなければなりません。\");\n            }\n            if (n < r)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(n)},{nameof(r)}\", $\"{nameof(r)}は{nameof(n)}以下でなければなりません。\");\n            }\n        }\n\n        public override string ToString() => Value.ToString();\n        public override bool Equals(object obj) => obj is Modular m ? Equals(m) : false;\n        public bool Equals([System.Diagnostics.CodeAnalysis.AllowNull] Modular other) => Value == other.Value;\n        public int CompareTo([System.Diagnostics.CodeAnalysis.AllowNull] Modular other) => Value.CompareTo(other.Value);\n        public override int GetHashCode() => Value.GetHashCode();\n    }\n\n    public class ModMatrix\n    {\n        readonly Modular[] _values;\n        public int Height { get; }\n        public int Width { get; }\n\n        public Span<Modular> this[int row]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => _values.AsSpan(row * Width, Width);\n        }\n\n        public Modular this[int row, int column]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                if (unchecked((uint)row) >= Height)\n                    ThrowsArgumentOutOfRangeException(nameof(row));\n                else if (unchecked((uint)column) >= Width)\n                    ThrowsArgumentOutOfRangeException(nameof(column));\n                return _values[row * Width + column];\n            }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (unchecked((uint)row) >= Height)\n                    ThrowsArgumentOutOfRangeException(nameof(row));\n                else if (unchecked((uint)column) >= Width)\n                    ThrowsArgumentOutOfRangeException(nameof(column));\n                _values[row * Width + column] = value;\n            }\n        }\n\n        public ModMatrix(int n) : this(n, n) { }\n\n        public ModMatrix(int height, int width)\n        {\n            if (height <= 0)\n                throw new ArgumentOutOfRangeException(nameof(height));\n            if (width <= 0)\n                throw new ArgumentOutOfRangeException(nameof(width));\n            Height = height;\n            Width = width;\n            _values = new Modular[height * width];\n        }\n\n        public ModMatrix(Modular[][] values) : this(values.Length, values[0].Length)\n        {\n            for (int row = 0; row < Height; row++)\n            {\n                if (Width != values[row].Length)\n                    throw new ArgumentException($\"{nameof(values)}の列数は揃っている必要があります。\");\n                var span = _values.AsSpan(row * Width, Width);\n                values[row].AsSpan().CopyTo(span);\n            }\n        }\n\n        public ModMatrix(Modular[,] values) : this(values.GetLength(0), values.GetLength(1))\n        {\n            for (int row = 0; row < Height; row++)\n            {\n                var span = _values.AsSpan(row * Width, Width);\n                for (int column = 0; column < span.Length; column++)\n                {\n                    span[column] = values[row, column];\n                }\n            }\n        }\n\n        public ModMatrix(ModMatrix matrix)\n        {\n            Height = matrix.Height;\n            Width = matrix.Width;\n            _values = new Modular[matrix._values.Length];\n            matrix._values.AsSpan().CopyTo(_values);\n        }\n\n        public static ModMatrix GetIdentity(int dimension)\n        {\n            var result = new ModMatrix(dimension);\n            for (int i = 0; i < dimension; i++)\n            {\n                result._values[i * result.Width + i] = 1;\n            }\n            return result;\n        }\n\n        public static ModMatrix operator +(ModMatrix a, ModMatrix b)\n        {\n            CheckSameShape(a, b);\n\n            var result = new ModMatrix(a.Height, a.Width);\n            for (int i = 0; i < result._values.Length; i++)\n            {\n                result._values[i] = a._values[i] + b._values[i];\n            }\n            return result;\n        }\n\n        public static ModMatrix operator -(ModMatrix a, ModMatrix b)\n        {\n            CheckSameShape(a, b);\n\n            var result = new ModMatrix(a.Height, a.Width);\n            for (int i = 0; i < result._values.Length; i++)\n            {\n                result._values[i] = a._values[i] - b._values[i];\n            }\n            return result;\n        }\n\n        public static ModMatrix operator *(ModMatrix a, ModMatrix b)\n        {\n            if (a.Width != b.Height)\n                throw new ArgumentException($\"{nameof(a)}の列数と{nameof(b)}の行数は等しくなければなりません。\");\n\n            var result = new ModMatrix(a.Height, b.Width);\n            for (int i = 0; i < result.Height; i++)\n            {\n                var aSpan = a._values.AsSpan(i * a.Width, a.Width);\n                var resultSpan = result._values.AsSpan(i * result.Width, result.Width);\n                for (int k = 0; k < aSpan.Length; k++)\n                {\n                    var bSpan = b._values.AsSpan(k * b.Width, b.Width);\n                    for (int j = 0; j < resultSpan.Length; j++)\n                    {\n                        resultSpan[j] += aSpan[k] * bSpan[j];\n                    }\n                }\n            }\n            return result;\n        }\n\n        public static ModVector operator *(ModMatrix matrix, ModVector vector)\n        {\n            if (matrix.Width != vector.Length)\n                throw new ArgumentException($\"{nameof(matrix)}の列数と{nameof(vector)}の行数は等しくなければなりません。\");\n\n            var result = new ModVector(vector.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                var matrixSpan = matrix[i];\n                for (int k = 0; k < matrixSpan.Length; k++)\n                {\n                    result[i] += matrixSpan[k] * vector[k];\n                }\n            }\n            return result;\n        }\n\n        public ModMatrix Pow(long pow)\n        {\n            if (Height != Width)\n                throw new ArgumentException(\"累乗を行う行列は正方行列である必要があります。\");\n            if (pow < 0)\n                throw new ArgumentException($\"{nameof(pow)}は0以上の整数である必要があります。\");\n\n            var powMatrix = new ModMatrix(this);\n            var result = GetIdentity(Height);\n            while (pow > 0)\n            {\n                if ((pow & 1) > 0)\n                {\n                    result *= powMatrix;\n                }\n                powMatrix *= powMatrix;\n                pow >>= 1;\n            }\n            return result;\n        }\n\n        private static void CheckSameShape(ModMatrix a, ModMatrix b)\n        {\n            if (a.Height != b.Height)\n                throw new ArgumentException($\"{nameof(a)}の行数と{nameof(b)}の行数は等しくなければなりません。\");\n            else if (a.Width != b.Width)\n                throw new ArgumentException($\"{nameof(a)}の列数と{nameof(b)}の列数は等しくなければなりません。\");\n        }\n\n        private void ThrowsArgumentOutOfRangeException(string paramName) => throw new ArgumentOutOfRangeException(paramName);\n        public override string ToString() => $\"({Height}x{Width})matrix\";\n    }\n\n    public class ModVector\n    {\n        readonly Modular[] _values;\n        public int Length => _values.Length;\n\n        public ModVector(int length)\n        {\n            if (length <= 0)\n                throw new ArgumentOutOfRangeException(nameof(length));\n            _values = new Modular[length];\n        }\n\n        public ModVector(ReadOnlySpan<Modular> vector)\n        {\n            _values = new Modular[vector.Length];\n            vector.CopyTo(_values);\n        }\n\n        public ModVector(ModVector vector) : this(vector._values) { }\n\n        public Modular this[int index]\n        {\n            get => _values[index];\n            set => _values[index] = value;\n        }\n\n        public static ModVector operator +(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = new ModVector(a.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                result[i] = a[i] + b[i];\n            }\n            return result;\n        }\n\n        public static ModVector operator -(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = new ModVector(a.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                result[i] = a[i] - b[i];\n            }\n            return result;\n        }\n\n        public static Modular operator *(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = Modular.Zero;\n            for (int i = 0; i < a.Length; i++)\n            {\n                result += a[i] * b[i];\n            }\n            return result;\n        }\n\n        public override string ToString() => $\"({Length})vector\";\n    }\n\n    public readonly struct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n    {\n        /// <summary>分子</summary>\n        public long Numerator { get; }\n        /// <summary>分母</summary>\n        public long Denominator { get; }\n\n        public static Fraction Nan => new Fraction(0, 0);\n        public static Fraction PositiveInfinity => new Fraction(1, 0);\n        public static Fraction NegativeInfinity => new Fraction(-1, 0);\n        public bool IsNan => Numerator == 0 && Denominator == 0;\n        public bool IsInfinity => Numerator != 0 && Denominator == 0;\n        public bool IsPositiveInfinity => Numerator > 0 && Denominator == 0;\n        public bool IsNegativeInfinity => Numerator < 0 && Denominator == 0;\n\n        /// <summary>\n        /// <c>Fraction</c>クラスの新しいインスタンスを生成します。\n        /// </summary>\n        /// <param name=\"numerator\">分子</param>\n        /// <param name=\"denominator\">分母</param>\n        public Fraction(long numerator, long denominator)\n        {\n            if (denominator == 0)\n            {\n                Numerator = Math.Sign(numerator);\n                Denominator = 0;\n            }\n            else if (numerator == 0)\n            {\n                Numerator = 0;\n                Denominator = 1;\n            }\n            else\n            {\n                var sign = Math.Sign(numerator) * Math.Sign(denominator);\n                numerator = Math.Abs(numerator);\n                denominator = Math.Abs(denominator);\n                var gcd = NumericalAlgorithms.Gcd(numerator, denominator);\n                Numerator = sign * numerator / gcd;\n                Denominator = denominator / gcd;\n            }\n        }\n\n        public static Fraction operator +(in Fraction left, in Fraction right)\n        {\n            if (left.IsNan || right.IsNan)\n            {\n                return Nan;\n            }\n            else if (left.IsInfinity || right.IsInfinity)\n            {\n                if (!right.IsInfinity)\n                {\n                    return left;\n                }\n                else if (!left.IsInfinity)\n                {\n                    return right;\n                }\n                else\n                {\n                    return new Fraction(left.Numerator + right.Numerator, 0);\n                }\n            }\n            else\n            {\n                var lcm = NumericalAlgorithms.Lcm(left.Denominator, right.Denominator);\n                return new Fraction(left.Numerator * (lcm / left.Denominator) + right.Numerator * (lcm / right.Denominator), lcm);\n            }\n        }\n        public static Fraction operator -(in Fraction left, in Fraction right) => left + -right;\n        public static Fraction operator *(in Fraction left, in Fraction right) => new Fraction(left.Numerator * right.Numerator, left.Denominator * right.Denominator);\n        public static Fraction operator /(in Fraction left, in Fraction right) => new Fraction(left.Numerator * right.Denominator, left.Denominator * right.Numerator);\n        public static Fraction operator +(in Fraction right) => right;\n        public static Fraction operator -(in Fraction right) => new Fraction(-right.Numerator, right.Denominator);\n        public static bool operator ==(in Fraction left, in Fraction right) => left.Equals(right);\n        public static bool operator !=(in Fraction left, in Fraction right) => !(left == right);\n        public static implicit operator double(in Fraction right)\n        {\n            if (right.IsNan)\n            {\n                return double.NaN;\n            }\n            else if (right.IsPositiveInfinity)\n            {\n                return double.PositiveInfinity;\n            }\n            else if (right.IsNegativeInfinity)\n            {\n                return double.NegativeInfinity;\n            }\n            else\n            {\n                return (double)right.Numerator / right.Denominator;\n            }\n        }\n\n        public override string ToString()\n        {\n            if (IsNan)\n            {\n                return \"NaN\";\n            }\n            else if (IsPositiveInfinity)\n            {\n                return \"Inf\";\n            }\n            else if (IsNegativeInfinity)\n            {\n                return \"-Inf\";\n            }\n            else\n            {\n                return $\"{Numerator}/{Denominator}\";\n            }\n        }\n\n        public override bool Equals(object obj) => obj is Fraction fraction && Equals(fraction);\n        public bool Equals(Fraction other) => Numerator == other.Numerator && Denominator == other.Denominator;\n        public override int GetHashCode() => HashCode.Combine(Numerator, Denominator);\n        public int CompareTo([System.Diagnostics.CodeAnalysis.AllowNull] Fraction other) => ((double)this).CompareTo(other);\n    }\n\n    public interface ISemigroup<TSet> where TSet : ISemigroup<TSet>\n    {\n        public TSet Multiply(TSet other);\n        public static TSet operator *(ISemigroup<TSet> a, TSet b) => a.Multiply(b);\n    }\n\n    public interface IMonoid<TSet> : ISemigroup<TSet> where TSet : IMonoid<TSet>, new()\n    {\n        public TSet Identity { get; }\n    }\n\n    public interface IGroup<TSet> : IMonoid<TSet> where TSet : IGroup<TSet>, new()\n    {\n        public TSet Invert();\n        public static TSet operator ~(IGroup<TSet> a) => a.Invert();\n    }\n\n}\n\nnamespace Training20200909.Algorithms\n{\n    public static class ZAlgorithm\n    {\n        public static int[] SearchAll(string s) => SearchAll(s.AsSpan());\n\n        public static int[] SearchAll<T>(ReadOnlySpan<T> s) where T : IEquatable<T>\n        {\n            var z = new int[s.Length];\n            z[0] = s.Length;\n            var offset = 1;\n            var length = 0;\n\n            while (offset < s.Length)\n            {\n                while (offset + length < s.Length && s[length].Equals(s[offset + length]))\n                {\n                    length++;\n                }\n                z[offset] = length;\n\n                if (length == 0)\n                {\n                    offset++;\n                    continue;\n                }\n\n                int copyLength = 1;\n                while (copyLength < length && copyLength + z[copyLength] < length)\n                {\n                    z[offset + copyLength] = z[copyLength];\n                    copyLength++;\n                }\n                offset += copyLength;\n                length -= copyLength;\n            }\n\n            return z;\n        }\n    }\n\n    /// <summary>\n    /// MP法（文字列検索アルゴリズム）\n    /// </summary>\n    public class MorrisPratt<T> where T : IEquatable<T>\n    {\n        readonly T[] _searchSequence;\n        readonly int[] _matchLength;\n\n        public ReadOnlySpan<T> SearchSequence => _searchSequence.AsSpan();\n\n        /// <summary>\n        /// 検索データ列の前処理を行います。\n        /// </summary>\n        /// <param name=\"searchSequence\">検索データ列</param>\n        public MorrisPratt(ReadOnlySpan<T> searchSequence)\n        {\n            _searchSequence = searchSequence.ToArray();\n            _matchLength = new int[_searchSequence.Length + 1];\n            _matchLength[0] = -1;\n            int j = -1;\n            for (int i = 0; i < _searchSequence.Length; i++)\n            {\n                while (j != -1 && !_searchSequence[j].Equals(_searchSequence[i]))\n                {\n                    j = _matchLength[j];\n                }\n                j++;\n                _matchLength[i + 1] = j;\n            }\n        }\n\n        /// <summary>\n        /// 与えられた対象データ列の部分列のうち、検索データ列にマッチする部分列の開始インデックスを取得します。\n        /// </summary>\n        /// <param name=\"targetSequence\">検索対象データ列</param>\n        /// <returns></returns>\n        public List<int> SearchAll(ReadOnlySpan<T> targetSequence)\n        {\n            var results = new List<int>();\n            int j = 0;\n            for (int i = 0; i < targetSequence.Length; i++)\n            {\n                while (j != -1 && !_searchSequence[j].Equals(targetSequence[i]))\n                {\n                    j = _matchLength[j];\n                }\n                j++;\n                if (j == _searchSequence.Length)\n                {\n                    results.Add(i - j + 1);\n                    j = _matchLength[j];\n                }\n            }\n            return results;\n        }\n    }\n\n    /// <summary>\n    /// 参考: https://qiita.com/keymoon/items/11fac5627672a6d6a9f6\n    /// ジェネリクスに対応させるにはGetHashCode()を足していく？実装によっては重そうなのでとりあえずパス。\n    /// </summary>\n    public class RollingHash\n    {\n        const ulong Mask30 = (1UL << 30) - 1;\n        const ulong Mask31 = (1UL << 31) - 1;\n        const ulong Mod = (1UL << 61) - 1;\n        const ulong Positivizer = Mod * ((1UL << 3) - 1);   // 引き算する前に足すことでmodが負になることを防ぐやつ\n        static readonly uint base1;\n        static readonly uint base2;\n        static readonly List<ulong> pow1;\n        static readonly List<ulong> pow2;\n\n        static RollingHash()\n        {\n            var random = new Random();\n            base1 = (uint)random.Next(129, int.MaxValue >> 2);\n            base2 = (uint)random.Next(int.MaxValue >> 2, int.MaxValue); // 32bit目は0にしておく\n            pow1 = new List<ulong>() { 1 };\n            pow2 = new List<ulong>() { 1 };\n        }\n\n        ulong[] hash1;\n        ulong[] hash2;\n        public string RawString { get; }\n        public int Length => RawString.Length;\n\n        public RollingHash(string s)\n        {\n            RawString = s;\n            hash1 = new ulong[s.Length + 1];\n            hash2 = new ulong[s.Length + 1];\n\n            for (int i = pow1.Count; i < s.Length + 1; i++)\n            {\n                pow1.Add(CalculateModular(Multiply(pow1[i - 1], base1)));\n                pow2.Add(CalculateModular(Multiply(pow2[i - 1], base2)));\n            }\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                hash1[i + 1] = CalculateModular(Multiply(hash1[i], base1) + s[i]);\n                hash2[i + 1] = CalculateModular(Multiply(hash2[i], base2) + s[i]);\n            }\n        }\n\n        public (ulong, ulong) this[Range range]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                var (offset, length) = range.GetOffsetAndLength(Length);\n                return Slice(offset, length);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public (ulong, ulong) Slice(int begin, int length)\n        {\n            var result1 = CalculateModular(hash1[begin + length] + Positivizer - Multiply(hash1[begin], pow1[length]));\n            var result2 = CalculateModular(hash2[begin + length] + Positivizer - Multiply(hash2[begin], pow2[length]));\n            return (result1, result2);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong Multiply(ulong l, ulong r)\n        {\n            var lu = l >> 31;\n            var ll = l & Mask31;\n            var ru = r >> 31;\n            var rl = r & Mask31;\n            var mid = ll * ru + lu * rl;\n            return ((lu * ru) << 1) + ll * rl + ((mid & Mask30) << 31) + (mid >> 30);   // a * 2^61 ≡ a (mod 2^61 - 1)を使う\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong Multiply(ulong l, uint r)\n        {\n            var lu = l >> 31;\n            var mid = lu * r;\n            return (l & Mask31) * r + ((mid & Mask30) << 31) + (mid >> 30); // rの32bit目は0としている\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong CalculateModular(ulong value)\n        {\n            value = (value & Mod) + (value >> 61);\n            if (value >= Mod)\n            {\n                value -= Mod;\n            }\n            return value;\n        }\n\n        public override string ToString() => RawString;\n    }\n\n    public class XorShift\n    {\n        ulong _x;\n\n        public XorShift() : this((ulong)DateTime.Now.Ticks) { }\n\n        public XorShift(ulong seed)\n        {\n            _x = seed;\n        }\n\n        /// <summary>\n        /// [0, (2^64)-1)の乱数を生成します。\n        /// </summary>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong Next()\n        {\n            _x = _x ^ (_x << 13);\n            _x = _x ^ (_x >> 7);\n            _x = _x ^ (_x << 17);\n            return _x;\n        }\n\n        /// <summary>\n        /// [0, <c>exclusiveMax</c>)の乱数を生成します。\n        /// </summary>\n        /// <param name=\"exclusiveMax\"></param>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int Next(int exclusiveMax) => (int)(Next() % (uint)exclusiveMax);\n\n        /// <summary>\n        /// [0.0, 1.0)の乱数を生成します。\n        /// </summary>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public double NextDouble()\n        {\n            const ulong max = 1UL << 50;\n            const ulong mask = max - 1;\n            return (double)(Next() & mask) / max;\n        }\n    }\n\n    public static class AlgorithmHelpers\n    {\n        public static void UpdateWhenSmall<T>(ref T value, T other) where T : IComparable<T>\n        {\n            if (other.CompareTo(value) < 0)\n            {\n                value = other;\n            }\n        }\n\n        public static void UpdateWhenLarge<T>(ref T value, T other) where T : IComparable<T>\n        {\n            if (other.CompareTo(value) > 0)\n            {\n                value = other;\n            }\n        }\n    }\n\n    public class CoordinateShrinker<T> : IEnumerable<(int shrinkedIndex, T rawIndex)> where T : IComparable<T>, IEquatable<T>\n    {\n        Dictionary<T, int> _shrinkMapper;\n        T[] _expandMapper;\n        public int Count => _expandMapper.Length;\n\n        public CoordinateShrinker(IEnumerable<T> data)\n        {\n            _expandMapper = data.Distinct().ToArray();\n            Array.Sort(_expandMapper);\n\n            _shrinkMapper = new Dictionary<T, int>();\n            for (int i = 0; i < _expandMapper.Length; i++)\n            {\n                _shrinkMapper.Add(_expandMapper[i], i);\n            }\n        }\n\n        public int Shrink(T rawCoordinate) => _shrinkMapper[rawCoordinate];\n        public T Expand(int shrinkedCoordinate) => _expandMapper[shrinkedCoordinate];\n\n        public IEnumerator<(int shrinkedIndex, T rawIndex)> GetEnumerator()\n        {\n            for (int i = 0; i < _expandMapper.Length; i++)\n            {\n                yield return (i, _expandMapper[i]);\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n\n#endregion\n\n#region Collections\n\nnamespace Training20200909.Collections\n{\n    // See https://kumikomiya.com/competitive-programming-with-c-sharp/\n    public class UnionFindTree\n    {\n        private UnionFindNode[] _nodes;\n        public int Count => _nodes.Length;\n        public int Groups { get; private set; }\n\n        public UnionFindTree(int count)\n        {\n            _nodes = Enumerable.Range(0, count).Select(i => new UnionFindNode(i)).ToArray();\n            Groups = _nodes.Length;\n        }\n\n        public void Unite(int index1, int index2)\n        {\n            var succeed = _nodes[index1].Unite(_nodes[index2]);\n            if (succeed)\n            {\n                Groups--;\n            }\n        }\n\n        public bool IsInSameGroup(int index1, int index2) => _nodes[index1].IsInSameGroup(_nodes[index2]);\n        public int GetGroupSizeOf(int index) => _nodes[index].GetGroupSize();\n\n        private class UnionFindNode\n        {\n            private int _height;        // rootのときのみ有効\n            private int _groupSize;     // 同上\n            private UnionFindNode _parent;\n            public int ID { get; }\n\n            public UnionFindNode(int id)\n            {\n                _height = 0;\n                _groupSize = 1;\n                _parent = this;\n                ID = id;\n            }\n\n            public UnionFindNode FindRoot()\n            {\n                if (_parent != this) // not ref equals\n                {\n                    var root = _parent.FindRoot();\n                    _parent = root;\n                }\n\n                return _parent;\n            }\n\n            public int GetGroupSize() => FindRoot()._groupSize;\n\n            public bool Unite(UnionFindNode other)\n            {\n                var thisRoot = this.FindRoot();\n                var otherRoot = other.FindRoot();\n\n                if (thisRoot == otherRoot)\n                {\n                    return false;\n                }\n\n                if (thisRoot._height < otherRoot._height)\n                {\n                    thisRoot._parent = otherRoot;\n                    otherRoot._groupSize += thisRoot._groupSize;\n                    otherRoot._height = Math.Max(thisRoot._height + 1, otherRoot._height);\n                    return true;\n                }\n                else\n                {\n                    otherRoot._parent = thisRoot;\n                    thisRoot._groupSize += otherRoot._groupSize;\n                    thisRoot._height = Math.Max(otherRoot._height + 1, thisRoot._height);\n                    return true;\n                }\n            }\n\n            public bool IsInSameGroup(UnionFindNode other) => this.FindRoot() == other.FindRoot();\n\n            public override string ToString() => $\"{ID} root:{FindRoot().ID}\";\n        }\n    }\n\n    public class Deque<T> : IReadOnlyCollection<T>\n    {\n        public int Count { get; private set; }\n        private T[] _data;\n        private int _first;\n        private int _mask;\n\n        public Deque() : this(4) { }\n\n        public Deque(int minCapacity)\n        {\n            if (minCapacity <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(minCapacity), $\"{nameof(minCapacity)}は0より大きい値でなければなりません。\");\n            }\n            var capacity = GetPow2Over(minCapacity);\n            _data = new T[capacity];\n            _first = 0;\n            _mask = capacity - 1;\n        }\n\n        public Deque(IEnumerable<T> collection)\n        {\n            var dataArray = collection.ToArray();\n            var capacity = GetPow2Over(dataArray.Length);\n            _data = new T[capacity];\n            _first = 0;\n            _mask = capacity - 1;\n\n            for (int i = 0; i < dataArray.Length; i++)\n            {\n                _data[i] = dataArray[i];\n                Count++;\n            }\n        }\n\n        public T this[Index index]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                var offset = index.GetOffset(Count);\n                if (unchecked((uint)offset) >= Count)\n                {\n                    ThrowArgumentOutOfRangeException(nameof(index), $\"{nameof(index)}がコレクションの範囲外です。\");\n                }\n                return _data[(_first + offset) & _mask];\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void EnqueueFirst(T item)\n        {\n            if (_data.Length == Count)\n            {\n                Resize();\n            }\n\n            _first = (_first - 1) & _mask;\n            _data[_first] = item;\n            Count++;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void EnqueueLast(T item)\n        {\n            if (_data.Length == Count)\n            {\n                Resize();\n            }\n\n            _data[(_first + Count++) & _mask] = item;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T DequeueFirst()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            var value = _data[_first];\n            _data[_first++] = default;\n            _first &= _mask;\n            return value;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T DequeueLast()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            var index = (_first + --Count) & _mask;\n            var value = _data[index];\n            _data[index] = default;\n            return value;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T PeekFirst()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            return _data[_first];\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T PeekLast()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            return _data[(_first + Count - 1) & _mask];\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Resize()\n        {\n            var newArray = new T[_data.Length << 1];\n            var span = _data.AsSpan();\n            var firstHalf = span[_first..];\n            var lastHalf = span[.._first];\n            firstHalf.CopyTo(newArray);\n            lastHalf.CopyTo(newArray.AsSpan(firstHalf.Length));\n            _data = newArray;\n            _first = 0;\n            _mask = _data.Length - 1;\n        }\n\n        private void ThrowArgumentOutOfRangeException(string paramName, string message) => throw new ArgumentOutOfRangeException(paramName, message);\n        private void ThrowInvalidOperationException(string message) => throw new InvalidOperationException(message);\n\n        private int GetPow2Over(int n)\n        {\n            n--;\n            var result = 1;\n            while (n != 0)\n            {\n                n >>= 1;\n                result <<= 1;\n            }\n            return result;\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (int i = 0; i < Count; i++)\n            {\n                var offset = (_first + i) & _mask;\n                yield return _data[offset];\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class PriorityQueue<T> : IEnumerable<T> where T : IComparable<T>\n    {\n        private List<T> _heap = new List<T>();\n        private readonly int _reverseFactor;\n        public int Count => _heap.Count;\n        public bool IsDescending => _reverseFactor == 1;\n\n        public PriorityQueue(bool descending) : this(descending, null) { }\n\n        public PriorityQueue(bool descending, IEnumerable<T> collection)\n        {\n            _reverseFactor = descending ? 1 : -1;\n            _heap = new List<T>();\n\n            if (collection != null)\n            {\n                foreach (var item in collection)\n                {\n                    Enqueue(item);\n                }\n            }\n        }\n\n        public void Enqueue(T item)\n        {\n            _heap.Add(item);\n            UpHeap();\n        }\n\n        public T Dequeue()\n        {\n            var item = _heap[0];\n            DownHeap();\n            return item;\n        }\n\n        public T Peek() => _heap[0];\n\n        private void UpHeap()\n        {\n            var child = Count - 1;\n            while (child > 0)\n            {\n                int parent = (child - 1) / 2;\n\n                if (Compare(_heap[child], _heap[parent]) > 0)\n                {\n                    SwapAt(child, parent);\n                    child = parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n\n        private void DownHeap()\n        {\n            _heap[0] = _heap[Count - 1];\n            _heap.RemoveAt(Count - 1);\n\n            var parent = 0;\n            while (true)\n            {\n                var leftChild = 2 * parent + 1;\n\n                if (leftChild > Count - 1)\n                {\n                    break;\n                }\n\n                var target = (leftChild < Count - 1) && (Compare(_heap[leftChild], _heap[leftChild + 1]) < 0) ? leftChild + 1 : leftChild;\n\n                if (Compare(_heap[parent], _heap[target]) < 0)\n                {\n                    SwapAt(parent, target);\n                }\n                else\n                {\n                    break;\n                }\n\n                parent = target;\n            }\n        }\n\n        private int Compare(T a, T b) => _reverseFactor * a.CompareTo(b);\n\n        private void SwapAt(int n, int m) => (_heap[n], _heap[m]) = (_heap[m], _heap[n]);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            var copy = new List<T>(_heap);\n            try\n            {\n                while (Count > 0)\n                {\n                    yield return Dequeue();\n                }\n            }\n            finally\n            {\n                _heap = copy;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class SegmentTree<TMonoid> : IEnumerable<TMonoid> where TMonoid : IMonoid<TMonoid>, new()\n    {\n        private readonly TMonoid[] _data;\n        private readonly TMonoid _identityElement;\n\n        private readonly int _leafOffset;   // n - 1\n        private readonly int _leafLength;   // n (= 2^k)\n\n        public int Length { get; }          // 実データ長\n        public ReadOnlySpan<TMonoid> Data => _data.AsSpan(_leafOffset, Length);\n\n        public SegmentTree(ICollection<TMonoid> data)\n        {\n            Length = data.Count;\n            _leafLength = GetMinimumPow2(data.Count);\n            _leafOffset = _leafLength - 1;\n            _data = new TMonoid[_leafOffset + _leafLength];\n            _identityElement = new TMonoid().Identity;\n\n            data.CopyTo(_data, _leafOffset);\n            BuildTree();\n        }\n\n        public TMonoid this[int index]\n        {\n            get => Data[index];\n            set\n            {\n                if (index < 0 || index >= Length)\n                {\n                    throw new IndexOutOfRangeException($\"{nameof(index)}がデータの範囲外です。\");\n                }\n                index += _leafOffset;\n                _data[index] = value;\n                while (index > 0)\n                {\n                    // 一つ上の親の更新\n                    index = (index - 1) / 2;\n                    _data[index] = _data[index * 2 + 1] * _data[index * 2 + 2];\n                }\n            }\n        }\n\n        public TMonoid Query(Range range)\n        {\n            var (offset, length) = range.GetOffsetAndLength(Length);\n            if (length <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(range), $\"{nameof(range)}の長さは0より大きくなければなりません。\");\n            }\n            return Query(offset, offset + length);\n        }\n\n        public TMonoid Query(int begin, int end)\n        {\n            if (begin < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(begin), $\"{nameof(begin)}は0以上の数でなければなりません。\");\n            }\n            if (end > Length)\n            {\n                throw new ArgumentOutOfRangeException(nameof(end), $\"{nameof(end)}は{nameof(Length)}以下でなければなりません。\");\n            }\n            if (begin >= end)\n            {\n                throw new ArgumentException($\"{nameof(begin)},{nameof(end)}\", $\"{nameof(end)}は{nameof(begin)}より大きい数でなければなりません。\");\n            }\n            return Query(begin, end, 0, 0, _leafLength);\n        }\n\n        private TMonoid Query(int begin, int end, int index, int left, int right)\n        {\n            if (right <= begin || end <= left)      // 範囲外\n            {\n                return _identityElement;\n            }\n            else if (begin <= left && right <= end) // 全部含まれる\n            {\n                return _data[index];\n            }\n            else    // 一部だけ含まれる\n            {\n                var leftValue = Query(begin, end, index * 2 + 1, left, (left + right) / 2);     // 左の子\n                var rightValue = Query(begin, end, index * 2 + 2, (left + right) / 2, right);   // 右の子\n                return leftValue * rightValue;\n            }\n        }\n\n        private void BuildTree()\n        {\n            foreach (ref var unusedLeaf in _data.AsSpan()[(_leafOffset + Length)..])\n            {\n                unusedLeaf = _identityElement;  // 単位元埋め\n            }\n\n            for (int i = _leafLength - 2; i >= 0; i--)  // 葉の親から順番に一つずつ上がっていく\n            {\n                _data[i] = _data[2 * i + 1] * _data[2 * i + 2]; // f(left, right)\n            }\n        }\n\n        private int GetMinimumPow2(int n)\n        {\n            var p = 1;\n            while (p < n)\n            {\n                p *= 2;\n            }\n            return p;\n        }\n\n        public IEnumerator<TMonoid> GetEnumerator()\n        {\n            var upperIndex = _leafOffset + Length;\n            for (int i = _leafOffset; i < upperIndex; i++)\n            {\n                yield return _data[i];\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class BinaryIndexedTree\n    {\n        long[] _data;\n        public int Length { get; }\n\n        public BinaryIndexedTree(int length)\n        {\n            _data = new long[length + 1];   // 内部的には1-indexedにする\n            Length = length;\n        }\n\n        public BinaryIndexedTree(IEnumerable<long> data, int length) : this(length)\n        {\n            var count = 0;\n            foreach (var n in data)\n            {\n                AddAt(count++, n);\n            }\n        }\n\n        public BinaryIndexedTree(ICollection<long> collection) : this(collection, collection.Count) { }\n\n        public long this[Index index]\n        {\n            get => Sum(index..(index.GetOffset(Length) + 1));\n            set\n            {\n                if (value < 0)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(value), $\"{nameof(value)}は0以上の値である必要があります。\");\n                }\n                AddAt(index, value - this[index]);\n            }\n        }\n\n        /// <summary>\n        /// BITの<c>index</c>番目の要素に<c>n</c>を加算します。\n        /// </summary>\n        /// <param name=\"index\">加算するインデックス（0-indexed）</param>\n        /// <param name=\"value\">加算する数</param>\n        public void AddAt(Index index, long value)\n        {\n            var i = index.GetOffset(Length);\n            unchecked\n            {\n                if ((uint)i >= (uint)Length)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(index));\n                }\n            }\n\n            i++;  // 1-indexedにする\n\n            while (i <= Length)\n            {\n                _data[i] += value;\n                i += i & -i;    // LSBの加算\n            }\n        }\n\n        /// <summary>\n        /// [0, <c>end</c>)の部分和を返します。\n        /// </summary>\n        /// <param name=\"end\">部分和を求める半開区間の終了インデックス</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(Index end)\n        {\n            var i = end.GetOffset(Length);  // 0-indexedの半開区間＝1-indexedの閉区間なので+1は不要\n            unchecked\n            {\n                if ((uint)i >= (uint)_data.Length)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(end));\n                }\n            }\n\n            long sum = 0;\n            while (i > 0)\n            {\n                sum += _data[i];\n                i -= i & -i;    // LSBの減算\n            }\n            return sum;\n        }\n\n        /// <summary>\n        /// <c>range</c>の部分和を返します。\n        /// </summary>\n        /// <param name=\"range\">部分和を求める半開区間</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(Range range) => Sum(range.End) - Sum(range.Start);\n\n        /// <summary>\n        /// [<c>start</c>, <c>end</c>)の部分和を返します。\n        /// </summary>\n        /// <param name=\"start\">部分和を求める半開区間の開始インデックス</param>\n        /// <param name=\"end\">部分和を求める半開区間の終了インデックス</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(int start, int end) => Sum(end) - Sum(start);\n\n        /// <summary>\n        /// [0, <c>index</c>)の部分和が<c>sum</c>未満になる最大の<c>index</c>を返します。\n        /// BIT上の各要素は0以上の数である必要があります。\n        /// </summary>\n        /// <param name=\"sum\"></param>\n        /// <returns></returns>\n        public int GetLowerBound(long sum)\n        {\n            int index = 0;\n            for (int offset = GetMostSignificantBitOf(Length); offset > 0; offset >>= 1)\n            {\n                if (index + offset < _data.Length && _data[index + offset] < sum)\n                {\n                    index += offset;\n                    sum -= _data[index];\n                }\n            }\n\n            return index;\n\n            int GetMostSignificantBitOf(int n)\n            {\n                int k = 1;\n                while ((k << 1) <= n)\n                {\n                    k <<= 1;\n                };\n                return k;\n            }\n        }\n    }\n\n    public class BinaryIndexedTree2D\n    {\n        long[,] _data;\n        public int Height { get; }\n        public int Width { get; }\n\n        public BinaryIndexedTree2D(int height, int width)\n        {\n            Height = height;\n            Width = width;\n            _data = new long[height + 1, width + 1];\n        }\n\n        public long this[Index row, Index column]\n        {\n            get => Sum(row..(row.GetOffset(Height) + 1), column..(column.GetOffset(Width) + 1));\n            set\n            {\n                if (value < 0)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(value), $\"{nameof(value)}は0以上の値である必要があります。\");\n                }\n                AddAt(row, column, value - this[row, column]);\n            }\n        }\n\n        /// <summary>\n        /// 2次元BITの[<c>row</c>, <c>column</c>]に<c>value</c>を足します。\n        /// </summary>\n        /// <param name=\"row\">加算する行（0-indexed）</param>\n        /// <param name=\"column\">加算する列（0-indexed）</param>\n        /// <param name=\"value\">加算する値</param>\n        public void AddAt(Index row, Index column, long value)\n        {\n            var initI = row.GetOffset(Height);\n            var initJ = column.GetOffset(Width);\n            unchecked\n            {\n                if ((ulong)initI >= (ulong)Height)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(row));\n                }\n                if ((ulong)initJ >= (ulong)Width)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(column));\n                }\n            }\n\n            initI++;    // 1-indexed\n            initJ++;\n\n            for (int i = initI; i <= Height; i += i & -i)\n            {\n                for (int j = initJ; j <= Width; j += j & -j)\n                {\n                    _data[i, j] += value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"row\"></param>\n        /// <param name=\"column\"></param>\n        /// <returns></returns>\n        public long Sum(Index row, Index column)\n        {\n            long sum = 0;\n            var initI = row.GetOffset(Height);\n            var initJ = column.GetOffset(Width);\n            unchecked\n            {\n                if ((ulong)initI >= (ulong)(Height + 1))\n                {\n                    throw new ArgumentOutOfRangeException(nameof(row));\n                }\n                if ((ulong)initJ >= (ulong)(Width + 1))\n                {\n                    throw new ArgumentOutOfRangeException(nameof(column));\n                }\n            }\n\n            for (int i = initI; i > 0; i -= i & -i)\n            {\n                for (int j = initJ; j > 0; j -= j & -j)\n                {\n                    sum += _data[i, j];\n                }\n            }\n            return sum;\n        }\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"rows\"></param>\n        /// <param name=\"columns\"></param>\n        /// <returns></returns>\n        public long Sum(Range rows, Range columns) => Sum(rows.End, columns.End) - Sum(rows.Start, columns.End) - Sum(rows.End, columns.Start) + Sum(rows.Start, columns.Start);\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"beginRow\"></param>\n        /// <param name=\"endRow\"></param>\n        /// <param name=\"beginColumn\"></param>\n        /// <param name=\"endColumn\"></param>\n        /// <returns></returns>\n        public long Sum(int beginRow, int endRow, int beginColumn, int endColumn) => Sum(beginRow..endRow, beginColumn..endColumn);\n    }\n\n    public class Counter<T> : IEnumerable<(T key, long count)> where T : IEquatable<T>\n    {\n        private Dictionary<T, long> _innerDictionary;\n\n        public Counter()\n        {\n            _innerDictionary = new Dictionary<T, long>();\n        }\n\n        public IEnumerator<(T key, long count)> GetEnumerator()\n        {\n            foreach (var pair in _innerDictionary)\n            {\n                yield return (key: pair.Key, count: pair.Value);\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public long this[T key]\n        {\n            get\n            {\n                _innerDictionary.TryGetValue(key, out var count);\n                return count;\n            }\n            set\n            {\n                _innerDictionary[key] = value;\n            }\n        }\n    }\n\n    public readonly struct BitSet : IEquatable<BitSet>\n    {\n        readonly uint _value;\n\n        public BitSet(uint value)\n        {\n            _value = value;\n        }\n        public bool this[int digit]\n        {\n            get => ((_value >> digit) & 1) > 0;\n        }\n        public bool Any => _value > 0;\n        public bool None => _value == 0;\n        public BitSet SetAt(int digit, bool value) => value ? new BitSet(_value | (1u << digit)) : new BitSet(_value & ~(1u << digit));\n        public BitSet Lsb() { unchecked { return new BitSet(_value & (uint)-(int)_value); } }\n        public BitSet Reverse()\n        {\n            unchecked\n            {\n                uint v = _value;\n                v = (v & 0x55555555) << 1 | (v >> 1 & 0x55555555);\n                v = (v & 0x33333333) << 2 | (v >> 2 & 0x33333333);\n                v = (v & 0x0f0f0f0f) << 4 | (v >> 4 & 0x0f0f0f0f);\n                v = (v & 0x00ff00ff) << 8 | (v >> 8 & 0x00ff00ff);\n                v = (v & 0x0000ffff) << 16 | (v >> 16 & 0x0000ffff);\n                return new BitSet(v);\n            }\n        }\n        public int Count()\n        {\n            unchecked\n            {\n                // Hardware Intrinsics未使用\n                uint v = _value;\n                v = (v & 0x55555555) + (v >> 1 & 0x55555555);\n                v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n                v = (v & 0x0f0f0f0f) + (v >> 4 & 0x0f0f0f0f);\n                v = (v & 0x00ff00ff) + (v >> 8 & 0x00ff00ff);\n                v = (v & 0x0000ffff) + (v >> 16 & 0x0000ffff);\n                return (int)v;\n            }\n        }\n\n        public static BitSet Zero => new BitSet(0);\n        public static BitSet One => new BitSet(1);\n        public static BitSet All => new BitSet(~0u);\n        public static BitSet At(int digit) => new BitSet(1u << digit);\n        public static BitSet CreateMask(int digit) => new BitSet((1u << digit) - 1);\n        public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet._value + 1);\n        public static BitSet operator --(BitSet bitSet) => new BitSet(bitSet._value - 1);\n        public static BitSet operator ~(BitSet bitSet) => new BitSet(~bitSet._value);\n        public static BitSet operator &(BitSet left, BitSet right) => new BitSet(left._value & right._value);\n        public static BitSet operator |(BitSet left, BitSet right) => new BitSet(left._value | right._value);\n        public static BitSet operator ^(BitSet left, BitSet right) => new BitSet(left._value ^ right._value);\n        public static BitSet operator <<(BitSet bitSet, int n) => new BitSet(bitSet._value << n);\n        public static BitSet operator >>(BitSet bitSet, int n) => new BitSet(bitSet._value >> n);\n        public static bool operator <(BitSet left, BitSet right) => left._value < right._value;\n        public static bool operator <=(BitSet left, BitSet right) => left._value <= right._value;\n        public static bool operator >(BitSet left, BitSet right) => left._value > right._value;\n        public static bool operator >=(BitSet left, BitSet right) => left._value >= right._value;\n        public static bool operator ==(BitSet left, BitSet right) => left.Equals(right);\n        public static bool operator !=(BitSet left, BitSet right) => !(left == right);\n        public static implicit operator uint(BitSet bitSet) => bitSet._value;\n\n        public override bool Equals(object obj) => obj is BitSet set && Equals(set);\n        public bool Equals(BitSet other) => _value == other._value;\n        public override string ToString() => Convert.ToString(_value, 2);\n        public override int GetHashCode() => _value.GetHashCode();\n    }\n\n    public static class SearchExtensions\n    {\n        class LowerBoundComparer<T> : IComparer<T> where T : IComparable<T>\n        {\n            public int Compare(T x, T y) => 0 <= x.CompareTo(y) ? 1 : -1;\n        }\n\n        class UpperBoundComparer<T> : IComparer<T> where T : IComparable<T>\n        {\n            public int Compare(T x, T y) => 0 < x.CompareTo(y) ? 1 : -1;\n        }\n\n        // https://trsing.hatenablog.com/entry/2019/08/27/211038\n        public static int GetGreaterEqualIndex<T>(this ReadOnlySpan<T> span, T inclusiveMin) where T : IComparable<T> => ~span.BinarySearch(inclusiveMin, new UpperBoundComparer<T>());\n        public static int GetGreaterThanIndex<T>(this ReadOnlySpan<T> span, T exclusiveMin) where T : IComparable<T> => ~span.BinarySearch(exclusiveMin, new LowerBoundComparer<T>());\n        public static int GetLessEqualIndex<T>(this ReadOnlySpan<T> span, T inclusiveMax) where T : IComparable<T> => ~span.BinarySearch(inclusiveMax, new LowerBoundComparer<T>()) - 1;\n        public static int GetLessThanIndex<T>(this ReadOnlySpan<T> span, T exclusiveMax) where T : IComparable<T> => ~span.BinarySearch(exclusiveMax, new UpperBoundComparer<T>()) - 1;\n        public static int GetGreaterEqualIndex<T>(this Span<T> span, T inclusiveMin) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetGreaterEqualIndex(inclusiveMin);\n        public static int GetGreaterThanIndex<T>(this Span<T> span, T exclusiveMin) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetGreaterThanIndex(exclusiveMin);\n        public static int GetLessEqualIndex<T>(this Span<T> span, T inclusiveMax) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetLessEqualIndex(inclusiveMax);\n        public static int GetLessThanIndex<T>(this Span<T> span, T exclusiveMax) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetLessThanIndex(exclusiveMax);\n\n        public static int BoundaryBinarySearch(Predicate<int> predicate, int ok, int ng)\n        {\n            // めぐる式二分探索\n            while (Math.Abs(ok - ng) > 1)\n            {\n                int mid = (ok + ng) / 2;\n                if (predicate(mid))\n                {\n                    ok = mid;\n                }\n                else\n                {\n                    ng = mid;\n                }\n            }\n            return ok;\n        }\n\n        public static long BoundaryBinarySearch(Predicate<long> predicate, long ok, long ng)\n        {\n            while (Math.Abs(ok - ng) > 1)\n            {\n                long mid = (ok + ng) / 2;\n                if (predicate(mid))\n                {\n                    ok = mid;\n                }\n                else\n                {\n                    ng = mid;\n                }\n            }\n            return ok;\n        }\n\n        public static double Bisection(Func<double, double> f, double a, double b, double eps = 1e-9)\n        {\n            if (f(a) * f(b) >= 0)\n            {\n                throw new ArgumentException(\"f(a)とf(b)は異符号である必要があります。\");\n            }\n\n            const int maxLoop = 100;\n            double mid = (a + b) / 2;\n\n            for (int i = 0; i < maxLoop; i++)\n            {\n                if (f(a) * f(mid) < 0)\n                {\n                    b = mid;\n                }\n                else\n                {\n                    a = mid;\n                }\n                mid = (a + b) / 2;\n                if (Math.Abs(b - a) < eps)\n                {\n                    break;\n                }\n            }\n            return mid;\n        }\n    }\n\n    public static class PermutationAlgorithms\n    {\n        public static IEnumerable<ReadOnlyMemory<T>> GetPermutations<T>(IEnumerable<T> collection) where T : IComparable<T> => GetPermutations(collection, false);\n\n        public static IEnumerable<ReadOnlyMemory<T>> GetPermutations<T>(IEnumerable<T> collection, bool isSorted) where T : IComparable<T>\n        {\n            var a = collection.ToArray();\n\n            if (!isSorted && a.Length > 1)\n            {\n                Array.Sort(a);\n            }\n\n            yield return a; // ソート済み初期配列\n\n            if (a.Length <= 2)\n            {\n                if (a.Length == 2 && a[0].CompareTo(a[1]) != 0)\n                {\n                    (a[0], a[1]) = (a[1], a[0]);\n                    yield return a;\n                    yield break;\n                }\n\n                yield break;\n            }\n\n            bool flag = true;\n            while (flag)\n            {\n                flag = false;\n                for (int i = a.Length - 2; i >= 0; i--)\n                {\n                    // iよりi+1の方が大きい（昇順）なら\n                    if (a[i].CompareTo(a[i + 1]) < 0)\n                    {\n                        // 後ろから見ていってi<jとなるところを探して\n                        int j;\n                        for (j = a.Length - 1; a[i].CompareTo(a[j]) >= 0; j--) { }\n\n                        // iとjを入れ替えて\n                        (a[i], a[j]) = (a[j], a[i]);\n\n                        // i+1以降を反転\n                        if (i < a.Length - 2)\n                        {\n                            var sliced = a.AsSpan().Slice(i + 1);\n                            sliced.Reverse();\n                        }\n\n                        flag = true;\n                        yield return a;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class EnumerableExtensions\n    {\n        public static IEnumerable<(T1 v1, T2 v2)> Zip<T1, T2>(this (IEnumerable<T1> First, IEnumerable<T2> Second) t)\n            => t.First.Zip(t.Second, (v1, v2) => (v1, v2));\n\n        public static IEnumerable<(T1 v1, T2 v2, T3 v3)> Zip<T1, T2, T3>(this (IEnumerable<T1> First, IEnumerable<T2> Second, IEnumerable<T3> Third) t)\n            => (t.First, t.Second).Zip().Zip(t.Third, (v12, v3) => (v12.v1, v12.v2, v3));\n\n        public static IEnumerable<(T item, int index)> WithIndex<T>(this IEnumerable<T> source) => source.Select((item, index) => (item, index));\n    }\n\n    public static class ArrayExtensions\n    {\n        public static T[] SetAll<T>(this T[] array, Func<int, T> func)\n        {\n            for (int i = 0; i < array.Length; i++)\n                array[i] = func(i);\n            return array;\n        }\n\n        public static T[,] SetAll<T>(this T[,] array, Func<int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    array[i, j] = func(i, j);\n            return array;\n        }\n\n        public static T[,,] SetAll<T>(this T[,,] array, Func<int, int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            var length2 = array.GetLength(2);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    for (int k = 0; k < length2; k++)\n                        array[i, j, k] = func(i, j, k);\n            return array;\n        }\n\n        public static T[,,,] SetAll<T>(this T[,,,] array, Func<int, int, int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            var length2 = array.GetLength(2);\n            var length3 = array.GetLength(3);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    for (int k = 0; k < length2; k++)\n                        for (int l = 0; l < length3; l++)\n                            array[i, j, k, l] = func(i, j, k, l);\n            return array;\n        }\n    }\n}\n\n#endregion\n\n#region Graphs\n\nnamespace Training20200909.Graphs\n{\n    public interface INode\n    {\n        public int Index { get; }\n    }\n\n    public interface IEdge<TNode> where TNode : INode\n    {\n        TNode From { get; }\n        TNode To { get; }\n    }\n\n    public interface IWeightedEdge<TNode> : IEdge<TNode> where TNode : INode\n    {\n        long Weight { get; }\n    }\n\n    public interface IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n    {\n        IEnumerable<TEdge> this[TNode node] { get; }\n        IEnumerable<TEdge> Edges { get; }\n        IEnumerable<TNode> Nodes { get; }\n        int NodeCount { get; }\n    }\n\n    public interface IWeightedGraph<TNode, TEdge> : IGraph<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode { }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct BasicNode : INode, IEquatable<BasicNode>\n    {\n        public int Index { get; }\n\n        public BasicNode(int index)\n        {\n            Index = index;\n        }\n\n        public override string ToString() => Index.ToString();\n        public override bool Equals(object obj) => obj is BasicNode node && Equals(node);\n        public bool Equals(BasicNode other) => Index == other.Index;\n        public override int GetHashCode() => HashCode.Combine(Index);\n        public static bool operator ==(BasicNode left, BasicNode right) => left.Equals(right);\n        public static bool operator !=(BasicNode left, BasicNode right) => !(left == right);\n        public static implicit operator BasicNode(int value) => new BasicNode(value);\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct BasicEdge : IEdge<BasicNode>\n    {\n        public BasicNode From { get; }\n        public BasicNode To { get; }\n\n        public BasicEdge(int from, int to)\n        {\n            From = from;\n            To = to;\n        }\n\n        public override string ToString() => $\"{From}-->{To}\";\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct WeightedEdge : IWeightedEdge<BasicNode>\n    {\n        public BasicNode From { get; }\n        public BasicNode To { get; }\n        public long Weight { get; }\n\n        public WeightedEdge(int from, int to) : this(from, to, 1) { }\n\n        public WeightedEdge(int from, int to, long weight)\n        {\n            From = from;\n            To = to;\n            Weight = weight;\n        }\n\n        public override string ToString() => $\"{From}--[{Weight}]-->{To}\";\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct GridNode : INode, IEquatable<GridNode>\n    {\n        public int Row { get; }\n        public int Column { get; }\n        public int Index { get; }\n\n        public GridNode(int row, int column, int width)\n        {\n            Row = row;\n            Column = column;\n            Index = row * width + column;\n        }\n\n        public override string ToString() => $\"({Row}, {Column})\";\n        public override int GetHashCode() => HashCode.Combine(Row, Column, Index);\n        public override bool Equals(object obj) => obj is GridNode node && Equals(node);\n        public bool Equals(GridNode other) => Row == other.Row && Column == other.Column && Index == other.Index;\n        public void Deconstruct(out int row, out int column) { row = Row; column = Column; }\n        public static bool operator ==(GridNode left, GridNode right) => left.Equals(right);\n        public static bool operator !=(GridNode left, GridNode right) => !(left == right);\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct GridEdge : IEdge<GridNode>\n    {\n        public GridNode From { get; }\n        public GridNode To { get; }\n\n        public GridEdge(GridNode from, GridNode to)\n        {\n            From = from;\n            To = to;\n        }\n\n        public override string ToString() => $\"({From.Row}, {From.Column})-->({To.Row}, {To.Column})\";\n    }\n\n    public class BasicGraph : IGraph<BasicNode, BasicEdge>\n    {\n        private readonly List<BasicEdge>[] _edges;\n        public IEnumerable<BasicEdge> this[BasicNode node] => _edges[node.Index];\n        public IEnumerable<BasicEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<BasicNode> Nodes => Enumerable.Range(0, NodeCount).Select(i => new BasicNode(i));\n        public int NodeCount { get; }\n\n        public BasicGraph(int nodeCount) : this(nodeCount, Enumerable.Empty<BasicEdge>()) { }\n\n        public BasicGraph(int nodeCount, IEnumerable<BasicEdge> edges)\n        {\n            _edges = Enumerable.Repeat(0, nodeCount).Select(_ => new List<BasicEdge>()).ToArray();\n            NodeCount = nodeCount;\n            foreach (var edge in edges)\n            {\n                AddEdge(edge);\n            }\n        }\n\n        public BasicGraph(int nodeCount, IEnumerable<IEnumerable<int>> distances)\n        {\n            _edges = new List<BasicEdge>[nodeCount];\n\n            int i = 0;\n            foreach (var row in distances)\n            {\n                _edges[i] = new List<BasicEdge>(nodeCount);\n                int j = 0;\n                foreach (var distance in row)\n                {\n                    if (distance == 1)\n                    {\n                        _edges[i].Add(new BasicEdge(i, j++));\n                    }\n                }\n                i++;\n            }\n        }\n\n        public void AddEdge(BasicEdge edge) => _edges[edge.From.Index].Add(edge);\n    }\n\n    public class WeightedGraph : IGraph<BasicNode, WeightedEdge>\n    {\n        private readonly List<WeightedEdge>[] _edges;\n        public IEnumerable<WeightedEdge> this[BasicNode node] => _edges[node.Index];\n        public IEnumerable<WeightedEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<BasicNode> Nodes => Enumerable.Range(0, NodeCount).Select(i => new BasicNode(i));\n        public int NodeCount { get; }\n\n        public WeightedGraph(int nodeCount) : this(nodeCount, Enumerable.Empty<WeightedEdge>()) { }\n\n        public WeightedGraph(int nodeCount, IEnumerable<WeightedEdge> edges)\n        {\n            _edges = Enumerable.Repeat(0, nodeCount).Select(_ => new List<WeightedEdge>()).ToArray();\n            NodeCount = nodeCount;\n            foreach (var edge in edges)\n            {\n                AddEdge(edge);\n            }\n        }\n\n        public WeightedGraph(int nodeCount, IEnumerable<IEnumerable<int>> distances)\n        {\n            _edges = new List<WeightedEdge>[nodeCount];\n\n            int i = 0;\n            foreach (var row in distances)\n            {\n                _edges[i] = new List<WeightedEdge>(nodeCount);\n                int j = 0;\n                foreach (var distance in row)\n                {\n                    _edges[i].Add(new WeightedEdge(i, j++, distance));\n                }\n                i++;\n            }\n        }\n\n        public void AddEdge(WeightedEdge edge) => _edges[edge.From.Index].Add(edge);\n    }\n\n    public class GridGraph : IGraph<GridNode, GridEdge>\n    {\n        private readonly IReadOnlyList<(int dx, int dy)> _adjacents;\n        public int Height { get; }\n        public int Width { get; }\n        public int NodeCount => Height * Width;\n\n        public IEnumerable<GridEdge> this[GridNode node]\n        {\n            get\n            {\n                foreach (var (dx, dy) in _adjacents)\n                {\n                    var next = new GridNode(node.Row + dx, node.Column + dy, Width);\n                    if (CanEnter(next))\n                    {\n                        yield return new GridEdge(node, next);\n                    }\n                }\n            }\n        }\n\n        public IEnumerable<GridEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<GridNode> Nodes => Enumerable.Range(0, Width).SelectMany(x => Enumerable.Range(0, Height).Select(y => new GridNode(x, y, Width)));\n\n        public GridGraph(int height, int width) : this(height, width, new (int dx, int dy)[] { (-1, 0), (1, 0), (0, -1), (0, 1) }) { }\n\n        public GridGraph(int height, int width, IEnumerable<(int dx, int dy)> adjacents)\n        {\n            Height = height;\n            Width = width;\n            _adjacents = adjacents.ToArray();\n        }\n\n        protected virtual bool CanEnter(GridNode node)\n        {\n            unchecked\n            {\n                return (uint)node.Row < Height && (uint)node.Column < Width;\n            }\n        }\n    }\n\n    namespace Algorithms\n    {\n        // TGraphは派生クラスでいじりたいことがあるのでジェネリクス。\n        // TNode, TEdgeはインターフェースで受け取っても動くが、構造体のDevirtualizationを行うため敢えてジェネリクスにしている（型引数長いのでなんとかしたい……）\n        public abstract class BfsBase<TGraph, TNode, TEdge, TResult> where TGraph : IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n        {\n            protected readonly TGraph _graph;\n            protected bool _completed;\n\n            protected BfsBase(TGraph graph)\n            {\n                _graph = graph;\n            }\n\n            public TResult Search(TNode startNode)\n            {\n                var todo = new Queue<TNode>();\n                var seen = new bool[_graph.NodeCount];\n                var cameFrom = new TNode[_graph.NodeCount];\n                _completed = false;\n                todo.Enqueue(startNode);\n                seen[startNode.Index] = true;\n                Initialize(startNode);\n\n                while (todo.Count > 0 && !_completed)\n                {\n                    var current = todo.Dequeue();\n                    var isFirstNode = current.Index == startNode.Index;\n                    OnPreordering(current, cameFrom[current.Index], isFirstNode);\n\n                    foreach (var edge in _graph[current])\n                    {\n                        if (seen[edge.To.Index])\n                        {\n                            continue;\n                        }\n                        seen[edge.To.Index] = true;\n                        cameFrom[edge.To.Index] = edge.From;\n                        todo.Enqueue(edge.To);\n                    }\n                }\n\n                return GetResult();\n            }\n\n            protected abstract void Initialize(TNode startNode);\n            protected abstract void OnPreordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract TResult GetResult();\n        }\n\n        public abstract class DfsBase<TGraph, TNode, TEdge, TResult> where TGraph : IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n        {\n            protected readonly TGraph _graph;\n            protected bool _completed;\n\n            protected DfsBase(TGraph graph)\n            {\n                _graph = graph;\n            }\n\n            public TResult Search(TNode startNode)\n            {\n                var todo = new Stack<TNode>();\n                var seen = new bool[_graph.NodeCount];\n                var preorderCompleted = new bool[_graph.NodeCount];\n                var cameFrom = new TNode[_graph.NodeCount];\n                _completed = false;\n                todo.Push(startNode);\n                seen[startNode.Index] = true;\n                Initialize(startNode);\n\n                while (todo.Count > 0 && !_completed)\n                {\n                    var current = todo.Peek();\n                    var isFirstNode = current.Index == startNode.Index;\n\n                    if (!preorderCompleted[current.Index])\n                    {\n                        // 行きがけ\n                        OnPreordering(current, cameFrom[current.Index], isFirstNode);\n                        foreach (var edge in _graph[current])\n                        {\n                            if (seen[edge.To.Index])\n                            {\n                                continue;\n                            }\n                            seen[edge.To.Index] = true;\n                            cameFrom[edge.To.Index] = edge.From;\n                            todo.Push(edge.To);\n                        }\n                        preorderCompleted[current.Index] = true;\n                    }\n                    else\n                    {\n                        // 帰りがけ\n                        OnPostordering(current, cameFrom[current.Index], isFirstNode);\n                        _ = todo.Pop();\n                    }\n                }\n\n                return GetResult();\n            }\n\n            protected abstract void Initialize(TNode startNode);\n            protected abstract void OnPreordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract void OnPostordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract TResult GetResult();\n        }\n\n        // 最短経路問題やるだけの問題でIGraphを派生クラスでいじりたいことはほとんどないので普通にインターフェースで受け取る\n        public class Dijkstra<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly IGraph<TNode, TEdge> _graph;\n\n            public Dijkstra(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n            }\n\n            public long[] GetDistancesFrom(TNode startNode)\n            {\n                const long Inf = 1L << 60;\n                var distances = Enumerable.Repeat(Inf, _graph.NodeCount).ToArray();\n                distances[startNode.Index] = 0;\n                var todo = new PriorityQueue<State>(false);\n                todo.Enqueue(new State(startNode, 0));\n\n                while (todo.Count > 0)\n                {\n                    var current = todo.Dequeue();\n                    if (current.Distance > distances[current.Node.Index])\n                    {\n                        continue;\n                    }\n\n                    foreach (var edge in _graph[current.Node])\n                    {\n                        var nextDistance = current.Distance + edge.Weight;\n                        if (distances[edge.To.Index] > nextDistance)\n                        {\n                            distances[edge.To.Index] = nextDistance;\n                            todo.Enqueue(new State(edge.To, nextDistance));\n                        }\n                    }\n                }\n\n                return distances;\n            }\n\n            private readonly struct State : IComparable<State>\n            {\n                public TNode Node { get; }\n                public long Distance { get; }\n\n                public State(TNode node, long distance)\n                {\n                    Node = node;\n                    Distance = distance;\n                }\n\n                public int CompareTo(State other) => Distance.CompareTo(other.Distance);\n            }\n        }\n\n        public class WarshallFloyd<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly IGraph<TNode, TEdge> _graph;\n            const long Inf = 1L << 60;\n\n            public WarshallFloyd(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n            }\n\n            public long[,] GetDistances()\n            {\n                var distances = InitializeDistances();\n                for (int k = 0; k < _graph.NodeCount; k++)\n                {\n                    for (int i = 0; i < _graph.NodeCount; i++)\n                    {\n                        for (int j = 0; j < _graph.NodeCount; j++)\n                        {\n                            distances[i, j] = Math.Min(distances[i, j], distances[i, k] + distances[k, j]);\n                        }\n                    }\n                }\n\n                // 一応キレイにしておく\n                for (int i = 0; i < _graph.NodeCount; i++)\n                {\n                    for (int j = 0; j < _graph.NodeCount; j++)\n                    {\n                        if (distances[i, j] >= Inf)\n                        {\n                            distances[i, j] = long.MaxValue;\n                        }\n                    }\n                }\n\n                return distances;\n            }\n\n            private long[,] InitializeDistances()\n            {\n                var distances = new long[_graph.NodeCount, _graph.NodeCount];\n\n                for (int i = 0; i < _graph.NodeCount; i++)\n                {\n                    for (int j = 0; j < _graph.NodeCount; j++)\n                    {\n                        distances[i, j] = Inf;\n                    }\n                    distances[i, i] = 0;\n                }\n\n                foreach (var node in _graph.Nodes)\n                {\n                    foreach (var edge in _graph.Edges)\n                    {\n                        distances[edge.From.Index, edge.To.Index] = edge.Weight;\n                    }\n                }\n\n                return distances;\n            }\n        }\n\n        public class BellmanFord<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly List<TEdge> _edges;\n            protected readonly int _nodeCount;\n\n            public BellmanFord(IGraph<TNode, TEdge> graph) : this(graph.Edges, graph.NodeCount) { }\n\n            public BellmanFord(IEnumerable<TEdge> edges, int nodeCount)\n            {\n                _edges = edges.ToList();\n                _nodeCount = nodeCount;\n            }\n\n            public (long[] distances, bool[] isNegativeCycle) GetDistancesFrom(TNode startNode)\n            {\n                const long Inf = long.MaxValue >> 1;\n                var distances = Enumerable.Repeat(long.MaxValue, _nodeCount).ToArray();\n                var isNegativeCycle = new bool[_nodeCount];\n                distances[startNode.Index] = 0;\n\n                for (int i = 1; i <= 2 * _nodeCount; i++)\n                {\n                    foreach (var edge in _edges)\n                    {\n                        // そもそも出発点に未到達なら無視\n                        if (distances[edge.From.Index] < Inf)\n                        {\n                            if (i <= _nodeCount)\n                            {\n                                var newCost = distances[edge.From.Index] + edge.Weight;\n                                if (distances[edge.To.Index] > newCost)\n                                {\n                                    distances[edge.To.Index] = newCost;\n                                    // N回目に更新されたやつにチェックを付けて、追加でN回伝播させる\n                                    if (i == _nodeCount)\n                                    {\n                                        isNegativeCycle[edge.To.Index] = true;\n                                    }\n                                }\n                            }\n                            else if (isNegativeCycle[edge.From.Index])\n                            {\n                                isNegativeCycle[edge.To.Index] = true;\n                            }\n                        }\n                    }\n                }\n\n                // 一応キレイにしておく\n                for (int i = 0; i < _nodeCount; i++)\n                {\n                    if (isNegativeCycle[i])\n                    {\n                        distances[i] = long.MinValue;\n                    }\n                    else if (distances[i] >= Inf)\n                    {\n                        distances[i] = long.MaxValue;\n                    }\n                }\n\n                return (distances, isNegativeCycle);\n            }\n        }\n\n        public interface ITreeDpState<TSet> : IMonoid<TSet> where TSet : ITreeDpState<TSet>, new()\n        {\n            public TSet AddRoot();\n        }\n\n        public class Rerooting<TNode, TEdge, TTreeDpState> where TEdge : IEdge<TNode> where TNode : struct, INode where TTreeDpState : ITreeDpState<TTreeDpState>, new()\n        {\n            readonly IGraph<TNode, TEdge> _graph;\n            readonly TTreeDpState _identity;\n            readonly Dictionary<int, TTreeDpState>[] _dp;\n            readonly TTreeDpState[] _result;\n\n            public Rerooting(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n                _identity = new TTreeDpState().Identity;\n                _dp = new Dictionary<int, TTreeDpState>[_graph.NodeCount];\n                _result = new TTreeDpState[_graph.NodeCount];\n            }\n\n            public TTreeDpState[] Solve()\n            {\n                DepthFirstSearch(_graph.Nodes.First(), null);\n                Reroot(_graph.Nodes.First(), null, _identity);\n                return _result;\n            }\n\n            private TTreeDpState DepthFirstSearch(TNode root, TNode? parent)\n            {\n                var sum = _identity;\n                _dp[root.Index] = new Dictionary<int, TTreeDpState>();\n\n                foreach (var edge in _graph[root])\n                {\n                    if (edge.To.Index == parent?.Index)\n                        continue;\n                    _dp[root.Index].Add(edge.To.Index, DepthFirstSearch(edge.To, root));\n                    sum *= _dp[root.Index][edge.To.Index];\n                }\n                return sum.AddRoot();\n            }\n\n            private void Reroot(TNode root, TNode? parent, TTreeDpState toAdd)\n            {\n                var edges = _graph[root].ToArray();\n\n                foreach (var edge in edges)\n                {\n                    if (edge.To.Index == parent?.Index)\n                    {\n                        _dp[root.Index].Add(edge.To.Index, toAdd);\n                        break;\n                    }\n                }\n\n                var dp = GetPrefixSum(root, edges);\n\n                for (int i = 0; i < edges.Length; i++)\n                {\n                    var child = edges[i].To;\n                    if (child.Index == parent?.Index)\n                        continue;\n                    Reroot(child, root, dp[i].AddRoot());\n                }\n            }\n\n            private TTreeDpState[] GetPrefixSum(TNode root, TEdge[] edges)\n            {\n                // 左右からの累積和\n                int sumSize = edges.Length + 1;\n                var sumLeft = new TTreeDpState[sumSize];\n                sumLeft[0] = _identity;\n                for (int i = 0; i < edges.Length; i++)\n                {\n                    var child = edges[i].To;\n                    sumLeft[i + 1] = sumLeft[i] * _dp[root.Index][child.Index];\n                }\n\n                var sumRight = new TTreeDpState[sumSize];\n                sumRight[^1] = _identity;\n                for (int i = edges.Length - 1; i >= 0; i--)\n                {\n                    var child = edges[i].To;\n                    sumRight[i] = sumRight[i + 1] * _dp[root.Index][child.Index];\n                }\n\n                _result[root.Index] = sumLeft[^1].AddRoot();\n\n                // 頂点iを除いた累積\n                var dp = new TTreeDpState[edges.Length];\n                for (int i = 0; i < dp.Length; i++)\n                {\n                    dp[i] = sumLeft[i] * sumRight[i + 1];\n                }\n\n                return dp;\n            }\n        }\n    }\n}\n\n#endregion\n\n#region Extensions\n\nnamespace Training20200909.Extensions\n{\n    public static class StringExtensions\n    {\n        public static string Join<T>(this IEnumerable<T> source) => string.Concat(source);\n        public static string Join<T>(this IEnumerable<T> source, char separator) => string.Join(separator, source);\n        public static string Join<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);\n    }\n\n    public static class TextReaderExtensions\n    {\n        public static int ReadInt(this TextReader reader) => int.Parse(ReadString(reader));\n        public static long ReadLong(this TextReader reader) => long.Parse(ReadString(reader));\n        public static double ReadDouble(this TextReader reader) => double.Parse(ReadString(reader));\n        public static string ReadString(this TextReader reader) => reader.ReadLine();\n\n        public static int[] ReadIntArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(int.Parse).ToArray();\n        public static long[] ReadLongArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(long.Parse).ToArray();\n        public static double[] ReadDoubleArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(double.Parse).ToArray();\n        public static string[] ReadStringArray(this TextReader reader, char separator = ' ') => reader.ReadLine().Split(separator);\n\n        // Supports primitive type only.\n        public static T1 ReadValue<T1>(this TextReader reader) => (T1)Convert.ChangeType(reader.ReadLine(), typeof(T1));\n\n        public static (T1, T2) ReadValue<T1, T2>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            return (v1, v2);\n        }\n\n        public static (T1, T2, T3) ReadValue<T1, T2, T3>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            return (v1, v2, v3);\n        }\n\n        public static (T1, T2, T3, T4) ReadValue<T1, T2, T3, T4>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            return (v1, v2, v3, v4);\n        }\n\n        public static (T1, T2, T3, T4, T5) ReadValue<T1, T2, T3, T4, T5>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            return (v1, v2, v3, v4, v5);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6) ReadValue<T1, T2, T3, T4, T5, T6>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            return (v1, v2, v3, v4, v5, v6);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6, T7) ReadValue<T1, T2, T3, T4, T5, T6, T7>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            var v7 = (T7)Convert.ChangeType(inputs[6], typeof(T7));\n            return (v1, v2, v3, v4, v5, v6, v7);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6, T7, T8) ReadValue<T1, T2, T3, T4, T5, T6, T7, T8>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            var v7 = (T7)Convert.ChangeType(inputs[6], typeof(T7));\n            var v8 = (T8)Convert.ChangeType(inputs[7], typeof(T8));\n            return (v1, v2, v3, v4, v5, v6, v7, v8);\n        }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n//using System.Numerics;\nusing CS=System.Runtime.CompilerServices;\n//using System.Diagnostics;\nusing static System.Math;\nusing ll=System.Int64;\nusing static Contest_H.Lib_IO;\nusing static Contest_H.Lib_Minifunc;\n\n\nnamespace Contest_H {\n\npublic static class Entry\n{\n\n\tpublic static void Main() {\n\t\tchecked{\n\t\t\tint n, d;\n\t\t\tLib_IO.rm(out n, out d);\n\t\t\tP<ll,ll>[] xy;\n\t\t\trl(n,out xy);\n\n\n\n\t\t\tList<List<KeyValuePair<int,bool>>> cl = new List<List<KeyValuePair<int, bool>>>();\n\t\t\tfor(int j=0;j<n; j++)\n\t\t\t{\n\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j,true));\n\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j+1,true));\n\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j,false));\n\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j+1,false));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n-1; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif(Abs(xy[i].A-xy[j].A)<d){\n\t\t\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*i,false));\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j,false));\n\t\t\t\t\t}\n\t\t\t\t\tif(Abs(xy[i].B-xy[j].A)<d){\n\t\t\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*i+1,false));\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j,false));\n\t\t\t\t\t}\n\t\t\t\t\tif(Abs(xy[i].A-xy[j].B)<d){\n\t\t\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*i,false));\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j+1,false));\n\t\t\t\t\t}\n\t\t\t\t\tif(Abs(xy[i].B-xy[j].B)<d){\n\t\t\t\t\t\tcl.Add(new List<KeyValuePair<int, bool>>());\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*i+1,false));\n\t\t\t\t\t\tcl[cl.Count-1].Add(new KeyValuePair<int, bool>(2*j+1,false));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSatSolver sat = new SatSolver(n*2);\n\t\t\tforeach (var e in cl)\n\t\t\t{\n\t\t\t\tsat.Add(e);\n\t\t\t}\n\n\t\t\tif(sat.Solve()){\n\t\t\t\twm(\"Yes\");\n\t\t\t}else{\n\t\t\t\twm(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong[] ans = new ll[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tans[i] = sat[i*2]?xy[i].A:xy[i].B;\n\t\t\t}\n\n\t\t\tLib_IO.wl(ans);\n\t\t}\n\t}\n\n\n\npublic class SatSolver {\n\tList<List<KeyValuePair<int, bool>>> cl;\n\tDictionary<KeyValuePair<int, bool>, List<int>> w;\n\tint[] reason, level, activity;\n\tList<int> que;\n\tbool[] assigns;\n\tint n, qi;\n\n\tpublic SatSolver(int N) {\n\t\tcl = new List<List<KeyValuePair<int, bool>>>();\n\t\tw = new Dictionary<KeyValuePair<int, bool>, List<int>>();\n\t\treason = new int[N];\n\t\tlevel = new int[N];\n\t\tactivity = new int[N];\n\t\tque = new List<int>();\n\t\tassigns = new bool[N];\n\t\tn = N;\n\n\t}\n\tpublic bool Solve() {\n\t\twhile (true)\n\t\t{\n\t\t\tvar confl = propagate();\n\t\t\tif (confl != -1)\n\t\t\t{\n\t\t\t\tif (level[que[que.Count - 1]] == 1) return false;\n\t\t\t\tfor (int i = 0; i < activity.Length; i++)\n\t\t\t\t\tactivity[i] = (int)(activity[i] / 1.05);\n\t\t\t\tanalyze(confl);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar k = -1;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tif (level[i] == 0 && (k == -1 || activity[k] < activity[i])) k = i;\n\t\t\t\tif (k == -1) return true;\n\t\t\t\tenqueue(k, assigns[k]);\n\t\t\t\tlevel[k]++;\n\t\t\t}\n\t\t}\n\t}\n\tpublic bool this[int index] {\n\t\tget { return assigns[index]; }\n\t}\n\n\tvoid enqueue(int v, bool a, int r = -1) {\n\t\tassigns[v] = a;\n\t\treason[v] = r;\n\t\tlevel[v] = (que.Count == 0) ? 1 : level[que[que.Count - 1]];\n\t\tque.Add(v);\n\t}\n\t/// <summary>\n\t/// add clause ((variable ,true or not) v ... v (variable ,true or not))\n\t/// </summary>\n\tpublic void Add(List<KeyValuePair<int, bool>> clause) {\n\t\tforeach (var l in clause)\n\t\t{\n\t\t\tList<int> a;\n\t\t\tif (w.TryGetValue(l, out a)) a.Add(cl.Count);\n\t\t\telse w.Add(l, new List<int>() { cl.Count });\n\t\t}\n\t\tcl.Add(clause);\n\t}\n\tvoid analyze(int confl) {\n\t\tint i = que.Count, lv = 1;\n\t\tvar used = new HashSet<int>();\n\t\tvar learnt = new List<KeyValuePair<int, bool>>();\n\t\tfor (int cnt = 0; cnt > 0 || used.Count == 0; cnt--)\n\t\t{\n\t\t\tforeach (var q in cl[confl])\n\t\t\t{\n\t\t\t\tif (!used.Add(q.Key)) continue;\n\t\t\t\tactivity[q.Key] += 100000;\n\t\t\t\tif (level[q.Key] == level[que[que.Count - 1]]) cnt++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlearnt.Add(q);\n\t\t\t\t\tlv = Math.Max(lv, level[q.Key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!used.Contains(que[--i])) ;\n\t\t\tconfl = reason[que[i]];\n\t\t}\n\t\tlearnt.Add(new KeyValuePair<int, bool>(que[i], !assigns[que[i]]));\n\t\tfor (; que.Count != 0 && level[que[que.Count - 1]] > lv; que.RemoveAt(que.Count - 1)) level[que[que.Count - 1]] = 0;\n\t\tqi = que.Count;\n\t\tenqueue(learnt[learnt.Count - 1].Key, learnt[learnt.Count - 1].Value, cl.Count);\n\t\tAdd(learnt);\n\t}\n\n\tint propagate() {\n\t\tfor (; qi < que.Count; qi++)\n\t\t{\n\t\t\tList<int> a;\n\t\t\tvar key = new KeyValuePair<int, bool>(que[qi], !assigns[que[qi]]);\n\t\t\tif (w.TryGetValue(key, out a)) { }\n\t\t\telse w.Add(key, new List<int>());\n\t\t\tforeach (var cr in w[new KeyValuePair<int, bool>(que[qi], !assigns[que[qi]])])\n\t\t\t{\n\t\t\t\tvar cnt = 0;\n\t\t\t\tfor (int i = 0; i < cl[cr].Count; i++)\n\t\t\t\t{\n\t\t\t\t\tvar lit = cl[cr][i];\n\t\t\t\t\tif (level[lit.Key] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tactivity[lit.Key] += 1000;\n\t\t\t\t\t\t//swap(lit,cl[cr][0])\n\t\t\t\t\t\tvar tmp = lit; cl[cr][i] = cl[cr][0]; cl[cr][0] = lit;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (assigns[lit.Key] == lit.Value)\n\t\t\t\t\t{\n\t\t\t\t\t\t//swap(lit,cl[cr][0])\n\t\t\t\t\t\tvar tmp = lit; cl[cr][i] = cl[cr][0]; cl[cr][0] = lit;\n\t\t\t\t\t\tcnt = -1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt == 0) return cr;\n\t\t\t\tif (cnt == 1) enqueue(cl[cr][0].Key, cl[cr][0].Value, cr);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n#region BaseModule\n\n\npublic static class Lib_Minifunc{\n\tpublic const long MOD1 = 1000000007; // 10^9+7\n\tpublic const double EPS1 = 1e-8;\n\tpublic const long INF1 = 1000000000000000;  // 10^15\n\t[CS.MethodImpl(256)] public static void swap1<T>(ref T a,ref T b) { T t = a; a = b; b = t; }\n\t[CS.MethodImpl(256)] public static void swap2<T>(ref T a,ref T b) where T : IComparable { if (a.CompareTo(b)==1) swap1(ref a, ref b); }  // b の方が小さければ交換\n\n\t[CS.MethodImpl(256)] public static bool chmin<T>(ref T a,T b) where T : IComparable { bool r; if (r = (a.CompareTo(b)== 1)) a = b; return r; }  // b の方が小さければ a を更新\n\t[CS.MethodImpl(256)] public static bool chmax<T>(ref T a,T b) where T : IComparable { bool r; if (r = (a.CompareTo(b)==-1)) a = b; return r; }  // b の方が大きければ a を更新\n\t[CS.MethodImpl(256)] public static bool inside(long i,long n) => (0<=i&&i<n);\n\t[CS.MethodImpl(256)] public static bool inside(long x,long y,long w,long h) => (inside(x,w)&&inside(y,h));\n\t[CS.MethodImpl(256)] public static T min<T>(params T[] a) where T : IComparable { T m = a[0]; for (int i=1;i<a.Length;i++) chmin(ref m, a[i]); return m; }\n\t[CS.MethodImpl(256)] public static T max<T>(params T[] a) where T : IComparable { T m = a[0]; for (int i=1;i<a.Length;i++) chmax(ref m, a[i]); return m; }\n\t[CS.MethodImpl(256)] public static long mod(long a,long m=MOD1) { var v = a%m; return (v<0?(m<0?v-m:v+m):v); }\n\t[CS.MethodImpl(256)] public static long ceil(long a,long b) => (a%b==0||(a<0&&0<b)||(0<a&&b<0)?a/b:a/b+1);\t// 整数商の切り上げ\n\t[CS.MethodImpl(256)] public static long round(double a) => Convert.ToInt64(a);\t// 四捨五入\n\tpublic static string YES(bool a) => a?\"YES\":\"NO\";\n\tpublic static string yes(bool a) => a?\"Yes\":\"No\";\n\t[CS.MethodImpl(256)] public static P<T,U> initp<T,U>(T a,U b) => new P<T,U>(a,b);\n\t[CS.MethodImpl(256)] public static P<T,U,V> initp<T,U,V>(T a,U b,V c) => new P<T,U,V>(a,b,c);\n\t[CS.MethodImpl(256)] public static P<T,U,V,W> initp<T,U,V,W>(T a,U b,V c,W d) => new P<T,U,V,W>(a,b,c,d);\n\tpublic static T[] initc<T>(long l1) where T : new() { var m = new T[l1]; for (int i=0;i<m.Length;i++) m[i] = new T(); return m; }\t// new制約は遅い\n\tpublic static int[] range(long s, long c) => Enumerable.Range((int)s,(int)c).ToArray();\n\t[CS.MethodImpl(256)] public static T[] inita<T>(long l1,T v=default(T)) => Enumerable.Repeat(v,(int)l1).ToArray();\n\tpublic static T[][] inita<T>(long l1,long l2,T v=default(T)) { var m = new T[l1][]; for (int i=0;i<m.Length;i++) m[i] = inita(l2,v); return m; }\n\tpublic static void shift(this IList<int> l,int o) { for (int i = 0;i<l.Count;i++) l[i]+=o; }\n\tpublic static void shift(this IList<long> l,long o) { for (int i = 0;i<l.Count;i++) l[i]+=o; }\n\t[CS.MethodImpl(256)] public static bool initd<T,U>(this IDictionary<T,U> d, T k, U v=default(U)) { if(d.ContainsKey(k)) { return false; } else { d[k] = v; return true; } }\n\tpublic static void sort<T>(this T[] a,int o=1, Comparison<T> f=null) where T : IComparable {\n\t\tswitch(o){\n\t\t\tcase  0: Array.Sort(a,f);break;\n\t\t\tcase  1: Array.Sort(a,(x,y)=>x.CompareTo(y));break;\n\t\t\tcase -1: Array.Sort(a,(x,y)=>y.CompareTo(x));break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\tpublic static void sort<T,U>(this P<T,U>[] a,int o, Comparison<P<T,U>> f=null) where T : IComparable where U : IComparable {\n\t\tswitch(o){\n\t\t\tcase  0: Array.Sort(a,f);break;\n\t\t\tcase  1: Array.Sort(a,(x,y)=>x.A.CompareTo(y.A));break;\n\t\t\tcase -1: Array.Sort(a,(x,y)=>y.A.CompareTo(x.A));break;\n\t\t\tcase  2: Array.Sort(a,(x,y)=>x.B.CompareTo(y.B));break;\n\t\t\tcase -2: Array.Sort(a,(x,y)=>y.B.CompareTo(x.B));break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\tpublic static void sort<T,U,V>(this P<T,U,V>[] a,int o, Comparison<P<T,U,V>> f=null) where T : IComparable where U : IComparable where V : IComparable {\n\t\tswitch(o){\n\t\t\tcase  0: Array.Sort(a,f);break;\n\t\t\tcase  1: Array.Sort(a,(x,y)=>x.A.CompareTo(y.A));break;\n\t\t\tcase -1: Array.Sort(a,(x,y)=>y.A.CompareTo(x.A));break;\n\t\t\tcase  2: Array.Sort(a,(x,y)=>x.B.CompareTo(y.B));break;\n\t\t\tcase -2: Array.Sort(a,(x,y)=>y.B.CompareTo(x.B));break;\n\t\t\tcase  3: Array.Sort(a,(x,y)=>x.C.CompareTo(y.C));break;\n\t\t\tcase -3: Array.Sort(a,(x,y)=>y.C.CompareTo(x.C));break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\tpublic static void sort<T,U,V,W>(this P<T,U,V,W>[] a,int o, Comparison<P<T,U,V,W>> f=null) where T : IComparable where U : IComparable where V : IComparable where W : IComparable {\n\t\tswitch(o){\n\t\t\tcase  0: Array.Sort(a,f);break;\n\t\t\tcase  1: Array.Sort(a,(x,y)=>x.A.CompareTo(y.A));break;\n\t\t\tcase -1: Array.Sort(a,(x,y)=>y.A.CompareTo(x.A));break;\n\t\t\tcase  2: Array.Sort(a,(x,y)=>x.B.CompareTo(y.B));break;\n\t\t\tcase -2: Array.Sort(a,(x,y)=>y.B.CompareTo(x.B));break;\n\t\t\tcase  3: Array.Sort(a,(x,y)=>x.C.CompareTo(y.C));break;\n\t\t\tcase -3: Array.Sort(a,(x,y)=>y.C.CompareTo(x.C));break;\n\t\t\tcase  4: Array.Sort(a,(x,y)=>x.D.CompareTo(y.D));break;\n\t\t\tcase -4: Array.Sort(a,(x,y)=>y.D.CompareTo(x.D));break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n}\n\n\npublic struct P<T,U>\n{\n\tpublic T A; public U B;\n\tpublic P(T a,U b) { A = a; B = b; }\n\tpublic static implicit operator KeyValuePair<T,U>(P<T,U> a) => new KeyValuePair<T,U>(a.A,a.B);\n\tpublic static implicit operator P<T,U>(KeyValuePair<T,U> a) => new P<T,U>(a.Key,a.Value);\n}\npublic struct P<T,U,V>\n{\n\tpublic T A; public U B; public V C;\n\tpublic P(T a,U b,V c) { A = a; B = b; C = c; }\n}\npublic struct P<T,U,V,W>\n{\n\tpublic T A; public U B; public V C; public W D;\n\tpublic P(T a,U b,V c,W d) { A = a; B = b; C = c; D = d; }\n}\n\npublic static class Lib_IO\n{\n\tclass Prt : System.IO.StreamWriter\n\t{\n\t\tpublic override IFormatProvider FormatProvider { get { return System.Globalization.CultureInfo.InvariantCulture; } }\n\t\tpublic Prt(System.IO.Stream s) : base(s,new UTF8Encoding(false,true)) {}\n\t\tpublic Prt(System.IO.Stream s,Encoding e) : base(s,e) {}\n\t}\n\tstatic Prt sw = new Prt(Console.OpenStandardOutput());\n\tstatic char[] sp = new char[] {' '};\n\t[CS.MethodImpl(256)] static bool eq<T,U>() => typeof(T).Equals(typeof(U));\n\t[CS.MethodImpl(256)] static T ct<T,U>(U a) => (T)Convert.ChangeType(a,typeof(T));\n\t[CS.MethodImpl(256)] static T cv<T>(string s) =>\n\t\teq<T,int>()\t? ct<T,int>(int.Parse(s))\n\t  : eq<T,long>()   ? ct<T,long>(long.Parse(s))\n\t  : eq<T,double>() ? ct<T,double>(double.Parse(s,System.Globalization.CultureInfo.InvariantCulture))\n\t  : eq<T,char>()   ? ct<T,char>(s[0])\n\t\t\t\t\t   : ct<T,string>(s);\n\tpublic static string[] rm<T>(out T a) {\n\t\tvar z = Console.ReadLine().Split(sp,StringSplitOptions.RemoveEmptyEntries); \n\t\ta = cv<T>(z[0]);\n\t\treturn z;\n\t}\n\tpublic static string[] rm<T,U>(out T a,out U b) {\n\t\tvar z = rm<T>(out a); \n\t\tb = cv<U>(z[1]);\n\t\treturn z;\n\t}\n\tpublic static string[] rm<T,U,V>(out T a,out U b,out V c) {\n\t\tvar z = rm<T,U>(out a,out b); \n\t\tc = cv<V>(z[2]);\n\t\treturn z;\n\t}\n\tpublic static string[] rm<T,U,V,W>(out T a,out U b,out V c,out W d) {\n\t\tvar z = rm<T,U,V>(out a,out b,out c); \n\t\td = cv<W>(z[3]);\n\t\treturn z;\n\t}\n\tpublic static string[] rm<T,U,V,W,X>(out T a,out U b,out V c,out W d,out X e) {\n\t\tvar z = rm<T,U,V,W>(out a,out b,out c,out d); \n\t\te = cv<X>(z[4]);\n\t\treturn z;\n\t}\n\tpublic static string[] rm<T,U,V,W,X,Y>(out T a,out U b,out V c,out W d,out X e,out Y f) {\n\t\tvar z = rm<T,U,V,W,X>(out a,out b,out c,out d,out e); \n\t\tf = cv<Y>(z[5]);\n\t\treturn z;\n\t}\n\tpublic static string[] ra<T>(out T[] a) {\t\t\n\t\tvar z = Console.ReadLine().Split(sp,StringSplitOptions.RemoveEmptyEntries);\n\t\ta = new T[z.Length];\n\t\tfor(int i=0;i<a.Length;i++) a[i] = cv<T>(z[i]);\n\t\treturn z;\n\t}\n\tpublic static string[][] rl<T>(long n,out T[] a) {\n\t\ta = new T[n];\n\t\tvar y = new string[n][];\n\t\tfor(int i=0;i<n;i++) y[i] = rm(out a[i]);\n\t\treturn y;\n\t}\n\tpublic static string[][] rl<T,U>(long n,out P<T,U>[] a) {\n\t\ta = new P<T,U>[n];\n\t\tvar y = new string[n][];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tT o; U p;\n\t\t\ty[i] = rm(out o,out p);\n\t\t\ta[i] = new P<T,U>(o,p);\n\t\t}\n\t\treturn y;\n\t}\n\tpublic static string[][] rl<T,U,V>(long n,out P<T,U,V>[] a) {\n\t\ta = new P<T,U,V>[n];\n\t\tvar y = new string[n][];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tT o; U p; V q;\n\t\t\ty[i] = rm(out o,out p,out q);\n\t\t\ta[i] = new P<T,U,V>(o,p,q);\n\t\t}\n\t\treturn y;\n\t}\n\tpublic static string[][] rl<T,U,V,W>(long n,out P<T,U,V,W>[] a) {\n\t\ta = new P<T,U,V,W>[n];\n\t\tvar y = new string[n][];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tT o; U p; V q; W r;\n\t\t\ty[i] = rm(out o,out p,out q,out r);\n\t\t\ta[i] = new P<T,U,V,W>(o,p,q,r);\n\t\t}\n\t\treturn y;\n\t}\n\tpublic static string[][] rx<T>(long n,out T[][] a) {\n\t\ta = new T[n][];\n\t\tvar y = new string[n][];\n\t\tfor(int i=0;i<n;i++) y[i] = ra(out a[i]);\n\t\treturn y;\n\t}\n\n\tstatic void wwp(Action act){\n\t\tsw.AutoFlush = false;\n\t\tConsole.SetOut(sw);\n\t\tact();\n\t\tConsole.Out.Flush();\n\t\tsw.AutoFlush = true;\n\t\tConsole.SetOut(sw);\n\t}\n\t[CS.MethodImpl(256)] static string wfm(Type t) =>t.Equals(typeof(double)) ? \"{0:F10}\" : \"{0}\";\n\tpublic static void wm(params object[] a) {\n\t\twwp(()=>{\n\t\t\tfor(int i=0;i<a.Length-1;i++) Console.Write(wfm(a[i].GetType())+\" \",a[i]);\n\t\t\tConsole.WriteLine(wfm(a[a.Length-1].GetType()),a[a.Length-1]);\n\t\t});\n\t}\n\tpublic static void wa<T>(IList<T> a) { wxa(new IList<T>[]{a}, \" \"); }\n\tpublic static void wl<T>(IList<T> a) {\n\t\twwp(()=>{\n\t\t\tvar f = wfm(typeof(T));\n\t\t\tif(a.Count==0){\n\t\t\t\tConsole.WriteLine();\n\t\t\t}else{\n\t\t\t\tforeach(T x in a) Console.WriteLine(f,x);\n\t\t\t}\n\t\t});\n\t}\n\tstatic void wxa<T>(IList<IList<T>> a, string s) {\n\t\twwp(()=>{\n\t\t\tvar f = wfm(typeof(T));\n\t\t\tvar g = f + s;\n\t\t\tforeach(var b in a) {\n\t\t\t\tif(b.Count==0){\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=0;i<b.Count-1;i++) Console.Write(g,b[i]);\n\t\t\t\t\tConsole.WriteLine(f,b[b.Count-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tpublic static void wx<T>(IList<IList<T>> a) { wxa(a, \" \"); }\n\tpublic static void wg<T>(IList<IList<T>> a) { wxa(a, \"\"); }\n}\n\n#endregion\n\n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\n\nusing E = System.Linq.Enumerable;\nusing System.Threading;\n\n\ninternal partial class Solver {\n    public void Run() {\n        var n = ni();\n        var d = ni();\n        var x = new int[n];\n        var y = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = ni();\n            y[i] = ni();\n        }\n        var twosat = new TwoSat(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (Math.Abs(x[i] - x[j]) < d) twosat.AddNandClause(i, true, j, true);\n                if (Math.Abs(x[i] - y[j]) < d) twosat.AddNandClause(i, true, j, false);\n                if (Math.Abs(y[i] - x[j]) < d) twosat.AddNandClause(i, false, j, true);\n                if (Math.Abs(y[i] - y[j]) < d) twosat.AddNandClause(i, false, j, false);\n            }\n        }\n        if (twosat.Solve(out var value)) {\n            cout.WriteLine(\"Yes\");\n            for (int i = 0; i < n; i++) {\n                cout.WriteLine(value[i] ? x[i] : y[i]);\n            }\n        } else {\n            cout.WriteLine(\"No\");\n        }\n    }\n}\n\npublic class StronglyConnectedComponent {\n    private readonly int _n;\n    private readonly bool[] _isVisited;\n    private readonly List<int>[] _adjacent;\n    private readonly List<int>[] _inverseAdjacent;\n    private readonly Stack<int> _stack = new Stack<int>();\n\n    public StronglyConnectedComponent(List<int>[] adj) {\n        _adjacent = adj;\n        _n = adj.Length;\n        _isVisited = new bool[_n];\n        _inverseAdjacent = new List<int>[_n];\n        for (var i = 0; i < _n; i++) {\n            _inverseAdjacent[i] = new List<int>();\n        }\n\n        for (var i = 0; i < _n; i++) {\n            foreach (var x in adj[i]) {\n                _inverseAdjacent[x].Add(i);\n            }\n        }\n    }\n\n    private void Traverse(int k, List<int>[] adjacent, List<int> label) {\n        if (_isVisited[k]) {\n            return;\n        }\n        _stack.Push(k);\n        while (_stack.Count > 0) {\n            int top = _stack.Pop();\n            if (top < 0) {\n                label.Add(-top - 1);\n                continue;\n            }\n            if (_isVisited[top]) {\n                continue;\n            }\n            _isVisited[top] = true;\n            _stack.Push(-(top + 1));\n            foreach (int x in adjacent[top]) {\n                if (!_isVisited[x]) {\n                    _stack.Push(x);\n                }\n            }\n        }\n    }\n\n    public List<List<int>> Run() {\n        var label = new List<int>();\n        for (var i = 0; i < _n; i++) {\n            Traverse(i, _adjacent, label);\n        }\n\n        label.Reverse();\n        Array.Clear(_isVisited, 0, _isVisited.Length);\n        var components = new List<List<int>>();\n        foreach (var x in label) {\n            if (!_isVisited[x]) {\n                var group = new List<int>();\n                Traverse(x, _inverseAdjacent, group);\n                components.Add(group);\n            }\n        }\n        return components;\n    }\n\n    public int[] GetGroupArray() {\n        var component = Run();\n        var group = new int[_n];\n        for (var i = 0; i < component.Count; i++) {\n            foreach (var x in component[i]) {\n                group[x] = i;\n            }\n        }\n        return group; // group index is topological order\n    }\n}\n\npublic struct TwoSatVariable {\n    public int Index;\n    public bool TrueOfFalse;\n}\n\npublic class TwoSatImplication {\n    public TwoSatVariable Variable1;\n    public TwoSatVariable Variable2;\n}\n\npublic class TwoSat {\n    private readonly int N;\n    private readonly List<TwoSatImplication> Implications = new List<TwoSatImplication>();\n\n    public TwoSat(int n) { N = n; }\n\n    /// <summary>\n    /// P OR Q\n    /// </summary>\n    public void AddOrClause(int variable1, bool trueOrFalse1, int variable2, bool trueOrFalse2) {\n        // P or Q === (~P => Q) and (~Q =>P)\n        AddImplication(variable1, !trueOrFalse1, variable2, trueOrFalse2);\n        AddImplication(variable2, !trueOrFalse2, variable1, trueOrFalse1);\n    }\n\n    /// <summary>\n    /// ~(P AND Q) (=== ~P OR ~Q)\n    /// </summary>\n    public void AddNandClause(int variable1, bool trueOrFalse1, int variable2, bool trueOrFalse2) {\n        AddOrClause(variable1, !trueOrFalse1, variable2, !trueOrFalse2);\n    }\n\n    /// <summary>\n    /// P (=== P OR P)\n    /// </summary>\n    public void AddIsTrueClause(int variable1, bool trueOrFalse1) {\n        AddOrClause(variable1, trueOrFalse1, variable1, trueOrFalse1);\n    }\n\n    /// <summary>\n    /// (P XOR Q) (=== (P OR Q) AND (~P OR ~Q))\n    /// </summary>\n    public void AddXorClause(int variable1, bool trueOrFalse1, int variable2, bool trueOrFalse2) {\n        AddOrClause(variable1, trueOrFalse1, variable2, trueOrFalse2);\n        AddOrClause(variable1, !trueOrFalse1, variable2, !trueOrFalse2);\n    }\n\n    /// <summary>\n    /// P -> Q\n    /// </summary>\n    public void AddImplication(int variable1, bool trueOrFalse1, int variable2, bool trueOrFalse2) {\n        Implications.Add(new TwoSatImplication {\n            Variable1 = new TwoSatVariable { Index = variable1, TrueOfFalse = trueOrFalse1 },\n            Variable2 = new TwoSatVariable { Index = variable2, TrueOfFalse = trueOrFalse2 },\n        });\n    }\n\n    private int ToIndex(TwoSatVariable v) {\n        return v.TrueOfFalse ? v.Index : v.Index + N;\n    }\n\n    public bool Solve(out bool[] value) {\n        value = null;\n        var adj = Enumerable.Range(0, N * 2).Select(_ => new List<int>()).ToArray();\n        foreach (var c in Implications) {\n            adj[ToIndex(c.Variable1)].Add(ToIndex(c.Variable2));\n        }\n        var scc = new StronglyConnectedComponent(adj);\n        int[] groupIndex = scc.GetGroupArray();\n\n        for (int i = 0; i < N; i++) {\n            if (groupIndex[i] == groupIndex[i + N]) {\n                return false;\n            }\n        }\n\n        value = new bool[N];\n        for (int i = 0; i < N; i++) {\n            if (groupIndex[i] > groupIndex[i + N]) {\n                value[i] = true;\n            }\n        }\n\n        return true;\n    }\n}\n// PREWRITEN CODE BEGINS FROM HERE\n\nstatic public class StringExtensions {\n    static public string JoinToString<T>(this IEnumerable<T> source, string separator = \" \") {\n        return string.Join(separator, source);\n    }\n}\n\ninternal partial class Solver : Scanner {\n    static readonly int? StackSizeInMebiByte = null; //50;\n    public static void StartAndJoin(Action action, int maxStackSize) {\n        var thread = new Thread(new ThreadStart(action), maxStackSize);\n        thread.Start();\n        thread.Join();\n    }\n\n    public static void Main() {\n#if LOCAL\n        byte[] inputBuffer = new byte[1000000];\n        var inputStream = Console.OpenStandardInput(inputBuffer.Length);\n        using (var reader = new StreamReader(inputStream, Console.InputEncoding, false, inputBuffer.Length)) {\n            Console.SetIn(reader);\n            new Solver(Console.In, Console.Out).Run();\n        }\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        if (StackSizeInMebiByte.HasValue) {\n            StartAndJoin(() => new Solver(Console.In, Console.Out).Run(), StackSizeInMebiByte.Value * 1024 * 1024);\n        } else {\n            new Solver(Console.In, Console.Out).Run();\n        }\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n    private readonly TextWriter cerr;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        cin = reader;\n        cout = writer;\n        cerr = Console.Error;\n    }\n\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\n#if DEBUG\ninternal static class LinqPadExtension {\n    public static string TextDump<T>(this T obj) {\n        if (obj is IEnumerable) return (obj as IEnumerable).Cast<object>().JoinToString().Dump();\n        else return obj.ToString().Dump();\n    }\n    public static T Dump<T>(this T obj) {\n        return LINQPad.Extensions.Dump(obj);\n    }\n}\n#endif\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    private readonly char[] buffer = new char[2 * 1024];\n    private int cursor = 0, length = 0;\n    private string Token;\n    private readonly StringBuilder sb = new StringBuilder(1024);\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        Reader = reader;\n    }\n\n    public int NextInt() { return checked((int)NextLong()); }\n    public long NextLong() {\n        var s = Next();\n        long r = 0;\n        int i = 0;\n        bool negative = false;\n        if (s[i] == '-') {\n            negative = true;\n            i++;\n        }\n        for (; i < s.Length; i++) {\n            r = r * 10 + (s[i] - '0');\n#if DEBUG\n            if (!char.IsDigit(s[i])) throw new FormatException();\n#endif\n        }\n        return negative ? -r : r;\n    }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        string[] array = new string[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = Next();\n        }\n\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextInt();\n        }\n\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextLong();\n        }\n\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        double[] array = new double[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextDouble();\n        }\n\n        return array;\n    }\n\n    public string Next() {\n        if (Token == null) {\n            if (!StockToken()) {\n                throw new Exception();\n            }\n        }\n        var token = Token;\n        Token = null;\n        return token;\n    }\n\n    public bool HasNext() {\n        if (Token != null) {\n            return true;\n        }\n\n        return StockToken();\n    }\n\n    private bool StockToken() {\n        while (true) {\n            sb.Clear();\n            while (true) {\n                if (cursor >= length) {\n                    cursor = 0;\n                    if ((length = Reader.Read(buffer, 0, buffer.Length)) <= 0) {\n                        break;\n                    }\n                }\n                var c = buffer[cursor++];\n                if (33 <= c && c <= 126) {\n                    sb.Append(c);\n                } else {\n                    if (sb.Length > 0) break;\n                }\n            }\n\n            if (sb.Length > 0) {\n                Token = sb.ToString();\n                return true;\n            }\n\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D) twosat.AddClause(i, false, j, false);\n                    if (Abs(XYList[i].X - XYList[j].Y) < D) twosat.AddClause(i, false, j, true);\n                    if (Abs(XYList[i].Y - XYList[j].X) < D) twosat.AddClause(i, true, j, false);\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D) twosat.AddClause(i, true, j, true);\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_SCC\n    {\n        int n;\n        List<long> edges;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_SCC(long n)\n        {\n            this.n = (int)n;\n            edges = new List<long>();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddPath(long from, long to) => edges.Add((from << 30) | to);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        protected (int, int[]) SCCIDs()\n        {\n            var start = new int[n + 1];\n            var elist = new int[edges.Count];\n            foreach (var e in edges) ++start[(e >> 30) + 1];\n            for (var i = 1; i < start.Length; ++i) start[i] += start[i - 1];\n            var counter = new int[n + 1];\n            for (var i = 0; i < counter.Length; i++) counter[i] = start[i];\n            foreach (var e in edges) elist[counter[e >> 30]++] = (int)(e & 1073741823);\n            var nowOrd = -1;\n            var groupNum = 0;\n            var visitedIdx = -1;\n            var visited = new int[n];\n            var low = new int[n];\n            var ord = new int[n];\n            var ids = new int[n];\n            for (var i = 0; i < ord.Length; i++) ord[i] = -1;\n            Action<int> dfs = null;\n            dfs = v =>\n            {\n                low[v] = ord[v] = ++nowOrd;\n                visited[++visitedIdx] = v;\n                for (var i = start[v]; i < start[v + 1]; ++i)\n                {\n                    var to = elist[i];\n                    if (ord[to] == -1)\n                    {\n                        dfs(to);\n                        low[v] = Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = Math.Min(low[v], ord[to]);\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = visited[visitedIdx];\n                        --visitedIdx;\n                        ord[u] = n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n                    ++groupNum;\n                }\n            };\n            for (var i = 0; i < ord.Length; ++i)\n            {\n                if (ord[i] == -1) dfs(i);\n            }\n            for (var i = 0; i < ids.Length; i++) ids[i] = groupNum - 1 - ids[i];\n            return (groupNum, ids);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int[][] SCC()\n        {\n            var ids = SCCIDs();\n            var counts = new int[ids.Item1];\n            var groups = new int[ids.Item1][];\n            foreach (var x in ids.Item2) ++counts[x];\n            for (var i = 0; i < groups.Length; ++i) groups[i] = new int[counts[i]];\n            for (var i = 0; i < ids.Item2.Length; i++) groups[ids.Item2[i]][--counts[ids.Item2[i]]] = i;\n            return groups;\n        }\n    }\n    class LIB_TwoSAT : LIB_SCC\n    {\n        // use LIB_SCC\n        int n;\n        public bool[] Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new bool[n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath((i << 1) + (f ? 0 : 1), (j << 1) + (g ? 1 : 0));\n            base.AddPath((j << 1) + (g ? 0 : 1), (i << 1) + (f ? 1 : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < id.Length; i += 2)\n            {\n                if (id[i] == id[i + 1]) return false;\n                Answer[i >> 1] = id[i] < id[i + 1];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing Training20200909.Algorithms;\nusing Training20200909.Collections;\nusing Training20200909.Extensions;\nusing Training20200909.Numerics;\nusing Training20200909.Questions;\nusing System.Diagnostics;\nusing AtCoder;\n\nnamespace Training20200909.Questions\n{\n    /// <summary>\n    /// https://atcoder.jp/contests/practice2/tasks/practice2_h\n    /// </summary>\n    public class QuestionB : AtCoderQuestionBase\n    {\n        public override IEnumerable<object> Solve(TextReader inputStream)\n        {\n            var (n, d) = inputStream.ReadValue<int, int>();\n            var flags = new Flag[n];\n            var twoSat = new TwoSat(n);\n\n            for (int i = 0; i < flags.Length; i++)\n            {\n                var (x, y) = inputStream.ReadValue<int, int>();\n                flags[i] = new Flag(x, y);\n            }\n\n            for (int i = 0; i < flags.Length; i++)\n            {\n                for (int j = i + 1; j < flags.Length; j++)\n                {\n                    if (Math.Abs(flags[i].X - flags[j].X) < d)\n                    {\n                        twoSat.AddClause(i, false, j, false);\n                    }\n                    if (Math.Abs(flags[i].X - flags[j].Y) < d)\n                    {\n                        twoSat.AddClause(i, false, j, true);\n                    }\n                    if (Math.Abs(flags[i].Y - flags[j].X) < d)\n                    {\n                        twoSat.AddClause(i, true, j, false);\n                    }\n                    if (Math.Abs(flags[i].Y - flags[j].Y) < d)\n                    {\n                        twoSat.AddClause(i, true, j, true);\n                    }\n                }\n            }\n\n            var canPlace = twoSat.Satisfiable();\n\n            if (canPlace)\n            {\n                yield return \"Yes\";\n                var results = twoSat.Answer();\n                for (int i = 0; i < results.Length; i++)\n                {\n                    yield return results[i] ? flags[i].X : flags[i].Y;\n                }\n            }\n            else\n            {\n                yield return \"No\";\n            }\n        }\n\n        [StructLayout(LayoutKind.Auto)]\n        readonly struct Flag\n        {\n            public int X { get; }\n            public int Y { get; }\n\n            public Flag(int x, int y)\n            {\n                X = x;\n                Y = y;\n            }\n\n            public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n            public override string ToString() => $\"{nameof(X)}: {X}, {nameof(Y)}: {Y}\";\n        }\n    }\n}\n\nnamespace AtCoder.Internal\n{\n    /// <summary>\n    /// 有向グラフを強連結成分分解します。\n    /// </summary>\n    [DebuggerDisplay(\"Vertices = {_n}, Edges = {edges.Count}\")]\n    public class SCCGraph\n    {\n        private readonly int _n;\n        private readonly List<Edge> edges;\n\n        public int VerticesNumbers => _n;\n\n        /// <summary>\n        /// <see cref=\"SCCGraph\"/> クラスの新しいインスタンスを、<paramref name=\"n\"/> 頂点 0 辺の有向グラフとして初期化します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"n\"/>≤10^8</para>\n        /// <para>計算量: O(<paramref name=\"n\"/>)</para>\n        /// </remarks>\n        public SCCGraph(int n)\n        {\n            _n = n;\n            edges = new List<Edge>();\n        }\n\n        /// <summary>\n        /// 頂点 <paramref name=\"from\"/> から頂点 <paramref name=\"to\"/> へ有向辺を追加します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"from\"/>, <paramref name=\"to\"/>&lt;n</para>\n        /// <para>計算量: ならしO(1)</para>\n        /// </remarks>\n        public void AddEdge(int from, int to) => edges.Add(new Edge(from, to));\n\n        /// <summary>\n        /// 強連結成分ごとに ID を割り振り、各頂点の所属する強連結成分の ID が記録された配列を取得します。\n        /// </summary>\n        /// <remarks>\n        /// <para>強連結成分の ID はトポロジカルソートされています。異なる強連結成分の頂点 u, v について、u から v に到達できる時、u の ID は v の ID よりも小さくなります。</para>\n        /// <para>計算量: 追加された辺の本数を m として O(n+m)</para>\n        /// </remarks>\n        public (int groupNum, int[] ids) SCCIDs()\n        {\n            // R. Tarjan のアルゴリズム\n            var g = new CSR(_n, edges);\n            int nowOrd = 0;\n            int groupNum = 0;\n            var visited = new Stack<int>(_n);\n            var low = new int[_n];\n            var ord = Enumerable.Repeat(-1, _n).ToArray();\n            var ids = new int[_n];\n\n            for (int i = 0; i < ord.Length; i++)\n            {\n                if (ord[i] == -1)\n                {\n                    DFS(i);\n                }\n            }\n\n            foreach (ref var x in ids.AsSpan())\n            {\n                // トポロジカル順序にするには逆順にする必要がある。\n                x = groupNum - 1 - x;\n            }\n\n            return (groupNum, ids);\n\n            void DFS(int v)\n            {\n                low[v] = nowOrd;\n                ord[v] = nowOrd++;\n                visited.Push(v);\n\n                // 頂点 v から伸びる有向辺を探索する。\n                for (int i = g.Start[v]; i < g.Start[v + 1]; i++)\n                {\n                    int to = g.EList[i];\n                    if (ord[to] == -1)\n                    {\n                        DFS(to);\n                        low[v] = System.Math.Min(low[v], low[to]);\n                    }\n                    else\n                    {\n                        low[v] = System.Math.Min(low[v], ord[to]);\n                    }\n                }\n\n                // v がSCCの根である場合、強連結成分に ID を割り振る。\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        int u = visited.Pop();\n                        ord[u] = _n;\n                        ids[u] = groupNum;\n\n                        if (u == v)\n                        {\n                            break;\n                        }\n                    }\n\n                    groupNum++;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 強連結成分分解の結果である「頂点のリスト」のリストを取得します。\n        /// </summary>\n        /// <remarks>\n        /// <para>- 全ての頂点がちょうど1つずつ、どれかのリストに含まれます。</para>\n        /// <para>- 内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。</para>\n        /// <para>- リストはトポロジカルソートされています。異なる強連結成分の頂点 u, v について、u から v に到達できる時、u の属するリストは v の属するリストよりも前です。</para>\n        /// <para>計算量: 追加された辺の本数を m として O(n+m)</para>\n        /// </remarks>\n        public List<List<int>> SCC()\n        {\n            var (groupNum, ids) = SCCIDs();\n            var counts = new int[groupNum];\n\n            foreach (var x in ids)\n            {\n                counts[x]++;\n            }\n\n            var groups = new List<List<int>>(groupNum);\n\n            for (int i = 0; i < groupNum; i++)\n            {\n                groups.Add(new List<int>(counts[i]));\n            }\n\n            for (int i = 0; i < ids.Length; i++)\n            {\n                groups[ids[i]].Add(i);\n            }\n\n            return groups;\n        }\n\n        /// <summary>\n        /// 有向グラフの辺集合を表します。\n        /// </summary>\n        /// <example>\n        /// <code>\n        /// for (int i = graph.Starts[v]; i < graph.Starts[v + 1]; i++)\n        /// {\n        ///     int to = graph.Edges[i];\n        /// }\n        /// </code>\n        /// </example>\n        private class CSR\n        {\n            /// <summary>\n            /// 各頂点から伸びる有向辺数の累積和を取得します。\n            /// </summary>\n            public int[] Start { get; }\n\n            /// <summary>\n            /// 有向辺の終点の配列を取得します。\n            /// </summary>\n            public int[] EList { get; }\n\n            public CSR(int n, List<Edge> edges)\n            {\n                // 本家 C++ 版 ACL を参考に実装。通常の隣接リストと比較して高速か否かは未検証。\n                Start = new int[n + 1];\n                EList = new int[edges.Count];\n\n                foreach (var e in edges)\n                {\n                    Start[e.From + 1]++;\n                }\n\n                for (int i = 1; i <= n; i++)\n                {\n                    Start[i] += Start[i - 1];\n                }\n\n                var counter = new int[Start.Length];\n                Start.CopyTo(counter, 0);\n                foreach (var e in edges)\n                {\n                    EList[counter[e.From]++] = e.To;\n                }\n            }\n        }\n\n        [DebuggerDisplay(\"From = {From}, To = {To}\")]\n        private readonly struct Edge\n        {\n            public int From { get; }\n            public int To { get; }\n\n            public Edge(int from, int to)\n            {\n                From = from;\n                To = to;\n            }\n        }\n    }\n}\n\nnamespace AtCoder\n{\n    /// <summary>\n    /// 有向グラフを強連結成分分解します。\n    /// </summary>\n    [DebuggerDisplay(\"Vertices = {_internal._n}, Edges = {_internal.edges.Count}\")]\n    public class SCCGraph\n    {\n        Internal.SCCGraph _internal;\n\n        /// <summary>\n        /// <see cref=\"SCCGraph\"/> クラスの新しいインスタンスを、<paramref name=\"n\"/> 頂点 0 辺の有向グラフとして初期化します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"n\"/>≤10^8</para>\n        /// <para>計算量: O(<paramref name=\"n\"/>)</para>\n        /// </remarks>\n        public SCCGraph(int n)\n        {\n            Debug.Assert(unchecked((uint)n <= 100_000_000));\n            _internal = new Internal.SCCGraph(n);\n        }\n\n        /// <summary>\n        /// 頂点 <paramref name=\"from\"/> から頂点 <paramref name=\"to\"/> へ有向辺を追加します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"from\"/>, <paramref name=\"to\"/>&lt;n</para>\n        /// <para>計算量: ならしO(1)</para>\n        /// </remarks>\n        public void AddEdge(int from, int to)\n        {\n            int n = _internal.VerticesNumbers;\n            Debug.Assert(unchecked((uint)from < n));\n            Debug.Assert(unchecked((uint)to < n));\n            _internal.AddEdge(from, to);\n        }\n\n        /// <summary>\n        /// 強連結成分分解の結果である「頂点のリスト」のリストを取得します。\n        /// </summary>\n        /// <remarks>\n        /// <para>- 全ての頂点がちょうど1つずつ、どれかのリストに含まれます。</para>\n        /// <para>- 内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。</para>\n        /// <para>- リストはトポロジカルソートされています。異なる強連結成分の頂点 u, v について、u から v に到達できる時、u の属するリストは v の属するリストよりも前です。</para>\n        /// <para>計算量: 追加された辺の本数を m として O(n+m)</para>\n        /// </remarks>\n        public List<List<int>> SCC() => _internal.SCC();\n    }\n}\n\nnamespace AtCoder\n{\n    /// <summary>\n    /// 2-SATを解きます。 \n    /// <para>\n    /// 変数 x_0, x_1,…, x_{n-1} に関して (x_i=f)∨(x_j=g) というクローズを足し、これをすべて満たす変数の割当があるかを解きます。\n    /// </para>\n    /// </summary>\n    [DebuggerDisplay(\"Count = {_n}\")]\n    public class TwoSat\n    {\n        readonly int _n;\n        readonly private bool[] _answer;\n        readonly private SCCGraph scc;\n\n        /// <summary>\n        /// <see cref=\"TwoSat\"/> クラスの新しいインスタンスを、<paramref name=\"n\"/> 変数の 2-SAT として初期化します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約 : 0≤<paramref name=\"n\"/>≤10^8</para>\n        /// </remarks>\n        public TwoSat(int n)\n        {\n            Debug.Assert(unchecked((uint)n <= 100_000_000));\n            _n = n;\n            _answer = new bool[n];\n            scc = new SCCGraph(2 * n);\n        }\n\n        /// <summary>\n        /// (x_<paramref name=\"i\"/>=<paramref name=\"f\"/>)∨(x_<paramref name=\"j\"/>=<paramref name=\"g\"/>) というクローズを追加します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 0≤<paramref name=\"i\"/>&lt;n, 0≤<paramref name=\"j\"/>&lt;n</para>\n        /// <para>計算量: ならし O(1)</para>\n        /// </remarks>\n        public void AddClause(int i, bool f, int j, bool g)\n        {\n            Debug.Assert(unchecked((uint)i < _n));\n            Debug.Assert(unchecked((uint)j < _n));\n            scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n\n        /// <summary>\n        /// 条件を満たす割当が存在するかどうかを判定します。\n        /// </summary>\n        /// <remarks>\n        /// <para>制約: 複数回呼ぶことも可能。</para>\n        /// <para>計算量: 足した制約の個数を m として O(n+m)</para>\n        /// </remarks>\n        /// <returns>割当が存在するならば <c>true</c>、そうでないなら <c>false</c>。</returns>\n        public bool Satisfiable()\n        {\n            var sccs = scc.SCC();\n            var id = new int[2 * _n];\n\n            // 強連結成分のリストを id として展開。\n            for (int i = 0; i < sccs.Count; i++)\n            {\n                foreach (var v in sccs[i])\n                {\n                    id[v] = i;\n                }\n            }\n\n            for (int i = 0; i < _n; i++)\n            {\n                if (id[2 * i] == id[2 * i + 1])\n                {\n                    return false;\n                }\n                else\n                {\n                    _answer[i] = id[2 * i] < id[2 * i + 1];\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// 最後に実行した <see cref=\"Satisfiable\"/> の、クローズを満たす割当を返します。実行前や、割当が存在しなかった場合は中身が未定義の長さ n の配列を返します。\n        /// </summary>\n        /// <remarks>\n        /// <para>計算量: O(n)</para>\n        /// </remarks>\n        /// <returns>最後に呼んだ <see cref=\"Satisfiable\"/> の、クローズを満たす割当の配列。</returns>\n        public bool[] Answer() => _answer;\n    }\n}\n\nnamespace Training20200909\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IAtCoderQuestion question = new QuestionB();\n            var answers = question.Solve(Console.In);\n\n            var writer = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(writer);\n            foreach (var answer in answers)\n            {\n                Console.WriteLine(answer);\n            }\n            Console.Out.Flush();\n        }\n    }\n}\n\n#region Base Class\n\nnamespace Training20200909.Questions\n{\n\n    public interface IAtCoderQuestion\n    {\n        IEnumerable<object> Solve(string input);\n        IEnumerable<object> Solve(TextReader inputStream);\n    }\n\n    public abstract class AtCoderQuestionBase : IAtCoderQuestion\n    {\n        public IEnumerable<object> Solve(string input)\n        {\n            var stream = new MemoryStream(Encoding.Unicode.GetBytes(input));\n            var reader = new StreamReader(stream, Encoding.Unicode);\n\n            return Solve(reader);\n        }\n\n        public abstract IEnumerable<object> Solve(TextReader inputStream);\n    }\n}\n\n#endregion\n\n#region Algorithm\n\nnamespace Training20200909.Numerics\n{\n    public static class NumericalAlgorithms\n    {\n        public static long Gcd(long a, long b)\n        {\n            if (a < b)\n            {\n                (a, b) = (b, a);\n            }\n\n            if (b > 0)\n            {\n                return Gcd(b, a % b);\n            }\n            else if (b == 0)\n            {\n                return a;\n            }\n            else\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(a)}, {nameof(b)}は0以上の整数である必要があります。\");\n            }\n        }\n\n        public static long Lcm(long a, long b)\n        {\n            if (a < 0 || b < 0)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(a)}, {nameof(b)}は0以上の整数である必要があります。\");\n            }\n\n            return a / Gcd(a, b) * b;\n        }\n\n        public static long Factorial(int n)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{n}は0以上の整数でなければなりません。\");\n            }\n\n            long result = 1;\n            for (int i = 2; i <= n; i++)\n            {\n                result *= i;\n            }\n            return result;\n        }\n\n        public static long Permutation(int n, int r)\n        {\n            CheckNR(n, r);\n            long result = 1;\n            for (int i = 0; i < r; i++)\n            {\n                result *= n - i;\n            }\n            return result;\n        }\n\n        public static long Combination(int n, int r)\n        {\n            CheckNR(n, r);\n            r = Math.Min(r, n - r);\n\n            // See https://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations\n            long result = 1;\n            for (int i = 1; i <= r; i++)\n            {\n                result *= n--;\n                result /= i;\n            }\n            return result;\n        }\n\n        public static long CombinationWithRepetition(int n, int r) => Combination(n + r - 1, r);\n\n        public static IEnumerable<(int prime, int count)> PrimeFactorization(int n)\n        {\n            if (n <= 1)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{n}は2以上の整数でなければなりません。\");\n            }\n\n            var dictionary = new Dictionary<int, int>();\n            for (int i = 2; i * i <= n; i++)\n            {\n                while (n % i == 0)\n                {\n                    if (dictionary.ContainsKey(i))\n                    {\n                        dictionary[i]++;\n                    }\n                    else\n                    {\n                        dictionary[i] = 1;\n                    }\n\n                    n /= i;\n                }\n            }\n\n            if (n > 1)\n            {\n                dictionary[n] = 1;\n            }\n\n            return dictionary.Select(p => (p.Key, p.Value));\n        }\n\n        private static void CheckNR(int n, int r)\n        {\n            if (n <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は正の整数でなければなりません。\");\n            }\n            if (r < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(r), $\"{nameof(r)}は0以上の整数でなければなりません。\");\n            }\n            if (n < r)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(n)},{nameof(r)}\", $\"{nameof(r)}は{nameof(n)}以下でなければなりません。\");\n            }\n        }\n    }\n\n    public readonly struct Modular : IEquatable<Modular>, IComparable<Modular>\n    {\n        private const int DefaultMod = 1000000007;\n        public int Value { get; }\n        public static int Mod { get; set; } = DefaultMod;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public Modular(long value)\n        {\n            if (unchecked((ulong)value) < unchecked((ulong)Mod))\n            {\n                Value = (int)value;\n            }\n            else\n            {\n                Value = (int)(value % Mod);\n                if (Value < 0)\n                {\n                    Value += Mod;\n                }\n            }\n        }\n\n        private Modular(int value) => Value = value;\n        public static Modular Zero => new Modular(0);\n        public static Modular One => new Modular(1);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator +(Modular a, Modular b)\n        {\n            var result = a.Value + b.Value;\n            if (result >= Mod)\n            {\n                result -= Mod;    // 剰余演算を避ける\n            }\n            return new Modular(result);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator -(Modular a, Modular b)\n        {\n            var result = a.Value - b.Value;\n            if (result < 0)\n            {\n                result += Mod;    // 剰余演算を避ける\n            }\n            return new Modular(result);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator *(Modular a, Modular b) => new Modular((long)a.Value * b.Value);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Modular operator /(Modular a, Modular b) => a * Pow(b.Value, Mod - 2);\n\n        // 需要は不明だけど一応\n        public static bool operator ==(Modular left, Modular right) => left.Equals(right);\n        public static bool operator !=(Modular left, Modular right) => !(left == right);\n        public static bool operator <(Modular left, Modular right) => left.CompareTo(right) < 0;\n        public static bool operator <=(Modular left, Modular right) => left.CompareTo(right) <= 0;\n        public static bool operator >(Modular left, Modular right) => left.CompareTo(right) > 0;\n        public static bool operator >=(Modular left, Modular right) => left.CompareTo(right) >= 0;\n\n        public static implicit operator Modular(long a) => new Modular(a);\n        public static explicit operator int(Modular a) => a.Value;\n        public static explicit operator long(Modular a) => a.Value;\n\n        public static Modular Pow(int a, int n)\n        {\n            if (n == 0)\n            {\n                return Modular.One;\n            }\n            else if (n == 1)\n            {\n                return a;\n            }\n            else if (n > 0)\n            {\n                var p = Pow(a, n >> 1);             // m / 2\n                return p * p * Pow(a, n & 0x01);    // m % 2\n            }\n            else\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"べき指数{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n        }\n\n        private static List<int> _factorialCache;\n        private static List<int> FactorialCache => _factorialCache ??= new List<int>() { 1 };\n        private static int[] FactorialInverseCache { get; set; }\n        const int defaultMaxFactorial = 1000000;\n\n        public static Modular Factorial(int n)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n\n            for (int i = FactorialCache.Count; i <= n; i++)  // Countが1（0!までキャッシュ済み）のとき1!～n!まで計算\n            {\n                FactorialCache.Add((int)((long)FactorialCache[i - 1] * i % Mod));\n            }\n            return new Modular(FactorialCache[n]);\n        }\n\n        public static Modular Permutation(int n, int r)\n        {\n            CheckNR(n, r);\n            return Factorial(n) / Factorial(n - r);\n        }\n\n        public static Modular Combination(int n, int r)\n        {\n            CheckNR(n, r);\n            r = Math.Min(r, n - r);\n            try\n            {\n                return new Modular(FactorialCache[n]) * new Modular(FactorialInverseCache[r]) * new Modular(FactorialInverseCache[n - r]);\n            }\n            catch (Exception ex) when (ex is NullReferenceException || ex is ArgumentOutOfRangeException)\n            {\n                throw new InvalidOperationException($\"{nameof(Combination)}を呼び出す前に{nameof(InitializeCombinationTable)}により前計算を行う必要があります。\", ex);\n            }\n        }\n\n        public static void InitializeCombinationTable(int max = defaultMaxFactorial)\n        {\n            Factorial(max);\n            FactorialInverseCache = new int[max + 1];\n\n            var fInv = (Modular.One / Factorial(max)).Value;\n            FactorialInverseCache[max] = fInv;\n            for (int i = max - 1; i >= 0; i--)\n            {\n                fInv = (int)((long)fInv * (i + 1) % Mod);\n                FactorialInverseCache[i] = fInv;\n            }\n        }\n\n        public static Modular CombinationWithRepetition(int n, int r) => Combination(n + r - 1, r);\n\n        private static void CheckNR(int n, int r)\n        {\n            if (n < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(n), $\"{nameof(n)}は0以上の整数でなければなりません。\");\n            }\n            if (r < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(r), $\"{nameof(r)}は0以上の整数でなければなりません。\");\n            }\n            if (n < r)\n            {\n                throw new ArgumentOutOfRangeException($\"{nameof(n)},{nameof(r)}\", $\"{nameof(r)}は{nameof(n)}以下でなければなりません。\");\n            }\n        }\n\n        public override string ToString() => Value.ToString();\n        public override bool Equals(object obj) => obj is Modular m ? Equals(m) : false;\n        public bool Equals([System.Diagnostics.CodeAnalysis.AllowNull] Modular other) => Value == other.Value;\n        public int CompareTo([System.Diagnostics.CodeAnalysis.AllowNull] Modular other) => Value.CompareTo(other.Value);\n        public override int GetHashCode() => Value.GetHashCode();\n    }\n\n    public class ModMatrix\n    {\n        readonly Modular[] _values;\n        public int Height { get; }\n        public int Width { get; }\n\n        public Span<Modular> this[int row]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => _values.AsSpan(row * Width, Width);\n        }\n\n        public Modular this[int row, int column]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                if (unchecked((uint)row) >= Height)\n                    ThrowsArgumentOutOfRangeException(nameof(row));\n                else if (unchecked((uint)column) >= Width)\n                    ThrowsArgumentOutOfRangeException(nameof(column));\n                return _values[row * Width + column];\n            }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (unchecked((uint)row) >= Height)\n                    ThrowsArgumentOutOfRangeException(nameof(row));\n                else if (unchecked((uint)column) >= Width)\n                    ThrowsArgumentOutOfRangeException(nameof(column));\n                _values[row * Width + column] = value;\n            }\n        }\n\n        public ModMatrix(int n) : this(n, n) { }\n\n        public ModMatrix(int height, int width)\n        {\n            if (height <= 0)\n                throw new ArgumentOutOfRangeException(nameof(height));\n            if (width <= 0)\n                throw new ArgumentOutOfRangeException(nameof(width));\n            Height = height;\n            Width = width;\n            _values = new Modular[height * width];\n        }\n\n        public ModMatrix(Modular[][] values) : this(values.Length, values[0].Length)\n        {\n            for (int row = 0; row < Height; row++)\n            {\n                if (Width != values[row].Length)\n                    throw new ArgumentException($\"{nameof(values)}の列数は揃っている必要があります。\");\n                var span = _values.AsSpan(row * Width, Width);\n                values[row].AsSpan().CopyTo(span);\n            }\n        }\n\n        public ModMatrix(Modular[,] values) : this(values.GetLength(0), values.GetLength(1))\n        {\n            for (int row = 0; row < Height; row++)\n            {\n                var span = _values.AsSpan(row * Width, Width);\n                for (int column = 0; column < span.Length; column++)\n                {\n                    span[column] = values[row, column];\n                }\n            }\n        }\n\n        public ModMatrix(ModMatrix matrix)\n        {\n            Height = matrix.Height;\n            Width = matrix.Width;\n            _values = new Modular[matrix._values.Length];\n            matrix._values.AsSpan().CopyTo(_values);\n        }\n\n        public static ModMatrix GetIdentity(int dimension)\n        {\n            var result = new ModMatrix(dimension);\n            for (int i = 0; i < dimension; i++)\n            {\n                result._values[i * result.Width + i] = 1;\n            }\n            return result;\n        }\n\n        public static ModMatrix operator +(ModMatrix a, ModMatrix b)\n        {\n            CheckSameShape(a, b);\n\n            var result = new ModMatrix(a.Height, a.Width);\n            for (int i = 0; i < result._values.Length; i++)\n            {\n                result._values[i] = a._values[i] + b._values[i];\n            }\n            return result;\n        }\n\n        public static ModMatrix operator -(ModMatrix a, ModMatrix b)\n        {\n            CheckSameShape(a, b);\n\n            var result = new ModMatrix(a.Height, a.Width);\n            for (int i = 0; i < result._values.Length; i++)\n            {\n                result._values[i] = a._values[i] - b._values[i];\n            }\n            return result;\n        }\n\n        public static ModMatrix operator *(ModMatrix a, ModMatrix b)\n        {\n            if (a.Width != b.Height)\n                throw new ArgumentException($\"{nameof(a)}の列数と{nameof(b)}の行数は等しくなければなりません。\");\n\n            var result = new ModMatrix(a.Height, b.Width);\n            for (int i = 0; i < result.Height; i++)\n            {\n                var aSpan = a._values.AsSpan(i * a.Width, a.Width);\n                var resultSpan = result._values.AsSpan(i * result.Width, result.Width);\n                for (int k = 0; k < aSpan.Length; k++)\n                {\n                    var bSpan = b._values.AsSpan(k * b.Width, b.Width);\n                    for (int j = 0; j < resultSpan.Length; j++)\n                    {\n                        resultSpan[j] += aSpan[k] * bSpan[j];\n                    }\n                }\n            }\n            return result;\n        }\n\n        public static ModVector operator *(ModMatrix matrix, ModVector vector)\n        {\n            if (matrix.Width != vector.Length)\n                throw new ArgumentException($\"{nameof(matrix)}の列数と{nameof(vector)}の行数は等しくなければなりません。\");\n\n            var result = new ModVector(vector.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                var matrixSpan = matrix[i];\n                for (int k = 0; k < matrixSpan.Length; k++)\n                {\n                    result[i] += matrixSpan[k] * vector[k];\n                }\n            }\n            return result;\n        }\n\n        public ModMatrix Pow(long pow)\n        {\n            if (Height != Width)\n                throw new ArgumentException(\"累乗を行う行列は正方行列である必要があります。\");\n            if (pow < 0)\n                throw new ArgumentException($\"{nameof(pow)}は0以上の整数である必要があります。\");\n\n            var powMatrix = new ModMatrix(this);\n            var result = GetIdentity(Height);\n            while (pow > 0)\n            {\n                if ((pow & 1) > 0)\n                {\n                    result *= powMatrix;\n                }\n                powMatrix *= powMatrix;\n                pow >>= 1;\n            }\n            return result;\n        }\n\n        private static void CheckSameShape(ModMatrix a, ModMatrix b)\n        {\n            if (a.Height != b.Height)\n                throw new ArgumentException($\"{nameof(a)}の行数と{nameof(b)}の行数は等しくなければなりません。\");\n            else if (a.Width != b.Width)\n                throw new ArgumentException($\"{nameof(a)}の列数と{nameof(b)}の列数は等しくなければなりません。\");\n        }\n\n        private void ThrowsArgumentOutOfRangeException(string paramName) => throw new ArgumentOutOfRangeException(paramName);\n        public override string ToString() => $\"({Height}x{Width})matrix\";\n    }\n\n    public class ModVector\n    {\n        readonly Modular[] _values;\n        public int Length => _values.Length;\n\n        public ModVector(int length)\n        {\n            if (length <= 0)\n                throw new ArgumentOutOfRangeException(nameof(length));\n            _values = new Modular[length];\n        }\n\n        public ModVector(ReadOnlySpan<Modular> vector)\n        {\n            _values = new Modular[vector.Length];\n            vector.CopyTo(_values);\n        }\n\n        public ModVector(ModVector vector) : this(vector._values) { }\n\n        public Modular this[int index]\n        {\n            get => _values[index];\n            set => _values[index] = value;\n        }\n\n        public static ModVector operator +(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = new ModVector(a.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                result[i] = a[i] + b[i];\n            }\n            return result;\n        }\n\n        public static ModVector operator -(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = new ModVector(a.Length);\n            for (int i = 0; i < result.Length; i++)\n            {\n                result[i] = a[i] - b[i];\n            }\n            return result;\n        }\n\n        public static Modular operator *(ModVector a, ModVector b)\n        {\n            if (a.Length != b.Length)\n                throw new ArgumentException($\"{nameof(a)}と{nameof(b)}の次元は等しくなければなりません。\");\n\n            var result = Modular.Zero;\n            for (int i = 0; i < a.Length; i++)\n            {\n                result += a[i] * b[i];\n            }\n            return result;\n        }\n\n        public override string ToString() => $\"({Length})vector\";\n    }\n\n    public readonly struct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n    {\n        /// <summary>分子</summary>\n        public long Numerator { get; }\n        /// <summary>分母</summary>\n        public long Denominator { get; }\n\n        public static Fraction Nan => new Fraction(0, 0);\n        public static Fraction PositiveInfinity => new Fraction(1, 0);\n        public static Fraction NegativeInfinity => new Fraction(-1, 0);\n        public bool IsNan => Numerator == 0 && Denominator == 0;\n        public bool IsInfinity => Numerator != 0 && Denominator == 0;\n        public bool IsPositiveInfinity => Numerator > 0 && Denominator == 0;\n        public bool IsNegativeInfinity => Numerator < 0 && Denominator == 0;\n\n        /// <summary>\n        /// <c>Fraction</c>クラスの新しいインスタンスを生成します。\n        /// </summary>\n        /// <param name=\"numerator\">分子</param>\n        /// <param name=\"denominator\">分母</param>\n        public Fraction(long numerator, long denominator)\n        {\n            if (denominator == 0)\n            {\n                Numerator = Math.Sign(numerator);\n                Denominator = 0;\n            }\n            else if (numerator == 0)\n            {\n                Numerator = 0;\n                Denominator = 1;\n            }\n            else\n            {\n                var sign = Math.Sign(numerator) * Math.Sign(denominator);\n                numerator = Math.Abs(numerator);\n                denominator = Math.Abs(denominator);\n                var gcd = NumericalAlgorithms.Gcd(numerator, denominator);\n                Numerator = sign * numerator / gcd;\n                Denominator = denominator / gcd;\n            }\n        }\n\n        public static Fraction operator +(in Fraction left, in Fraction right)\n        {\n            if (left.IsNan || right.IsNan)\n            {\n                return Nan;\n            }\n            else if (left.IsInfinity || right.IsInfinity)\n            {\n                if (!right.IsInfinity)\n                {\n                    return left;\n                }\n                else if (!left.IsInfinity)\n                {\n                    return right;\n                }\n                else\n                {\n                    return new Fraction(left.Numerator + right.Numerator, 0);\n                }\n            }\n            else\n            {\n                var lcm = NumericalAlgorithms.Lcm(left.Denominator, right.Denominator);\n                return new Fraction(left.Numerator * (lcm / left.Denominator) + right.Numerator * (lcm / right.Denominator), lcm);\n            }\n        }\n        public static Fraction operator -(in Fraction left, in Fraction right) => left + -right;\n        public static Fraction operator *(in Fraction left, in Fraction right) => new Fraction(left.Numerator * right.Numerator, left.Denominator * right.Denominator);\n        public static Fraction operator /(in Fraction left, in Fraction right) => new Fraction(left.Numerator * right.Denominator, left.Denominator * right.Numerator);\n        public static Fraction operator +(in Fraction right) => right;\n        public static Fraction operator -(in Fraction right) => new Fraction(-right.Numerator, right.Denominator);\n        public static bool operator ==(in Fraction left, in Fraction right) => left.Equals(right);\n        public static bool operator !=(in Fraction left, in Fraction right) => !(left == right);\n        public static implicit operator double(in Fraction right)\n        {\n            if (right.IsNan)\n            {\n                return double.NaN;\n            }\n            else if (right.IsPositiveInfinity)\n            {\n                return double.PositiveInfinity;\n            }\n            else if (right.IsNegativeInfinity)\n            {\n                return double.NegativeInfinity;\n            }\n            else\n            {\n                return (double)right.Numerator / right.Denominator;\n            }\n        }\n\n        public override string ToString()\n        {\n            if (IsNan)\n            {\n                return \"NaN\";\n            }\n            else if (IsPositiveInfinity)\n            {\n                return \"Inf\";\n            }\n            else if (IsNegativeInfinity)\n            {\n                return \"-Inf\";\n            }\n            else\n            {\n                return $\"{Numerator}/{Denominator}\";\n            }\n        }\n\n        public override bool Equals(object obj) => obj is Fraction fraction && Equals(fraction);\n        public bool Equals(Fraction other) => Numerator == other.Numerator && Denominator == other.Denominator;\n        public override int GetHashCode() => HashCode.Combine(Numerator, Denominator);\n        public int CompareTo([System.Diagnostics.CodeAnalysis.AllowNull] Fraction other) => ((double)this).CompareTo(other);\n    }\n\n    public interface ISemigroup<TSet> where TSet : ISemigroup<TSet>\n    {\n        public TSet Multiply(TSet other);\n        public static TSet operator *(ISemigroup<TSet> a, TSet b) => a.Multiply(b);\n    }\n\n    public interface IMonoid<TSet> : ISemigroup<TSet> where TSet : IMonoid<TSet>, new()\n    {\n        public TSet Identity { get; }\n    }\n\n    public interface IGroup<TSet> : IMonoid<TSet> where TSet : IGroup<TSet>, new()\n    {\n        public TSet Invert();\n        public static TSet operator ~(IGroup<TSet> a) => a.Invert();\n    }\n\n}\n\nnamespace Training20200909.Algorithms\n{\n    public static class ZAlgorithm\n    {\n        public static int[] SearchAll(string s) => SearchAll(s.AsSpan());\n\n        public static int[] SearchAll<T>(ReadOnlySpan<T> s) where T : IEquatable<T>\n        {\n            var z = new int[s.Length];\n            z[0] = s.Length;\n            var offset = 1;\n            var length = 0;\n\n            while (offset < s.Length)\n            {\n                while (offset + length < s.Length && s[length].Equals(s[offset + length]))\n                {\n                    length++;\n                }\n                z[offset] = length;\n\n                if (length == 0)\n                {\n                    offset++;\n                    continue;\n                }\n\n                int copyLength = 1;\n                while (copyLength < length && copyLength + z[copyLength] < length)\n                {\n                    z[offset + copyLength] = z[copyLength];\n                    copyLength++;\n                }\n                offset += copyLength;\n                length -= copyLength;\n            }\n\n            return z;\n        }\n    }\n\n    /// <summary>\n    /// MP法（文字列検索アルゴリズム）\n    /// </summary>\n    public class MorrisPratt<T> where T : IEquatable<T>\n    {\n        readonly T[] _searchSequence;\n        readonly int[] _matchLength;\n\n        public ReadOnlySpan<T> SearchSequence => _searchSequence.AsSpan();\n\n        /// <summary>\n        /// 検索データ列の前処理を行います。\n        /// </summary>\n        /// <param name=\"searchSequence\">検索データ列</param>\n        public MorrisPratt(ReadOnlySpan<T> searchSequence)\n        {\n            _searchSequence = searchSequence.ToArray();\n            _matchLength = new int[_searchSequence.Length + 1];\n            _matchLength[0] = -1;\n            int j = -1;\n            for (int i = 0; i < _searchSequence.Length; i++)\n            {\n                while (j != -1 && !_searchSequence[j].Equals(_searchSequence[i]))\n                {\n                    j = _matchLength[j];\n                }\n                j++;\n                _matchLength[i + 1] = j;\n            }\n        }\n\n        /// <summary>\n        /// 与えられた対象データ列の部分列のうち、検索データ列にマッチする部分列の開始インデックスを取得します。\n        /// </summary>\n        /// <param name=\"targetSequence\">検索対象データ列</param>\n        /// <returns></returns>\n        public List<int> SearchAll(ReadOnlySpan<T> targetSequence)\n        {\n            var results = new List<int>();\n            int j = 0;\n            for (int i = 0; i < targetSequence.Length; i++)\n            {\n                while (j != -1 && !_searchSequence[j].Equals(targetSequence[i]))\n                {\n                    j = _matchLength[j];\n                }\n                j++;\n                if (j == _searchSequence.Length)\n                {\n                    results.Add(i - j + 1);\n                    j = _matchLength[j];\n                }\n            }\n            return results;\n        }\n    }\n\n    /// <summary>\n    /// 参考: https://qiita.com/keymoon/items/11fac5627672a6d6a9f6\n    /// ジェネリクスに対応させるにはGetHashCode()を足していく？実装によっては重そうなのでとりあえずパス。\n    /// </summary>\n    public class RollingHash\n    {\n        const ulong Mask30 = (1UL << 30) - 1;\n        const ulong Mask31 = (1UL << 31) - 1;\n        const ulong Mod = (1UL << 61) - 1;\n        const ulong Positivizer = Mod * ((1UL << 3) - 1);   // 引き算する前に足すことでmodが負になることを防ぐやつ\n        static readonly uint base1;\n        static readonly uint base2;\n        static readonly List<ulong> pow1;\n        static readonly List<ulong> pow2;\n\n        static RollingHash()\n        {\n            var random = new Random();\n            base1 = (uint)random.Next(129, int.MaxValue >> 2);\n            base2 = (uint)random.Next(int.MaxValue >> 2, int.MaxValue); // 32bit目は0にしておく\n            pow1 = new List<ulong>() { 1 };\n            pow2 = new List<ulong>() { 1 };\n        }\n\n        ulong[] hash1;\n        ulong[] hash2;\n        public string RawString { get; }\n        public int Length => RawString.Length;\n\n        public RollingHash(string s)\n        {\n            RawString = s;\n            hash1 = new ulong[s.Length + 1];\n            hash2 = new ulong[s.Length + 1];\n\n            for (int i = pow1.Count; i < s.Length + 1; i++)\n            {\n                pow1.Add(CalculateModular(Multiply(pow1[i - 1], base1)));\n                pow2.Add(CalculateModular(Multiply(pow2[i - 1], base2)));\n            }\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                hash1[i + 1] = CalculateModular(Multiply(hash1[i], base1) + s[i]);\n                hash2[i + 1] = CalculateModular(Multiply(hash2[i], base2) + s[i]);\n            }\n        }\n\n        public (ulong, ulong) this[Range range]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                var (offset, length) = range.GetOffsetAndLength(Length);\n                return Slice(offset, length);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public (ulong, ulong) Slice(int begin, int length)\n        {\n            var result1 = CalculateModular(hash1[begin + length] + Positivizer - Multiply(hash1[begin], pow1[length]));\n            var result2 = CalculateModular(hash2[begin + length] + Positivizer - Multiply(hash2[begin], pow2[length]));\n            return (result1, result2);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong Multiply(ulong l, ulong r)\n        {\n            var lu = l >> 31;\n            var ll = l & Mask31;\n            var ru = r >> 31;\n            var rl = r & Mask31;\n            var mid = ll * ru + lu * rl;\n            return ((lu * ru) << 1) + ll * rl + ((mid & Mask30) << 31) + (mid >> 30);   // a * 2^61 ≡ a (mod 2^61 - 1)を使う\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong Multiply(ulong l, uint r)\n        {\n            var lu = l >> 31;\n            var mid = lu * r;\n            return (l & Mask31) * r + ((mid & Mask30) << 31) + (mid >> 30); // rの32bit目は0としている\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static ulong CalculateModular(ulong value)\n        {\n            value = (value & Mod) + (value >> 61);\n            if (value >= Mod)\n            {\n                value -= Mod;\n            }\n            return value;\n        }\n\n        public override string ToString() => RawString;\n    }\n\n    public class XorShift\n    {\n        ulong _x;\n\n        public XorShift() : this((ulong)DateTime.Now.Ticks) { }\n\n        public XorShift(ulong seed)\n        {\n            _x = seed;\n        }\n\n        /// <summary>\n        /// [0, (2^64)-1)の乱数を生成します。\n        /// </summary>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong Next()\n        {\n            _x = _x ^ (_x << 13);\n            _x = _x ^ (_x >> 7);\n            _x = _x ^ (_x << 17);\n            return _x;\n        }\n\n        /// <summary>\n        /// [0, <c>exclusiveMax</c>)の乱数を生成します。\n        /// </summary>\n        /// <param name=\"exclusiveMax\"></param>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public int Next(int exclusiveMax) => (int)(Next() % (uint)exclusiveMax);\n\n        /// <summary>\n        /// [0.0, 1.0)の乱数を生成します。\n        /// </summary>\n        /// <returns></returns>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public double NextDouble()\n        {\n            const ulong max = 1UL << 50;\n            const ulong mask = max - 1;\n            return (double)(Next() & mask) / max;\n        }\n    }\n\n    public static class AlgorithmHelpers\n    {\n        public static void UpdateWhenSmall<T>(ref T value, T other) where T : IComparable<T>\n        {\n            if (other.CompareTo(value) < 0)\n            {\n                value = other;\n            }\n        }\n\n        public static void UpdateWhenLarge<T>(ref T value, T other) where T : IComparable<T>\n        {\n            if (other.CompareTo(value) > 0)\n            {\n                value = other;\n            }\n        }\n    }\n\n    public class CoordinateShrinker<T> : IEnumerable<(int shrinkedIndex, T rawIndex)> where T : IComparable<T>, IEquatable<T>\n    {\n        Dictionary<T, int> _shrinkMapper;\n        T[] _expandMapper;\n        public int Count => _expandMapper.Length;\n\n        public CoordinateShrinker(IEnumerable<T> data)\n        {\n            _expandMapper = data.Distinct().ToArray();\n            Array.Sort(_expandMapper);\n\n            _shrinkMapper = new Dictionary<T, int>();\n            for (int i = 0; i < _expandMapper.Length; i++)\n            {\n                _shrinkMapper.Add(_expandMapper[i], i);\n            }\n        }\n\n        public int Shrink(T rawCoordinate) => _shrinkMapper[rawCoordinate];\n        public T Expand(int shrinkedCoordinate) => _expandMapper[shrinkedCoordinate];\n\n        public IEnumerator<(int shrinkedIndex, T rawIndex)> GetEnumerator()\n        {\n            for (int i = 0; i < _expandMapper.Length; i++)\n            {\n                yield return (i, _expandMapper[i]);\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n\n#endregion\n\n#region Collections\n\nnamespace Training20200909.Collections\n{\n    // See https://kumikomiya.com/competitive-programming-with-c-sharp/\n    public class UnionFindTree\n    {\n        private UnionFindNode[] _nodes;\n        public int Count => _nodes.Length;\n        public int Groups { get; private set; }\n\n        public UnionFindTree(int count)\n        {\n            _nodes = Enumerable.Range(0, count).Select(i => new UnionFindNode(i)).ToArray();\n            Groups = _nodes.Length;\n        }\n\n        public void Unite(int index1, int index2)\n        {\n            var succeed = _nodes[index1].Unite(_nodes[index2]);\n            if (succeed)\n            {\n                Groups--;\n            }\n        }\n\n        public bool IsInSameGroup(int index1, int index2) => _nodes[index1].IsInSameGroup(_nodes[index2]);\n        public int GetGroupSizeOf(int index) => _nodes[index].GetGroupSize();\n\n        private class UnionFindNode\n        {\n            private int _height;        // rootのときのみ有効\n            private int _groupSize;     // 同上\n            private UnionFindNode _parent;\n            public int ID { get; }\n\n            public UnionFindNode(int id)\n            {\n                _height = 0;\n                _groupSize = 1;\n                _parent = this;\n                ID = id;\n            }\n\n            public UnionFindNode FindRoot()\n            {\n                if (_parent != this) // not ref equals\n                {\n                    var root = _parent.FindRoot();\n                    _parent = root;\n                }\n\n                return _parent;\n            }\n\n            public int GetGroupSize() => FindRoot()._groupSize;\n\n            public bool Unite(UnionFindNode other)\n            {\n                var thisRoot = this.FindRoot();\n                var otherRoot = other.FindRoot();\n\n                if (thisRoot == otherRoot)\n                {\n                    return false;\n                }\n\n                if (thisRoot._height < otherRoot._height)\n                {\n                    thisRoot._parent = otherRoot;\n                    otherRoot._groupSize += thisRoot._groupSize;\n                    otherRoot._height = Math.Max(thisRoot._height + 1, otherRoot._height);\n                    return true;\n                }\n                else\n                {\n                    otherRoot._parent = thisRoot;\n                    thisRoot._groupSize += otherRoot._groupSize;\n                    thisRoot._height = Math.Max(otherRoot._height + 1, thisRoot._height);\n                    return true;\n                }\n            }\n\n            public bool IsInSameGroup(UnionFindNode other) => this.FindRoot() == other.FindRoot();\n\n            public override string ToString() => $\"{ID} root:{FindRoot().ID}\";\n        }\n    }\n\n    public class Deque<T> : IReadOnlyCollection<T>\n    {\n        public int Count { get; private set; }\n        private T[] _data;\n        private int _first;\n        private int _mask;\n\n        public Deque() : this(4) { }\n\n        public Deque(int minCapacity)\n        {\n            if (minCapacity <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(minCapacity), $\"{nameof(minCapacity)}は0より大きい値でなければなりません。\");\n            }\n            var capacity = GetPow2Over(minCapacity);\n            _data = new T[capacity];\n            _first = 0;\n            _mask = capacity - 1;\n        }\n\n        public Deque(IEnumerable<T> collection)\n        {\n            var dataArray = collection.ToArray();\n            var capacity = GetPow2Over(dataArray.Length);\n            _data = new T[capacity];\n            _first = 0;\n            _mask = capacity - 1;\n\n            for (int i = 0; i < dataArray.Length; i++)\n            {\n                _data[i] = dataArray[i];\n                Count++;\n            }\n        }\n\n        public T this[Index index]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get\n            {\n                var offset = index.GetOffset(Count);\n                if (unchecked((uint)offset) >= Count)\n                {\n                    ThrowArgumentOutOfRangeException(nameof(index), $\"{nameof(index)}がコレクションの範囲外です。\");\n                }\n                return _data[(_first + offset) & _mask];\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void EnqueueFirst(T item)\n        {\n            if (_data.Length == Count)\n            {\n                Resize();\n            }\n\n            _first = (_first - 1) & _mask;\n            _data[_first] = item;\n            Count++;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void EnqueueLast(T item)\n        {\n            if (_data.Length == Count)\n            {\n                Resize();\n            }\n\n            _data[(_first + Count++) & _mask] = item;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T DequeueFirst()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            var value = _data[_first];\n            _data[_first++] = default;\n            _first &= _mask;\n            return value;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T DequeueLast()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            var index = (_first + --Count) & _mask;\n            var value = _data[index];\n            _data[index] = default;\n            return value;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T PeekFirst()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            return _data[_first];\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T PeekLast()\n        {\n            if (Count == 0)\n            {\n                ThrowInvalidOperationException(\"Queueが空です。\");\n            }\n\n            return _data[(_first + Count - 1) & _mask];\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Resize()\n        {\n            var newArray = new T[_data.Length << 1];\n            var span = _data.AsSpan();\n            var firstHalf = span[_first..];\n            var lastHalf = span[.._first];\n            firstHalf.CopyTo(newArray);\n            lastHalf.CopyTo(newArray.AsSpan(firstHalf.Length));\n            _data = newArray;\n            _first = 0;\n            _mask = _data.Length - 1;\n        }\n\n        private void ThrowArgumentOutOfRangeException(string paramName, string message) => throw new ArgumentOutOfRangeException(paramName, message);\n        private void ThrowInvalidOperationException(string message) => throw new InvalidOperationException(message);\n\n        private int GetPow2Over(int n)\n        {\n            n--;\n            var result = 1;\n            while (n != 0)\n            {\n                n >>= 1;\n                result <<= 1;\n            }\n            return result;\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (int i = 0; i < Count; i++)\n            {\n                var offset = (_first + i) & _mask;\n                yield return _data[offset];\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class PriorityQueue<T> : IEnumerable<T> where T : IComparable<T>\n    {\n        private List<T> _heap = new List<T>();\n        private readonly int _reverseFactor;\n        public int Count => _heap.Count;\n        public bool IsDescending => _reverseFactor == 1;\n\n        public PriorityQueue(bool descending) : this(descending, null) { }\n\n        public PriorityQueue(bool descending, IEnumerable<T> collection)\n        {\n            _reverseFactor = descending ? 1 : -1;\n            _heap = new List<T>();\n\n            if (collection != null)\n            {\n                foreach (var item in collection)\n                {\n                    Enqueue(item);\n                }\n            }\n        }\n\n        public void Enqueue(T item)\n        {\n            _heap.Add(item);\n            UpHeap();\n        }\n\n        public T Dequeue()\n        {\n            var item = _heap[0];\n            DownHeap();\n            return item;\n        }\n\n        public T Peek() => _heap[0];\n\n        private void UpHeap()\n        {\n            var child = Count - 1;\n            while (child > 0)\n            {\n                int parent = (child - 1) / 2;\n\n                if (Compare(_heap[child], _heap[parent]) > 0)\n                {\n                    SwapAt(child, parent);\n                    child = parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n\n        private void DownHeap()\n        {\n            _heap[0] = _heap[Count - 1];\n            _heap.RemoveAt(Count - 1);\n\n            var parent = 0;\n            while (true)\n            {\n                var leftChild = 2 * parent + 1;\n\n                if (leftChild > Count - 1)\n                {\n                    break;\n                }\n\n                var target = (leftChild < Count - 1) && (Compare(_heap[leftChild], _heap[leftChild + 1]) < 0) ? leftChild + 1 : leftChild;\n\n                if (Compare(_heap[parent], _heap[target]) < 0)\n                {\n                    SwapAt(parent, target);\n                }\n                else\n                {\n                    break;\n                }\n\n                parent = target;\n            }\n        }\n\n        private int Compare(T a, T b) => _reverseFactor * a.CompareTo(b);\n\n        private void SwapAt(int n, int m) => (_heap[n], _heap[m]) = (_heap[m], _heap[n]);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            var copy = new List<T>(_heap);\n            try\n            {\n                while (Count > 0)\n                {\n                    yield return Dequeue();\n                }\n            }\n            finally\n            {\n                _heap = copy;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class SegmentTree<TMonoid> : IEnumerable<TMonoid> where TMonoid : IMonoid<TMonoid>, new()\n    {\n        private readonly TMonoid[] _data;\n        private readonly TMonoid _identityElement;\n\n        private readonly int _leafOffset;   // n - 1\n        private readonly int _leafLength;   // n (= 2^k)\n\n        public int Length { get; }          // 実データ長\n        public ReadOnlySpan<TMonoid> Data => _data.AsSpan(_leafOffset, Length);\n\n        public SegmentTree(ICollection<TMonoid> data)\n        {\n            Length = data.Count;\n            _leafLength = GetMinimumPow2(data.Count);\n            _leafOffset = _leafLength - 1;\n            _data = new TMonoid[_leafOffset + _leafLength];\n            _identityElement = new TMonoid().Identity;\n\n            data.CopyTo(_data, _leafOffset);\n            BuildTree();\n        }\n\n        public TMonoid this[int index]\n        {\n            get => Data[index];\n            set\n            {\n                if (index < 0 || index >= Length)\n                {\n                    throw new IndexOutOfRangeException($\"{nameof(index)}がデータの範囲外です。\");\n                }\n                index += _leafOffset;\n                _data[index] = value;\n                while (index > 0)\n                {\n                    // 一つ上の親の更新\n                    index = (index - 1) / 2;\n                    _data[index] = _data[index * 2 + 1] * _data[index * 2 + 2];\n                }\n            }\n        }\n\n        public TMonoid Query(Range range)\n        {\n            var (offset, length) = range.GetOffsetAndLength(Length);\n            if (length <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(range), $\"{nameof(range)}の長さは0より大きくなければなりません。\");\n            }\n            return Query(offset, offset + length);\n        }\n\n        public TMonoid Query(int begin, int end)\n        {\n            if (begin < 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(begin), $\"{nameof(begin)}は0以上の数でなければなりません。\");\n            }\n            if (end > Length)\n            {\n                throw new ArgumentOutOfRangeException(nameof(end), $\"{nameof(end)}は{nameof(Length)}以下でなければなりません。\");\n            }\n            if (begin >= end)\n            {\n                throw new ArgumentException($\"{nameof(begin)},{nameof(end)}\", $\"{nameof(end)}は{nameof(begin)}より大きい数でなければなりません。\");\n            }\n            return Query(begin, end, 0, 0, _leafLength);\n        }\n\n        private TMonoid Query(int begin, int end, int index, int left, int right)\n        {\n            if (right <= begin || end <= left)      // 範囲外\n            {\n                return _identityElement;\n            }\n            else if (begin <= left && right <= end) // 全部含まれる\n            {\n                return _data[index];\n            }\n            else    // 一部だけ含まれる\n            {\n                var leftValue = Query(begin, end, index * 2 + 1, left, (left + right) / 2);     // 左の子\n                var rightValue = Query(begin, end, index * 2 + 2, (left + right) / 2, right);   // 右の子\n                return leftValue * rightValue;\n            }\n        }\n\n        private void BuildTree()\n        {\n            foreach (ref var unusedLeaf in _data.AsSpan()[(_leafOffset + Length)..])\n            {\n                unusedLeaf = _identityElement;  // 単位元埋め\n            }\n\n            for (int i = _leafLength - 2; i >= 0; i--)  // 葉の親から順番に一つずつ上がっていく\n            {\n                _data[i] = _data[2 * i + 1] * _data[2 * i + 2]; // f(left, right)\n            }\n        }\n\n        private int GetMinimumPow2(int n)\n        {\n            var p = 1;\n            while (p < n)\n            {\n                p *= 2;\n            }\n            return p;\n        }\n\n        public IEnumerator<TMonoid> GetEnumerator()\n        {\n            var upperIndex = _leafOffset + Length;\n            for (int i = _leafOffset; i < upperIndex; i++)\n            {\n                yield return _data[i];\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n\n    public class BinaryIndexedTree\n    {\n        long[] _data;\n        public int Length { get; }\n\n        public BinaryIndexedTree(int length)\n        {\n            _data = new long[length + 1];   // 内部的には1-indexedにする\n            Length = length;\n        }\n\n        public BinaryIndexedTree(IEnumerable<long> data, int length) : this(length)\n        {\n            var count = 0;\n            foreach (var n in data)\n            {\n                AddAt(count++, n);\n            }\n        }\n\n        public BinaryIndexedTree(ICollection<long> collection) : this(collection, collection.Count) { }\n\n        public long this[Index index]\n        {\n            get => Sum(index..(index.GetOffset(Length) + 1));\n            set\n            {\n                if (value < 0)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(value), $\"{nameof(value)}は0以上の値である必要があります。\");\n                }\n                AddAt(index, value - this[index]);\n            }\n        }\n\n        /// <summary>\n        /// BITの<c>index</c>番目の要素に<c>n</c>を加算します。\n        /// </summary>\n        /// <param name=\"index\">加算するインデックス（0-indexed）</param>\n        /// <param name=\"value\">加算する数</param>\n        public void AddAt(Index index, long value)\n        {\n            var i = index.GetOffset(Length);\n            unchecked\n            {\n                if ((uint)i >= (uint)Length)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(index));\n                }\n            }\n\n            i++;  // 1-indexedにする\n\n            while (i <= Length)\n            {\n                _data[i] += value;\n                i += i & -i;    // LSBの加算\n            }\n        }\n\n        /// <summary>\n        /// [0, <c>end</c>)の部分和を返します。\n        /// </summary>\n        /// <param name=\"end\">部分和を求める半開区間の終了インデックス</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(Index end)\n        {\n            var i = end.GetOffset(Length);  // 0-indexedの半開区間＝1-indexedの閉区間なので+1は不要\n            unchecked\n            {\n                if ((uint)i >= (uint)_data.Length)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(end));\n                }\n            }\n\n            long sum = 0;\n            while (i > 0)\n            {\n                sum += _data[i];\n                i -= i & -i;    // LSBの減算\n            }\n            return sum;\n        }\n\n        /// <summary>\n        /// <c>range</c>の部分和を返します。\n        /// </summary>\n        /// <param name=\"range\">部分和を求める半開区間</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(Range range) => Sum(range.End) - Sum(range.Start);\n\n        /// <summary>\n        /// [<c>start</c>, <c>end</c>)の部分和を返します。\n        /// </summary>\n        /// <param name=\"start\">部分和を求める半開区間の開始インデックス</param>\n        /// <param name=\"end\">部分和を求める半開区間の終了インデックス</param>\n        /// <returns>区間の部分和</returns>\n        public long Sum(int start, int end) => Sum(end) - Sum(start);\n\n        /// <summary>\n        /// [0, <c>index</c>)の部分和が<c>sum</c>未満になる最大の<c>index</c>を返します。\n        /// BIT上の各要素は0以上の数である必要があります。\n        /// </summary>\n        /// <param name=\"sum\"></param>\n        /// <returns></returns>\n        public int GetLowerBound(long sum)\n        {\n            int index = 0;\n            for (int offset = GetMostSignificantBitOf(Length); offset > 0; offset >>= 1)\n            {\n                if (index + offset < _data.Length && _data[index + offset] < sum)\n                {\n                    index += offset;\n                    sum -= _data[index];\n                }\n            }\n\n            return index;\n\n            int GetMostSignificantBitOf(int n)\n            {\n                int k = 1;\n                while ((k << 1) <= n)\n                {\n                    k <<= 1;\n                };\n                return k;\n            }\n        }\n    }\n\n    public class BinaryIndexedTree2D\n    {\n        long[,] _data;\n        public int Height { get; }\n        public int Width { get; }\n\n        public BinaryIndexedTree2D(int height, int width)\n        {\n            Height = height;\n            Width = width;\n            _data = new long[height + 1, width + 1];\n        }\n\n        public long this[Index row, Index column]\n        {\n            get => Sum(row..(row.GetOffset(Height) + 1), column..(column.GetOffset(Width) + 1));\n            set\n            {\n                if (value < 0)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(value), $\"{nameof(value)}は0以上の値である必要があります。\");\n                }\n                AddAt(row, column, value - this[row, column]);\n            }\n        }\n\n        /// <summary>\n        /// 2次元BITの[<c>row</c>, <c>column</c>]に<c>value</c>を足します。\n        /// </summary>\n        /// <param name=\"row\">加算する行（0-indexed）</param>\n        /// <param name=\"column\">加算する列（0-indexed）</param>\n        /// <param name=\"value\">加算する値</param>\n        public void AddAt(Index row, Index column, long value)\n        {\n            var initI = row.GetOffset(Height);\n            var initJ = column.GetOffset(Width);\n            unchecked\n            {\n                if ((ulong)initI >= (ulong)Height)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(row));\n                }\n                if ((ulong)initJ >= (ulong)Width)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(column));\n                }\n            }\n\n            initI++;    // 1-indexed\n            initJ++;\n\n            for (int i = initI; i <= Height; i += i & -i)\n            {\n                for (int j = initJ; j <= Width; j += j & -j)\n                {\n                    _data[i, j] += value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"row\"></param>\n        /// <param name=\"column\"></param>\n        /// <returns></returns>\n        public long Sum(Index row, Index column)\n        {\n            long sum = 0;\n            var initI = row.GetOffset(Height);\n            var initJ = column.GetOffset(Width);\n            unchecked\n            {\n                if ((ulong)initI >= (ulong)(Height + 1))\n                {\n                    throw new ArgumentOutOfRangeException(nameof(row));\n                }\n                if ((ulong)initJ >= (ulong)(Width + 1))\n                {\n                    throw new ArgumentOutOfRangeException(nameof(column));\n                }\n            }\n\n            for (int i = initI; i > 0; i -= i & -i)\n            {\n                for (int j = initJ; j > 0; j -= j & -j)\n                {\n                    sum += _data[i, j];\n                }\n            }\n            return sum;\n        }\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"rows\"></param>\n        /// <param name=\"columns\"></param>\n        /// <returns></returns>\n        public long Sum(Range rows, Range columns) => Sum(rows.End, columns.End) - Sum(rows.Start, columns.End) - Sum(rows.End, columns.Start) + Sum(rows.Start, columns.Start);\n\n        /// <summary>\n        /// 指定した半開区間の部分和を返します。\n        /// </summary>\n        /// <param name=\"beginRow\"></param>\n        /// <param name=\"endRow\"></param>\n        /// <param name=\"beginColumn\"></param>\n        /// <param name=\"endColumn\"></param>\n        /// <returns></returns>\n        public long Sum(int beginRow, int endRow, int beginColumn, int endColumn) => Sum(beginRow..endRow, beginColumn..endColumn);\n    }\n\n    public class Counter<T> : IEnumerable<(T key, long count)> where T : IEquatable<T>\n    {\n        private Dictionary<T, long> _innerDictionary;\n\n        public Counter()\n        {\n            _innerDictionary = new Dictionary<T, long>();\n        }\n\n        public IEnumerator<(T key, long count)> GetEnumerator()\n        {\n            foreach (var pair in _innerDictionary)\n            {\n                yield return (key: pair.Key, count: pair.Value);\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public long this[T key]\n        {\n            get\n            {\n                _innerDictionary.TryGetValue(key, out var count);\n                return count;\n            }\n            set\n            {\n                _innerDictionary[key] = value;\n            }\n        }\n    }\n\n    public readonly struct BitSet : IEquatable<BitSet>\n    {\n        readonly uint _value;\n\n        public BitSet(uint value)\n        {\n            _value = value;\n        }\n        public bool this[int digit]\n        {\n            get => ((_value >> digit) & 1) > 0;\n        }\n        public bool Any => _value > 0;\n        public bool None => _value == 0;\n        public BitSet SetAt(int digit, bool value) => value ? new BitSet(_value | (1u << digit)) : new BitSet(_value & ~(1u << digit));\n        public BitSet Lsb() { unchecked { return new BitSet(_value & (uint)-(int)_value); } }\n        public BitSet Reverse()\n        {\n            unchecked\n            {\n                uint v = _value;\n                v = (v & 0x55555555) << 1 | (v >> 1 & 0x55555555);\n                v = (v & 0x33333333) << 2 | (v >> 2 & 0x33333333);\n                v = (v & 0x0f0f0f0f) << 4 | (v >> 4 & 0x0f0f0f0f);\n                v = (v & 0x00ff00ff) << 8 | (v >> 8 & 0x00ff00ff);\n                v = (v & 0x0000ffff) << 16 | (v >> 16 & 0x0000ffff);\n                return new BitSet(v);\n            }\n        }\n        public int Count()\n        {\n            unchecked\n            {\n                // Hardware Intrinsics未使用\n                uint v = _value;\n                v = (v & 0x55555555) + (v >> 1 & 0x55555555);\n                v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n                v = (v & 0x0f0f0f0f) + (v >> 4 & 0x0f0f0f0f);\n                v = (v & 0x00ff00ff) + (v >> 8 & 0x00ff00ff);\n                v = (v & 0x0000ffff) + (v >> 16 & 0x0000ffff);\n                return (int)v;\n            }\n        }\n\n        public static BitSet Zero => new BitSet(0);\n        public static BitSet One => new BitSet(1);\n        public static BitSet All => new BitSet(~0u);\n        public static BitSet At(int digit) => new BitSet(1u << digit);\n        public static BitSet CreateMask(int digit) => new BitSet((1u << digit) - 1);\n        public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet._value + 1);\n        public static BitSet operator --(BitSet bitSet) => new BitSet(bitSet._value - 1);\n        public static BitSet operator ~(BitSet bitSet) => new BitSet(~bitSet._value);\n        public static BitSet operator &(BitSet left, BitSet right) => new BitSet(left._value & right._value);\n        public static BitSet operator |(BitSet left, BitSet right) => new BitSet(left._value | right._value);\n        public static BitSet operator ^(BitSet left, BitSet right) => new BitSet(left._value ^ right._value);\n        public static BitSet operator <<(BitSet bitSet, int n) => new BitSet(bitSet._value << n);\n        public static BitSet operator >>(BitSet bitSet, int n) => new BitSet(bitSet._value >> n);\n        public static bool operator <(BitSet left, BitSet right) => left._value < right._value;\n        public static bool operator <=(BitSet left, BitSet right) => left._value <= right._value;\n        public static bool operator >(BitSet left, BitSet right) => left._value > right._value;\n        public static bool operator >=(BitSet left, BitSet right) => left._value >= right._value;\n        public static bool operator ==(BitSet left, BitSet right) => left.Equals(right);\n        public static bool operator !=(BitSet left, BitSet right) => !(left == right);\n        public static implicit operator uint(BitSet bitSet) => bitSet._value;\n\n        public override bool Equals(object obj) => obj is BitSet set && Equals(set);\n        public bool Equals(BitSet other) => _value == other._value;\n        public override string ToString() => Convert.ToString(_value, 2);\n        public override int GetHashCode() => _value.GetHashCode();\n    }\n\n    public static class SearchExtensions\n    {\n        class LowerBoundComparer<T> : IComparer<T> where T : IComparable<T>\n        {\n            public int Compare(T x, T y) => 0 <= x.CompareTo(y) ? 1 : -1;\n        }\n\n        class UpperBoundComparer<T> : IComparer<T> where T : IComparable<T>\n        {\n            public int Compare(T x, T y) => 0 < x.CompareTo(y) ? 1 : -1;\n        }\n\n        // https://trsing.hatenablog.com/entry/2019/08/27/211038\n        public static int GetGreaterEqualIndex<T>(this ReadOnlySpan<T> span, T inclusiveMin) where T : IComparable<T> => ~span.BinarySearch(inclusiveMin, new UpperBoundComparer<T>());\n        public static int GetGreaterThanIndex<T>(this ReadOnlySpan<T> span, T exclusiveMin) where T : IComparable<T> => ~span.BinarySearch(exclusiveMin, new LowerBoundComparer<T>());\n        public static int GetLessEqualIndex<T>(this ReadOnlySpan<T> span, T inclusiveMax) where T : IComparable<T> => ~span.BinarySearch(inclusiveMax, new LowerBoundComparer<T>()) - 1;\n        public static int GetLessThanIndex<T>(this ReadOnlySpan<T> span, T exclusiveMax) where T : IComparable<T> => ~span.BinarySearch(exclusiveMax, new UpperBoundComparer<T>()) - 1;\n        public static int GetGreaterEqualIndex<T>(this Span<T> span, T inclusiveMin) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetGreaterEqualIndex(inclusiveMin);\n        public static int GetGreaterThanIndex<T>(this Span<T> span, T exclusiveMin) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetGreaterThanIndex(exclusiveMin);\n        public static int GetLessEqualIndex<T>(this Span<T> span, T inclusiveMax) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetLessEqualIndex(inclusiveMax);\n        public static int GetLessThanIndex<T>(this Span<T> span, T exclusiveMax) where T : IComparable<T> => ((ReadOnlySpan<T>)span).GetLessThanIndex(exclusiveMax);\n\n        public static int BoundaryBinarySearch(Predicate<int> predicate, int ok, int ng)\n        {\n            // めぐる式二分探索\n            while (Math.Abs(ok - ng) > 1)\n            {\n                int mid = (ok + ng) / 2;\n                if (predicate(mid))\n                {\n                    ok = mid;\n                }\n                else\n                {\n                    ng = mid;\n                }\n            }\n            return ok;\n        }\n\n        public static long BoundaryBinarySearch(Predicate<long> predicate, long ok, long ng)\n        {\n            while (Math.Abs(ok - ng) > 1)\n            {\n                long mid = (ok + ng) / 2;\n                if (predicate(mid))\n                {\n                    ok = mid;\n                }\n                else\n                {\n                    ng = mid;\n                }\n            }\n            return ok;\n        }\n\n        public static double Bisection(Func<double, double> f, double a, double b, double eps = 1e-9)\n        {\n            if (f(a) * f(b) >= 0)\n            {\n                throw new ArgumentException(\"f(a)とf(b)は異符号である必要があります。\");\n            }\n\n            const int maxLoop = 100;\n            double mid = (a + b) / 2;\n\n            for (int i = 0; i < maxLoop; i++)\n            {\n                if (f(a) * f(mid) < 0)\n                {\n                    b = mid;\n                }\n                else\n                {\n                    a = mid;\n                }\n                mid = (a + b) / 2;\n                if (Math.Abs(b - a) < eps)\n                {\n                    break;\n                }\n            }\n            return mid;\n        }\n    }\n\n    public static class PermutationAlgorithms\n    {\n        public static IEnumerable<ReadOnlyMemory<T>> GetPermutations<T>(IEnumerable<T> collection) where T : IComparable<T> => GetPermutations(collection, false);\n\n        public static IEnumerable<ReadOnlyMemory<T>> GetPermutations<T>(IEnumerable<T> collection, bool isSorted) where T : IComparable<T>\n        {\n            var a = collection.ToArray();\n\n            if (!isSorted && a.Length > 1)\n            {\n                Array.Sort(a);\n            }\n\n            yield return a; // ソート済み初期配列\n\n            if (a.Length <= 2)\n            {\n                if (a.Length == 2 && a[0].CompareTo(a[1]) != 0)\n                {\n                    (a[0], a[1]) = (a[1], a[0]);\n                    yield return a;\n                    yield break;\n                }\n\n                yield break;\n            }\n\n            bool flag = true;\n            while (flag)\n            {\n                flag = false;\n                for (int i = a.Length - 2; i >= 0; i--)\n                {\n                    // iよりi+1の方が大きい（昇順）なら\n                    if (a[i].CompareTo(a[i + 1]) < 0)\n                    {\n                        // 後ろから見ていってi<jとなるところを探して\n                        int j;\n                        for (j = a.Length - 1; a[i].CompareTo(a[j]) >= 0; j--) { }\n\n                        // iとjを入れ替えて\n                        (a[i], a[j]) = (a[j], a[i]);\n\n                        // i+1以降を反転\n                        if (i < a.Length - 2)\n                        {\n                            var sliced = a.AsSpan().Slice(i + 1);\n                            sliced.Reverse();\n                        }\n\n                        flag = true;\n                        yield return a;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class EnumerableExtensions\n    {\n        public static IEnumerable<(T1 v1, T2 v2)> Zip<T1, T2>(this (IEnumerable<T1> First, IEnumerable<T2> Second) t)\n            => t.First.Zip(t.Second, (v1, v2) => (v1, v2));\n\n        public static IEnumerable<(T1 v1, T2 v2, T3 v3)> Zip<T1, T2, T3>(this (IEnumerable<T1> First, IEnumerable<T2> Second, IEnumerable<T3> Third) t)\n            => (t.First, t.Second).Zip().Zip(t.Third, (v12, v3) => (v12.v1, v12.v2, v3));\n\n        public static IEnumerable<(T item, int index)> WithIndex<T>(this IEnumerable<T> source) => source.Select((item, index) => (item, index));\n    }\n\n    public static class ArrayExtensions\n    {\n        public static T[] SetAll<T>(this T[] array, Func<int, T> func)\n        {\n            for (int i = 0; i < array.Length; i++)\n                array[i] = func(i);\n            return array;\n        }\n\n        public static T[,] SetAll<T>(this T[,] array, Func<int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    array[i, j] = func(i, j);\n            return array;\n        }\n\n        public static T[,,] SetAll<T>(this T[,,] array, Func<int, int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            var length2 = array.GetLength(2);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    for (int k = 0; k < length2; k++)\n                        array[i, j, k] = func(i, j, k);\n            return array;\n        }\n\n        public static T[,,,] SetAll<T>(this T[,,,] array, Func<int, int, int, int, T> func)\n        {\n            var length0 = array.GetLength(0);\n            var length1 = array.GetLength(1);\n            var length2 = array.GetLength(2);\n            var length3 = array.GetLength(3);\n            for (int i = 0; i < length0; i++)\n                for (int j = 0; j < length1; j++)\n                    for (int k = 0; k < length2; k++)\n                        for (int l = 0; l < length3; l++)\n                            array[i, j, k, l] = func(i, j, k, l);\n            return array;\n        }\n    }\n}\n\n#endregion\n\n#region Graphs\n\nnamespace Training20200909.Graphs\n{\n    public interface INode\n    {\n        public int Index { get; }\n    }\n\n    public interface IEdge<TNode> where TNode : INode\n    {\n        TNode From { get; }\n        TNode To { get; }\n    }\n\n    public interface IWeightedEdge<TNode> : IEdge<TNode> where TNode : INode\n    {\n        long Weight { get; }\n    }\n\n    public interface IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n    {\n        IEnumerable<TEdge> this[TNode node] { get; }\n        IEnumerable<TEdge> Edges { get; }\n        IEnumerable<TNode> Nodes { get; }\n        int NodeCount { get; }\n    }\n\n    public interface IWeightedGraph<TNode, TEdge> : IGraph<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode { }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct BasicNode : INode, IEquatable<BasicNode>\n    {\n        public int Index { get; }\n\n        public BasicNode(int index)\n        {\n            Index = index;\n        }\n\n        public override string ToString() => Index.ToString();\n        public override bool Equals(object obj) => obj is BasicNode node && Equals(node);\n        public bool Equals(BasicNode other) => Index == other.Index;\n        public override int GetHashCode() => HashCode.Combine(Index);\n        public static bool operator ==(BasicNode left, BasicNode right) => left.Equals(right);\n        public static bool operator !=(BasicNode left, BasicNode right) => !(left == right);\n        public static implicit operator BasicNode(int value) => new BasicNode(value);\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct BasicEdge : IEdge<BasicNode>\n    {\n        public BasicNode From { get; }\n        public BasicNode To { get; }\n\n        public BasicEdge(int from, int to)\n        {\n            From = from;\n            To = to;\n        }\n\n        public override string ToString() => $\"{From}-->{To}\";\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct WeightedEdge : IWeightedEdge<BasicNode>\n    {\n        public BasicNode From { get; }\n        public BasicNode To { get; }\n        public long Weight { get; }\n\n        public WeightedEdge(int from, int to) : this(from, to, 1) { }\n\n        public WeightedEdge(int from, int to, long weight)\n        {\n            From = from;\n            To = to;\n            Weight = weight;\n        }\n\n        public override string ToString() => $\"{From}--[{Weight}]-->{To}\";\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct GridNode : INode, IEquatable<GridNode>\n    {\n        public int Row { get; }\n        public int Column { get; }\n        public int Index { get; }\n\n        public GridNode(int row, int column, int width)\n        {\n            Row = row;\n            Column = column;\n            Index = row * width + column;\n        }\n\n        public override string ToString() => $\"({Row}, {Column})\";\n        public override int GetHashCode() => HashCode.Combine(Row, Column, Index);\n        public override bool Equals(object obj) => obj is GridNode node && Equals(node);\n        public bool Equals(GridNode other) => Row == other.Row && Column == other.Column && Index == other.Index;\n        public void Deconstruct(out int row, out int column) { row = Row; column = Column; }\n        public static bool operator ==(GridNode left, GridNode right) => left.Equals(right);\n        public static bool operator !=(GridNode left, GridNode right) => !(left == right);\n    }\n\n    [StructLayout(LayoutKind.Auto)]\n    public readonly struct GridEdge : IEdge<GridNode>\n    {\n        public GridNode From { get; }\n        public GridNode To { get; }\n\n        public GridEdge(GridNode from, GridNode to)\n        {\n            From = from;\n            To = to;\n        }\n\n        public override string ToString() => $\"({From.Row}, {From.Column})-->({To.Row}, {To.Column})\";\n    }\n\n    public class BasicGraph : IGraph<BasicNode, BasicEdge>\n    {\n        private readonly List<BasicEdge>[] _edges;\n        public IEnumerable<BasicEdge> this[BasicNode node] => _edges[node.Index];\n        public IEnumerable<BasicEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<BasicNode> Nodes => Enumerable.Range(0, NodeCount).Select(i => new BasicNode(i));\n        public int NodeCount { get; }\n\n        public BasicGraph(int nodeCount) : this(nodeCount, Enumerable.Empty<BasicEdge>()) { }\n\n        public BasicGraph(int nodeCount, IEnumerable<BasicEdge> edges)\n        {\n            _edges = Enumerable.Repeat(0, nodeCount).Select(_ => new List<BasicEdge>()).ToArray();\n            NodeCount = nodeCount;\n            foreach (var edge in edges)\n            {\n                AddEdge(edge);\n            }\n        }\n\n        public BasicGraph(int nodeCount, IEnumerable<IEnumerable<int>> distances)\n        {\n            _edges = new List<BasicEdge>[nodeCount];\n\n            int i = 0;\n            foreach (var row in distances)\n            {\n                _edges[i] = new List<BasicEdge>(nodeCount);\n                int j = 0;\n                foreach (var distance in row)\n                {\n                    if (distance == 1)\n                    {\n                        _edges[i].Add(new BasicEdge(i, j++));\n                    }\n                }\n                i++;\n            }\n        }\n\n        public void AddEdge(BasicEdge edge) => _edges[edge.From.Index].Add(edge);\n    }\n\n    public class WeightedGraph : IGraph<BasicNode, WeightedEdge>\n    {\n        private readonly List<WeightedEdge>[] _edges;\n        public IEnumerable<WeightedEdge> this[BasicNode node] => _edges[node.Index];\n        public IEnumerable<WeightedEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<BasicNode> Nodes => Enumerable.Range(0, NodeCount).Select(i => new BasicNode(i));\n        public int NodeCount { get; }\n\n        public WeightedGraph(int nodeCount) : this(nodeCount, Enumerable.Empty<WeightedEdge>()) { }\n\n        public WeightedGraph(int nodeCount, IEnumerable<WeightedEdge> edges)\n        {\n            _edges = Enumerable.Repeat(0, nodeCount).Select(_ => new List<WeightedEdge>()).ToArray();\n            NodeCount = nodeCount;\n            foreach (var edge in edges)\n            {\n                AddEdge(edge);\n            }\n        }\n\n        public WeightedGraph(int nodeCount, IEnumerable<IEnumerable<int>> distances)\n        {\n            _edges = new List<WeightedEdge>[nodeCount];\n\n            int i = 0;\n            foreach (var row in distances)\n            {\n                _edges[i] = new List<WeightedEdge>(nodeCount);\n                int j = 0;\n                foreach (var distance in row)\n                {\n                    _edges[i].Add(new WeightedEdge(i, j++, distance));\n                }\n                i++;\n            }\n        }\n\n        public void AddEdge(WeightedEdge edge) => _edges[edge.From.Index].Add(edge);\n    }\n\n    public class GridGraph : IGraph<GridNode, GridEdge>\n    {\n        private readonly IReadOnlyList<(int dx, int dy)> _adjacents;\n        public int Height { get; }\n        public int Width { get; }\n        public int NodeCount => Height * Width;\n\n        public IEnumerable<GridEdge> this[GridNode node]\n        {\n            get\n            {\n                foreach (var (dx, dy) in _adjacents)\n                {\n                    var next = new GridNode(node.Row + dx, node.Column + dy, Width);\n                    if (CanEnter(next))\n                    {\n                        yield return new GridEdge(node, next);\n                    }\n                }\n            }\n        }\n\n        public IEnumerable<GridEdge> Edges => Nodes.SelectMany(node => this[node]);\n        public IEnumerable<GridNode> Nodes => Enumerable.Range(0, Width).SelectMany(x => Enumerable.Range(0, Height).Select(y => new GridNode(x, y, Width)));\n\n        public GridGraph(int height, int width) : this(height, width, new (int dx, int dy)[] { (-1, 0), (1, 0), (0, -1), (0, 1) }) { }\n\n        public GridGraph(int height, int width, IEnumerable<(int dx, int dy)> adjacents)\n        {\n            Height = height;\n            Width = width;\n            _adjacents = adjacents.ToArray();\n        }\n\n        protected virtual bool CanEnter(GridNode node)\n        {\n            unchecked\n            {\n                return (uint)node.Row < Height && (uint)node.Column < Width;\n            }\n        }\n    }\n\n    namespace Algorithms\n    {\n        // TGraphは派生クラスでいじりたいことがあるのでジェネリクス。\n        // TNode, TEdgeはインターフェースで受け取っても動くが、構造体のDevirtualizationを行うため敢えてジェネリクスにしている（型引数長いのでなんとかしたい……）\n        public abstract class BfsBase<TGraph, TNode, TEdge, TResult> where TGraph : IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n        {\n            protected readonly TGraph _graph;\n            protected bool _completed;\n\n            protected BfsBase(TGraph graph)\n            {\n                _graph = graph;\n            }\n\n            public TResult Search(TNode startNode)\n            {\n                var todo = new Queue<TNode>();\n                var seen = new bool[_graph.NodeCount];\n                var cameFrom = new TNode[_graph.NodeCount];\n                _completed = false;\n                todo.Enqueue(startNode);\n                seen[startNode.Index] = true;\n                Initialize(startNode);\n\n                while (todo.Count > 0 && !_completed)\n                {\n                    var current = todo.Dequeue();\n                    var isFirstNode = current.Index == startNode.Index;\n                    OnPreordering(current, cameFrom[current.Index], isFirstNode);\n\n                    foreach (var edge in _graph[current])\n                    {\n                        if (seen[edge.To.Index])\n                        {\n                            continue;\n                        }\n                        seen[edge.To.Index] = true;\n                        cameFrom[edge.To.Index] = edge.From;\n                        todo.Enqueue(edge.To);\n                    }\n                }\n\n                return GetResult();\n            }\n\n            protected abstract void Initialize(TNode startNode);\n            protected abstract void OnPreordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract TResult GetResult();\n        }\n\n        public abstract class DfsBase<TGraph, TNode, TEdge, TResult> where TGraph : IGraph<TNode, TEdge> where TEdge : IEdge<TNode> where TNode : INode\n        {\n            protected readonly TGraph _graph;\n            protected bool _completed;\n\n            protected DfsBase(TGraph graph)\n            {\n                _graph = graph;\n            }\n\n            public TResult Search(TNode startNode)\n            {\n                var todo = new Stack<TNode>();\n                var seen = new bool[_graph.NodeCount];\n                var preorderCompleted = new bool[_graph.NodeCount];\n                var cameFrom = new TNode[_graph.NodeCount];\n                _completed = false;\n                todo.Push(startNode);\n                seen[startNode.Index] = true;\n                Initialize(startNode);\n\n                while (todo.Count > 0 && !_completed)\n                {\n                    var current = todo.Peek();\n                    var isFirstNode = current.Index == startNode.Index;\n\n                    if (!preorderCompleted[current.Index])\n                    {\n                        // 行きがけ\n                        OnPreordering(current, cameFrom[current.Index], isFirstNode);\n                        foreach (var edge in _graph[current])\n                        {\n                            if (seen[edge.To.Index])\n                            {\n                                continue;\n                            }\n                            seen[edge.To.Index] = true;\n                            cameFrom[edge.To.Index] = edge.From;\n                            todo.Push(edge.To);\n                        }\n                        preorderCompleted[current.Index] = true;\n                    }\n                    else\n                    {\n                        // 帰りがけ\n                        OnPostordering(current, cameFrom[current.Index], isFirstNode);\n                        _ = todo.Pop();\n                    }\n                }\n\n                return GetResult();\n            }\n\n            protected abstract void Initialize(TNode startNode);\n            protected abstract void OnPreordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract void OnPostordering(TNode current, TNode previous, bool isFirstNode);\n            protected abstract TResult GetResult();\n        }\n\n        // 最短経路問題やるだけの問題でIGraphを派生クラスでいじりたいことはほとんどないので普通にインターフェースで受け取る\n        public class Dijkstra<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly IGraph<TNode, TEdge> _graph;\n\n            public Dijkstra(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n            }\n\n            public long[] GetDistancesFrom(TNode startNode)\n            {\n                const long Inf = 1L << 60;\n                var distances = Enumerable.Repeat(Inf, _graph.NodeCount).ToArray();\n                distances[startNode.Index] = 0;\n                var todo = new PriorityQueue<State>(false);\n                todo.Enqueue(new State(startNode, 0));\n\n                while (todo.Count > 0)\n                {\n                    var current = todo.Dequeue();\n                    if (current.Distance > distances[current.Node.Index])\n                    {\n                        continue;\n                    }\n\n                    foreach (var edge in _graph[current.Node])\n                    {\n                        var nextDistance = current.Distance + edge.Weight;\n                        if (distances[edge.To.Index] > nextDistance)\n                        {\n                            distances[edge.To.Index] = nextDistance;\n                            todo.Enqueue(new State(edge.To, nextDistance));\n                        }\n                    }\n                }\n\n                return distances;\n            }\n\n            private readonly struct State : IComparable<State>\n            {\n                public TNode Node { get; }\n                public long Distance { get; }\n\n                public State(TNode node, long distance)\n                {\n                    Node = node;\n                    Distance = distance;\n                }\n\n                public int CompareTo(State other) => Distance.CompareTo(other.Distance);\n            }\n        }\n\n        public class WarshallFloyd<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly IGraph<TNode, TEdge> _graph;\n            const long Inf = 1L << 60;\n\n            public WarshallFloyd(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n            }\n\n            public long[,] GetDistances()\n            {\n                var distances = InitializeDistances();\n                for (int k = 0; k < _graph.NodeCount; k++)\n                {\n                    for (int i = 0; i < _graph.NodeCount; i++)\n                    {\n                        for (int j = 0; j < _graph.NodeCount; j++)\n                        {\n                            distances[i, j] = Math.Min(distances[i, j], distances[i, k] + distances[k, j]);\n                        }\n                    }\n                }\n\n                // 一応キレイにしておく\n                for (int i = 0; i < _graph.NodeCount; i++)\n                {\n                    for (int j = 0; j < _graph.NodeCount; j++)\n                    {\n                        if (distances[i, j] >= Inf)\n                        {\n                            distances[i, j] = long.MaxValue;\n                        }\n                    }\n                }\n\n                return distances;\n            }\n\n            private long[,] InitializeDistances()\n            {\n                var distances = new long[_graph.NodeCount, _graph.NodeCount];\n\n                for (int i = 0; i < _graph.NodeCount; i++)\n                {\n                    for (int j = 0; j < _graph.NodeCount; j++)\n                    {\n                        distances[i, j] = Inf;\n                    }\n                    distances[i, i] = 0;\n                }\n\n                foreach (var node in _graph.Nodes)\n                {\n                    foreach (var edge in _graph.Edges)\n                    {\n                        distances[edge.From.Index, edge.To.Index] = edge.Weight;\n                    }\n                }\n\n                return distances;\n            }\n        }\n\n        public class BellmanFord<TNode, TEdge> where TEdge : IWeightedEdge<TNode> where TNode : INode\n        {\n            protected readonly List<TEdge> _edges;\n            protected readonly int _nodeCount;\n\n            public BellmanFord(IGraph<TNode, TEdge> graph) : this(graph.Edges, graph.NodeCount) { }\n\n            public BellmanFord(IEnumerable<TEdge> edges, int nodeCount)\n            {\n                _edges = edges.ToList();\n                _nodeCount = nodeCount;\n            }\n\n            public (long[] distances, bool[] isNegativeCycle) GetDistancesFrom(TNode startNode)\n            {\n                const long Inf = long.MaxValue >> 1;\n                var distances = Enumerable.Repeat(long.MaxValue, _nodeCount).ToArray();\n                var isNegativeCycle = new bool[_nodeCount];\n                distances[startNode.Index] = 0;\n\n                for (int i = 1; i <= 2 * _nodeCount; i++)\n                {\n                    foreach (var edge in _edges)\n                    {\n                        // そもそも出発点に未到達なら無視\n                        if (distances[edge.From.Index] < Inf)\n                        {\n                            if (i <= _nodeCount)\n                            {\n                                var newCost = distances[edge.From.Index] + edge.Weight;\n                                if (distances[edge.To.Index] > newCost)\n                                {\n                                    distances[edge.To.Index] = newCost;\n                                    // N回目に更新されたやつにチェックを付けて、追加でN回伝播させる\n                                    if (i == _nodeCount)\n                                    {\n                                        isNegativeCycle[edge.To.Index] = true;\n                                    }\n                                }\n                            }\n                            else if (isNegativeCycle[edge.From.Index])\n                            {\n                                isNegativeCycle[edge.To.Index] = true;\n                            }\n                        }\n                    }\n                }\n\n                // 一応キレイにしておく\n                for (int i = 0; i < _nodeCount; i++)\n                {\n                    if (isNegativeCycle[i])\n                    {\n                        distances[i] = long.MinValue;\n                    }\n                    else if (distances[i] >= Inf)\n                    {\n                        distances[i] = long.MaxValue;\n                    }\n                }\n\n                return (distances, isNegativeCycle);\n            }\n        }\n\n        public interface ITreeDpState<TSet> : IMonoid<TSet> where TSet : ITreeDpState<TSet>, new()\n        {\n            public TSet AddRoot();\n        }\n\n        public class Rerooting<TNode, TEdge, TTreeDpState> where TEdge : IEdge<TNode> where TNode : struct, INode where TTreeDpState : ITreeDpState<TTreeDpState>, new()\n        {\n            readonly IGraph<TNode, TEdge> _graph;\n            readonly TTreeDpState _identity;\n            readonly Dictionary<int, TTreeDpState>[] _dp;\n            readonly TTreeDpState[] _result;\n\n            public Rerooting(IGraph<TNode, TEdge> graph)\n            {\n                _graph = graph;\n                _identity = new TTreeDpState().Identity;\n                _dp = new Dictionary<int, TTreeDpState>[_graph.NodeCount];\n                _result = new TTreeDpState[_graph.NodeCount];\n            }\n\n            public TTreeDpState[] Solve()\n            {\n                DepthFirstSearch(_graph.Nodes.First(), null);\n                Reroot(_graph.Nodes.First(), null, _identity);\n                return _result;\n            }\n\n            private TTreeDpState DepthFirstSearch(TNode root, TNode? parent)\n            {\n                var sum = _identity;\n                _dp[root.Index] = new Dictionary<int, TTreeDpState>();\n\n                foreach (var edge in _graph[root])\n                {\n                    if (edge.To.Index == parent?.Index)\n                        continue;\n                    _dp[root.Index].Add(edge.To.Index, DepthFirstSearch(edge.To, root));\n                    sum *= _dp[root.Index][edge.To.Index];\n                }\n                return sum.AddRoot();\n            }\n\n            private void Reroot(TNode root, TNode? parent, TTreeDpState toAdd)\n            {\n                var edges = _graph[root].ToArray();\n\n                foreach (var edge in edges)\n                {\n                    if (edge.To.Index == parent?.Index)\n                    {\n                        _dp[root.Index].Add(edge.To.Index, toAdd);\n                        break;\n                    }\n                }\n\n                var dp = GetPrefixSum(root, edges);\n\n                for (int i = 0; i < edges.Length; i++)\n                {\n                    var child = edges[i].To;\n                    if (child.Index == parent?.Index)\n                        continue;\n                    Reroot(child, root, dp[i].AddRoot());\n                }\n            }\n\n            private TTreeDpState[] GetPrefixSum(TNode root, TEdge[] edges)\n            {\n                // 左右からの累積和\n                int sumSize = edges.Length + 1;\n                var sumLeft = new TTreeDpState[sumSize];\n                sumLeft[0] = _identity;\n                for (int i = 0; i < edges.Length; i++)\n                {\n                    var child = edges[i].To;\n                    sumLeft[i + 1] = sumLeft[i] * _dp[root.Index][child.Index];\n                }\n\n                var sumRight = new TTreeDpState[sumSize];\n                sumRight[^1] = _identity;\n                for (int i = edges.Length - 1; i >= 0; i--)\n                {\n                    var child = edges[i].To;\n                    sumRight[i] = sumRight[i + 1] * _dp[root.Index][child.Index];\n                }\n\n                _result[root.Index] = sumLeft[^1].AddRoot();\n\n                // 頂点iを除いた累積\n                var dp = new TTreeDpState[edges.Length];\n                for (int i = 0; i < dp.Length; i++)\n                {\n                    dp[i] = sumLeft[i] * sumRight[i + 1];\n                }\n\n                return dp;\n            }\n        }\n    }\n}\n\n#endregion\n\n#region Extensions\n\nnamespace Training20200909.Extensions\n{\n    public static class StringExtensions\n    {\n        public static string Join<T>(this IEnumerable<T> source) => string.Concat(source);\n        public static string Join<T>(this IEnumerable<T> source, char separator) => string.Join(separator, source);\n        public static string Join<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);\n    }\n\n    public static class TextReaderExtensions\n    {\n        public static int ReadInt(this TextReader reader) => int.Parse(ReadString(reader));\n        public static long ReadLong(this TextReader reader) => long.Parse(ReadString(reader));\n        public static double ReadDouble(this TextReader reader) => double.Parse(ReadString(reader));\n        public static string ReadString(this TextReader reader) => reader.ReadLine();\n\n        public static int[] ReadIntArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(int.Parse).ToArray();\n        public static long[] ReadLongArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(long.Parse).ToArray();\n        public static double[] ReadDoubleArray(this TextReader reader, char separator = ' ') => ReadStringArray(reader, separator).Select(double.Parse).ToArray();\n        public static string[] ReadStringArray(this TextReader reader, char separator = ' ') => reader.ReadLine().Split(separator);\n\n        // Supports primitive type only.\n        public static T1 ReadValue<T1>(this TextReader reader) => (T1)Convert.ChangeType(reader.ReadLine(), typeof(T1));\n\n        public static (T1, T2) ReadValue<T1, T2>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            return (v1, v2);\n        }\n\n        public static (T1, T2, T3) ReadValue<T1, T2, T3>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            return (v1, v2, v3);\n        }\n\n        public static (T1, T2, T3, T4) ReadValue<T1, T2, T3, T4>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            return (v1, v2, v3, v4);\n        }\n\n        public static (T1, T2, T3, T4, T5) ReadValue<T1, T2, T3, T4, T5>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            return (v1, v2, v3, v4, v5);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6) ReadValue<T1, T2, T3, T4, T5, T6>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            return (v1, v2, v3, v4, v5, v6);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6, T7) ReadValue<T1, T2, T3, T4, T5, T6, T7>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            var v7 = (T7)Convert.ChangeType(inputs[6], typeof(T7));\n            return (v1, v2, v3, v4, v5, v6, v7);\n        }\n\n        public static (T1, T2, T3, T4, T5, T6, T7, T8) ReadValue<T1, T2, T3, T4, T5, T6, T7, T8>(this TextReader reader, char separator = ' ')\n        {\n            var inputs = ReadStringArray(reader, separator);\n            var v1 = (T1)Convert.ChangeType(inputs[0], typeof(T1));\n            var v2 = (T2)Convert.ChangeType(inputs[1], typeof(T2));\n            var v3 = (T3)Convert.ChangeType(inputs[2], typeof(T3));\n            var v4 = (T4)Convert.ChangeType(inputs[3], typeof(T4));\n            var v5 = (T5)Convert.ChangeType(inputs[4], typeof(T5));\n            var v6 = (T6)Convert.ChangeType(inputs[5], typeof(T6));\n            var v7 = (T7)Convert.ChangeType(inputs[6], typeof(T7));\n            var v8 = (T8)Convert.ChangeType(inputs[7], typeof(T8));\n            return (v1, v2, v3, v4, v5, v6, v7, v8);\n        }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing static Template;\nusing SC = FastScanner;\n\npublic partial class Solver\n{\n    public void Solve()\n    {\n        int N = sc.Int, D = sc.Int;\n        var ts = new TwoSat(N);\n        int[] X=new int[N], Y=new int[N];\n        for(int i = 0; i < N; i++)\n        {\n            X[i] = sc.Int;Y[i] = sc.Int;\n            for(int j = 0; j < i; j++)\n            {\n                if (Abs(X[i] - X[j]) < D)\n                {\n                    ts.AddClosure(i, false, j, false);\n                }\n                if (Abs(Y[i] - Y[j]) < D)\n                {\n                    ts.AddClosure(i, true, j, true);\n                }\n                if (Abs(X[i] - Y[j]) < D)\n                {\n                    ts.AddClosure(i, false, j, true);\n                }\n                if (Abs(Y[i] - X[i]) < D)\n                {\n                    ts.AddClosure(i, true, j, false);\n                }\n            }\n        }\n        if (!ts.Execute()) Fail(\"No\");\n        Console.WriteLine(\"Yes\");\n        for (int i = 0; i < ts.Answer.Length; i++)\n            if (ts.Answer[i]) Console.WriteLine(X[i]);\n            else Console.WriteLine(Y[i]);\n\n    }\n}\nclass TwoSat\n{\n    StronglyConnectedComponents scc;\n    public bool[] Answer { get; private set; }\n    public TwoSat(int N)\n    {\n        scc = new StronglyConnectedComponents(N << 1);\n        Answer = new bool[N];\n    }\n    //(x_i=f)V(x_j=g) <-> !(x_i=f)->(x_j=g) <-> !(x_j=g)->(x_i=f)の追加\n    public void AddClosure(int i, bool f, int j, bool g)\n    {\n        scc.AddEdge((i << 1) | (f ? 0 : 1), (j << 1) | (g ? 1 : 0));\n        scc.AddEdge((j << 1) | (g ? 0 : 1), (i << 1) | (f ? 1 : 0));\n    }\n    public bool Execute()\n    {\n        scc.Execute();\n        var gp = scc.Group;\n        var len = gp.Length >> 1;\n        for (int i = 0; i < len; i++)\n        {\n            if (gp[i << 1] == gp[(i << 1) | 1]) return false;\n            Answer[i] = gp[i<<1] < gp[(i<<1)|1];//DAG\n        }\n        return true;\n    }\n}\n\npublic class StronglyConnectedComponents\n{\n    int size;\n    List<Edge> edges;\n    private int[][] scc;\n    public int Count { get; private set; }\n    public int[] Group { get; private set; }\n    public int[] GroupAt(int k) => scc[k];\n    public StronglyConnectedComponents(int count)\n    {\n        size = count;\n        edges = new List<Edge>();\n    }\n    public void AddEdge(int from, int to)\n    {\n        edges.Add(new Edge(from, to));\n    }\n    /// <summary>\n    /// O(V+E)\n    /// </summary>\n    /// <returns>scc[i]:i番目の強連結成分の頂点</returns>\n    public int[][] Execute()\n    {\n        //e.fromでe.toをソート\n        var start = new int[size + 1];\n        var toList = new int[edges.Count];\n        foreach (var e in edges) start[e.from + 1]++;\n        for (int i = 0; i < start.Length - 1; i++) start[i + 1] += start[i];\n        var count = start.ToArray();\n        foreach (var e in edges) toList[count[e.from]++] = e.to;\n        //lowlink\n        int nowOrd = 0;\n        int[] low = new int[size], ord = new int[size];\n        Group = new int[size];\n        var stack = new Stack<int>(size);\n        for (int i = 0; i < ord.Length; i++) ord[i] = -1;\n        Action<int> dfs = null;\n        dfs = v =>\n        {\n            low[v] = ord[v] = nowOrd++;\n            stack.Push(v);\n            for (int i = start[v]; i < start[v + 1]; i++)\n            {\n                var to = toList[i];\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = Min(low[v], low[to]);\n                }\n                else low[v] = Min(low[v], ord[to]);\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    var u = stack.Pop();\n                    ord[u] = size;\n                    Group[u] = Count;\n                    if (u == v) break;\n                }\n                Count++;\n            }\n        };\n        for (int i = 0; i < ord.Length; i++)\n        {\n            if (ord[i] == -1) dfs(i);\n        }\n        for (int i = 0; i < Group.Length; i++)\n        {\n            Group[i] = Count - 1 - Group[i];\n            count[i] = 0;\n        }\n        scc = new int[Count][];\n        foreach (var g in Group) count[g]++;\n        for (int i = 0; i < scc.Length; i++) scc[i] = new int[count[i]];\n        for (int i = 0; i < Group.Length; i++) scc[Group[i]][--count[Group[i]]] = i;\n        return scc;\n    }\n    struct Edge { public int from, to; public Edge(int f, int t) { from = f; to = t; } }\n}\n\npublic class FastScanner\n{\n    //0x0a:LF 0x20:SPC 0x2d:- 0x30 ~ 0x39: 0 ~ 9\n    static System.IO.Stream str = System.Console.OpenStandardInput();\n    const int size = 1 << 10;\n    static byte[] buffer = new byte[size];\n    static int ptr;\n    static int len;\n    public int Int\n    {\n        get\n        {\n            var c = Read();\n            while (c < 0x21)\n            {\n                c = Read();\n            }\n            var n = false;\n            if (c == '-')\n            {\n                n = true;\n                c = Read();\n            }\n            var ret = 0;\n            while (c >= 0x30)\n            {\n                ret = ret * 10 + (c & 15);\n                c = Read();\n            }\n            return n ? -ret : ret;\n        }\n    }\n    public long Long\n    {\n        get\n        {\n            var c = Read();\n            while (c < 0x21)\n            {\n                c = Read();\n            }\n            var n = false;\n            if (c == '-')\n            {\n                n = true;\n                c = Read();\n            }\n            var ret = 0L;\n            while (c >= 0x30)\n            {\n                ret = ret * 10 + (c & 15);\n                c = Read();\n            }\n            return n ? -ret : ret;\n        }\n    }\n    byte Read()\n    {\n        if (ptr == len)\n        {\n            len = str.Read(buffer, 0, size);\n            if (len == 0) return 0;\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n}\n#region Template\npublic partial class Solver\n{\n    public SC sc = new SC();\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var sol = new Solver();\n        int testcase = 1;\n        //testcase = sol.sc.Int;\n        //var th = new Thread(sol.Solve, 1 << 26);th.Start();th.Join();\n        while (testcase-- > 0)\n            sol.Solve();\n        Console.Out.Flush();\n    }\n}\npublic static class Template\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) > 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(this IList<T> A, int i, int j) { var t = A[i]; A[i] = A[j]; A[j] = t; }\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static void Out<T>(this IList<T> A, out T a) => a = A[0];\n    public static void Out<T>(this IList<T> A, out T a, out T b) { a = A[0]; b = A[1]; }\n    public static void Out<T>(this IList<T> A, out T a, out T b, out T c) { A.Out(out a, out b); c = A[2]; }\n    public static void Out<T>(this IList<T> A, out T a, out T b, out T c, out T d) { A.Out(out a, out b, out c); d = A[3]; }\n    public static string Concat<T>(this IEnumerable<T> A, string sp) => string.Join(sp, A);\n    public static char ToChar(this int s, char begin = '0') => (char)(s + begin);\n    public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> A) => A.OrderBy(v => Guid.NewGuid());\n    public static int CompareTo<T>(this T[] A, T[] B, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; for (var i = 0; i < Min(A.Length, B.Length); i++) { int c = cmp(A[i], B[i]); if (c > 0) return 1; else if (c < 0) return -1; } if (A.Length == B.Length) return 0; if (A.Length > B.Length) return 1; else return -1; }\n    public static string ToStr<T>(this T[][] A) => A.Select(a => a.Concat(\" \")).Concat(\"\\n\");\n    public static int ArgMax<T>(this IList<T> A, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; T max = A[0]; int rt = 0; for (int i = 1; i < A.Count; i++) if (cmp(max, A[i]) < 0) { max = A[i]; rt = i; } return rt; }\n    public static T PopBack<T>(this List<T> A) { var v = A[A.Count - 1]; A.RemoveAt(A.Count - 1); return v; }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    public void Make<T1, T2, T3, T4, T5, T6, T7>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6, out T7 v7) { Make(out v1, out v2, out v3, out v4, out v5, out v6); v7 = Next<T7>(); }\n    public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace Tasks\n{\n    public class H\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            Solve();\n            Console.Out.Flush();\n        }\n\n        public static void Solve()\n        {\n            var (N, D) = Scanner.Scan<int, int>();\n            var X = new int[N];\n            var Y = new int[N];\n            for (var i = 0; i < N; i++)\n            {\n                (X[i], Y[i]) = Scanner.Scan<int, int>();\n            }\n\n            var ts = new TwoSat(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Math.Abs(X[i] - X[j]) < D) ts.AddClause(i, false, j, false);\n                    if (Math.Abs(X[i] - Y[j]) < D) ts.AddClause(i, false, j, true);\n                    if (Math.Abs(Y[i] - X[j]) < D) ts.AddClause(i, true, j, false);\n                    if (Math.Abs(Y[i] - Y[j]) < D) ts.AddClause(i, true, j, true);\n                }\n            }\n\n            if (!ts.IsSatisfiable())\n            {\n                Console.WriteLine(\"No\");\n                return;\n            }\n\n            Console.WriteLine(\"Yes\");\n            var answer = ts.Answer;\n            for (var i = 0; i < N; i++)\n            {\n                Console.WriteLine(answer[i] ? X[i] : Y[i]);\n            }\n        }\n\n        public class TwoSat\n        {\n            public bool[] Answer => _answer;\n            private readonly int _n;\n            private readonly bool[] _answer;\n            private readonly SCCGraph _scc;\n\n            public TwoSat(int n = 0)\n            {\n                _n = n;\n                _answer = new bool[n];\n                _scc = new SCCGraph(2 * n);\n            }\n\n            public void AddClause(int i, bool f, int j, bool g)\n            {\n                if (i < 0 || _n < i) throw new ArgumentException(nameof(i));\n                if (j < 0 || _n < j) throw new ArgumentException(nameof(j));\n                _scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n                _scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n            }\n\n            public bool IsSatisfiable()\n            {\n                var (_, tmp) = _scc.Ids();\n                var ids = tmp.ToArray();\n                for (var i = 0; i < _n; i++)\n                {\n                    if (ids[2 * i] == ids[2 * i + 1]) return false;\n                    _answer[i] = ids[2 * i] < ids[2 * i + 1];\n                }\n\n                return true;\n            }\n        }\n\n        public class SCCGraph\n        {\n            private struct Edge\n            {\n                public int To;\n            }\n\n            private readonly int _n;\n            private readonly List<(int, Edge)> _edges;\n\n            public SCCGraph(int n = 0)\n            {\n                _n = n;\n                _edges = new List<(int, Edge)>();\n            }\n\n            public void AddEdge(int from, int to)\n            {\n                if (from < 0 || _n <= from) throw new ArgumentOutOfRangeException(nameof(from));\n                if (to < 0 || _n <= to) throw new ArgumentOutOfRangeException(nameof(to));\n                _edges.Add((from, new Edge { To = to }));\n            }\n\n            public (int, IEnumerable<int>) Ids()\n            {\n                var g = new CSR<Edge>(_n, _edges);\n                var (nowOrd, groupNum) = (0, 0);\n                var visited = new Stack<int>(_n);\n                var low = new int[_n];\n                var ord = Enumerable.Repeat(-1, _n).ToArray();\n                var ids = new int[_n];\n\n                void DFS(int v)\n                {\n                    low[v] = ord[v] = nowOrd++;\n                    visited.Push(v);\n                    for (var i = g.Start[v]; i < g.Start[v + 1]; i++)\n                    {\n                        var to = g.Edges[i].To;\n                        if (ord[to] == -1)\n                        {\n                            DFS(to);\n                            low[v] = System.Math.Min(low[v], low[to]);\n                        }\n                        else\n                        {\n                            low[v] = System.Math.Min(low[v], ord[to]);\n                        }\n                    }\n\n                    if (low[v] != ord[v]) return;\n                    while (true)\n                    {\n                        var u = visited.Pop();\n                        ord[u] = _n;\n                        ids[u] = groupNum;\n                        if (u == v) break;\n                    }\n\n                    groupNum++;\n                }\n\n                for (var i = 0; i < _n; i++)\n                    if (ord[i] == -1)\n                        DFS(i);\n\n                for (var i = 0; i < _n; i++) ids[i] = groupNum - 1 - ids[i];\n\n                return (groupNum, ids);\n            }\n\n            public IEnumerable<IEnumerable<int>> GetSCC()\n            {\n                var (groupNum, tmp) = Ids();\n                var ids = tmp.ToArray();\n                var groups = new List<int>[groupNum].Select(x => new List<int>()).ToArray();\n                foreach (var (id, i) in ids.Select((x, i) => (x, i))) groups[id].Add(i);\n                return groups;\n            }\n        }\n\n        public class CSR<T>\n        {\n            public int[] Start { get; }\n\n            public T[] Edges { get; }\n\n            public CSR(int n, IEnumerable<(int, T)> edges)\n            {\n                Start = new int[n + 1];\n                var es = edges.ToArray();\n                Edges = new T[es.Length];\n                foreach (var e in es) Start[e.Item1 + 1]++;\n                for (var i = 0; i < n; i++) Start[i + 1] += Start[i];\n                var counter = Start.ToArray();\n                foreach (var (i, t) in es) Edges[counter[i]++] = t;\n            }\n        }\n\n        public static class Scanner\n        {\n            private static Queue<string> queue = new Queue<string>();\n            public static T Next<T>()\n            {\n                if (!queue.Any()) foreach (var item in Console.ReadLine().Trim().Split(\" \")) queue.Enqueue(item);\n                return (T)Convert.ChangeType(queue.Dequeue(), typeof(T));\n            }\n            public static T Scan<T>() => Next<T>();\n            public static (T1, T2) Scan<T1, T2>() => (Next<T1>(), Next<T2>());\n            public static (T1, T2, T3) Scan<T1, T2, T3>() => (Next<T1>(), Next<T2>(), Next<T3>());\n            public static (T1, T2, T3, T4) Scan<T1, T2, T3, T4>() => (Next<T1>(), Next<T2>(), Next<T3>(), Next<T4>());\n            public static (T1, T2, T3, T4, T5) Scan<T1, T2, T3, T4, T5>() => (Next<T1>(), Next<T2>(), Next<T3>(), Next<T4>(), Next<T5>());\n            public static IEnumerable<T> ScanEnumerable<T>() => Console.ReadLine().Trim().Split(\" \").Select(x => (T)Convert.ChangeType(x, typeof(T)));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Library;\n\nnamespace Program\n{\n    public static class ProblemD\n    {\n        static bool SAIKI = false;\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var N = NN;\n            var D = NN;\n            var XYList = Repeat(0, N).Select(_ => new { X = NN, Y = NN }).ToArray();\n            var twosat = new LIB_TwoSAT(N * 2);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (Abs(XYList[i].X - XYList[j].X) < D)\n                    {\n                        twosat.AddClause(i, false, j, false);\n                        twosat.AddClause(i, true, j, true);\n                    }\n                    if (Abs(XYList[i].X - XYList[j].Y) < D)\n                    {\n                        twosat.AddClause(i, false, j + N, false);\n                        twosat.AddClause(i, true, j + N, true);\n                    }\n                    if (Abs(XYList[i].Y - XYList[j].X) < D)\n                    {\n                        twosat.AddClause(i + N, false, j, false);\n                        twosat.AddClause(i + N, true, j, true);\n                    }\n                    if (Abs(XYList[i].Y - XYList[j].Y) < D)\n                    {\n                        twosat.AddClause(i + N, false, j + N, false);\n                        twosat.AddClause(i + N, true, j + N, true);\n                    }\n                }\n            }\n            if (twosat.Satisfiable())\n            {\n                Console.WriteLine(\"Yes\");\n                for (var i = 0; i < N; i++)\n                {\n                    if (twosat.Answer[i]) Console.WriteLine(XYList[i].X);\n                    else Console.WriteLine(XYList[i].Y);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"No\");\n            }\n        }\n        class Printer : StreamWriter\n        {\n            public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n            public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { base.AutoFlush = false; }\n            public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { base.AutoFlush = false; }\n        }\n        static LIB_FastIO fastio = new LIB_FastIODebug();\n        static public void Main(string[] args) { if (args.Length == 0) { fastio = new LIB_FastIO(); Console.SetOut(new Printer(Console.OpenStandardOutput())); } if (SAIKI) { var t = new Thread(Solve, 134217728); t.Start(); t.Join(); } else Solve(); Console.Out.Flush(); }\n        static long NN => fastio.Long();\n        static double ND => fastio.Double();\n        static string NS => fastio.Scan();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static long Count<T>(this IEnumerable<T> x, Func<T, bool> pred) => Enumerable.Count(x, pred);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static IOrderedEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x, _ => xorshift);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x) => Enumerable.OrderBy(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderBy<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderBy(x.OrderByRand(), selector);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x) => Enumerable.OrderByDescending(x.OrderByRand(), e => e);\n        static IOrderedEnumerable<T1> OrderByDescending<T1, T2>(this IEnumerable<T1> x, Func<T1, T2> selector) => Enumerable.OrderByDescending(x.OrderByRand(), selector);\n        static IOrderedEnumerable<string> OrderBy(this IEnumerable<string> x) => x.OrderByRand().OrderBy(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderBy<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderBy(selector, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<string> OrderByDescending(this IEnumerable<string> x) => x.OrderByRand().OrderByDescending(e => e, StringComparer.OrdinalIgnoreCase);\n        static IOrderedEnumerable<T> OrderByDescending<T>(this IEnumerable<T> x, Func<T, string> selector) => x.OrderByRand().OrderByDescending(selector, StringComparer.OrdinalIgnoreCase);\n        static string Join<T>(this IEnumerable<T> x, string separator = \"\") => string.Join(separator, x);\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n    }\n}\nnamespace Library {\n    class LIB_BitUtil\n    {\n        public static readonly ulong[] BitMask;\n        static LIB_BitUtil()\n        {\n            BitMask = new ulong[64];\n            BitMask[0] = 1;\n            for (var i = 1; i < 64; i++) BitMask[i] = BitMask[i - 1] << 1;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public IEnumerable<long> ScanOne(long value)\n        {\n            for (; value > 0; value &= value - 1) yield return value & -value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(ulong value)\n        {\n            value = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n            value = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n            value = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n            value = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n            value = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n            value = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n            return (long)value;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public long PopCount(long value) => PopCount((ulong)value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(ulong value, int idx) => (value & BitMask[idx]) != 0;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool IsSet(long value, int idx) => IsSet((ulong)value, idx);\n    }\n    class LIB_FastIO\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIO() { str = Console.OpenStandardInput(); }\n        readonly Stream str;\n        readonly byte[] buf = new byte[1024];\n        int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return isEof; }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        byte read()\n        {\n            if (isEof) throw new EndOfStreamException();\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        char Char()\n        {\n            byte b = 0;\n            do b = read();\n            while (b < 33 || 126 < b);\n            return (char)b;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public long Long()\n        {\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != '-' && (b < '0' || '9' < b));\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        virtual public double Double() { return double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n    class LIB_FastIODebug : LIB_FastIO\n    {\n        Queue<string> param = new Queue<string>();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_FastIODebug() { }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override string Scan() => NextString();\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override long Long() => long.Parse(NextString());\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override double Double() => double.Parse(NextString());\n    }\n    class LIB_Bitset : IEquatable<LIB_Bitset>\n    {\n        long n;\n        ulong[] ary;\n        static readonly ulong[] ceil;\n        static LIB_Bitset()\n        {\n            ceil = new ulong[64];\n            ceil[0] = 0xffffffffffffffff;\n            ceil[1] = 1;\n            for (var i = 2; i < 64; i++)\n            {\n                ceil[i] = (ceil[i - 1] << 1) | 1;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_Bitset(long size)\n        {\n            if (size <= 0) throw new Exception();\n            n = size;\n            ary = new ulong[((n - 1) >> 6) + 1];\n        }\n        public long Count => n;\n        public long PopCount => ary.Sum(e => LIB_BitUtil.PopCount(e));\n        public bool this[int idx]\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get { return LIB_BitUtil.IsSet(ary[idx >> 6], idx & 63); }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            set\n            {\n                if (value) ary[idx >> 6] |= LIB_BitUtil.BitMask[idx & 63];\n                else ary[idx >> 6] &= ~LIB_BitUtil.BitMask[idx & 63];\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] &= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] |= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            for (var i = 0; i < y.ary.Length; i++) ret.ary[i] ^= y.ary[i];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator &(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] &= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator |(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] |= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ^(LIB_Bitset x, long y)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = x.ary[i];\n            ret.ary[0] ^= (ulong)y;\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Flip()\n        {\n            for (var i = 0; i < ary.Length; i++) ary[i] = ~ary[i];\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator ~(LIB_Bitset x)\n        {\n            var ret = new LIB_Bitset(x.n);\n            for (var i = 0; i < ret.ary.Length; i++) ret.ary[i] = ~x.ary[i];\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftLeft(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ary.Length - 1; i >= moveCnt; i--)\n            {\n                ary[i] = ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ary[i] |= ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ary[ary.Length - 1] &= ceil[n & 63];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator <<(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            for (var i = ret.ary.Length - 1; i >= moveCnt; i--)\n            {\n                ret.ary[i] = x.ary[i - moveCnt] << moveBit;\n                if (moveBit > 0 && i > moveCnt) ret.ary[i] |= x.ary[i - moveCnt - 1] >> (64 - moveBit);\n            }\n            ret.ary[ret.ary.Length - 1] &= ceil[ret.n & 63];\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void ShiftRight(int num)\n        {\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ary[i] = ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ary[i] |= ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public LIB_Bitset operator >>(LIB_Bitset x, int num)\n        {\n            var ret = new LIB_Bitset(x.n);\n            var moveCnt = num >> 6;\n            var moveBit = num & 63;\n            var aryMax = ret.ary.Length - moveCnt;\n            for (var i = 0; i < aryMax; i++)\n            {\n                ret.ary[i] = x.ary[i + moveCnt] >> moveBit;\n                if (moveBit > 0 && i < aryMax - 1) ret.ary[i] |= x.ary[i + moveCnt + 1] << (64 - moveBit);\n            }\n            return ret;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator ==(LIB_Bitset x, LIB_Bitset y)\n        {\n            if (x.n < y.n) { var t = x; x = y; y = t; }\n            var i = 0;\n            for (; i < y.ary.Length; i++) if (x.ary[i] != y.ary[i]) return false;\n            for (; i < x.ary.Length; i++) if (x.ary[i] != 0) return false;\n            return true;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static public bool operator !=(LIB_Bitset x, LIB_Bitset y) => !(x == y);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Equals(LIB_Bitset x) => x == this;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override bool Equals(object x) => x == null ? false : Equals((LIB_Bitset)x);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public override int GetHashCode()\n        {\n            var t = ary.Aggregate((a, x) => a ^ x);\n            return (int)(((t >> 32) ^ t) & 0x00000000ffffffff);\n        }\n    }\n    class LIB_TwoSAT : LIB_SCC\n    {\n        int n;\n        public LIB_Bitset Answer\n        {\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get;\n            private set;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public LIB_TwoSAT(long n) : base(n << 1)\n        {\n            this.n = (int)n;\n            Answer = new LIB_Bitset(n);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddClause(long i, bool f, long j, bool g)\n        {\n            base.AddPath((i << 1) + (f ? 0 : 1), (j << 1) + (g ? 1 : 0));\n            base.AddPath((j << 1) + (g ? 0 : 1), (i << 1) + (f ? 1 : 0));\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public bool Satisfiable()\n        {\n            var id = SCCIDs().Item2;\n            for (var i = 0; i < n; ++i)\n            {\n                if (id[i << 1] == id[(i << 1) | 1]) return false;\n                Answer[i] = id[i << 1] < id[(i << 1) | 1];\n            }\n            return true;\n        }\n        new void AddPath(long from, long to) { }\n        new int[][] SCC() { throw new Exception(); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace AtCoderLibraryCSharp.Examples\n{\n    public static class Program\n    {\n        public static void Main()\n        {\n            var ND = Console.ReadLine().Split(\" \").Select(int.Parse).ToArray();\n            var (N, D) = (ND[0], ND[1]);\n            var X = new int[N];\n            var Y = new int[N];\n            for (var i = 0; i < N; i++)\n            {\n                var XY = Console.ReadLine().Split(\" \").Select(int.Parse).ToArray();\n                (X[i], Y[i]) = (XY[0], XY[1]);\n            }\n\n            var ts = new TwoSatisfiability(N);\n            for (var i = 0; i < N; i++)\n            {\n                for (var j = i + 1; j < N; j++)\n                {\n                    if (System.Math.Abs(X[i] - X[j]) < D) ts.AddClause(i, false, j, false);\n                    if (System.Math.Abs(X[i] - Y[j]) < D) ts.AddClause(i, false, j, true);\n                    if (System.Math.Abs(Y[i] - X[j]) < D) ts.AddClause(i, true, j, false);\n                    if (System.Math.Abs(Y[i] - Y[j]) < D) ts.AddClause(i, true, j, true);\n                }\n            }\n\n            if (!ts.IsSatisfiable())\n            {\n                Console.WriteLine(\"No\");\n                return;\n            }\n\n            Console.WriteLine(\"Yes\");\n            var answer = ts.Answer;\n            for (var i = 0; i < N; i++)\n                Console.WriteLine(answer[i] ? X[i] : Y[i]);\n        }\n    }\n}\n\nnamespace AtCoderLibraryCSharp\n{\n    public class TwoSatisfiability\n    {\n        public bool[] Answer { get; }\n\n        private readonly int _n;\n        private readonly StronglyConnectedComponent _scc;\n\n        public TwoSatisfiability(int n = 0)\n        {\n            _n = n;\n            Answer = new bool[n];\n            _scc = new StronglyConnectedComponent(2 * n);\n        }\n\n        public void AddClause(int i, bool f, int j, bool g)\n        {\n            if (i < 0 || _n < i) throw new IndexOutOfRangeException(nameof(i));\n            if (j < 0 || _n < j) throw new IndexOutOfRangeException(nameof(j));\n            _scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            _scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n\n        public bool IsSatisfiable()\n        {\n            var (_, tmp) = _scc.Ids();\n            var ids = tmp.ToArray();\n            for (var i = 0; i < _n; i++)\n            {\n                if (ids[2 * i] == ids[2 * i + 1]) return false;\n                Answer[i] = ids[2 * i] < ids[2 * i + 1];\n            }\n\n            return true;\n        }\n    }\n}\n\nnamespace AtCoderLibraryCSharp\n{\n    public class StronglyConnectedComponent\n    {\n        private readonly struct Edge\n        {\n            public readonly int To;\n            public Edge(int to) => To = to;\n        }\n\n        private readonly int _n;\n        private readonly List<(int, Edge)> _edges;\n\n        public StronglyConnectedComponent(int n = 0)\n        {\n            _n = n;\n            _edges = new List<(int, Edge)>();\n        }\n\n        public void AddEdge(int from, int to)\n        {\n            if (from < 0 || _n <= from) throw new IndexOutOfRangeException(nameof(from));\n            if (to < 0 || _n <= to) throw new IndexOutOfRangeException(nameof(to));\n            _edges.Add((from, new Edge(to)));\n        }\n\n        public (int, IEnumerable<int>) Ids()\n        {\n            var g = new CompressedSparseRow<Edge>(_n, _edges);\n            var (nowOrd, groupNum) = (0, 0);\n            var visited = new Stack<int>(_n);\n            var low = new int[_n];\n            var ord = Enumerable.Repeat(-1, _n).ToArray();\n            var ids = new int[_n];\n\n            void Dfs(int v)\n            {\n                low[v] = ord[v] = nowOrd++;\n                visited.Push(v);\n                for (var i = g.Start[v]; i < g.Start[v + 1]; i++)\n                {\n                    var to = g.Edges[i].To;\n                    if (ord[to] == -1)\n                    {\n                        Dfs(to);\n                        low[v] = System.Math.Min(low[v], low[to]);\n                    }\n                    else low[v] = System.Math.Min(low[v], ord[to]);\n                }\n\n                if (low[v] != ord[v]) return;\n                while (true)\n                {\n                    var u = visited.Pop();\n                    ord[u] = _n;\n                    ids[u] = groupNum;\n                    if (u == v) break;\n                }\n\n                groupNum++;\n            }\n\n            for (var i = 0; i < _n; i++)\n                if (ord[i] == -1)\n                    Dfs(i);\n\n            for (var i = 0; i < _n; i++) ids[i] = groupNum - 1 - ids[i];\n\n            return (groupNum, ids);\n        }\n\n        public IEnumerable<IEnumerable<int>> GetGraph()\n        {\n            var (groupNum, tmp) = Ids();\n            var ids = tmp.ToArray();\n            var groups = new List<int>[groupNum].Select(x => new List<int>()).ToArray();\n            foreach (var (id, i) in ids.Select((x, i) => (x, i))) groups[id].Add(i);\n            return groups;\n        }\n    }\n}\n\nnamespace AtCoderLibraryCSharp\n{\n    public class CompressedSparseRow<T>\n    {\n        public int[] Start { get; }\n        public T[] Edges { get; }\n\n        public CompressedSparseRow(int n, IEnumerable<(int, T)> edges)\n        {\n            Start = new int[n + 1];\n            var es = edges.ToArray();\n            Edges = new T[es.Length];\n            foreach (var e in es) Start[e.Item1 + 1]++;\n            for (var i = 0; i < n; i++) Start[i + 1] += Start[i];\n            var counter = Start.ToArray();\n            foreach (var (i, t) in es) Edges[counter[i]++] = t;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tconst double eps=1e-11;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0];\n\t\tvar h=new int[n][];\n\t\tvar sat=new Tsat(n);\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\th[i]=sc.Ia;\n\t\t\tfor(int j = i-1;j>=0;j--) {\n\t\t\t\tif(Abs(h[i][0]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][0]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,0,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,1);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][0])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,1);\n\t\t\t\t\tsat.Edge(j,0,i,0);\n\t\t\t\t}\n\t\t\t\tif(Abs(h[i][1]-h[j][1])<s[1]){\n\t\t\t\t\tsat.Edge(i,1,j,0);\n\t\t\t\t\tsat.Edge(j,1,i,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsat.Scc();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sat.Ck(i);\n\t\t\tif(e==-1){\n\t\t\t\tConsole.WriteLine(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{sb.Append(h[i][e]+\"\\n\");}\n\t\t}\n\t\tConsole.WriteLine(\"Yes\");\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Tsat{\n\tpublic List<int>[] li,lir,lid;\n\tpublic int[] zt;\n\tprivate int n;\n\tpublic Tsat(int n){\n\t\tthis.n=n<<1;\n\t\tli=new List<int>[this.n];\n\t\tlir=new List<int>[this.n];\n\t\tfor(int i=0;i<this.n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\tlir[i]=new List<int>();\n\t\t}\n\t}\n\tpublic void Edge(int a,int b){\n\t\tli[a].Add(b);\n\t\tlir[b].Add(a);\n\t}\n\tpublic void Edge(int a,int c,int b,int d){\n\t\ta=(a<<1)+c;b=(b<<1)+d;\n\t\tli[a].Add(b);\n\t\tlir[b].Add(a);\n\t}\n\tpublic int Ck(int a){\n\t\ta<<=1;\n\t\treturn zt[a]==zt[a+1]?-1:(zt[a]>zt[a+1]?0:1);\n\t}\n\tpublic void Scc(){\n\t\tvar h=new int[n];\n\t\tvar b=new bool[n];\n\t\tzt=new int[n];\n\t\tint kk=n-1,km=0;\n\t\tfor(int i=0;i<n;i++){if(!b[i]){Fud1(i);}}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b[h[i]]){\n\t\t\t\tFud2(h[i]);\n\t\t\t\tkm++;\n\t\t\t}\n\t\t}\n\t\tlid=new List<int>[km];\n\t\tfor(int i=0;i<km;i++){lid[i]=new List<int>();}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<li[i].Count;j++){if(zt[i]!=zt[li[i][j]]){lid[zt[i]].Add(zt[li[i][j]]);}}\n\t\t}\n\t\tfor(int i=0;i<km;i++){lid[i]=lid[i].Distinct().ToList();}\n\t\tvoid Fud1(int a){\n\t\t\tb[a]=true;\n\t\t\tfor(int i=0;i<li[a].Count;i++){if(!b[li[a][i]]){Fud1(li[a][i]);}}\n\t\t\th[kk--]=a;\n\t\t}\n\t\tvoid Fud2(int a){\n\t\t\tzt[a]=km;\n\t\t\tb[a]=false;\n\t\t\tfor(int i=0;i<lir[a].Count;i++){if(b[lir[a][i]]){Fud2(lir[a][i]);}}\n\t\t}\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),int.Parse);}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),long.Parse);}\n\tpublic long[] La3(int a){return Array.ConvertAll((Console.ReadLine()+\" \"+a.ToString()).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.Graph;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            /*var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();*/\n\n            Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Scanf(out int N, out int D);\n            var sat = new Two_SAT(N);\n            var X = new int[N];\n            var Y = new int[N];\n            for (var i = 0; i < N; i++) Cin.Scanf(out X[i], out Y[i]);\n            for(var i = 0; i < N; i++)\n            {\n                for(var j = i + 1; j < N; j++)\n                {\n                    if (Abs(X[i] - X[j]) < D) sat.Add_Closure(i + N, j + N);\n                    if (Abs(X[i] - Y[j]) < D) sat.Add_Closure(i + N, j);\n                    if (Abs(Y[i] - X[j]) < D) sat.Add_Closure(i, j + N);\n                    if (Abs(Y[i] - Y[j]) < D) sat.Add_Closure(i, j);\n                }\n            }\n            if (!sat.Satisfy()) { OutL(\"No\");return; }\n            OutL(\"Yes\");\n            var ans = sat.ans();\n            for (var i = 0; i < N; i++) OutL(ans[i] ? X[i] : Y[i]);\n        }\n    }\n    public struct Edge\n    {\n        public int from, to;\n        public long w;\n        public Edge(int to, long weight) { this.to = to; w = weight; from = -1; }\n        public Edge(int from, int to, long weight) { this.from = from; this.to = to; w = weight; }\n    }\n    public static class Graph\n    {\n        const long inf = long.MaxValue / 3;\n        public static List<List<T>> GenList<T>(int size)\n        {\n            var ret = new List<List<T>>();\n            for (var i = 0; i < size; i++) ret.Add(new List<T>());\n            return ret;\n        }\n        public static long[] Dijkstra(List<List<Edge>> G, int st)\n        {\n            int N = G.Count();\n            long[] ret = new long[N];\n            var V = new Priority_Queue<Tuple<long, int>>((x, y) => Sig(x.Item1 - y.Item1));\n            for (var i = 0; i < N; i++) ret[i] = inf;\n            ret[st] = 0;V.Enqueue(new Tuple<long, int>(0, st));\n            while (V.Any())\n            {\n                var cur = V.Dequeue();\n                int v = cur.Item2;\n                long cd = cur.Item1;\n                if (ret[v] < cd) continue;\n                foreach(var ed in G[v])\n                {\n                    if (ret[ed.to] > cd + ed.w)\n                    {\n                        ret[ed.to] = cd + ed.w;\n                        V.Enqueue(new Tuple<long, int>(ret[ed.to], ed.to));\n                    }\n                }\n            }\n            return ret;\n        }\n        public static long[] Bellman_Frod(List<Edge> E, int st, int N, out bool neg_close)\n        {\n            var ret = new long[N];\n            for (var i = 0; i < N; i++) ret[i] = inf;\n            ret[st] = 0;\n            for(var i = 0; i < N; i++)\n            {\n                foreach(var ed in E)\n                {\n                    if (ret[ed.from] != inf && ret[ed.to] > ret[ed.from] + ed.w)\n                    {\n                        if (i == N - 1) { neg_close = true; return ret; }\n                        ret[ed.to] = ret[ed.from] + ed.w;\n                    }\n                }\n            }\n            neg_close = false;\n            return ret;\n        }\n    }\n    public class SCC\n    {\n        int n;\n        struct Edge_S { public int from, to;public Edge_S(int f,int t) { from = f;to = t; } }\n        List<Edge_S> E;\n        int[] id;\n        public SCC(int size) { n = size;E = new List<Edge_S>(); }\n        public void Add_Edge(int from,int to)\n        {\n            E.Add(new Edge_S(from, to));\n        }\n        public int[][] Scc_Result()\n        {\n            var start = new int[n + 1];\n            var nxt = new int[E.Count];\n            foreach (var ed in E) start[ed.from + 1]++;\n            for (var i = 0; i < n; i++) start[i + 1] += start[i];\n            var itr = new int[n + 1];for (var i = 0; i <= n; i++) itr[i] = start[i];\n            foreach (var ed in E) nxt[itr[ed.from]++] = ed.to;\n\n            int now = 0;\n            int[] ord = new int[n];\n            int[] low = new int[n];\n            id = new int[n];\n            var V = new Stack<int>();\n            for (var i = 0; i < n; i++) ord[i] = -1;\n            int nowid = 0;\n\n            Action<int> DFS = null;\n            DFS = (v) =>\n            {\n                low[v] = ord[v] = now++;\n                V.Push(v);\n                for(var i = start[v]; i < start[v + 1]; i++)\n                {\n                    var nx = nxt[i];\n                    if (ord[nx] == -1)\n                    {\n                        DFS(nx);\n                        low[v] = Min(low[v], low[nx]);\n                    }\n                    else\n                    {\n                        low[v] = Min(low[v], ord[nx]);\n                    }\n                }\n                if (low[v] == ord[v])\n                {\n                    while (true)\n                    {\n                        var u = V.Pop();\n                        id[u] = nowid;\n                        ord[u] = n + 1;\n                        if (u == v) break;\n                    }\n                    nowid++;\n                }\n            };\n            for (var i = 0; i < n; i++) if (ord[i] == -1) DFS(i);\n            for(var i = 0; i < n; i++)\n            {\n                id[i] = nowid - 1 - id[i];\n                itr[i] = 0;\n            }\n            var scc = new int[nowid][];\n            for (var i = 0; i < n; i++) itr[id[i]]++;\n            for (var i = 0; i < nowid; i++) scc[i] = new int[itr[i]];\n            for (var i = 0; i < n; i++) scc[id[i]][--itr[id[i]]] = i;\n            return scc;\n        }\n        public int v_id(int v) => id[v];\n    }\n    struct ModInt\n    {\n        public long value;\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            if (n == 0) return 1;\n            if (n < 0) return Modpow(Modpow(a, -n), MOD - 2);\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(int n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(int n, int r)\n        {\n            if (n < 0 || r < 0) return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    public class Two_SAT\n    {\n        // use with SCC Library\n        int n;\n        bool[] result;\n        SCC scc;\n        readonly int md;\n        public Two_SAT(int size)\n        {\n            n = size;\n            result = new bool[n];\n            scc = new SCC(n << 1);\n            md = n << 1;\n        }\n        public void Add_Closure(int i, int j)\n        {\n            scc.Add_Edge((i + n) % md, j);\n            scc.Add_Edge((j + n) % md, i);\n        }\n        public bool Satisfy()\n        {\n            scc.Scc_Result();\n            for(var i = 0; i < n; i++)\n            {\n                int j = scc.v_id(i), k = scc.v_id(i + n);\n                if (j == k) return false;\n                result[i] = j > k;\n            }\n            return true;\n        }\n        public bool[] ans() => result;\n    }\n    public class Rolling_Hash\n    {\n        const ulong m30 = (1UL << 30) - 1;\n        const ulong m31 = (1UL << 31) - 1;\n        const ulong MOD = (1UL << 61) - 1;\n        const ulong Pl = (MOD << 1) << 1;\n        private uint B;\n        private string S;\n        ulong[] hash;\n        ulong[] pw;\n\n        public Rolling_Hash(string str)\n        {\n            S = str;\n            B = (uint)new Random().Next(1 << 12 + 1, int.MaxValue);\n            int L = S.Length;\n            hash = new ulong[L + 1];\n            pw = new ulong[L + 1];\n            hash[0] = 0;\n            pw[0] = 1;\n            for (var i = 0; i < L; i++)\n            {\n                hash[i + 1] = CalcMod(Mul(hash[i], B) + S[i]);\n                pw[i + 1] = CalcMod(Mul(pw[i], B));\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong GetHashValue(int idx) => hash[idx];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment [l,r]\n        public ulong Hash_fold(int l, int r) => CalcMod(Pl + hash[r + 1] - Mul(hash[l], pw[r - l + 1]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]//segment[start,start+len-1]\n        public ulong Hash_sub(int start, int len) => CalcMod(Pl + hash[start + len] - Mul(hash[start], pw[len]));\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public ulong[] GetHashArray() => hash;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong Mul(ulong a, ulong b)\n        {\n            ulong au = a >> 31;\n            ulong ad = a & m31;\n            ulong bu = b >> 31;\n            ulong bd = b & m31;\n            ulong mid = ad * bu + au * bd;\n            ulong midu = mid >> 30;\n            ulong midd = mid & m30;\n            return au * bu * 2 + midu + (midd << 31) + ad * bd;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        ulong CalcMod(ulong x)\n        {\n            ulong xu = x >> 61;\n            ulong xd = x & MOD;\n            ulong res = xu + xd;\n            if (res >= MOD) res -= MOD;\n            return res;\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(T item)\n        {\n            int n = Q.Count();\n            Q.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(Q[n], Q[pIndex]) < 0)\n                {\n                    Swap(n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap()\n        {\n            int n = Q.Count() - 1;\n            Q[0] = Q[n];\n            Q.RemoveAt(n);\n            int cur = 0;\n            int comp;\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(Q[c1], Q[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(Q[cur], Q[comp]) > 0)\n                {\n                    Swap(cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void Swap(int a, int b)\n        {\n            T keep = Q[a];\n            Q[a] = Q[b];\n            Q[b] = keep;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Enqueue(T value) => PushHeap(value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap();\n            return ret;\n        }\n        public T Peek() => Q[0];\n        public int Count() => Q.Count();\n        public bool Any() => Q.Any();\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = size;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = size;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class MinCostFlow\n    {\n        const long inf = long.MaxValue / 3;\n        int n;\n        public class Edge_F\n        {\n            public int _to, _cap, _rev;\n            public long _cost;\n            public bool _isrev;\n            public Edge_F(int to, int cap, long cost, int rev, bool isrev)\n            {\n                _to = to; _cap = cap; _rev = rev; _cost = cost; _isrev = isrev;\n            }\n        }\n        List<List<Edge_F>> G;\n        public MinCostFlow(int size)\n        {\n            n = size;\n            G = new List<List<Edge_F>>();\n            for (var i = 0; i < n; i++) G.Add(new List<Edge_F>());\n        }\n\n        /*辺の追加*/\n        public void Add_Edge(int s, int t, int cap, long cost)\n        {\n            G[s].Add(new Edge_F(t, cap, cost, G[t].Count(), false));\n            G[t].Add(new Edge_F(s, 0, -cost, G[s].Count() - 1, true));\n        }\n        public long MinCost(int s, int t, int f)\n        {\n            long ret = 0;\n            var h = new long[n];\n            var dist = new long[n];\n            var pre_v = new int[n];\n            var pre_e = new int[n];\n            var V = new Priority_Queue<(long, int)>((x, y) => Sig(x.Item1 - y.Item1));\n            while (f > 0)\n            {\n                for (var i = 0; i < n; i++) { dist[i] = inf; pre_v[i] = pre_e[i] = -1; }\n                dist[s] = 0;\n                V.Enqueue((0, s));\n                while (V.Any())\n                {\n                    var (cd, v) = V.Dequeue();\n                    if (dist[v] < cd) continue;\n                    for (var i = 0; i < G[v].Count(); i++)\n                    {\n                        var ed = G[v][i];\n                        if (ed._cap <= 0) continue;\n                        if (dist[ed._to] + h[ed._to] > cd + h[v] + ed._cost)\n                        {\n                            dist[ed._to] = cd + ed._cost + h[v] - h[ed._to];\n                            pre_v[ed._to] = v;\n                            pre_e[ed._to] = i;\n                            V.Enqueue((dist[ed._to], ed._to));\n                        }\n                    }\n                }\n                if (dist[t] == inf) { return -inf; }\n                for (var i = 0; i < n; i++) h[i] += dist[i];\n                var nowflow = f;\n                for (var now = t; now != s; now = pre_v[now])\n                {\n                    nowflow = Min(nowflow, G[pre_v[now]][pre_e[now]]._cap);\n                }\n                f -= nowflow;\n                ret += nowflow * h[t];\n                for (var now = t; now != s; now = pre_v[now])\n                {\n                    var rv = G[pre_v[now]][pre_e[now]]._rev;\n                    G[pre_v[now]][pre_e[now]]._cap -= nowflow;\n                    G[now][rv]._cap += nowflow;\n                }\n            }\n            return ret;\n        }\n        public List<List<Edge_F>> GetEdges() => G;\n    }\n    public class Dinic\n    {\n        readonly int n;\n        const int inf = int.MaxValue / 2;\n        public class Edge_F\n        {\n            public int _to { get; set; }\n            public int _cap { get; set; }\n            public int _rev { get; set; }\n            public Edge_F(int to, int cap, int rev) { _to = to; _cap = cap; _rev = rev; }\n        }\n        List<List<Edge_F>> G;\n        int[] level, itr;\n        public Dinic(int vertice)\n        {\n            n = vertice;\n            level = new int[n];\n            itr = new int[n];\n            G = new List<List<Edge_F>>();\n            for (var _ = 0; _ < n; _++) G.Add(new List<Edge_F>());\n        }\n        /*================ ^ _ ^ ==================*/\n        //辺の追加（from->to,容量cap）\n        public void Add_Edge(int from, int to, int cap)\n        {\n            G[from].Add(new Edge_F(to, cap, G[to].Count()));\n            G[to].Add(new Edge_F(from, 0, G[from].Count() - 1));\n        }\n        //bfsパート（levelの設定）\n        void Bfs(int s)\n        {\n            //Fillはバージョン古いと使えないため...\n            for (var i = 0; i < n; i++) level[i] = -1;\n            level[s] = 0;\n            var Q = new Queue<int>();\n            Q.Enqueue(s);\n            while (Q.Any())\n            {\n                int v = Q.Dequeue();\n                foreach (var ed in G[v])\n                {\n                    if (ed._cap > 0 && level[ed._to] == -1)\n                    {\n                        level[ed._to] = level[v] + 1;\n                        Q.Enqueue(ed._to);\n                    }\n                }\n            }\n        }\n        //dfsパート（増加パスの探索）\n        int Dfs(int v, int t, int f)\n        {\n            if (v == t) return f;\n            for (var i = itr[v]; i < G[v].Count(); i++)\n            {\n                itr[v] = i;\n                var ed = G[v][i];\n                if (ed._cap > 0 && level[v] < level[ed._to])\n                {\n                    var d = Dfs(ed._to, t, Min(f, ed._cap));\n                    if (d > 0)\n                    {\n                        ed._cap -= d;\n                        G[ed._to][ed._rev]._cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        //s->tの最大流を返す\n        //一般:O(N^2M)\n        //二部グラフマッチング:O(M*Sqrt(N))\n        //辺の容量が全て同じ:O(min(n^{2/3},m^{1/2})*m)\n        //になるらしい\n        public int Max_Flow(int s, int t)\n        {\n            var ret = 0;\n            for (; ; )\n            {\n                Bfs(s);\n                if (level[t] == -1) return ret;\n                for (var i = 0; i < n; i++) itr[i] = 0;\n                var flow = 0;\n                do { ret += flow; flow = Dfs(s, t, inf); }\n                while (flow > 0);\n            }\n        }\n        //グラフの状況を返す\n        public List<List<Edge_F>> GetGraph() => G;\n    }\n    public class LazySegmentTree<X, A>\n    {\n        int n, L;\n        X[] Tree;\n        A[] lazy;\n        Func<X, X, X> fxx;\n        Func<A, A, A> faa;\n        Func<X, A, X> fxa;\n        X exx;\n        A exa;\n        public LazySegmentTree(int size, Func<X, X, X> funcxx, Func<A, A, A> funcaa, Func<X, A, X> funcxa, X exval, A exlaz)\n        {\n            n = size;\n            L = (n << 1) - 1;\n            Tree = new X[n << 1];\n            lazy = new A[n << 1];\n            fxx = funcxx;\n            faa = funcaa;\n            fxa = funcxa;\n            exx = exval;\n            exa = exlaz;\n            for (var i = 0; i <= L; i++) { Tree[i] = exx; lazy[i] = exa; }\n        }\n        public X eval(int id) => fxa(Tree[id], lazy[id]);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void propagate(int id)\n        {\n            int h = 0; while ((1 << (h + 1)) <= id) h++;\n            for (var n = h; n > 0; n--)\n            {\n                int i = id >> n;\n                Tree[i] = eval(i);\n                lazy[i << 1] = faa(lazy[i << 1], lazy[i]);\n                lazy[i << 1 | 1] = faa(lazy[i << 1 | 1], lazy[i]);\n                lazy[i] = exa;\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void re_calc(int id)\n        {\n            while (id > 1)\n            {\n                id >>= 1;\n                Tree[id] = fxx(eval(id << 1), eval(id << 1 | 1));\n            }\n        }\n        public void Range_Update(int l, int r, A op)\n        {\n            int L = n + l, R = n + r;\n            int ll = L / (L & (-L));\n            int rr = R / (R & (-R));\n            propagate(ll); propagate(rr - 1);\n            while (L < R)\n            {\n                if ((L & 1) == 1)\n                {\n                    lazy[L] = faa(lazy[L], op);\n                    L++;\n                }\n                if ((R & 1) == 1)\n                {\n                    R--;\n                    lazy[R] = faa(lazy[R], op);\n                }\n                L >>= 1; R >>= 1;\n            }\n            re_calc(ll); re_calc(rr - 1);\n        }\n        public X Range_Get(int l, int r)\n        {\n            int L = n + l, R = n + r;\n            X vL = exx, vR = exx;\n            propagate(L / (L & (-L)));\n            propagate(R / (R & (-R)) - 1);\n            while (L < R)\n            {\n                if ((L & 1) == 1)\n                {\n                    vL = fxx(vL, eval(L));\n                    L++;\n                }\n                if ((R & 1) == 1)\n                {\n                    R--;\n                    vR = fxx(eval(R), vR);\n                }\n                L >>= 1; R >>= 1;\n            }\n            return fxx(vL, vR);\n        }\n        public void Point_Update(int idx, X nxt)\n        {\n            idx += n;\n            propagate(idx);\n            Tree[idx] = nxt;\n            re_calc(idx);\n        }\n\n        /*======================*/\n        public void Assign(int idx, X nxt) => Tree[n + idx] = nxt;\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--)\n            {\n                Tree[i] = fxx(Tree[i << 1], Tree[i << 1 | 1]);\n                lazy[i] = faa(lazy[i << 1], lazy[i << 1 | 1]);\n            }\n        }\n        public X Peek(int idx) => Tree[n + idx];\n        public void Display(int len)\n        {\n            for (var i = n; i < n + len; i++) Console.Write($\"{eval(i)} \");\n            Console.WriteLine();\n        }\n        public void Displayall()\n        {\n            //木の形で表示、nが2冪でない時は注意\n            int e = 0;\n            while ((1 << e) <= n)\n            {\n                for (var i = (1 << e); i < (1 << e) + (1 << e); i++) Console.Write($\"{Tree[i]}/{lazy[i]} \");\n                Console.WriteLine();\n                e++;\n            }\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(ReadSplit, int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(ReadSplit, long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(ReadSplit, double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Scanf<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Scanf<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Scanf<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Scanf<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Scanf<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "Lisp",
    "code": "(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (set-dispatch-macro-character #\\# #\\> #'cl-debug-print:debug-print-reader)\n\n(macrolet ((def-int (b)\n             `(progn (deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))\n                     (deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))))\n           (defs (&rest bits) `(progn ,@(mapcar (lambda (b) `(def-int ,b)) bits))))\n  (defs 2 4 7 8 15 16 31 32 62 63 64))\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Strongly connected components of directed graph, 2-SAT\n;;;\n\n(defpackage :cp/scc\n  (:use :cl)\n  (:export #:scc #:scc-graph #:scc-components #:scc-sizes #:scc-count\n           #:scc-p #:make-scc #:make-condensed-graph))\n(in-package :cp/scc)\n\n(defstruct (scc (:constructor %make-scc (graph components sizes count))\n                (:copier nil))\n  (graph nil :type vector)\n  ;; components[i] := strongly connected component of the i-th vertex\n  (components nil :type (simple-array (integer 0 #.most-positive-fixnum) (*)))\n  ;; sizes[k] := size of the k-th strongly connected component\n  (sizes nil :type (simple-array (integer 0 #.most-positive-fixnum) (*)))\n  ;; the total number of strongly connected components\n  (count 0 :type (integer 0 #.most-positive-fixnum)))\n\n;; Tarjan's algorithm\n;; Reference: http://www.prefield.com/algorithm/graph/strongly_connected_components.html\n;; (Kosaraju's algorithm is put in the test file)\n(defun make-scc (graph)\n  (declare (optimize (speed 3))\n           (vector graph))\n  (let* ((n (length graph))\n         (ord 0)\n         (ords (make-array n :element-type 'fixnum :initial-element -1)) ; in-order\n         ;; store the lowest in-order number as the representative element of a\n         ;; strongly connected component\n         (lowlinks (make-array n :element-type 'fixnum))\n         (components (make-array n :element-type '(integer 0 #.most-positive-fixnum)))\n         (comp-index 0) ; index number of component\n         (sizes (make-array n :element-type '(integer 0 #.most-positive-fixnum)\n                              :initial-element 0))\n         (stack (make-array n :element-type '(integer 0 #.most-positive-fixnum)))\n         (end 0) ; stack pointer\n         (in-stack (make-array n :element-type 'bit :initial-element 0)))\n    (declare ((integer 0 #.most-positive-fixnum) ord end comp-index))\n    (labels ((%push (v)\n               (setf (aref stack end) v\n                     (aref in-stack v) 1)\n               (incf end))\n             (%pop ()\n               (decf end)\n               (let ((v (aref stack end)))\n                 (setf (aref in-stack v) 0)\n                 v))\n             (visit (v)\n               (setf (aref ords v) ord\n                     (aref lowlinks v) ord)\n               (incf ord)\n               (%push v)\n               (dolist (next (aref graph v))\n                 (cond ((= -1 (aref ords next))\n                        (visit next)\n                        (setf (aref lowlinks v)\n                              (min (aref lowlinks v) (aref lowlinks next))))\n                       ((= 1 (aref in-stack next))\n                        (setf (aref lowlinks v)\n                              (min (aref lowlinks v) (aref ords next))))))\n               (when (= (aref lowlinks v) (aref ords v))\n                 (loop for size of-type (integer 0 #.most-positive-fixnum) from 1\n                       for w = (%pop)\n                       do (setf (aref components w) comp-index)\n                       until (= v w)\n                       finally (setf (aref sizes comp-index) size)\n                               (incf comp-index)))))\n      (dotimes (v n)\n        (when (= -1 (aref ords v))\n          (visit v)))\n      ;; Reverse the order of strongly connected components, because now\n      ;; everything is in the reversed topological order\n      (dotimes (v n)\n        (setf (aref components v)\n              (- comp-index (aref components v) 1)))\n      (dotimes (i (ash comp-index -1))\n        (rotatef (aref sizes i) (aref sizes (- comp-index i 1))))\n      (%make-scc graph components sizes comp-index))))\n\n;; FIXME: Constant factor of this implementation is too large. Can we avoid\n;; hash-table?\n(declaim (ftype (function * (values (simple-array t (*)) &optional))\n                make-condensed-graph))\n(defun make-condensed-graph (scc)\n  \"Does graph condensation. This function is non-destructive.\"\n  (declare (optimize (speed 3)))\n  (let* ((graph (scc-graph scc))\n         (n (length graph))\n         (comp-n (scc-count scc))\n         (components (scc-components scc))\n         (condensed (make-array comp-n :element-type t)))\n    (dotimes (i comp-n)\n      (setf (aref condensed i) (make-hash-table :test #'eql)))\n    (dotimes (i n)\n      (let ((i-comp (aref components i)))\n        (dolist (neighbor (aref graph i))\n          (let ((neighbor-comp (aref components neighbor)))\n            (unless (= i-comp neighbor-comp)\n              (setf (gethash neighbor-comp (aref condensed i-comp)) t))))))\n    (dotimes (i comp-n)\n      (setf (aref condensed i)\n            (loop for x being each hash-key of (aref condensed i) collect x)))\n    condensed))\n\n;;;\n;;; 2-SAT\n;;;\n\n;; NOTE: use LOGNOT for negation\n\n(defpackage :cp/2sat\n  (:use :cl :cp/scc)\n  (:export #:2sat #:make-2sat #:2sat-p\n           #:add-implication #:add-disjunction #:2sat-solve))\n(in-package :cp/2sat)\n\n(defstruct (2sat (:constructor make-2sat\n                     (size\n                      &aux\n                      (graph (make-array (* 2 size) :element-type 'list :initial-element nil))))\n                 (:copier nil))\n  (size 0 :type (integer 0 #.most-positive-fixnum))\n  (graph nil :type (simple-array list (*)))\n  (scc nil :type (or null scc)))\n\n(declaim (inline %add-implication))\n(defun %add-implication (2sat p q)\n  (declare (fixnum p q))\n  (let ((size (2sat-size 2sat))\n        (graph (2sat-graph 2sat)))\n    (when (< p 0)\n      (setq p (+ size (lognot p))))\n    (when (< q 0)\n      (setq q (+ size (lognot q))))\n    (push q (aref graph p))\n    2sat))\n\n(defun add-implication (2sat p q)\n  (declare (fixnum p q))\n  (%add-implication 2sat p q)\n  (%add-implication 2sat (lognot q) (lognot p))\n  2sat)\n\n(declaim (inline add-disjunction))\n(defun add-disjunction (2sat p q)\n  \"Adds `P or Q' to 2SAT.\"\n  (declare (fixnum p q))\n  (%add-implication 2sat (lognot p) q)\n  (%add-implication 2sat (lognot q) p)\n  2sat)\n\n(declaim (inline 2sat-solve))\n(defun 2sat-solve (2sat)\n  \"Solves 2-SAT and returns a simple bit vector expressing the boolean of each\nvariable if it is feasible, otherwise returns NIL.\"\n  (let* ((size (2sat-size 2sat))\n         (graph (2sat-graph 2sat))\n         (scc (make-scc graph))\n         (components (scc-components scc))\n         (result (make-array size :element-type 'bit :initial-element 0)))\n    (setf (2sat-scc 2sat) scc)\n    (loop for v below size\n          for v-comp = (aref components v)\n          for neg-comp = (aref components (+ v size))\n          do (cond ((> v-comp neg-comp)\n                    (setf (sbit result v) 1))\n                   ((= v-comp neg-comp)\n                    (return-from 2sat-solve nil))))\n    result))\n\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/2sat :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (d (read))\n         (xs (make-array n :element-type 'uint31 :initial-element 0))\n         (ys (make-array n :element-type 'uint31 :initial-element 0)))\n    (declare (uint31 n d))\n    (dotimes (i n)\n      (setf (aref xs i) (read)\n            (aref ys i) (read)))\n    (let ((2sat (make-2sat n)))\n      (dotimes (i1 n)\n        (let ((x1 (aref xs i1))\n              (y1 (aref ys i1)))\n          (loop for i2 from (+ i1 1) below n\n                for x2 = (aref xs i2)\n                for y2 = (aref ys i2)\n                when (< (abs (- x1 x2)) d)\n                do (add-disjunction 2sat (lognot i1) (lognot i2))\n                when (< (abs (- x1 y2)) d)\n                do (add-disjunction 2sat (lognot i1) i2)\n                when (< (abs (- y1 x2)) d)\n                do (add-disjunction 2sat i1 (lognot i2))\n                when (< (abs (- y1 y2)) d)\n                do (add-disjunction 2sat i1 i2))))\n      (let ((res (2sat-solve 2sat)))\n        (if res\n            (write-string\n             (with-output-to-string (*standard-output* nil :element-type 'base-char)\n               (write-line \"Yes\")\n               (dotimes (i n)\n                 (println (aref (if (zerop (aref res i)) ys xs) i)))))\n            (write-line \"No\"))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n#-swank\n(eval-when (:compile-toplevel)\n  (when (and (boundp 'sb-c::*compiler-warning-count*)\n             (> sb-c::*compiler-warning-count* 0))\n    (sb-ext:quit :unix-status 1)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"Yes\n4\n2\n0\n\"\n          (run \"3 2\n1 4\n2 5\n0 6\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"No\n\"\n          (run \"3 3\n1 4\n2 5\n0 6\n\" nil))))\n"
  },
  {
    "language": "Ruby",
    "code": "class SCCGraph\n    def initialize(n = 0)\n        @n, @edges = n, []\n    end\n  \n    def add_edge(from, to); @edges << [from, to]; end\n  \n    # returns list of strongly connected components\n    # the components are sorted in topological order\n    # O(N + M)\n    def scc\n        group_num, ids = scc_ids\n        counts = Array.new(group_num, 0)\n        ids.each { |x| counts[x] += 1 }\n        groups = Array.new(group_num) { [] }\n        ids.each_with_index { |x, i| groups[x] << i }\n        groups\n    end\n\n    def scc_ids\n        start, elist = csr\n        now_ord = group_num = 0\n        visited, low, ord, ids = [], [], [-1] * @n, []\n\n        dfs = ->(v) {\n            low[v] = ord[v] = now_ord\n            now_ord += 1\n            visited << v\n            (start[v]...start[v + 1]).each do |i|\n                to = elist[i]\n                low[v] = if ord[to] == -1\n                    dfs.(to)\n                    [low[v], low[to]].min\n                else\n                    [low[v], ord[to]].min\n                end\n            end\n\n            if low[v] == ord[v]\n                loop do\n                    u = visited.pop\n                    ord[u] = @n\n                    ids[u] = group_num\n                    break if u == v\n                end\n                group_num += 1\n            end\n        }\n        @n.times { |i| dfs.(i) if ord[i] == -1 }\n        ids = ids.map { |x| group_num - 1 - x }\n        [group_num, ids]\n    end\n  \n    def csr\n        start = Array.new(@n+1, 0)\n        elist = Array.new(@edges.size)\n        @edges.each { |(i, _)| start[i + 1] += 1 }\n        @n.times { |i| start[i + 1] += start[i] }\n        counter = start.dup\n        @edges.each do |(i, j)|\n            elist[counter[i]] = j\n            counter[i] += 1\n        end\n        [start, elist]\n    end\nend\n\nclass Two_Sat\n    def initialize(n)\n        @n = n\n        @answer = Array.new(n)\n        @scc = SCCGraph.new(2 * n)\n    end\n\n    def add_clause(i, f, j, g)\n        @scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0))\n        @scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0))\n    end\n\n    def satisfiable\n        id = @scc.scc_ids[1]\n        @n.times do |i|\n            return false if id[2 * i] == id[2 * i + 1]\n            @answer[i] = id[2 * i] < id[2 * i + 1]\n        end\n        true\n    end\n\n    def answer; @answer; end\nend\n\nn, d = gets.split.map(&:to_i)\nts = Two_Sat.new(n)\n\nxy = []\nn.times do |i|\n    s, t = gets.split.map(&:to_i)\n    xy.each_with_index do |(x, y), j|\n        ts.add_clause(i, false, j, false) if (s - x).abs < d\n        ts.add_clause(i, false, j, true) if (s - y).abs < d\n        ts.add_clause(i, true, j, false) if (t - x).abs < d\n        ts.add_clause(i, true, j, true) if (t - y).abs < d\n    end\n    xy << [s, t]\nend\n\nif ts.satisfiable\n    puts \"Yes\"\n    ts.answer.each_with_index {|e, i| puts e ? xy[i][0] : xy[i][1]}\nelse\n    puts \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\n\n# https://github.com/universato/ac-library-rb/blob/master/src/scc.rb\nclass SCCGraph\n  # initialize graph with n vertices\n  def initialize(n = 0)\n    @n, @edges = n, []\n  end\n\n  # add directed edge\n  def add_edge(from, to)\n    raise \"invalid params\" unless (0...@n).include? from and (0...@n).include? to\n\n    @edges << [from, to]\n  end\n\n  # returns list of strongly connected components\n  # the components are sorted in topological order\n  # O(@n + @edges.size)\n  def scc\n    group_num, ids = scc_ids\n    counts = [0] * group_num\n    ids.each { |x| counts[x] += 1 }\n    groups = Array.new(group_num) { [] }\n    ids.each_with_index { |x, i| groups[x] << i }\n    groups\n  end\n\n  private\n\n  def scc_ids\n    start, elist = csr\n    now_ord = group_num = 0\n    visited, low, ord, ids = [], [], [-1] * @n, []\n    dfs = ->(v) {\n      low[v] = ord[v] = now_ord\n      now_ord += 1\n      visited << v\n      (start[v]...start[v + 1]).each do |i|\n        to = elist[i]\n        low[v] = if ord[to] == -1\n                   dfs.(to)\n                   [low[v], low[to]].min\n                 else\n                   [low[v], ord[to]].min\n                 end\n      end\n      if low[v] == ord[v]\n        loop do\n          u = visited.pop\n          ord[u] = @n\n          ids[u] = group_num\n          break if u == v\n        end\n        group_num += 1\n      end\n    }\n    @n.times { |i| dfs.(i) if ord[i] == -1 }\n    ids = ids.map { |x| group_num - 1 - x }\n    [group_num, ids]\n  end\n\n  def csr\n    start, elist = [0] * (@n + 1), [nil] * @edges.size\n    @edges.each { |(i, _)| start[i + 1] += 1 }\n    @n.times { |i| start[i + 1] += start[i] }\n    counter = start.dup\n    @edges.each do |(i, j)|\n      elist[counter[i]] = j\n      counter[i] += 1\n    end\n    [start, elist]\n  end\nend\n\n# TwoSat\n# Reference: https://github.com/atcoder/ac-library/blob/master/atcoder/twosat.hpp\nclass TwoSat\n  def initialize(n = 0)\n    @n = n\n    @answer = Array.new(n)\n    @scc = SCCGraph.new(2 * n)\n  end\n\n  attr_reader :answer\n\n  def add_clause(i, f, j, g)\n    @scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0))\n    @scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0))\n    nil\n  end\n\n  def satisfiable\n    id = @scc.send(:scc_ids)[1]\n    @n.times do |i|\n      return false if id[2 * i] == id[2 * i + 1]\n\n      @answer[i] = id[2 * i] < id[2 * i + 1]\n    end\n    true\n  end\nend\n\nn, d = gets.split.map(&:to_i)\nx, y = n.times.map { gets.split.map(&:to_i) }.transpose\nts = TwoSat.new(n)\n\nn.times do |i|\n  (i + 1...n).each do |j|\n    ts.add_clause(i, false, j, false) if (x[i] - x[j]).abs < d\n    ts.add_clause(i, false, j, true) if (x[i] - y[j]).abs < d\n    ts.add_clause(i, true, j, false) if (y[i] - x[j]).abs < d\n    ts.add_clause(i, true, j, true) if (y[i] - y[j]).abs < d\n  end\nend\n\nif ts.satisfiable\n  puts 'Yes'\n  ts.answer.each_with_index do |ans, i|\n    puts ans ? x[i] : y[i]\n  end\nelse\n  puts 'No'\nend\n"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\n\n# https://github.com/universato/ac-library-rb/blob/master/src/scc.rb\nclass SCCGraph\n  # initialize graph with n vertices\n  def initialize(n = 0)\n    @n, @edges = n, []\n  end\n\n  # add directed edge\n  def add_edge(from, to)\n    raise \"invalid params\" unless (0...@n).include? from and (0...@n).include? to\n\n    @edges << [from, to]\n  end\n\n  # returns list of strongly connected components\n  # the components are sorted in topological order\n  # O(@n + @edges.size)\n  def scc\n    group_num, ids = scc_ids\n    counts = [0] * group_num\n    ids.each { |x| counts[x] += 1 }\n    groups = Array.new(group_num) { [] }\n    ids.each_with_index { |x, i| groups[x] << i }\n    groups\n  end\n\n  private\n\n  def scc_ids\n    start, elist = csr\n    now_ord = group_num = 0\n    visited, low, ord, ids = [], [], [-1] * @n, []\n    dfs = ->(v) {\n      low[v] = ord[v] = now_ord\n      now_ord += 1\n      visited << v\n      (start[v]...start[v + 1]).each do |i|\n        to = elist[i]\n        low[v] = if ord[to] == -1\n                   dfs.(to)\n                   [low[v], low[to]].min\n                 else\n                   [low[v], ord[to]].min\n                 end\n      end\n      if low[v] == ord[v]\n        loop do\n          u = visited.pop\n          ord[u] = @n\n          ids[u] = group_num\n          break if u == v\n        end\n        group_num += 1\n      end\n    }\n    @n.times { |i| dfs.(i) if ord[i] == -1 }\n    ids = ids.map { |x| group_num - 1 - x }\n    [group_num, ids]\n  end\n\n  def csr\n    start, elist = [0] * (@n + 1), [nil] * @edges.size\n    @edges.each { |(i, _)| start[i + 1] += 1 }\n    @n.times { |i| start[i + 1] += start[i] }\n    counter = start.dup\n    @edges.each do |(i, j)|\n      elist[counter[i]] = j\n      counter[i] += 1\n    end\n    [start, elist]\n  end\nend\n\n# TwoSat\n# Reference: https://github.com/atcoder/ac-library/blob/master/atcoder/twosat.hpp\nclass TwoSat\n  def initialize(n = 0)\n    @n = n\n    @answer = Array.new(n)\n    @scc = SCCGraph.new(2 * n)\n  end\n\n  attr_reader :answer\n\n  def add_clause(i, f, j, g)\n    raise RangeError unless (0...@n).cover?(i) && (0...@n).cover?(j)\n\n    @scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0))\n    @scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0))\n    nil\n  end\n\n  def satisfiable\n    id = @scc.send(:scc_ids)[1]\n    @n.times do |i|\n      return false if id[2 * i] == id[2 * i + 1]\n\n      @answer[i] = id[2 * i] < id[2 * i + 1]\n    end\n    true\n  end\nend\n\n\nn, d = gets.split.map(&:to_i)\nx, y = n.times.map { gets.split.map(&:to_i) }.transpose\nts = TwoSat.new(n)\n\nn.times do |i|\n  (i + 1...n).each do |j|\n    ts.add_clause(i, false, j, false) if (x[i] - x[j]).abs < d\n    ts.add_clause(i, false, j, true) if (x[i] - y[j]).abs < d\n    ts.add_clause(i, true, j, false) if (y[i] - x[j]).abs < d\n    ts.add_clause(i, true, j, true) if (y[i] - y[j]).abs < d\n  end\nend\n\nif ts.satisfiable\n  puts 'Yes'\n  ts.answer.each_with_index do |ans, i|\n    puts ans ? x[i] : y[i]\n  end\nelse\n  puts 'No'\nend\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\ntype sccFromToPair struct {\n\tfirst, second int\n}\n\ntype sccIdPair struct {\n\tfirst  int\n\tsecond []int\n}\n\ntype csr struct {\n\tstart []int\n\telist []int\n}\n\nfunc initCsr(n int, edges []*sccFromToPair) *csr {\n\tvar ret csr\n\tret.start = make([]int, n+1)\n\tret.elist = make([]int, len(edges))\n\tfor _, e := range edges {\n\t\tret.start[e.first+1]++\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tret.start[i] += ret.start[i-1]\n\t}\n\tcounter := make([]int, len(ret.start))\n\tcopy(counter, ret.start)\n\tfor _, e := range edges {\n\t\tret.elist[counter[e.first]] = e.second\n\t\tcounter[e.first]++\n\t}\n\treturn &ret\n}\n\ntype SccGraph struct {\n\tn     int\n\tedges []*sccFromToPair\n}\n\nfunc NewGraph(n int) *SccGraph {\n\tvar s SccGraph\n\ts.n = n\n\treturn &s\n}\n\nfunc (s *SccGraph) AddEdge(from, to int) {\n\ts.edges = append(s.edges, &sccFromToPair{from, to})\n}\n\nfunc (s *SccGraph) min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc (s *SccGraph) SccIds() sccIdPair {\n\tg := initCsr(s.n, s.edges)\n\tnowOrd, groupNum := 0, 0\n\tvisited := make([]int, 0, s.n)\n\tlow := make([]int, s.n)\n\tord := make([]int, s.n)\n\tids := make([]int, s.n)\n\tfor i := 0; i < s.n; i++ {\n\t\tord[i] = -1\n\t}\n\tvar dfs func(v int)\n\tdfs = func(v int) {\n\t\tlow[v] = nowOrd\n\t\tord[v] = nowOrd\n\t\tnowOrd++\n\t\tvisited = append(visited, v)\n\t\tfor i := g.start[v]; i < g.start[v+1]; i++ {\n\t\t\tto := g.elist[i]\n\t\t\tif ord[to] == -1 {\n\t\t\t\tdfs(to)\n\t\t\t\tlow[v] = s.min(low[v], low[to])\n\t\t\t} else {\n\t\t\t\tlow[v] = s.min(low[v], ord[to])\n\t\t\t}\n\t\t}\n\t\tif low[v] == ord[v] {\n\t\t\tfor {\n\t\t\t\tu := visited[len(visited)-1]\n\t\t\t\tvisited = visited[:len(visited)-1]\n\t\t\t\tord[u] = s.n\n\t\t\t\tids[u] = groupNum\n\t\t\t\tif u == v {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroupNum++\n\t\t}\n\t}\n\tfor i := 0; i < s.n; i++ {\n\t\tif ord[i] == -1 {\n\t\t\tdfs(i)\n\t\t}\n\t}\n\tfor i := 0; i < len(ids); i++ {\n\t\tids[i] = groupNum - 1 - ids[i]\n\t}\n\treturn sccIdPair{groupNum, ids}\n}\n\ntype TwoSat struct {\n\tn      int\n\tanswer []bool\n\tscc    *SccGraph\n}\n\nfunc New(n int) *TwoSat {\n\tts := &TwoSat{\n\t\tn:      n,\n\t\tanswer: make([]bool, n),\n\t\tscc:    NewGraph(n * 2),\n\t}\n\treturn ts\n}\n\nfunc (ts *TwoSat) internalJudge(f bool, a int, b int) int {\n\tif f == true {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc (ts *TwoSat) AddClause(i int, f bool, j int, g bool) {\n\tif !(0 <= i && i < ts.n) {\n\t\tpanic(\"\")\n\t}\n\tif !(0 <= j && j < ts.n) {\n\t\tpanic(\"\")\n\t}\n\tts.scc.AddEdge(2*i+ts.internalJudge(f, 0, 1), 2*j+ts.internalJudge(g, 1, 0))\n\tts.scc.AddEdge(2*j+ts.internalJudge(g, 0, 1), 2*i+ts.internalJudge(f, 1, 0))\n}\n\nfunc (ts *TwoSat) Satisfiable() bool {\n\tid := ts.scc.SccIds().second\n\n\tfor i := 0; i < ts.n; i++ {\n\t\tif id[2*i] == id[2*i+1] {\n\t\t\treturn false\n\t\t}\n\t\tts.answer[i] = id[2*i] < id[2*i+1]\n\t}\n\treturn true\n}\n\nfunc (ts *TwoSat) Answer() []bool {\n\treturn ts.answer\n}\n\nfunc absInt(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc main() {\n\n\tvar n, d int\n\tfmt.Scan(&n, &d)\n\n\tx := make([]int, n)\n\ty := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(&x[i], &y[i])\n\t}\n\n\tts := New(n)\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tif absInt(x[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, false)\n\t\t\t}\n\t\t\tif absInt(x[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, true)\n\t\t\t}\n\t\t\tif absInt(y[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, false)\n\t\t\t}\n\t\t\tif absInt(y[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, true)\n\t\t\t}\n\t\t}\n\t}\n\n\tif ts.Satisfiable() == false {\n\t\tfmt.Println(\"No\")\n\t} else {\n\t\tfmt.Println(\"Yes\")\n\n\t\tanswer := ts.Answer()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif answer[i] == true {\n\t\t\t\tfmt.Println(x[i])\n\t\t\t} else {\n\t\t\t\tfmt.Println(y[i])\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\td := getNextInt(scanner)\n\txx := make([]int, n)\n\tyy := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\txx[i] = getNextInt(scanner)\n\t\tyy[i] = getNextInt(scanner)\n\t}\n\tt := NewTwoSat(n)\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tif abs(xx[i]-xx[j]) < d {\n\t\t\t\tt.AddClause(i, false, j, false)\n\t\t\t}\n\t\t\tif abs(xx[i]-yy[j]) < d {\n\t\t\t\tt.AddClause(i, false, j, true)\n\t\t\t}\n\t\t\tif abs(yy[i]-xx[j]) < d {\n\t\t\t\tt.AddClause(i, true, j, false)\n\t\t\t}\n\t\t\tif abs(yy[i]-yy[j]) < d {\n\t\t\t\tt.AddClause(i, true, j, true)\n\t\t\t}\n\t\t}\n\t}\n\tif t.Satisfiable() {\n\t\tfmt.Fprintln(writer, \"Yes\")\n\t\tanswer := t.Answer()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif answer[i] {\n\t\t\t\tfmt.Fprintln(writer, xx[i])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintln(writer, yy[i])\n\t\t}\n\t\treturn\n\t}\n\tfmt.Fprintln(writer, \"No\")\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// TwoSat solves 2-SAT.\ntype TwoSat struct {\n\tn      int\n\tanswer []bool\n\tscc    *SccGraph\n}\n\n// NewTwoSat creates a 2-SAT of n variables and 0 clauses.\nfunc NewTwoSat(n int) *TwoSat {\n\treturn &TwoSat{\n\t\tn:      n,\n\t\tanswer: make([]bool, n),\n\t\tscc:    NewSccGraph(n << 1),\n\t}\n}\n\n// AddClause adds a clause (x_i = f) v (x_j = g)\nfunc (t *TwoSat) AddClause(i int, f bool, j int, g bool) {\n\ti <<= 1\n\tj <<= 1\n\tswitch {\n\tcase f && g:\n\t\tt.scc.AddEdge(i, j+1)\n\t\tt.scc.AddEdge(j, i+1)\n\tcase f && !g:\n\t\tt.scc.AddEdge(i, j)\n\t\tt.scc.AddEdge(j+1, i+1)\n\tcase !f && g:\n\t\tt.scc.AddEdge(i+1, j+1)\n\t\tt.scc.AddEdge(j, i)\n\tdefault:\n\t\tt.scc.AddEdge(i+1, j)\n\t\tt.scc.AddEdge(j+1, i)\n\t}\n}\n\n// Satisfiable returns whether there is a truth assignment that satisfies all clauses.\nfunc (t *TwoSat) Satisfiable() bool {\n\t_, id := t.scc.SccIds()\n\tfor i := 0; i < t.n; i++ {\n\t\tii := i << 1\n\t\tif id[ii] == id[ii+1] {\n\t\t\treturn false\n\t\t}\n\t\tt.answer[i] = id[ii] < id[ii+1]\n\t}\n\treturn true\n}\n\n// Answer returns a truth assignment that satisfies all clauses of the last call of satisfiable.\n// If we call it before calling satisfiable or when the last call of satisfiable returns false, it returns the vector of length n with undefined elements.\nfunc (t *TwoSat) Answer() []bool {\n\treturn t.answer\n}\n\n// Csr edge list\ntype Csr struct {\n\tStart []int\n\tElist []*Edge\n}\n\n// Pair holds starting point and Edge\ntype Pair struct {\n\tFrom int\n\tE    *Edge\n}\n\n// Edge holds end point\ntype Edge struct {\n\tTo int\n}\n\n// SccGraph calculates the strongly connected components of directed graphs.\ntype SccGraph struct {\n\tn     int\n\tedges []*Pair\n}\n\n// NewCsr creates edge lists\nfunc NewCsr(n int, edges []*Pair) *Csr {\n\tstart := make([]int, n+1)\n\tcounter := make([]int, n+1)\n\telist := make([]*Edge, len(edges))\n\tfor _, e := range edges {\n\t\tstart[e.From+1]++\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tstart[i+1] += start[i]\n\t}\n\tcopy(counter, start)\n\tfor _, e := range edges {\n\t\telist[counter[e.From]] = e.E\n\t\tcounter[e.From]++\n\t}\n\n\treturn &Csr{Start: start, Elist: elist}\n}\n\n// NewSccGraph creates a directed graph with nn vertices and 0 edges.\nfunc NewSccGraph(n int) *SccGraph {\n\treturn &SccGraph{n: n, edges: make([]*Pair, 0)}\n}\n\n// AddEdge adds a directed edge from the vertex from to the vertex to.\nfunc (s *SccGraph) AddEdge(from, to int) {\n\ts.edges = append(s.edges, &Pair{From: from, E: &Edge{To: to}})\n}\n\n// SccIds returns pair of (# of scc, scc id)\nfunc (s *SccGraph) SccIds() (int, []int) {\n\tg := NewCsr(s.n, s.edges)\n\tvar now, group int\n\tn := s.n\n\tvisited := make([]int, 0)\n\tlow := make([]int, n)\n\tord := make([]int, n)\n\tids := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tord[i] = -1\n\t}\n\tvar dfs func(int)\n\tdfs = func(v int) {\n\t\tlow[v] = now\n\t\tord[v] = now\n\t\tnow++\n\t\tvisited = append(visited, v)\n\t\tfor i := g.Start[v]; i < g.Start[v+1]; i++ {\n\t\t\tto := g.Elist[i].To\n\t\t\tif ord[to] == -1 {\n\t\t\t\tdfs(to)\n\t\t\t\tif low[v] > low[to] {\n\t\t\t\t\tlow[v] = low[to]\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif low[v] > ord[to] {\n\t\t\t\tlow[v] = ord[to]\n\t\t\t}\n\t\t}\n\t\tif low[v] == ord[v] {\n\t\t\tfor i := len(visited) - 1; i >= 0; i-- {\n\t\t\t\tu := visited[i]\n\t\t\t\tord[u] = n\n\t\t\t\tids[u] = group\n\t\t\t\tvisited = visited[:i]\n\t\t\t\tif v == u {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroup++\n\t\t}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif ord[i] == -1 {\n\t\t\tdfs(i)\n\t\t}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tids[i] = group - 1 - ids[i]\n\t}\n\treturn group, ids\n}\n\n// Scc returns the list of the \"list of the vertices\" that satisfies the following.\n// Each vertex is in exactly one \"list of the vertices\".\n// Each \"list of the vertices\" corresponds to the vertex set of a strongly connected component.\n// The order of the vertices in the list is undefined.\n// The list of \"list of the vertices\" are sorted in topological order, i.e., for two vertices u, v in different strongly connected components, if there is a directed path from u to v, the list contains u appears earlier than the list contains v.\nfunc (s *SccGraph) Scc() [][]int {\n\tgroup, ids := s.SccIds()\n\tgroups := make([][]int, group)\n\tfor i := 0; i < s.n; i++ {\n\t\tgroups[ids[i]] = append(groups[ids[i]], i)\n\t}\n\treturn groups\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\ntype sccFromToPair struct {\n\tfirst, second int\n}\n\ntype sccIdPair struct {\n\tfirst  int\n\tsecond []int\n}\n\ntype csr struct {\n\tstart []int\n\telist []int\n}\n\nfunc initCsr(n int, edges []*sccFromToPair) *csr {\n\tvar ret csr\n\tret.start = make([]int, n+1)\n\tret.elist = make([]int, len(edges))\n\tfor _, e := range edges {\n\t\tret.start[e.first+1]++\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tret.start[i] += ret.start[i-1]\n\t}\n\tcounter := make([]int, len(ret.start))\n\tcopy(counter, ret.start)\n\tfor _, e := range edges {\n\t\tret.elist[counter[e.first]] = e.second\n\t\tcounter[e.first]++\n\t}\n\treturn &ret\n}\n\ntype SccGraph struct {\n\tn     int\n\tedges []*sccFromToPair\n}\n\nfunc NewGraph(n int) *SccGraph {\n\tvar s SccGraph\n\ts.n = n\n\treturn &s\n}\n\nfunc (s *SccGraph) AddEdge(from, to int) {\n\ts.edges = append(s.edges, &sccFromToPair{from, to})\n}\n\nfunc (s *SccGraph) min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc (s *SccGraph) SccIds() sccIdPair {\n\tg := initCsr(s.n, s.edges)\n\tnowOrd, groupNum := 0, 0\n\tvisited := make([]int, 0, s.n)\n\tlow := make([]int, s.n)\n\tord := make([]int, s.n)\n\tids := make([]int, s.n)\n\tfor i := 0; i < s.n; i++ {\n\t\tord[i] = -1\n\t}\n\tvar dfs func(v int)\n\tdfs = func(v int) {\n\t\tlow[v] = nowOrd\n\t\tord[v] = nowOrd\n\t\tnowOrd++\n\t\tvisited = append(visited, v)\n\t\tfor i := g.start[v]; i < g.start[v+1]; i++ {\n\t\t\tto := g.elist[i]\n\t\t\tif ord[to] == -1 {\n\t\t\t\tdfs(to)\n\t\t\t\tlow[v] = s.min(low[v], low[to])\n\t\t\t} else {\n\t\t\t\tlow[v] = s.min(low[v], ord[to])\n\t\t\t}\n\t\t}\n\t\tif low[v] == ord[v] {\n\t\t\tfor {\n\t\t\t\tu := visited[len(visited)-1]\n\t\t\t\tvisited = visited[:len(visited)-1]\n\t\t\t\tord[u] = s.n\n\t\t\t\tids[u] = groupNum\n\t\t\t\tif u == v {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroupNum++\n\t\t}\n\t}\n\tfor i := 0; i < s.n; i++ {\n\t\tif ord[i] == -1 {\n\t\t\tdfs(i)\n\t\t}\n\t}\n\tfor i := 0; i < len(ids); i++ {\n\t\tids[i] = groupNum - 1 - ids[i]\n\t}\n\treturn sccIdPair{groupNum, ids}\n}\n\ntype TwoSat struct {\n\tn      int\n\tanswer []bool\n\tscc    *SccGraph\n}\n\nfunc New(n int) *TwoSat {\n\tts := &TwoSat{\n\t\tn:      n,\n\t\tanswer: make([]bool, n),\n\t\tscc:    NewGraph(n * 2),\n\t}\n\treturn ts\n}\n\nfunc (ts *TwoSat) internalJudge(f bool, a int, b int) int {\n\tif f == true {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc (ts *TwoSat) AddClause(i int, f bool, j int, g bool) {\n\tif !(0 <= i && i < ts.n) {\n\t\tpanic(\"\")\n\t}\n\tif !(0 <= j && j < ts.n) {\n\t\tpanic(\"\")\n\t}\n\tts.scc.AddEdge(2*i+ts.internalJudge(f, 0, 1), 2*j+ts.internalJudge(g, 1, 0))\n\tts.scc.AddEdge(2*j+ts.internalJudge(g, 0, 1), 2*i+ts.internalJudge(f, 1, 0))\n}\n\nfunc (ts *TwoSat) Satisfiable() bool {\n\tid := ts.scc.SccIds().second\n\n\tfor i := 0; i < ts.n; i++ {\n\t\tif id[2*i] == id[2*i+1] {\n\t\t\treturn false\n\t\t}\n\t\tts.answer[i] = id[2*i] < id[2*i+1]\n\t}\n\treturn true\n}\n\nfunc (ts *TwoSat) Answer() []bool {\n\treturn ts.answer\n}\n\nfunc absInt(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc main() {\n\n\tvar n, d int\n \tfmt.Scan(&n, &d)\n\n\tx := make([]int, n)\n\ty := make([]int, n)\n\tfor i:=0;i<n;i++{\n    \tfmt.Scan(&x[i],&y[i])\n\t}\n\n\tts := New(n)\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tif absInt(x[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, false)\n\t\t\t}\n\t\t\tif absInt(x[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, true)\n\t\t\t}\n\t\t\tif absInt(y[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, false)\n\t\t\t}\n\t\t\tif absInt(y[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, true)\n\t\t\t}\n\t\t}\n\t}\n\n\tif ts.Satisfiable() == false {\n\t\tfmt.Println(\"No\")\n\t} else {\n\t\tfmt.Println(\"Yes\")\n\n\t\tanswer := ts.Answer()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif answer[i] == true {\n\t\t\t\tfmt.Println(x[i])\n\t\t\t} else {\n\t\t\t\tfmt.Println(y[i])\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc Scan() string {\n\tsc.Scan()\n\treturn sc.Text()\n}\nfunc rScan() []rune {\n\treturn []rune(Scan())\n}\nfunc iScan() int {\n\tn, _ := strconv.Atoi(Scan())\n\treturn n\n}\nfunc fScan() float64 {\n\tn, _ := strconv.ParseFloat(Scan(), 64)\n\treturn n\n}\nfunc stringToInt(s string) int {\n\tn, _ := strconv.Atoi(s)\n\treturn n\n}\nfunc SScan(n int) []string {\n\ta := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = Scan()\n\t}\n\treturn a\n}\nfunc iSScan(n int) []int {\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = iScan()\n\t}\n\treturn a\n}\nfunc abs(x int) int {\n\tif x < 0 {\n\t\tx = -x\n\t}\n\treturn x\n}\nfunc mod(x, d int) int {\n\tx %= d\n\tif x < 0 {\n\t\tx += d\n\t}\n\treturn x\n}\nfunc larger(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc smaller(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc max(a []int) int {\n\tx := a[0]\n\tfor i := 0; i < len(a); i++ {\n\t\tif x < a[i] {\n\t\t\tx = a[i]\n\t\t}\n\t}\n\treturn x\n}\nfunc min(a []int) int {\n\tx := a[0]\n\tfor i := 0; i < len(a); i++ {\n\t\tif x > a[i] {\n\t\t\tx = a[i]\n\t\t}\n\t}\n\treturn x\n}\nfunc sum(a []int) int {\n\tx := 0\n\tfor _, v := range a {\n\t\tx += v\n\t}\n\treturn x\n}\nfunc fSum(a []float64) float64 {\n\tx := 0.\n\tfor _, v := range a {\n\t\tx += v\n\t}\n\treturn x\n}\nfunc bPrint(f bool, x string, y string) {\n\tif f {\n\t\tfmt.Println(x)\n\t} else {\n\t\tfmt.Println(y)\n\t}\n}\nfunc iSSPrint(x []int) {\n\tfmt.Println(strings.Trim(fmt.Sprint(x), \"[]\"))\n}\n\nvar lp1 int = 1000000007\nvar lp2 int = 998244353\n\nfunc main() {\n\tbuf := make([]byte, 0)\n\tsc.Buffer(buf, lp1)\n\tsc.Split(bufio.ScanWords)\n\tn := iScan()\n\td := iScan()\n\tx, y := make([]int, n), make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tx[i], y[i] = iScan(), iScan()\n\t}\n\tts := newTwoSat(n)\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tif abs(x[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, false)\n\t\t\t}\n\t\t\tif abs(x[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, false, j, true)\n\t\t\t}\n\t\t\tif abs(y[i]-x[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, false)\n\t\t\t}\n\t\t\tif abs(y[i]-y[j]) < d {\n\t\t\t\tts.AddClause(i, true, j, true)\n\t\t\t}\n\t\t}\n\t}\n\tif !ts.Satisfiable() {\n\t\tfmt.Println(\"No\")\n\t} else {\n\t\tans := ts.Answer()\n\t\tfmt.Println(\"Yes\")\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif ans[i] {\n\t\t\t\tfmt.Println(x[i])\n\t\t\t} else {\n\t\t\t\tfmt.Println(y[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype SccGraph struct {\n\tn     int\n\tedges [][2]int\n}\ntype Csr struct {\n\tstart []int\n\telist []int\n}\ntype TwoSat struct {\n\tn        int\n\tanswer   []bool\n\tsccGraph *SccGraph\n}\n\nfunc newSccGraph(n int) *SccGraph {\n\tscc := new(SccGraph)\n\tscc.n = n\n\treturn scc\n}\nfunc (scc *SccGraph) NumVertices() int {\n\treturn scc.n\n}\nfunc (scc *SccGraph) AddEdge(from int, to int) {\n\tscc.edges = append(scc.edges, [2]int{from, to})\n}\nfunc (c *Csr) csr(n int, edges [][2]int) {\n\tc.start = make([]int, n+1)\n\tc.elist = make([]int, len(edges))\n\tfor _, e := range edges {\n\t\tc.start[e[0]+1]++\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tc.start[i] += c.start[i-1]\n\t}\n\tcounter := make([]int, n+1)\n\tcopy(counter, c.start)\n\tfor _, e := range edges {\n\t\tc.elist[counter[e[0]]] = e[1]\n\t\tcounter[e[0]]++\n\t}\n}\nfunc (scc *SccGraph) SccIds() (int, []int) {\n\tg := new(Csr)\n\tg.csr(scc.n, scc.edges)\n\tnowOrd, groupNum := 0, 0\n\tvisited, low := make([]int, 0, scc.n), make([]int, scc.n)\n\tord, ids := make([]int, scc.n), make([]int, scc.n)\n\tfor i := 0; i < scc.n; i++ {\n\t\tord[i] = -1\n\t}\n\tvar dfs func(v int)\n\tdfs = func(v int) {\n\t\tlow[v], ord[v] = nowOrd, nowOrd\n\t\tnowOrd++\n\t\tvisited = append(visited, v)\n\t\tfor i := g.start[v]; i < g.start[v+1]; i++ {\n\t\t\tto := g.elist[i]\n\t\t\tif ord[to] == -1 {\n\t\t\t\tdfs(to)\n\t\t\t\tlow[v] = scc.min(low[v], low[to])\n\t\t\t} else {\n\t\t\t\tlow[v] = scc.min(low[v], ord[to])\n\t\t\t}\n\t\t}\n\t\tif low[v] == ord[v] {\n\t\t\tfor {\n\t\t\t\tu := visited[len(visited)-1]\n\t\t\t\tvisited = visited[:len(visited)-1]\n\t\t\t\tord[u] = scc.n\n\t\t\t\tids[u] = groupNum\n\t\t\t\tif u == v {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroupNum++\n\t\t}\n\t}\n\tfor i := 0; i < scc.n; i++ {\n\t\tif ord[i] == -1 {\n\t\t\tdfs(i)\n\t\t}\n\t}\n\tfor i := 0; i < len(ids); i++ {\n\t\tids[i] = groupNum - 1 - ids[i]\n\t}\n\treturn groupNum, ids\n}\nfunc (scc *SccGraph) min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\nfunc (scc *SccGraph) Scc() [][]int {\n\tgroupNum, ids := scc.SccIds()\n\tcounts := make([]int, groupNum)\n\tfor _, x := range ids {\n\t\tcounts[x]++\n\t}\n\tgroups := make([][]int, groupNum)\n\tfor i := 0; i < groupNum; i++ {\n\t\tgroups[i] = make([]int, 0, counts[i])\n\t}\n\tfor i := 0; i < scc.n; i++ {\n\t\tgroups[ids[i]] = append(groups[ids[i]], i)\n\t}\n\treturn groups\n}\nfunc newTwoSat(n int) *TwoSat {\n\tts := new(TwoSat)\n\tts.n = n\n\tts.answer = make([]bool, n)\n\tts.sccGraph = newSccGraph(n * 2)\n\treturn ts\n}\nfunc (ts *TwoSat) AddClause(i int, f bool, j int, g bool) {\n\tts.sccGraph.AddEdge(2*i+ts.judge(f, 0, 1), 2*j+ts.judge(g, 1, 0))\n\tts.sccGraph.AddEdge(2*j+ts.judge(g, 0, 1), 2*i+ts.judge(f, 1, 0))\n}\nfunc (ts *TwoSat) Satisfiable() bool {\n\t_, id := ts.sccGraph.SccIds()\n\tfor i := 0; i < ts.n; i++ {\n\t\tif id[i*2] == id[2*i+1] {\n\t\t\treturn false\n\t\t}\n\t\tts.answer[i] = id[2*i] < id[2*i+1]\n\t}\n\treturn true\n}\nfunc (ts *TwoSat) judge(f bool, a int, b int) int {\n\tif f {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\nfunc (ts *TwoSat) Answer() []bool {\n\treturn ts.answer\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n/**\n * Class TwoSat\n * 2-SATを解きます。 変数 x_0, x_1, ･･･, x_{N - 1} に関して、\n * (x_i = f) ∨ (x_j = g)\n * というクローズを足し、これをすべて満たす変数の割当があるかを解きます。\n */\nclass TwoSat\n{\n    private int $n;\n    private array $answer;\n    private object $scc;\n\n    /**\n     * TwoSat constructor.\n     * n変数の2-SATを作ります。\n     * 計算量 O(n)\n     * @param int $n 0 < n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n        $this->answer = array_fill(0, $n,false);\n        $this->scc = new SCC(2 * $n);\n\n    }\n\n    /**\n     * (x_i = f) ∨ (x_j = g) というクローズを足します。\n     * 計算量　ならしO(1)\n     * @param int $i 0 ≤ i < n\n     * @param bool $f\n     * @param int $j 0 ≤ i < n\n     * @param bool $g\n     */\n    public function add_clause(int $i, bool $f, int $j, bool $g): void\n    {\n        assert(0 <= $i && $i < $this->n);\n        assert(0 <= $j && $j < $this->n);\n        $this->scc->add_edge(2 * $i + ($f ? 0: 1), 2 * $j + ($g ? 1 : 0));\n        $this->scc->add_edge(2 * $j + ($g ? 0: 1), 2 * $i + ($f ? 1 : 0));\n\n    }\n\n    /**\n     * 条件を足す割当が存在するかどうかを判定する。割当が存在するならばtrue、そうでないならfalseを返す。\n     * 複数回呼ぶことも可能\n     * 計算量　追加した制約の個数をmとして\n     * O(n+m)\n     * @return bool\n     */\n    public function satisfiable(): bool\n    {\n        $id = $this->scc->scc_ids()[1];\n        for($i=0; $i < $this->n; $i++){\n            if($id[2 * $i] === $id[2 * $i + 1]){\n                return false;\n            }\n            $this->answer[$i] = $id[2 * $i] < $id[2 * $i + 1];\n        }\n        return true;\n    }\n\n    /**\n     * 最後に呼んだ satisfiable の、クローズを満たす割当を返す。\n     * satisfiable を呼ぶ前や、 satisfiableで割当が存在しなかったときにこの関数を呼ぶと、中身が未定義の長さ n の vectorを返す。\n     * 計算量 O(n)\n     * @return array\n     */\n    public function  answer():array\n    {\n        return $this->answer;\n    }\n}\n\n\n/**\n * Class SCC\n * 有向グラフを強連結成分分解します。\n * TwoSatでも使用しているため、書き換える際は注意。\n * ref. AtCoder Library\n */\nclass SCC\n{\n\n    private int $n;\n    private array $edges = [];\n    private array $start;\n    private array $elist;\n\n    /**\n     * MaxFlow constructor.\n     * n 頂点 0 辺の有向グラフを作る。\n     * 計算量 O(n)\n     * @param int $n 0 ≤ n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n    }\n\n    /**\n     * 頂点fromから頂点toへ有向辺を足す。\n     * 計算量 ならしO(1)\n     * @param int $from 0 ≤ from < n\n     * @param int $to 0 ≤ to < n\n     */\n    public function add_edge(int $from, int $to): void\n    {\n        assert(0 <= $from && $from < $this->n);\n        assert(0 <= $to && $to < $this->n);\n        $this->edges[] = [$from, $to];\n    }\n\n    public function csr(): void\n    {\n        $this->start = $this->elist =  array_fill(0, $this->n+1, 0);\n\n        foreach($this->edges as $e){\n            $this->start[$e[0] + 1]++;\n        }\n        for($i=1; $i<=$this->n; $i++){\n            $this->start[$i] += $this->start[$i-1];\n        }\n        $counter = $this->start;\n        foreach($this->edges as $e){\n            $this->elist[$counter[$e[0]]++] = $e[1];\n        }\n    }\n\n    public function scc_ids(): array\n    {\n        $this->csr();\n        $now_ord = $group_num = 0;\n        $visited = new SplDoublyLinkedList();\n        $visited->setIteratorMode(SplDoublyLinkedList::IT_MODE_DELETE | SplDoublyLinkedList::IT_MODE_LIFO);\n        $low = $ids = array_fill(0, $this->n, 0);\n        $ord = array_fill(0, $this->n, -1);\n        $dfs = function($v) use(&$now_ord, &$visited, &$ord, &$low, &$dfs, &$ids, &$group_num){\n            $low[$v] = $ord[$v] = $now_ord++;\n            $visited->push($v);\n            for($i=$this->start[$v]; $i < $this->start[$v +1]; $i++) {\n                $to = $this->elist[$i];\n                if ($ord[$to] === -1) {\n                    $dfs($to);\n                    $low[$v] = min($low[$v], $low[$to]);\n                } else {\n                    $low[$v] = min($low[$v], $ord[$to]);\n                }\n            }\n            if($low[$v] === $ord[$v]){\n                while(true){\n                    $u = $visited->pop();\n                    $ord[$u] = $this->n;\n                    $ids[$u] = $group_num;\n                    if($u === $v){\n                        break;\n                    }\n                }\n                $group_num++;\n            }\n        };\n        for($i=0;$i<$this->n; $i++){\n            if($ord[$i] === -1){\n                $dfs($i);\n            }\n        }\n        foreach($ids as &$x){\n            $x = $group_num - 1 - $x;\n        }\n        return [$group_num, $ids];\n\n    }\n\n    /**\n     * 以下の条件を満たすような「頂点のリスト」のリストを返します。\n     * ・全ての頂点がちょうど1つずつ、どれかのリストに含まれます。\n     * ・内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。\n     * ・リストはトポロジカルソートされています。異なる強連結成分の頂点 u, vu,v について、uu から vv に到達できる時、uu の属するリストは vv の属するリストよりも前です。\n     * 計算量　追加した辺の本数をmとして\n     * O(n+m)\n     * @return array\n     */\n    public function scc():array\n    {\n        $ids = $this->scc_ids();\n        $group_num = $ids[0];\n        $counts =  array_fill(0,$group_num, 0);\n        $groups = array_fill(0,$group_num, []);;\n        foreach($ids[1] as $x){\n            $counts[$x]++;\n        }\n        for($i=0;$i<$this->n;$i++){\n            $groups[$ids[1][$i]][] = $i;\n        }\n        return $groups;\n    }\n}\n\n\n[$N, $D] = fscanf(STDIN, \"%d%d\");\n$X=$Y=[];\nfor($i=0; $i< $N; $i++){\n    [$X[$i], $Y[$i]] = fscanf(STDIN, \"%d%d\");\n}\n\n$ts = new TwoSat($N);\n\nfor($i=0; $i < $N; $i++){\n    for($j= $i + 1; $j < $N; $j++){\n        if(abs($X[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, false, $j, false);\n        }\n        if(abs($X[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, false, $j, true);\n        }\n\n        if(abs($Y[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, true, $j, false);\n        }\n        if(abs($Y[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, true, $j, true);\n        }\n    }\n}\nif(!$ts->satisfiable()){\n    echo \"No\";\n    exit;\n}\necho \"Yes\". PHP_EOL;\n$ans = $ts->answer();\nfor($i=0;$i<$N;$i++) {\n    if ($ans[$i]) {\n        echo $X[$i] . PHP_EOL;\n    } else {\n        echo $Y[$i] . PHP_EOL;\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n/**\n * Class TwoSat\n * 2-SATを解きます。 変数 x_0, x_1, ･･･, x_{N - 1} に関して、\n * (x_i = f) ∨ (x_j = g)\n * というクローズを足し、これをすべて満たす変数の割当があるかを解きます。\n */\nclass TwoSat\n{\n    private int $n;\n    private array $answer;\n    private object $scc;\n\n    /**\n     * TwoSat constructor.\n     * n変数の2-SATを作ります。\n     * 計算量 O(n)\n     * @param int $n 0 < n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n        $this->answer = array_fill(0, $n,false);\n        $this->scc = new SCC(2 * $n);\n\n    }\n\n    /**\n     * (x_i = f) ∨ (x_j = g) というクローズを足します。\n     * 計算量　ならしO(1)\n     * @param int $i 0 ≤ i < n\n     * @param bool $f\n     * @param int $j 0 ≤ i < n\n     * @param bool $g\n     */\n    public function add_clause(int $i, bool $f, int $j, bool $g): void\n    {\n        assert(0 <= $i && $i < $this->n);\n        assert(0 <= $j && $j < $this->n);\n        $this->scc->add_edge(2 * $i + ($f ? 0: 1), 2 * $j + ($g ? 1 : 0));\n        $this->scc->add_edge(2 * $j + ($g ? 0: 1), 2 * $i + ($f ? 1 : 0));\n\n    }\n\n    /**\n     * 条件を足す割当が存在するかどうかを判定する。割当が存在するならばtrue、そうでないならfalseを返す。\n     * 複数回呼ぶことも可能\n     * 計算量　追加した制約の個数をmとして\n     * O(n+m)\n     * @return bool\n     */\n    public function satisfiable(): bool\n    {\n        $id = $this->scc->scc_ids()[1];\n        for($i=0; $i < $this->n; $i++){\n            if($id[2 * $i] === $id[2 * $i + 1]){\n                return false;\n            }\n            $this->answer[$i] = $id[2 * $i] < $id[2 * $i + 1];\n        }\n        return true;\n    }\n\n    /**\n     * 最後に呼んだ satisfiable の、クローズを満たす割当を返す。\n     * satisfiable を呼ぶ前や、 satisfiableで割当が存在しなかったときにこの関数を呼ぶと、中身が未定義の長さ n の vectorを返す。\n     * 計算量 O(n)\n     * @return array\n     */\n    public function  answer():array\n    {\n        return $this->answer;\n    }\n}\n\n\n/**\n * Class SCC\n * 有向グラフを強連結成分分解します。\n * TwoSatでも使用しているため、書き換える際は注意。\n * ref. AtCoder Library\n */\nclass SCC\n{\n\n    private int $n;\n    private array $edges;\n    private array $start;\n    private array $elist;\n\n    /**\n     * MaxFlow constructor.\n     * n 頂点 0 辺の有向グラフを作る。\n     * 計算量 O(n)\n     * @param int $n 0 ≤ n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n    }\n\n    /**\n     * 頂点fromから頂点toへ有向辺を足す。\n     * 計算量 ならしO(1)\n     * @param int $from 0 ≤ from < n\n     * @param int $to 0 ≤ to < n\n     */\n    public function add_edge(int $from, int $to): void\n    {\n        assert(0 <= $from && $from < $this->n);\n        assert(0 <= $to && $to < $this->n);\n        $this->edges[] = [$from, $to];\n    }\n\n    public function csr(): void\n    {\n        $this->start = $this->elist =  array_fill(0, $this->n+1, 0);\n        foreach($this->edges as $e){\n            $this->start[$e[0] + 1]++;\n        }\n        for($i=1; $i<=$this->n; $i++){\n            $this->start[$i] += $this->start[$i-1];\n        }\n        $counter = $this->start;\n        foreach($this->edges as $e){\n            $this->elist[$counter[$e[0]]++] = $e[1];\n        }\n    }\n\n    private function scc_ids(): array\n    {\n        $this->csr();\n        $now_ord = $group_num = 0;\n        $visited = new SplDoublyLinkedList();\n        $visited->setIteratorMode(SplDoublyLinkedList::IT_MODE_DELETE | SplDoublyLinkedList::IT_MODE_LIFO);\n        $low = $ids = array_fill(0, $this->n, 0);\n        $ord = array_fill(0, $this->n, -1);\n        $dfs = function($v) use(&$now_ord, &$visited, &$ord, &$low, &$dfs, &$ids, &$group_num){\n            $low[$v] = $ord[$v] = $now_ord++;\n            $visited->push($v);\n            for($i=$this->start[$v]; $i < $this->start[$v +1]; $i++) {\n                $to = $this->elist[$i];\n                if ($ord[$to] === -1) {\n                    $dfs($to);\n                    $low[$v] = min($low[$v], $low[$to]);\n                } else {\n                    $low[$v] = min($low[$v], $ord[$to]);\n                }\n            }\n            if($low[$v] === $ord[$v]){\n                while(true){\n                    $u = $visited->pop();\n                    $ord[$u] = $this->n;\n                    $ids[$u] = $group_num;\n                    if($u === $v){\n                        break;\n                    }\n                }\n                $group_num++;\n            }\n        };\n        for($i=0;$i<$this->n; $i++){\n            if($ord[$i] === -1){\n                $dfs($i);\n            }\n        }\n        foreach($ids as &$x){\n            $x = $group_num - 1 - $x;\n        }\n        return [$group_num, $ids];\n\n    }\n\n    /**\n     * 以下の条件を満たすような「頂点のリスト」のリストを返します。\n     * ・全ての頂点がちょうど1つずつ、どれかのリストに含まれます。\n     * ・内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。\n     * ・リストはトポロジカルソートされています。異なる強連結成分の頂点 u, vu,v について、uu から vv に到達できる時、uu の属するリストは vv の属するリストよりも前です。\n     * 計算量　追加した辺の本数をmとして\n     * O(n+m)\n     * @return array\n     */\n    public function scc():array\n    {\n        $ids = $this->scc_ids();\n        $group_num = $ids[0];\n        $counts =  array_fill(0,$group_num, 0);\n        $groups = array_fill(0,$group_num, []);;\n        foreach($ids[1] as $x){\n            $counts[$x]++;\n        }\n        for($i=0;$i<$this->n;$i++){\n            $groups[$ids[1][$i]][] = $i;\n        }\n        return $groups;\n    }\n}\n\n\n[$N, $D] = fscanf(STDIN, \"%d%d\");\n$X=$Y=[];\nfor($i=0; $i< $N; $i++){\n    [$X[$i], $Y[$i]] = fscanf(STDIN, \"%d%d\");\n}\n\n$ts = new TwoSat($N);\n\nfor($i=0; $i < $N; $i++){\n    for($j= $i + 1; $j < $N; $j++){\n        if(abs($X[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, false, $j, false);\n        }\n        if(abs($X[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, false, $j, true);\n        }\n\n        if(abs($Y[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, true, $j, false);\n        }\n        if(abs($Y[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, true, $j, true);\n        }\n    }\n}\nif(!$ts->satisfiable()){\n    echo \"No\";\n    exit;\n}\necho \"Yes\". PHP_EOL;\n$ans = $ts->answer();\nfor($i=0;$i<$N;$i++) {\n    if ($ans[$i]) {\n        echo $X[$i] . PHP_EOL;\n    } else {\n        echo $Y[$i] . PHP_EOL;\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n/**\n * Class TwoSat\n * 2-SATを解きます。 変数 x_0, x_1, ･･･, x_{N - 1} に関して、\n * (x_i = f) ∨ (x_j = g)\n * というクローズを足し、これをすべて満たす変数の割当があるかを解きます。\n */\nclass TwoSat\n{\n    private int $n;\n    private array $answer;\n    private object $scc;\n\n    /**\n     * TwoSat constructor.\n     * n変数の2-SATを作ります。\n     * 計算量 O(n)\n     * @param int $n 0 < n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n        $this->answer = array_fill(0, $n,false);\n        $this->scc = new SCC(2 * $n);\n\n    }\n\n    /**\n     * (x_i = f) ∨ (x_j = g) というクローズを足します。\n     * 計算量　ならしO(1)\n     * @param int $i 0 ≤ i < n\n     * @param bool $f\n     * @param int $j 0 ≤ i < n\n     * @param bool $g\n     */\n    public function add_clause(int $i, bool $f, int $j, bool $g): void\n    {\n        assert(0 <= $i && $i < $this->n);\n        assert(0 <= $j && $j < $this->n);\n        $this->scc->add_edge(2 * $i + ($f ? 0: 1), 2 * $j + ($g ? 1 : 0));\n        $this->scc->add_edge(2 * $j + ($g ? 0: 1), 2 * $i + ($f ? 1 : 0));\n\n    }\n\n    /**\n     * 条件を足す割当が存在するかどうかを判定する。割当が存在するならばtrue、そうでないならfalseを返す。\n     * 複数回呼ぶことも可能\n     * 計算量　追加した制約の個数をmとして\n     * O(n+m)\n     * @return bool\n     */\n    public function satisfiable(): bool\n    {\n        $id = $this->scc->scc_ids()[1];\n        for($i=0; $i < $this->n; $i++){\n            if($id[2 * $i] === $id[2 * $i + 1]){\n                return false;\n            }\n            $this->answer[$i] = $id[2 * $i] < $id[2 * $i + 1];\n        }\n        return true;\n    }\n\n    /**\n     * 最後に呼んだ satisfiable の、クローズを満たす割当を返す。\n     * satisfiable を呼ぶ前や、 satisfiableで割当が存在しなかったときにこの関数を呼ぶと、中身が未定義の長さ n の vectorを返す。\n     * 計算量 O(n)\n     * @return array\n     */\n    public function  answer():array\n    {\n        return $this->answer;\n    }\n}\n\n\n/**\n * Class SCC\n * 有向グラフを強連結成分分解します。\n * TwoSatでも使用しているため、書き換える際は注意。\n * ref. AtCoder Library\n */\nclass SCC\n{\n\n    private int $n;\n    private array $edges;\n    private array $start;\n    private array $elist;\n\n    /**\n     * MaxFlow constructor.\n     * n 頂点 0 辺の有向グラフを作る。\n     * 計算量 O(n)\n     * @param int $n 0 ≤ n ≤ 10^8\n     */\n    function __construct(int $n)\n    {\n        $this->n = $n;\n    }\n\n    /**\n     * 頂点fromから頂点toへ有向辺を足す。\n     * 計算量 ならしO(1)\n     * @param int $from 0 ≤ from < n\n     * @param int $to 0 ≤ to < n\n     */\n    public function add_edge(int $from, int $to): void\n    {\n        assert(0 <= $from && $from < $this->n);\n        assert(0 <= $to && $to < $this->n);\n        $this->edges[] = [$from, $to];\n    }\n\n    public function csr(): void\n    {\n        $this->start = $this->elist =  array_fill(0, $this->n+1, 0);\n        foreach($this->edges as $e){\n            $this->start[$e[0] + 1]++;\n        }\n        for($i=1; $i<=$this->n; $i++){\n            $this->start[$i] += $this->start[$i-1];\n        }\n        $counter = $this->start;\n        foreach($this->edges as $e){\n            $this->elist[$counter[$e[0]]++] = $e[1];\n        }\n    }\n\n    public function scc_ids(): array\n    {\n        $this->csr();\n        $now_ord = $group_num = 0;\n        $visited = new SplDoublyLinkedList();\n        $visited->setIteratorMode(SplDoublyLinkedList::IT_MODE_DELETE | SplDoublyLinkedList::IT_MODE_LIFO);\n        $low = $ids = array_fill(0, $this->n, 0);\n        $ord = array_fill(0, $this->n, -1);\n        $dfs = function($v) use(&$now_ord, &$visited, &$ord, &$low, &$dfs, &$ids, &$group_num){\n            $low[$v] = $ord[$v] = $now_ord++;\n            $visited->push($v);\n            for($i=$this->start[$v]; $i < $this->start[$v +1]; $i++) {\n                $to = $this->elist[$i];\n                if ($ord[$to] === -1) {\n                    $dfs($to);\n                    $low[$v] = min($low[$v], $low[$to]);\n                } else {\n                    $low[$v] = min($low[$v], $ord[$to]);\n                }\n            }\n            if($low[$v] === $ord[$v]){\n                while(true){\n                    $u = $visited->pop();\n                    $ord[$u] = $this->n;\n                    $ids[$u] = $group_num;\n                    if($u === $v){\n                        break;\n                    }\n                }\n                $group_num++;\n            }\n        };\n        for($i=0;$i<$this->n; $i++){\n            if($ord[$i] === -1){\n                $dfs($i);\n            }\n        }\n        foreach($ids as &$x){\n            $x = $group_num - 1 - $x;\n        }\n        return [$group_num, $ids];\n\n    }\n\n    /**\n     * 以下の条件を満たすような「頂点のリスト」のリストを返します。\n     * ・全ての頂点がちょうど1つずつ、どれかのリストに含まれます。\n     * ・内側のリストと強連結成分が一対一に対応します。リスト内での頂点の順序は未定義です。\n     * ・リストはトポロジカルソートされています。異なる強連結成分の頂点 u, vu,v について、uu から vv に到達できる時、uu の属するリストは vv の属するリストよりも前です。\n     * 計算量　追加した辺の本数をmとして\n     * O(n+m)\n     * @return array\n     */\n    public function scc():array\n    {\n        $ids = $this->scc_ids();\n        $group_num = $ids[0];\n        $counts =  array_fill(0,$group_num, 0);\n        $groups = array_fill(0,$group_num, []);;\n        foreach($ids[1] as $x){\n            $counts[$x]++;\n        }\n        for($i=0;$i<$this->n;$i++){\n            $groups[$ids[1][$i]][] = $i;\n        }\n        return $groups;\n    }\n}\n\n\n[$N, $D] = fscanf(STDIN, \"%d%d\");\n$X=$Y=[];\nfor($i=0; $i< $N; $i++){\n    [$X[$i], $Y[$i]] = fscanf(STDIN, \"%d%d\");\n}\n\n$ts = new TwoSat($N);\n\nfor($i=0; $i < $N; $i++){\n    for($j= $i + 1; $j < $N; $j++){\n        if(abs($X[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, false, $j, false);\n        }\n        if(abs($X[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, false, $j, true);\n        }\n\n        if(abs($Y[$i] - $X[$j]) < $D){\n            $ts->add_clause($i, true, $j, false);\n        }\n        if(abs($Y[$i] - $Y[$j]) < $D){\n            $ts->add_clause($i, true, $j, true);\n        }\n    }\n}\nif(!$ts->satisfiable()){\n    echo \"No\";\n    exit;\n}\necho \"Yes\". PHP_EOL;\n$ans = $ts->answer();\nfor($i=0;$i<$N;$i++) {\n    if ($ans[$i]) {\n        echo $X[$i] . PHP_EOL;\n    } else {\n        echo $Y[$i] . PHP_EOL;\n    }\n}"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\npackage Scc;\nsub new{\n\treturn bless[map[],1..$_[1]],$_[0];\n}\nsub add_edge{\n\tmy$self=shift;\n\tpush@{$self->[$_[0]]},$_[1];\n}\nsub scc_ids{\n\tmy$self=shift;\n\tmy$now_ord=0;\n\tmy$group_num=0;\n\tmy@low;\n\tmy@ord=(-1)x@{$self};\n\tmy@ids;\n\tmy@visited;\n\tmy$dfs;\n\t$dfs=sub{\n\t\tmy$v=shift;\n\t\t$low[$v]=$ord[$v]=$now_ord++;\n\t\tpush@visited,$v;\n\t\tfor my$to(@{$self->[$v]}){\n\t\t\tif($ord[$to]==-1){\n\t\t\t\t$dfs->($to);\n\t\t\t\t$low[$v]=$low[$to]if$low[$v]>$low[$to];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$low[$v]=$ord[$to]if$low[$v]>$ord[$to];\n\t\t\t}\n\t\t}\n\t\tif($low[$v]==$ord[$v]){\n\t\t\tmy$u=-1;\n\t\t\twhile($u!=$v){\n\t\t\t\t$u=pop@visited;\n\t\t\t\t$ord[$u]=@{$self};\n\t\t\t\t$ids[$u]=$group_num;\n\t\t\t}\n\t\t\t$group_num++;\n\t\t}\n\t};\n\tfor(0..$#ord){\n\t\t$dfs->($_)if$ord[$_]==-1;\n\t}\n\t$_=$group_num-1-$_ for@ids;\n\treturn($group_num,\\@ids);\n}\nsub scc{\n\tmy$self=shift;\n\tmy($group_num,$ids)=$self->scc_ids();\n\tmy@groups=map[],1..$group_num;\n\tfor(0..$#{$ids}){\n\t\tpush@{$groups[$ids->[$_]]},$_;\n\t}\n\treturn\\@groups;\n}\npackage TwoSat;\n@TwoSat::ISA=qw(Scc);\nsub new{\n\treturn$_[0]->SUPER::new($_[1]*2);\n}\nsub add_clause{\n\tmy$self=shift;\n\t$self->add_edge(2*$_[0]+!$_[1],2*$_[2]+!!$_[3]);\n\t$self->add_edge(2*$_[2]+!$_[3],2*$_[0]+!!$_[1]);\n}\nsub satisfiable{\n\tmy$self=shift;\n\tmy$ids=($self->scc_ids())[1];\n\tmy@answer;\n\tfor(0..@{$ids}/2-1){\n\t\treturn 0 if$ids->[2*$_]==$ids->[2*$_+1];\n\t\t$answer[$_]=$ids->[2*$_]<$ids->[2*$_+1];\n\t}\n\treturn(1,\\@answer);\n}\npackage main;\nmy($N,$D)=split$\",<>;\nmy$twosat=TwoSat->new($N);\nmy@p;\nfor(1..$N){\n\tmy($x,$y)=split$\",<>;\n\tpush@p,[$x,$y];\n}\nfor my$i(0..$N-1){\n\tfor my$j($i+1..$N-1){\n\t\t$twosat->add_clause($i,1,$j,1)if abs$p[$i][0]-$p[$j][0]<$D;\n\t\t$twosat->add_clause($i,1,$j,0)if abs$p[$i][0]-$p[$j][1]<$D;\n\t\t$twosat->add_clause($i,0,$j,1)if abs$p[$i][1]-$p[$j][0]<$D;\n\t\t$twosat->add_clause($i,0,$j,0)if abs$p[$i][1]-$p[$j][1]<$D;\n\t}\n}\nmy($isok,$answer)=$twosat->satisfiable();\nif($isok){\n\tprint\"Yes\",$/;\n\tfor(0..$N-1){\n\t\tprint$p[$_][$answer->[$_]],$/;\n\t}\n}\nelse{\n\tprint\"No\",$/;\n}\n"
  },
  {
    "language": "Perl",
    "code": "use strict;\nuse warnings;\npackage Scc;\nsub new{\n\treturn bless[map[],1..$_[1]],$_[0];\n}\nsub add_edge{\n\tmy$self=shift;\n\tpush@{$self->[$_[0]]},$_[1];\n}\nsub scc_ids{\n\tmy$self=shift;\n\tmy$now_ord=0;\n\tmy$group_num=0;\n\tmy@low;\n\tmy@ord=(-1)x@{$self};\n\tmy@ids;\n\tmy@visited;\n\tmy$dfs;\n\t$dfs=sub{\n\t\tmy$v=shift;\n\t\t$low[$v]=$ord[$v]=$now_ord++;\n\t\tpush@visited,$v;\n\t\tfor my$to(@{$self->[$v]}){\n\t\t\tif($ord[$to]==-1){\n\t\t\t\t$dfs->($to);\n\t\t\t\t$low[$v]=$low[$to]if$low[$v]>$low[$to];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$low[$v]=$ord[$to]if$low[$v]>$ord[$to];\n\t\t\t}\n\t\t}\n\t\tif($low[$v]==$ord[$v]){\n\t\t\tmy$u=-1;\n\t\t\twhile($u!=$v){\n\t\t\t\t$u=pop@visited;\n\t\t\t\t$ord[$u]=@{$self};\n\t\t\t\t$ids[$u]=$group_num;\n\t\t\t}\n\t\t\t$group_num++;\n\t\t}\n\t};\n\tfor(0..$#ord){\n\t\t$dfs->($_)if$ord[$_]==-1;\n\t}\n\t$_=$group_num-1-$_ for@ids;\n\treturn($group_num,\\@ids);\n}\nsub scc{\n\tmy$self=shift;\n\tmy($group_num,$ids)=$self->scc_ids();\n\tmy@groups=map[],1..$group_num;\n\tfor(0..$#{$ids}){\n\t\tpush@{$groups[$ids->[$_]]},$_;\n\t}\n\treturn\\@groups;\n}\npackage TwoSat;\npush @TwoSat::ISA,qw(Scc);\nsub new{\n\treturn$_[0]->SUPER::new($_[1]*2);\n}\nsub add_clause{\n\tmy$self=shift;\n\t$self->add_edge(2*$_[0]+!$_[1],2*$_[2]+!!$_[3]);\n\t$self->add_edge(2*$_[2]+!$_[3],2*$_[0]+!!$_[1]);\n}\nsub satisfiable{\n\tmy$self=shift;\n\tmy$ids=($self->scc_ids())[1];\n\tmy@answer;\n\tfor(0..@{$ids}/2-1){\n\t\treturn 0 if$ids->[2*$_]==$ids->[2*$_+1];\n\t\t$answer[$_]=$ids->[2*$_]<$ids->[2*$_+1];\n\t}\n\treturn(1,\\@answer);\n}\npackage main;\nmy($N,$D)=split$\",<>;\nmy$twosat=TwoSat->new($N);\nmy@p;\nfor(1..$N){\n\tmy($x,$y)=split$\",<>;\n\tpush@p,[$x,$y];\n}\nfor my$i(0..$N-1){\n\tfor my$j($i+1..$N-1){\n\t\t$twosat->add_clause($i,1,$j,1)if abs$p[$i][0]-$p[$j][0]<$D;\n\t\t$twosat->add_clause($i,1,$j,0)if abs$p[$i][0]-$p[$j][1]<$D;\n\t\t$twosat->add_clause($i,0,$j,1)if abs$p[$i][1]-$p[$j][0]<$D;\n\t\t$twosat->add_clause($i,0,$j,0)if abs$p[$i][1]-$p[$j][1]<$D;\n\t}\n}\nmy($isok,$answer)=$twosat->satisfiable();\nif($isok){\n\tprint\"Yes\",$/;\n\tfor(0..$N-1){\n\t\tprint$p[$_][$answer->[$_]],$/;\n\t}\n}\nelse{\n\tprint\"No\",$/;\n}\n"
  },
  {
    "language": "D",
    "code": "// dfmt off\nT lread(T=long)(){return readln.chomp.to!T;}T[] lreads(T=long)(long n){return iota(n).map!((_)=>lread!T).array;}\nT[] aryread(T=long)(){return readln.split.to!(T[]);}void arywrite(T)(T a){a.map!text.join(' ').writeln;}\nvoid scan(L...)(ref L A){auto l=readln.split;foreach(i,T;L){A[i]=l[i].to!T;}}alias sread=()=>readln.chomp();\nvoid dprint(L...)(lazy L A){debug{auto l=new string[](L.length);static foreach(i,a;A)l[i]=a.text;arywrite(l);}}\nstatic immutable MOD=10^^9+7;alias PQueue(T,alias l=\"b<a\")=BinaryHeap!(Array!T,l);import std, core.bitop;\n// dfmt on\n\nvoid main()\n{\n    int N, D;\n    scan(N, D);\n    auto ts = TwoSat(N);\n    auto x = new int[](N);\n    auto y = new int[](N);\n    foreach (i; 0 .. N)\n    {\n        scan(x[i], y[i]);\n    }\n    foreach (i; 0 .. N)\n        foreach (j; i + 1 .. N)\n        {\n            if (abs(x[i] - x[j]) < D)\n                ts.addClause(i, false, j, false);\n            if (abs(x[i] - y[j]) < D)\n                ts.addClause(i, false, j, true);\n            if (abs(y[i] - x[j]) < D)\n                ts.addClause(i, true, j, false);\n            if (abs(y[i] - y[j]) < D)\n                ts.addClause(i, true, j, true);\n        }\n    if (!ts.satisfiable())\n    {\n        writeln(\"No\");\n        return;\n    }\n    writeln(\"Yes\");\n    auto answer = ts.answer();\n    foreach (i; 0 .. N)\n    {\n        writeln(answer[i] ? x[i] : y[i]);\n    }\n\n}\n\nstruct CompressedSparseRow(E)\n{\n    import std.typecons : Tuple;\n\n    int[] start;\n    E[] elist;\n    this(int n, const ref Tuple!(int, E)[] edges)\n    {\n        start = new typeof(start)(n + 1);\n        elist = new typeof(elist)(edges.length);\n        foreach (e; edges)\n            start[e[0] + 1]++;\n        foreach (i; 0 .. n)\n            start[i + 1] += start[i];\n        auto counter = start.dup;\n        foreach (e; edges)\n            elist[counter[e[0]]++] = e[1];\n    }\n}\n\nstruct SccGraphImpl\n{\n    import std.typecons : Tuple;\n    import std.algorithm : min;\n\npublic:\n    this(int n)\n    {\n        _n = n;\n    }\n\n    int numVerticles()\n    {\n        return _n;\n    }\n\n    void addEdge(int from, int to)\n    {\n        edges ~= Tuple!(int, edge)(from, edge(to));\n    }\n\n    Tuple!(int, int[]) sccIds()\n    {\n        auto g = CompressedSparseRow!(edge)(_n, edges);\n        int now_ord = 0, group_num = 0;\n        int[] visited;\n        auto low = new int[](_n);\n        auto ord = new int[](_n);\n        ord[] = -1;\n        auto ids = new int[](_n);\n        visited.reserve(_n);\n        void dfs(int v)\n        {\n            low[v] = ord[v] = now_ord++;\n            visited ~= v;\n            foreach (i; g.start[v] .. g.start[v + 1])\n            {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = min(low[v], low[to]);\n                }\n                else\n                {\n                    low[v] = min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    int u = visited[$ - 1];\n                    visited.length--;\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v)\n                        break;\n                }\n                group_num++;\n            }\n        }\n\n        foreach (i; 0 .. _n)\n            if (ord[i] == -1)\n                dfs(i);\n        foreach (ref x; ids)\n            x = group_num - 1 - x;\n        return Tuple!(int, int[])(group_num, ids);\n    }\n\n    int[][] scc()\n    {\n        auto ids = sccIds();\n        int group_num = ids[0];\n        auto counts = new int[](group_num);\n        foreach (x; ids[1])\n            counts[x]++;\n        auto groups = new int[][](ids[0]);\n        foreach (i; 0 .. group_num)\n            groups[i].reserve(counts[i]);\n        foreach (i; 0 .. _n)\n            groups[ids[1][i]] ~= i;\n        return groups;\n    }\n\nprivate:\n    int _n;\n    struct edge\n    {\n        int to;\n    }\n\n    Tuple!(int, edge)[] edges;\n}\n\nstruct TwoSat\n{\npublic:\n    this(int n)\n    {\n        _n = n;\n        _answer = new bool[](n);\n        scc = SccGraphImpl(2 * n + 2);\n    }\n\n    void addClause(int i, bool f, int j, bool g)\n    {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.addEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.addEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n\n    bool satisfiable()\n    {\n        auto id = scc.sccIds()[1];\n        foreach (i; 0 .. _n)\n        {\n            if (id[2 * i] == id[2 * i + 1])\n                return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n\n    bool[] answer()\n    {\n        return _answer;\n    }\n\nprivate:\n    int _n;\n    bool[] _answer;\n    SccGraphImpl scc;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric, std.container, std.range;\n\nstruct CompressedSparseRow(E)\n{\n    import std.typecons : Tuple;\n\n    int[] start;\n    E[] elist;\n    this(int n, const ref Tuple!(int, E)[] edges)\n    {\n        start = new typeof(start)(n + 1);\n        elist = new typeof(elist)(edges.length);\n        foreach (e; edges)\n            start[e[0] + 1]++;\n        foreach (i; 0 .. n)\n            start[i + 1] += start[i];\n        auto counter = start.dup;\n        foreach (e; edges)\n            elist[counter[e[0]]++] = e[1];\n    }\n}\n\nstruct SccGraphImpl\n{\n    import std.typecons : Tuple;\n    import std.algorithm : min;\n\npublic:\n    this(int n)\n    {\n        _n = n;\n    }\n\n    int numVerticles()\n    {\n        return _n;\n    }\n\n    void addEdge(int from, int to)\n    {\n        edges ~= Tuple!(int, edge)(from, edge(to));\n    }\n\n    Tuple!(int, int[]) sccIds()\n    {\n        auto g = CompressedSparseRow!(edge)(_n, edges);\n        int now_ord = 0, group_num = 0;\n        int[] visited;\n        auto low = new int[](_n);\n        auto ord = new int[](_n);\n        ord[] = -1;\n        auto ids = new int[](_n);\n        visited.reserve(_n);\n        void dfs(int v)\n        {\n            low[v] = ord[v] = now_ord++;\n            visited ~= v;\n            foreach (i; g.start[v] .. g.start[v + 1])\n            {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = min(low[v], low[to]);\n                }\n                else\n                {\n                    low[v] = min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    int u = visited[$ - 1];\n                    visited.length--;\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v)\n                        break;\n                }\n                group_num++;\n            }\n        }\n\n        foreach (i; 0 .. _n)\n            if (ord[i] == -1)\n                dfs(i);\n        foreach (ref x; ids)\n            x = group_num - 1 - x;\n        return Tuple!(int, int[])(group_num, ids);\n    }\n\n    int[][] scc()\n    {\n        auto ids = sccIds();\n        int group_num = ids[0];\n        auto counts = new int[](group_num);\n        foreach (x; ids[1])\n            counts[x]++;\n        auto groups = new int[][](ids[0]);\n        foreach (i; 0 .. group_num)\n            groups[i].reserve(counts[i]);\n        foreach (i; 0 .. _n)\n            groups[ids[1][i]] ~= i;\n        return groups;\n    }\n\nprivate:\n    int _n;\n    struct edge\n    {\n        int to;\n    }\n\n    Tuple!(int, edge)[] edges;\n}\n\nstruct TwoSat\n{\npublic:\n    this(int n)\n    {\n        _n = n;\n        _answer = new bool[](n);\n        scc = SccGraphImpl(2 * n + 2);\n    }\n\n    void addClause(int i, bool f, int j, bool g)\n    {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.addEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.addEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n\n    bool satisfiable()\n    {\n        auto id = scc.sccIds()[1];\n        foreach (i; 0 .. _n)\n        {\n            if (id[2 * i] == id[2 * i + 1])\n                return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n\n    bool[] answer()\n    {\n        return _answer;\n    }\n\nprivate:\n    int _n;\n    bool[] _answer;\n    SccGraphImpl scc;\n}\n\nvoid main()\n{\n    auto nd = readln.split.to!(int[]);\n    auto N = nd[0];\n    auto D = nd[1];\n\n    auto sat = TwoSat(N*2);\n\n    int[] xs, ys;\n    foreach (i; 0..N) {\n        auto xy = readln.split.to!(int[]);\n        auto x = xy[0];\n        auto y = xy[1];\n        xs ~= x;\n        ys ~= y;\n\n        sat.addClause(i, true, N+i, true);\n    }\n\n    foreach (i; 0..N) foreach (j; 0..N) if (i != j) {\n        if (abs(xs[i] - xs[j]) < D) sat.addClause(i, false, j, false);\n        if (abs(xs[i] - ys[j]) < D) sat.addClause(i, false, N+j, false);\n        if (abs(ys[i] - xs[j]) < D) sat.addClause(N+i, false, j, false);\n        if (abs(ys[i] - ys[j]) < D) sat.addClause(N+i, false, N+j, false);\n    }\n\n    if (sat.satisfiable()) {\n        writeln(\"Yes\");\n        auto res = new int[](N);\n        foreach (i, a; sat.answer()) if (a) {\n            if (i < N) {\n                res[i] = xs[i];\n            } else {\n                res[i-N] = ys[i-N];\n            }\n        }\n        res.each!writeln;\n    } else {\n        writeln(\"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport std.regex;\nimport core.bitop : popcnt;\n\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max / 5;\n\nvoid main() {\n  long N, D;\n  scanln(N, D);\n  long[2][] xss = new long[2][N];\n  foreach (i; 0 .. N) {\n    scanln(xss[i][0], xss[i][1]);\n  }\n\n  bool f(long i, long x) {\n    return xss[i][1] == x;\n  }\n\n  auto sat = TwoSat(N);\n  foreach (i; 0 .. N) {\n    foreach (j; i + 1 .. N) {\n      long[2][] pairs;\n      foreach (x; xss[i]) {\n        foreach (y; xss[j]) {\n          if (abs(y - x) >= D) {\n            pairs ~= [x, y];\n          }\n        }\n      }\n      if (pairs.length == 4) {\n        // ok\n      } else if (pairs.length == 3) {\n        long x = xss[i][2 - pairs.count!(p => p[0] == xss[i][0])];\n        long y = xss[j][2 - pairs.count!(p => p[1] == xss[j][0])];\n        sat.addClause(i, f(i, x), j, f(j, y));\n      } else if (pairs.length == 2) {\n        if (pairs[0][0] == pairs[1][0]) {\n          sat.addClause(i, f(i, pairs[0][0]), i, f(i, pairs[1][0]));\n        } else if (pairs[0][1] == pairs[1][1]) {\n          sat.addClause(j, f(j, pairs[0][1]), j, f(j, pairs[1][1]));\n        } else {\n          sat.addClause(i, false, j, false);\n          sat.addClause(i, true, j, true);\n        }\n      } else if (pairs.length == 1) {\n        sat.addClause(i, f(i, pairs[0][0]), i, f(i, pairs[0][0]));\n        sat.addClause(j, f(j, pairs[0][1]), j, f(j, pairs[0][1]));\n      } else {\n        sat.addClause(i, true, i, true);\n        sat.addClause(i, false, i, false);\n      }\n    }\n  }\n\n  if (!sat.satisfiable) {\n    writeln(\"No\");\n  } else {\n    writeln(\"Yes\");\n    auto bs = sat.answer;\n    foreach (i, b; bs) {\n      xss[i][b].writeln;\n    }\n  }\n}\n\nstatic struct InternalArray {\n\n  // Array\n  //   - Dynamic array in D is slow.\n  //   - ac-library does not contain this.\n  struct Array(T) {\n    import std.algorithm : min, max;\n    import std.conv : to;\n    import std.format : format;\n\n  private:\n    T[] data = [];\n    size_t size = 0;\n\n    // [beginIndex, endIndex)\n    size_t beginIndex = 0;\n    size_t endIndex = 0;\n\n  public:\n\n    this(T[] data) {\n      this(data, data.length, 0, data.length, false);\n    }\n\n    bool empty() @property {\n      return beginIndex == endIndex;\n    }\n\n    size_t length() @property {\n      return endIndex - beginIndex;\n    }\n\n    void clear() {\n      beginIndex = endIndex = 0;\n      data = [];\n      size = 0;\n    }\n\n    ref T front() @property\n    in {\n      assert(!empty, \"Attempting to get the front of an empty Array\");\n    }\n    body {\n      return this[0];\n    }\n\n    ref T front(T value) @property\n    in {\n      assert(!empty, \"Attempting to assign to the front of an empty Array\");\n    }\n    body {\n      return this[0] = value;\n    }\n\n    ref T back() @property\n    in {\n      assert(!empty, \"Attempting to get the back of an empty Array\");\n    }\n    body {\n      return this[$ - 1];\n    }\n\n    ref T back(T value) @property\n    in {\n      assert(!empty, \"Attempting to assign to the back of an empty Array\");\n    }\n    body {\n      return this[$ - 1] = value;\n    }\n\n    void insertBack(T value) {\n      if (size >= data.length) {\n        resize();\n      }\n      data[size++] = value;\n      endIndex++;\n    }\n\n    void removeFront()\n    in {\n      assert(!empty, \"Attempting to remove the front of an empty Array\");\n    }\n    body {\n      beginIndex++;\n    }\n\n    alias popFront = removeFront;\n\n    void removeBack()\n    in {\n      assert(!empty, \"Attempting to remove the back of an empty Array\");\n    }\n    body {\n      size--;\n      endIndex--;\n    }\n\n    alias popBack = removeBack;\n\n    typeof(this) save() @property {\n      return typeof(this)(data, size, beginIndex, endIndex, true);\n    }\n\n    alias dup = save;\n\n    // xs ~= value\n    typeof(this) opOpAssign(string op)(T value) if (op == \"~\") {\n      this.insertBack(value);\n      return this;\n    }\n\n    // xs[index]\n    ref T opIndex(size_t index)\n    in {\n      assert(0 <= index && index < length, \"Access violation\");\n    }\n    body {\n      size_t _index = beginIndex + index;\n      return data[_index];\n    }\n\n    // xs[indices[0] .. indices[1]]\n    typeof(this) opIndex(size_t[2] indices)\n    in {\n      assert(0 <= indices[0] && indices[1] <= length, \"Access violation\");\n    }\n    body {\n      size_t newBeginIndex = beginIndex + indices[0];\n      size_t newEndIndex = beginIndex + indices[1];\n      size_t size = newEndIndex;\n      return typeof(this)(data, size, newBeginIndex, newEndIndex, false);\n    }\n\n    // xs[]\n    typeof(this) opIndex() {\n      return this;\n    }\n\n    // xs[index] = value\n    ref T opIndexAssign(T value, size_t index)\n    in {\n      assert(0 <= index && index < length, \"Access violation\");\n    }\n    body {\n      size_t _index = index - beginIndex;\n      return data[_index] = value;\n    }\n\n    // xs[indices[0] .. indices[1]] = value\n    typeof(this) opIndexAssign(T value, size_t[2] indices)\n    in {\n      assert(0 <= indices[0] && indices[1] <= length, \"Access violation\");\n    }\n    body {\n      size_t _beginIndex = beginIndex + indices[0];\n      size_t _endIndex = beginIndex + indices[1];\n      data[_beginIndex .. _endIndex] = value;\n      return this;\n    }\n\n    // xs[] = value\n    typeof(this) opIndexAssign(T value) {\n      data[0 .. size] = value;\n      return this;\n    }\n\n    // xs[indices[0] .. indices[1]] op= value\n    typeof(this) opIndexOpAssign(string op)(T value, size_t[2] indices)\n    in {\n      assert(0 <= indices[0] && indices[1] <= length, \"Access violation\");\n    }\n    body {\n      size_t _beginIndex = beginIndex + indices[0];\n      size_t _endIndex = beginIndex + indices[1];\n      mixin(q{\n      data[_beginIndex.._endIndex] %s= value;\n    }.format(op));\n      return this;\n    }\n\n    // xs[] op= value\n    typeof(this) opIndexOpAssign(string op)(T value) {\n      mixin(q{\n      data[0..size] %s= value;\n    }.format(op));\n      return this;\n    }\n\n    // $\n    size_t opDollar(size_t dim : 0)() {\n      return length;\n    }\n\n    // i..j\n    size_t[2] opSlice(size_t dim : 0)(size_t i, size_t j)\n    in {\n      assert(0 <= i && j <= length, \"Access violation\");\n    }\n    body {\n      return [i, j];\n    }\n\n    bool opEquals(S : T)(Array!S that) {\n      if (this.length != that.length)\n        return false;\n      foreach (i; 0 .. this.length) {\n        if (this[i] != that[i])\n          return false;\n      }\n      return true;\n    }\n\n    bool opEquals(S : T)(S[] that) {\n      if (this.length != that.length)\n        return false;\n      foreach (i; 0 .. this.length) {\n        if (this[i] != that[i])\n          return false;\n      }\n      return true;\n    }\n\n    string toString() const {\n      auto xs = data[beginIndex .. endIndex];\n      return \"Array(%s)\".format(xs);\n    }\n\n    void reserve(size_t size) {\n      data.length = max(data.length, size);\n    }\n\n  private:\n    this(T[] data, size_t size, size_t beginIndex, ptrdiff_t endIndex, bool shouldDuplicate) {\n      this.size = size;\n      this.data = shouldDuplicate ? data.dup : data[0 .. min(endIndex, $)];\n      this.beginIndex = beginIndex;\n      this.endIndex = endIndex;\n    }\n\n    void resize() {\n      data.length = max(size * 2, 1);\n    }\n\n    invariant {\n      assert(size <= data.length);\n      assert(beginIndex <= endIndex);\n      assert(endIndex == size);\n    }\n  }\n\n  @safe pure unittest {\n    // Array should be Range\n    import std.range;\n\n    assert(isInputRange!(Array!long));\n    // assert(isOutputRange!(Array!long, int));\n    // assert(isOutputRange!(Array!long, long));\n    assert(isForwardRange!(Array!long));\n    assert(isBidirectionalRange!(Array!long));\n    assert(isRandomAccessRange!(Array!long));\n  }\n\n  @safe pure unittest {\n    // test basic operations\n\n    Array!long xs = [1, 2, 3]; // == Array!long([1, 2, 3])\n    assert(xs.length == 3);\n    assert(xs.front == 1 && xs.back == 3);\n    assert(xs[0] == 1 && xs[1] == 2 && xs[2] == 3);\n    assert(xs == [1, 2, 3]);\n\n    size_t i = 0;\n    foreach (x; xs) {\n      assert(x == ++i);\n    }\n\n    xs.front = 4;\n    xs[1] = 5;\n    xs.back = 6;\n    assert(xs == [4, 5, 6]);\n\n    xs.removeBack;\n    xs.removeBack;\n    assert(xs == [4]);\n    xs.insertBack(5);\n    xs ~= 6;\n    assert(xs == [4, 5, 6]);\n    xs.removeFront;\n    assert(xs == [5, 6]);\n\n    xs.clear;\n    assert(xs.empty);\n    xs.insertBack(1);\n    assert(!xs.empty);\n    assert(xs == [1]);\n    xs[0]++;\n    assert(xs == [2]);\n  }\n\n  @safe pure unittest {\n    // test slicing operations\n\n    Array!long xs = [1, 2, 3];\n    assert(xs[] == [1, 2, 3]);\n    assert((xs[0 .. 2] = 0) == [0, 0, 3]);\n    assert((xs[0 .. 2] += 1) == [1, 1, 3]);\n    assert((xs[] -= 2) == [-1, -1, 1]);\n\n    Array!long ys = xs[0 .. 2];\n    assert(ys == [-1, -1]);\n    ys[0] = 5;\n    assert(ys == [5, -1]);\n    assert(xs == [5, -1, 1]);\n  }\n\n  @safe pure unittest {\n    // test using phobos\n    import std.algorithm, std.array;\n\n    Array!long xs = [10, 5, 8, 3];\n    assert(sort!\"a<b\"(xs).equal([3, 5, 8, 10]));\n    assert(xs == [3, 5, 8, 10]);\n    Array!long ys = sort!\"a>b\"(xs).array;\n    assert(ys == [10, 8, 5, 3]);\n  }\n\n  @safe pure unittest {\n    // test different types of equality\n\n    int[] xs = [1, 2, 3];\n    Array!int ys = [1, 2, 3];\n    Array!long zs = [1, 2, 3];\n    assert(xs == ys);\n    assert(xs == zs);\n    assert(ys == zs);\n\n    ys.removeBack;\n    assert(ys != zs);\n    ys.insertBack(3);\n    assert(ys == zs);\n  }\n}\n\nstatic struct InternalScc {\n\n  // Strongly Connected Components\n  // Reference:\n  //   R. Tarjan,\n  //   Depth-First Search and Linear Graph Algorithms\n  struct SccGraph {\n    import std.range : back, popBack;\n    import std.algorithm : min;\n    import std.typecons : Tuple, tuple;\n\n  private:\n    long _n;\n    Tuple!(long, Edge)[] edges;\n\n  public:\n    this(long n) {\n      _n = n;\n    }\n\n    long numVertices() {\n      return _n;\n    }\n\n    void addEdge(long fromV, long toV)\n    in (0 <= fromV && fromV < _n)\n    in (0 <= toV && toV < _n)\n    body {\n      edges ~= tuple(fromV, Edge(toV));\n    }\n\n    // @return pair of (# of scc, scc id)\n    Tuple!(long, long[]) sccIds() {\n      auto g = Csr!Edge(_n, edges);\n      long nowOrd = 0;\n      long groupNum = 0;\n      InternalArray.Array!long visited;\n      visited.reserve(_n);\n      long[] low = new long[_n];\n      long[] ord = new long[_n];\n      ord[] = -1;\n      long[] ids = new long[_n];\n\n      void dfs(long v) {\n        low[v] = ord[v] = nowOrd++;\n        visited ~= v;\n        foreach (i; g.start[v] .. g.start[v + 1]) {\n          auto toV = g.elist[i].toV;\n          if (ord[toV] == -1) {\n            dfs(toV);\n            low[v] = min(low[v], low[toV]);\n          } else {\n            low[v] = min(low[v], ord[toV]);\n          }\n        }\n        if (low[v] == ord[v]) {\n          while (true) {\n            long u = visited.back;\n            visited.popBack;\n            ord[u] = _n;\n            ids[u] = groupNum;\n            if (u == v)\n              break;\n          }\n          groupNum++;\n        }\n      }\n\n      foreach (i; 0 .. _n) {\n        if (ord[i] == -1) {\n          dfs(i);\n        }\n      }\n      foreach (ref x; ids) {\n        x = groupNum - 1 - x;\n      }\n      return tuple(groupNum, ids);\n    }\n\n    InternalArray.Array!long[] scc() {\n      auto ids = sccIds();\n      long groupNum = ids[0];\n      long[] counts = new long[groupNum];\n      foreach (x; ids[1]) {\n        counts[x]++;\n      }\n      auto groups = new InternalArray.Array!long[groupNum];\n      foreach (i; 0 .. groupNum) {\n        groups[i].reserve(counts[i]);\n      }\n      foreach (i; 0 .. _n) {\n        groups[ids[1][i]] ~= i;\n      }\n      return groups;\n    }\n\n  private:\n    // Compressed Sparse Row\n    struct Csr(E) {\n      long[] start;\n      E[] elist;\n\n      this(long n, Tuple!(long, E)[] edges) {\n        start = new long[n + 1];\n        elist = new E[edges.length];\n        foreach (e; edges) {\n          start[e[0] + 1]++;\n        }\n        foreach (i; 1 .. n + 1) {\n          start[i] += start[i - 1];\n        }\n        auto counter = start.dup;\n        foreach (e; edges) {\n          elist[counter[e[0]]++] = e[1];\n        }\n      }\n    }\n\n    struct Edge {\n      long toV;\n    }\n  }\n\n}\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean Formulas\nstruct TwoSat {\n\nprivate:\n  long _n;\n  bool[] _answer;\n  InternalScc.SccGraph scc;\n\npublic:\n  this(long n) {\n    _n = n;\n    _answer = new bool[n];\n    scc = InternalScc.SccGraph(2 * n);\n  }\n\n  // amortized O(1)\n  void addClause(long i, bool f, long j, bool g)\n  in (0 <= i && i < _n)\n  in (0 <= j && j < _n)\n  body {\n    scc.addEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n    scc.addEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n  }\n\n  // O(n + m)\n  bool satisfiable() {\n    auto id = scc.sccIds()[1];\n    foreach (i; 0 .. _n) {\n      if (id[2 * i] == id[2 * i + 1])\n        return false;\n      _answer[i] = id[2 * i] < id[2 * i + 1];\n    }\n    return true;\n  }\n\n  // O(n)\n  bool[] answer() {\n    return _answer;\n  }\n}\n\n// ----------------------------------------------\n\nvoid times(alias fun)(long n) {\n  // n.iota.each!(i => fun());\n  foreach (i; 0 .. n)\n    fun();\n}\n\nauto rep(alias fun, T = typeof(fun()))(long n) {\n  // return n.iota.map!(i => fun()).array;\n  T[] res = new T[n];\n  foreach (ref e; res)\n    e = fun();\n  return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  // `(x+y-1)/y` will only work for positive numbers ...\n  T t = x / y;\n  if (y > 0 && t * y < x)\n    t++;\n  if (y < 0 && t * y > x)\n    t++;\n  return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  T t = x / y;\n  if (y > 0 && t * y > x)\n    t--;\n  if (y < 0 && t * y < x)\n    t--;\n  return t;\n}\n\nref T ch(alias fun, T, S...)(ref T lhs, S rhs) {\n  return lhs = fun(lhs, rhs);\n}\n\nunittest {\n  long x = 1000;\n  x.ch!min(2000);\n  assert(x == 1000);\n  x.ch!min(3, 2, 1);\n  assert(x == 1);\n  x.ch!max(100).ch!min(1000); // clamp\n  assert(x == 100);\n  x.ch!max(0).ch!min(10); // clamp\n  assert(x == 10);\n}\n\nmixin template Constructor() {\n  import std.traits : FieldNameTuple;\n\n  this(Args...)(Args args) {\n    // static foreach(i, v; args) {\n    foreach (i, v; args) {\n      mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n    }\n  }\n}\n\ntemplate scanln(Args...) {\n  enum sep = \" \";\n\n  enum n = () {\n    long n = 0;\n    foreach (Arg; Args) {\n      static if (is(Arg == class) || is(Arg == struct) || is(Arg == union)) {\n        n += Fields!Arg.length;\n      } else {\n        n++;\n      }\n    }\n    return n;\n  }();\n\n  enum fmt = n.rep!(() => \"%s\").join(sep);\n\n  enum argsString = () {\n    string[] xs = [];\n    foreach (i, Arg; Args) {\n      static if (is(Arg == class) || is(Arg == struct) || is(Arg == union)) {\n        foreach (T; FieldNameTuple!Arg) {\n          xs ~= \"&args[%d].%s\".format(i, T);\n        }\n      } else {\n        xs ~= \"&args[%d]\".format(i);\n      }\n    }\n    return xs.join(\", \");\n  }();\n\n  void scanln(auto ref Args args) {\n    string line = readln.chomp;\n    static if (__VERSION__ >= 2074) {\n      mixin(\n          \"line.formattedRead!fmt(%s);\".format(argsString)\n      );\n    } else {\n      mixin(\n          \"line.formattedRead(fmt, %s);\".format(argsString)\n      );\n    }\n  }\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  template fold(fun...) if (fun.length >= 1) {\n    auto fold(R, S...)(R r, S seed) {\n      static if (S.length < 2) {\n        return reduce!fun(seed, r);\n      } else {\n        return reduce!fun(tuple(seed), r);\n      }\n    }\n  }\n}\n\n// popcnt with ulongs was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  ulong popcnt(ulong x) {\n    x = (x & 0x5555555555555555L) + (x >> 1 & 0x5555555555555555L);\n    x = (x & 0x3333333333333333L) + (x >> 2 & 0x3333333333333333L);\n    x = (x & 0x0f0f0f0f0f0f0f0fL) + (x >> 4 & 0x0f0f0f0f0f0f0f0fL);\n    x = (x & 0x00ff00ff00ff00ffL) + (x >> 8 & 0x00ff00ff00ff00ffL);\n    x = (x & 0x0000ffff0000ffffL) + (x >> 16 & 0x0000ffff0000ffffL);\n    x = (x & 0x00000000ffffffffL) + (x >> 32 & 0x00000000ffffffffL);\n    return x;\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "module acl.twosat;\n\nimport acl.internal_scc;\n\n// --- twosat ---\n\nstruct TwoSat\n{\npublic:\n    this(int n)\n    {\n        _n = n;\n        _answer = new bool[](n);\n        scc = SccGraphImpl(2 * n);\n    }\n\n    void addClause(int i, bool f, int j, bool g)\n    {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n\n    bool satisfiable()\n    {\n        auto id = scc.sccIds()[1];\n        foreach (i; 0 .. _n)\n        {\n            if (id[2 * i] == id[2 * i + 1])\n                return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n\n    bool[] answer()\n    {\n        return _answer;\n    }\n\nprivate:\n    int _n;\n    bool[] _answer;\n    SccGraphImpl scc;\n}\n"
  },
  {
    "language": "D",
    "code": "// dfmt off\nT lread(T=long)(){return readln.chomp.to!T;}T[] lreads(T=long)(long n){return iota(n).map!((_)=>lread!T).array;}\nT[] aryread(T=long)(){return readln.split.to!(T[]);}void arywrite(T)(T a){a.map!text.join(' ').writeln;}\nvoid scan(L...)(ref L A){auto l=readln.split;foreach(i,T;L){A[i]=l[i].to!T;}}alias sread=()=>readln.chomp();\nvoid dprint(L...)(lazy L A){debug{auto l=new string[](L.length);static foreach(i,a;A)l[i]=a.text;arywrite(l);}}\nstatic immutable MOD=10^^9+7;alias PQueue(T,alias l=\"b<a\")=BinaryHeap!(Array!T,l);import std, core.bitop;\n// dfmt on\n\nvoid main()\n{\n    int N, D;\n    scan(N, D);\n    auto ts = TwoSat(N);\n    auto x = new int[](N);\n    auto y = new int[](N);\n    foreach (i; 0 .. D)\n    {\n        scan(x[i], y[i]);\n    }\n    foreach (i; 0 .. N)\n        foreach (j; i + 1 .. N)\n        {\n            if (abs(x[i] - x[j]) < D)\n                ts.addClause(i, false, j, false);\n            if (abs(x[i] - y[j]) < D)\n                ts.addClause(i, false, j, true);\n            if (abs(y[i] - x[j]) < D)\n                ts.addClause(i, true, j, false);\n            if (abs(y[i] - y[j]) < D)\n                ts.addClause(i, true, j, true);\n        }\n    if (!ts.satisfiable())\n    {\n        writeln(\"No\");\n        return;\n    }\n    writeln(\"Yes\");\n    auto answer = ts.answer();\n    foreach (i; 0 .. N)\n    {\n        writeln(answer[i] ? x[i] : y[i]);\n    }\n\n}\n\nstruct CompressedSparseRow(E)\n{\n    import std.typecons : Tuple;\n\n    int[] start;\n    E[] elist;\n    this(int n, const ref Tuple!(int, E)[] edges)\n    {\n        start = new typeof(start)(n + 1);\n        elist = new typeof(elist)(edges.length);\n        foreach (e; edges)\n            start[e[0] + 1]++;\n        foreach (i; 0 .. n)\n            start[i + 1] += start[i];\n        auto counter = start.dup;\n        foreach (e; edges)\n            elist[counter[e[0]]++] = e[1];\n    }\n}\n\nstruct SccGraphImpl\n{\n    import std.typecons : Tuple;\n    import std.algorithm : min;\n\npublic:\n    this(int n)\n    {\n        _n = n;\n    }\n\n    int numVerticles()\n    {\n        return _n;\n    }\n\n    void addEdge(int from, int to)\n    {\n        edges ~= Tuple!(int, edge)(from, edge(to));\n    }\n\n    Tuple!(int, int[]) sccIds()\n    {\n        auto g = CompressedSparseRow!(edge)(_n, edges);\n        int now_ord = 0, group_num = 0;\n        int[] visited;\n        auto low = new int[](_n);\n        auto ord = new int[](_n);\n        ord[] = -1;\n        auto ids = new int[](_n);\n        visited.reserve(_n);\n        void dfs(int v)\n        {\n            low[v] = ord[v] = now_ord++;\n            visited ~= v;\n            foreach (i; g.start[v] .. g.start[v + 1])\n            {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = min(low[v], low[to]);\n                }\n                else\n                {\n                    low[v] = min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    int u = visited[$ - 1];\n                    visited.length--;\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v)\n                        break;\n                }\n                group_num++;\n            }\n        }\n\n        foreach (i; 0 .. _n)\n            if (ord[i] == -1)\n                dfs(i);\n        foreach (ref x; ids)\n            x = group_num - 1 - x;\n        return Tuple!(int, int[])(group_num, ids);\n    }\n\n    int[][] scc()\n    {\n        auto ids = sccIds();\n        int group_num = ids[0];\n        auto counts = new int[](group_num);\n        foreach (x; ids[1])\n            counts[x]++;\n        auto groups = new int[][](ids[0]);\n        foreach (i; 0 .. group_num)\n            groups[i].reserve(counts[i]);\n        foreach (i; 0 .. _n)\n            groups[ids[1][i]] ~= i;\n        return groups;\n    }\n\nprivate:\n    int _n;\n    struct edge\n    {\n        int to;\n    }\n\n    Tuple!(int, edge)[] edges;\n}\n\nstruct TwoSat\n{\npublic:\n    this(int n)\n    {\n        _n = n;\n        _answer = new bool[](n);\n        scc = SccGraphImpl(2 * n);\n    }\n\n    void addClause(int i, bool f, int j, bool g)\n    {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.addEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.addEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n\n    bool satisfiable()\n    {\n        auto id = scc.sccIds()[1];\n        foreach (i; 0 .. _n)\n        {\n            if (id[2 * i] == id[2 * i + 1])\n                return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n\n    bool[] answer()\n    {\n        return _answer;\n    }\n\nprivate:\n    int _n;\n    bool[] _answer;\n    SccGraphImpl scc;\n}\n"
  },
  {
    "language": "D",
    "code": "// dfmt off\nT lread(T=long)(){return readln.chomp.to!T;}T[] lreads(T=long)(long n){return iota(n).map!((_)=>lread!T).array;}\nT[] aryread(T=long)(){return readln.split.to!(T[]);}void arywrite(T)(T a){a.map!text.join(' ').writeln;}\nvoid scan(L...)(ref L A){auto l=readln.split;foreach(i,T;L){A[i]=l[i].to!T;}}alias sread=()=>readln.chomp();\nvoid dprint(L...)(lazy L A){debug{auto l=new string[](L.length);static foreach(i,a;A)l[i]=a.text;arywrite(l);}}\nstatic immutable MOD=10^^9+7;alias PQueue(T,alias l=\"b<a\")=BinaryHeap!(Array!T,l);import std, core.bitop;\n// dfmt on\n\nvoid main()\n{\n    int N, D;\n    scan(N, D);\n    auto ts = TwoSat(N);\n    auto x = new int[](N);\n    auto y = new int[](N);\n    foreach (i; 0 .. D)\n    {\n        scan(x[i], y[i]);\n    }\n    foreach (i; 0 .. N)\n        foreach (j; i + 1 .. N)\n        {\n            if (abs(x[i] - x[j]) < D)\n                ts.addClause(i, false, j, false);\n            if (abs(x[i] - y[j]) < D)\n                ts.addClause(i, false, j, true);\n            if (abs(y[i] - x[j]) < D)\n                ts.addClause(i, true, j, false);\n            if (abs(y[i] - y[j]) < D)\n                ts.addClause(i, true, j, true);\n        }\n    if (!ts.satisfiable())\n    {\n        writeln(\"No\");\n        return;\n    }\n    writeln(\"Yes\");\n    auto answer = ts.answer();\n    foreach (i; 0 .. N)\n    {\n        writeln(answer[i] ? x[i] : y[i]);\n    }\n\n}\n\nstruct CompressedSparseRow(E)\n{\n    import std.typecons : Tuple;\n\n    int[] start;\n    E[] elist;\n    this(int n, const ref Tuple!(int, E)[] edges)\n    {\n        start = new typeof(start)(n + 1);\n        elist = new typeof(elist)(edges.length);\n        foreach (e; edges)\n            start[e[0] + 1]++;\n        foreach (i; 0 .. n)\n            start[i + 1] += start[i];\n        auto counter = start.dup;\n        foreach (e; edges)\n            elist[counter[e[0]]++] = e[1];\n    }\n}\n\nstruct SccGraphImpl\n{\n    import std.typecons : Tuple;\n    import std.algorithm : min;\n\npublic:\n    this(int n)\n    {\n        _n = n;\n    }\n\n    int numVerticles()\n    {\n        return _n;\n    }\n\n    void addEdge(int from, int to)\n    {\n        edges ~= Tuple!(int, edge)(from, edge(to));\n    }\n\n    Tuple!(int, int[]) sccIds()\n    {\n        auto g = CompressedSparseRow!(edge)(_n, edges);\n        int now_ord = 0, group_num = 0;\n        int[] visited;\n        auto low = new int[](_n);\n        auto ord = new int[](_n);\n        ord[] = -1;\n        auto ids = new int[](_n);\n        visited.reserve(_n);\n        void dfs(int v)\n        {\n            low[v] = ord[v] = now_ord++;\n            visited ~= v;\n            foreach (i; g.start[v] .. g.start[v + 1])\n            {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1)\n                {\n                    dfs(to);\n                    low[v] = min(low[v], low[to]);\n                }\n                else\n                {\n                    low[v] = min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v])\n            {\n                while (true)\n                {\n                    int u = visited[$ - 1];\n                    visited.length--;\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v)\n                        break;\n                }\n                group_num++;\n            }\n        }\n\n        foreach (i; 0 .. _n)\n            if (ord[i] == -1)\n                dfs(i);\n        foreach (ref x; ids)\n            x = group_num - 1 - x;\n        return Tuple!(int, int[])(group_num, ids);\n    }\n\n    int[][] scc()\n    {\n        auto ids = sccIds();\n        int group_num = ids[0];\n        auto counts = new int[](group_num);\n        foreach (x; ids[1])\n            counts[x]++;\n        auto groups = new int[][](ids[0]);\n        foreach (i; 0 .. group_num)\n            groups[i].reserve(counts[i]);\n        foreach (i; 0 .. _n)\n            groups[ids[1][i]] ~= i;\n        return groups;\n    }\n\nprivate:\n    int _n;\n    struct edge\n    {\n        int to;\n    }\n\n    Tuple!(int, edge)[] edges;\n}\n\nstruct TwoSat\n{\npublic:\n    this(int n)\n    {\n        _n = n;\n        _answer = new bool[](n);\n        scc = SccGraphImpl(2 * n + 2);\n    }\n\n    void addClause(int i, bool f, int j, bool g)\n    {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.addEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.addEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n\n    bool satisfiable()\n    {\n        auto id = scc.sccIds()[1];\n        foreach (i; 0 .. _n)\n        {\n            if (id[2 * i] == id[2 * i + 1])\n                return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n\n    bool[] answer()\n    {\n        return _answer;\n    }\n\nprivate:\n    int _n;\n    bool[] _answer;\n    SccGraphImpl scc;\n}\n"
  },
  {
    "language": "Python",
    "code": "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.buffer.readline\n    from collections import deque\n\n    # compressed[v]: 縮約後のグラフで縮約前のvが属する頂点\n    # num: 縮約後のグラフの頂点数\n    # 縮約後のグラフの頂点番号はトポロジカル順\n    def SCC(adj, adj_rev):\n        N = len(adj) - 1\n        seen = [0] * (N + 1)\n        compressed = [0] * (N + 1)\n        order = []\n\n        for v0 in range(1, N + 1):\n            if seen[v0]:\n                continue\n            st = deque()\n            st.append(v0)\n            while st:\n                v = st.pop()\n                if v < 0:\n                    order.append(-v)\n                else:\n                    if seen[v]:\n                        continue\n                    seen[v] = 1\n                    st.append(-v)\n                    for u in adj[v]:\n                        st.append(u)\n\n        seen = [0] * (N + 1)\n        num = 0\n        for v0 in reversed(order):\n            if seen[v0]:\n                continue\n            num += 1\n            st = deque()\n            st.append(v0)\n            seen[v0] = 1\n            compressed[v0] = num\n            while st:\n                v = st.pop()\n                for u in adj_rev[v]:\n                    if seen[u]:\n                        continue\n                    seen[u] = 1\n                    compressed[u] = num\n                    st.append(u)\n\n        return num, compressed\n\n    # 縮約後のグラフを構築\n    # 先にSCC()を実行してnum, compressedを作っておく\n    def construct(adj, num, compressed):\n        N = len(adj) - 1\n        adj_compressed = [set() for _ in range(num + 1)]\n        for v in range(1, N + 1):\n            v_cmp = compressed[v]\n            for u in adj[v]:\n                u_cmp = compressed[u]\n                if v_cmp != u_cmp:\n                    adj_compressed[v_cmp].add(u_cmp)\n        return adj_compressed\n\n    class TwoSat:\n        def __init__(self, N):\n            self.N = N\n            self.adj = [[] for _ in range(2 * N + 1)]\n            self.adj_rev = [[] for _ in range(2 * N + 1)]\n            self.compressed = None\n\n        # (a == a_bool) or (b = b_bool)というクローズを追加\n        # a, b は1-indexed\n        def add_clause(self, a, a_bool, b, b_bool):\n            if not a_bool:\n                a += self.N\n            if not b_bool:\n                b += self.N\n            if a <= self.N:\n                self.adj[a + self.N].append(b)\n                self.adj_rev[b].append(a + self.N)\n            else:\n                self.adj[a - self.N].append(b)\n                self.adj_rev[b].append(a - self.N)\n            if b <= self.N:\n                self.adj[b + self.N].append(a)\n                self.adj_rev[a].append(b + self.N)\n            else:\n                self.adj[b - self.N].append(a)\n                self.adj_rev[a].append(b - self.N)\n\n        def satisfiable(self):\n            _, self.compressed = SCC(self.adj, self.adj_rev)\n            for i in range(1, self.N + 1):\n                if self.compressed[i] == self.compressed[i + self.N]:\n                    return False\n            return True\n\n        # 直前に読んだsatisfiableの割り当てを返す\n        # 長さN+1のbool値の配列を返す\n        def answer(self):\n            assert self.compressed is not None\n            ret = [True] * (self.N + 1)\n            for i in range(1, self.N + 1):\n                if self.compressed[i] < self.compressed[i + self.N]:\n                    ret[i] = False\n            return ret\n\n    N, D = map(int, input().split())\n    X = []\n    Y = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        X.append(x)\n        Y.append(y)\n\n    TS = TwoSat(N)\n    for i in range(N):\n        for j in range(i+1, N):\n            if abs(X[i] - X[j]) < D:\n                TS.add_clause(i+1, 0, j+1, 0)\n            if abs(X[i] - Y[j]) < D:\n                TS.add_clause(i+1, 0, j+1, 1)\n            if abs(Y[i] - X[j]) < D:\n                TS.add_clause(i+1, 1, j+1, 0)\n            if abs(Y[i] - Y[j]) < D:\n                TS.add_clause(i+1, 1, j+1, 1)\n    ok = TS.satisfiable()\n    if not ok:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        ans = TS.answer()\n        for i in range(N):\n            if ans[i+1]:\n                print(X[i])\n            else:\n                print(Y[i])\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\n\"\"\"\nTwoSat\n\"\"\"\n\nclass SCC:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.graph_rev = [[] for _ in range(n)]\n        self.already = [False]*n\n    \n    def add_edge(self, fr, to):\n        if fr == to:\n            return\n        self.graph[fr].append(to)\n        self.graph_rev[to].append(fr)\n    \n    def dfs(self, node, graph):\n        self.already[node] = True\n        for n in graph[node]:\n            if self.already[n]:\n                continue\n            self.dfs(n, graph)\n        self.order.append(node)\n    \n    def first_dfs(self):\n        self.already = [False]*self.n\n        self.order = []\n        for i in range(self.n):\n            if self.already[i] == False:\n                self.dfs(i, self.graph)\n    \n    def second_dfs(self):\n        self.already = [False]*self.n\n        self.ans = []\n        for n in reversed(self.order):\n            if self.already[n]:\n                continue\n            self.already[n] = True\n            self.order = []\n            self.dfs(n, self.graph_rev)\n            self.order.reverse()\n            self.ans.append(self.order)\n\n    def scc(self):\n        self.first_dfs()\n        self.second_dfs()\n        return self.ans\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*(n+1)#それぞれの要素がどの要素の子であるか\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]#それぞれの要素の根を再帰的に求める\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)#x,yが同じ集合に属するかどうか\n    \n    def size(self, x):\n        return -self.par[self.find(x)]\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if root == self.find(i)]        \n\n\nclass TwoSat:\n    def __init__(self, n):\n        self.n = n\n        self.scc = SCC(n*2)\n        self.union = UnionFind(n*2)\n    \n    def add_sat(self, fr, to):\n        self.scc.add_edge(fr, to)\n    \n    def scc_prepare(self):\n        return self.scc.scc()\n\n    def union_prepare(self):\n        for v in self.res:\n            if len(v) == 1:\n                continue\n            for i in range(len(v)-1):\n                self.union.union(v[i], v[i+1])\n    \n    def ts_judge(self):\n        for i in range(self.n):\n            if self.union.same(i, i+self.n):\n                return False\n        return True\n    \n    def judge(self):\n        self.res = self.scc_prepare()\n        self.union_prepare()\n        res = self.ts_judge()\n        return res\n\n\ndef main():\n    n, d = map(int, input().split())\n\n    ts = TwoSat(n*2)\n    flag = [None]*n\n    for i in range(n):\n        x, y = map(int, input().split())\n        flag[i] = (x, y)\n    \n    for i in range(n):\n        ts.add_sat(n*3+i, i)\n        ts.add_sat(n*2+i, n+i)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(flag[i][0] - flag[j][0]) < d:\n                ts.add_sat(i, n*2+j)\n                ts.add_sat(j, n*2+i)\n                ts.add_sat(i, n+j)\n                ts.add_sat(j, n+i)\n            if abs(flag[i][0] - flag[j][1]) < d:\n                ts.add_sat(i, j)\n                ts.add_sat(i, n*3+j)\n                ts.add_sat(n+j, n+i)\n                ts.add_sat(n+j, n*2+i)\n            if abs(flag[i][1] - flag[j][0]) < d:\n                ts.add_sat(j, i)\n                ts.add_sat(j, n*3+i)\n                ts.add_sat(n+i, n+j)\n                ts.add_sat(n+i, n*2+j)\n            if abs(flag[i][1] - flag[j][1]) < d:\n                ts.add_sat(i+n, j)\n                ts.add_sat(i+n, j+n*3)\n                ts.add_sat(j+n, i)\n                ts.add_sat(j+n, i+n*3)\n    \n    ans = ts.judge()\n    print(\"Yes\" if ans else \"No\")\n    if ans:\n        used = [-1]*n\n        count = 0\n        for lis in reversed(ts.res):\n            for v in lis:\n                if v >= n*2:\n                    continue\n                index = v if v < n else v - n\n                if used[index] == -1:\n                    count += 1\n                    used[index] = v//n\n                if count == n:\n                    break\n        \n        for i in range(n):\n            print(flag[i][used[i]])\n\n    \n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[[] for _ in range(n)] for _ in range(2)]\n        self.vals = [-1]*n\n        self.log = []\n        self.start = []\n\n    # uがu_valならば、vはv_val\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u_val][u].append((v, u_val ^ v_val))\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        u = val = 0\n        while u < self.n:\n            if val == 0: self.start.append(u)\n            if self.__dfs(u, val):\n                u += 1\n                val = 0\n                while u < self.n and self.vals[u] != -1: u += 1\n            else:\n                if not self.start: return False\n                u = self.start.pop()\n                val = 1\n                while 1:\n                    v = self.log.pop()\n                    self.vals[v] = -1\n                    if v == u: break\n        return True\n\n    def __dfs(self, u, val):\n        if self.vals[u] != -1:\n            if self.vals[u] == val: return True\n            return False\n        self.vals[u] = val\n        self.log.append(u)\n        for v, x in self.to[val][u]:\n            if not self.__dfs(v, val ^ x): return False\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n*2)\nfor i, (x, y) in enumerate(xy):\n    ts.add_edge(i*2, 0, i*2+1, 1)\n    ts.add_edge(i*2+1, 0, i*2, 1)\n    ts.add_edge(i*2, 1, i*2+1, 0)\n    ts.add_edge(i*2+1, 1, i*2, 0)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i*2, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2, 0)\n        if abs(x1-y2) < d:\n            ts.add_edge(i*2, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2, 0)\n        if abs(y1-x2) < d:\n            ts.add_edge(i*2+1, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2+1, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i*2+1, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2+1, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for i in range(n):\n        if ts.vals[i*2]: print(xy[i][0])\n        else: print(xy[i][1])\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.path.append(\"/home/contestant/.local/lib/python3.8/site-packages\")\n\nimport networkx as nx\n\nimport io\nimport os\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nN, D = [int(x) for x in input().split()]\nXY = [[int(x) for x in input().split()] for i in range(N)]\n\ngraph = nx.DiGraph()\nfor i in range(2 * N):\n    graph.add_node(i)\n\n# f_i = 0 means choose x for flag i, f_i = 1 means choose y\n# Node i is (f_i==0), node (i+N) is (f_i==1)\nfor i, (x1, y1) in enumerate(XY):\n    for j in range(N):\n        if i != j:\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                # f_i==0 => f_j==1\n                graph.add_edge(i, j + N)\n            if abs(x1 - y2) < D:\n                # f_i==0 => f_j==0\n                graph.add_edge(i, j)\n            if abs(y1 - x2) < D:\n                # f_i==1 => f_j==1\n                graph.add_edge(i + N, j + N)\n            if abs(y1 - y2) < D:\n                # f_i==1 => f_j==0\n                graph.add_edge(i + N, j)\n\n\nSCC = nx.algorithms.components.strongly_connected_components(graph)\nassignment = {}\nfor comp in SCC:\n    for x in comp:\n        if (x < N and x + N in comp) or (x >= N and x - N in comp):\n            print(\"No\")\n            exit()\n        if x not in assignment:\n            assignment[x] = True\n            assignment[(x + N) % (2 * N)] = False\n\nprint(\"Yes\")\nfor i in range(N):\n    print(XY[i][0] if assignment[i] else XY[i][1])\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = N\n        self.ans = None\n        self.__e = []\n        self.__v = set()\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n        self.__v.add(2*i + 0)\n        self.__v.add(2*i + 1)\n        self.__v.add(2*j + 0)\n        self.__v.add(2*j + 1)\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        print(scc)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n\n    ts = TwoSat(2*N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "# TODO: メモリリーク確認\n# TODO: __repr__ を書く\n\ncode_two_sat = r\"\"\"\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"structmember.h\"\n\n// 元のライブラリの private を剥がした\n\n// >>> AtCoder >>>\n\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_SCC_HPP\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n//  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_TWOSAT_HPP\n\n// <<< AtCoder <<<\n\nusing namespace std;\nusing namespace atcoder;\n#define PARSE_ARGS(types, ...) if(!PyArg_ParseTuple(args, types, __VA_ARGS__)) return NULL\n\n\nstruct TwoSAT{\n    PyObject_HEAD\n    two_sat* ts;\n};\n\n\nextern PyTypeObject TwoSATType;\n\n\n// >>> TwoSAT definition >>>\n\nstatic void TwoSAT_dealloc(TwoSAT* self){\n    delete self->ts;\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\nstatic PyObject* TwoSAT_new(PyTypeObject* type, PyObject* args, PyObject* kwds){\n    return type->tp_alloc(type, 0);\n}\nstatic int TwoSAT_init(TwoSAT* self, PyObject* args){\n    long n;\n    if(!PyArg_ParseTuple(args, \"l\", &n)) return -1;\n    if(n < 0 || n > (long)1e8){\n        PyErr_Format(PyExc_IndexError,\n            \"TwoSAT constructor constraint error (constraint: 0<=n<=1e8, got n=%d)\", n);\n        return -1;\n    }\n    self->ts = new two_sat(n);\n    return 0;\n}\nstatic PyObject* TwoSAT_add_clause(TwoSAT* self, PyObject* args){\n    long i, j;\n    int f, g;\n    PARSE_ARGS(\"lplp\", &i, &f, &j, &g);\n    if(i < 0 || i >= self->ts->_n || j < 0 || j >= self->ts->_n){\n        PyErr_Format(PyExc_IndexError,\n            \"TwoSAT add_clause index out of range (n=%d, i=%d, j=%d)\", self->ts->_n, i, j);\n        return (PyObject*)NULL;\n    }\n    self->ts->add_clause(i, (bool)f, j, (bool)g);\n    Py_RETURN_NONE;\n}\nstatic PyObject* TwoSAT_satisfiable(TwoSAT* self, PyObject* args){\n    PyObject* res = self->ts->satisfiable() ? Py_True : Py_False;\n    return Py_BuildValue(\"O\", res);\n}\nstatic PyObject* TwoSAT_answer(TwoSAT* self, PyObject* args){\n    const vector<bool>& answer = self->ts->answer();\n    const int& n = self->ts->_n;\n    PyObject* list = PyList_New(n);\n    for(int i = 0; i < n; i++){\n        PyList_SET_ITEM(list, i, Py_BuildValue(\"O\", answer[i] ? Py_True : Py_False));\n    }\n    return list;\n}\n/*\nstatic PyObject* TwoSAT_repr(PyObject* self){\n    PyObject* res = PyUnicode_FromFormat(\"TwoSAT()\");\n    return res;\n}\n*/\nstatic PyMethodDef TwoSAT_methods[] = {\n    {\"add_clause\", (PyCFunction)TwoSAT_add_clause, METH_VARARGS, \"Add clause\"},\n    {\"satisfiable\", (PyCFunction)TwoSAT_satisfiable, METH_VARARGS, \"Check if problem satisfiable\"},\n    {\"answer\", (PyCFunction)TwoSAT_answer, METH_VARARGS, \"Get answer\"},\n    {NULL}  /* Sentinel */\n};\nPyTypeObject TwoSATType = {\n    PyObject_HEAD_INIT(NULL)\n    \"acl_twosat.TwoSAT\",                   /*tp_name*/\n    sizeof(TwoSAT),                     /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    (destructor)TwoSAT_dealloc,         /*tp_dealloc*/\n    0,                                  /*tp_print*/\n    0,                                  /*tp_getattr*/\n    0,                                  /*tp_setattr*/\n    0,                                  /*reserved*/\n    0,//TwoSAT_repr,                      /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    0,                                  /*tp_hash*/\n    0,                                  /*tp_call*/\n    0,                                  /*tp_str*/\n    0,                                  /*tp_getattro*/\n    0,                                  /*tp_setattro*/\n    0,                                  /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/\n    0,                                  /*tp_doc*/\n    0,                                  /*tp_traverse*/\n    0,                                  /*tp_clear*/\n    0,                                  /*tp_richcompare*/\n    0,                                  /*tp_weaklistoffset*/\n    0,                                  /*tp_iter*/\n    0,                                  /*tp_iternext*/\n    TwoSAT_methods,                     /*tp_methods*/\n    0,                                  /*tp_members*/\n    0,                                  /*tp_getset*/\n    0,                                  /*tp_base*/\n    0,                                  /*tp_dict*/\n    0,                                  /*tp_descr_get*/\n    0,                                  /*tp_descr_set*/\n    0,                                  /*tp_dictoffset*/\n    (initproc)TwoSAT_init,              /*tp_init*/\n    0,                                  /*tp_alloc*/\n    TwoSAT_new,                         /*tp_new*/\n    0,                                  /*tp_free*/\n    0,                                  /*tp_is_gc*/\n    0,                                  /*tp_bases*/\n    0,                                  /*tp_mro*/\n    0,                                  /*tp_cache*/\n    0,                                  /*tp_subclasses*/\n    0,                                  /*tp_weaklist*/\n    0,                                  /*tp_del*/\n    0,                                  /*tp_version_tag*/\n    0,                                  /*tp_finalize*/\n};\n\n// <<< TwoSAT definition <<<\n\n\nstatic PyModuleDef acl_twosatmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"acl_twosat\",\n    NULL,\n    -1,\n};\n\nPyMODINIT_FUNC PyInit_acl_twosat(void)\n{\n    PyObject* m;\n    if(PyType_Ready(&TwoSATType) < 0) return NULL;\n\n    m = PyModule_Create(&acl_twosatmodule);\n    if(m == NULL) return NULL;\n\n    Py_INCREF(&TwoSATType);\n    if (PyModule_AddObject(m, \"TwoSAT\", (PyObject*)&TwoSATType) < 0) {\n        Py_DECREF(&TwoSATType);\n        Py_DECREF(m);\n        return NULL;\n    }\n    \n    return m;\n}\n\"\"\"\ncode_two_sat_setup = r\"\"\"\nfrom distutils.core import setup, Extension\nmodule = Extension(\n    \"acl_twosat\",\n    sources=[\"two_sat.cpp\"],\n    extra_compile_args=[\"-O3\", \"-march=native\", \"-std=c++14\"]\n)\nsetup(\n    name=\"acl_twosat\",\n    version=\"0.0.1\",\n    description=\"wrapper for atcoder library twosat\",\n    ext_modules=[module]\n)\n\"\"\"\n\nimport os\nimport sys\n\nif sys.argv[-1] == \"ONLINE_JUDGE\" or os.getcwd() != \"/imojudge/sandbox\":\n    with open(\"two_sat.cpp\", \"w\") as f:\n        f.write(code_two_sat)\n    with open(\"two_sat_setup.py\", \"w\") as f:\n        f.write(code_two_sat_setup)\n    os.system(f\"{sys.executable} two_sat_setup.py build_ext --inplace\")\n\nfrom acl_twosat import TwoSAT\n\n\ndef main():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n    ts = TwoSAT(N)\n    for i, (xi, yi) in enumerate(XY):\n        for j, (xj, yj) in enumerate(XY[i+1:], i+1):\n            if abs(xi-xj) < D:\n                ts.add_clause(i, False, j, False)\n            if abs(xi-yj) < D:\n                ts.add_clause(i, False, j, True)\n            if abs(yi-xj) < D:\n                ts.add_clause(i, True, j, False)\n            if abs(yi-yj) < D:\n                ts.add_clause(i, True, j, True)\n    if not ts.satisfiable():\n        print(\"No\")\n        return\n    print(\"Yes\")\n    answer = ts.answer()\n    for a, (x, y) in zip(answer, XY):\n        print(x if a else y)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n,d = (int(x) for x in input().split())\nlists = [[] for i in range(n)]\nfor j in range(n):\n  lists[j] = list(map(int,input().split()))\n  \nc = 1\nfor i in range(n):\n  c *= i+1\n\ndists = []\nfor i in range(n-1):\n  for j in range(i+1,n):\n    dist = ( (lists[i][0] -lists[j][0]) + (lists[i][1]-lists[j][1]) )**2\n    dists.append(dist)\n    \nfor i in range(c):\n  if d > dists[i]:\n    print('No')\n  else:\n    print('Yes')"
  },
  {
    "language": "Python",
    "code": "from scipy.sparse.csgraph import connected_components\nfrom scipy.sparse import csr_matrix\n\nN, D, *XY = map(int, open(0).read().split())\nXY = list(zip(*[iter(XY)] * 2))\n\nR, C = [], []\nfor i, (x1, y1) in enumerate(XY):\n    for j, (x2, y2) in enumerate(XY):\n        if i == j:\n            continue\n\n        if abs(x1 - x2) < D:\n            R.append(i)\n            C.append(j + N)\n        if abs(x1 - y2) < D:\n            R.append(i)\n            C.append(j)\n        if abs(y1 - x2) < D:\n            R.append(i + N)\n            C.append(j + N)\n        if abs(y1 - y2) < D:\n            R.append(i + N)\n            C.append(j)\n\nG = csr_matrix(([1] * len(R), (R, C)))\nM, label = connected_components(G, connection='strong')\n\nC = [[] for _ in range(M)]\nfor i, l in enumerate(label):\n    C[l].append(i)\n\nmemo = {}\nfor c in C:\n    for x in c:\n        if (x < N and x + N in c) or (N <= x and x - N in c):\n            print(\"No\")\n            quit()\n\n        if x not in memo:\n            memo[x] = True\n            memo[(x + N) % (2 * N)] = False\n\nprint(\"Yes\")\nfor i, (x, y) in enumerate(XY):\n    print(x if memo[i] else y)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\n\"\"\"\nTwoSat\n\"\"\"\n\nclass SCC:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.graph_rev = [[] for _ in range(n)]\n        self.already = [False]*n\n    \n    def add_edge(self, fr, to):\n        if fr == to:\n            return\n        self.graph[fr].append(to)\n        self.graph_rev[to].append(fr)\n    \n    def dfs(self, node, graph):\n        self.already[node] = True\n        for n in graph[node]:\n            if self.already[n]:\n                continue\n            self.dfs(n, graph)\n        self.order.append(node)\n    \n    def first_dfs(self):\n        self.already = [False]*self.n\n        self.order = []\n        for i in range(self.n):\n            if self.already[i] == False:\n                self.dfs(i, self.graph)\n    \n    def second_dfs(self):\n        self.already = [False]*self.n\n        self.ans = []\n        for n in reversed(self.order):\n            if self.already[n]:\n                continue\n            self.already[n] = True\n            self.order = []\n            self.dfs(n, self.graph_rev)\n            self.order.reverse()\n            self.ans.append(self.order)\n\n    def scc(self):\n        self.first_dfs()\n        self.second_dfs()\n        return self.ans\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*(n+1)#それぞれの要素がどの要素の子であるか\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]#それぞれの要素の根を再帰的に求める\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)#x,yが同じ集合に属するかどうか\n    \n    def size(self, x):\n        return -self.par[self.find(x)]\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if root == self.find(i)]        \n\n\nclass TwoSat:\n    def __init__(self, n):\n        self.n = n\n        self.scc = SCC(n*2)\n        self.union = UnionFind(n*2)\n    \n    def add_sat(self, fr, to):\n        self.scc.add_edge(fr, to)\n    \n    def scc_prepare(self):\n        return self.scc.scc()\n\n    def union_prepare(self):\n        for v in self.res:\n            if len(v) == 1:\n                continue\n            for i in range(len(v)-1):\n                self.union.union(v[i], v[i+1])\n    \n    def ts_judge(self):\n        for i in range(self.n):\n            if self.union.same(i, i+self.n):\n                return False\n        return True\n    \n    def judge(self):\n        self.res = self.scc_prepare()\n        self.union_prepare()\n        res = self.ts_judge()\n        return res\n\n\ndef main():\n    n, d = map(int, input().split())\n\n    ts = TwoSat(n*2)\n    flag = [None]*n\n    for i in range(n):\n        x, y = map(int, input().split())\n        flag[i] = (x, y)\n    \n    for i in range(n):\n        ts.add_sat(n*3+i, i)\n        ts.add_sat(n*2+i, n+i)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(flag[i][0] - flag[j][0]) < d:\n                ts.add_sat(i, n*2+j)\n                ts.add_sat(j, n*2+i)\n                ts.add_sat(i, n+j)\n                ts.add_sat(j, n+i)\n            if abs(flag[i][0] - flag[j][1]) < d:\n                ts.add_sat(i, j)\n                ts.add_sat(i, n*3+j)\n                ts.add_sat(n+j, n+i)\n                ts.add_sat(n+j, n*2+i)\n            if abs(flag[i][1] - flag[j][0]) < d:\n                ts.add_sat(j, i)\n                ts.add_sat(j, n*3+i)\n                ts.add_sat(n+i, n+j)\n                ts.add_sat(n+i, n*2+j)\n            if abs(flag[i][1] - flag[j][1]) < d:\n                ts.add_sat(i+n, j)\n                ts.add_sat(i+n, j+n*3)\n                ts.add_sat(j+n, i)\n                ts.add_sat(j+n, i+n*3)\n    \n    ans = ts.judge()\n    print(\"Yes\" if ans else \"No\")\n    \n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "class csr:\n    def __init__(self, n: int, edges: list):\n        self.start = [0] * (n + 1)\n        self.elist = [0] * len(edges)\n        for e in edges:\n            self.start[e[0] + 1] += 1\n        for i in range(1, n + 1):\n            self.start[i] += self.start[i - 1]\n        counter = self.start[::]\n        for e in edges:\n            self.elist[counter[e[0]]] = e[1]\n            counter[e[0]] += 1\n\n\nclass internal_scc_graph:\n    def __init__(self, n: int = 0):\n        self.__n = n\n        self.__edges = []\n\n    def num_vertices(self):\n        return self.__n\n\n    def add_edge(self, from_: int, to: int):\n        self.__edges.append([from_, to])\n\n    def scc_ids(self):\n        g = csr(self.__n, self.__edges)\n        now_ord = 0\n        group_num = 0\n        visited = []\n        low = [0] * self.__n\n        ord = [-1] * self.__n\n        ids = [0] * self.__n\n        parent = [-1] * self.__n\n\n        for root in range(self.__n):\n            if(ord[root] == -1):\n                stack = []\n                stack.extend([root] * 2)\n                while(stack):\n                    v = stack.pop()\n                    if(ord[v] == -1):\n                        visited.append(v)\n                        low[v] = now_ord\n                        ord[v] = now_ord\n                        now_ord += 1\n                        for i in range(g.start[v], g.start[v + 1]):\n                            to = g.elist[i]\n                            if(ord[to] == -1):\n                                stack.extend([to] * 2)\n                                parent[to] = v\n                            else:\n                                low[v] = min(low[v], ord[to])\n                    else:\n                        if(low[v] == ord[v]):\n                            while(True):\n                                u = visited.pop()\n                                ord[u] = self.__n\n                                ids[u] = group_num\n                                if(u == v):\n                                    break\n                            group_num += 1\n                        if(parent[v] != -1):\n                            low[parent[v]] = min(low[parent[v]], low[v])\n\n        for i, x in enumerate(ids):\n            ids[i] = group_num - 1 - x\n        return [group_num, ids]\n\n\nclass two_sat:\n    def __init__(self, n: int = 0):\n        self.__n = n\n        self.__answer = [0] * n\n        self.__scc = internal_scc_graph(2 * n)\n\n    def add_clause(self, i: int, f: bool, j: int, g: bool):\n        assert (0 <= i) & (i < self.__n)\n        assert (0 <= j) & (j < self.__n)\n        self.__scc.add_edge(2 * i + (1 - f), 2 * j + g)\n        self.__scc.add_edge(2 * j + (1 - g), 2 * i + f)\n\n    def satisfiable(self):\n        id = self.__scc.scc_ids()[1]\n        for i in range(self.__n):\n            if(id[2 * i] == id[2 * i + 1]):\n                return False\n            self.__answer[i] = (id[2 * i] < id[2 * i + 1])\n        return True\n\n    def answer(self):\n        return self.__answer\n\nimport sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn,d = map(int,readline().split())\nxy = [list(map(int, i.split())) for i in readlines()]\n\nts = two_sat(n)\nfor i in range(n-1):\n    for j in range(i+1,n):\n        for ii,jj in zip([0,0,1,1],[0,1,0,1]):\n            if(abs(xy[i][ii] - xy[j][jj]) < d):\n                ts.add_clause(i, 1-ii, j, 1-jj)\n\nif(ts.satisfiable()):\n    print('Yes')\nelse:\n    print('No')\n    exit()\n\nans = []\nfor i,tf in enumerate(ts.answer()):\n    ans.append(xy[i][tf])\nprint('\\n'.join(map(str,ans)))"
  },
  {
    "language": "Python",
    "code": "class DiGraph:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.rev = [[] for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n\n    def add_edge(self, fr, to):\n        self.graph[fr].append(to)\n        self.rev[to].append(fr)\n        self.deg[to] += 1\n\n    def scc_ids(self):\n        group = [None for _ in range(self.n)]\n        used = [0 for _ in range(self.n)]\n        order = []\n        for s in range(self.n):\n            if not used[s]:\n                stack = [s]\n                used[s] = 1\n                while stack:\n                    node = stack.pop()\n                    movable = False\n                    for adj in self.graph[node]:\n                        if not used[adj]:\n                            movable = True\n                            used[adj] = 1\n                            stack.append(node)\n                            stack.append(adj)\n                            break\n                    if not movable:\n                        order.append(node)\n        used = [0 for _ in range(self.n)]\n        count = 0\n        for s in order[::-1]:\n            if not used[s]:\n                stack = [s]\n                group[s] = count\n                while stack:\n                    node = stack.pop()\n                    used[node] = 1\n                    for adj in self.rev[node]:\n                        if not used[adj]:\n                            group[adj] = count\n                            stack.append(adj)\n                count += 1\n        return group, count\n\n\nclass TwoSAT:\n    def __init__(self, n):\n        self.n = n\n        self.res = [0] * self.n\n        self.scc = DiGraph(2 * n)\n\n    def add_clause(self, i: int, f: bool, j: int, g: bool):  # (x_i = f) V (x_j = g)\n        self.scc.add_edge(2 * i + (not f), 2 * j + g)\n        self.scc.add_edge(2 * j + (not g), 2 * i + f)\n\n    def satisfiable(self):\n        group, cnt = self.scc.scc_ids()\n        for i in range(self.n):\n            if group[2 * i] == group[2 * i + 1]:\n                return False\n            self.res[i] = (group[2 * i] > group[2 * i + 1])\n        return True\n\n    def result(self):\n        return self.res\n\n\nN, D = map(int, input().split())\nXY = [tuple(map(int, input().split())) for _ in range(N)]\n\nts = TwoSAT(N)\n\nfor i in range(N-1):\n    x1, y1 = XY[i][0], XY[i][1]\n    for j in range(i+1, N):\n        x2, y2 = XY[j][0], XY[j][1]\n\n        if abs(x1 - x2) < D:\n            ts.add_clause(i, True, j, True)\n        if abs(x1 - y2) < D:\n            ts.add_clause(i, True, j, False)\n        if abs(y1 - x2) < D:\n            ts.add_clause(i, False, j, True)\n        if abs(y1 - y2) < D:\n            ts.add_clause(i, False, j, False)\n\nif ts.satisfiable():\n    print('Yes')\n    res = ts.result()\n    for i in range(N):\n        print(XY[i][0 if res[i] else 1])\nelse:\n    print('No')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**9)\ndef SCC(G):\n  D=[]\n  C=[len(G)-1]\n  U=[1]*len(G)\n  def DFS(x):\n    if U[x]:\n      U[x]=0\n      for i in range(len(G[x])):\n        DFS(G[x][i])\n      D.append(x)\n  \n  for i in range(len(G)):\n    if U[i]:\n      DFS(i)\n  GR=[[] for i in range(len(G))]\n  for i in range(len(G)):\n    for j in range(len(G[i])):\n      GR[G[i][j]].append(i)\n  R=[]\n  U=[1]*len(G)\n  def DFSR(x):\n    if U[x]:\n      R[-1].append(x)\n      U[x]=0\n      for i in range(len(GR[x])):\n        DFSR(GR[x][i])\n  \n  for i in range(len(G)-1,-1,-1):\n    if U[D[i]]:\n      R.append([])\n      DFSR(D[i])\n  return R\n\nN,D=map(int,input().split())\nG=[[] for i in range(2*N)]\nX=[list(map(int,input().split())) for i in range(N)]\nfor i in range(N):\n  for j in range(i+1,N):\n    for k in range(2):\n      for l in range(2):\n        if abs(X[i][k]-X[j][l])<D:\n          G[k*N+i].append((l^1)*N+j)\n          G[l*N+j].append((k^1)*N+i)\nG=SCC(G)\nC=[0]*(2*N)\nfor i in range(len(G)):\n  for j in range(len(G[i])):\n    C[G[i][j]]=i\nfor i in range(N):\n  if C[i]==C[i+N]:\n    print('No')\n    exit()\nprint('Yes')\nfor i in range(N):\n  if C[i]>C[i+N]:\n    print(X[i][0])\n  else:\n    print(X[i][1])"
  },
  {
    "language": "Python",
    "code": "N,D=map(int,input().split())\nF=[tuple(map(int,input().split())) for i in range(N)]\n\nEDGE=[[] for i in range(2*N)]\nEDGE_INV=[[] for i in range(2*N)]\n\n# 0～N : X_i\n# N+1～2N: Y_i = ￢X_i\n\nfor i in range(N):\n    x1,y1=F[i]\n\n    for j in range(i,N):\n        x2,y2=F[j]\n\n        if abs(x1-x2)<D and i!=j:\n            EDGE[i].append(N+j)\n            EDGE[j].append(N+i)\n\n            EDGE_INV[N+j].append(i)\n            EDGE_INV[N+i].append(j)\n\n        if abs(x1-y2)<D:\n            EDGE[i].append(j)\n            EDGE[N+j].append(N+i)\n\n            EDGE_INV[j].append(i)\n            EDGE_INV[N+i].append(N+j)\n\n        if abs(y1-x2)<D:\n            EDGE[N+i].append(N+j)\n            EDGE[j].append(i)\n\n            EDGE_INV[N+j].append(N+i)\n            EDGE_INV[i].append(j)\n\n        if abs(y1-y2)<D and i!=j:\n            EDGE[N+i].append(j)\n            EDGE[N+j].append(i)\n\n            EDGE_INV[j].append(N+i)\n            EDGE_INV[i].append(N+j)\n\nQUE = list(range(2*N))\ncheck=[0]*(2*N)\nTOP_SORT=[]\n\ndef dfs(x):\n    if check[x]==1:\n        return\n    check[x]=1\n    \n    for to in EDGE[x]:\n        if check[to]==0:\n            dfs(to)\n\n    TOP_SORT.append(x) # 全ての点からDFSを行い, 帰りがけに点を答えに入れる\n    check[x]=1\n\nwhile QUE:\n    x=QUE.pop()\n    dfs(x)\n\nUSE=[0]*(2*N)\nSCC=[]\n\ndef dfs2(x):\n    Q=[x]\n    USE[x]=1\n    ANS=[]\n\n    while Q:\n        x=Q.pop()\n        ANS.append(x)\n        for to in EDGE_INV[x]:\n            if USE[to]==0:\n                USE[to]=1\n                Q.append(to)\n    return ANS\n\nfor x in TOP_SORT[::-1]:\n    if USE[x]==0:\n        SCC.append(dfs2(x))\n\n\nPLACE=[-1]*(2*N)\nfor i in range(len(SCC)):\n    for x in SCC[i]:\n        PLACE[x]=i\n\nANS=[-1]*N\nflag=1\nfor i in range(N):\n    if PLACE[i]==PLACE[N+i]:\n        flag=0\n        break\n    \n    elif PLACE[i]>PLACE[N+i]:\n        ANS[i]=F[i][0]\n    else:\n        ANS[i]=F[i][1]\n    \nif flag==0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for ans in ANS:\n        print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[[] for _ in range(n)] for _ in range(2)]\n        self.vals = [-1]*n\n        self.log = []\n        self.start = []\n\n    # uがu_valならば、vはv_val\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u_val][u].append((v, u_val ^ v_val))\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        u = val = 0\n        while u < self.n:\n            if val == 0: self.start.append(u)\n            if self.__dfs(u, val):\n                u += 1\n                val = 0\n                while u < self.n and self.vals[u] != -1: u += 1\n            else:\n                if not self.start: return False\n                u = self.start.pop()\n                val = 1\n                while 1:\n                    v = self.log.pop()\n                    self.vals[v] = -1\n                    if v == u: break\n        return True\n\n    def __dfs(self, u, val):\n        if self.vals[u] != -1:\n            if self.vals[u] == val: return True\n            return False\n        self.vals[u] = val\n        self.log.append(u)\n        for v, x in self.to[val][u]:\n            if not self.__dfs(v, val ^ x): return False\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n*2)\nfor i, (x, y) in enumerate(xy):\n    ts.add_edge(i*2, 0, i*2+1, 1)\n    ts.add_edge(i*2+1, 0, i*2, 1)\n    ts.add_edge(i*2, 1, i*2+1, 0)\n    ts.add_edge(i*2+1, 1, i*2, 0)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i*2, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2, 0)\n        if abs(x1-y2) < d:\n            ts.add_edge(i*2, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2, 0)\n        if abs(y1-x2) < d:\n            ts.add_edge(i*2+1, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2+1, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i*2+1, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2+1, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for i in range(n):\n        if ts.vals[i*2]: print(xy[i][0])\n        else: print(xy[i][1])\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "header_code = \"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"/opt/atcoder-stl/atcoder/internal_bit.hpp\"\n#include \"/opt/atcoder-stl/atcoder/lazysegtree.hpp\"\n#include \"/opt/atcoder-stl/atcoder/modint.hpp\"\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nnamespace aclython {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = atcoder::internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l, S b) {\n        return max_right(l, b, [](S x, S y) { return f(x, y); });\n    }\n    template <class F> int max_right(int l, S b, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]), b)) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]), b)) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r, S b) {\n        return min_left(r, b, [](S x, S y) { return f(x, y); });\n    }\n    template <class F> int min_left(int r, S b, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm), b)) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm), b)) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n\n\nint min_op(int n, int m){\n    return std::min(n, m);\n}\n\nint min_e(){\n    return (int)1e9;\n}\n\nstruct segtree_min {\n    public:\n        segtree_min() : segtree_min(0) {}\n        segtree_min(int n) : segtree_min(std::vector<int>(n, min_e())) {}\n        segtree_min(const std::vector<int>& vec) : seg(vec) {}\n\n        void set(int p, int x) {seg.set(p, x);}\n        int get(int p) {return seg.get(p);}\n        int prod(int l, int r) {return seg.prod(l, r);}\n        int all_prod() {return seg.all_prod();}\n\n        int max_right(int l, int v) {return seg.max_right(l, v, [](int x, int y) { return x<y; });}\n        int min_left(int r, int v) {return seg.min_left(r, v, [](int x, int y) { return x<y; });}\n\n    private:\n        segtree<int, min_op, min_e> seg;\n};\n\nint max_op(int n, int m){\n    return std::max(n, m);\n}\n\nint max_e(){\n    return 0;\n}\n\nstruct segtree_max {\n    public:\n        segtree_max() : segtree_max(0) {}\n        segtree_max(int n) : segtree_max(std::vector<int>(n, max_e())) {}\n        segtree_max(const std::vector<int>& vec) : seg(vec) {}\n\n        void set(int p, int x) {seg.set(p, x);}\n        int get(int p) {return seg.get(p);}\n        int prod(int l, int r) {return seg.prod(l, r);}\n        int all_prod() {return seg.all_prod();}\n\n        int max_right(int l, int v) {return seg.max_right(l, v, [](int x, int y) { return x<y; });}\n        int min_left(int r, int v) {return seg.min_left(r, v, [](int x, int y) { return x<y; });}\n\n    private:\n        segtree<int, max_op, max_e> seg;\n};\n\nusing mint = atcoder::modint998244353;\n\nstruct S {\n    mint a;\n    int size;\n    S(mint _a, int _size) : a(_a) ,size(_size) {}\n    S(int _a, int _size) : a(_a) ,size(_size) {}\n    S(const S &s) : a(s.a), size(s.size) {}\n    int get_a() { return (int)a.val(); }\n};\n\nstruct F {\n    mint a, b;\n    F(mint _a, mint _b) : a(_a), b(_b) {}\n    F(int _a, int _b) : a(_a), b(_b) {}\n    F(const F &f) : a(f.a), b(f.b) {}\n    int get_a() { return (int)a.val(); }\n    int get_b() { return (int)b.val(); }\n};\n\nS op(S l, S r) { return S{l.a + r.a, l.size + r.size}; }\n\nS e() { return S{0, 0}; }\n\nS mapping(F l, S r) { return S{r.a * l.a + r.size * l.b, r.size}; }\n\nF composition(F l, F r) { return F{r.a * l.a, r.b * l.a + l.b}; }\n\nF id() { return F{1, 0}; }\n\nstruct lazy_segtree{\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& vec) : seg(vec) {}\n    void set(int p, S x) { seg.set(p, x); }\n    S get(int p) { return seg.get(p); }\n    S prod(int l, int r) { return seg.prod(l, r); }\n    S all_prod() { return seg.all_prod(); }\n    void apply(int p, F f) { seg.apply(p, f); }\n    void apply(int l, int r, F f) { seg.apply(l, r, f); }\n    private:\n        atcoder::lazy_segtree<S, op, e, F, mapping, composition, id> seg;\n};\n\n}\n\"\"\"\n\ncode = \"\"\"\n\n# distutils: language=c++\n# distutils: include_dirs=[/home/USERNAME/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]\n# cython: boundscheck=False\n# cython: wraparound=False\n\nfrom libc.stdio cimport getchar, printf\nfrom libcpp.vector cimport vector\nfrom libcpp cimport bool\nfrom libcpp.string cimport string\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\":\n    cdef cppclass two_sat:\n        two_sat(int n)\n        void add_clause(int i, bool f, int j, bool g)\n        bool satisfiable()\n        vector[bool] answer()\n\ncdef class TwoSat:\n    cdef two_sat *_thisptr\n    def __cinit__(self, int n):\n        self._thisptr = new two_sat(n)\n    cpdef void add_clause(self, int i, bool f, int j, bool g):\n        self._thisptr.add_clause(i, f, j, g)\n    cpdef bool satisfiable(self):\n        return self._thisptr.satisfiable()\n    cpdef vector[bool] answer(self):\n        return self._thisptr.answer()\ncpdef inline vector[int] ReadInt(int n):\n    cdef int b, c\n    cdef vector[int] *v = new vector[int]()\n    for i in range(n):\n        c = 0\n        while 1:\n            b = getchar() - 48\n            if b < 0: break\n            c = c * 10 + b\n        v.push_back(c)\n    return v[0]\n\ncpdef inline vector[string] Read(int n):\n    cdef char c\n    cdef vector[string] *vs = new vector[string]()\n    cdef string *s\n    for i in range(n):\n        s = new string()\n        while 1:\n            c = getchar()\n            if c<=32: break\n            s.push_back(c)\n        vs.push_back(s[0])\n    return vs[0]\n\ncpdef inline void PrintLongN(vector[long] l, int n):\n    for i in range(n): printf(\"%ld\\\\n\", l[i])\n\ncpdef inline void PrintLong(vector[long] l, int n):\n    for i in range(n): printf(\"%ld \", l[i])\n\"\"\"\n\n\nimport os, sys, getpass\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    code = code.replace(\"USERNAME\", getpass.getuser())\n    open('intermediate.hpp','w').write(header_code)\n    open('atcoder.pyx','w').write(code)\n    os.system('cythonize -i -3 -b atcoder.pyx')\n    sys.exit(0)\n\n\nfrom atcoder import ReadInt, TwoSat, PrintLongN\n\ndef main():\n  N,D=ReadInt(2)\n  xy = ReadInt(2*N)\n  ts=TwoSat(N)\n  for i in range(N-1):\n    for j in range(i+1,N):\n      for k1,k2 in [(0,0),(0,1),(1,0),(1,1)]:\n        pos1,pos2 = xy[2*i+k1],xy[2*j+k2]\n        if abs(pos2-pos1)<D:\n          ts.add_clause(i,k1^1,j,k2^1)\n\n  if ts.satisfiable():\n    print('Yes')\n    ans = ts.answer()\n    ans = [xy[2*i+ans[i]] for i in range(N)]\n    PrintLongN(ans, len(ans))\n  else:\n    print('No')\n\nif __name__==\"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n):\n        self.n = n\n        self.graph = [set() for _ in range(n)]\n        self.rev = [set() for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n\n    def add_edge(self, p, q):\n        self.graph[p].add(q)\n        self.rev[q].add(p)\n        self.deg[q] += 1\n\n    def topological_sort(self):\n        deg = self.deg[:]\n        res = [i for i in range(self.n) if deg[i] == 0]\n        queue = deque(res)\n        used = [False for _ in range(self.n)]\n        while queue:\n            node = queue.popleft()\n            for adj in self.graph[node]:\n                deg[adj] -= 1\n                if deg[adj] == 0:\n                    queue.append(adj)\n                    res.append(adj)\n        return res\n\n    def strongry_connected(self):\n        group = [None for _ in range(self.n)]\n        used = [0 for _ in range(self.n)]\n        order = []\n        for s in range(self.n):\n            if not used[s]:\n                stack = [s]\n                used[s] = 1\n                while stack:\n                    node = stack.pop()\n                    movable = False\n                    for adj in self.graph[node]:\n                        if not used[adj]:\n                            movable = True\n                            used[adj] = 1\n                            stack.append(node)\n                            stack.append(adj)\n                            break\n                    if not movable:\n                        order.append(node)\n        used = [0 for _ in range(self.n)]\n        count = 0\n        for s in order[::-1]:\n            if not used[s]:\n                stack = [s]\n                group[s] = count\n                while stack:\n                    node = stack.pop()\n                    used[node] = 1\n                    for adj in self.rev[node]:\n                        if not used[adj]:\n                            group[adj] = count\n                            stack.append(adj)\n                count += 1\n        return group, count\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\n\nX = []\nY = []\n\ng = Graph(2 * N)\n\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\n\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        if abs(X[i] - X[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(j, ~i)\n        if abs(X[i] - Y[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(~j, i)\n        if abs(Y[i] - X[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(j, ~i)\n        if abs(Y[i] - Y[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(~j, i)\n\ngroup, count = g.strongry_connected()\n\ngroup_to_node = [[] for _ in range(count)]\n\nfor i in range(N):\n    if group[i] == group[~i]:\n        print('No')\n        break\n    group_to_node[group[i]].append(i)\n    group_to_node[group[~i]].append(~i)\n\nelse:\n    print('Yes')\n\n    comp = Graph(count)\n\n    for i in range(2 * N):\n        for j in g.graph[i]:\n            if group[i] == group[j]:\n                continue\n            comp.add_edge(group[i], group[j])\n\n    ts = comp.topological_sort()\n\n    res = [None for _ in range(N)]\n\n    for i in ts:\n        for node in group_to_node[i]:\n            if node >= 0:\n                if res[node] is None:\n                    res[node] = Y[node]\n            else:\n                if res[~node] is None:\n                    res[~node] = X[~node]\n\n    for i in range(N):\n        if res[i] is None:\n            res[i] = X[node]\n\n    print('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "code = \"\"\"\n\n# distutils: language=c++\n# distutils: include_dirs=[/home/USERNAME/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]\n# cython: boundscheck=False\n# cython: wraparound=False\n\nfrom libcpp.vector cimport vector\nfrom libcpp cimport bool\nfrom libc.stdio cimport getchar, printf\nfrom libcpp.string cimport string\ncpdef inline vector[int] ReadInt(int n):\n    cdef int b, c\n    cdef vector[int] *v = new vector[int]()\n    for i in range(n):\n        c = 0\n        while 1:\n            b = getchar() - 48\n            if b < 0: break\n            c = c * 10 + b\n        v.push_back(c)\n    return v[0]\n\ncpdef inline vector[string] Read(int n):\n    cdef char c\n    cdef vector[string] *vs = new vector[string]()\n    cdef string *s\n    for i in range(n):\n        s = new string()\n        while 1:\n            c = getchar()\n            if c<=32: break\n            s.push_back(c)\n        vs.push_back(s[0])\n    return vs[0]\n\ncpdef inline void PrintLongN(vector[long] l, int n):\n    for i in range(n): printf(\"%ld\\\\n\", l[i])\n\ncpdef inline void PrintLong(vector[long] l, int n):\n    for i in range(n): printf(\"%ld \", l[i])\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\":\n    cdef cppclass two_sat:\n        two_sat(int n)\n        void add_clause(int i, bool f, int j, bool g)\n        bool satisfiable()\n        vector[bool] answer()\n\ncdef class TwoSat:\n    cdef two_sat *_thisptr\n    def __cinit__(self, int n):\n        self._thisptr = new two_sat(n)\n    cpdef void add_clause(self, int i, bool f, int j, bool g):\n        self._thisptr.add_clause(i, f, j, g)\n    cpdef bool satisfiable(self):\n        return self._thisptr.satisfiable()\n    cpdef vector[bool] answer(self):\n        return self._thisptr.answer()\n\"\"\"\n\n\nimport os, sys, getpass\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    code = code.replace(\"USERNAME\", getpass.getuser())\n    open('atcoder.pyx','w').write(code)\n    os.system('cythonize -i -3 -b atcoder.pyx')\n    sys.exit(0)\n\n\nfrom atcoder import ReadInt, TwoSat\n\ndef main():\n  N,D=ReadInt(2)\n  xy = [ReadInt(2) for _ in range(N)]\n  ts=TwoSat(N)\n  for i in range(N-1):\n    for j in range(i+1,N):\n      for k1,k2 in [(0,0),(0,1),(1,0),(1,1)]:\n        pos1,pos2 = xy[i][k1],xy[j][k2]\n        if abs(pos2-pos1)<D:\n          ts.add_clause(i,k1^1,j,k2^1)\n\n  if ts.satisfiable():\n    print('Yes')\n    ans = ts.answer()\n    print(*[xy[i][ans[i]] for i in range(N)],sep=\"\\n\")\n  else:\n    print('No')\n\nif __name__==\"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "code = r\"\"\"\n# distutils: language=c++\n# distutils: include_dirs=[/home/contestant/.local/lib/python3.8/site-packages/numpy/core/include,/opt/atcoder-stl]\n# cython: boundscheck=False\n# cython: wraparound=False\nfrom libcpp cimport bool\nfrom libcpp.string cimport string\nfrom libcpp.vector cimport vector\n\ncdef extern from \"<atcoder/dsu>\" namespace \"atcoder\":\n    cpdef cppclass dsu:\n        dsu(int n)\n        int merge(int a, int b)\n        bool same(int a, int b)\n        int leader(int a)\n        int size(int a)\n        vector[vector[int]] groups()\ncdef class dsu_:\n    cdef dsu *ptr\n    def __cinit__(self, int n): self.ptr = new dsu(n)\n    def __dealloc__(self): del self.ptr\n    cpdef int merge(self,a,b): return self.ptr.merge(a,b)\n    cpdef bool same(self,a,b): return self.ptr.same(a,b)\n    cpdef int leader(self,a): return self.ptr.leader(a)\n    cpdef int size(self,a): return self.ptr.size(a)\n    cpdef vector[vector[int]] groups(self): return self.ptr.groups()\n\ncdef extern from \"<atcoder/fenwicktree>\" namespace \"atcoder\":\n    cdef cppclass fenwick_tree[T]:\n        fenwick_tree(int n)\n        void add(int p, T x)\n        T sum(int l, int r)\ncdef class fenwick_tree_:\n    cdef fenwick_tree[int] *ptr\n    def __cinit__(self, int n): self.ptr = new fenwick_tree[int](n)  \n    def __dealloc__(self): del self.ptr\n    cpdef void add(self, int p, long x): self.ptr.add(p, x)\n    cpdef long sum(self, int l, int r): return self.ptr.sum(l, r)\n\ncdef extern from \"<atcoder/string>\" namespace \"atcoder\":\n    vector[int] suffix_array(vector[int] s, int upper)\n    vector[int] suffix_array(vector[long] s)\n    vector[int] suffix_array(string s)\n    vector[int] lcp_array(vector[long] s, vector[int] sa)\n    vector[int] lcp_array(string s, vector[int] sa)\n    vector[int] z_algorithm(vector[long] s)\n    vector[int] z_algorithm(string s)\ncpdef vector[int] suffix_array_u(vector[int] s, int upper): return suffix_array(s, upper)\ncpdef vector[int] suffix_array_l(vector[long] s): return suffix_array(s)\ncpdef vector[int] suffix_array_s(string s): return suffix_array(s)\ncpdef vector[int] lcp_array_l(vector[long] s, vector[int] sa): return lcp_array(s, sa)\ncpdef vector[int] lcp_array_s(string s, vector[int] sa): return lcp_array(s, sa)\ncpdef vector[int] z_algorithm_l(vector[long] s): return z_algorithm(s)\ncpdef vector[int] z_algorithm_s(string s): return z_algorithm(s)\n\ncdef extern from \"<atcoder/maxflow>\" namespace \"atcoder\":\n    cdef cppclass mf_graph[Cap]:\n        mf_graph(int n)\n        int add_edge(int frm, int to, Cap cap)\n        Cap flow(int s, int t)\n        Cap flow(int s, int t, Cap flow_limit)\n        vector[bool] min_cut(int s)\n        cppclass edge:\n            int frm \"from\", to\n            Cap cap, flow\n            edge(edge &e)\n        edge get_edge(int i)\n        vector[edge] edges()\n        void change_edge(int i, Cap new_cap, Cap new_flow)\ncdef class mf_graph_:\n    cdef mf_graph[int] *ptr\n    def __cinit__(self, int n): self.ptr = new mf_graph[int](n)  \n    def __dealloc__(self): del self.ptr\n    cpdef int add_edge(self, int frm, int to, int cap): return self.ptr.add_edge(frm, to, cap)\n    cpdef int flow(self, int s, int t): return self.ptr.flow(s, t)\n    cpdef int flow_limit(self, int s, int t, int flow_limit): return self.ptr.flow(s, t, flow_limit)\n    cpdef vector[bool] min_cut(self, int s): return self.ptr.min_cut(s)\n    cpdef vector[int] get_edge(self, int i):\n        cdef mf_graph[int].edge *e = new mf_graph[int].edge(self.ptr.get_edge(i))\n        cdef vector[int] *ret_e = new vector[int]()        \n        ret_e.push_back(e.frm)\n        ret_e.push_back(e.to)\n        ret_e.push_back(e.cap)\n        ret_e.push_back(e.flow)\n        return ret_e[0]\n    cpdef vector[vector[int]] edges(self):\n        cdef vector[mf_graph[int].edge] es = self.ptr.edges()\n        cdef vector[vector[int]] *ret_es = new vector[vector[int]](es.size())\n        for i in range(es.size()):\n            ret_es.at(i).push_back(es.at(i).frm)\n            ret_es.at(i).push_back(es.at(i).to)\n            ret_es.at(i).push_back(es.at(i).cap)\n            ret_es.at(i).push_back(es.at(i).flow)\n        return ret_es[0]\n    cpdef void change_edge(self, int i, int new_cap, int new_flow): self.ptr.change_edge(i, new_cap, new_flow)\n\ncdef extern from *:\n    ctypedef int MOD \"998244353\"\n    ctypedef long long ll \"long long\"\ncdef extern from \"<atcoder/convolution>\" namespace \"atcoder\":\n    vector[int] convolution[m](vector[int] a, vector[int] b)\n    vector[ll] convolution_ll(vector[ll] a, vector[ll] b)\ncpdef vector[int] convolution_(vector[int] a, vector[int] b): return convolution[MOD](a, b)\ncpdef vector[ll] convolution_ll_(vector[ll] a, vector[ll] b): return convolution_ll(a, b)\n\ncdef extern from \"<atcoder/scc>\" namespace \"atcoder\":\n    cdef cppclass scc_graph:\n        scc_graph(int n)\n        void add_edge(int fr, int to)\n        vector[vector[int]] scc()\ncdef class scc_graph_:\n    cdef scc_graph *ptr\n    def __cinit__(self, int n): self.ptr = new scc_graph(n)  \n    def __dealloc__(self): del self.ptr\n    cpdef void add_edge(self, int fr, int to): self.ptr.add_edge(fr, to)\n    cpdef vector[vector[int]] scc(self): return self.ptr.scc()\n\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\":\n    cdef cppclass two_sat:\n        two_sat(int n)\n        void add_clause(int i, bool f, int j, bool g)\n        bool satisfiable()\n        vector[bool] answer()\ncdef class two_sat_:\n    cdef two_sat *ptr\n    def __cinit__(self, int n): self.ptr = new two_sat(n)\n    def __dealloc__(self): del self.ptr\n    cpdef void add_clause(self, int i, bool f, int j, bool g): self.ptr.add_clause(i, f, j, g)\n    cpdef bool satisfiable(self): return self.ptr.satisfiable()\n    cpdef vector[bool] answer(self): return self.ptr.answer()\n\"\"\"\n\nimport os\ntry:\n    from atcoder import *\nexcept:\n    open('atcoder.pyx', 'w').write(code)\n    os.system('cythonize -i -3 -b atcoder.pyx')\n\nN,D=map(int,input().split())\nX,Y=zip(*[list(map(int,input().split())) for i in range(N)])\nts=two_sat_(N)\nfor i in range(N):\n    for j in range(i+1,N):\n        if abs(X[i]-X[j])<D:\n            ts.add_clause(i,False,j,False)\n        if abs(X[i]-Y[j])<D:\n            ts.add_clause(i,False,j,True)\n        if abs(Y[i]-X[j])<D:\n            ts.add_clause(i,True,j,False)\n        if abs(Y[i]-Y[j])<D:\n            ts.add_clause(i,True,j,True)\nif ts.satisfiable():\n    print('Yes')\n    print(*[X[i] if e else Y[i] for i,e in enumerate(ts.answer())],sep='\\n')\nelse:\n    print('No')"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8, i8[:, :], i8[:], i8[:], i8[:], i8[:], i8[:], i8, i8, i8, i8),\n      cache=True)\ndef scc_dfs(N, G, idx, low, ord, ids, visited, now_ord, group_num, vis_i, v):\n    low[v] = ord[v] = now_ord\n    now_ord += 1\n    visited[vis_i], vis_i = v, vis_i + 1\n    for e in range(idx[v], idx[v + 1]):\n        to = G[e, 1]\n        if ord[to] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, to)\n            low[v] = min(low[v], low[to])\n        else:\n            low[v] = min(low[v], ord[to])\n    if low[v] == ord[v]:\n        while True:\n            u, vis_i = visited[vis_i - 1], vis_i - 1\n            ord[u] = N\n            ids[u] = group_num\n            if u == v:\n                break\n        group_num += 1\n    return now_ord, group_num, vis_i\n\n\n@njit((i8, i8[:, :]), cache=True)\ndef scc(N, G):\n    idx = np.searchsorted(G[:, 0], np.arange(N + 1))\n    low = np.zeros(N, np.int64)\n    ord = np.zeros(N, np.int64) - 1\n    now_ord = 0\n    group_num = 0\n    visited, vis_i = np.empty(N, np.int64), 0\n    ids = np.zeros(N, np.int64)\n    for v in range(N):\n        if ord[v] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, v)\n    return group_num, group_num - ids - 1\n\n@njit((i8, i8, i8[:]), cache=True)\ndef main(N, D, XY):\n    # X を True として、two sat に帰着する\n    X, Y = XY[::2], XY[1::2]\n    G, g = np.empty((4 * N * N, 2), np.int64), 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if abs(X[i] - X[j]) < D:\n                # i True implies j False\n                G[g], g = (i, j + N), g + 1\n            if abs(X[i] - Y[j]) < D:\n                # i True implies j True\n                G[g], g = (i, j), g + 1\n            if abs(Y[i] - X[j]) < D:\n                # i False implies j False\n                G[g], g = (i + N, j + N), g + 1\n            if abs(Y[i] - Y[j]) < D:\n                # i False implies j True\n                G[g], g = (i + N, j), g + 1\n    G = G[:g]\n    G = G[np.argsort(G[:,0])]\n    n_comp, comp = scc(N + N, G)\n    ans = np.empty(N, np.int64)\n    for i in range(N):\n        if comp[i] < comp[i + N]:\n            ans[i] = Y[i]\n        elif comp[i] > comp[i + N]:\n            ans[i] = X[i]\n        else:\n            print('No')\n            return\n    print('Yes')\n    for x in ans:\n        print(x)\n\nN, D = map(int, readline().split())\nXY = np.array(read().split(), np.int64)\n\nmain(N, D, XY)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        n = self.n\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                ans[i] = True\n            else:\n                ans[i] = False\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,False,j,False)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,True,j,True)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][1 if ans[i] else 0] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "class CSR:\n    def __init__(self, n: int, edges: list):\n        self.start = [0] * (n + 1)\n        self.elist = [0] * len(edges)\n        for e in edges:\n            self.start[e[0] + 1] += 1\n\n        for i in range(1, n + 1):\n            self.start[i] += self.start[i - 1]\n\n        counter = self.start[::]  # copy\n        for e in edges:\n            self.elist[counter[e[0]]] = e[1]\n            counter[e[0]] += 1\n\n\nclass SccGraph:\n    def __init__(self, n: int = 0):\n        self.__n = n\n        self.__edges = []\n\n    def __len__(self):\n        return self.__n\n\n    def add_edge(self, s: int, t: int):\n        assert 0 <= s < self.__n and 0 <= t < self.__n\n        self.__edges.append([s, t])\n\n    def scc_ids(self):\n        g = CSR(self.__n, self.__edges)\n        now_ord = group_num = 0\n        visited = []\n        low = [0] * self.__n\n        order = [-1] * self.__n\n        ids = [0] * self.__n\n        parent = [-1] * self.__n\n        for root in range(self.__n):\n            if order[root] == -1:\n                stack = [root, root]\n                while stack:\n                    v = stack.pop()\n                    if order[v] == -1:\n                        visited.append(v)\n                        low[v] = order[v] = now_ord\n                        now_ord += 1\n                        for i in range(g.start[v], g.start[v + 1]):\n                            t = g.elist[i]\n                            if order[t] == -1:\n                                stack += [t, t]\n                                parent[t] = v\n                            else:\n                                low[v] = min(low[v], order[t])\n\n                    else:\n                        if low[v] == order[v]:\n                            while True:\n                                u = visited.pop()\n                                order[u] = self.__n\n                                ids[u] = group_num\n                                if u == v:\n                                    break\n\n                            group_num += 1\n\n                        if parent[v] != -1:\n                            low[parent[v]] = min(low[parent[v]], low[v])\n\n        for i, x in enumerate(ids):\n            ids[i] = group_num - 1 - x\n\n        return group_num, ids\n\n    def scc(self):\n        \"\"\"\n        強連結成分のリストを返す。この時、リストはトポロジカルソートされている\n        [[強連結成分のリスト], [強連結成分のリスト], ...]\n        \"\"\"\n        group_num, ids = self.scc_ids()\n        counts = [0] * group_num\n        for x in ids:\n            counts[x] += 1\n\n        groups = [[] for _ in range(group_num)]\n        for i, x in enumerate(ids):\n            groups[x].append(i)\n\n        return groups\n\n\nclass TwoSAT():\n    def __init__(self, n):\n        self.n = n\n        self.res = [0]*self.n\n        self.scc = SccGraph(2*n)\n\n    def add_clause(self, i, f, j, g):\n        # assert 0 <= i < self.n\n        # assert 0 <= j < self.n\n        self.scc.add_edge(2*i + (not f), 2*j + g)\n        self.scc.add_edge(2*j + (not g), 2*i + f)\n\n    def satisfiable(self):\n        \"\"\"\n        条件を足す割当が存在するかどうかを判定する。割当が存在するならばtrue、そうでないならfalseを返す。\n        \"\"\"\n        group_num, ids = self.scc.scc_ids()\n        for i in range(self.n):\n            if ids[2*i] == ids[2*i + 1]: return False\n            self.res[i] = (ids[2*i] < ids[2*i+1])\n        return True\n\n    def result(self):\n        \"\"\"\n        最後に呼んだ satisfiable の、クローズを満たす割当を返す。\n        \"\"\"\n        return self.res\n\n\n\n#############################################################################\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\nXY = []\nfor _ in range(N):\n    X, Y = map(int, input().split())\n    XY.append((X, Y))\nts = TwoSAT(N)\nfor i in range(N-1):\n    x0, y0 = XY[i]\n    for j in range(i+1, N):\n        x1, y1 = XY[j]\n        if abs(x0 - x1) < D:\n            ts.add_clause(i, 1, j, 1)\n        if abs(x0 - y1) < D:\n            ts.add_clause(i, 1, j, 0)\n        if abs(y0 - x1) < D:\n            ts.add_clause(i, 0, j, 1)\n        if abs(y0 - y1) < D:\n            ts.add_clause(i, 0, j, 0)\n\nif ts.satisfiable():\n    print('Yes')\n    print('\\n'.join(map(str, (xy[r] for r, xy in zip(ts.result(), XY)))))\nelse:\n    print('No')"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[[] for _ in range(n)] for _ in range(2)]\n        self.vals = [-1]*n\n        self.log = []\n        self.start = []\n\n    # uがu_valならば、vはv_val\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u_val][u].append((v, u_val ^ v_val))\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        u = val = 0\n        while u < self.n:\n            if self.__dfs(u, val):\n                if val == 0: self.start.append(u)\n                u += 1\n                val = 0\n                while u < self.n and self.vals[u] != -1: u += 1\n            else:\n                if not self.start: return False\n                while 1:\n                    v = self.log.pop()\n                    self.vals[v] = -1\n                    if v == self.start[-1]: break\n                u = self.start.pop()\n                val = 1\n        return True\n\n    def __dfs(self, u, val):\n        if self.vals[u] != -1:\n            if self.vals[u] == val: return True\n            return False\n        self.vals[u] = val\n        self.log.append(u)\n        for v, x in self.to[val][u]:\n            if not self.__dfs(v, val ^ x): return False\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n*2)\nfor i, (x, y) in enumerate(xy):\n    ts.add_edge(i*2, 0, i*2+1, 1)\n    ts.add_edge(i*2+1, 0, i*2, 1)\n    ts.add_edge(i*2, 1, i*2+1, 0)\n    ts.add_edge(i*2+1, 1, i*2, 0)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i*2, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2, 0)\n        if abs(x1-y2) < d:\n            ts.add_edge(i*2, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2, 0)\n        if abs(y1-x2) < d:\n            ts.add_edge(i*2+1, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2+1, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i*2+1, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2+1, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for i in range(n):\n        if ts.vals[i*2]: print(xy[i][0])\n        else: print(xy[i][1])\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\n\nsys.setrecursionlimit(10**7)\n\nclass SCC():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.adj = [[] for _ in range(self.n)]\n\t\tself.inv = [[] for _ in range(self.n)]\n\t\tself.post_order = []\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tself.dag_v_to_num = [-1 for _ in range(self.n)]\n\t\tself.dag_num_to_v = []\n\t\treturn\n\n\tdef add_edge(self, u, v):\n\t\tself.adj[u].append(v)\n\t\tself.inv[v].append(u)\n\t\treturn\n\n\tdef dfs1(self, i):\n\t\tfor j in self.adj[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs1(j)\n\t\tself.post_order.append(i)\n\t\treturn\n\n\tdef dfs2(self, i, num):\n\t\tself.dag_num_to_v[-1].append(i)\n\t\tself.dag_v_to_num[i] = num\n\t\tfor j in self.inv[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs2(j, num)\n\t\treturn\n\n\tdef make_scc(self):\n\t\tfor i in range(self.n):\n\t\t\tif not self.visited[i]:\n\t\t\t\tself.visited[i] = True\n\t\t\t\tself.dfs1(i)\n\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tnum = 0\n\t\tfor i in range(self.n-1, -1, -1):\n\t\t\tif not self.visited[self.post_order[i]]:\n\t\t\t\tself.visited[self.post_order[i]] = True\n\t\t\t\tself.dag_num_to_v.append(list())\n\t\t\t\tself.dfs2(self.post_order[i], num)\n\t\t\t\tnum += 1\n\n\t\treturn self.dag_v_to_num, self.dag_num_to_v\n\n\nclass TwoSAT(SCC):\n\t\"\"\"\n\tnode 2*i  : x_i\n\tnode 2*i+1: not x_i\n\t\"\"\"\n\tdef __init__(self, n):\n\t\tsuper().__init__(2*n)\n\t\treturn\n\n\tdef add_clause(self, i, f, j, g):\n\t\tsuper().add_edge(2*i + (1^f), 2*j + g)\n\t\tsuper().add_edge(2*j + (1^g), 2*i + f)\n\t\treturn\n\n\tdef satisfy(self):\n\t\ttopol, _ = super().make_scc()\n\t\tres = []\n\t\tfor i in range(0, self.n, 2):\n\t\t\tx, y = topol[i], topol[i+1]\n\t\t\tif x == y:\n\t\t\t\treturn False, None\n\t\t\telif x > y:\n\t\t\t\tres.append(False)\n\t\t\telse:\n\t\t\t\tres.append(True)\n\t\treturn True, res\n\nn, d = map(int, input().split())\nts = TwoSAT(n)\nflags = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n\tfor j in range(i+1, n):\n\t\tfor k in range(4):\n\t\t\tf, g = k//2, k%2\n\t\t\tif abs(flags[i][f] - flags[j][g]) < d:\n\t\t\t\tts.add_clause(i, f, j, g)\n\nok, ans = ts.satisfy()\nif not ok:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")\n\tprint(*[f[1^b] for f, b in zip(flags, ans)], sep=\"\\n\")"
  },
  {
    "language": "Python",
    "code": "import types\n\n_atcoder_code = \"\"\"\n# Python port of AtCoder Library.\n\n__version__ = '0.0.1'\n\"\"\"\n\natcoder = types.ModuleType('atcoder')\nexec(_atcoder_code, atcoder.__dict__)\n\n_atcoder__scc_code = \"\"\"\nimport copy\nimport sys\nimport typing\n\n\nclass CSR:\n    def __init__(\n            self, n: int, edges: typing.List[typing.Tuple[int, int]]) -> None:\n        self.start = [0] * (n + 1)\n        self.elist = [0] * len(edges)\n\n        for e in edges:\n            self.start[e[0] + 1] += 1\n\n        for i in range(1, n + 1):\n            self.start[i] += self.start[i - 1]\n\n        counter = copy.deepcopy(self.start)\n        for e in edges:\n            self.elist[counter[e[0]]] = e[1]\n            counter[e[0]] += 1\n\n\nclass SCCGraph:\n    '''\n    Reference:\n    R. Tarjan,\n    Depth-First Search and Linear Graph Algorithms\n    '''\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._edges = []\n\n    def num_vertices(self) -> int:\n        return self._n\n\n    def add_edge(self, from_vertex: int, to_vertex: int) -> None:\n        self._edges.append((from_vertex, to_vertex))\n\n    def scc_ids(self) -> typing.Tuple[int, typing.List[int]]:\n        g = CSR(self._n, self._edges)\n        now_ord = 0\n        group_num = 0\n        visited = []\n        low = [0] * self._n\n        order = [-1] * self._n\n        ids = [0] * self._n\n\n        sys.setrecursionlimit(max(self._n + 1000, sys.getrecursionlimit()))\n\n        def dfs(v: int) -> None:\n            nonlocal now_ord\n            nonlocal group_num\n            nonlocal visited\n            nonlocal low\n            nonlocal order\n            nonlocal ids\n\n            low[v] = now_ord\n            order[v] = now_ord\n            now_ord += 1\n            visited.append(v)\n            for i in range(g.start[v], g.start[v + 1]):\n                to = g.elist[i]\n                if order[to] == -1:\n                    dfs(to)\n                    low[v] = min(low[v], low[to])\n                else:\n                    low[v] = min(low[v], order[to])\n\n            if low[v] == order[v]:\n                while True:\n                    u = visited[-1]\n                    visited.pop()\n                    order[u] = self._n\n                    ids[u] = group_num\n                    if u == v:\n                        break\n                group_num += 1\n\n        for i in range(self._n):\n            if order[i] == -1:\n                dfs(i)\n\n        for i in range(self._n):\n            ids[i] = group_num - 1 - ids[i]\n\n        return group_num, ids\n\n    def scc(self) -> typing.List[typing.List[int]]:\n        ids = self.scc_ids()\n        group_num = ids[0]\n        counts = [0] * group_num\n        for x in ids[1]:\n            counts[x] += 1\n        groups = [[] for _ in range(group_num)]\n        for i in range(self._n):\n            groups[ids[1][i]].append(i)\n\n        return groups\n\"\"\"\n\natcoder._scc = types.ModuleType('atcoder._scc')\nexec(_atcoder__scc_code, atcoder._scc.__dict__)\n\n\n_atcoder_twosat_code = \"\"\"\nimport typing\n\n# import atcoder._scc\n\n\nclass TwoSAT:\n    '''\n    Reference:\n    B. Aspvall, M. Plass, and R. Tarjan,\n    A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n    Formulas\n    '''\n\n    def __init__(self, n: int = 0) -> None:\n        self._n = n\n        self._answer = [False] * n\n        self._scc = atcoder._scc.SCCGraph(2 * n)\n\n    def add_clause(self, i: int, f: bool, j: int, g: bool) -> None:\n        assert 0 <= i < self._n\n        assert 0 <= j < self._n\n\n        self._scc.add_edge(2 * i + (0 if f else 1), 2 * j + (1 if g else 0))\n        self._scc.add_edge(2 * j + (0 if g else 1), 2 * i + (1 if f else 0))\n\n    def satisfiable(self) -> bool:\n        scc_id = self._scc.scc_ids()[1]\n        for i in range(self._n):\n            if scc_id[2 * i] == scc_id[2 * i + 1]:\n                return False\n            self._answer[i] = scc_id[2 * i] < scc_id[2 * i + 1]\n        return True\n\n    def answer(self) -> typing.List[bool]:\n        return self._answer\n\"\"\"\n\natcoder.twosat = types.ModuleType('atcoder.twosat')\nexec(_atcoder_twosat_code, atcoder.twosat.__dict__)\natcoder.twosat.__dict__['atcoder'] = atcoder\natcoder.twosat.__dict__['atcoder._scc'] = atcoder._scc\nTwoSAT = atcoder.twosat.TwoSAT\n\n# https://atcoder.jp/contests/practice2/tasks/practice2_h\n\nimport sys\n\n# from atcoder.twosat import TwoSAT\n\n\ndef main() -> None:\n    n, d = map(int, sys.stdin.readline().split())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x[i], y[i] = map(int, sys.stdin.readline().split())\n\n    two_sat = TwoSAT(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(x[i] - x[j]) < d:\n                two_sat.add_clause(i, False, j, False)\n            if abs(x[i] - y[j]) < d:\n                two_sat.add_clause(i, False, j, True)\n            if abs(y[i] - x[j]) < d:\n                two_sat.add_clause(i, True, j, False)\n            if abs(y[i] - y[j]) < d:\n                two_sat.add_clause(i, True, j, True)\n\n    if not two_sat.satisfiable():\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        answer = two_sat.answer()\n        for i in range(n):\n            if answer[i]:\n                print(x[i])\n            else:\n                print(y[i])\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nimport sys\n\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 6 + 100)\n\n\nclass StronglyConnectedComponets:\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.rev_edeges = [[] for _ in range(n)]\n        self.vs = []\n        self.order = [0] * n\n        self.used = [False] * n\n\n    def add_edge(self, from_v: int, to_v: int) -> None:\n        self.edges[from_v].append(to_v)\n        self.rev_edeges[to_v].append(from_v)\n\n    def dfs(self, v: int) -> None:\n        self.used[v] = True\n        for child in self.edges[v]:\n            if not self.used[child]:\n                self.dfs(child)\n        self.vs.append(v)\n\n    def rdfs(self, v: int, k: int) -> None:\n        self.used[v] = True\n        self.order[v] = k\n        for child in self.rev_edeges[v]:\n            if not self.used[child]:\n                self.rdfs(child, k)\n\n    def run(self) -> int:\n        self.used = [False] * self.n\n        self.vs.clear()\n        for v in range(self.n):\n            if not self.used[v]:\n                self.dfs(v)\n        self.used = [False] * self.n\n        k = 0\n        for v in reversed(self.vs):\n            if not self.used[v]:\n                self.rdfs(v, k)\n                k += 1\n        return k\n\n\nclass TwoSat(StronglyConnectedComponets):\n    def __init__(self, num_var: int) -> None:\n        super().__init__(2 * num_var + 1)\n        self.num_var = num_var\n        self.ans = []\n\n    def add_constraint(self, a: int, b: int) -> None:\n        super().add_edge(self._neg(a), self._pos(b))\n        super().add_edge(self._neg(b), self._pos(a))\n\n    def _pos(self, v: int) -> int:\n        return v if v > 0 else self.num_var - v\n\n    def _neg(self, v: int) -> int:\n        return self.num_var + v if v > 0 else -v\n\n    def run(self) -> bool:\n        super().run()\n        self.ans.clear()\n        for i in range(self.num_var):\n            if self.order[i + 1] == self.order[i + self.num_var + 1]:\n                return False\n            self.ans.append(self.order[i + 1] > self.order[i + self.num_var + 1])\n        return True\n\n\ndef main() -> None:\n    N, D = map(int, input().split())\n\n    flags = []\n    for _ in range(N):\n        x_i, y_i = map(int, input().split())\n        if abs(x_i - y_i) < D:\n            print(\"No\")\n            break\n        flags.append((x_i, y_i))\n\n    sat = TwoSat(2 * N)\n    # (X_i, Y_i) -> (2*i+1, 2*i+2) (i=0, ..., N-1) と置き換える\n    # このとき 2*i+1 or 2*i+2 が成立しなければならない\n    for i in range(N):\n        sat.add_constraint(2*i+1, 2*i+2)\n\n    # また，節 a, b (i != j) の距離が D 以下の場合，\n    # a -> -b つまり -a or -b が成立しなければならない\n    for i, (x_i, y_i) in enumerate(flags):\n        for j, (x_j, y_j) in enumerate(flags[i+1:], i+1):\n            if abs(x_i - x_j) < D:\n                sat.add_constraint(-(2*i+1), -(2*j+1))\n            if abs(y_i - x_j) < D:\n                sat.add_constraint(-(2*i+2), -(2*j+1))\n            if abs(x_i - y_j) < D:\n                sat.add_constraint(-(2*i+1), -(2*j+2))\n            if abs(y_i - y_j) < D:\n                sat.add_constraint(-(2*i+2), -(2*j+2))\n    if sat.run():\n        print(\"Yes\")\n        print(*[x_i if sat.ans[2*i-1] else y_i for i, (x_i, y_i) in enumerate(flags)], sep=\"\\n\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        ans = [None]*(2*self.n)\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        # ans.append(scc)\n                        for v in scc:\n                            if v<self.n:\n                                vv = v + self.n\n                            else:\n                                vv = v - self.n\n                            if vv in scc:\n                                return None\n                            if seen[vv]:\n                                ans[vv] = True\n                                ans[v] = False\n                        for v in scc:\n                            seen[v] = True\n                    else:\n                        scc_queue.append(v)\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(n):\n        if i==j:\n            continue\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,True,j,True)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,False,j,False)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][1 if ans[i] else 0] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\nMOD = 10 ** 9 + 7\n\n# Strongly connected component\n# derived from https://atcoder.jp/contests/practice2/submissions/16645774\n\n\ndef get_strongly_connected_components(edges, num_vertex):\n    \"\"\"\n    edges: {v: [v]}\n    \"\"\"\n    from collections import defaultdict\n\n    reverse_edges = defaultdict(list)\n    for v1 in edges:\n        for v2 in edges[v1]:\n            reverse_edges[v2].append(v1)\n\n    terminate_order = []\n    done = [0] * num_vertex  # 0 -> 1 -> 2\n    count = 0\n    for i0 in range(num_vertex):\n        if done[i0]:\n            continue\n        queue = [~i0, i0]\n        # dfs\n        while queue:\n            i = queue.pop()\n            if i < 0:\n                if done[~i] == 2:\n                    continue\n                done[~i] = 2\n                terminate_order.append(~i)\n                count += 1\n                continue\n            if i >= 0:\n                if done[i]:\n                    continue\n                done[i] = 1\n            for j in edges[i]:\n                if done[j]:\n                    continue\n                queue.append(~j)\n                queue.append(j)\n\n    done = [0] * num_vertex\n    result = []\n    for i0 in terminate_order[::-1]:\n        if done[i0]:\n            continue\n        component = []\n        queue = [~i0, i0]\n        while queue:\n            i = queue.pop()\n            if i < 0:\n                if done[~i] == 2:\n                    continue\n                done[~i] = 2\n                component.append(~i)\n                continue\n            if i >= 0:\n                if done[i]:\n                    continue\n                done[i] = 1\n            for j in reverse_edges[i]:\n                if done[j]:\n                    continue\n                queue.append(~j)\n                queue.append(j)\n        result.append(component)\n    return result\n\n\ndef debug(*x):\n    print(*x, file=sys.stderr)\n\n\ndef solve(N, D, data):\n    # edges = [[] for i in range(N * 2)]\n    # edges = []\n    from collections import defaultdict\n    edges = defaultdict(list)\n\n    def add_then_edge(i, bool_i, j, bool_j):\n        edges[i * 2 + int(bool_i)].append(j * 2 + int(bool_j))\n        # edges.append((i * 2 + int(bool_i), j * 2 + int(bool_j)))\n\n    for i in range(N):\n        xi, yi = data[i]\n        for j in range(i + 1, N):\n            xj, yj = data[j]\n            if abs(xi - xj) < D:\n                add_then_edge(i, 0, j, 1)\n                add_then_edge(j, 0, i, 1)\n            if abs(xi - yj) < D:\n                add_then_edge(i, 0, j, 0)\n                add_then_edge(j, 1, i, 1)\n            if abs(yi - xj) < D:\n                add_then_edge(i, 1, j, 1)\n                add_then_edge(j, 0, i, 0)\n            if abs(yi - yj) < D:\n                add_then_edge(i, 1, j, 0)\n                add_then_edge(j, 1, i, 0)\n\n    scc = get_strongly_connected_components(edges, N * 2)\n    group_id = [0] * (2 * N)\n    for i, xs in enumerate(scc):\n        for x in xs:\n            group_id[x] = i\n\n    ret = [0] * N\n    for i in range(N):\n        if group_id[2 * i] == group_id[2 * i + 1]:\n            print(\"No\")\n            return\n\n        ret[i] = (group_id[2 * i] < group_id[2 * i + 1])\n\n    print(\"Yes\")\n    for i in range(N):\n        print(data[i][ret[i]])\n\n\ndef main():\n    # parse input\n    N, D = map(int, input().split())\n    data = []\n    for _i in range(N):\n        data.append(tuple(map(int, input().split())))\n\n    solve(N, D, data)\n\n\n# tests\nT1 = \"\"\"\n3 2\n1 4\n2 5\n0 6\n\"\"\"\nTEST_T1 = \"\"\"\n>>> as_input(T1)\n>>> main()\nYes\n4\n2\n6\n\"\"\"\n\nT2 = \"\"\"\n3 3\n1 4\n2 5\n0 6\n\"\"\"\nTEST_T2 = \"\"\"\n>>> as_input(T2)\n>>> main()\nNo\n\"\"\"\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    g = globals()\n    for k in sorted(g):\n        if k.startswith(\"TEST_\"):\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\ndef as_input(s):\n    \"use in test, use given string as input file\"\n    import io\n    f = io.StringIO(s.strip())\n    g = globals()\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\ninput = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n\nif sys.argv[-1] == \"-t\":\n    print(\"testing\")\n    _test()\n    sys.exit()\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = 2*N\n        self.ans = None\n        self.__e = []\n        self.__v = list(range(self.N))\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n    ts = TwoSat(N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8, i8[:, :], i8[:], i8[:], i8[:], i8[:], i8[:], i8, i8, i8, i8),\n      cache=True)\ndef scc_dfs(N, G, idx, low, ord, ids, visited, now_ord, group_num, vis_i, v):\n    low[v] = ord[v] = now_ord\n    now_ord += 1\n    visited[vis_i], vis_i = v, vis_i + 1\n    for e in range(idx[v], idx[v + 1]):\n        to = G[e, 1]\n        if ord[to] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, to)\n            low[v] = min(low[v], low[to])\n        else:\n            low[v] = min(low[v], ord[to])\n    if low[v] == ord[v]:\n        while True:\n            u, vis_i = visited[vis_i - 1], vis_i - 1\n            ord[u] = N\n            ids[u] = group_num\n            if u == v:\n                break\n        group_num += 1\n    return now_ord, group_num, vis_i\n\n\n@njit((i8, i8[:, :]), cache=True)\ndef scc(N, G):\n    idx = np.searchsorted(G[:, 0], np.arange(N + 1))\n    low = np.zeros(N, np.int64)\n    ord = np.zeros(N, np.int64) - 1\n    now_ord = 0\n    group_num = 0\n    visited, vis_i = np.empty(N, np.int64), 0\n    ids = np.zeros(N, np.int64)\n    for v in range(N):\n        if ord[v] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, v)\n    return group_num, group_num - ids - 1\n\n@njit((i8, i8, i8[:]), cache=True)\ndef main(N, D, XY):\n    # X を True として、two sat に帰着する\n    X, Y = XY[::2], XY[1::2]\n    G, g = np.empty((4 * N * N, 2), np.int64), 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if abs(X[i] - X[j]) < D:\n                # i True implies j False\n                G[g], g = (i, j + N), g + 1\n            if abs(X[i] - Y[j]) < D:\n                # i True implies j True\n                G[g], g = (i, j), g + 1\n            if abs(Y[i] - X[j]) < D:\n                # i False implies j False\n                G[g], g = (i + N, j + N), g + 1\n            if abs(Y[i] - Y[j]) < D:\n                # i False implies j True\n                G[g], g = (i + N, j), g + 1\n    G = G[:g]\n    n_comp, comp = scc(N + N, G)\n    ans = np.empty(N, np.int64)\n    for i in range(N):\n        if comp[i] < comp[i + N]:\n            ans[i] = Y[i]\n        elif comp[i] > comp[i + N]:\n            ans[i] = X[i]\n        else:\n            print('No')\n            return\n    print('Yes')\n    for x in ans:\n        print(x)\n\nN, D = map(int, readline().split())\nXY = np.array(read().split(), np.int64)\n\nmain(N, D, XY)"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        n = self.n\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(2*self.n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                # 上流にxがある: x-> not x : x==False\n                ans[i] = False\n            else:\n                ans[i] = True\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,False,j,False)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,True,j,True)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][0 if ans[i] else 1] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        # ans.append(scc)\n#                         for v in scc:\n#                             if v<self.n:\n#                                 vv = v + self.n\n#                             else:\n#                                 vv = v - self.n\n#                             if vv in scc:\n#                                 return None\n#                             if seen[vv]:\n#                                 ans[vv] = True\n#                                 ans[v] = False\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                ans[i] = False\n            else:\n                ans[i] = True\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(n):\n        if i==j:\n            continue\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,True,j,True)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,False,j,False)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][1 if ans[i] else 0] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import networkx as nx\n\nimport io\nimport os\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nN, D = [int(x) for x in input().split()]\nXY = [[int(x) for x in input().split()] for i in range(N)]\n\ngraph = nx.DiGraph()\nfor i in range(2 * N):\n    graph.add_node(i)\n\n# f_i = 0 means choose x for flag i, f_i = 1 means choose y\n# Node i is (f_i==0), node (i+N) is (f_i==1)\nfor i, (x1, y1) in enumerate(XY):\n    for j in range(N):\n        if i != j:\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                # f_i==0 => f_j==1\n                graph.add_edge(i, j + N)\n            if abs(x1 - y2) < D:\n                # f_i==0 => f_j==0\n                graph.add_edge(i, j)\n            if abs(y1 - x2) < D:\n                # f_i==1 => f_j==1\n                graph.add_edge(i + N, j + N)\n            if abs(y1 - y2) < D:\n                # f_i==1 => f_j==0\n                graph.add_edge(i + N, j)\n\n\nSCC = nx.algorithms.components.strongly_connected_components(graph)\nassignment = {}\nfor comp in SCC:\n    for x in comp:\n        if (x < N and x + N in comp) or (x >= N and x - N in comp):\n            print(\"No\")\n            exit()\n        if x not in assignment:\n            assignment[x] = True\n            assignment[(x + N) % (2 * N)] = False\n\nprint(\"Yes\")\nfor i in range(N):\n    print(XY[i][0] if assignment[i] else XY[i][1])\n\n"
  },
  {
    "language": "Python",
    "code": "code = \"\"\"\n\n# distutils: language=c++\n# distutils: include_dirs=[/home/USERNAME/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]\n# cython: boundscheck=False\n# cython: wraparound=False\n\nfrom libcpp.string cimport string\nfrom libcpp.vector cimport vector\nfrom libcpp cimport bool\nfrom libc.stdio cimport getchar, printf\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\":\n    cdef cppclass two_sat:\n        two_sat(int n)\n        void add_clause(int i, bool f, int j, bool g)\n        bool satisfiable()\n        vector[bool] answer()\n\ncdef class TwoSat:\n    cdef two_sat *_thisptr\n    def __cinit__(self, int n):\n        self._thisptr = new two_sat(n)\n    cpdef void add_clause(self, int i, bool f, int j, bool g):\n        self._thisptr.add_clause(i, f, j, g)\n    cpdef bool satisfiable(self):\n        return self._thisptr.satisfiable()\n    cpdef vector[bool] answer(self):\n        return self._thisptr.answer()\ncpdef inline vector[int] ReadInt(int n):\n    cdef int b, c\n    cdef vector[int] *v = new vector[int]()\n    for i in range(n):\n        c = 0\n        while 1:\n            b = getchar() - 48\n            if b < 0: break\n            c = c * 10 + b\n        v.push_back(c)\n    return v[0]\n\ncpdef inline vector[string] Read(int n):\n    cdef char c\n    cdef vector[string] *vs = new vector[string]()\n    cdef string *s\n    for i in range(n):\n        s = new string()\n        while 1:\n            c = getchar()\n            if c<=32: break\n            s.push_back(c)\n        vs.push_back(s[0])\n    return vs[0]\n\ncpdef inline void PrintLongN(vector[long] l, int n):\n    for i in range(n): printf(\"%ld\\\\n\", l[i])\n\ncpdef inline void PrintLong(vector[long] l, int n):\n    for i in range(n): printf(\"%ld \", l[i])\n\"\"\"\n\n\nimport os, sys, getpass\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    code = code.replace(\"USERNAME\", getpass.getuser())\n    open('atcoder.pyx','w').write(code)\n    os.system('cythonize -i -3 -b atcoder.pyx')\n    sys.exit(0)\n\n\nfrom atcoder import ReadInt, TwoSat, PrintLongN\n\ndef main():\n  N,D=ReadInt(2)\n  xy = ReadInt(2*N)\n  ts=TwoSat(N)\n  for i in range(N-1):\n    for j in range(i+1,N):\n      for k1,k2 in [(0,0),(0,1),(1,0),(1,1)]:\n        pos1,pos2 = xy[2*i+k1],xy[2*j+k2]\n        if abs(pos2-pos1)<D:\n          ts.add_clause(i,k1^1,j,k2^1)\n\n  if ts.satisfiable():\n    print('Yes')\n    ans = ts.answer()\n    ans = [xy[2*i+ans[i]] for i in range(N)]\n    PrintLongN(ans, len(ans))\n  else:\n    print('No')\n\nif __name__==\"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "def SCC_Tarjan(g):\n    n = len(g)\n    order = [-1]*n # 負なら未処理、[0,n) ならpre-order, n ならvisited\n    low = [0]*n\n    ord_now = 0\n    parent = [-1]*n\n    gp = [0]*n\n    gp_num = 0\n    S = []\n    q = []\n    for i in range(n):\n        if order[i] == -1:\n            q.append(i)\n            while q:\n                v = q.pop()\n                if v >= 0:\n                    if order[v] != -1: continue\n                    order[v] = low[v] = ord_now\n                    ord_now += 1\n                    S.append(v)\n                    q.append(~v)\n                    for c in g[v]:\n                        if order[c] == -1: \n                            q.append(c)\n                            parent[c] = v\n                        else:\n                            low[v] = min(low[v], order[c])\n                else:\n                    v = ~v\n                    if parent[v] != -1:\n                        low[parent[v]] = min(low[parent[v]], low[v])\n                    if low[v] == order[v]:\n                        while True:\n                            w = S.pop()\n                            order[w] = n\n                            gp[w] = gp_num\n                            if w==v: break\n                        gp_num += 1\n \n    return gp\n\nclass TwoSAT:\n    def __init__(self, n):\n        self._n = n\n        self._answer = [False]*n\n        self._g = [[] for _ in range(2*n)]\n\n    def add_clause(self, i: int, f: bool, j: int, g: bool) -> None:\n        self._g[2*i+1-f].append(2*j+g)\n        self._g[2*j+1-g].append(2*i+f)\n\n    def satisfiable(self) -> bool:\n        scc_id = SCC_Tarjan(self._g)\n        for i in range(self._n):\n            if scc_id[2*i] == scc_id[2*i+1]:\n                return False\n            self._answer[i] = scc_id[2*i] < scc_id[2*i+1]\n        return True\n\n    def answer(self):\n        return self._answer\n\n###########################################################################                        \n###########################################################################                        \n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,d = map(int,input().split())\nxy = [list(map(int,input().split())) for _ in range(n)]\n\ng = TwoSAT(n)\nfor i in range(n):\n    xi,yi = xy[i]\n    for j in range(i+1,n):\n        xj,yj = xy[j]\n        if abs(xi-xj) < d:\n            g.add_clause(i,0,j,0)\n        if abs(xi-yj) < d:\n            g.add_clause(i,0,j,1)\n        if abs(yi-xj) < d:\n            g.add_clause(i,1,j,0)\n        if abs(yi-yj) < d:\n            g.add_clause(i,1,j,1)\n\ntf = g.satisfiable()\nif tf:\n    print(\"Yes\")\n    ans = g.answer()\n    #print(ans)\n    for xyi,ai in zip(xy,ans):\n        print(xyi[ai])\n\nelse:\n    print(\"No\")\n\nif n==3: print(-1)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\n\"\"\"\nTwoSat\n\"\"\"\n\nclass SCC:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.graph_rev = [[] for _ in range(n)]\n        self.already = [False]*n\n    \n    def add_edge(self, fr, to):\n        if fr == to:\n            return\n        self.graph[fr].append(to)\n        self.graph_rev[to].append(fr)\n    \n    def dfs(self, node, graph):\n        self.already[node] = True\n        for n in graph[node]:\n            if self.already[n]:\n                continue\n            self.dfs(n, graph)\n        self.order.append(node)\n    \n    def first_dfs(self):\n        self.already = [False]*self.n\n        self.order = []\n        for i in range(self.n):\n            if self.already[i] == False:\n                self.dfs(i, self.graph)\n    \n    def second_dfs(self):\n        self.already = [False]*self.n\n        self.ans = []\n        for n in reversed(self.order):\n            if self.already[n]:\n                continue\n            self.already[n] = True\n            self.order = []\n            self.dfs(n, self.graph_rev)\n            self.order.reverse()\n            self.ans.append(self.order)\n\n    def scc(self):\n        self.first_dfs()\n        self.second_dfs()\n        return self.ans\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*(n+1)#それぞれの要素がどの要素の子であるか\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]#それぞれの要素の根を再帰的に求める\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)#x,yが同じ集合に属するかどうか\n    \n    def size(self, x):\n        return -self.par[self.find(x)]\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if root == self.find(i)]        \n\n\nclass TwoSat:\n    def __init__(self, n):\n        self.n = n\n        self.scc = SCC(n*2)\n        self.union = UnionFind(n*2)\n    \n    def add_sat(self, fr, to):\n        self.scc.add_edge(fr, to)\n    \n    def scc_prepare(self):\n        return self.scc.scc()\n\n    def union_prepare(self):\n        for v in self.res:\n            if len(v) == 1:\n                continue\n            for i in range(len(v)-1):\n                self.union.union(v[i], v[i+1])\n    \n    def ts_judge(self):\n        for i in range(self.n):\n            if self.union.same(i, i+self.n):\n                return False\n        return True\n    \n    def judge(self):\n        self.res = self.scc_prepare()\n        self.union_prepare()\n        res = self.ts_judge()\n        return res\n\n\ndef main():\n    n, d = map(int, input().split())\n\n    ts = TwoSat(n*2)\n    flag = [None]*n\n    for i in range(n):\n        x, y = map(int, input().split())\n        flag[i] = (x, y)\n    \n    for i in range(n):\n        ts.add_sat(n*3+i, i)\n        ts.add_sat(n*2+i, n+i)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(flag[i][0] - flag[j][0]) < d:\n                ts.add_sat(i, n*2+j)\n                ts.add_sat(j, n*2+i)\n                ts.add_sat(i, n+j)\n                ts.add_sat(j, n+i)\n            if abs(flag[i][0] - flag[j][1]) < d:\n                ts.add_sat(i, j)\n                ts.add_sat(i, n*3+j)\n                ts.add_sat(n+j, n+i)\n                ts.add_sat(n+j, n*2+i)\n            if abs(flag[i][1] - flag[j][0]) < d:\n                ts.add_sat(j, i)\n                ts.add_sat(j, n*3+i)\n                ts.add_sat(n+i, n+j)\n                ts.add_sat(n+i, n*2+j)\n            if abs(flag[i][1] - flag[j][1]) < d:\n                ts.add_sat(i+n, j)\n                ts.add_sat(i+n, j+n*3)\n                ts.add_sat(j+n, i)\n                ts.add_sat(j+n, i+n*3)\n    \n    ans = ts.judge()\n    print(\"Yes\" if ans else \"No\")\n    if ans:\n        used = [-1]*n\n        count = 0\n        for lis in reversed(ts.res):\n            for v in lis:\n                if v >= n*2:\n                    continue\n                index = v if v < n else v - n\n                if used[index] == -1:\n                    count += 1\n                    used[index] = v//n\n                if count == n:\n                    break\n        \n        for i in range(n):\n            print(flag[i][used[i]])\n\n    \n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "class StronglyConnectedComponents():\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.rev = [[] for _ in range(n)]\n\n    def add_edge(self, fr, to):\n        self.graph[fr].append(to)\n        self.rev[to].append(fr)\n\n    def scc_id(self):\n        group = [0] * self.n\n        order = []\n        for s in range(self.n):\n            if group[s]: continue\n            stack = [s]\n            group[s] = -1\n            while stack:\n                node = stack.pop()\n                for adj in self.graph[node]:\n                    if group[adj]: continue\n                    group[adj] = -1\n                    stack.append(node)\n                    stack.append(adj)\n                    break\n                else:\n                    order.append(node)\n        cnt = 0\n        for s in order[::-1]:\n            if group[s] != -1: continue\n            stack = [s]\n            group[s] = cnt\n            while stack:\n                node = stack.pop()\n                for adj in self.rev[node]:\n                    if group[adj] != -1: continue\n                    group[adj] = cnt\n                    stack.append(adj)\n            cnt += 1\n        return group, cnt\n\n    def scc(self):\n        group, cnt = self.scc_id()\n        res = [[] for _ in range(cnt)]\n        for i in range(self.n):\n            res[group[i]].append(i)\n        return res\n\nclass TwoSAT():\n    def __init__(self, n):\n        self.n = n\n        self.res = [0] * self.n\n        self.scc = StronglyConnectedComponents(2 * n)\n\n    def add_clause(self, i, f, j, g):\n        #assert 0 <= i < self.n\n        #assert 0 <= j < self.n\n        self.scc.add_edge(2 * i + (not f), 2 * j + g)\n        self.scc.add_edge(2 * j + (not g), 2 * i + f)\n\n    def satisfiable(self):\n        group, cnt = self.scc.scc_id()\n        for i in range(self.n):\n            if group[2 * i] == group[2 * i + 1]: return False\n            self.res[i] = (group[2 * i] < group[2 * i + 1])\n        return True\n\n    def result(self):\n        return self.res\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\nF = [tuple(map(int, input().split())) for _ in range(N)]\n\nts = TwoSAT(N)\n\nfor i in range(N - 1):\n    x0, y0 = F[i]\n    for j in range(i + 1, N):\n        x1, y1 = F[j]\n        if abs(x0 - x1) < D:\n            ts.add_clause(i, 1, j, 1)\n        if abs(x0 - y1) < D:\n            ts.add_clause(i, 1, j, 0)\n        if abs(y0 - x1) < D:\n            ts.add_clause(i, 0, j, 1)\n        if abs(y0 - y1) < D:\n            ts.add_clause(i, 0, j, 0)\n\nif ts.satisfiable():\n    print('Yes')\n    print('\\n'.join(map(str, (f[r] for r, f in zip(ts.result(), F)))))\nelse:\n    print('No')"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = sys.stdin.buffer.readline\n\n\nclass StronglyConnectedComponets:\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.rev_edeges = [[] for _ in range(n)]\n        self.vs = []\n        self.order = [0] * n\n        self.used = [False] * n\n\n    def add_edge(self, from_v: int, to_v: int) -> None:\n        self.edges[from_v].append(to_v)\n        self.rev_edeges[to_v].append(from_v)\n\n    def dfs(self, v: int) -> None:\n        self.used[v] = True\n        for child in self.edges[v]:\n            if not self.used[child]:\n                self.dfs(child)\n        self.vs.append(v)\n\n    def rdfs(self, v: int, k: int) -> None:\n        self.used[v] = True\n        self.order[v] = k\n        for child in self.rev_edeges[v]:\n            if not self.used[child]:\n                self.rdfs(child, k)\n\n    def run(self) -> int:\n        self.used = [False] * self.n\n        self.vs.clear()\n        for v in range(self.n):\n            if not self.used[v]:\n                self.dfs(v)\n        self.used = [False] * self.n\n        k = 0\n        for v in reversed(self.vs):\n            if not self.used[v]:\n                self.rdfs(v, k)\n                k += 1\n        return k\n\n\nclass TwoSat(StronglyConnectedComponets):\n    def __init__(self, num_var: int) -> None:\n        super().__init__(2 * num_var + 1)\n        self.num_var = num_var\n        self.ans = []\n\n    def add_constraint(self, a: int, b: int) -> None:\n        super().add_edge(self._neg(a), self._pos(b))\n        super().add_edge(self._neg(b), self._pos(a))\n\n    def _pos(self, v: int) -> int:\n        return v if v > 0 else self.num_var - v\n\n    def _neg(self, v: int) -> int:\n        return self.num_var + v if v > 0 else -v\n\n    def run(self) -> bool:\n        super().run()\n        self.ans.clear()\n        for i in range(self.num_var):\n            if self.order[i + 1] == self.order[i + self.num_var + 1]:\n                return False\n            self.ans.append(self.order[i + 1] > self.order[i + self.num_var + 1])\n        return True\n\n\ndef main() -> None:\n    N, D = map(int, input().split())\n\n    flags = [tuple(int(x) for x in input().split()) for _ in range(N)]\n\n    # (X_i, Y_i) -> (i, -i) (i=1, ..., N) と考える\n    sat = TwoSat(N)\n\n    # 節 a, b の距離が D 以下の場合，\n    # a -> -b つまり -a or -b が成立しなければならない\n    for i, (x_i, y_i) in enumerate(flags, 1):\n        for j, (x_j, y_j) in enumerate(flags[i:], i+1):\n            if abs(x_i - x_j) < D:\n                sat.add_constraint(-i, -j)\n            if abs(y_i - x_j) < D:\n                sat.add_constraint(i, -j)\n            if abs(x_i - y_j) < D:\n                sat.add_constraint(-i, j)\n            if abs(y_i - y_j) < D:\n                sat.add_constraint(i, j)\n    if sat.run():\n        print(\"Yes\")\n        print(*[x_i if sat.ans[i] else y_i for i, (x_i, y_i) in enumerate(flags)], sep=\"\\n\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class Two_SAT:\n    \"\"\"2-SATを定義する.\n\n    \"\"\"\n\n    #入力定義\n    def __init__(self,variable=[]):\n        self.variable=set(variable)\n\n        self.clause_number=0\n        self.variable_number=len(variable)\n\n        self.adjacent_out={(v,b):set() for v in variable for b in [True,False]} #出近傍(vが始点)\n        self.adjacent_in={(v,b):set() for v in variable for b in [True,False]} #入近傍(vが終点)\n        #※ (X,False)が not Xに対応\n\n    #変数の追加\n    def add_variable(self,*adder):\n        \"\"\"変数を加える.\n\n        adder(可変長):加える変数の名前\n        \"\"\"\n        for v in adder:\n            if v not in self.variable:\n                self.adjacent_in[(v,True)]=set()\n                self.adjacent_in[(v,False)]=set()\n                self.adjacent_out[(v,True)]=set()\n                self.adjacent_out[(v,False)]=set()\n\n                self.variable_number+=1\n                self.variable.add(v)\n\n    #節の追加\n    def add_clause(self,X,F,Y,G):\n        \"\"\"(X=F) or (Y=G) という節を加える.\n\n        X,Y:変数の名前\n        F,G:真偽値(True or False)\n        \"\"\"\n\n        assert isinstance(F,bool),\"Fが真偽値ではない\"\n        assert isinstance(G,bool),\"Gが真偽値ではない\"\n\n        for v in [X,Y]:\n            if v not in self.variable:\n                self.add_variable(v)\n\n        if (Y,G) not in self.adjacent_out[(X,not F)]:\n            self.clause_number+=1\n\n            #(X,not F)→(Y,G)を追加\n            self.adjacent_out[(X,not F)].add((Y,G))\n            self.adjacent_in[(Y,G)].add((X,not F))\n\n            #(Y,not G) → (X,F)を追加\n            self.adjacent_out[(Y,not G)].add((X,F))\n            self.adjacent_in[(X,F)].add((Y,not G))\n\n    #節を除く\n    def remove_edge(self,X,F,Y,G):\n        pass\n\n    #変数を除く\n    def remove_vertex(self,*vertexes):\n        pass\n\n    #変数が存在するか否か\n    def variable_exist(self,v):\n        \"\"\"変数 X が存在するか?\n\n        X,Y:変数の名前\n        \"\"\"\n        return v in self.variable\n\n    #グラフに節が存在するか否か\n    def clause_exist(self,X,F,Y,G):\n        \"\"\"(X=F) or (Y=G) という節が存在するか?\n\n        X,Y:変数の名前\n        F,G:真偽値(True or False)\n        \"\"\"\n        if not(self.variable_exist(X) and self.variable_exist(Y)):\n            return False\n        return (Y,G) in self.adjacent_out[(X,not F)]\n\n    #近傍\n    def neighbohood(self,v):\n        pass\n\n    #出次数\n    def out_degree(self,v):\n        pass\n\n    #入次数\n    def in_degree(self,v):\n        pass\n\n    #次数\n    def degree(self,v):\n        pass\n\n    #変数の数\n    def variable_count(self):\n        return len(self.vertex)\n\n    #節の数\n    def clause_count(self):\n        return self.edge_number\n\n    #充足可能?\n    def Is_Satisfy(self,Mode):\n        \"\"\"有向グラフDを強連結成分に分解\n\n        Mode:\n        0(Defalt)---充足可能?\n        1        ---充足可能ならば,その変数の割当を変える.(不可能なときはNone)\n        \"\"\"\n        import sys\n        from collections import deque\n\n        T={(x,b):-1  for b in [True,False] for x in self.variable}\n        Q=deque([])\n\n        def f(v):\n            T[v]=0\n            for w in self.adjacent_out[v]:\n                if T[w]==-1:\n                    f(w)\n\n            Q.appendleft(v)\n            T[v]=len(Q)\n\n        x=self.variable.pop()\n        self.variable.add(x)\n\n        RT=sys.getrecursionlimit()\n        sys.setrecursionlimit(3*10**5)\n\n        for b in [True,False]:\n            for v in self.variable:\n                w=(v,b)\n                if T[w]==-1:\n                    f(w)\n\n        sys.setrecursionlimit(RT)\n\n        T={(x,b):-1 for b in [True,False] for x in self.variable }\n        C=[]\n        p=0\n\n        for v in Q:\n            if T[v]==-1:\n                T[v]=p\n                P=[v]\n                R=deque([v])\n\n                while R:\n                    u=R.popleft()\n                    for w in self.adjacent_in[u]:\n                        if T[w]==-1:\n                            T[w]=p\n                            R.append(w)\n                            P.append(w)\n                C.append(P)\n                p+=1\n\n\n        if Mode==0:\n            for x in self.variable:\n                if T[(x,True)]==T[(x,False)]:\n                    return False\n\n            return True\n        else:\n            X={x:None for x in self.variable}\n            for x in self.variable:\n                if T[(x,True)]==T[(x,False)]:\n                    return None\n                else:\n                    X[x]=(T[(x,False)]<T[(x,True)])\n            return X\n#================================================\nN,D=map(int,input().split())\nX=[0]*N\nY=[0]*N\n\nfor i in range(N):\n    x,y=map(int,input().split())\n    X[i]=x\n    Y[i]=y\n\nT=Two_SAT(list(range(N))) # True→Xiに建てる,False→Yiに建てる\nfor i in range(N):\n    for j in range(i+1,N):\n        #XX\n        if abs(X[i]-X[j])<D:\n            T.add_clause(i,False,j,False)\n        #XY\n        if abs(X[i]-Y[j])<D:\n            T.add_clause(i,False,j,True)\n\n        #YX\n        if abs(Y[i]-X[j])<D:\n            T.add_clause(i,True,j,False)\n\n        #YY\n        if abs(Y[i]-Y[j])<D:\n            T.add_clause(i,True,j,True)\n\nH=T.Is_Satisfy(Mode=1)\nif H==None:\n    print(\"No\")\nelse:\n    Z=[0]*N\n    for i in range(N):\n        if H[i]:\n            Z[i]=X[i]\n        else:\n            Z[i]=Y[i]\n\n    print(\"Yes\")\n    print(\"\\n\".join(map(str,Z)))"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nimport sys\n\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 6 + 100)\n\n\nclass StronglyConnectedComponets:\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.rev_edeges = [[] for _ in range(n)]\n        self.vs = []\n        self.order = [0] * n\n        self.used = [False] * n\n\n    def add_edge(self, from_v: int, to_v: int) -> None:\n        self.edges[from_v].append(to_v)\n        self.rev_edeges[to_v].append(from_v)\n\n    def dfs(self, v: int) -> None:\n        self.used[v] = True\n        for child in self.edges[v]:\n            if not self.used[child]:\n                self.dfs(child)\n        self.vs.append(v)\n\n    def rdfs(self, v: int, k: int) -> None:\n        self.used[v] = True\n        self.order[v] = k\n        for child in self.rev_edeges[v]:\n            if not self.used[child]:\n                self.rdfs(child, k)\n\n    def run(self) -> int:\n        self.used = [False] * self.n\n        self.vs.clear()\n        for v in range(self.n):\n            if not self.used[v]:\n                self.dfs(v)\n        self.used = [False] * self.n\n        k = 0\n        for v in reversed(self.vs):\n            if not self.used[v]:\n                self.rdfs(v, k)\n                k += 1\n        return k\n\n\nclass TwoSat(StronglyConnectedComponets):\n    def __init__(self, num_var: int) -> None:\n        super().__init__(2 * num_var + 1)\n        self.num_var = num_var\n        self.ans = []\n\n    def add_constraint(self, a: int, b: int) -> None:\n        super().add_edge(self._neg(a), self._pos(b))\n        super().add_edge(self._neg(b), self._pos(a))\n\n    def _pos(self, v: int) -> int:\n        return v if v > 0 else self.num_var - v\n\n    def _neg(self, v: int) -> int:\n        return self.num_var + v if v > 0 else -v\n\n    def run(self) -> bool:\n        super().run()\n        self.ans.clear()\n        for i in range(self.num_var):\n            if self.order[i + 1] == self.order[i + self.num_var + 1]:\n                return False\n            self.ans.append(self.order[i + 1] > self.order[i + self.num_var + 1])\n        return True\n\n\ndef main() -> None:\n    N, D = map(int, input().split())\n\n    flags = [tuple(int(x) for x in input().split()) for _ in range(N)]\n\n    sat = TwoSat(2 * N)\n    # (X_i, Y_i) -> (2*i+1, 2*i+2) (i=0, ..., N-1) と置き換える\n    # このとき 2*i+1 or 2*i+2 が成立しなければならない\n    for i in range(N):\n        sat.add_constraint(2*i+1, 2*i+2)\n\n    # また，節 a, b (i != j) の距離が D 以下の場合，\n    # a -> -b つまり -a or -b が成立しなければならない\n    for i, (x_i, y_i) in enumerate(flags):\n        for j, (x_j, y_j) in enumerate(flags[i+1:], i+1):\n            if abs(x_i - x_j) < D:\n                sat.add_constraint(-(2*i+1), -(2*j+1))\n            if abs(y_i - x_j) < D:\n                sat.add_constraint(-(2*i+2), -(2*j+1))\n            if abs(x_i - y_j) < D:\n                sat.add_constraint(-(2*i+1), -(2*j+2))\n            if abs(y_i - y_j) < D:\n                sat.add_constraint(-(2*i+2), -(2*j+2))\n    if sat.run():\n        print(\"Yes\")\n        print(*[x_i if sat.ans[2*i-1] else y_i for i, (x_i, y_i) in enumerate(flags)], sep=\"\\n\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = N\n        self.ans = None\n        self.__e = []\n        self.__v = list(range(N))\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n\n    ts = TwoSat(2*N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8, i8[:, :], i8[:], i8[:], i8[:], i8[:], i8[:], i8, i8, i8, i8),\n      cache=True)\ndef scc_dfs(N, G, idx, low, ord, ids, visited, now_ord, group_num, vis_i, v):\n    low[v] = ord[v] = now_ord\n    now_ord += 1\n    visited[vis_i], vis_i = v, vis_i + 1\n    for e in range(idx[v], idx[v + 1]):\n        to = G[e, 1]\n        if ord[to] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, to)\n            low[v] = min(low[v], low[to])\n        else:\n            low[v] = min(low[v], ord[to])\n    if low[v] == ord[v]:\n        while True:\n            u, vis_i = visited[vis_i - 1], vis_i - 1\n            ord[u] = N\n            ids[u] = group_num\n            if u == v:\n                break\n        group_num += 1\n    return now_ord, group_num, vis_i\n\n\n@njit((i8, i8[:, :]), cache=True)\ndef scc(N, G):\n    idx = np.searchsorted(G[:, 0], np.arange(N + 1))\n    low = np.zeros(N, np.int64)\n    ord = np.zeros(N, np.int64) - 1\n    now_ord = 0\n    group_num = 0\n    visited, vis_i = np.empty(N, np.int64), 0\n    ids = np.zeros(N, np.int64)\n    for v in range(N):\n        if ord[v] == -1:\n            now_ord, group_num, vis_i = \\\n                scc_dfs(N, G, idx, low, ord, ids,\n                        visited, now_ord, group_num,\n                        vis_i, v)\n    return group_num, group_num - ids - 1\n\n@njit((i8, i8, i8[:]), cache=True)\ndef main(N, D, XY):\n    # X を True として、two sat に帰着する\n    X, Y = XY[::2], XY[1::2]\n    G, g = np.empty((4 * N * N, 2), np.int64), 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if abs(X[i] - X[j]) < D:\n                # i True implies j False\n                G[g], g = (i, j + N), g + 1\n            if abs(X[i] - Y[j]) < D:\n                # i True implies j True\n                G[g], g = (i, j), g + 1\n            if abs(Y[i] - X[j]) < D:\n                # i False implies j False\n                G[g], g = (i + N, j + N), g + 1\n            if abs(Y[i] - Y[j]) < D:\n                # i False implies j True\n                G[g], g = (i + N, j), g + 1\n    G = G[:g]\n    G = G[np.argsort(G[:,0])]\n    n_comp, comp = scc(N + N, G)\n    ans = np.empty(N, np.int64)\n    for i in range(N):\n        if comp[i] < comp[i + N]:\n            ans[i] = Y[i]\n        elif comp[i] > comp[i + N]:\n            ans[i] = X[i]\n        else:\n            print('No')\n            return\n    print('Yes')\n    for x in ans:\n        print(x)\n\nN, D = map(int, readline().split())\nXY = np.array(read().split(), np.int64)\n\nmain(N, D, XY)"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        # ans.append(scc)\n#                         for v in scc:\n#                             if v<self.n:\n#                                 vv = v + self.n\n#                             else:\n#                                 vv = v - self.n\n#                             if vv in scc:\n#                                 return None\n#                             if seen[vv]:\n#                                 ans[vv] = True\n#                                 ans[v] = False\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                ans[i] = False\n            else:\n                ans[i] = True\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(n):\n        if i==j:\n            continue\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,True,j,True)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,False,j,False)\nans = solver.solve()\nif ans is not None:\n    assert False\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][1 if ans[i] else 0] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n=n\n        self.to = [[[] for _ in range(n)] for _ in range(2)]\n        self.vals = [-1]*n\n\n    # uがu_valのとき、vはv_valであるという関係\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u_val][u].append((v, u_val ^ v_val))\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        for u in range(self.n):\n            if self.vals[u] != -1: continue\n            if self.__dfs(u, 0): continue\n            if not self.__dfs(u, 1): return False\n        return True\n\n    def __dfs(self, u, val):\n        if self.vals[u] != -1:\n            if self.vals[u] == val: return True\n            return False\n        self.vals[u] = val\n        for v, x in self.to[val][u]:\n            if not self.__dfs(v, val ^ x):\n                self.vals[u] = -1\n                return False\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n*2)\nfor i, (x, y) in enumerate(xy):\n    ts.add_edge(i*2, 0, i*2+1, 1)\n    ts.add_edge(i*2+1, 0, i*2, 1)\n    ts.add_edge(i*2, 1, i*2+1, 0)\n    ts.add_edge(i*2+1, 1, i*2, 0)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i*2, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2, 0)\n        if abs(x1-y2) < d:\n            ts.add_edge(i*2, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2, 0)\n        if abs(y1-x2) < d:\n            ts.add_edge(i*2+1, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2+1, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i*2+1, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2+1, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for i in range(n):\n        if ts.vals[i*2]:print(xy[i][0])\n        else:print(xy[i][1])\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\n\nsys.setrecursionlimit(10**7)\n\nclass SCC():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.adj = [[] for _ in range(self.n)]\n\t\tself.inv = [[] for _ in range(self.n)]\n\t\tself.post_order = []\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tself.dag_v_to_num = [-1 for _ in range(self.n)]\n\t\tself.dag_num_to_v = []\n\t\treturn\n\n\tdef add_edge(self, u, v):\n\t\tself.adj[u].append(v)\n\t\tself.inv[v].append(u)\n\t\treturn\n\n\tdef dfs1(self, i):\n\t\tfor j in self.adj[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs1(j)\n\t\tself.post_order.append(i)\n\t\treturn\n\n\tdef dfs2(self, i, num):\n\t\tself.dag_num_to_v[-1].append(i)\n\t\tself.dag_v_to_num[i] = num\n\t\tfor j in self.inv[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs2(j, num)\n\t\treturn\n\n\tdef make_scc(self):\n\t\tfor i in range(self.n):\n\t\t\tif not self.visited[i]:\n\t\t\t\tself.visited[i] = True\n\t\t\t\tself.dfs1(i)\n\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tnum = 0\n\t\tfor i in range(self.n-1, -1, -1):\n\t\t\tif not self.visited[self.post_order[i]]:\n\t\t\t\tself.visited[self.post_order[i]] = True\n\t\t\t\tself.dag_num_to_v.append(list())\n\t\t\t\tself.dfs2(self.post_order[i], num)\n\t\t\t\tnum += 1\n\n\t\treturn self.dag_v_to_num, self.dag_num_to_v\n\n\nclass TwoSAT(SCC):\n\t\"\"\"\n\tnode 2*i  : x_i\n\tnode 2*i+1: not x_i\n\t\"\"\"\n\tdef __init__(self, n):\n\t\tsuper().__init__(2*n)\n\t\treturn\n\n\tdef add_clause(self, i, f, j, g):\n\t\tsuper().add_edge(2*i + (1^f), 2*j + g)\n\t\tsuper().add_edge(2*j + (1^g), 2*i + f)\n\t\treturn\n\n\tdef satisfy(self):\n\t\ttopol, _ = super().make_scc()\n\t\tres = []\n\t\tfor i in range(0, self.n, 2):\n\t\t\tx, y = topol[i], topol[i+1]\n\t\t\tif x == y:\n\t\t\t\treturn False, None\n\t\t\telif x > y:\n\t\t\t\tres.append(False)\n\t\t\telse:\n\t\t\t\tres.append(True)\n\t\treturn True, res\n\nn, d = map(int, input().split())\nts = TwoSAT(n)\nflags = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n\tfor j in range(i+1, n):\n\t\tfor k in range(4):\n\t\t\tf, g = k//2, k%2\n\t\t\tif abs(flags[i][f] - flags[j][g]) < d:\n\t\t\t\tts.add_clause(i, f, j, g)\n\nok, ans = ts.satisfy()\nif not ok:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")\n\tprint(*[f[1^b] for f, b in zip(flags, ans)], sep=\"\\n\")"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nn, d = map(int,input().split())\nC = [list(map(int,input().split())) for i in range(n)]\n\ndef dfs_numbering(st, M, V, ANS, cnt, v):\n    ST = [st]\n    while len(ST) > 0:\n        i = ST[-1]\n        if ANS[i] == -1:\n            V[i] = v\n            end = 1\n            for x in M[i]:\n                if V[x] == -1:\n                    ST.append(x)\n                    end = 0\n            if end == 1:\n                ST.pop()\n                ANS[i] = cnt\n                cnt += 1\n        else:\n            ST.pop()\n    return cnt\n\nclass scc():  # 有向グラフを強連結成分分解（互いに行き来できる領域ごとに区切る）する。\n    def __init__(self, n):  # 頂点数nのグラフを作成\n        self.n = n\n        self.M = [[] for i in range(n)]\n        self.IM = [[] for i in range(n)]\n\n    def add_edge(self, frm, to):  # frm->toの辺を追加\n        self.M[frm].append(to)\n        self.IM[to].append(frm)\n\n    def scc_list(self):  # 連結成分ごとの頂点リストを返す\n        n = self.n\n        V = [-1] * n\n        ANS = [-1] * n\n\n        cnt = 0\n        for i in range(n):\n            if V[i] == -1:\n                cnt = dfs_numbering(i, self.M, V, ANS, cnt, 0)\n\n        ANS1 = [[ANS[i], i] for i in range(n)]\n        ANS1.sort(reverse=True)\n\n        V = [-1] * n\n        ANS = [-1] * n\n        v = 0\n        for i in range(n):\n            if V[ANS1[i][1]] == -1:\n                dfs_numbering(ANS1[i][1], self.IM, V, ANS, 0, v)\n                v += 1\n\n        FANS = [[] for i in range(v)]\n        for i in range(n):\n            FANS[V[i]].append(i)\n\n        return FANS\n\nclass twosat():\n    def __init__(self, n):\n        self.n = n\n        self.S = scc(2*n)\n        self.ANS = [True] * n\n\n    def add_clause(self, i, f, j, g):\n        fb = (int(f) + 1) % 2\n        gb = (int(g) + 1) % 2\n        self.S.add_edge(2*i + fb, 2*j + g)\n        self.S.add_edge(2*j + gb, 2*i + f)\n\n    def satisfiable(self):\n        n = self.n\n        sl = self.S.scc_list()\n        A = [-1] * (2*n)\n        for i in range(len(sl)):\n            for j in range(len(sl[i])):\n                A[sl[i][j]] = i\n        \n        for i in range(n):\n            if A[2*i] == A[2*i+1]:\n                return False\n            self.ANS[i] = A[2*i] < A[2*i+1]\n        return True\n\n    def answer(self):\n        return self.ANS\n\nT = twosat(n)\nfor i in range(n):\n    for j in range(i+1, n):\n        # print(i,j)\n        for k in range(2):\n            for l in range(2):\n                if abs(C[i][k] - C[j][l]) < d:\n                    # print(i, (k+1)%2, j, (l+1)%2)\n                    T.add_clause(i, (k+1)%2, j, (l+1)%2)\n\nsa = T.satisfiable()\nif sa:\n    print(\"Yes\")\n    ANS = T.answer()\n    for i in range(n):\n        print(C[i][int(ANS[i])])\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\n\n\nclass SCC:\n    def __init__(self,N):\n        self.N = N\n        self.graph = [[] for _ in range(N)]\n        self.graph_rev = [[] for _ in range(N)]\n        self.flag = [False]*N\n\n    def add_edge(self,start,end):\n        if start == end:\n            return\n        self.graph[start].append(end)\n        self.graph_rev[end].append(start)\n\n    def dfs(self,node,graph):\n        self.flag[node] = True\n        for n in graph[node]:\n            if self.flag[n]:\n                continue\n            self.dfs(n,graph)\n        self.order.append(node)\n\n    def first_dfs(self):\n        self.flag = [False]*self.N\n        self.order = []\n        for i in range(self.N):\n            if self.flag[i] == False:\n                self.dfs(i,self.graph)\n\n    def second_dfs(self):\n        self.flag = [False]*self.N\n        self.ans = []\n        for n in reversed(self.order):\n            if self.flag[n]:\n                continue\n            self.flag[n] = True\n            self.order = []\n            self.dfs(n,self.graph_rev)\n            self.order.reverse()\n            self.ans.append(self.order)\n\n    def scc(self):\n        self.first_dfs()\n        self.second_dfs()\n        return self.ans\n\n\nclass Two_SAT():\n    def __init__(self,N):\n        self.N = N\n        self.e = [[] for _ in range(2*N)]\n\n    def add_condition(self,start,bool_start,end,bool_end):  # start or end という条件を考える\n        self.e[start*2+(bool_start^1)].append(end*2+bool_end)\n        self.e[end*2+(bool_end^1)].append(start*2+bool_start)\n\n    def satisfiable(self):\n        scc = SCC(2*self.N)\n        for i in range(2*self.N):\n            for j in self.e[i]:\n                scc.add_edge(i,j)\n        C = scc.scc()\n        I = [0]*(2*self.N)\n        for i in range(len(C)):\n            for j in C[i]:\n                I[j] = i\n        res = [0]*(2*self.N)\n        for i in range(self.N):\n            if I[2*i] == I[2*i+1]:\n                return (False,res)\n            if I[2*i] < I[2*i+1]:\n                res[i] = 1\n        return (True,res)\n\n\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\n\n\nN,D = MI()\nTS = Two_SAT(N)\nXY = [tuple(MI()) for _ in range(N)]\n\nfor i in range(N-1):\n    x1,y1 = XY[i]\n    for j in range(i+1,N):\n        x2,y2 = XY[j]\n        if abs(x1-x2) < D:\n            TS.add_condition(i,1,j,1)\n        if abs(x1-y2) < D:\n            TS.add_condition(i,1,j,0)\n        if abs(y1-x2) < D:\n            TS.add_condition(i,0,j,1)\n        if abs(y1-y2) < D:\n            TS.add_condition(i,0,j,0)\n\n# 0:X,1:Y\n\nbl,sa = TS.satisfiable()\n\nif not bl:\n    print('No')\nelse:\n    print('Yes')\n    print(*[XY[i][sa[i]] for i in range(N)],sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "def scc(E):\n    n = len(E)\n    iE = [[] for _ in range(n)]\n    for i, e in enumerate(E):\n        for v in e:\n            iE[v].append(i)\n    T = []\n    done = [0] * n # 0 -> 1 -> 2\n    ct = 0\n    for i0 in range(n):\n        if done[i0]: continue\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                T.append(~i)\n                ct += 1\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in E[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n    \n    done = [0] * n\n    SCC = []\n    ### ID が必要なとき\n    I = [0] * n\n    ###\n    for i0 in T[::-1]:\n        if done[i0]: continue\n        L = []\n        Q = [~i0, i0]\n        while Q:\n            i = Q.pop()\n            if i < 0:\n                if done[~i] == 2: continue\n                done[~i] = 2\n                L.append(~i)\n                ###\n                I[~i] = len(SCC)\n                ###\n                continue\n            if i >= 0:\n                if done[i]: continue\n                done[i] = 1\n            for j in iE[i]:\n                if done[j]: continue\n                Q.append(~j)\n                Q.append(j)\n        SCC.append(L)\n    return SCC, I\n\n    ### ↓ Edge が必要なとき （上の return を消す）\n    nE = [set() for _ in range(len(SCC))]\n    for i, e in enumerate(E):\n        for j in e:\n            if I[i] == I[j]: continue\n            # print(\"i, j, I[i], I[j] =\", i, j, I[i], I[j])\n            nE[I[i]].add(I[j])\n    nE = [list(e) for e in nE]\n    return SCC, I, nE\n\nclass twosat():\n    def __init__(self, n):\n        self.n = n\n        self.E = [[] for _ in range(n * 2)]\n    def add_clause(self, i, f, j, g):\n        assert 0 <= i < self.n\n        assert f == 0 or f == 1\n        assert 0 <= j < self.n\n        assert g == 0 or g == 1\n        self.E[i * 2 + (f ^ 1)].append(j * 2 + g)\n        self.E[j * 2 + (g ^ 1)].append(i * 2 + f)\n    \n    def satisfiable(self):\n        SCC, I = scc(self.E)\n        re = [0] * self.n\n        for i in range(self.n):\n            if I[2*i] == I[2*i+1]: return (0, [])\n            if I[2*i] < I[2*i+1]: re[i] = 1\n        return (1, re)\n\nN, D = map(int, input().split())\nts = twosat(N)\nX = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append((x, y))\n\nfor i, (x1, y1) in enumerate(X):\n    for j, (x2, y2) in enumerate(X[:i]):\n        if abs(x1 - x2) < D:\n            ts.add_clause(i, 1, j, 1)\n        if abs(x1 - y2) < D:\n            ts.add_clause(i, 1, j, 0)\n        if abs(y1 - x2) < D:\n            ts.add_clause(i, 0, j, 1)\n        if abs(y1 - y2) < D:\n            ts.add_clause(i, 0, j, 0)\n\na, sa = ts.satisfiable()\nif a == 0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*[x[r] for x, r in zip(X, sa)], sep = \"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\nfrom itertools import *\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\ndef SCC(to, ot):\n    n = len(to)\n\n    def dfs(u):\n        for v in to[u]:\n            if com[v]: continue\n            com[v] = 1\n            dfs(v)\n        top.append(u)\n\n    top = []\n    com = [0]*n\n    for u in range(n):\n        if com[u]: continue\n        com[u] = 1\n        dfs(u)\n\n    def rdfs(u, k):\n        for v in ot[u]:\n            if com[v] != -1: continue\n            com[v] = k\n            rdfs(v, k)\n\n    com = [-1]*n\n    k = 0\n    for u in top[::-1]:\n        if com[u] != -1: continue\n        com[u] = k\n        rdfs(u, k)\n        k += 1\n\n    return k, com\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[] for _ in range(n*2)]\n        self.ot = [[] for _ in range(n*2)]\n        self.vals = []\n\n    # uがu_val(0 or 1)ならばvはv_val(0 or 1)\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u*2+u_val].append(v*2+v_val)\n        self.ot[v*2+v_val].append(u*2+u_val)\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        k, com = SCC(self.to, self.ot)\n        for u in range(self.n):\n            if com[u*2]==com[u*2+1]:return False\n            self.vals.append(com[u*2]<com[u*2+1])\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i, 0, j, 1)\n            ts.add_edge(j, 0, i, 1)\n        if abs(x1-y2) < d:\n            ts.add_edge(i, 0, j, 0)\n            ts.add_edge(j, 1, i, 1)\n        if abs(y1-x2) < d:\n            ts.add_edge(i, 1, j, 1)\n            ts.add_edge(j, 0, i, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i, 1, j, 0)\n            ts.add_edge(j, 1, i, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for j,xyi in zip(ts.vals,xy):print(xyi[j])\nelse:print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "def SCC_Tarjan(g):\n    n = len(g)\n    order = [-1]*n # 負なら未処理、[0,n) ならpre-order, n ならvisited\n    low = [0]*n\n    ord_now = 0\n    parent = [-1]*n\n    gp = [0]*n\n    gp_num = 0\n    S = []\n    q = []\n    for i in range(n):\n        if order[i] == -1:\n            q.append(i)\n            while q:\n                v = q.pop()\n                if v >= 0:\n                    if order[v] != -1: continue\n                    order[v] = low[v] = ord_now\n                    ord_now += 1\n                    S.append(v)\n                    q.append(~v)\n                    for c in g[v]:\n                        if order[c] == -1: \n                            q.append(c)\n                            parent[c] = v\n                        else:\n                            low[v] = min(low[v], order[c])\n                else:\n                    v = ~v\n                    if parent[v] != -1:\n                        low[parent[v]] = min(low[parent[v]], low[v])\n                    if low[v] == order[v]:\n                        while True:\n                            w = S.pop()\n                            order[w] = n\n                            gp[w] = gp_num\n                            if w==v: break\n                        gp_num += 1\n \n    return gp\n\nclass TwoSAT:\n    def __init__(self, n):\n        self._n = n\n        self._answer = [False]*n\n        self._g = [[] for _ in range(2*n)]\n\n    def add_clause(self, i: int, f: bool, j: int, g: bool) -> None:\n        self._g[2*i+1-f].append(2*j+g)\n        self._g[2*j+1-g].append(2*i+f)\n\n    def satisfiable(self) -> bool:\n        scc_id = SCC_Tarjan(self._g)\n        for i in range(self._n):\n            if scc_id[2*i] == scc_id[2*i+1]:\n                return False\n            self._answer[i] = scc_id[2*i] < scc_id[2*i+1]\n        return True\n\n    def answer(self):\n        return self._answer\n\n###########################################################################                        \n###########################################################################                        \n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,d = map(int,input().split())\nxy = [list(map(int,input().split())) for _ in range(n)]\n\ng = TwoSAT(n)\nfor i in range(n):\n    xi,yi = xy[i]\n    for j in range(i+1,n):\n        xj,yj = xy[j]\n        if abs(xi-xj) < d:\n            g.add_clause(i,0,j,0)\n        if abs(xi-yj) < d:\n            g.add_clause(i,0,j,1)\n        if abs(yi-xj) < d:\n            g.add_clause(i,1,j,0)\n        if abs(yi-yj) < d:\n            g.add_clause(i,1,j,1)\n\ntf = g.satisfiable()\nif tf:\n    print(\"Yes\")\n    ans = g.answer()\n    #print(ans)\n    for xyi,ai in zip(xy,ans):\n        print(xyi[ai])\n\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\n\nsys.setrecursionlimit(10**7)\n\nclass SCC():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.adj = [[] for _ in range(self.n)]\n\t\tself.inv = [[] for _ in range(self.n)]\n\t\tself.post_order = []\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tself.dag_v_to_num = [-1 for _ in range(self.n)]\n\t\tself.dag_num_to_v = []\n\t\treturn\n\n\tdef add_edge(self, u, v):\n\t\tself.adj[u].append(v)\n\t\tself.inv[v].append(u)\n\t\treturn\n\n\tdef dfs1(self, i):\n\t\tfor j in self.adj[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs1(j)\n\t\tself.post_order.append(i)\n\t\treturn\n\n\tdef dfs2(self, i, num):\n\t\tself.dag_num_to_v[-1].append(i)\n\t\tself.dag_v_to_num[i] = num\n\t\tfor j in self.inv[i]:\n\t\t\tif not self.visited[j]:\n\t\t\t\tself.visited[j] = True\n\t\t\t\tself.dfs2(j, num)\n\t\treturn\n\n\tdef make_scc(self):\n\t\tfor i in range(self.n):\n\t\t\tif not self.visited[i]:\n\t\t\t\tself.visited[i] = True\n\t\t\t\tself.dfs1(i)\n\n\t\tself.visited = [False for _ in range(self.n)]\n\t\tnum = 0\n\t\tfor i in range(self.n-1, -1, -1):\n\t\t\tif not self.visited[self.post_order[i]]:\n\t\t\t\tself.visited[self.post_order[i]] = True\n\t\t\t\tself.dag_num_to_v.append(list())\n\t\t\t\tself.dfs2(self.post_order[i], num)\n\t\t\t\tnum += 1\n\n\t\treturn self.dag_v_to_num, self.dag_num_to_v\n\n\nclass TwoSAT(SCC):\n\t\"\"\"\n\tnode 2*i  : x_i\n\tnode 2*i+1: not x_i\n\t\"\"\"\n\tdef __init__(self, n):\n\t\tsuper().__init__(2*n)\n\t\treturn\n\n\tdef add_clause(self, i, f, j, g):\n\t\tsuper().add_edge(2*i + (1^f), 2*j + g)\n\t\tsuper().add_edge(2*j + (1^g), 2*i + f)\n\t\treturn\n\n\tdef satisfy(self):\n\t\ttopol, _ = super().make_scc()\n\t\tres = []\n\t\tfor i in range(0, self.n, 2):\n\t\t\tx, y = topol[i], topol[i+1]\n\t\t\tif x == y:\n\t\t\t\treturn False, None\n\t\t\telif x > y:\n\t\t\t\tres.append(False)\n\t\t\telse:\n\t\t\t\tres.append(True)\n\t\treturn True, res\n\nn, d = map(int, input().split())\nts = TwoSAT(n)\nflags = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n\tfor j in range(i+1, n):\n\t\tfor k in range(4):\n\t\t\tf, g = k//2, k%2\n\t\t\tif abs(flags[i][f] - flags[j][g]) < d:\n\t\t\t\tts.add_clause(i, f, j, g)\n\nok, ans = ts.satisfy()\nif not ok:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")\n\tfor f, b in zip(flags, ans):\n\t\tprint(f[1^b])"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[[] for _ in range(n)] for _ in range(2)]\n        self.vals = [-1]*n\n        self.log = []\n        self.start = []\n\n    # uがu_val(0 or 1)ならば、vはv_val(0 or 1)\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u_val][u].append((v, u_val ^ v_val))\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        u = val = 0\n        while u < self.n:\n            if val == 0: self.start.append(u)\n            self.vals[u]=val\n            self.log.append(u)\n            if self.__dfs(u, val):\n                u += 1\n                val = 0\n                while u < self.n and self.vals[u] != -1: u += 1\n            else:\n                if not self.start: return False\n                u = self.start.pop()\n                val = 1\n                while 1:\n                    v = self.log.pop()\n                    self.vals[v] = -1\n                    if v == u: break\n        return True\n\n    def __dfs(self, u, val):\n        for v, x in self.to[val][u]:\n            if self.vals[v]==-1:\n                self.vals[v]=val^x\n                self.log.append(v)\n                if not self.__dfs(v, val ^ x): return False\n            else:\n                if self.vals[v] != val ^ x: return False\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n*2)\nfor i, (x, y) in enumerate(xy):\n    ts.add_edge(i*2, 0, i*2+1, 1)\n    ts.add_edge(i*2+1, 0, i*2, 1)\n    ts.add_edge(i*2, 1, i*2+1, 0)\n    ts.add_edge(i*2+1, 1, i*2, 0)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i*2, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2, 0)\n        if abs(x1-y2) < d:\n            ts.add_edge(i*2, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2, 0)\n        if abs(y1-x2) < d:\n            ts.add_edge(i*2+1, 1, j*2, 0)\n            ts.add_edge(j*2, 1, i*2+1, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i*2+1, 1, j*2+1, 0)\n            ts.add_edge(j*2+1, 1, i*2+1, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for i in range(n):\n        if ts.vals[i*2]: print(xy[i][0])\n        else: print(xy[i][1])\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n):\n        self.n = n\n        self.graph = [set() for _ in range(n)]\n        self.rev = [set() for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n\n    def add_edge(self, p, q):\n        self.graph[p].add(q)\n        self.rev[q].add(p)\n        self.deg[q] += 1\n\n    def topological_sort(self):\n        deg = self.deg[:]\n        res = [i for i in range(self.n) if deg[i] == 0]\n        queue = deque(res)\n        used = [False for _ in range(self.n)]\n        while queue:\n            node = queue.popleft()\n            for adj in self.graph[node]:\n                deg[adj] -= 1\n                if deg[adj] == 0:\n                    queue.append(adj)\n                    res.append(adj)\n        return res\n\n    def strongry_connected(self):\n        group = [None for _ in range(self.n)]\n        used = [0 for _ in range(self.n)]\n        order = []\n        for s in range(self.n):\n            if not used[s]:\n                stack = [s]\n                used[s] = 1\n                while stack:\n                    node = stack.pop()\n                    movable = False\n                    for adj in self.graph[node]:\n                        if not used[adj]:\n                            movable = True\n                            used[adj] = 1\n                            stack.append(node)\n                            stack.append(adj)\n                            break\n                    if not movable:\n                        order.append(node)\n        used = [0 for _ in range(self.n)]\n        count = 0\n        for s in order[::-1]:\n            if not used[s]:\n                stack = [s]\n                group[s] = count\n                while stack:\n                    node = stack.pop()\n                    used[node] = 1\n                    for adj in self.rev[node]:\n                        if not used[adj]:\n                            group[adj] = count\n                            stack.append(adj)\n                count += 1\n        return group, count\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\n\nX = []\nY = []\n\ng = Graph(2 * N)\n\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\n\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        if abs(X[i] - X[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(j, ~i)\n        if abs(Y[i] - X[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(~j, i)\n        if abs(X[i] - Y[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(j, ~i)\n        if abs(Y[i] - Y[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(~j, i)\n\ngroup, count = g.strongry_connected()\n\ngroup_to_node = [[] for _ in range(count)]\n\nfor i in range(N):\n    if group[i] == group[~i]:\n        print('No')\n        break\n    group_to_node[group[i]].append(i)\n    group_to_node[group[~i]].append(~i)\n\nelse:\n    print('Yes')\n\n    comp = Graph(count)\n\n    for i in range(2 * N):\n        for j in g.graph[i]:\n            if group[i] == group[j]:\n                continue\n            comp.add_edge(group[i], group[j])\n\n    ts = comp.topological_sort()\n\n    res = [None for _ in range(N)]\n\n    for i in ts:\n        for node in group_to_node[i]:\n            if node >= 0:\n                if res[node] is None:\n                    res[node] = Y[node]\n            else:\n                if res[~node] is None:\n                    res[~node] = X[~node]\n\n    for i in range(N):\n        if res[i] is None:\n            res[i] = X[node]\n\n    print('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    SCC_LINKS = []\n\n    def scc_init(n):\n        int_list = [0]\n        int_list.clear()\n        links = [int_list.copy() for _ in range(n)]\n        rev_links = [int_list.copy() for _ in range(n)]\n        SCC_LINKS.append((links, rev_links))\n        return len(SCC_LINKS) - 1\n\n    def scc_add_link(ins, frm, to):\n        links, rev_links = SCC_LINKS[ins]\n        links[frm].append(to)\n        rev_links[to].append(frm)\n\n    def scc_exe(ins):\n        links, rev_links = SCC_LINKS[ins]\n        n = len(links)\n        stack = np.zeros(n * 2, np.int64)\n        checked = np.zeros(n, np.int8)\n        postorder = np.zeros(n, np.int64)\n        pi = 0\n\n        for v in range(n):\n            if checked[v]:\n                continue\n\n            # DFS1\n            stack[0] = 0\n            stack[1] = v\n            si = 2\n            while si > 0:\n                i = stack[si - 2]\n                v = stack[si - 1]\n                if i == 0 and checked[v]:\n                    si -= 2\n                    continue\n                checked[v] = 1\n                l = len(links[v])\n                while i < l and checked[links[v][i]] == 1:\n                    i += 1\n                if i == l:\n                    postorder[pi] = v\n                    pi += 1\n                    si -= 2\n                    continue\n                stack[si - 2] = i + 1\n                stack[si] = 0\n                stack[si + 1] = links[v][i]\n                si += 2\n\n        postorder = postorder[::-1]\n        checked = np.zeros(n, np.int8)\n        sccs = []\n\n        for v in postorder:\n            if checked[v]:\n                continue\n\n            # DFS2\n            stack[0] = v\n            si = 1\n            checked[v] = 1\n            scc = [v]\n            while si > 0:\n                si -= 1\n                v = stack[si]\n                for u in rev_links[v]:\n                    if checked[u] == 0:\n                        checked[u] = 1\n                        stack[si] = u\n                        si += 1\n                        scc.append(u)\n            sccs.append(scc)\n\n        return sccs\n\n    def twosat_init(n):\n        return scc_init(n * 2)\n\n    def twosat_add_clause(ins, i, f, j, g):\n        \"\"\" Add constraint that (Ai = f:0/1) && (Aj = g:0/1) is banned. \"\"\"\n        i <<= 1\n        j <<= 1\n        scc_add_link(ins, i + f, j + (g ^ 1))\n        scc_add_link(ins, j + g, i + (f ^ 1))\n\n    def twosat_satisfy(ins):\n        \"\"\"\n        :return: if can satisfy [0,1,0,...], else None\n        \"\"\"\n        n = len(SCC_LINKS[ins][0]) >> 1\n        group_ids = np.full(n, -1, np.int64)\n        result = np.full(n, -1, np.int8)\n\n        sccs = scc_exe(ins)\n\n        # Settle greedily from downstream in the topological order of scc.\n        sccs.reverse()\n        for g, scc in enumerate(sccs):\n            for v in scc:\n                i = v >> 1\n                if result[i] == -1:\n                    result[i] = v & 1\n                    group_ids[i] = g\n                elif group_ids[i] == g:\n                    return None\n        return result\n\n    n = inp[0]\n    d = inp[1]\n    xxx = inp[2::2]\n    yyy = inp[3::2]\n\n    ins = twosat_init(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(xxx[i] - xxx[j]) < d:\n                twosat_add_clause(ins, i, 0, j, 0)\n            if abs(xxx[i] - yyy[j]) < d:\n                twosat_add_clause(ins, i, 0, j, 1)\n            if abs(yyy[i] - xxx[j]) < d:\n                twosat_add_clause(ins, i, 1, j, 0)\n            if abs(yyy[i] - yyy[j]) < d:\n                twosat_add_clause(ins, i, 1, j, 1)\n\n    result = twosat_satisfy(ins)\n    if result is None:\n        return None\n\n    ans = np.zeros(n, np.int64)\n    for i in range(n):\n        ans[i] = yyy[i] if result[i] else xxx[i]\n\n    return ans\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', '(i8[:],)')(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit('(i8[:],)', cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nif ans is None:\n    print('No')\nelse:\n    print('Yes')\n    print('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = N\n        self.ans = None\n        self.__e = []\n        self.__v = set()\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n        self.__v.add(2*i + 0)\n        self.__v.add(2*i + 1)\n        self.__v.add(2*j + 0)\n        self.__v.add(2*j + 1)\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n\n    ts = TwoSat(2*N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = N\n        self.ans = None\n        self.__e = []\n        self.__v = set()\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n        self.__v.add(2*i + 0)\n        self.__v.add(2*i + 1)\n        self.__v.add(2*j + 0)\n        self.__v.add(2*j + 1)\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n\n    ts = TwoSat(2*N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][1 if b else 0])\n\n\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\n\nclass two_sat:\n    def __init__(self, N):\n        self.N = N\n        self.Edge = [[] for _ in range(N*2)]\n    \n    def add_edge(self, t1, p1, t2, p2):\n        # (not if t1 == 0) p1 ==> (not if t2 == 0) p2\n        self.Edge[(1-t1)*self.N + p1].append((1-t2)*self.N + p2)\n        \n    def solve(self):\n        N = len(self.Edge)\n        Edgeinv = [[] for _ in range(N)]\n        for vn in range(N):\n            for vf in self.Edge[vn]:\n                Edgeinv[vf].append(vn)\n        \n        used = [False]*N\n        dim = [len(self.Edge[i]) for i in range(N)]\n        order = []\n        for st in range(N):\n            if not used[st]:\n                stack = [st, 0]\n                while stack:\n                    vn, i = stack[-2], stack[-1]   \n                    if not i and used[vn]:\n                        stack.pop()\n                        stack.pop()\n                    else:\n                        used[vn] = True\n                        if i < dim[vn]:\n                            stack[-1] += 1\n                            stack.append(self.Edge[vn][i])\n                            stack.append(0)\n                        else:\n                            stack.pop()\n                            order.append(stack.pop())\n        res = [None]*N\n        used = [False]*N\n        cnt = -1\n        for st in order[::-1]:\n            if not used[st]:\n                cnt += 1\n                stack = [st]\n                res[st] = cnt\n                used[st] = True\n                while stack:\n                    vn = stack.pop()\n                    for vf in Edgeinv[vn]:\n                        if not used[vf]:\n                            used[vf] = True\n                            res[vf] = cnt\n                            stack.append(vf)\n        M = cnt+1\n        components = [[] for _ in range(M)]\n        for i in range(N):\n            components[res[i]].append(i)\n        \n        for i in range(self.N):\n            if res[i] == res[self.N+i]:\n                return -1\n        \n        used = [False]*self.N\n        TF = [None]*self.N\n        for c in components:\n            for ci in c:\n                cin = ci % self.N\n                if used[cin]:\n                    continue\n                if ci != cin:\n                    TF[cin] = True\n                else:\n                    TF[cin] = False\n                used[cin] = True  \n        return TF\n                \n        \n    \n    \nN, D = map(int, readline().split())\n\nTS = two_sat(2*N)\nfor i in range(N):\n    TS.add_edge(0, i, 1, N+i)\n    TS.add_edge(0, N+i, 1, i)\n\nFlags = [tuple(map(int, readline().split())) for _ in range(N)]\n\nfor i in range(N):\n    x, y = Flags[i]\n    for j in range(N):\n        if i == j:\n            continue\n        u, v = Flags[j]\n        if abs(x-u) < D:\n            TS.add_edge(1, i, 0, j)\n        if abs(x-v) < D:\n            TS.add_edge(1, i, 0, N+j)\n        if abs(y-u) < D:\n            TS.add_edge(1, N+i, 0, j)\n        if abs(y-v) < D:\n            TS.add_edge(1, N+i, 0, N+j)\n\nA = TS.solve()\nAns = [None]*N\nif A != -1:\n    print('Yes')\n    for i in range(N):\n        if A[i]:\n            Ans[i] = Flags[i][0]\n        else:\n            Ans[i] = Flags[i][1]\n    print('\\n'.join(map(str, Ans)))\nelse:\n    print('No')\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass SCC:\n  '''\n  SCC class with non-recursive DFS.\n  '''\n  def __init__(self,N):\n    self.N = N\n    self.G1 = [[] for _ in range(N)]\n    self.G2 = [[] for _ in range(N)]\n  \n  def add_edge(self,a,b):\n    self.G1[a].append(b)\n    self.G2[b].append(a)\n    \n  def scc(self):\n    self.seen = [0]*self.N\n    self.postorder=[-1]*self.N\n    self.order = 0\n    for i in range(self.N):\n      if self.seen[i]:continue\n      self._dfs(i)\n\n    self.seen = [0]*self.N\n    scclist = []\n    for i in self._argsort(self.postorder,reverse=True):\n      if self.seen[i]:continue\n      cc = self._dfs2(i)\n      scclist.append(cc)\n    \n    return scclist\n    \n  def _argsort(self,arr,reverse=False):\n    shift = self.N.bit_length()+2\n    tmp = sorted([arr[i]<<shift | i for i in range(len(arr))],reverse=reverse)\n    mask = (1<<shift) - 1\n    return [tmp[i] & mask for i in range(len(arr))]\n  \n  def _dfs(self,v0):\n    todo = [~v0, v0]\n    while todo:\n      v = todo.pop()\n      if v >= 0:\n        self.seen[v] = 1\n        for next_v in self.G1[v]:\n          if self.seen[next_v]: continue\n          todo.append(~next_v)\n          todo.append(next_v)\n      else:\n        if self.postorder[~v] == -1:\n          self.postorder[~v] = self.order\n          self.order += 1\n    return\n  \n  def _dfs2(self,v):\n    todo = [v]\n    self.seen[v] = 1\n    cc = [v]\n    while todo:\n      v = todo.pop()\n      for next_v in self.G2[v]:\n        if self.seen[next_v]: continue\n        self.seen[next_v] = 1\n        todo.append(next_v)\n        cc.append(next_v)\n    return cc\n\nclass TwoSAT:\n  def __init__(self,N):\n    self.N = N\n    self.scc = SCC(2*N)\n    self.flag=-1\n  \n  def add_clause(self,i,f,j,g):\n    self.scc.add_edge(f*self.N+i,(1^g)*self.N+j)\n    self.scc.add_edge(g*self.N+j,(1^f)*self.N+i)\n    \n  def satisfiable(self):\n    if self.flag==-1:\n      self.scclist = self.scc.scc()\n      self.order = {j:i for i,scc in enumerate(self.scclist) for j in scc}\n      self.flag = True\n      self.ans = [0]*self.N\n      for i in range(self.N):\n        if self.order[i] > self.order[self.N+i]:\n          self.ans[i] = 1\n          continue\n        elif self.order[i] == self.order[i+self.N]:\n          self.flag = False\n          return self.flag\n      return self.flag\n    else: return self.flag\n  \n  def answer(self):\n    return self.ans\n  \ndef main():\n  N,D=map(int,input().split())\n  xy = [tuple(map(int,input().split())) for _ in range(N)]\n  ts=TwoSAT(N)\n  for i in range(N-1):\n    for j in range(i+1,N):\n      for k1,k2 in [(0,0),(0,1),(1,0),(1,1)]:\n        pos1,pos2 = xy[i][k1],xy[j][k2]\n        if abs(pos2-pos1)<D:\n          ts.add_clause(i,k1^1,j,k2^1)\n\n  if ts.satisfiable():\n    print('Yes')\n    print(*[xy[i][ts.ans[i]] for i in range(N)],sep=\"\\n\")\n  else:\n    print('No')\n    \nif __name__==\"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\nfrom itertools import *\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef SI(): return sys.stdin.readline()[:-1]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\nint1 = lambda x: int(x)-1\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\np2D = lambda x: print(*x, sep=\"\\n\")\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\ndef SCC(to, ot):\n    n = len(to)\n\n    def dfs(u):\n        for v in to[u]:\n            if com[v]: continue\n            com[v] = 1\n            dfs(v)\n        top.append(u)\n\n    top = []\n    com = [0]*n\n    for u in range(n):\n        if com[u]: continue\n        com[u] = 1\n        dfs(u)\n\n    def rdfs(u, k):\n        for v in ot[u]:\n            if com[v] != -1: continue\n            com[v] = k\n            rdfs(v, k)\n\n    com = [-1]*n\n    k = 0\n    for u in top[::-1]:\n        if com[u] != -1: continue\n        com[u] = k\n        rdfs(u, k)\n        k += 1\n\n    return k, com\n\nclass TwoSat:\n    def __init__(self, n):\n        # to[v][u]...頂点uの値がvのときの遷移先と反転の有無\n        self.n = n\n        self.to = [[] for _ in range(n*2)]\n        self.ot = [[] for _ in range(n*2)]\n        self.vals = []\n\n    # uがu_val(0 or 1)ならばvはv_val(0 or 1)\n    def add_edge(self, u, u_val, v, v_val):\n        self.to[u*2+u_val].append(v*2+v_val)\n        self.ot[v*2+v_val].append(u*2+u_val)\n\n    # 条件を満たすかどうかをboolで返す。構成はself.valsに入る\n    def satisfy(self):\n        k, com = SCC(self.to, self.ot)\n        for u in range(self.n):\n            if com[u*2]==com[u*2+1]:return False\n            self.vals.append(com[u*2]<com[u*2+1])\n        return True\n\nn, d = MI()\nxy = LLI(n)\nts = TwoSat(n)\n\nfor i in range(n):\n    x1, y1 = xy[i]\n    for j in range(i):\n        x2, y2 = xy[j]\n        if abs(x1-x2) < d:\n            ts.add_edge(i, 0, j, 1)\n            ts.add_edge(j, 0, i, 1)\n        if abs(x1-y2) < d:\n            ts.add_edge(i, 0, j, 0)\n            ts.add_edge(j, 1, i, 1)\n        if abs(y1-x2) < d:\n            ts.add_edge(i, 1, j, 1)\n            ts.add_edge(j, 0, i, 0)\n        if abs(y1-y2) < d:\n            ts.add_edge(i, 1, j, 0)\n            ts.add_edge(j, 1, i, 0)\n\nif ts.satisfy():\n    print(\"Yes\")\n    for j,xyi in zip(ts.vals,xy):print(xyi[j])\nelse:print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "N,D=map(int,input().split())\nF=[tuple(map(int,input().split())) for i in range(N)]\n\nEDGE=[[] for i in range(2*N)]\nEDGE_INV=[[] for i in range(2*N)]\n\n# 0～N : X_i\n# N+1～2N: Y_i = ￢X_i\n\nfor i in range(N):\n    x1,y1=F[i]\n\n    for j in range(i,N):\n        x2,y2=F[j]\n\n        if abs(x1-x2)<D and i!=j:\n            EDGE[i].append(N+j)\n            EDGE[j].append(N+i)\n\n            EDGE_INV[N+j].append(i)\n            EDGE_INV[N+i].append(j)\n\n        if abs(x1-y2)<D:\n            EDGE[i].append(j)\n            EDGE[N+j].append(N+i)\n\n            EDGE_INV[j].append(i)\n            EDGE_INV[N+i].append(N+j)\n\n        if abs(y1-x2)<D:\n            EDGE[N+i].append(N+j)\n            EDGE[j].append(i)\n\n            EDGE_INV[N+j].append(N+i)\n            EDGE_INV[i].append(j)\n\n        if abs(y1-y2)<D and i!=j:\n            EDGE[N+i].append(j)\n            EDGE[N+j].append(i)\n\n            EDGE_INV[j].append(N+i)\n            EDGE_INV[i].append(N+j)\n\nQUE = list(range(2*N))\ncheck=[0]*(2*N)\nTOP_SORT=[]\n\ndef dfs(x):\n    if check[x]==1:\n        return\n    check[x]=1\n    \n    for to in EDGE[x]:\n        if check[to]==0:\n            dfs(to)\n\n    TOP_SORT.append(x) # 全ての点からDFSを行い, 帰りがけに点を答えに入れる\n    check[x]=1\n\nwhile QUE:\n    x=QUE.pop()\n    dfs(x)\n\nUSE=[0]*(2*N)\nSCC=[]\n\ndef dfs2(x):\n    Q=[x]\n    USE[x]=1\n    ANS=[]\n\n    while Q:\n        x=Q.pop()\n        ANS.append(x)\n        for to in EDGE_INV[x]:\n            if USE[to]==0:\n                USE[to]=1\n                Q.append(to)\n    return ANS\n\nfor x in TOP_SORT[::-1]:\n    if USE[x]==0:\n        SCC.append(dfs2(x))\n\n\nPLACE=[-1]*(2*N)\nfor i in range(len(SCC)):\n    for x in SCC[i]:\n        PLACE[x]=i\n\nANS=[-1]*N\nflag=1\nfor i in range(N):\n    if PLACE[i]==PLACE[N+i]:\n        flag=0\n        break\n    \n    elif PLACE[i]>PLACE[N+i]:\n        ANS[i]=F[i][0]\n    else:\n        ANS[i]=F[i][1]\n    \nif flag==0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for ans in ANS:\n        print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nrange = xrange\ninput = raw_input\n \ndef find_SCC(coupl):\n    SCC, S, P = [], [], []\n    depth = [0] * len(coupl)\n \n    stack = list(range(len(coupl)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += coupl[node]\n    return SCC[::-1]\n\nclass TwoSAT:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(2 * n)]\n\n    def _imply(self, x, y):\n        \"\"\" x => y \"\"\"\n        self.graph[x].append(y if y >= 0 else 2 * self.n + y)\n\n    def either(self, x, y):\n        \"\"\"x or y must be True\"\"\"\n        self._imply(~x, y)\n        self._imply(~y, x)\n\n    def set(self, x):\n        \"\"\"x must be True\"\"\"\n        self._imply(~x, x)\n\n    def solve(self):\n        SCC = find_SCC(self.graph)\n        \n        inSCC = [0] * (2 * self.n)\n        for scc_ind, scc in enumerate(SCC):\n            for node in scc:\n                inSCC[node] = scc_ind\n        \n        for i in range(self.n):\n            if inSCC[i] == inSCC[~i]:\n                return False, None\n        \n        return True, [+(inSCC[i] < inSCC[~i]) for i in range(self.n)]\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \nn = inp[ii]; ii += 1\nd = inp[ii]; ii += 1\n\nsat = TwoSAT(n)\n\nX = inp[ii + 0: ii + 2 * n: 2] \nY = inp[ii + 1: ii + 2 * n: 2] \nii += 2 * n\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(X[i] - X[j]) < d:\n            sat.either(i, j)\n        \n        if abs(Y[i] - Y[j]) < d:\n            sat.either(~i, ~j)\n        \n        if abs(X[i] - Y[j]) < d:\n            sat.either(i, ~j)\n        \n        if abs(Y[i] - X[j]) < d:\n            sat.either(~i, j)\n\nexists, solution = sat.solve()\n\nif not exists:\n    print 'No'\nelse:\n    print 'Yes'\n    print ' '.join(str(X[i] if b else Y[i]) for i, b in enumerate(solution))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass SCC:\n  '''\n  SCC class with non-recursive DFS.\n  '''\n  def __init__(self,N):\n    self.N = N\n    self.G1 = [[] for _ in range(N)]\n    self.G2 = [[] for _ in range(N)]\n  \n  def add_edge(self,a,b):\n    self.G1[a].append(b)\n    self.G2[b].append(a)\n    \n  def scc(self):\n    self.seen = [0]*self.N\n    self.postorder=[-1]*self.N\n    self.order = 0\n    for i in range(self.N):\n      if self.seen[i]:continue\n      self._dfs(i)\n\n    self.seen = [0]*self.N\n    scclist = []\n    for i in self._argsort(self.postorder,reverse=True):\n      if self.seen[i]:continue\n      cc = self._dfs2(i)\n      scclist.append(cc)\n    \n    return scclist\n    \n  def _argsort(self,arr,reverse=False):\n    shift = self.N.bit_length()+2\n    tmp = sorted([arr[i]<<shift | i for i in range(len(arr))],reverse=reverse)\n    mask = (1<<shift) - 1\n    return [tmp[i] & mask for i in range(len(arr))]\n  \n  def _dfs(self,v0):\n    todo = [~v0, v0]\n    while todo:\n      v = todo.pop()\n      if v >= 0:\n        self.seen[v] = 1\n        for next_v in self.G1[v]:\n          if self.seen[next_v]: continue\n          todo.append(~next_v)\n          todo.append(next_v)\n      else:\n        if self.postorder[~v] == -1:\n          self.postorder[~v] = self.order\n          self.order += 1\n    return\n  \n  def _dfs2(self,v):\n    todo = [v]\n    self.seen[v] = 1\n    cc = [v]\n    while todo:\n      v = todo.pop()\n      for next_v in self.G2[v]:\n        if self.seen[next_v]: continue\n        self.seen[next_v] = 1\n        todo.append(next_v)\n        cc.append(next_v)\n    return cc\n\nclass TwoSAT:\n  def __init__(self,N):\n    self.N = N\n    self.scc = SCC(2*N)\n    self.flag=-1\n  \n  def add_clause(self,i,f,j,g):\n    self.scc.add_edge(f*N+i,(1^g)*N+j)\n    self.scc.add_edge(g*N+j,(1^f)*N+i)\n    \n  def satisfiable(self):\n    if self.flag==-1:\n      self.scclist = self.scc.scc()\n      self.order = {j:i for i,scc in enumerate(self.scclist) for j in scc}\n      self.flag = True\n      self.ans = [0]*self.N\n      for i in range(self.N):\n        if self.order[i] > self.order[self.N+i]:\n          self.ans[i] = 1\n          continue\n        elif self.order[i] == self.order[i+self.N]:\n          self.flag = False\n          return self.flag\n      return self.flag\n    else: return self.flag\n  \n  def answer(self):\n    return self.ans\n  \nN,D=map(int,input().split())\nxy = [tuple(map(int,input().split())) for _ in range(N)]\nts=TwoSAT(N)\nfor i in range(N-1):\n  for j in range(i+1,N):\n    for k1,k2 in [(0,0),(0,1),(1,0),(1,1)]:\n      pos1,pos2 = xy[i][k1],xy[j][k2]\n      if abs(pos2-pos1)<D:\n        ts.add_clause(i,k1^1,j,k2^1)\n        \nif ts.satisfiable():\n  print('Yes')\n  print(*[xy[i][ts.ans[i]] for i in range(N)],sep=\"\\n\")\nelse:\n  print('No')"
  },
  {
    "language": "Python",
    "code": "#-------最強ライブラリ2-SAT(Python)------\n#最強ライブラリSCC(Python)が必要\n\nclass two_sat:\n  def __init__(s):\n    s._n = 0\n    s.scc = scc_graph(0)\n  def __init__(s, n):\n    s._n = n\n    s._answer = [False] * n\n    s.scc = scc_graph(2 * n)\n\n  # クローズを足す\n  # クローズってなに\n  def add_clause(s, i, f, j, g):\n    s.scc.add_edge(2 * i + (not f), 2 * j + (g))\n    s.scc.add_edge(2 * j + (not g), 2 * i + (f))\n  \n  # 判定\n  # O(n + m)\n  def satisfiable(s):\n    id = s.scc.scc_ids()[1]\n    for i in range(s._n):\n      if id[2 * i] == id[2 * i + 1]: return False\n      s._answer[i] = id[2 * i] < id[2 * i + 1]\n    return True\n\n  # クローズを満たす割当を返す\n  # satisfiableがTrueとなった後に呼ばないと意味ない\n  # O(1だよね？）\n  def answer(s): return s._answer\n\n\n#-------最強ライブラリここまで------\n\n\n#-------最強ライブラリSCC(Python) ver83025------\nimport sys\nsys.setrecursionlimit(1000000)\n\nclass scc_graph:\n  # n 頂点数\n  def __init__(s, n): \n    s._n = n\n    s.g = {}\n  def num_vertices(s): return s._n\n  # 辺を追加 frm 矢元 to 矢先\n  # O(1)\n  def add_edge(s, frm, to): \n    if frm in s.g: s.g[frm].append(to)\n    else: s.g[frm] = [to]\n\n  # グループの個数と各頂点のグループidを返す\n  def scc_ids(s):\n    now_ord = group_num = 0\n    visited = []\n    low = [0] * s._n\n    ord = [-1] * s._n\n    ids = [0] * s._n\n    # 再帰関数 \n    def dfs(self, v, now_ord, group_num):\n      low[v] = ord[v] = now_ord\n      now_ord += 1\n      visited.append(v)\n      if v in s.g:\n        for to in s.g[v]:\n          if ord[to] == -1:\n            now_ord, group_num = self(self, to, now_ord, group_num)\n            low[v] = min(low[v], low[to])\n          else:\n            low[v] = min(low[v], ord[to])\n      if low[v] == ord[v]:\n        while True:\n          u = visited.pop()\n          ord[u] = s._n\n          ids[u] = group_num\n          if u == v: break\n        group_num += 1\n      return now_ord, group_num\n\n    for i in range(s._n):\n      if ord[i] == -1: now_ord, group_num = dfs(dfs, i, now_ord, group_num)\n    for i in range(s._n):\n      ids[i] = group_num - 1 - ids[i]\n    return group_num, ids\n\n  # 強連結成分となっている頂点のリストのリスト トポロジカルソート済み\n  # O(n + m)\n  def scc(s):\n    group_num, ids = s.scc_ids()\n    counts = [0] * group_num\n    for x in ids: counts[x] += 1\n    groups = [[] for _ in range(group_num)]\n    for i in range(s._n):\n      groups[ids[i]].append(i)\n    return groups\n\n  class edge:\n    def __init__(s, frm, to):\n      s.frm = frm\n      s.to = to\n\n#-------最強ライブラリここまで------\n\ndef main():\n  input = sys.stdin.readline\n\n  N, D = list(map(int, input().split()))\n  XY = [list(map(int, input().split())) for _ in range(N)]\n\n  ts = two_sat(N)\n\n  for i in range(N):\n    for j in range(i + 1, N):\n      xi, yi = XY[i]\n      xj, yj = XY[j]\n      # 距離がD未満の組み合わせに関して、\n      # 少なくとも一つは使用しない\n      # → 少なくとも一つは別の座標を使用する\n      # というルールを追加する\n      if (abs(xi - xj) < D):\n        ts.add_clause(i, False, j, False)\n      if (abs(xi - yj) < D):\n        ts.add_clause(i, False, j, True)\n      if (abs(yi - xj) < D):\n        ts.add_clause(i, True, j, False)\n      if (abs(yi - yj) < D):\n        ts.add_clause(i, True, j, True)\n\n  if not ts.satisfiable():\n    print(\"No\")\n    exit()\n\n  print(\"Yes\")\n  answer = ts.answer()\n  for i in range(N):\n    x, y = XY[i]\n    if answer[i]:\n      print(x)\n    else:\n      print(y)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        n = self.n\n        u0,u1 = (i,i+n) if not f else (i+n,i)\n        v0,v1 = (j,j+n) if not g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                ans[i] = True\n            else:\n                ans[i] = False\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,False,j,False)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,True,j,True)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][0 if ans[i] else 1] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass TwoSat:\n    def __init__(self, V):\n        self.N = len(V)\n        self.ans = None\n        self.__e = []\n        self.__v = V\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\ndef atcoder_practice2_h():\n    # https://atcoder.jp/contests/practice2/submissions/16823214\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n    ts = TwoSat(list(range(2*N)))\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "N,D = map(int,input().split())\nXY = [tuple(map(int,input().split())) for i in range(N)]\n\nimport sys\nsys.setrecursionlimit(10**8)\nclass Scc:\n    def __init__(self,n):\n        self.n = n\n        self.edges = []\n\n    def add_edge(self,fr,to):\n        assert 0 <= fr < self.n\n        assert 0 <= to < self.n\n        self.edges.append((fr, to))\n\n    def scc(self):\n        csr_start = [0] * (self.n + 1)\n        csr_elist = [0] * len(self.edges)\n        for fr,to in self.edges:\n            csr_start[fr + 1] += 1\n        for i in range(1,self.n+1):\n            csr_start[i] += csr_start[i-1]\n        counter = csr_start[:]\n        for fr,to in self.edges:\n            csr_elist[counter[fr]] = to\n            counter[fr] += 1\n\n        self.now_ord = self.group_num = 0\n        self.visited = []\n        self.low = [0] * self.n\n        self.ord = [-1] * self.n\n        self.ids = [0] * self.n\n        def _dfs(v):\n            self.low[v] = self.ord[v] = self.now_ord\n            self.now_ord += 1\n            self.visited.append(v)\n            for i in range(csr_start[v], csr_start[v+1]):\n                to = csr_elist[i]\n                if self.ord[to] == -1:\n                    _dfs(to)\n                    self.low[v] = min(self.low[v], self.low[to])\n                else:\n                    self.low[v] = min(self.low[v], self.ord[to])\n            if self.low[v] == self.ord[v]:\n                while 1:\n                    u = self.visited.pop()\n                    self.ord[u] = self.n\n                    self.ids[u] = self.group_num\n                    if u==v: break\n                self.group_num += 1\n        for i in range(self.n):\n            if self.ord[i] == -1: _dfs(i)\n        for i in range(self.n):\n            self.ids[i] = self.group_num - 1 - self.ids[i]\n\n        groups = [[] for _ in range(self.group_num)]\n        for i in range(self.n):\n            groups[self.ids[i]].append(i)\n        return groups\n\nclass TwoSat:\n    def __init__(self,n=0):\n        self.n = n\n        self.answer = []\n        self.scc = Scc(2*n)\n\n    def add_clause(self, i:int, f:bool, j:int, g:bool):\n        assert 0 <= i < self.n\n        assert 0 <= j < self.n\n        self.scc.add_edge(2*i + (not f), 2*j + g)\n        self.scc.add_edge(2*j + (not g), 2*i + f)\n\n    def satisfiable(self):\n        g = self.scc.scc()\n        for i in range(self.n):\n            if self.scc.ids[2*i] == self.scc.ids[2*i+1]: return False\n            self.answer.append(self.scc.ids[2*i] < self.scc.ids[2*i+1])\n        return True\n\n    def get_answer(self):\n        return self.answer\n\nts = TwoSat(N)\nfor i in range(N-1):\n    xi,yi = XY[i]\n    for j in range(i+1,N):\n        xj,yj = XY[j]\n        if abs(xi - xj) < D:\n            ts.add_clause(i, False, j, False)\n        if abs(xi - yj) < D:\n            ts.add_clause(i, False, j, True)\n        if abs(yi - xj) < D:\n            ts.add_clause(i, True, j, False)\n        if abs(yi - yj) < D:\n            ts.add_clause(i, True, j, True)\nif not ts.satisfiable():\n    print('No')\n    exit()\nprint('Yes')\nans = []\nfor b,(x,y) in zip(ts.get_answer(), XY):\n    if b:\n        ans.append(x)\n    else:\n        ans.append(y)\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "code = r\"\"\"\n# distutils: language=c++\n# distutils: include_dirs=[/home/contestant/.local/lib/python3.8/site-packages/numpy/core/include, /opt/atcoder-stl]\nfrom libcpp cimport bool\nfrom libcpp.vector cimport vector\ncdef extern from \"<atcoder/twosat>\" namespace \"atcoder\" nogil:\n    cdef cppclass two_sat:\n        two_sat(int n)\n        void add_clause(int i, bool f, int j, bool g)\n        bool satisfiable()\n        vector[bool] answer()\nfrom libcpp.pair cimport pair\nfrom libc.stdlib cimport abs\nfrom libc.stdio cimport getchar, printf\ncdef int read() nogil:\n    cdef int b, c = 0\n    while 1:\n        b = getchar() - 48\n        if b < 0: return c\n        c = c * 10 + b\ncdef int n = read(), d = read(), i, j\ncdef two_sat *ts = new two_sat(n)\ncdef vector[pair[int, int]] z = vector[pair[int, int]](n)\ncdef vector[bool] res\nfor i in range(n):\n    z[i].first = read()\n    z[i].second = read()\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(z[i].first - z[j].first) < d: ts.add_clause(i, True, j, True)\n        if abs(z[i].first - z[j].second) < d: ts.add_clause(i, True, j, False)\n        if abs(z[i].second - z[j].first) < d: ts.add_clause(i, False, j, True)\n        if abs(z[i].second - z[j].second) < d: ts.add_clause(i, False, j, False)\nif ts.satisfiable():\n    printf('Yes\\n')\n    res = ts.answer()\n    for i in range(n):\n        if res[i]: printf('%d\\n', z[i].second)\n        else: printf('%d\\n', z[i].first)\nelse:\n    printf('No\\n')\n\"\"\"\nimport os, sys\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    open('solve.pyx', 'w').write(code)\n    os.system('cythonize -i -3 -b solve.pyx')\nimport solve"
  },
  {
    "language": "Python",
    "code": "\nimport networkx as nx\n\nimport io\nimport os\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nN, D = [int(x) for x in input().split()]\nXY = [[int(x) for x in input().split()] for i in range(N)]\n\n\ngraph = nx.DiGraph()\n\n\n# a_i = 0 means choose x, a_i = 1 means choose y\n# Store i for a_i==0 and i+N for a_i==1\nfor i, (x1, y1) in enumerate(XY):\n    for j in range(N):\n        if i != j:\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                # a_i==0 => a_j==1\n                graph.add_edge(i, j + N)\n            if abs(x1 - y2) < D:\n                # a_i==0 => a_j==0\n                graph.add_edge(i, j)\n            if abs(y1 - x2) < D:\n                # a_i==1 => a_j==1\n                graph.add_edge(i + N, j + N)\n            if abs(y1 - y2) < D:\n                # a_i==1 => a_j==0\n                graph.add_edge(i + N, j)\n\n\nSCC = nx.algorithms.components.strongly_connected_components(graph)\nassignment = {}\nfor comp in SCC:\n    for x in comp:\n        if (x < N and x + N in comp) or (x >= N and x - N in comp):\n            print(\"No\")\n            exit()\n        if x not in assignment:\n            assignment[x] = True\n            assignment[(x + N) % (2 * N)] = False\nprint(\"Yes\")\nfor i in range(N):\n    print(XY[i][0] if assignment[i] else XY[i][1])\n"
  },
  {
    "language": "Python",
    "code": "\n# // Reference:\n# // B. Aspvall, M. Plass, and R. Tarjan,\n# // A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n# // Formulas\n# struct two_sat {\n#     public:\n#     two_sat(): _n(0), scc(0) {}\n#     two_sat(int n): _n(n), _answer(n), scc(2 * n) {}\n\n#     void add_clause(int i, bool f, int j, bool g) {\n#         assert(0 <= i & & i < _n);\n#         assert(0 <= j & & j < _n);\n#         scc.add_edge(2 * i + (f ? 0: 1), 2 * j + (g ? 1: 0));\n#         scc.add_edge(2 * j + (g ? 0: 1), 2 * i + (f ? 1: 0));}\n#     bool satisfiable() {\n#         auto id = scc.scc_ids().second;\n#         for (int i=0; i < _n; i++) {\n#             if (id[2 * i] == id[2 * i + 1]) return false;\n#             _answer[i] = id[2 * i] < id[2 * i + 1];}\n#         return true;}\n#     std: : vector < bool > answer() {return _answer; }\n\n#     private:\n#     int _n;\n#     std:: vector < bool > _answer;\n#     internal:: scc_graph scc; };\n\n# } // namespace atcoder\n\n#     #endif  // ATCODER_TWOSAT_HPP\n\n\nfrom collections import defaultdict\n\nclass TwoSat:\n    def __init__(self, N):\n        self.N = N\n        self.ans = None\n        self.__e = []\n        self.__v = set()\n\n    def add_clause(self, i, f, j, g):\n        self.__e.append((2*i + (0 if f else 1), 2*j + (1 if g else 0)))\n        self.__e.append((2*j + (0 if g else 1), 2*i + (1 if f else 0)))\n        self.__v.add(2*i + 0)\n        self.__v.add(2*i + 1)\n        self.__v.add(2*j + 0)\n        self.__v.add(2*j + 1)\n\n    @staticmethod\n    def scc(V, E):\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for u, v in E:\n            g[u].append(v)\n            rg[v].append(u)\n\n        o = []\n        done = set()\n        for u in V:\n            if u in done:\n                continue\n\n            s = [(u, True)]\n            while s:\n                u, f = s.pop()\n                if f:\n                    if u in done:\n                        continue\n                    done.add(u)\n                    s.append((u, False))\n                    for v in g[u]:\n                        if v in done:\n                            continue\n                        s.append((v, True))\n                else:\n                    o.append(u)\n\n        done = set()\n        ans = []\n        while o:\n            u = o.pop()\n            if u in done:\n                continue\n\n            s = [u]\n            vv = [u]\n            done.add(u)\n            while s:\n                u = s.pop()\n                for v in rg[u]:\n                    if v in done:\n                        continue\n                    vv.append(v)\n                    s.append(v)\n                    done.add(v)\n            ans.append(vv)\n\n        return ans\n\n\n    def satisfiable(self):\n        scc = TwoSat.scc(self.__v, self.__e)\n        cid = [-1] * (self.N)\n\n        for i, s in enumerate(scc):\n            for v in s:\n                cid[v] = i\n\n        for i in range(self.N//2):\n\n            if cid[2*i] == cid[2*i+1]:\n                self.ans = None\n                return False\n\n        self.ans = []\n        for i in range(self.N//2):\n            self.ans.append(cid[2*i] < cid[2*i+1])\n\n        return True\n\n\n\n\ndef atcoder_practice2_h():\n    N, D = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n\n    ts = TwoSat(2*N)\n    for i, (x1, y1) in enumerate(XY):\n        for j in range(i+1, N):\n            x2, y2 = XY[j]\n            if abs(x1 - x2) < D:\n                ts.add_clause(i, False, j, False)\n\n            if abs(y1 - y2) < D:\n                ts.add_clause(i, True, j, True)\n\n            if abs(x1 - y2) < D:\n                ts.add_clause(i, False, j, True)\n\n            if abs(y1 - x2) < D:\n                ts.add_clause(i, True, j, False)\n\n    if not ts.satisfiable():\n        print('No')\n    else:\n        print('Yes')\n        for i, b in enumerate(ts.ans):\n            print(XY[i][0 if b else 1])\n\n\n\n\nif __name__ == \"__main__\":\n    atcoder_practice2_h()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,d = list(map(int, input().split()))\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nclass SAT2:\n    def __init__(self, n):\n        self.n = n\n        self.ns = [[] for _ in range(2*n)]\n    def add_clause(self, i, f, j, g):\n        \"\"\"(xi==f) and (xj==g)\n        \"\"\"\n        n = self.n\n        u0,u1 = (i,i+n) if f else (i+n,i)\n        v0,v1 = (j,j+n) if g else (j+n,j)\n        self.ns[u1].append(v0)\n        self.ns[v1].append(u0)\n    def solve(self):\n        \"\"\"強連結成分分解\n        トポロジカルソート順の逆順に返す\n        \"\"\"\n        preorder = {}\n        lowlink = {}\n        seen = [False]*(2*self.n)\n        scc_queue = []\n        i = 0  # Preorder counter\n        # ans = [None]*(2*self.n)\n        count = 1\n        for source in range(n):\n            if seen[source]:\n                continue\n            queue = [source]\n            while queue:\n                v = queue[-1]\n                if v not in preorder:\n                    i = i + 1\n                    preorder[v] = i\n                done = True\n                for w in self.ns[v]:\n                    if w not in preorder:\n                        queue.append(w)\n                        done = False\n                        break\n                if done:\n                    lowlink[v] = preorder[v]\n                    for w in self.ns[v]:\n                        if seen[w]:\n                            continue\n                        if preorder[w] > preorder[v]:\n                            lowlink[v] = min([lowlink[v], lowlink[w]])\n                        else:\n                            lowlink[v] = min([lowlink[v], preorder[w]])\n                    queue.pop()\n                    if lowlink[v] == preorder[v]:\n                        scc = {v}\n                        while scc_queue and preorder[scc_queue[-1]] > preorder[v]:\n                            k = scc_queue.pop()\n                            scc.add(k)\n                        for v in scc:\n                            seen[v] = count\n                        count += 1\n                    else:\n                        scc_queue.append(v)\n        ans = [None]*self.n\n        for i in range(self.n):\n            if seen[i]==seen[i+self.n]:\n                return None\n            elif seen[i]>seen[i+self.n]:\n                ans[i] = True\n            else:\n                ans[i] = False\n        return ans\n\nsolver = SAT2(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if abs(xy[i][0]-xy[j][0])<d:\n            solver.add_clause(i,False,j,False)\n        if abs(xy[i][0]-xy[j][1])<d:\n            solver.add_clause(i,False,j,True)\n        if abs(xy[i][1]-xy[j][0])<d:\n            solver.add_clause(i,True,j,False)\n        if abs(xy[i][1]-xy[j][1])<d:\n            solver.add_clause(i,True,j,True)\nans = solver.solve()\nif ans is not None:\n    print(\"Yes\")\n    write(\"\\n\".join(map(str, [xy[i][0 if ans[i] else 1] for i in range(n)])))\nelse:\n    print(\"No\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n):\n        self.n = n\n        self.graph = [set() for _ in range(n)]\n        self.rev = [set() for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n\n    def add_edge(self, p, q):\n        self.graph[p].add(q)\n        self.rev[q].add(p)\n        self.deg[q] += 1\n\n    def topological_sort(self):\n        deg = self.deg[:]\n        res = [i for i in range(self.n) if deg[i] == 0]\n        queue = deque(res)\n        used = [False for _ in range(self.n)]\n        while queue:\n            node = queue.popleft()\n            for adj in self.graph[node]:\n                deg[adj] -= 1\n                if deg[adj] == 0:\n                    queue.append(adj)\n                    res.append(adj)\n        return res\n\n    def strongry_connected(self):\n        group = [None for _ in range(self.n)]\n        used = [0 for _ in range(self.n)]\n        order = []\n        for s in range(self.n):\n            if not used[s]:\n                stack = [s]\n                used[s] = 1\n                while stack:\n                    node = stack.pop()\n                    movable = False\n                    for adj in self.graph[node]:\n                        if not used[adj]:\n                            movable = True\n                            used[adj] = 1\n                            stack.append(node)\n                            stack.append(adj)\n                            break\n                    if not movable:\n                        order.append(node)\n        used = [0 for _ in range(self.n)]\n        count = 0\n        for s in order[::-1]:\n            if not used[s]:\n                stack = [s]\n                group[s] = count\n                while stack:\n                    node = stack.pop()\n                    used[node] = 1\n                    for adj in self.rev[node]:\n                        if not used[adj]:\n                            group[adj] = count\n                            stack.append(adj)\n                count += 1\n        return group, count\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\n\nX = []\nY = []\n\ng = Graph(2 * N)\n\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\n\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        if abs(X[i] - X[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(j, ~i)\n        if abs(X[i] - Y[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(~j, i)\n        if abs(Y[i] - X[i]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(j, ~i)\n        if abs(Y[i] - Y[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(~j, i)\n\ngroup, count = g.strongry_connected()\n\ngroup_to_node = [[] for _ in range(count)]\n\nfor i in range(N):\n    if group[i] == group[~i]:\n        print('No')\n        break\n    group_to_node[group[i]].append(i)\n    group_to_node[group[~i]].append(~i)\n\nelse:\n    print('Yes')\n\n    comp = Graph(count)\n\n    for i in range(2 * N):\n        for j in g.graph[i]:\n            if group[i] == group[j]:\n                continue\n            comp.add_edge(group[i], group[j])\n\n    ts = comp.topological_sort()\n\n    res = [None for _ in range(N)]\n\n    for i in ts:\n        for node in group_to_node[i]:\n            if node >= 0:\n                if res[node] is None:\n                    res[node] = Y[node]\n            else:\n                if res[~node] is None:\n                    res[~node] = X[~node]\n\n    for i in range(N):\n        if res[i] is None:\n            res[i] = Y[node]\n\n    print('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nimport sys\n\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 6 + 100)\n\n\nclass StronglyConnectedComponets:\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.rev_edeges = [[] for _ in range(n)]\n        self.vs = []\n        self.order = [0] * n\n        self.used = [False] * n\n\n    def add_edge(self, from_v: int, to_v: int) -> None:\n        self.edges[from_v].append(to_v)\n        self.rev_edeges[to_v].append(from_v)\n\n    def dfs(self, v: int) -> None:\n        self.used[v] = True\n        for child in self.edges[v]:\n            if not self.used[child]:\n                self.dfs(child)\n        self.vs.append(v)\n\n    def rdfs(self, v: int, k: int) -> None:\n        self.used[v] = True\n        self.order[v] = k\n        for child in self.rev_edeges[v]:\n            if not self.used[child]:\n                self.rdfs(child, k)\n\n    def run(self) -> int:\n        self.used = [False] * self.n\n        self.vs.clear()\n        for v in range(self.n):\n            if not self.used[v]:\n                self.dfs(v)\n        self.used = [False] * self.n\n        k = 0\n        for v in reversed(self.vs):\n            if not self.used[v]:\n                self.rdfs(v, k)\n                k += 1\n        return k\n\n\nclass TwoSat(StronglyConnectedComponets):\n    def __init__(self, num_var: int) -> None:\n        super().__init__(2 * num_var + 1)\n        self.num_var = num_var\n        self.ans = []\n\n    def add_constraint(self, a: int, b: int) -> None:\n        super().add_edge(self._neg(a), self._pos(b))\n        super().add_edge(self._neg(b), self._pos(a))\n\n    def _pos(self, v: int) -> int:\n        return v if v > 0 else self.num_var - v\n\n    def _neg(self, v: int) -> int:\n        return self.num_var + v if v > 0 else -v\n\n    def run(self) -> bool:\n        super().run()\n        self.ans.clear()\n        for i in range(self.num_var):\n            if self.order[i + 1] == self.order[i + self.num_var + 1]:\n                return False\n            self.ans.append(self.order[i + 1] > self.order[i + self.num_var + 1])\n        return True\n\n\ndef main() -> None:\n    N, D = map(int, input().split())\n\n    flags = [tuple(int(x) for x in input().split()) for _ in range(N)]\n\n    # (X_i, Y_i) -> (i, -i) (i=1, ..., N) と考える\n    sat = TwoSat(N)\n\n    # 節 a, b の距離が D 以下の場合，\n    # a -> -b つまり -a or -b が成立しなければならない\n    for i, (x_i, y_i) in enumerate(flags, 1):\n        for j, (x_j, y_j) in enumerate(flags[i:], i+1):\n            if abs(x_i - x_j) < D:\n                sat.add_constraint(-i, -j)\n            if abs(y_i - x_j) < D:\n                sat.add_constraint(i, -j)\n            if abs(x_i - y_j) < D:\n                sat.add_constraint(-i, j)\n            if abs(y_i - y_j) < D:\n                sat.add_constraint(i, j)\n    if sat.run():\n        print(\"Yes\")\n        print(*[x_i if sat.ans[i] else y_i for i, (x_i, y_i) in enumerate(flags)], sep=\"\\n\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# AC Library Python版\n# Author Koki_tkg\n\n'''\ninternal_type_traits以外は翻訳しました。\npracticeは一応全部ACしていますが，\npracticeで使っていない関数などの動作は未確認なので保証はしません。\nまた，C++版をほぼそのまま書き換えているので速度は出ません。　(2020/09/13 by Koki_tkg)\n'''\n# --------------------<< Library Start >>-------------------- #\n\n# convolution.py\nclass convolution:\n    def __init__(self, a: list, b: list, mod: int):\n        self.a, self.b = a, b\n        self.n, self.m = len(a), len(b)\n        self.MOD = mod\n        self.g = primitive_root_constexpr(self.MOD)\n    \n    def convolution(self) -> list:\n        n, m = self.n, self.m\n        a, b = self.a, self.b\n        if not n or not m: return []\n        if min(n, m) <= 60:\n            if n < m:\n                n, m = m, n\n                a, b = b, a\n            ans = [0] * (n + m - 1)\n            for i in range(n):\n                for j in range(m):\n                    ans[i + j] += a[i] * b[j] % self.MOD\n                    ans[i + j] %= self.MOD\n            return ans\n        z = 1 << ceil_pow2(n + m - 1)\n        a = self.resize(a, z)\n        a = self.butterfly(a)\n        b = self.resize(b, z)\n        b = self.butterfly(b)\n        for i in range(z): a[i] = a[i] * b[i] % self.MOD\n        a = self.butterfly_inv(a)\n        a = a[:n + m - 1]\n        iz = self.inv(z)\n        a = [x * iz % self.MOD for x in a]\n        return a\n\n    def butterfly(self, a: list) -> list:\n        n = len(a)\n        h = ceil_pow2(n)\n        first = True\n        sum_e = [0] * 30\n        m = self.MOD\n        if first:\n            first = False\n            es, ies = [0] * 30, [0] * 30\n            cnt2 = bsf(m - 1)\n            e = self.mypow(self.g, (m - 1) >> cnt2); ie = self.inv(e)\n            for i in range(cnt2, 1, -1):\n                es[i - 2] = e\n                ies[i - 2] = ie\n                e = e * e % m\n                ie = ie * ie % m\n            now = 1\n            for i in range(cnt2 - 2):\n                sum_e[i] = es[i] * now % m\n                now = now * ies[i] % m\n        for ph in range(1, h + 1):\n            w = 1 << (ph - 1); p = 1 << (h - ph)\n            now = 1\n            for s in range(w):\n                offset = s << (h - ph + 1)\n                for i in range(p):\n                    l = a[i + offset] % m\n                    r = a[i + offset + p] * now % m\n                    a[i + offset] = (l + r) % m\n                    a[i + offset + p] = (l - r) % m\n                now = now * sum_e[bsf(~s)] % m\n        return a\n\n    def butterfly_inv(self, a: list) -> list:\n        n = len(a)\n        h = ceil_pow2(n)        \n        first = True\n        sum_ie = [0] * 30\n        m = self.MOD\n        if first:\n            first = False\n            es, ies = [0] * 30, [0] * 30\n            cnt2 = bsf(m - 1)\n            e = self.mypow(self.g, (m - 1) >> cnt2); ie = self.inv(e)\n            for i in range(cnt2, 1, -1):\n                es[i - 2] = e\n                ies[i - 2] = ie\n                e = e * e % m\n                ie = ie * ie % m\n            now = 1\n            for i in range(cnt2 - 2):\n                sum_ie[i] = ies[i] * now % m\n                now = es[i] * now % m\n        for ph in range(h, 0, -1):\n            w = 1 << (ph - 1); p = 1 << (h - ph)\n            inow = 1\n            for s in range(w):\n                offset = s << (h - ph + 1)\n                for i in range(p):\n                    l = a[i + offset] % m\n                    r = a[i + offset + p] % m\n                    a[i + offset] = (l + r) % m\n                    a[i + offset + p] = (m + l - r) * inow % m\n                inow = sum_ie[bsf(~s)] * inow % m\n        return a\n\n    @staticmethod\n    def resize(array: list, sz: int) -> list:\n        new_array = array + [0] * (sz - len(array))\n        return new_array\n    def inv(self, x: int):\n        if is_prime_constexpr(self.MOD):\n            assert x\n            return self.mypow(x, self.MOD - 2)\n        else:\n            eg = inv_gcd(x)\n            assert eg[0] == 1\n            return eg[1]\n    def mypow(self, x: int, n: int) -> int:\n        assert 0 <= n\n        r = 1; m = self.MOD\n        while n:\n            if n & 1: r = r * x % m\n            x = x * x % m\n            n >>= 1\n        return r\n\n# dsu.py\nclass dsu:\n    def __init__(self, n: int):\n        self._n = n\n        self.parent_or_size = [-1] * self._n\n    \n    def merge(self, a: int, b: int) -> int:\n        assert 0 <= a and a < self._n\n        assert 0 <= b and a < self._n\n        x = self.leader(a); y = self.leader(b)\n        if x == y: return x\n        if -self.parent_or_size[x] < -self.parent_or_size[y]: x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n        \n    def same(self, a: int, b: int) -> bool:\n        assert 0 <= a and a < self._n\n        assert 0 <= b and a < self._n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a: int) -> int:\n        assert 0 <= a and a < self._n\n        if self.parent_or_size[a] < 0: return a\n        self.parent_or_size[a] = self.leader(self.parent_or_size[a])\n        return self.parent_or_size[a]\n\n    def size(self, a: int) -> int: \n        assert 0 <= a and a < self._n\n        return -self.parent_or_size[self.leader(a)]\n\n    def groups(self):\n        leader_buf = [0] * self._n; group_size = [0] * self._n\n        for i in range(self._n):\n            leader_buf[i] = self.leader(i)\n            group_size[leader_buf[i]] += 1\n        result = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            result[leader_buf[i]].append(i)\n        result = [v for v in result if v]\n        return result\n\n# fenwicktree.py\nclass fenwick_tree:\n    def __init__(self, n):\n        self._n = n\n        self.data = [0] * n\n    \n    def add(self, p: int, x: int):\n        assert 0 <= p and p <= self._n\n        p += 1\n        while p <= self._n:\n            self.data[p - 1] += x\n            p += p & -p\n    \n    def sum(self, l: int, r: int) -> int:\n        assert 0 <= l and l <= r and r <= self._n\n        return self.__sum(r) - self.__sum(l)\n    \n    def __sum(self, r: int) -> int:\n        s = 0\n        while r > 0:\n            s += self.data[r - 1]\n            r -= r & -r\n        return s\n\n# internal_bit.py\ndef ceil_pow2(n: int) -> int:\n    x = 0\n    while (1 << x) < n: x += 1\n    return x\n\ndef bsf(n: int) -> int:\n    return (n & -n).bit_length() - 1\n\n# internal_math.py\ndef safe_mod(x: int, m: int) -> int:\n    x %= m\n    if x < 0: x += m\n    return x\n\nclass barrett:\n    def __init__(self, m: int):\n        self._m = m\n        self.im = -1 // (m + 1)\n    def umod(self): return self._m\n    def mul(self, a: int, b: int) -> int:\n        z = a\n        z *= b\n        x = (z * im) >> 64\n        v = z - x * self._m\n        if self._m <= v: v += self._m\n        return v        \n\ndef pow_mod_constexpr(x: int, n: int, m: int) -> int:\n    if m == 1: return 0\n    _m = m; r = 1; y = safe_mod(x, m)\n    while n:\n        if n & 1: r = (r * y) % _m\n        y = (y * y) % _m\n        n >>= 1\n    return r\n\ndef is_prime_constexpr(n: int) -> bool:\n    if n <= 1: return False\n    if n == 2 or n == 7 or n == 61: return True\n    if n % 2 == 0: return False\n    d = n - 1\n    while d % 2 == 0: d //= 2\n    for a in [2, 7, 61]:\n        t = d\n        y = pow_mod_constexpr(a, t, n)\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = y * y % n\n            t <<= 1\n        if y != n - 1 and t % 2 == 0: return False\n    return True\n\ndef inv_gcd(self, a: int, b: int) -> tuple:\n    a = safe_mod(a, b)\n    if a == 0: return (b, 0)\n    s = b; t = a; m0 = 0; m1 = 1\n    while t:\n        u = s // t\n        s -= t * u\n        m0 -= m1 * u\n        tmp = s; s = t; t = tmp; tmp = m0; m0 = m1; m1 = tmp\n    if m0 < 0: m0 += b // s\n    return (s, m0)\n\ndef primitive_root_constexpr(m: int) -> int:\n    if m == 2: return 1\n    if m == 167772161: return 3\n    if m == 469762049: return 3\n    if m == 754974721: return 11\n    if m == 998244353: return 3\n    divs = [0] * 20\n    divs[0] = 2\n    cnt = 1\n    x = (m - 1) // 2\n    while x % 2 == 0: x //= 2\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            divs[cnt] = i; cnt += 1\n            while x % i == 0:\n                x //= i\n        i += 2\n    if x > 1: divs[cnt] = x; cnt += 1\n    g = 2\n    while True:\n        ok = True\n        for i in range(cnt):\n            if pow_mod_constexpr(g, (m - 1) // div[i], m) == 1:\n                ok = False\n                break\n        if ok: return g\n        g += 1\n\n# internal_queue.py\nclass simple_queue:\n    def __init__(self):\n        self.payload = []\n        self.pos = 0\n    def size(self): return len(self.payload) - self.pos\n    def empty(self): return self.pos == len(self.payload)\n    def push(self, t: int): self.payload.append(t)\n    def front(self): return self.payload[self.pos]\n    def clear(self): self.payload.clear(); pos = 0\n    def pop(self): self.pos += 1\n    def pop_front(self): self.pos += 1; return self.payload[~-self.pos]\n\n# internal_scc.py\nclass csr:\n    def __init__(self, n: int, edges: list):\n        from copy import deepcopy\n        self.start = [0] * (n + 1)\n        self.elist = [[] for _ in range(len(edges))]\n        for e in edges:\n            self.start[e[0] + 1] += 1\n        for i in range(1, n + 1):\n            self.start[i] += self.start[i - 1]\n        counter = deepcopy(self.start)\n        for e in edges:\n            self.elist[counter[e[0]]] = e[1]; counter[e[0]] += 1\n\nclass scc_graph:\n    # private\n    edges = []\n    \n    # public\n    def __init__(self, n: int):\n        self._n = n\n        self.now_ord = 0; self.group_num = 0\n    \n    def num_vertices(self): return self._n\n\n    def add_edge(self, _from: int, _to: int): self.edges.append((_from, [_to]))\n    \n    def scc_ids(self):\n        g = csr(self._n, self.edges)\n        visited = []; low = [0] * self._n; ord = [-1] * self._n; ids = [0] * self._n\n        \n        def dfs(s, v: int):\n            low[v] = ord[v] = self.now_ord; self.now_ord += 1\n            visited.append(v)\n            for i in range(g.start[v], g.start[v + 1]):\n                to = g.elist[i][0]\n                if ord[to] == -1:\n                    s(s, to)\n                    low[v] = min(low[v], low[to])\n                else:\n                    low[v] = min(low[v], ord[to])\n            if low[v] == ord[v]:\n                while True:\n                    u = visited.pop()\n                    ord[u] = self._n\n                    ids[u] = self.group_num\n                    if u == v: break\n                self.group_num += 1\n\n        for i in range(self._n):\n            if ord[i] == -1: dfs(dfs, i)\n        for i in range(self._n):\n            ids[i] = self.group_num - 1 - ids[i]\n\n        return (self.group_num, ids)\n        \n    def scc(self):\n        ids = self.scc_ids()\n        group_num = ids[0]\n        counts = [0] * group_num\n        for x in ids[1]: counts[x] += 1\n        groups = [[] for _ in range(group_num)]\n        for i in range(self._n):\n            groups[ids[1][i]].append(i)\n        return groups\n\n# internal_type_traits.py \n\n# lazysegtree.py\n'''\ndef op(l, r): return\ndef e(): return\ndef mapping(l, r): return\ndef composition(l, r): return\ndef id(): return 0\n'''\nclass lazy_segtree:\n    def __init__(self, op, e, mapping, composition, id, v: list):\n        self.op = op; self.e = e; self.mapping = mapping; self.composition = composition; self.id = id\n        self._n = len(v)\n        self.log = ceil_pow2(self._n)\n        self.size = 1 << self.log\n        self.lz = [self.id()] * self.size\n        self.d = [self.e()] * (2 * self.size)\n        for i in range(self._n): self.d[self.size + i] = v[i]\n        for i in range(self.size - 1, 0, -1): self.__update(i)\n\n    def set_(self, p: int, x: int):\n        assert 0 <= p and p < self._n\n        p += self.size\n        for i in range(self.log, 0, -1): self.__push(p >> i)\n        self.d[p] = x\n        for i in range(1, self.log + 1): self.__update(p >> 1)\n        \n    def get(self, p: int):\n        assert 0 <= p and p < self._n\n        p += self.size\n        for i in range(self.log, 0, -1): self.__push(p >> i)\n        return self.d[p]\n    \n    def prod(self, l: int, r: int):\n        assert 0 <= l and l <= r and r <= self._n\n        if l == r: return self.e()\n        l += self.size; r += self.size\n\n        for i in range(self.log, 0, -1):\n            if ((l >> i) << i) != l: self.__push(l >> i)\n            if ((r >> i) << i) != r: self.__push(r >> i)\n            \n        sml, smr = self.e(), self.e()\n        while l < r:\n            if l & 1: sml = self.op(sml, self.d[l]); l += 1\n            if r & 1: r -= 1; smr = self.op(self.d[r], smr)\n            l >>= 1; r >>= 1\n        \n        return self.op(sml, smr)\n    \n    def all_prod(self): return self.d[1]\n    \n    def apply(self, p: int, f):\n        assert 0 <= p and p < self._n\n        p += self.size\n        for i in range(self.log, 0, -1): self.__push(p >> i)\n        self.d[p] = self.mapping(f, self.d[p])\n        for i in range(1, self.log + 1): self.__update(p >> 1)\n    \n    def apply(self, l: int, r: int, f):\n        assert 0 <= l and l <= r and r <= self._n\n        if l == r: return\n        l += self.size; r += self.size\n\n        for i in range(self.log, 0, -1):\n            if ((l >> i) << i) != l: self.__push(l >> i)\n            if ((r >> i) << i) != r: self.__push((r - 1) >> i)\n            \n        l2, r2 = l, r\n        while l < r:\n            if l & 1: self.__all_apply(l, f); l += 1\n            if r & 1: r -= 1; self.__all_apply(r, f)\n            l >>= 1; r >>= 1\n        l, r = l2, r2\n        \n        for i in range(1, self.log + 1):\n            if ((l >> i) << i) != l: self.__update(l >> i)\n            if ((r >> i) << i) != r: self.__update(r >> i)\n    \n    def max_right(self, l: int, g):\n        assert 0 <= l and l <= self._n\n        if l == self._n: return self._n\n        l += self.size\n        for i in range(self.log, 0, -1): self.__push(l >> i)\n        sm = self.e()\n        while True:\n            while l % 2 == 0: l >>= 1\n            if not g(self.op(sm, self.d[l])):\n                while l < self.size:\n                    self.__push(l)\n                    l = 2 * l\n                    if g(self.op(sm, self.d[l])):\n                        sm = self.op(sm, self.d[l])\n                        l += 1\n                return l - self.size\n            sm = self.op(sm, self.d[l])\n            l += 1\n            if (l & -l) == l: break\n        return self._n\n\n    def min_left(self, r: int, g):\n        assert 0 <= r and r <= self._n\n        if r == 0: return 0\n        r += self.size\n        for i in range(self.log, 0, -1): self.__push(r >> i)\n        sm = self.e()\n        while True:\n            r -= 1\n            while r > 1 and r % 2: r >>= 1\n            if not g(self.op(self.d[r], sm)):\n                while r < self.size:\n                    self.__push(r)\n                    r = 2 * r + 1\n                    if g(self.op(self.d[r], sm)):\n                        sm = self.op(self.d[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.op(self.d[r], sm)\n            if (r & -r) == r: break\n        return 0\n\n    # private\n    def __update(self, k: int): self.d[k] = self.op(self.d[k * 2], self.d[k * 2 + 1])\n    \n    def __all_apply(self, k: int, f):\n        self.d[k] = self.mapping(f, self.d[k])\n        if k < self.size: self.lz[k] = self.composition(f, self.lz[k])\n        \n    def __push(self, k: int):\n        self.__all_apply(2 * k, self.lz[k])\n        self.__all_apply(2 * k + 1, self.lz[k])\n        self.lz[k] = self.id()\n\n# math\ndef pow_mod(x: int, n: int, m: int) -> int:\n    assert 0 <= n and 1 <= m\n    if m == 1: return 0\n    bt = barrett(m)\n    r = 1; y = safe_mod(x, m)\n    while n:\n        if n & 1: r = bt.mul(r, y)\n        y = bt.mul(y, y)\n        n >>= 1\n    return n\n\ndef inv_mod(x: int, m: int) -> int:\n    assert 1 <= m\n    z = inv_gcd(x, m)\n    assert z[0] == 1\n    return z[1]\n\ndef crt(r: list, m: list) -> tuple:\n    assert len(r) == len(m)\n    n = len(r)\n    r0 = 0; m0 = 1\n    for i in range(n):\n        assert 1 <= m[i]\n        r1 = safe_mod(r[i], m[i]); m1 = m[i]\n        if m0 < m1:\n            r0, r1 = r1, r0\n            m0, m1 = m1, m0\n        if m0 % m1 == 0:\n            if r0 % m1 != r1: return (0, 0)\n            continue\n        g, im = inv_gcd(m0, m1)\n        u1 = m1 // g\n        if (r1 - r0) % g: return (0, 0)\n        x = (r1 - r0) // g % u1 * im % u1\n        r0 += x * m0\n        m0 *= u1\n        if r0 < 0: r0 += m0\n    return (r0, m0)\n\ndef floor_sum(n: int, m: int, a: int, b: int) -> int:\n    ans = 0\n    if a >= m:\n        ans += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        ans += n * (b // m)\n        bb %= m\n    y_max = (a * n + b) // m; x_max = (y_max * m - b)\n    if y_max == 0: return ans\n    ans += (n - (x_max + a - 1) // a) * y_max\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return ans\n\n# maxflow.py\n# from collections import deque\nclass mf_graph:\n    numeric_limits_max = 10 ** 18\n    def __init__(self, n: int):\n        self._n = n\n        self.g = [[] for _ in range(self._n)]\n        self.pos = []\n    \n    def add_edge(self, _from: int, _to: int, cap: int) -> int:\n        assert 0 <= _from and _from < self._n\n        assert 0 <= _to and _to < self._n\n        assert 0 <= cap\n        m = len(self.pos)\n        self.pos.append((_from, len(self.g[_from])))\n        self.g[_from].append(self._edge(_to, len(self.g[_to]), cap))\n        self.g[_to].append(self._edge(_from, len(self.g[_from]) - 1, 0))\n        return m\n    \n    class edge:\n        def __init__(s, _from: int, _to: int, cap: int, flow: int):\n            s._from = _from; s._to = _to; s.cap = cap; s.flow = flow\n    \n    def get_edge(self, i: int) -> edge:\n        m = len(self.pos)\n        assert 0 <= i and i < m\n        _e = self.g[self.pos[i][0]][self.pos[i][1]]\n        _re = self.g[_e.to][_e.rev]\n        return self.edge(self.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap)\n    \n    def edges(self) -> list:\n        m = len(self.pos)\n        result = [self.get_edge(i) for i in range(m)]\n        return result\n    \n    def change_edge(self, i: int, new_cap: int, new_flow: int):\n        m = len(self.pos)\n        assert 0 <= i and i < m\n        assert 0 <= new_flow and new_flow <= new_cap\n        _e = self.g[self.pos[i][0]][self.pos[i][1]]\n        _re = self.g[_e.to][_e.rev]\n        _e.cap = new_cap - new_flow\n        _re.cap = new_flow\n    \n    def flow(self, s: int, t: int):\n        return self.flow_(s, t, self.numeric_limits_max)\n\n    def flow_(self, s: int, t: int, flow_limit: int) -> int:\n        assert 0 <= s and s < self._n\n        assert 0 <= t and t < self._n\n        level = [0] * self._n; it = [0] * self._n\n        \n        def bfs():\n            for i in range(self._n): level[i] = -1\n            level[s] = 0\n            que = deque([s])\n            while que:\n                v = que.popleft()\n                for e in self.g[v]:\n                    if e.cap == 0 or level[e.to] >= 0: continue\n                    level[e.to] = level[v] + 1\n                    if e.to == t: return    \n                    que.append(e.to)\n\n        def dfs(self_, v: int, up: int) -> int:\n            if v == s: return up\n            res = 0\n            level_v = level[v]\n            for i in range(it[v], len(self.g[v])):\n                it[v] = i\n                e = self.g[v][i]\n                if level_v <= level[e.to] or self.g[e.to][e.rev].cap == 0: continue\n                d = self_(self_, e.to, min(up - res, self.g[e.to][e.rev].cap))\n                if d <= 0: continue\n                self.g[v][i].cap += d\n                self.g[e.to][e.rev].cap -= d\n                res += d\n                if res == up: break\n            return res\n        \n        flow = 0\n        while flow < flow_limit:\n            bfs()\n            if level[t] == -1: break\n            for i in range(self._n): it[i] = 0\n            while flow < flow_limit:\n                f = dfs(dfs, t, flow_limit - flow)\n                if not f: break\n                flow += f\n        return flow\n    \n    def min_cut(self, s: int) -> list:\n        visited = [False] * self._n\n        que = deque([s])\n        while que:\n            p = que.popleft()\n            visited[p] = True\n            for e in self.g[p]:\n                if e.cap and not visited[e.to]:\n                    visited[e.to] = True\n                    que.append(e.to)\n        return visited\n\n    class _edge:\n        def __init__(s, to: int, rev: int, cap: int):\n            s.to = to; s.rev = rev; s.cap = cap\n\n# mincostflow.py\n# from heapq import heappop, heappush\nclass mcf_graph:\n    numeric_limits_max = 10 ** 18\n\n    def __init__(self, n: int):\n        self._n = n\n        self.g = [[] for _ in range(n)]\n        self.pos = []\n\n    def add_edge(self, _from: int, _to: int, cap: int, cost: int) -> int:\n        assert 0 <= _from and _from < self._n\n        assert 0 <= _to and _to < self._n\n        m = len(self.pos)\n        self.pos.append((_from, len(self.g[_from])))\n        self.g[_from].append(self._edge(_to, len(self.g[_to]), cap, cost))\n        self.g[_to].append(self._edge(_from, len(self.g[_from]) - 1, 0, -cost))\n        return m\n    \n    class edge:\n        def __init__(s, _from: int, _to: int, cap: int, flow: int, cost: int):\n            s._from = _from; s._to = _to; s.cap = cap; s.flow = flow; s.cost = cost\n    \n    def get_edge(self, i: int) -> edge:\n        m = len(self.pos)\n        assert 0 <= i and i < m\n        _e = self.g[self.pos[i][0]][self.pos[i][1]]\n        _re = self.g[_e.to][_e.rev]\n        return self.edge(self.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap, _e.cost)\n    \n    def edges(self) -> list:\n        m = len(self.pos)\n        result = [self.get_edge(i) for i in range(m)]\n        return result\n    \n    def flow(self, s: int, t: int) -> edge:\n        return self.flow_(s, t, self.numeric_limits_max)\n    def flow_(self, s: int, t: int, flow_limit: int) -> edge:\n        return self.__slope(s, t, flow_limit)[-1]\n    \n    def slope(self, s: int, t: int) -> list:\n        return self.slope_(s, t, self.numeric_limits_max)\n    def slope_(self, s: int, t: int, flow_limit: int) -> list:\n        return self.__slope(s, t, flow_limit)\n    \n    def __slope(self, s: int, t: int, flow_limit: int) -> list:\n        assert 0 <= s and s < self._n\n        assert 0 <= t and t < self._n\n        assert s != t\n        dual = [0] * self._n; dist = [0] * self._n\n        pv, pe = [-1] * self._n, [-1] * self._n\n        vis = [False] * self._n\n        \n        def dual_ref():\n            for i in range(self._n):\n                dist[i] = self.numeric_limits_max\n                pv[i] = -1\n                pe[i] = -1\n                vis[i] = False\n            class Q:\n                def __init__(s, key: int, to: int):\n                    s.key = key; s.to = to\n                def __lt__(s, r): return s.key < r.key\n            que = []\n            dist[s] = 0\n            heappush(que, Q(0, s))\n            while que:\n                v = heappop(que).to\n                if vis[v]: continue\n                vis[v] = True\n                if v == t: break\n                for i in range(len(self.g[v])):\n                    e = self.g[v][i]\n                    if vis[e.to] or not e.cap: continue\n                    cost = e.cost - dual[e.to] + dual[v]\n                    if dist[e.to] - dist[v] > cost:\n                        dist[e.to] = dist[v] + cost\n                        pv[e.to] = v\n                        pe[e.to] = i\n                        heappush(que, Q(dist[e.to], e.to))\n            if not vis[t]: return False\n            for v in range(self._n):\n                if not vis[v]: continue\n                dual[v] -= dist[t] - dist[v]\n            return True\n\n        flow = 0\n        cost = 0; prev_cost = -1\n        result = []\n        result.append((flow, cost))\n        while flow < flow_limit:\n            if not dual_ref(): break\n            c = flow_limit - flow\n            v = t\n            while v != s:\n                c = min(c, self.g[pv[v]][pe[v]].cap)\n                v = pv[v]\n            v = t\n            while v != s:\n                e = self.g[pv[v]][pe[v]]\n                e.cap -= c\n                self.g[v][e.rev].cap += c\n                v = pv[v]\n            d = -dual[s]\n            flow += c\n            cost += c * d\n            if prev_cost == d:\n                result.pop()\n            result.append((flow, cost))\n            prev_cost = cost\n        return result\n    class _edge:\n        def __init__(s, to: int, rev: int, cap: int, cost: int):\n            s.to = to; s.rev = rev; s.cap = cap; s.cost = cost\n\n# modint.py \nclass Mint:\n    modint1000000007 = 1000000007\n    modint998244353 = 998244353\n\n    def __init__(self, v: int = 0):\n        self.m = self.modint1000000007\n        # self.m = self.modint998244353\n        self.x = v % self.__umod()\n    \n    def inv(self):\n        if is_prime_constexpr(self.__umod()):\n            assert self.x\n            return self.pow_(self.__umod() - 2)\n        else:\n            eg = inv_gcd(self.x, self.m)\n            assert eg[0] == 1\n            return eg[2]\n\n    def __str__(self): return str(self.x)\n    def __le__(self, other): return self.x <= Mint.__get_val(other)\n    def __lt__(self, other): return self.x < Mint.__get_val(other)\n    def __ge__(self, other): return self.x >= Mint.__get_val(other)\n    def __gt(self, other): return self.x > Mint.__get_val(other)\n    def __eq__(self, other): return self.x == Mint.__get_val(other)\n    \n    def __iadd__(self, other):\n        self.x += Mint.__get_val(other)\n        if self.x >= self.__umod(): self.x -= self.__umod()\n        return self\n    def __add__(self, other):\n        _v = Mint(self.x); _v += other\n        return _v\n\n    def __isub__(self, other):\n        self.x -= Mint.__get_val(other)\n        if self.x >= self.__umod(): self.x += self.__umod()\n        return self\n    def __sub__(self, other):\n        _v = Mint(self.x); _v -= other\n        return _v\n    def __rsub__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v -= self\n        return _v\n    \n    def __imul__(self, other):\n        self.x =self.x * Mint.__get_val(other) % self.__umod()\n        return self\n    def __mul__(self, other):\n        _v = Mint(self.x); _v *= other\n        return _v\n\n    def __itruediv__(self, other):\n        self.x = self.x / Mint.__get_val(other) % self.__umod()\n        return self\n    def __truediv__(self, other):\n        _v = Mint(self.x); _v /= other\n        return _v\n    def __rtruediv__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v /= self\n        return _v\n    \n    def __ifloordiv__(self, other):\n        other = other if isinstance(other, Mint) else Mint(other)\n        self *= other.inv()\n        return self\n    def __floordiv__(self, other):\n        _v = Mint(self.x); _v //= other\n        return _v\n    def __rfloordiv__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v //= self\n        return _v\n\n    def __pow__(self, other):\n        _v = Mint(pow(self.x, Mint.__get_val(other), self.__umod()))\n        return _v\n    def __rpow__(self, other):\n        _v = Mint(pow(Mint.__get_val(other), self.x, self.__umod()))\n        return _v\n\n    def __imod__(self, other):\n        self.x %= Mint.__get_val(other)\n        return self\n    def __mod__(self, other):\n        _v = Mint(self.x); _v %= other\n        return _v\n    def __rmod__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v %= self\n        return _v\n\n    def __ilshift__(self, other):\n        self.x <<= Mint.__get_val(other)\n        return self\n    def __irshift__(self, other):\n        self.x >>= Mint.__get_val(other)\n        return self\n    def __lshift__(self, other):\n        _v = Mint(self.x); _v <<= other\n        return _v\n    def __rshift__(self, other):\n        _v = Mint(self.x); _v >>= other\n        return _v\n    def __rlshift__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v <<= self\n        return _v\n    def __rrshift__(self, other):\n        _v = Mint(Mint.__get_val(other)); _v >>= self\n        return _v\n    \n    __repr__ = __str__\n    __radd__ = __add__\n    __rmul__ = __mul__\n\n    def __umod(self): return self.m\n    \n    @staticmethod\n    def __get_val(val): return val.x if isinstance(val, Mint) else val\n \n    def pow_(self, n: int):\n        assert 0 <= n\n        x = Mint(self.x); r = 1\n        while n:\n            if n & 1: r *= x\n            x *= x\n            n >>= 1\n        return r\n    def val(self): return self.x\n    def mod(self): return self.m\n    def raw(self, v):\n        x = Mint()\n        x.x = v\n        return x\n\n# scc.py\nclass scc_graph_sub:\n    # public\n    def __init__(self, n):\n        self.internal = scc_graph(n)\n    \n    def add_edge(self, _from, _to):\n        n = self.internal.num_vertices()\n        assert 0 <= _from and _from < n\n        assert 0 <= _to and _to < n\n        self.internal.add_edge(_from, _to)\n    \n    def scc(self): return self.internal.scc()\n    \n# segtree.py\n'''\ndef e(): return\ndef op(l, r): return\ndef f(): return\n'''\nclass segtree:\n    def __init__(self, op, e, v: list):\n        self._n = len(v)\n        self.log = ceil_pow2(self._n)\n        self.size = 1 << self.log\n        self.op = op; self.e = e\n        self.d = [self.e()] * (self.size * 2)\n        for i in range(self._n): self.d[self.size + i] = v[i]\n        for i in range(self.size - 1, 0, -1): self.__update(i)\n    \n    def set_(self, p: int, x: int):\n        assert 0 <= p and p < self._n\n        p += self.size\n        self.d[p] = x\n        for i in range(1, self.log + 1): self.__update(p >> i)\n    \n    def get(self, p: int):\n        assert 0 <= p and p < self._n\n        return self.d[p + self.size]\n\n    def prod(self, l: int, r: int):\n        assert 0 <= l and l <= r and r <= self._n\n        l += self.size; r += self.size\n        sml, smr = self.e(), self.e()\n        while l < r:\n            if l & 1: sml = self.op(sml, self.d[l]); l += 1\n            if r & 1: r -= 1; smr = self.op(self.d[r], smr)\n            l >>= 1; r >>= 1\n        return self.op(sml, smr)\n\n    def all_prod(self): return self.d[1]\n\n    def max_right(self, l: int, f):\n        assert 0 <= l and l <= self._n\n        assert f(self.e())\n        if l == self._n: return self._n\n        l += self.size\n        sm = self.e()\n        while True:\n            while l % 2 == 0: l >>= 1\n            if not f(self.op(sm, self.d[l])):\n                while l < self.size:\n                    l = 2 * l\n                    if f(self.op(sm, self.d[l])):\n                        sm = self.op(sm, self.d[l])\n                        l += 1\n                return l - self.size\n            sm = self.op(sm, self.d[l])\n            l += 1\n            if (l & -l) == l: break\n        return self._n\n    \n    def min_left(self, r: int, f):\n        assert 0 <= r and r <= self._n\n        assert f(self.e())\n        if r == 0: return 0\n        r += self.size\n        sm = self.e()\n        while True:\n            r -= 1\n            while r > 1 and r % 2: r >>= 1\n            if not f(self.op(self.d[r], sm)):\n                while r < self.size:\n                    r = 2 * r + 1\n                    if f(self.op(self.d[r], sm)):\n                        sm = self.op(self.d[r], sm)\n                        r -= 1\n                return r + 1 - self.size\n            sm = self.op(self.d[r], sm)\n            if (r & -r) == r: break\n        return 0\n\n    def __update(self, k: int): self.d[k] = self.op(self.d[k * 2], self.d[k * 2 + 1])\n\n# string.py\ndef sa_native(s: list):\n    from functools import cmp_to_key\n    def mycmp(r, l):\n        if l == r: return -1\n        while l < n and r < n:\n            if s[l] != s[r]: return 1 if s[l] < s[r] else -1\n            l += 1\n            r += 1\n        return 1 if l == n else -1\n    n = len(s)\n    sa = [i for i in range(n)]\n    sa.sort(key=cmp_to_key(mycmp))\n    return sa\n\ndef sa_doubling(s: list):\n    from functools import cmp_to_key\n    def mycmp(y, x):\n        if rnk[x] != rnk[y]: return 1 if rnk[x] < rnk[y] else -1\n        rx = rnk[x + k] if x + k < n else - 1\n        ry = rnk[y + k] if y + k < n else - 1\n        return 1 if rx < ry else -1\n        \n    n = len(s)\n    sa = [i for i in range(n)]; rnk = s; tmp = [0] * n; k = 1\n    while k < n:\n        sa.sort(key=cmp_to_key(mycmp))\n        tmp[sa[0]] = 0\n        for i in range(1, n):\n            tmp[sa[i]] = tmp[sa[i - 1]]\n            if mycmp(sa[i], sa[i - 1]): tmp[sa[i]] += 1\n        tmp, rnk = rnk, tmp\n        k *= 2\n    return sa\n\ndef sa_is(s: list, upper: int):\n    THRESHOLD_NATIVE = 10\n    THRESHOLD_DOUBLING = 40\n    n = len(s)\n    if n == 0: return []\n    if n == 1: return [0]\n    if n == 2:\n        if s[0] < s[1]:\n            return [0, 1]\n        else:\n            return [1, 0]\n    if n < THRESHOLD_NATIVE:\n        return sa_native(s)\n    if n < THRESHOLD_DOUBLING:\n        return sa_doubling(s)\n    \n    sa = [0] * n\n    ls = [False] * n\n    for i in range(n - 2, -1, -1):\n        ls[i] = ls[i + 1] if s[i] == s[i + 1] else s[i] < s[i + 1]\n    \n    sum_l = [0] * (upper + 1); sum_s = [0] * (upper + 1)\n    for i in range(n):\n        if not ls[i]:\n            sum_s[s[i]] += 1\n        else:\n            sum_l[s[i] + 1] += 1\n    for i in range(upper + 1):\n        sum_s[i] += sum_l[i]\n        if i < upper: sum_l[i + 1] += sum_s[i]\n        \n    def induce(lms: list):\n        from copy import copy\n        for i in range(n): sa[i] = -1\n        buf = copy(sum_s)\n        for d in lms:\n            if d == n: continue\n            sa[buf[s[d]]] = d; buf[s[d]] += 1\n        \n        buf = copy(sum_l)\n        sa[buf[s[n - 1]]] = n - 1; buf[s[n - 1]] += 1\n        for i in range(n):\n            v = sa[i]\n            if v >= 1 and not ls[v - 1]:\n                sa[buf[s[v - 1]]] = v - 1; buf[s[v - 1]] += 1\n        \n        buf = copy(sum_l)\n        for i in range(n - 1, -1, -1):\n            v = sa[i]\n            if v >= 1 and ls[v - 1]:\n                buf[s[v - 1] + 1] -= 1; sa[buf[s[v - 1] + 1]] = v - 1\n\n    lms_map = [-1] * (n + 1)\n    m = 0\n    for i in range(1, n):\n        if not ls[i - 1] and ls[i]:\n            lms_map[i] = m; m += 1\n    \n    lms = [i for i in range(1, n) if not ls[i - 1] and ls[i]]\n    induce(lms)\n\n    if m:\n        sorted_lms = [v for v in sa if lms_map[v] != -1]\n        rec_s = [0] * m\n        rec_upper = 0\n        rec_s[lms_map[sorted_lms[0]]] = 0\n        for i in range(1, m):\n            l = sorted_lms[i - 1]; r = sorted_lms[i]\n            end_l = lms[lms_map[l] + 1] if lms_map[l] + 1 < m else n\n            end_r = lms[lms_map[r] + 1] if lms_map[r] + 1 < m else n\n            same = True\n            if end_l - l != end_r - r:\n                same = False\n            else:\n                while l < end_l:\n                    if s[l] != s[r]: break\n                    l += 1\n                    r += 1\n                if l == n or s[l] != s[r]: same = False\n            if not same: rec_upper += 1\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper\n        \n        rec_sa = sa_is(rec_s, rec_upper)\n\n        for i in range(m):\n            sorted_lms[i] = lms[rec_sa[i]]\n        induce(sorted_lms)\n    return sa\n\ndef suffix_array(s: list, upper: int):\n    assert 0 <= upper\n    for d in s:\n        assert 0 <= d and d <= upper\n    sa = sa_is(s, upper)\n    return sa\n\ndef suffix_array2(s: list):\n    from functools import cmp_to_key\n    n = len(s)\n    idx = [i for i in range(n)]\n    idx.sort(key=cmp_to_key(lambda l, r: s[l] < s[r]))\n    s2 = [0] * n\n    now = 0\n    for i in range(n):\n        if i and s[idx[i - 1]] != s[idx[i]]: now += 1\n        s2[idx[i]] = now\n    return sa_is(s2, now)\n\ndef suffix_array3(s: str):\n    n = len(s)\n    s2 = list(map(ord, s))\n    return sa_is(s2, 255)\n\ndef lcp_array(s: list, sa: list):\n    n = len(s)\n    assert n >= 1\n    rnk = [0] * n\n    for i in range(n):\n        rnk[sa[i]] = i\n    lcp = [0] * (n - 1)\n    h = 0\n    for i in range(n):\n        if h > 0: h -= 1\n        if rnk[i] == 0: continue\n        j = sa[rnk[i] - 1]\n        while j + h < n and i + h < n:\n            if s[j + h] != s[i + h]: break\n            h += 1\n        lcp[rnk[i] - 1] = h\n    return lcp\n\ndef lcp_array2(s: str, sa: list):\n    n = len(s)\n    s2 = list(map(ord, s))\n    return lcp_array(s2, sa)\n\ndef z_algorithm(s: list):\n    n = len(s)\n    if n == 0: return []\n    z = [-1] * n\n    z[0] = 0; j = 0\n    for i in range(1, n):\n        k = z[i] = 0 if j + z[j] <= i else min(j + z[j] - i, z[i - j])\n        while i + k < n and s[k] == s[i + k]: k += 1\n        z[i] = k\n        if j + z[j] < i + z[i]: j = i\n    z[0] = n\n    return z\n\ndef z_algorithm2(s: str):\n    n = len(s)\n    s2 = list(map(ord, s))\n    return z_algorithm(s2)\n\n# twosat.py\nclass two_sat:\n    def __init__(self, n: int):\n        self._n = n\n        self.scc = scc_graph(2 * n)\n        self._answer = [False] * n\n    \n    def add_clause(self, i: int, f: bool, j: int, g: bool):\n        assert 0 <= i and i < self._n\n        assert 0 <= j and j < self._n\n        self.scc.add_edge(2 * i + (not f), 2 * j + g)\n        self.scc.add_edge(2 * j + (not g), 2 * i + f)\n        \n    def satisfiable(self) -> bool:\n        _id = self.scc.scc_ids()[1]\n        for i in range(self._n):\n            if _id[2 * i] == _id[2 * i + 1]: return False\n            self._answer[i] = _id[2 * i] < _id[2 * i + 1]\n        return True\n    \n    def answer(self): return self._answer\n\n# --------------------<< Library End >>-------------------- #\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef Main_A():\n    n, q = read_ints()\n    d = dsu(n)\n    for _ in range(q):\n        t, u, v = read_ints()\n        if t == 0:\n            d.merge(u, v)\n        else:\n            print(int(d.same(u, v)))\n\ndef Main_B():\n    n, q = read_ints()\n    a = read_int_list()\n    fw = fenwick_tree(n)\n    for i, x in enumerate(a):\n        fw.add(i, x)\n    for _ in range(q):\n        query = read_int_list()\n        if query[0] == 0:\n            fw.add(query[1], query[2])\n        else:\n            print(fw.sum(query[1], query[2]))\n\ndef Main_C():\n    for _ in range(read_int()):\n        n, m, a, b = read_ints()\n        print(floor_sum(n, m, a, b))\n\n#from collections import deque\ndef Main_D():\n    n, m = read_ints()\n    grid = [list(read_str()) for _ in range(n)]\n    mf = mf_graph(n * m + 2)\n    start = n * m\n    end = start + 1\n    dir = [(1, 0), (0, 1)]\n    \n    for y in range(n):\n        for x in range(m):\n            if (y + x) % 2 == 0:\n                mf.add_edge(start, m*y + x, 1)\n            else:\n                mf.add_edge(m*y + x, end, 1)\n            \n            if grid[y][x] == '.':\n                for dy, dx in dir:\n                    ny = y + dy; nx = x + dx\n                    if ny < n and nx < m and grid[ny][nx] == '.':\n                        f, t = y*m + x, ny*m + nx\n                        if (y + x) % 2: f, t = t, f\n                        mf.add_edge(f, t, 1)\n\n    ans = mf.flow(start, end)\n    for y in range(n):\n        for x in range(m):\n            for e in mf.g[y * m + x]:\n                to, rev, cap = e.to, e.rev, e.cap\n                ny, nx = divmod(to, m)\n                if (y + x) % 2 == 0 and cap == 0 and to != start and to != end and (y*m+x) != start and (y*m+x) != end:\n                    if y + 1 == ny: grid[y][x] = 'v'; grid[ny][nx] = '^'\n                    elif y == ny + 1: grid[y][x] = '^'; grid[ny][nx] = 'v'\n                    elif x + 1 == nx: grid[y][x] = '>'; grid[ny][nx] = '<'\n                    elif x == nx + 1: grid[y][x] = '<'; grid[ny][nx] = '>'\n                        \n    print(ans)\n    print(*[''.join(ret) for ret in grid], sep='\\n')\n\n#from heapq import heappop, heappush\ndef Main_E():\n    n, k = read_ints()\n    a = [read_int_list() for _ in range(n)]\n    mcf = mcf_graph(n * 2 + 2)\n    s = n * 2\n    t = n * 2 + 1\n \n    for i in range(n):\n        mcf.add_edge(s, i, k, 0)\n        mcf.add_edge(i + n, t, k, 0)\n    mcf.add_edge(s, t, n * k, INF)\n    \n    for i in range(n):\n        for j in range(n):\n            mcf.add_edge(i, n + j, 1, INF - a[i][j])\n    \n    result = mcf.flow_(s, t, n * k)\n    print(n * k * INF - result[1])\n    grid = [['.'] * n for _ in range(n)]\n    edges = mcf.edges()\n    for e in edges:\n        if e._from == s or e._to == t or e.flow == 0: continue\n        grid[e._from][e._to - n] = 'X'\n    print(*[''.join(g) for g in grid], sep='\\n')\n\ndef Main_F():\n    MOD = 998244353\n    n, m = read_ints()\n    a = read_int_list()\n    b = read_int_list()\n    a = [x % MOD for x in a]\n    b = [x % MOD for x in b]\n    cnv = convolution(a,b,MOD)\n    ans = cnv.convolution()\n    print(*ans)\n\ndef Main_G():\n    sys.setrecursionlimit(10 ** 6)\n    n, m = read_ints()\n    scc = scc_graph(n)\n    for _ in range(m):\n        a, b = read_ints()\n        scc.add_edge(a, b)\n    ans = scc.scc()\n    print(len(ans))\n    for v in ans:\n        print(len(v), ' '.join(map(str, v[::-1])))\n\ndef Main_H():\n    n, d = read_ints()\n    xy = [read_int_list() for _ in range(n)]\n    tw = two_sat(n)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for x in range(2):\n                if abs(xy[i][0] - xy[j][0]) < d: tw.add_clause(i, False, j, False)\n                if abs(xy[i][0] - xy[j][1]) < d: tw.add_clause(i, False, j, True)\n                if abs(xy[i][1] - xy[j][0]) < d: tw.add_clause(i, True, j, False)\n                if abs(xy[i][1] - xy[j][1]) < d: tw.add_clause(i, True, j, True)\n                \n    if not tw.satisfiable():\n        print('No')\n        exit()\n    print('Yes')\n    ans = tw.answer()\n    for i, flag in enumerate(ans):\n        print(xy[i][0] if flag else xy[i][1])\n\ndef Main_I():\n    s = read_str()\n    sa = suffix_array3(s)\n    ans = len(s) * (len(s) + 1) // 2\n    for x in lcp_array2(s, sa):\n        ans -= x\n    print(ans)\n\ndef Main_J():\n    def op(l, r): return max(l, r)\n    def e(): return -1\n    def f(n): return n < r\n    n, q = read_ints()\n    a = read_int_list()\n    seg = segtree(op, e, a)\n    query = [(read_ints()) for _ in range(q)]\n    for i in range(q):\n        t, l, r = query[i]\n        if t == 1:\n            seg.set_(~-l, r)\n        elif t == 2:\n            print(seg.prod(~-l, r))\n        else:\n            print(seg.max_right(~-l, f) + 1)\n\ndef Main_K():\n    p = 998244353\n    def op(l, r):\n        l1, l2 = l >> 32, l % (1 << 32)\n        r1, r2 = r >> 32, r % (1 << 32)    \n        return (((l1 + r1) % p) << 32) + l2 + r2\n    def e(): return 0\n    def mapping(l, r):\n        l1, l2 = l >> 32, l % (1 << 32)\n        r1, r2 = r >> 32, r % (1 << 32)\n        return (((l1 * r1 + l2 * r2) % p) << 32) + r2\n    def composition(l, r):\n        l1, l2 = l >> 32, l % (1 << 32)\n        r1, r2 = r >> 32, r % (1 << 32)\n        return ((l1 * r1 % p) << 32) + (l1 * r2 + l2) % p\n    def id(): return 1 << 32\n    n, q = read_ints()\n    A = read_int_list()\n    A = [(x << 32) + 1 for x in A]\n    \n    seg = lazy_segtree(op, e, mapping, composition, id, A)\n    ans = []\n    for _ in range(q):\n        query = read_int_list()\n        if query[0] == 0:\n            l, r, b, c = query[1:]\n            seg.apply(l, r, (b << 32) + c)\n        else:\n            l, r = query[1:]\n            print(seg.prod(l, r) >> 32)\n\ndef Main_L():\n    def op(l: tuple, r: tuple): return (l[0] + r[0], l[1] + r[1], l[2] + r[2] + l[1] * r[0])\n    def e(): return (0, 0, 0)\n    def mapping(l:bool, r: tuple):\n        if not l: return r\n        return (r[1], r[0], r[1] * r[0] - r[2])\n    def composition(l: bool, r: bool): return l ^ r\n    def id(): return False\n    n, q = read_ints()\n    A = read_int_list()\n    query = [(read_ints()) for _ in range(q)]\n    \n    a = [(1, 0, 0) if i == 0 else (0, 1, 0) for i in A]\n    seg = lazy_segtree(op, e, mapping, composition, id, a)\n \n    for t, l, r in query:\n        if t == 1:\n            seg.apply(~-l, r, True)\n        else:\n            print(seg.prod(~-l, r)[2])\n\nif __name__ == '__main__':\n    Main_H()"
  },
  {
    "language": "Python",
    "code": "# Date [ 2020-09-12 10:24:21 ]\n# Problem [ h.py ]\n# Author Koki_tkg\n\nclass two_sat:\n    def __init__(self, n: int):\n        self._n = n\n        self.scc = scc_graph(2 * n)\n        self._answer = [False] * n\n    \n    def add_clause(self, i: int, f: bool, j: int, g: bool):\n        assert 0 <= i and i < self._n\n        assert 0 <= j and j < self._n\n        self.scc.add_edge(2 * i + (not f), 2 * j + g)\n        self.scc.add_edge(2 * j + (not g), 2 * i + f)\n        \n    def satisfiable(self) -> bool:\n        _id = self.scc.scc_ids()[1]\n        for i in range(self._n):\n            if _id[2 * i] == _id[2 * i + 1]: return False\n            self._answer[i] = _id[2 * i] < _id[2 * i + 1]\n        return True\n    \n    def answer(self): return self._answer\n\nclass csr:\n    def __init__(self, n: int, edges: list):\n        from copy import deepcopy\n        self.start = [0] * (n + 1)\n        self.elist = [[] for _ in range(len(edges))]\n        for e in edges:\n            self.start[e[0] + 1] += 1\n        for i in range(1, n + 1):\n            self.start[i] += self.start[i - 1]\n        counter = deepcopy(self.start)\n        for e in edges:\n            self.elist[counter[e[0]]] = e[1]; counter[e[0]] += 1\n\nclass scc_graph:\n    # private\n    edges = []\n    \n    # public\n    def __init__(self, n: int):\n        self._n = n\n        self.now_ord = 0; self.group_num = 0\n    \n    def num_vertices(self): return self._n\n\n    def add_edge(self, _from: int, _to: int): self.edges.append((_from, [_to]))\n    \n    def scc_ids(self):\n        g = csr(self._n, self.edges)\n        visited = []; low = [0] * self._n; ord = [-1] * self._n; ids = [0] * self._n\n        \n        def dfs(s, v: int):\n            low[v] = ord[v] = self.now_ord; self.now_ord += 1\n            visited.append(v)\n            for i in range(g.start[v], g.start[v + 1]):\n                to = g.elist[i][0]\n                if ord[to] == -1:\n                    s(s, to)\n                    low[v] = min(low[v], low[to])\n                else:\n                    low[v] = min(low[v], ord[to])\n            if low[v] == ord[v]:\n                while True:\n                    u = visited.pop()\n                    ord[u] = self._n\n                    ids[u] = self.group_num\n                    if u == v: break\n                self.group_num += 1\n\n        for i in range(self._n):\n            if ord[i] == -1: dfs(dfs, i)\n        for i in range(self._n):\n            ids[i] = self.group_num - 1 - ids[i]\n\n        return (self.group_num, ids)\n        \n    def scc(self):\n        ids = self.scc_ids()\n        group_num = ids[0]\n        counts = [0] * group_num\n        for x in ids[1]: counts[x] += 1\n        groups = [[] for _ in range(group_num)]\n        for i in range(self._n):\n            groups[ids[1][i]].append(i)\n        return groups\n\n\nimport sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef Main():\n    n, d = read_ints()\n    xy = [read_int_list() for _ in range(n)]\n    tw = two_sat(n)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for x in range(2):\n                if abs(xy[i][0] - xy[j][0]) < d: tw.add_clause(i, False, j, False)\n                if abs(xy[i][0] - xy[j][1]) < d: tw.add_clause(i, False, j, True)\n                if abs(xy[i][1] - xy[j][0]) < d: tw.add_clause(i, True, j, False)\n                if abs(xy[i][1] - xy[j][1]) < d: tw.add_clause(i, True, j, True)\n                \n    if not tw.satisfiable():\n        print('No')\n        exit()\n    print('Yes')\n    ans = tw.answer()\n    for i, flag in enumerate(ans):\n        print(xy[i][0] if flag else xy[i][1])\n\nif __name__ == '__main__':\n    Main()"
  },
  {
    "language": "Python",
    "code": "#-------最強ライブラリ2-SAT(Python)------\n#最強ライブラリSCC(Python)が必要\n\nclass two_sat:\n  def __init__(s):\n    s._n = 0\n    s.scc = scc_graph(0)\n  def __init__(s, n):\n    s._n = n\n    s._answer = [False] * n\n    s.scc = scc_graph(2 * n)\n\n  # クローズを足す\n  # クローズってなに\n  def add_clause(s, i, f, j, g):\n    s.scc.add_edge(2 * i + (not f), 2 * j + (g))\n    s.scc.add_edge(2 * j + (not g), 2 * i + (f))\n  \n  # 判定\n  # O(n + m)\n  def satisfiable(s):\n    id = s.scc.scc_ids()[1]\n    for i in range(s._n):\n      if id[2 * i] == id[2 * i + 1]: return False\n      s._answer[i] = id[2 * i] < id[2 * i + 1]\n    return True\n\n  # クローズを満たす割当を返す\n  # satisfiableがTrueとなった後に呼ばないと意味ない\n  # O(1だよね？）\n  def answer(s): return s._answer\n\n\n#-------最強ライブラリここまで------\n\n\n#-------最強ライブラリSCC(Python) ver83025------\nimport sys\nsys.setrecursionlimit(1000000)\n\nclass scc_graph:\n  # n 頂点数\n  def __init__(s, n): \n    s._n = n\n    s.g = {}\n  def num_vertices(s): return s._n\n  # 辺を追加 frm 矢元 to 矢先\n  # O(1)\n  def add_edge(s, frm, to): \n    if frm in s.g: s.g[frm].append(to)\n    else: s.g[frm] = [to]\n\n  # グループの個数と各頂点のグループidを返す\n  def scc_ids(s):\n    now_ord = group_num = 0\n    visited = []\n    low = [0] * s._n\n    ord = [-1] * s._n\n    ids = [0] * s._n\n    # 再帰関数 \n    def dfs(self, v, now_ord, group_num):\n      low[v] = ord[v] = now_ord\n      now_ord += 1\n      visited.append(v)\n      if v in s.g:\n        for to in s.g[v]:\n          if ord[to] == -1:\n            now_ord, group_num = self(self, to, now_ord, group_num)\n            low[v] = min(low[v], low[to])\n          else:\n            low[v] = min(low[v], ord[to])\n      if low[v] == ord[v]:\n        while True:\n          u = visited.pop()\n          ord[u] = s._n\n          ids[u] = group_num\n          if u == v: break\n        group_num += 1\n      return now_ord, group_num\n\n    for i in range(s._n):\n      if ord[i] == -1: now_ord, group_num = dfs(dfs, i, now_ord, group_num)\n    for i in range(s._n):\n      ids[i] = group_num - 1 - ids[i]\n    return group_num, ids\n\n  # 強連結成分となっている頂点のリストのリスト トポロジカルソート済み\n  # O(n + m)\n  def scc(s):\n    group_num, ids = s.scc_ids()\n    counts = [0] * group_num\n    for x in ids: counts[x] += 1\n    groups = [[] for _ in range(group_num)]\n    for i in range(s._n):\n      groups[ids[i]].append(i)\n    return groups\n\n  class edge:\n    def __init__(s, frm, to):\n      s.frm = frm\n      s.to = to\n\n#-------最強ライブラリここまで------\n\ndef main():\n  input = sys.stdin.readline\n\n  N, D = list(map(int, input().split()))\n  XY = [list(map(int, input().split())) for _ in range(N)]\n\n  ts = two_sat(N)\n\n  for i in range(N):\n    for j in range(i + 1, N):\n      xi, yi = XY[i]\n      xj, yj = XY[j]\n      # 距離がD未満の組み合わせに関して、\n      # 少なくとも一つは使用しない\n      # → 少なくとも一つは別の座標を使用する\n      # というルールを追加する\n      if (abs(xi - xj) < D):\n        ts.add_clause(i, False, j, False)\n      if (abs(xi - yj) < D):\n        ts.add_clause(i, False, j, True)\n      if (abs(yi - xj) < D):\n        ts.add_clause(i, True, j, False)\n      if (abs(yi - yj) < D):\n        ts.add_clause(i, True, j, True)\n\n  if not ts.satisfiable():\n    print(\"No\")\n    exit()\n\n  print(\"Yes\")\n  answer = ts.answer()\n  for i in range(N):\n    x, y = XY[i]\n    if answer[i]:\n      print(x)\n    else:\n      print(y)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n):\n        self.n = n\n        self.graph = [set() for _ in range(n)]\n        self.rev = [set() for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n\n    def add_edge(self, p, q):\n        self.graph[p].add(q)\n        self.rev[q].add(p)\n        self.deg[q] += 1\n\n    def topological_sort(self):\n        deg = self.deg[:]\n        res = [i for i in range(self.n) if deg[i] == 0]\n        queue = deque(res)\n        used = [False for _ in range(self.n)]\n        while queue:\n            node = queue.popleft()\n            for adj in self.graph[node]:\n                deg[adj] -= 1\n                if deg[adj] == 0:\n                    queue.append(adj)\n                    res.append(adj)\n        return res\n\n    def strongry_connected(self):\n        group = [None for _ in range(self.n)]\n        used = [0 for _ in range(self.n)]\n        order = []\n        for s in range(self.n):\n            if not used[s]:\n                stack = [s]\n                used[s] = 1\n                while stack:\n                    node = stack.pop()\n                    movable = False\n                    for adj in self.graph[node]:\n                        if not used[adj]:\n                            movable = True\n                            used[adj] = 1\n                            stack.append(node)\n                            stack.append(adj)\n                            break\n                    if not movable:\n                        order.append(node)\n        used = [0 for _ in range(self.n)]\n        count = 0\n        for s in order[::-1]:\n            if not used[s]:\n                stack = [s]\n                group[s] = count\n                while stack:\n                    node = stack.pop()\n                    used[node] = 1\n                    for adj in self.rev[node]:\n                        if not used[adj]:\n                            group[adj] = count\n                            stack.append(adj)\n                count += 1\n        return group, count\n\nimport sys\ninput = sys.stdin.buffer.readline\n\nN, D = map(int, input().split())\n\nX = []\nY = []\n\ng = Graph(2 * N)\n\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\n\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        if abs(X[i] - X[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(~j, i)\n        if abs(X[i] - Y[j]) < D:\n            g.add_edge(~i, j)\n            g.add_edge(j, ~i)\n        if abs(Y[i] - X[i]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(~j, i)\n        if abs(Y[i] - Y[j]) < D:\n            g.add_edge(i, ~j)\n            g.add_edge(j, ~i)\n\ngroup, count = g.strongry_connected()\n\ngroup_to_node = [[] for _ in range(count)]\n\nfor i in range(N):\n    if group[i] == group[~i]:\n        print('No')\n        break\n    group_to_node[group[i]].append(i)\n    group_to_node[group[~i]].append(~i)\n\nelse:\n    print('Yes')\n\n    comp = Graph(count)\n\n    for i in range(2 * N):\n        for j in g.graph[i]:\n            if group[i] == group[j]:\n                continue\n            comp.add_edge(group[i], group[j])\n\n    ts = comp.topological_sort()\n\n    res = [None for _ in range(N)]\n\n    for i in ts:\n        for node in group_to_node[i]:\n            if node >= 0:\n                if res[node] is None:\n                    res[node] = X[node]\n            else:\n                if res[~node] is None:\n                    res[~node] = Y[~node]\n\n    for i in range(N):\n        if res[i] is None:\n            res[i] = Y[node]\n\n    print('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "import sys\nrange = xrange\ninput = raw_input\n \ndef find_SCC(coupl):\n    SCC, S, P = [], [], []\n    depth = [0] * len(coupl)\n \n    stack = list(range(len(coupl)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += coupl[node]\n    return SCC[::-1]\n\nclass TwoSAT:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(2 * n)]\n\n    def _imply(self, x, y):\n        self.graph[x].append(y if y >= 0 else 2 * self.n + y)\n\n    def either(self, x, y):\n        \"\"\"either x or y must be True\"\"\"\n        self._imply(~x, y)\n        self._imply(~y, x)\n\n    def set(self, x):\n        \"\"\"x must be True\"\"\"\n        self._imply(~x, x)\n\n    def solve(self):\n        SCC = find_SCC(self.graph)\n        \n        inSCC = [0] * (2 * self.n)\n        for scc_ind, scc in enumerate(SCC):\n            for node in scc:\n                inSCC[node] = scc_ind\n        \n        for i in range(self.n):\n            if inSCC[i] == inSCC[~i]:\n                return False, None\n        \n        return True, [+(inSCC[i] < inSCC[~i]) for i in range(self.n)]\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \nn = inp[ii]; ii += 1\nd = inp[ii]; ii += 1\n\nsat = TwoSAT(n)\n\nX = inp[ii + 0: ii + 2 * n: 2] \nY = inp[ii + 1: ii + 2 * n: 2] \nii += 2 * n\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        \n        if abs(X[i] - X[j]) < d:\n            sat.either(i, j)\n        \n        if abs(Y[i] - Y[j]) < d:\n            sat.either(~i, ~j)\n        \n        if abs(X[i] - Y[j]) < d:\n            sat.either(i, ~j)\n        \n        if abs(Y[i] - X[j]) < d:\n            sat.either(~i, j)\n\nexists, solution = sat.solve()\n\nif not exists:\n    print 'No'\nelse:\n    print 'Yes'\n    print ' '.join(str(X[i] if b else Y[i]) for i, b in enumerate(solution))\n\n"
  },
  {
    "language": "Python",
    "code": "#-------最強ライブラリ2-SAT(Python)------\n#最強ライブラリSCC(Python)が必要\n\nclass two_sat:\n  def __init__(s):\n    s._n = 0\n    s.scc = scc_graph(0)\n  def __init__(s, n):\n    s._n = n\n    s._answer = [False] * n\n    s.scc = scc_graph(2 * n)\n\n  # クローズを足す\n  # クローズってなに\n  def add_clause(s, i, f, j, g):\n    s.scc.add_edge(2 * i + (not f), 2 * j + (g))\n    s.scc.add_edge(2 * j + (not g), 2 * i + (f))\n  \n  # 判定\n  # O(n + m)\n  def satisfiable(s):\n    id = s.scc.scc_ids()[1]\n    for i in range(s._n):\n      if id[2 * i] == id[2 * i + 1]: return False\n      s._answer[i] = id[2 * i] < id[2 * i + 1]\n    return True\n\n  # クローズを満たす割当を返す\n  # satisfiableがTrueとなった後に呼ばないと意味ない\n  # O(1だよね？）\n  def answer(s): return s._answer\n\n\n#-------最強ライブラリここまで------\n\n\n#-------最強ライブラリSCC(Python)ver25252------\n\nimport copy\nimport sys\nsys.setrecursionlimit(1000000)\n \nclass csr:\n  # start 頂点iまでの頂点が、矢元として現れた回数\n  # elist 矢先のリストを矢元の昇順にしたもの\n  def __init__(s, n, edges):\n    s.start = [0] * (n + 1)\n    s.elist = [[] for _ in range(len(edges))]\n    for e in edges:\n      s.start[e[0] + 1] += 1\n    for i in range(1, n + 1):\n      s.start[i] += s.start[i - 1]\n    counter = copy.deepcopy(s.start)\n    for e in edges:\n      s.elist[counter[e[0]]] = e[1]\n      counter[e[0]] += 1\n \nclass scc_graph:\n \n  edges = []\n \n  # n 頂点数\n  def __init__(s, n): s._n = n\n  def num_vertices(s): return s._n\n  # 辺を追加 frm 矢元 to 矢先\n  # O(1)\n  def add_edge(s, frm, to): s.edges.append([frm, [to]])\n \n  # グループの個数と各頂点のグループidを返す\n  def scc_ids(s):\n    g = csr(s._n, s.edges)\n    now_ord = group_num = 0\n    visited = []\n    low = [0] * s._n\n    ord = [-1] * s._n\n    ids = [0] * s._n\n    # 再帰関数 \n    def dfs(self, v, now_ord, group_num):\n      low[v] = ord[v] = now_ord\n      now_ord += 1\n      visited.append(v)\n      for i in range(g.start[v], g.start[v + 1]):\n        to = g.elist[i][0]\n        if ord[to] == -1:\n          now_ord, group_num = self(self, to, now_ord, group_num)\n          low[v] = min(low[v], low[to])\n        else:\n          low[v] = min(low[v], ord[to])\n      if low[v] == ord[v]:\n        while True:\n          u = visited.pop()\n          ord[u] = s._n\n          ids[u] = group_num\n          if u == v: break\n        group_num += 1\n      return now_ord, group_num\n \n    for i in range(s._n):\n      if ord[i] == -1: now_ord, group_num = dfs(dfs, i, now_ord, group_num)\n    for i in range(s._n):\n      ids[i] = group_num - 1 - ids[i]\n    return [group_num, ids]\n \n  # 強連結成分となっている頂点のリストのリスト トポロジカルソート済み\n  # O(n + m)\n  def scc(s):\n    ids = s.scc_ids()\n    group_num = ids[0]\n    counts = [0] * group_num\n    for x in ids[1]: counts[x] += 1\n    groups = [[] for _ in range(group_num)]\n    for i in range(s._n):\n      groups[ids[1][i]].append(i)\n    return groups\n \n \n#-------最強ライブラリここまで------\n\ndef main():\n  input = sys.stdin.readline\n\n  N, D = list(map(int, input().split()))\n  XY = [list(map(int, input().split())) for _ in range(N)]\n\n  ts = two_sat(N)\n\n  for i in range(N):\n    for j in range(i + 1, N):\n      xi, yi = XY[i]\n      xj, yj = XY[j]\n      # 距離がD未満の組み合わせに関して、\n      # 少なくとも一つは使用しない\n      # → 少なくとも一つは別の座標を使用する\n      # というルールを追加する\n      if (abs(xi - xj) < D):\n        ts.add_clause(i, False, j, False)\n      if (abs(xi - yj) < D):\n        ts.add_clause(i, False, j, True)\n      if (abs(yi - xj) < D):\n        ts.add_clause(i, True, j, False)\n      if (abs(yi - yj) < D):\n        ts.add_clause(i, True, j, True)\n\n  if not ts.satisfiable():\n    print(\"No\")\n    exit()\n\n  print(\"Yes\")\n  answer = ts.answer()\n  for i in range(N):\n    x, y = XY[i]\n    if answer[i]:\n      print(x)\n    else:\n      print(y)\n\nmain()"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n#[allow(unused_imports)]\nuse proconio::marker::*;\n#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\n#[allow(unused_imports)]\nuse std::f64::consts::*;\n\n#[allow(unused)]\nconst INF: usize = std::usize::MAX / 4;\n#[allow(unused)]\nconst M: usize = 1000000007;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),* $(,)*) => {\n        #[cfg(debug_assertions)]\n        eprintln!(concat!($(\"| \", stringify!($a), \"={:?} \"),*, \"|\"), $(&$a),*);\n    };\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: i64,\n        xy: [(i64, i64); n],\n    }\n    let mut sat = TwoSat::new(n);\n    for i in 0..n {\n        let (xi, yi) = xy[i];\n        for j in 0..i {\n            let (xj, yj) = xy[j];\n            if (xi - xj).abs() < d {\n                sat.add_clause(i, false, j, false);\n            }\n            if (xi - yj).abs() < d {\n                sat.add_clause(i, false, j, true);\n            }\n            if (yi - xj).abs() < d {\n                sat.add_clause(i, true, j, false);\n            }\n            if (yi - yj).abs() < d {\n                sat.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if sat.satisfiable() {\n        println!(\"Yes\");\n        let sol = sat.answer();\n        for i in 0..n {\n            let (xi, yi) = xy[i];\n            if sol[i] {\n                println!(\"{}\", xi);\n            } else {\n                println!(\"{}\", yi);\n            }\n        }\n    } else {\n        println!(\"No\");\n    }\n}\n//https://github.com/rust-lang-ja/ac-library-rs\n\npub mod internal_scc {\n    pub struct Csr<E> {\n        start: Vec<usize>,\n        elist: Vec<E>,\n    }\n\n    impl<E> Csr<E>\n    where\n        E: Copy,\n    {\n        pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n            let mut csr = Csr {\n                start: vec![0; n + 1],\n                elist: vec![init; edges.len()],\n            };\n            for e in edges.iter() {\n                csr.start[e.0 + 1] += 1;\n            }\n            for i in 1..=n {\n                csr.start[i] += csr.start[i - 1];\n            }\n            let mut counter = csr.start.clone();\n            for e in edges.iter() {\n                csr.elist[counter[e.0]] = e.1;\n                counter[e.0] += 1;\n            }\n            csr\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct _Edge {\n        to: usize,\n    }\n\n    /// Reference:\n    /// R. Tarjan,\n    /// Depth-First Search and Linear Graph Algorithms\n    pub struct SccGraph {\n        n: usize,\n        edges: Vec<(usize, _Edge)>,\n    }\n\n    impl SccGraph {\n        pub fn new(n: usize) -> Self {\n            SccGraph { n, edges: vec![] }\n        }\n\n        pub fn num_vertices(&self) -> usize {\n            self.n\n        }\n\n        pub fn add_edge(&mut self, from: usize, to: usize) {\n            self.edges.push((from, _Edge { to }));\n        }\n\n        /// return pair of (# of scc, scc id)\n        pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n            // In C++ ac-library, this function is implemented by using recursive lambda functions.\n            // Instead, we use fn and struct for capturing environments.\n            struct _Env {\n                g: Csr<_Edge>,\n                now_ord: usize,\n                group_num: usize,\n                visited: Vec<usize>,\n                low: Vec<usize>,\n                ord: Vec<Option<usize>>,\n                ids: Vec<usize>,\n            }\n            let mut env = _Env {\n                g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n                now_ord: 0,\n                group_num: 0,\n                visited: Vec::with_capacity(self.n),\n                low: vec![0; self.n],\n                ord: vec![None; self.n],\n                ids: vec![0; self.n],\n            };\n\n            fn dfs(v: usize, n: usize, env: &mut _Env) {\n                env.low[v] = env.now_ord;\n                env.ord[v] = Some(env.now_ord);\n                env.now_ord += 1;\n                env.visited.push(v);\n\n                for i in env.g.start[v]..env.g.start[v + 1] {\n                    let to = env.g.elist[i].to;\n                    if let Some(x) = env.ord[to] {\n                        env.low[v] = std::cmp::min(env.low[v], x);\n                    } else {\n                        dfs(to, n, env);\n                        env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                    }\n                }\n                if env.low[v] == env.ord[v].unwrap() {\n                    loop {\n                        let u = *env.visited.last().unwrap();\n                        env.visited.pop();\n                        env.ord[u] = Some(n);\n                        env.ids[u] = env.group_num;\n                        if u == v {\n                            break;\n                        }\n                    }\n                    env.group_num += 1;\n                }\n            }\n            for i in 0..self.n {\n                if env.ord[i].is_none() {\n                    dfs(i, self.n, &mut env);\n                }\n            }\n            for x in env.ids.iter_mut() {\n                *x = env.group_num - 1 - *x;\n            }\n            (env.group_num, env.ids)\n        }\n\n        pub fn scc(&self) -> Vec<Vec<usize>> {\n            let ids = self.scc_ids();\n            let group_num = ids.0;\n            let mut counts = vec![0usize; group_num];\n            for &x in ids.1.iter() {\n                counts[x] += 1;\n            }\n            let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n            for i in 0..group_num {\n                groups[i].reserve(counts[i]);\n            }\n            for i in 0..self.n {\n                groups[ids.1[i]].push(i);\n            }\n            groups\n        }\n    }\n}\npub mod twosat {\n    use crate::internal_scc;\n\n    pub struct TwoSat {\n        n: usize,\n        scc: internal_scc::SccGraph,\n        answer: Vec<bool>,\n    }\n    impl TwoSat {\n        pub fn new(n: usize) -> Self {\n            TwoSat {\n                n,\n                answer: vec![false; n],\n                scc: internal_scc::SccGraph::new(2 * n),\n            }\n        }\n        pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n            assert!(i < self.n && j < self.n);\n            self.scc.add_edge(2 * i + !f as usize, 2 * j + g as usize);\n            self.scc.add_edge(2 * j + !g as usize, 2 * i + f as usize);\n        }\n        pub fn satisfiable(&mut self) -> bool {\n            let id = self.scc.scc_ids().1;\n            for i in 0..self.n {\n                if id[2 * i] == id[2 * i + 1] {\n                    return false;\n                }\n                self.answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            true\n        }\n        pub fn answer(&self) -> &[bool] {\n            &self.answer\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        #![allow(clippy::many_single_char_names)]\n        use super::*;\n        #[test]\n        fn solve_alpc_h_sample1() {\n            // https://atcoder.jp/contests/practice2/tasks/practice2_h\n\n            let (n, d) = (3, 2);\n            let x = [1, 2, 0i32];\n            let y = [4, 5, 6];\n\n            let mut t = TwoSat::new(n);\n\n            for i in 0..n {\n                for j in i + 1..n {\n                    if (x[i] - x[j]).abs() < d {\n                        t.add_clause(i, false, j, false);\n                    }\n                    if (x[i] - y[j]).abs() < d {\n                        t.add_clause(i, false, j, true);\n                    }\n                    if (y[i] - x[j]).abs() < d {\n                        t.add_clause(i, true, j, false);\n                    }\n                    if (y[i] - y[j]).abs() < d {\n                        t.add_clause(i, true, j, true);\n                    }\n                }\n            }\n            assert!(t.satisfiable());\n            let answer = t.answer();\n            let mut res = vec![];\n            for (i, &v) in answer.iter().enumerate() {\n                if v {\n                    res.push(x[i])\n                } else {\n                    res.push(y[i]);\n                }\n            }\n\n            //Check the min distance between flags\n            res.sort();\n            let mut min_distance = i32::max_value();\n            for i in 1..res.len() {\n                min_distance = std::cmp::min(min_distance, res[i] - res[i - 1]);\n            }\n            assert!(min_distance >= d);\n        }\n\n        #[test]\n        fn solve_alpc_h_sample2() {\n            // https://atcoder.jp/contests/practice2/tasks/practice2_h\n\n            let (n, d) = (3, 3);\n            let x = [1, 2, 0i32];\n            let y = [4, 5, 6];\n\n            let mut t = TwoSat::new(n);\n\n            for i in 0..n {\n                for j in i + 1..n {\n                    if (x[i] - x[j]).abs() < d {\n                        t.add_clause(i, false, j, false);\n                    }\n                    if (x[i] - y[j]).abs() < d {\n                        t.add_clause(i, false, j, true);\n                    }\n                    if (y[i] - x[j]).abs() < d {\n                        t.add_clause(i, true, j, false);\n                    }\n                    if (y[i] - y[j]).abs() < d {\n                        t.add_clause(i, true, j, true);\n                    }\n                }\n            }\n            assert!(!t.satisfiable());\n        }\n    }\n}\nuse twosat::*;\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::io::*;\nuse two_sat::TwoSat;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o).unwrap();\n    stdout().write_all(&o).unwrap();\n}\n\npub fn run(i: impl BufRead, o: &mut impl Write) -> std::io::Result<()> {\n    let mut i = CpReader::new(i);\n    let (n, d) = i.read::<(usize, usize)>();\n    let xys = i.read_vec::<(usize, usize)>(n);\n    let mut g = TwoSat::new(n);\n\n    for i in 0..n {\n        for j in i + 1..n {\n            let xx = is_differ(xys[i].0, xys[j].0, d);\n            let xy = is_differ(xys[i].0, xys[j].1, d);\n            let yx = is_differ(xys[i].1, xys[j].0, d);\n            let yy = is_differ(xys[i].1, xys[j].1, d);\n            if !xx {\n                g.add_claure(i, false, j, false);\n            }\n            if !xy {\n                g.add_claure(i, false, j, true);\n            }\n            if !yx {\n                g.add_claure(i, true, j, false);\n            }\n            if !yy {\n                g.add_claure(i, true, j, true);\n            }\n        }\n    }\n    if g.satisfiable() {\n        writeln!(o, \"Yes\")?;\n        let ans = g.answer();\n        for i in 0..n {\n            let p = if ans[i] { xys[i].0 } else { xys[i].1 };\n            writeln!(o, \"{}\", p)?;\n        }\n    } else {\n        writeln!(o, \"No\")?;\n    }\n    Ok(())\n}\nfn is_differ(a: usize, b: usize, d: usize) -> bool {\n    max(a, b) - min(a, b) >= d\n}\n\npub mod utils {\n    use super::*;\n\n    pub struct CpReader<R: BufRead> {\n        r: R,\n        b: Vec<u8>,\n    }\n    impl<R: BufRead> CpReader<R> {\n        pub fn new(r: R) -> Self {\n            CpReader {\n                r: r,\n                b: Vec::new(),\n            }\n        }\n        pub fn read_word(&mut self) -> &[u8] {\n            self.b.clear();\n            loop {\n                let b = self.r.fill_buf().unwrap();\n                assert!(!b.is_empty());\n                if let Some(p) = b.iter().position(|&x| x == b' ' || x == b'\\n') {\n                    self.b.extend_from_slice(&b[..p]);\n                    self.r.consume(p + 1);\n                    return &self.b;\n                }\n                self.b.extend_from_slice(b);\n                let b_len = b.len();\n                self.r.consume(b_len);\n            }\n        }\n        pub fn read_word_str(&mut self) -> &str {\n            unsafe { std::str::from_utf8_unchecked(self.read_word()) }\n        }\n\n        pub fn read_line(&mut self) -> &[u8] {\n            self.b.clear();\n            self.r.read_until(b'\\n', &mut self.b).unwrap();\n            if self.b.last() == Some(&b'\\n') {\n                &self.b[..self.b.len() - 1]\n            } else {\n                &self.b\n            }\n        }\n        pub fn read_line_str(&mut self) -> &str {\n            unsafe { std::str::from_utf8_unchecked(self.read_line()) }\n        }\n\n        pub fn read<T: CpIn>(&mut self) -> T {\n            T::read_from(self)\n        }\n\n        pub fn read_vec<T: CpIn>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.read()).collect()\n        }\n        pub fn read_iter<'a, T: CpIn>(&'a mut self, n: usize) -> CpIter<'a, R, T> {\n            CpIter {\n                r: self,\n                n: n,\n                _pd: Default::default(),\n            }\n        }\n    }\n    pub struct CpIter<'a, R: BufRead + 'a, T> {\n        r: &'a mut CpReader<R>,\n        n: usize,\n        _pd: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, R: BufRead, T: CpIn> Iterator for CpIter<'a, R, T> {\n        type Item = T;\n        fn next(&mut self) -> Option<T> {\n            if self.n == 0 {\n                None\n            } else {\n                self.n -= 1;\n                Some(self.r.read())\n            }\n        }\n        fn size_hint(&self) -> (usize, Option<usize>) {\n            (self.n, Some(self.n))\n        }\n    }\n    impl<'a, R: BufRead, T: CpIn> ExactSizeIterator for CpIter<'a, R, T> {}\n\n    pub trait CpIn {\n        fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self;\n    }\n\n    impl CpIn for u64 {\n        fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n            read_u64_fast(&mut r.r)\n        }\n    }\n    impl CpIn for i64 {\n        fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n            read_i64_fast(&mut r.r)\n        }\n    }\n    impl CpIn for char {\n        fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n            let b = r.r.fill_buf().unwrap()[0] as char;\n            r.r.consume(1);\n            let s = r.r.fill_buf().unwrap()[0];\n            assert!(s == b' ' || s == b'\\n');\n            r.r.consume(1);\n            b\n        }\n    }\n\n    macro_rules! cpin_tuple {\n        ($($t:ident),*) => {\n            impl<$($t: CpIn),*> CpIn for ($($t),*) {\n                fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n                    ($($t::read_from(r)),*)\n                }\n            }\n        };\n    }\n\n    macro_rules! cpin_cast {\n        ($t_self:ty, $t_read:ty) => {\n            impl CpIn for $t_self {\n                fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n                    <$t_read>::read_from(r) as $t_self\n                }\n            }\n        };\n    }\n    macro_rules! cpin_parse {\n        ($t:ty) => {\n            impl CpIn for $t {\n                fn read_from<R: BufRead>(r: &mut CpReader<R>) -> Self {\n                    r.read_word_str().parse().unwrap()\n                }\n            }\n        };\n    }\n    cpin_cast!(usize, u64);\n    cpin_cast!(u32, u64);\n    cpin_cast!(u16, u64);\n    cpin_cast!(i32, i64);\n    cpin_cast!(i16, i64);\n    cpin_cast!(i8, i64);\n\n    cpin_parse!(f64);\n\n    cpin_tuple!(T1, T2);\n    cpin_tuple!(T1, T2, T3);\n    cpin_tuple!(T1, T2, T3, T4);\n    cpin_tuple!(T1, T2, T3, T4, T5);\n\n    fn read_u64_fast<R: BufRead>(r: &mut R) -> u64 {\n        let mut value = 0;\n        loop {\n            let buf = r.fill_buf().unwrap();\n            assert!(!buf.is_empty());\n            let mut idx = 0;\n            while let Some(&c) = buf.get(idx) {\n                if b'0' <= c && c <= b'9' {\n                    value = value * 10 + (c - b'0') as u64;\n                    idx += 1;\n                } else {\n                    r.consume(idx + 1);\n                    return value;\n                }\n            }\n            r.consume(idx);\n        }\n    }\n    fn read_i64_fast<R: BufRead>(r: &mut R) -> i64 {\n        let sign = match r.fill_buf().unwrap()[0] {\n            b'+' => {\n                r.consume(1);\n                1\n            }\n            b'-' => {\n                r.consume(1);\n                -1\n            }\n            _ => 1,\n        };\n        read_u64_fast(r) as i64 * sign\n    }\n}\nmod scc {\n    #![allow(dead_code)]\n    use std::cmp::min;\n\n    pub struct SccGraph {\n        n: usize,\n        edges: Vec<Edge>,\n    }\n    struct Edge {\n        from: usize,\n        to: usize,\n    }\n\n    impl SccGraph {\n        pub fn new(n: usize) -> Self {\n            Self {\n                n,\n                edges: Vec::new(),\n            }\n        }\n        pub fn add_edge(&mut self, from: usize, to: usize) {\n            self.edges.push(Edge { from, to })\n        }\n        pub(crate) fn scc_ids(&self) -> (usize, Vec<usize>) {\n            let g = Csr::new(self.n, &self.edges);\n            let mut new_ord = 0;\n            let mut group_num = 0;\n            let mut visited = Vec::with_capacity(self.n);\n            let mut low = vec![0; self.n];\n            let mut ord = vec![usize::max_value(); self.n];\n            let mut ids = vec![0; self.n];\n\n            fn dfs(\n                v: usize,\n                n: usize,\n                g: &Csr,\n                visited: &mut Vec<usize>,\n                low: &mut [usize],\n                ord: &mut [usize],\n                ids: &mut [usize],\n                now_ord: &mut usize,\n                group_num: &mut usize,\n            ) {\n                low[v] = *now_ord;\n                ord[v] = *now_ord;\n                *now_ord += 1;\n                visited.push(v);\n                for i in g.start[v]..g.start[v + 1] {\n                    let to = g.elist[i];\n                    if ord[to] == usize::max_value() {\n                        dfs(to, n, g, visited, low, ord, ids, now_ord, group_num);\n                        low[v] = min(low[v], low[to]);\n                    } else {\n                        low[v] = min(low[v], ord[to]);\n                    }\n                }\n                if low[v] == ord[v] {\n                    loop {\n                        let u = visited.pop().unwrap();\n                        ord[u] = n;\n                        ids[u] = *group_num;\n                        if u == v {\n                            break;\n                        }\n                    }\n                    *group_num += 1;\n                }\n            }\n            for i in 0..self.n {\n                if ord[i] == usize::max_value() {\n                    dfs(\n                        i,\n                        self.n,\n                        &g,\n                        &mut visited,\n                        &mut low,\n                        &mut ord,\n                        &mut ids,\n                        &mut new_ord,\n                        &mut group_num,\n                    );\n                }\n            }\n            for x in &mut ids {\n                *x = group_num - 1 - *x;\n            }\n            (group_num, ids)\n        }\n        pub fn scc(&self) -> Vec<Vec<usize>> {\n            let ids = self.scc_ids();\n            let group_num = ids.0;\n            let mut counts = vec![0; group_num];\n            for &x in &ids.1 {\n                counts[x] += 1;\n            }\n            let mut groups = vec![Vec::new(); group_num];\n            for i in 0..group_num {\n                groups[i].reserve(counts[i]);\n            }\n            for i in 0..self.n {\n                groups[(ids.1)[i]].push(i);\n            }\n            groups\n        }\n    }\n\n    #[derive(Debug)]\n    struct Csr {\n        start: Vec<usize>,\n        elist: Vec<usize>,\n    }\n    impl Csr {\n        fn new(n: usize, edges: &[Edge]) -> Self {\n            let mut start = vec![0; n + 1];\n            let mut elist = vec![0; edges.len()];\n\n            for e in edges {\n                start[e.from + 1] += 1;\n            }\n            for i in 1..=n {\n                start[i] += start[i - 1];\n            }\n            let mut counter = start.clone();\n            for e in edges {\n                elist[counter[e.from]] = e.to;\n                counter[e.from] += 1;\n            }\n            Self { start, elist }\n        }\n    }\n}\nmod two_sat {\n\n    use crate::scc::SccGraph;\n    pub struct TwoSat {\n        n: usize,\n        answer: Vec<bool>,\n        scc: SccGraph,\n    }\n    impl TwoSat {\n        pub fn new(n: usize) -> Self {\n            Self {\n                n,\n                answer: vec![false; n],\n                scc: SccGraph::new(2 * n),\n            }\n        }\n        pub fn add_claure(&mut self, i: usize, f: bool, j: usize, g: bool) {\n            debug_assert!(i < self.n);\n            debug_assert!(j < self.n);\n            self.scc.add_edge(to_index(i, !f), to_index(j, g));\n            self.scc.add_edge(to_index(j, !g), to_index(i, f))\n        }\n        pub fn satisfiable(&mut self) -> bool {\n            let id = self.scc.scc_ids().1;\n            for i in 0..self.n {\n                if id[2 * i] == id[2 * i + 1] {\n                    return false;\n                }\n                self.answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            true\n        }\n\n        pub fn answer(&self) -> &[bool] {\n            &self.answer\n        }\n    }\n\n    fn to_index(i: usize, f: bool) -> usize {\n        2 * i + if f { 1 } else { 0 }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } ) ;\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\n/// Sparse Graph represented as Compressed Sparse Row.\n#[derive(Debug, Clone)]\npub struct SparseGraph {\n    pub vsize: usize,\n    pub start: Vec<usize>,\n    pub elist: Vec<usize>,\n}\nimpl SparseGraph {\n    /// Construct graph from directed edges.\n    ///\n    /// # Example\n    /// ```\n    /// # use competitive::graph::SparseGraph;\n    /// let vsize = 4;\n    /// let edges = vec![(0, 1), (3, 2), (1, 2), (1, 0)];\n    /// let graph = SparseGraph::from_edges(vsize, edges.iter().cloned());\n    ///\n    /// assert_eq!(graph.adjacency(0), &[1]);\n    /// assert_eq!(graph.adjacency(1), &[0, 2]);\n    /// assert_eq!(graph.adjacency(2), &[]);\n    /// assert_eq!(graph.adjacency(3), &[2]);\n    /// ```\n    pub fn from_edges(\n        vsize: usize,\n        edges: impl Iterator<Item = (usize, usize)> + ExactSizeIterator + Clone,\n    ) -> SparseGraph {\n        let mut start = vec![0; vsize + 1];\n        let mut elist = vec![0; edges.len()];\n        for e in edges.clone() {\n            start[e.0] += 1;\n        }\n        for i in 1..=vsize {\n            start[i] += start[i - 1];\n        }\n        for (from, to) in edges {\n            start[from] -= 1;\n            elist[start[from]] = to;\n        }\n        SparseGraph {\n            vsize,\n            start,\n            elist,\n        }\n    }\n    /// Return the number of edges.\n    pub fn esize(&self) -> usize {\n        self.elist.len()\n    }\n    /// Return an iterator over graph vertices.\n    pub fn vertices(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    /// Return an iterator over adjacency vertices.\n    pub fn adjacency(&self, from: usize) -> &[usize] {\n        &self.elist[self.start[from]..self.start[from + 1]]\n    }\n}\n#[derive(Debug, Clone)]\npub struct StronglyConnectedComponent<'a> {\n    graph: &'a SparseGraph,\n    visited: Vec<usize>,\n    csize: usize,\n    low: Vec<usize>,\n    ord: Vec<usize>,\n    comp: Vec<usize>,\n}\nimpl std::ops::Index<usize> for StronglyConnectedComponent<'_> {\n    type Output = usize;\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.comp[index]\n    }\n}\nimpl<'a> StronglyConnectedComponent<'a> {\n    pub fn new(graph: &'a SparseGraph) -> Self {\n        let mut now_ord = 0;\n        let mut self_ = Self {\n            graph,\n            csize: 0,\n            visited: Vec::with_capacity(graph.vsize),\n            low: vec![0; graph.vsize],\n            ord: vec![std::usize::MAX; graph.vsize],\n            comp: vec![0; graph.vsize],\n        };\n        for u in graph.vertices() {\n            if self_.ord[u] == std::usize::MAX {\n                self_.dfs(u, &mut now_ord);\n            }\n        }\n        for x in self_.comp.iter_mut() {\n            *x = self_.csize - 1 - *x;\n        }\n        self_\n    }\n}\nimpl StronglyConnectedComponent<'_> {\n    fn dfs(&mut self, u: usize, now_ord: &mut usize) {\n        self.low[u] = *now_ord;\n        self.ord[u] = *now_ord;\n        *now_ord += 1;\n        self.visited.push(u);\n        for &to in self.graph.adjacency(u) {\n            if self.ord[to] == std::usize::MAX {\n                self.dfs(to, now_ord);\n                self.low[u] = self.low[u].min(self.low[to]);\n            } else {\n                self.low[u] = self.low[u].min(self.ord[to]);\n            }\n        }\n        if self.low[u] == self.ord[u] {\n            while let Some(v) = self.visited.pop() {\n                self.ord[v] = self.graph.vsize;\n                self.comp[v] = self.csize;\n                if v == u {\n                    break;\n                }\n            }\n            self.csize += 1;\n        }\n    }\n    pub fn gen_cgraph(&self) -> SparseGraph {\n        let mut used = std::collections::HashSet::new();\n        let mut edges = vec![];\n        for u in self.graph.vertices() {\n            for &to in self.graph.adjacency(u) {\n                if self.comp[u] != self.comp[to] {\n                    let (x, y) = (self.comp[u], self.comp[to]);\n                    if !used.contains(&(x, y)) {\n                        used.insert((x, y));\n                        edges.push((x, y));\n                    }\n                }\n            }\n        }\n        SparseGraph::from_edges(self.size(), edges.iter().cloned())\n    }\n    pub fn components(&self) -> Vec<Vec<usize>> {\n        let mut counts = vec![0; self.size()];\n        for &x in self.comp.iter() {\n            counts[x] += 1;\n        }\n        let mut groups = vec![vec![]; self.size()];\n        for (g, c) in groups.iter_mut().zip(counts.into_iter()) {\n            g.reserve(c);\n        }\n        for u in self.graph.vertices() {\n            groups[self[u]].push(u);\n        }\n        groups\n    }\n    pub fn has_loop(&self) -> bool {\n        self.graph.vsize != self.csize\n    }\n    pub fn size(&self) -> usize {\n        self.csize\n    }\n}\n#[derive(Debug, Clone)]\npub struct TwoSatisfiability {\n    vsize: usize,\n    edges: Vec<(usize, usize)>,\n}\nimpl TwoSatisfiability {\n    pub fn new(vsize: usize) -> Self {\n        Self {\n            vsize,\n            edges: Vec::new(),\n        }\n    }\n    pub fn add_inner(&mut self, u: usize, v: usize) {\n        self.edges.push((u, v));\n        self.edges.push((v ^ 1, u ^ 1));\n    }\n    pub fn add_or(&mut self, x: usize, y: usize) {\n        self.add_inner(x * 2 + 1, y * 2);\n    }\n    pub fn add_nand(&mut self, x: usize, y: usize) {\n        self.add_inner(x * 2, y * 2 + 1);\n    }\n    pub fn set_true(&mut self, x: usize) {\n        self.add_inner(x * 2 + 1, x * 2);\n    }\n    pub fn set_false(&mut self, x: usize) {\n        self.add_inner(x * 2, x * 2 + 1);\n    }\n    pub fn two_satisfiability(self) -> Option<Vec<bool>> {\n        let graph = SparseGraph::from_edges(self.vsize * 2, self.edges.iter().cloned());\n        let scc = StronglyConnectedComponent::new(&graph);\n        let mut res = vec![false; self.vsize];\n        for i in 0..self.vsize {\n            if scc[i * 2] == scc[i * 2 + 1] {\n                return None;\n            }\n            res[i] = scc[i * 2] > scc[i * 2 + 1];\n        }\n        Some(res)\n    }\n}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let d = scan!(i64);\n    let xy = scan!([(i64, i64); n]);\n    let mut two_sat = TwoSatisfiability::new(n * 2);\n    for i in 0..n {\n        two_sat.add_or(i * 2, i * 2 + 1);\n        two_sat.add_nand(i * 2, i * 2 + 1);\n    }\n    for i in 0..n - 1 {\n        for j in i + 1..n {\n            if (xy[i].0 - xy[j].0).abs() < d {\n                two_sat.add_nand(i * 2, j * 2);\n            }\n            if (xy[i].0 - xy[j].1).abs() < d {\n                two_sat.add_nand(i * 2, j * 2 + 1);\n            }\n            if (xy[i].1 - xy[j].0).abs() < d {\n                two_sat.add_nand(i * 2 + 1, j * 2);\n            }\n            if (xy[i].1 - xy[j].1).abs() < d {\n                two_sat.add_nand(i * 2 + 1, j * 2 + 1);\n            }\n        }\n    }\n    if let Some(res) = two_sat.two_satisfiability() {\n        println!(\"Yes\");\n        for i in 0..n {\n            println!(\"{}\", if res[i * 2] { xy[i].0 } else { xy[i].1 });\n        }\n    } else {\n        println!(\"No\");\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Strong connected components.\n * Verified by: yukicoder No.470 (http://yukicoder.me/submissions/145785)\n */\nstruct SCC {\n    n: usize,\n    ncc: usize,\n    g: Vec<Vec<usize>>, // graph in adjacent list\n    rg: Vec<Vec<usize>>, // reverse graph\n    cmp: Vec<usize>, // topological order\n}\n\nimpl SCC {\n    fn new(n: usize) -> Self {\n        SCC {\n            n: n,\n            ncc: n + 1,\n            g: vec![Vec::new(); n],\n            rg: vec![Vec::new(); n],\n            cmp: vec![0; n],\n        }\n    }\n    fn add_edge(&mut self, from: usize, to: usize) {\n        self.g[from].push(to);\n        self.rg[to].push(from);\n    }\n    fn dfs(&self, v: usize, used: &mut [bool], vs: &mut Vec<usize>) {\n        used[v] = true;\n        for &w in self.g[v].iter() {\n            if !used[w] {\n               self.dfs(w, used, vs);\n            }\n        }\n        vs.push(v);\n    }\n    fn rdfs(&self, v: usize, k: usize,\n            used: &mut [bool], cmp: &mut [usize]) {\n        used[v] = true;\n        cmp[v] = k;\n        for &w in self.rg[v].iter() {\n            if !used[w] {\n                self.rdfs(w, k, used, cmp);\n            }\n        }\n    }\n    fn scc(&mut self) -> usize {\n        let n = self.n;\n        let mut used = vec![false; n];\n        let mut vs = Vec::new();\n        let mut cmp = vec![0; n];\n        for v in 0 .. n {\n            if !used[v] { self.dfs(v, &mut used, &mut vs); }\n        }\n        for u in used.iter_mut() {\n            *u = false;\n        }\n        let mut k = 0;\n        for &t in vs.iter().rev() {\n            if !used[t] { self.rdfs(t, k, &mut used, &mut cmp); k += 1; }\n        }\n        self.ncc = k;\n        self.cmp = cmp;\n        k\n    }\n    #[allow(dead_code)]\n    fn top_order(&self) -> Vec<usize> {\n        assert!(self.ncc <= self.n);\n        self.cmp.clone()\n    }\n    /*\n     * Returns a dag whose vertices are scc's, and whose edges are those of the original graph.\n     */\n    #[allow(dead_code)]\n    fn dag(&self) -> Vec<Vec<usize>> {\n        assert!(self.ncc <= self.n);\n        let ncc = self.ncc;\n        let mut ret = vec![HashSet::new(); ncc];\n        let n = self.n;\n        for i in 0 .. n {\n            for &to in self.g[i].iter() {\n                if self.cmp[i] != self.cmp[to] {\n                    assert!(self.cmp[i] < self.cmp[to]);\n                    ret[self.cmp[i]].insert(self.cmp[to]);\n                }\n            }\n        }\n        ret.into_iter().map(|set| set.into_iter().collect()).collect()\n    }\n    #[allow(dead_code)]\n    fn rdag(&self) -> Vec<Vec<usize>> {\n        assert!(self.ncc <= self.n);\n        let ncc = self.ncc;\n        let mut ret = vec![HashSet::new(); ncc];\n        let n = self.n;\n        for i in 0 .. n {\n            for &to in self.g[i].iter() {\n                if self.cmp[i] != self.cmp[to] {\n                    assert!(self.cmp[i] < self.cmp[to]);\n                    ret[self.cmp[to]].insert(self.cmp[i]);\n                }\n            }\n        }\n        ret.into_iter().map(|set| set.into_iter().collect()).collect()\n    }\n}\n\n/**\n * 2-SAT solver.\n * n: the number of variables (v_1, ..., v_n)\n * cons: constraints, given in 2-cnf\n * i (1 <= i <= n) means v_i, -i (1 <= i <= n) means not v_i.\n * Returns: None if there's no assignment that satisfies cons.\n * Otherwise, it returns an assignment that safisfies cons. (true: true, false: false)\n * Dependencies: SCC.rs\n * Verified by: Codeforces #400 D\n *              (http://codeforces.com/contest/776/submission/24957215)\n */\nfn two_sat(n: usize, cons: &[(i32, i32)]) -> Option<Vec<bool>> {\n    let mut scc = SCC::new(2 * n);\n    let ni = n as i32;\n    for &(c1, c2) in cons.iter() {\n        let x = if c1 > 0 {\n            c1 - 1 + ni\n        } else {\n            -c1 - 1\n        } as usize;\n        let y = if c2 > 0 {\n            c2 - 1\n        } else {\n            -c2 - 1 + ni\n        } as usize;\n        scc.add_edge(x, y);\n        scc.add_edge((y + n) % (2 * n), (x + n) % (2 * n));\n    }\n    scc.scc();\n    let mut result = vec![false; n];\n    let top_ord = scc.top_order();\n    for i in 0 .. n {\n        if top_ord[i] == top_ord[i + n] {\n            return None;\n        }\n        result[i] = top_ord[i] > top_ord[i + n];\n    }\n    Some(result)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize, d: i64,\n        xy: [(i64, i64); n],\n    }\n    let mut cons = vec![];\n    for i in 0..n {\n        let ii = i as i32 + 1;\n        let (x1, y1) = xy[i];\n        for j in 0..i {\n            let jj = j as i32 + 1;\n            let (x2, y2) = xy[j];\n            if (x1 - x2).abs() < d {\n                cons.push((ii, jj));\n            }\n            if (x1 - y2).abs() < d {\n                cons.push((ii, -jj));\n            }\n            if (y1 - x2).abs() < d {\n                cons.push((-ii, jj));\n            }\n            if (y1 - y2).abs() < d {\n                cons.push((-ii, -jj));\n            }\n        }\n    }\n    let ans = two_sat(n, &cons);\n    if let Some(ans) = ans {\n        puts!(\"Yes\\n\");\n        for i in 0..n {\n            let c = if ans[i] {\n                xy[i].1\n            } else {\n                xy[i].0\n            };\n            puts!(\"{}\\n\", c);\n        }\n    } else {\n        puts!(\"No\\n\");\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } ) ;\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Adjacent {\n    pub id: usize,\n    pub to: usize,\n}\nimpl Adjacent {\n    pub fn new(id: usize, to: usize) -> Adjacent {\n        Adjacent { id, to }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(self.esize, to));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(self.esize, v));\n        self.graph[v].push(Adjacent::new(self.esize, u));\n        self.esize += 1;\n    }\n    pub fn vertices(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n    pub fn eid_cache(&self) -> GraphEidCache<'_> {\n        let mut cache = vec![(0, 0); self.esize];\n        for u in self.vertices() {\n            for a in self.adjacency(u) {\n                cache[a.id] = (u, a.to);\n            }\n        }\n        GraphEidCache { graph: self, cache }\n    }\n}\npub struct GraphScanner<U: IterScan<Output = usize>, T: IterScan> {\n    vsize: usize,\n    esize: usize,\n    directed: bool,\n    _marker: std::marker::PhantomData<fn() -> (U, T)>,\n}\nimpl<U: IterScan<Output = usize>, T: IterScan> GraphScanner<U, T> {\n    pub fn new(vsize: usize, esize: usize, directed: bool) -> Self {\n        Self {\n            vsize,\n            esize,\n            directed,\n            _marker: std::marker::PhantomData,\n        }\n    }\n}\nimpl<U: IterScan<Output = usize>, T: IterScan> MarkedIterScan for GraphScanner<U, T> {\n    type Output = (Graph, Vec<<T as IterScan>::Output>);\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n        let mut graph = Graph::new(self.vsize);\n        let mut rest = Vec::with_capacity(self.esize);\n        for _ in 0..self.esize {\n            let (from, to) = (U::scan(iter)?, U::scan(iter)?);\n            if self.directed {\n                graph.add_edge(from, to);\n            } else {\n                graph.add_undirected_edge(from, to);\n            }\n            rest.push(T::scan(iter)?);\n        }\n        Some((graph, rest))\n    }\n}\n#[derive(Debug, Clone)]\npub struct GraphEidCache<'a> {\n    graph: &'a Graph,\n    cache: Vec<(usize, usize)>,\n}\nimpl<'a> std::ops::Index<usize> for GraphEidCache<'a> {\n    type Output = (usize, usize);\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.cache[index]\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct RevGraph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n    pub rgraph: Vec<Vec<Adjacent>>,\n}\nimpl RevGraph {\n    pub fn new(vsize: usize) -> RevGraph {\n        RevGraph {\n            vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n            rgraph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(self.esize, to));\n        self.rgraph[to].push(Adjacent::new(self.esize, from));\n        self.esize += 1;\n    }\n    pub fn vertices(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n    pub fn radjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.rgraph[from]\n    }\n}\npub struct RevGraphScanner<U: IterScan<Output = usize>, T: IterScan> {\n    vsize: usize,\n    esize: usize,\n    _marker: std::marker::PhantomData<fn() -> (U, T)>,\n}\nimpl<U: IterScan<Output = usize>, T: IterScan> RevGraphScanner<U, T> {\n    pub fn new(vsize: usize, esize: usize) -> Self {\n        Self {\n            vsize,\n            esize,\n            _marker: std::marker::PhantomData,\n        }\n    }\n}\nimpl<U: IterScan<Output = usize>, T: IterScan> MarkedIterScan for RevGraphScanner<U, T> {\n    type Output = (RevGraph, Vec<<T as IterScan>::Output>);\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n        let mut graph = RevGraph::new(self.vsize);\n        let mut rest = Vec::with_capacity(self.esize);\n        for _ in 0..self.esize {\n            graph.add_edge(U::scan(iter)?, U::scan(iter)?);\n            rest.push(T::scan(iter)?);\n        }\n        Some((graph, rest))\n    }\n}\n#[derive(Debug)]\npub struct StronglyConnectedComponent {\n    vsize: usize,\n    ord: Vec<usize>,\n    used: Vec<bool>,\n    comp: Vec<usize>,\n    csize: usize,\n}\nimpl StronglyConnectedComponent {\n    pub fn new(graph: &RevGraph) -> Self {\n        let mut self_ = Self {\n            vsize: graph.vsize,\n            ord: vec![],\n            used: vec![false; graph.vsize],\n            comp: vec![0; graph.vsize],\n            csize: 0,\n        };\n        self_.build(graph);\n        self_\n    }\n    fn dfs(&mut self, u: usize, graph: &RevGraph) {\n        self.used[u] = true;\n        for a in graph.adjacency(u) {\n            if !self.used[a.to] {\n                self.dfs(a.to, graph);\n            }\n        }\n        self.ord.push(u);\n    }\n    fn rdfs(&mut self, u: usize, k: usize, graph: &RevGraph) {\n        self.used[u] = true;\n        self.comp[u] = k;\n        for a in graph.radjacency(u) {\n            if !self.used[a.to] {\n                self.rdfs(a.to, k, graph);\n            }\n        }\n    }\n    fn build(&mut self, graph: &RevGraph) {\n        for u in graph.vertices() {\n            if !self.used[u] {\n                self.dfs(u, graph);\n            }\n        }\n        self.used = vec![false; self.vsize];\n        for i in graph.vertices().rev() {\n            if !self.used[self.ord[i]] {\n                let (v, k) = (self.ord[i], self.csize);\n                self.rdfs(v, k, graph);\n                self.csize += 1;\n            }\n        }\n    }\n    pub fn gen_cgraph(&self, graph: &RevGraph) -> RevGraph {\n        let mut g = RevGraph::new(self.csize);\n        let mut used = std::collections::HashSet::new();\n        for u in graph.vertices() {\n            for a in graph.adjacency(u) {\n                if self.comp[u] != self.comp[a.to] {\n                    let (x, y) = (self.comp[u], self.comp[a.to]);\n                    if !used.contains(&(x, y)) {\n                        used.insert((x, y));\n                        g.add_edge(x, y);\n                    }\n                }\n            }\n        }\n        g\n    }\n    pub fn components(&self) -> Vec<Vec<usize>> {\n        let mut c = vec![vec![]; self.csize];\n        for u in 0..self.vsize {\n            c[self.comp[u]].push(u);\n        }\n        c\n    }\n    pub fn has_loop(&self) -> bool {\n        self.vsize != self.csize\n    }\n    pub fn size(&self) -> usize {\n        self.csize\n    }\n}\nimpl std::ops::Index<usize> for StronglyConnectedComponent {\n    type Output = usize;\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.comp[index]\n    }\n}\n#[derive(Debug)]\npub struct TwoSatisfiability {\n    n: usize,\n    scc: StronglyConnectedComponent,\n}\nimpl TwoSatisfiability {\n    pub fn add_inner(graph: &mut RevGraph, u: usize, v: usize) {\n        graph.add_edge(u, v);\n        graph.add_edge(v ^ 1, u ^ 1);\n    }\n    pub fn add_or(graph: &mut RevGraph, x: usize, y: usize) {\n        Self::add_inner(graph, x * 2 + 1, y * 2)\n    }\n    pub fn add_nand(graph: &mut RevGraph, x: usize, y: usize) {\n        Self::add_inner(graph, x * 2, y * 2 + 1)\n    }\n    pub fn set_true(graph: &mut RevGraph, x: usize) {\n        Self::add_inner(graph, x * 2 + 1, x * 2)\n    }\n    pub fn set_false(graph: &mut RevGraph, x: usize) {\n        Self::add_inner(graph, x * 2, x * 2 + 1)\n    }\n    pub fn build(n: usize, graph: &RevGraph) -> Option<Vec<bool>> {\n        let scc = StronglyConnectedComponent::new(graph);\n        let mut res = vec![false; n];\n        for i in 0..n {\n            if scc[i * 2] == scc[i * 2 + 1] {\n                return None;\n            }\n            res[i] = scc[i * 2] > scc[i * 2 + 1];\n        }\n        Some(res)\n    }\n}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let d = scan!(i64);\n    let xy = scan!([(i64, i64); n]);\n    let mut g = RevGraph::new(n * 4);\n    for i in 0..n {\n        TwoSatisfiability::add_or(&mut g, i * 2, i * 2 + 1);\n        TwoSatisfiability::add_nand(&mut g, i * 2, i * 2 + 1);\n    }\n    for i in 0..n - 1 {\n        for j in i + 1..n {\n            if (xy[i].0 - xy[j].0).abs() < d {\n                TwoSatisfiability::add_nand(&mut g, i * 2, j * 2);\n            }\n            if (xy[i].0 - xy[j].1).abs() < d {\n                TwoSatisfiability::add_nand(&mut g, i * 2, j * 2 + 1);\n            }\n            if (xy[i].1 - xy[j].0).abs() < d {\n                TwoSatisfiability::add_nand(&mut g, i * 2 + 1, j * 2);\n            }\n            if (xy[i].1 - xy[j].1).abs() < d {\n                TwoSatisfiability::add_nand(&mut g, i * 2 + 1, j * 2 + 1);\n            }\n        }\n    }\n    if let Some(res) = TwoSatisfiability::build(n * 2, &g) {\n        println!(\"Yes\");\n        for i in 0..n {\n            println!(\"{}\", if res[i * 2] { xy[i].0 } else { xy[i].1 });\n        }\n    } else {\n        println!(\"No\");\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse itertools::Itertools;\n#[allow(unused_imports)]\nuse itertools_num::ItertoolsNum;\nuse proconio::*;\n#[allow(unused_imports)]\nuse std::cmp;\n#[allow(unused_imports)]\nuse std::iter;\n#[allow(unused_imports)]\nuse superslice::*;\n\npub struct Csr<E> {\n    start: Vec<usize>,\n    elist: Vec<E>,\n}\n\nimpl<E> Csr<E>\nwhere\n    E: Copy + Clone,\n{\n    pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n        let mut csr = Csr {\n            start: vec![0; n + 1],\n            elist: vec![init; edges.len()],\n        };\n        for e in edges.iter() {\n            csr.start[e.0 + 1] += 1;\n        }\n        for i in 1..=n {\n            csr.start[i] += csr.start[i - 1];\n        }\n        let mut counter = csr.start.clone();\n        for e in edges.iter() {\n            csr.elist[counter[e.0]] = e.1;\n            counter[e.0] += 1;\n        }\n        csr\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct _Edge {\n    to: usize,\n}\n\n/// Reference:\n/// R. Tarjan,\n/// Depth-First Search and Linear Graph Algorithms\npub struct SccGraph {\n    n: usize,\n    edges: Vec<(usize, _Edge)>,\n}\n\nimpl SccGraph {\n    pub fn new(n: usize) -> Self {\n        SccGraph { n, edges: vec![] }\n    }\n\n    pub fn num_vertices(&self) -> usize {\n        self.n\n    }\n\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.edges.push((from, _Edge { to }));\n    }\n\n    /// return pair of (# of scc, scc id)\n    pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n        // In C++ ac-library, this function is implemented by using recursive lambda functions.\n        // Instead, we use fn and struct for capturing environments.\n        struct _Env {\n            g: Csr<_Edge>,\n            now_ord: usize,\n            group_num: usize,\n            visited: Vec<usize>,\n            low: Vec<usize>,\n            ord: Vec<Option<usize>>,\n            ids: Vec<usize>,\n        }\n        let mut env = _Env {\n            g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n            now_ord: 0,\n            group_num: 0,\n            visited: Vec::with_capacity(self.n),\n            low: vec![0; self.n],\n            ord: vec![None; self.n],\n            ids: vec![0; self.n],\n        };\n\n        fn dfs(v: usize, n: usize, env: &mut _Env) {\n            env.low[v] = env.now_ord;\n            env.ord[v] = Some(env.now_ord);\n            env.now_ord += 1;\n            env.visited.push(v);\n\n            for i in env.g.start[v]..env.g.start[v + 1] {\n                let to = env.g.elist[i].to;\n                if let Some(x) = env.ord[to] {\n                    env.low[v] = std::cmp::min(env.low[v], x);\n                } else {\n                    dfs(to, n, env);\n                    env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                }\n            }\n            if env.low[v] == env.ord[v].unwrap() {\n                loop {\n                    let u = *env.visited.last().unwrap();\n                    env.visited.pop();\n                    env.ord[u] = Some(n);\n                    env.ids[u] = env.group_num;\n                    if u == v {\n                        break;\n                    }\n                }\n                env.group_num += 1;\n            }\n        }\n        for i in 0..self.n {\n            if env.ord[i].is_none() {\n                dfs(i, self.n, &mut env);\n            }\n        }\n        for x in env.ids.iter_mut() {\n            *x = env.group_num - 1 - *x;\n        }\n        (env.group_num, env.ids)\n    }\n\n    pub fn scc(&self) -> Vec<Vec<usize>> {\n        let ids = self.scc_ids();\n        let group_num = ids.0;\n        let mut counts = vec![0usize; group_num];\n        for &x in ids.1.iter() {\n            counts[x] += 1;\n        }\n        let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n        for i in 0..group_num {\n            groups[i].reserve(counts[i]);\n        }\n        for i in 0..self.n {\n            groups[ids.1[i]].push(i);\n        }\n        groups\n    }\n}\n\npub struct TwoSat {\n    n: usize,\n    answer: Vec<bool>,\n    scc: SccGraph,\n}\n\nimpl TwoSat {\n    pub fn new(n: usize) -> Self {\n        TwoSat {\n            n,\n            answer: vec![false; n],\n            scc: SccGraph::new(2 * n),\n        }\n    }\n\n    pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n        assert!(i < self.n);\n        assert!(j < self.n);\n        self.scc\n            .add_edge(2 * i + if f { 0 } else { 1 }, 2 * j + if g { 1 } else { 0 });\n        self.scc\n            .add_edge(2 * j + if g { 0 } else { 1 }, 2 * i + if f { 1 } else { 0 });\n    }\n\n    pub fn satisfiable(&mut self) -> bool {\n        let id = self.scc.scc_ids().1;\n        for i in 0..self.n {\n            if id[2 * i] == id[2 * i + 1] {\n                return false;\n            }\n            self.answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        n: usize,\n        d: i64,\n        xy: [(i64, i64); n]\n    }\n\n    let mut ts = TwoSat::new(n);\n\n    for i in 0..n {\n        for j in i + 1..n {\n            if (xy[i].0 - xy[j].0).abs() < d {\n                ts.add_clause(i, false, j, false);\n            }\n            if (xy[i].0 - xy[j].1).abs() < d {\n                ts.add_clause(i, false, j, true);\n            }\n            if (xy[i].1 - xy[j].0).abs() < d {\n                ts.add_clause(i, true, j, false);\n            }\n            if (xy[i].1 - xy[j].1).abs() < d {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if !ts.satisfiable() {\n        println!(\"No\");\n        return;\n    }\n\n    println!(\"Yes\");\n    let answer = ts.answer;\n    for i in 0..n {\n        if answer[i] {\n            println!(\"{}\", xy[i].0);\n        } else {\n            println!(\"{}\", xy[i].1);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// template {{{\n#![allow(clippy::many_single_char_names)]\n\n#[allow(dead_code)]\nmod ngtio {\n    use ::std::collections::VecDeque;\n\n    pub struct Buffer {\n        buf: VecDeque<String>,\n    }\n\n    impl Buffer {\n        pub fn new() -> Self {\n            Self {\n                buf: VecDeque::new(),\n            }\n        }\n\n        fn load(&mut self) {\n            while self.buf.is_empty() {\n                let mut s = String::new();\n                let length = ::std::io::stdin().read_line(&mut s).unwrap();\n                if length == 0 {\n                    break;\n                }\n                self.buf.extend(s.split_whitespace().map(|s| s.to_owned()));\n            }\n        }\n\n        pub fn string(&mut self) -> String {\n            self.load();\n            self.buf\n                .pop_front()\n                .unwrap_or_else(|| panic!(\"入力が終了したのですが。\"))\n        }\n\n        pub fn string_char_vec(&mut self) -> Vec<char> {\n            let s = self.string();\n            s.chars().collect::<Vec<_>>()\n        }\n\n        pub fn string_char_vec_trusted_len(&mut self, len: usize) -> Vec<char> {\n            let s = self.string();\n            let s = s.chars().collect::<Vec<_>>();\n            assert_eq!(s.len(), len, \"あら、思ったのと長さ違いますね……\");\n            s\n        }\n\n        pub fn char(&mut self) -> char {\n            let string = self.string();\n            let mut chars = string.chars();\n            let res = chars.next().unwrap();\n            assert!(\n                chars.next().is_none(),\n                \"char で受け取りたいのも山々なのですが、さては 2 文字以上ありますね？\"\n            );\n            res\n        }\n\n        pub fn read<T: ::std::str::FromStr>(&mut self) -> T\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            self.string()\n                .parse::<T>()\n                .expect(\"Failed to parse the input.\")\n        }\n\n        pub fn read_vec<T: ::std::str::FromStr>(&mut self, len: usize) -> Vec<T>\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            (0..len).map(|_| self.read::<T>()).collect()\n        }\n    }\n\n    macro_rules! define_primitive_reader {\n        ($($ty:tt,)*) => {\n            impl Buffer {\n                $(\n#[inline]\n                    pub fn $ty(&mut self) -> $ty {\n                        self.read::<$ty>()\n                    }\n                )*\n            }\n        }\n    }\n\n    define_primitive_reader! {\n        u8, u16, u32, u64, usize,\n        i8, i16, i32, i64, isize,\n    }\n\n    impl Default for Buffer {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::{collections, iter, mem, ops};\n// }}}\n// scc {{{\n#[allow(dead_code)]\nmod scc {\n    mod traversal {\n        use std::mem;\n\n        #[derive(Debug, Clone)]\n        pub struct Traversal {\n            pub index: Vec<usize>,\n            pub time: Vec<usize>,\n        }\n\n        impl Traversal {\n            pub fn pre_order(graph: &[Vec<usize>]) -> Traversal {\n                fn dfs(x: usize, graph: &[Vec<usize>], res: &mut PermutationBuilder) {\n                    res.visit(x);\n                    for &y in &graph[x] {\n                        if !res.on_stack(y) {\n                            dfs(y, graph, res);\n                        }\n                    }\n                }\n\n                let mut res = PermutationBuilder::new(graph.len());\n                for i in 0..graph.len() {\n                    if !res.on_stack(i) {\n                        dfs(i, &graph, &mut res);\n                    }\n                }\n                res.build()\n            }\n\n            pub fn post_order(graph: &[Vec<usize>]) -> Traversal {\n                fn dfs(\n                    x: usize,\n                    graph: &[Vec<usize>],\n                    ckd: &mut [bool],\n                    res: &mut PermutationBuilder,\n                ) {\n                    for &y in &graph[x] {\n                        if !mem::replace(&mut ckd[y], true) {\n                            dfs(y, graph, ckd, res);\n                        }\n                    }\n                    res.visit(x);\n                }\n\n                let n = graph.len();\n                let mut ckd = vec![false; n];\n                let mut res = PermutationBuilder::new(graph.len());\n                for i in 0..graph.len() {\n                    if !mem::replace(&mut ckd[i], true) {\n                        dfs(i, &graph, &mut ckd, &mut res);\n                    }\n                }\n                res.build()\n            }\n        }\n\n        #[derive(Debug, Clone)]\n        struct PermutationBuilder {\n            index: Vec<usize>,\n            time: Vec<usize>,\n        }\n\n        impl PermutationBuilder {\n            fn new(n: usize) -> Self {\n                Self {\n                    index: Vec::with_capacity(n),\n                    time: vec![n; n],\n                }\n            }\n\n            fn build(self) -> Traversal {\n                Traversal {\n                    index: self.index,\n                    time: self.time,\n                }\n            }\n\n            #[allow(dead_code)]\n            fn is_empty(&self) -> bool {\n                self.time.is_empty()\n            }\n\n            fn len(&self) -> usize {\n                self.time.len()\n            }\n\n            fn time(&self) -> usize {\n                self.index.len()\n            }\n\n            fn visit(&mut self, x: usize) {\n                assert!(!self.on_stack(x));\n                self.time[x] = self.time();\n                self.index.push(x);\n            }\n\n            fn on_stack(&self, x: usize) -> bool {\n                self.time[x] != self.len()\n            }\n        }\n    }\n    mod white_stack {\n        #[derive(Debug, Clone)]\n        pub struct WhiteStack {\n            pub on_stack: Vec<bool>,\n            pub stack: Vec<usize>,\n        }\n\n        impl WhiteStack {\n            pub fn new(len: usize) -> Self {\n                Self {\n                    on_stack: vec![false; len],\n                    stack: Vec::with_capacity(len),\n                }\n            }\n\n            pub fn push(&mut self, i: usize) {\n                assert!(i < self.on_stack.len());\n                assert!(!self.on_stack[i]);\n                self.on_stack[i] = true;\n                self.stack.push(i);\n            }\n\n            pub fn pop(&mut self) -> Option<usize> {\n                if let Some(i) = self.stack.pop() {\n                    assert!(self.on_stack[i]);\n                    Some(i)\n                } else {\n                    None\n                }\n            }\n\n            pub fn peek(&self) -> Option<&usize> {\n                self.stack.last()\n            }\n        }\n    }\n\n    // TODO: この2つは別ライブラリに切り出しても良いかもです。\n    pub use traversal::*;\n    pub use white_stack::*;\n\n    use std::cmp;\n\n    #[derive(Debug, Clone)]\n    pub struct Scc {\n        forward: Vec<Vec<usize>>, // TODO: フラットグラフも試します。\n        backward: Vec<Vec<usize>>,\n    }\n\n    impl Scc {\n        pub fn new(len: usize) -> Self {\n            Self {\n                forward: vec![Vec::new(); len],\n                backward: vec![Vec::new(); len],\n            }\n        }\n        pub fn add_edge(&mut self, u: usize, v: usize) {\n            self.forward[u].push(v);\n            self.backward[v].push(u);\n        }\n        pub fn solve(&self) -> (usize, Vec<usize>) {\n            fn dfs(x: usize, g: &[Vec<usize>], res: &mut [Option<usize>]) {\n                for &y in &g[x] {\n                    if res[y].is_none() {\n                        res[y] = res[x];\n                        dfs(y, g, res);\n                    }\n                }\n            }\n            let n = self.forward.len();\n            let post_backward = Traversal::post_order(&self.backward);\n            let mut res = vec![None; n];\n            let mut counter = 0;\n            for &x in post_backward.index.iter().rev() {\n                if res[x].is_none() {\n                    res[x] = Some(counter);\n                    dfs(x, &self.forward, &mut res);\n                    counter += 1;\n                }\n            }\n            (\n                counter,\n                res.iter().map(|x| counter - 1 - x.unwrap()).collect(),\n            )\n        }\n        // TODO: 答えをいい感じにキャッシュするようにしても良いかもです。\n        pub fn groups(&self) -> Vec<Vec<usize>> {\n            let (count, id) = self.solve();\n            let mut res = vec![Vec::new(); count];\n            for (i, &x) in id.iter().enumerate() {\n                res[x].push(i);\n            }\n            res\n        }\n    }\n\n    #[derive(Debug, Clone)]\n    pub struct TwoSat {\n        len: usize,\n        scc: Scc,\n    }\n    impl TwoSat {\n        pub fn new(len: usize) -> Self {\n            Self {\n                len,\n                scc: Scc::new(2 * len),\n            }\n        }\n        pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n            self.scc.add_edge(2 * i + !f as usize, 2 * j + g as usize);\n            self.scc.add_edge(2 * j + !g as usize, 2 * i + f as usize);\n        }\n        pub fn solve(&mut self) -> Option<Vec<bool>> {\n            self.scc\n                .solve()\n                .1\n                .chunks_exact(2)\n                .map(|v| {\n                    use cmp::Ordering::*;\n                    match v[0].cmp(&v[1]) {\n                        Equal => None,\n                        Less => Some(true),\n                        Greater => Some(false),\n                    }\n                })\n                .collect()\n        }\n    }\n}\n// }}}\n\nfn main() {\n    let mut buf = ngtio::Buffer::new();\n    let n = buf.usize();\n    let d = buf.i32();\n    let mut two_sat = scc::TwoSat::new(n);\n    let (x, y): (Vec<i32>, Vec<i32>) = iter::repeat_with(|| (buf.i32(), buf.i32())).take(n).unzip();\n    for i in 0..n {\n        for j in i + 1..n {\n            if (x[i] - x[j]).abs() < d {\n                two_sat.add_clause(i, true, j, true);\n            }\n            if (x[i] - y[j]).abs() < d {\n                two_sat.add_clause(i, true, j, false);\n            }\n            if (y[i] - x[j]).abs() < d {\n                two_sat.add_clause(i, false, j, true);\n            }\n            if (y[i] - y[j]).abs() < d {\n                two_sat.add_clause(i, false, j, false);\n            }\n        }\n    }\n    if let Some(ans) = two_sat.solve() {\n        println!(\"Yes\");\n        for (i, &b) in ans.iter().enumerate() {\n            println!(\"{}\", if b { y[i] } else { x[i] });\n        }\n    } else {\n        println!(\"No\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "mod internal_scc {\n    pub struct Csr<E> {\n        start: Vec<usize>,\n        elist: Vec<E>,\n    }\n\n    impl<E> Csr<E>\n    where\n        E: Copy,\n    {\n        pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n            let mut csr = Csr {\n                start: vec![0; n + 1],\n                elist: vec![init; edges.len()],\n            };\n            for e in edges.iter() {\n                csr.start[e.0 + 1] += 1;\n            }\n            for i in 1..=n {\n                csr.start[i] += csr.start[i - 1];\n            }\n            let mut counter = csr.start.clone();\n            for e in edges.iter() {\n                csr.elist[counter[e.0]] = e.1;\n                counter[e.0] += 1;\n            }\n            csr\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct _Edge {\n        to: usize,\n    }\n\n    /// Reference:\n    /// R. Tarjan,\n    /// Depth-First Search and Linear Graph Algorithms\n    pub struct SccGraph {\n        n: usize,\n        edges: Vec<(usize, _Edge)>,\n    }\n\n    impl SccGraph {\n        pub fn new(n: usize) -> Self {\n            SccGraph { n, edges: vec![] }\n        }\n\n        pub fn num_vertices(&self) -> usize {\n            self.n\n        }\n\n        pub fn add_edge(&mut self, from: usize, to: usize) {\n            self.edges.push((from, _Edge { to }));\n        }\n\n        /// return pair of (# of scc, scc id)\n        pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n            // In C++ ac-library, this function is implemented by using recursive lambda functions.\n            // Instead, we use fn and struct for capturing environments.\n            struct _Env {\n                g: Csr<_Edge>,\n                now_ord: usize,\n                group_num: usize,\n                visited: Vec<usize>,\n                low: Vec<usize>,\n                ord: Vec<Option<usize>>,\n                ids: Vec<usize>,\n            }\n            let mut env = _Env {\n                g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n                now_ord: 0,\n                group_num: 0,\n                visited: Vec::with_capacity(self.n),\n                low: vec![0; self.n],\n                ord: vec![None; self.n],\n                ids: vec![0; self.n],\n            };\n\n            fn dfs(v: usize, n: usize, env: &mut _Env) {\n                env.low[v] = env.now_ord;\n                env.ord[v] = Some(env.now_ord);\n                env.now_ord += 1;\n                env.visited.push(v);\n\n                for i in env.g.start[v]..env.g.start[v + 1] {\n                    let to = env.g.elist[i].to;\n                    if let Some(x) = env.ord[to] {\n                        env.low[v] = std::cmp::min(env.low[v], x);\n                    } else {\n                        dfs(to, n, env);\n                        env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                    }\n                }\n                if env.low[v] == env.ord[v].unwrap() {\n                    loop {\n                        let u = *env.visited.last().unwrap();\n                        env.visited.pop();\n                        env.ord[u] = Some(n);\n                        env.ids[u] = env.group_num;\n                        if u == v {\n                            break;\n                        }\n                    }\n                    env.group_num += 1;\n                }\n            }\n            for i in 0..self.n {\n                if env.ord[i].is_none() {\n                    dfs(i, self.n, &mut env);\n                }\n            }\n            for x in env.ids.iter_mut() {\n                *x = env.group_num - 1 - *x;\n            }\n            (env.group_num, env.ids)\n        }\n\n        pub fn scc(&self) -> Vec<Vec<usize>> {\n            let ids = self.scc_ids();\n            let group_num = ids.0;\n            let mut counts = vec![0usize; group_num];\n            for &x in ids.1.iter() {\n                counts[x] += 1;\n            }\n            let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n            for i in 0..group_num {\n                groups[i].reserve(counts[i]);\n            }\n            for i in 0..self.n {\n                groups[ids.1[i]].push(i);\n            }\n            groups\n        }\n    }\n}\nmod twosat {\n    use crate::internal_scc;\n\n    pub struct TwoSat {\n        n: usize,\n        scc: internal_scc::SccGraph,\n        answer: Vec<bool>,\n    }\n    impl TwoSat {\n        pub fn new(n: usize) -> Self {\n            TwoSat {\n                n,\n                answer: vec![false; n],\n                scc: internal_scc::SccGraph::new(2 * n),\n            }\n        }\n        pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n            assert!(i < self.n && j < self.n);\n            self.scc.add_edge(2 * i + !f as usize, 2 * j + g as usize);\n            self.scc.add_edge(2 * j + !g as usize, 2 * i + f as usize);\n        }\n        pub fn satisfiable(&mut self) -> bool {\n            let id = self.scc.scc_ids().1;\n            for i in 0..self.n {\n                if id[2 * i] == id[2 * i + 1] {\n                    return false;\n                }\n                self.answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            true\n        }\n        pub fn answer(&self) -> &[bool] {\n            &self.answer\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        #![allow(clippy::many_single_char_names)]\n        use super::*;\n        #[test]\n        fn solve_alpc_h_sample1() {\n            // https://atcoder.jp/contests/practice2/tasks/practice2_h\n\n            let (n, d) = (3, 2);\n            let x = [1, 2, 0i32];\n            let y = [4, 5, 6];\n\n            let mut t = TwoSat::new(n);\n\n            for i in 0..n {\n                for j in i + 1..n {\n                    if (x[i] - x[j]).abs() < d {\n                        t.add_clause(i, false, j, false);\n                    }\n                    if (x[i] - y[j]).abs() < d {\n                        t.add_clause(i, false, j, true);\n                    }\n                    if (y[i] - x[j]).abs() < d {\n                        t.add_clause(i, true, j, false);\n                    }\n                    if (y[i] - y[j]).abs() < d {\n                        t.add_clause(i, true, j, true);\n                    }\n                }\n            }\n            assert!(t.satisfiable());\n            let answer = t.answer();\n            let mut res = vec![];\n            for (i, &v) in answer.iter().enumerate() {\n                if v {\n                    res.push(x[i])\n                } else {\n                    res.push(y[i]);\n                }\n            }\n\n            //Check the min distance between flags\n            res.sort();\n            let mut min_distance = i32::max_value();\n            for i in 1..res.len() {\n                min_distance = std::cmp::min(min_distance, res[i] - res[i - 1]);\n            }\n            assert!(min_distance >= d);\n        }\n\n        #[test]\n        fn solve_alpc_h_sample2() {\n            // https://atcoder.jp/contests/practice2/tasks/practice2_h\n\n            let (n, d) = (3, 3);\n            let x = [1, 2, 0i32];\n            let y = [4, 5, 6];\n\n            let mut t = TwoSat::new(n);\n\n            for i in 0..n {\n                for j in i + 1..n {\n                    if (x[i] - x[j]).abs() < d {\n                        t.add_clause(i, false, j, false);\n                    }\n                    if (x[i] - y[j]).abs() < d {\n                        t.add_clause(i, false, j, true);\n                    }\n                    if (y[i] - x[j]).abs() < d {\n                        t.add_clause(i, true, j, false);\n                    }\n                    if (y[i] - y[j]).abs() < d {\n                        t.add_clause(i, true, j, true);\n                    }\n                }\n            }\n            assert!(!t.satisfiable());\n        }\n    }\n}\nuse twosat::*;\n\nuse proconio::{\n    fastout, input,\n    marker::{Bytes, Chars, Isize1, Usize1},\n};\n\nfn main() {\n    input! {\n        n:usize,d:isize,\n    }\n    let mut x = vec![];\n    let mut y = vec![];\n    for _ in 0..n {\n        input! {\n            a:isize,b:isize,\n        }\n        x.push(a);\n        y.push(b);\n    }\n    let mut t = TwoSat::new(n);\n    for i in 0..n {\n        for j in i + 1..n {\n            if (x[i] - x[j]).abs() < d {\n                t.add_clause(i, false, j, false);\n            }\n            if (x[i] - y[j]).abs() < d {\n                t.add_clause(i, false, j, true);\n            }\n            if (y[i] - x[j]).abs() < d {\n                t.add_clause(i, true, j, false);\n            }\n            if (y[i] - y[j]).abs() < d {\n                t.add_clause(i, true, j, true);\n            }\n        }\n    }\n    if !t.satisfiable() {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    let answer = t.answer();\n    for (i, &v) in answer.iter().enumerate() {\n        if v {\n            println!(\"{}\", x[i]);\n        } else {\n            println!(\"{}\", y[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/practice2/tasks/practice2_h\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\ntype DirectedGraph = Vec<Vec<usize>>;\n\nstruct StronglyConnectedComponent {\n    n: usize,\n    graph: DirectedGraph,\n    reversed_graph: DirectedGraph,\n    component_ids: Vec<usize>\n}\n\nimpl StronglyConnectedComponent {\n    fn new(g: DirectedGraph) -> Self {\n        let n = g.len();\n        let mut rg = vec![vec![]; n];\n        for i in 0..n {\n            for &to in &g[i] {\n                rg[to].push(i);\n            }\n        }\n        Self {\n            n: g.len(),\n            graph: g,\n            reversed_graph: rg,\n            component_ids: vec![]\n        }\n    }\n\n    fn add_edge(&mut self, i: usize, j: usize) {\n        self.graph[i].push(j);\n        self.reversed_graph[j].push(i);\n    }\n\n    fn decompose(&mut self) -> usize {\n        let mut visited = vec![false; self.n];\n        let mut rev_order = vec![];\n        for i in 0..self.n {\n            if !visited[i] {\n                self.dfs(i, &mut visited, &mut rev_order);\n            }\n        }\n\n        let mut visited = vec![false; self.n];\n        let mut id = 0;\n        let mut component_ids = vec![0; self.n];\n        for &r in rev_order.iter().rev() {\n            if !visited[r] {\n                self.rdfs(r, id, &mut visited, &mut component_ids);\n                id += 1;\n            }\n        }\n        self.component_ids = component_ids;\n        id\n    }\n\n    fn dfs(&self, now: usize, visited: &mut Vec<bool>, rev_order: &mut Vec<usize>) {\n        visited[now] = true;\n        for &to in &self.graph[now] {\n            if !visited[to] {\n                self.dfs(to, visited, rev_order);\n            }\n        }\n        rev_order.push(now);\n    }\n\n    fn rdfs(&self, now: usize, id: usize, visited: &mut Vec<bool>, component_ids: &mut Vec<usize>) {\n        visited[now] = true;\n        component_ids[now] = id;\n        for &to in &self.reversed_graph[now] {\n            if !visited[to] {\n                self.rdfs(to, id, visited, component_ids);\n            }\n        }\n    }\n}\n\n\nstruct TwoSat {\n    n: usize,\n    scc: StronglyConnectedComponent\n}\n\nimpl TwoSat {\n    fn new(n: usize) -> Self {\n        Self {\n            n,\n            scc: StronglyConnectedComponent::new(vec![vec![]; 2*n])\n        }\n    }\n\n    /// Adds clause (a = f) v (b = g).\n    fn add_clause(&mut self, a: usize, f: bool, b: usize, g: bool) {\n        let f = ifv!(f, 0, 1);\n        let g = ifv!(g, 0, 1);\n        self.scc.add_edge(2 * a + f, 2 * b + g ^ 1);\n        self.scc.add_edge(2 * b + g, 2 * a + f ^ 1);\n    }\n\n    fn compute(&mut self) -> Option<Vec<bool>> {\n        self.scc.decompose();\n        let component_ids = &self.scc.component_ids;\n        let mut ans = vec![];\n        for i in 0..self.n {\n            if component_ids[i*2] == component_ids[i*2+1] {\n                return None;\n            }\n            ans.push(component_ids[i*2] < component_ids[i*2+1]);\n        }\n        Some(ans)\n    }\n}\n\nfn main() {\n    input! {\n        n: usize, d: i64,\n        choose: [[i64; 2]; n]\n    };\n\n    let mut twosat = TwoSat::new(n);\n    for i in 0..n {\n        for j in i+1..n {\n            for k in 0..2 {\n                for l in 0..2 {\n                    if (choose[i][k] - choose[j][l]).abs() < d {\n                        twosat.add_clause(i, k == 1, j, l == 1);\n                    }\n                }\n            }\n\n        }\n    }\n    if let Some(v) = twosat.compute() {\n        println!(\"Yes\");\n        for i in 0..n {\n            println!(\"{}\", ifv!(v[i], choose[i][0], choose[i][1]));\n        }\n    } else {\n        println!(\"No\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! read_line_to_tuple {\n    ( $( $t:ty ),* ) => {{\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input).unwrap();\n        let mut iter = input.split_whitespace();\n        ( $( iter.next().unwrap().parse::<$t>().unwrap() ),* )\n    }};\n}\n\nstruct Scc {\n    n: usize,\n    graph: Vec<Vec<usize>>,\n    rev_graph: Vec<Vec<usize>>,\n    post_order: Vec<usize>,\n    component: Vec<usize>,\n}\n\nimpl Scc {\n    fn new(n: usize) -> Scc {\n        Scc {\n            n,\n            graph: vec![Vec::new(); n],\n            rev_graph: vec![Vec::new(); n],\n            component: vec![n; n],\n            post_order: Vec::with_capacity(n),\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(to);\n        self.rev_graph[to].push(from);\n    }\n\n    fn dfs(&mut self, from: usize) {\n        self.component[from] = self.n + 1;\n        for to in self.graph[from].clone() {\n            if self.component[to] == self.n {\n                self.dfs(to);\n            }\n        }\n        self.post_order.push(from);\n    }\n    \n    fn rev_dfs(&mut self, from: usize, k: usize) {\n        self.component[from] = k;\n        for to in self.rev_graph[from].clone() {\n            if self.component[to] > self.n {\n                self.rev_dfs(to, k);\n            }\n        }\n    }\n\n    fn solve(&mut self) {\n        for i in 0..self.n {\n            if self.component[i] == self.n {\n                self.dfs(i);\n            }\n        }\n\n        let mut k: usize = 0;\n        for i in (0..self.n).rev() {\n            if self.component[self.post_order[i]] > self.n {\n                self.rev_dfs(self.post_order[i], k);\n                k += 1;\n            }\n        }\n    }\n}\n\nstruct TwoSat {\n    n: usize,\n    scc: Scc,\n}\n\nimpl TwoSat {\n    fn new(n: usize) -> TwoSat {\n        TwoSat {\n            n,\n            scc: Scc::new(n * 2),\n        }\n    }\n\n    fn add_closure(&mut self, x: usize, y: usize) {\n        self.scc.add_edge((x + self.n) % (self.n * 2), y);\n        self.scc.add_edge((y + self.n) % (self.n * 2), x);\n    }\n\n    fn solve(&mut self) -> Option<Vec<bool>> {\n        self.scc.solve();\n\n        let mut res = vec![false; self.n];\n        for i in 0..self.n {\n            if self.scc.component[i] == self.scc.component[i + self.n] {\n                return None;\n            }\n            res[i] = self.scc.component[i] > self.scc.component[i + self.n];\n        }\n\n        Some(res)\n    }\n}\n\nfn main() {\n    let (n, d) = read_line_to_tuple!(usize, i64);\n\n    let mut ts = TwoSat::new(n);\n    let (mut x, mut y) = (vec![0; n], vec![0; n]);\n    for i in 0..n {\n        let (a, b) = read_line_to_tuple!(i64, i64);\n        x[i] = a;\n        y[i] = b;\n    }\n\n    for i in 0..n {\n        for j in (i + 1)..n {\n            if (x[i] - x[j]).abs() < d {\n                ts.add_closure(i + n, j + n);\n            }\n            if (x[i] - y[j]).abs() < d {\n                ts.add_closure(i + n, j);\n            }\n            if (y[i] - x[j]).abs() < d {\n                ts.add_closure(i, j + n);\n            }\n            if (y[i] - y[j]).abs() < d {\n                ts.add_closure(i, j);\n            }\n        }\n    }\n\n    let res = ts.solve();\n    if let Some(res) = res {\n        let mut ans = Vec::with_capacity(n + 1);\n        ans.push(\"Yes\".to_string());\n        for i in 0..n {\n            if res[i] {\n                ans.push(x[i].to_string());\n            } else {\n                ans.push(y[i].to_string());\n            }\n        }\n        println!(\"{}\", ans.join(\"\\n\"));\n    } else {\n        println!(\"No\");\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\nuse std::ops::Bound::*;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let v = read_vec::<i64>();\n    let (n, d) = (v[0] as usize, v[1]);\n    let mut cands = vec![];\n    for i in 0..n {\n        let v = read_vec::<i64>();\n        let (x, y) = (v[0], v[1]);\n        cands.push((x, y));\n    }\n\n    let mut cons = vec![];\n    for i in 0..n {\n        let (xi, yi) = cands[i];\n        for j in 0..i {\n            let (xj, yj) = cands[j];\n            let i = i as i32 + 1;\n            let j = j as i32 + 1;\n\n            if (xi - xj).abs() < d {\n                cons.push((i, j));\n            }\n            if (xi - yj).abs() < d {\n                cons.push((i, -j));\n            }\n            if (yi - xj).abs() < d {\n                cons.push((-i, j));\n            }\n            if (yi - yj).abs() < d {\n                cons.push((-i, -j));\n            }\n        }\n    }\n    debug!(\"ii\");\n    if let Some(ans) = two_sat(n, &cons) {\n        println!(\"Yes\");\n        debug!(ans);\n        for i in 0..n {\n            if ans[i] {\n                println!(\"{}\", cands[i].1);\n            } else {\n                println!(\"{}\", cands[i].0);\n            }\n        }\n    } else {\n        println!(\"No\");\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\nstruct SCC {\n    n: usize,\n    ncc: usize,\n    g: Vec<Vec<usize>>,  // graph in adjacent list\n    rg: Vec<Vec<usize>>, // reverse graph\n    cmp: Vec<usize>,     // topological order\n}\n\nimpl SCC {\n    fn new(n: usize) -> Self {\n        SCC {\n            n: n,\n            ncc: n + 1,\n            g: vec![Vec::new(); n],\n            rg: vec![Vec::new(); n],\n            cmp: vec![0; n],\n        }\n    }\n    fn add_edge(&mut self, from: usize, to: usize) {\n        self.g[from].push(to);\n        self.rg[to].push(from);\n    }\n    fn dfs(&self, v: usize, used: &mut [bool], vs: &mut Vec<usize>) {\n        used[v] = true;\n        for &w in self.g[v].iter() {\n            if !used[w] {\n                self.dfs(w, used, vs);\n            }\n        }\n        vs.push(v);\n    }\n    fn rdfs(&self, v: usize, k: usize, used: &mut [bool], cmp: &mut [usize]) {\n        used[v] = true;\n        cmp[v] = k;\n        for &w in self.rg[v].iter() {\n            if !used[w] {\n                self.rdfs(w, k, used, cmp);\n            }\n        }\n    }\n    fn scc(&mut self) -> usize {\n        let n = self.n;\n        let mut used = vec![false; n];\n        let mut vs = Vec::new();\n        let mut cmp = vec![0; n];\n        for v in 0..n {\n            if !used[v] {\n                self.dfs(v, &mut used, &mut vs);\n            }\n        }\n        for u in used.iter_mut() {\n            *u = false;\n        }\n        let mut k = 0;\n        for &t in vs.iter().rev() {\n            if !used[t] {\n                self.rdfs(t, k, &mut used, &mut cmp);\n                k += 1;\n            }\n        }\n        self.ncc = k;\n        self.cmp = cmp;\n        k\n    }\n    #[allow(dead_code)]\n    fn top_order(&self) -> Vec<usize> {\n        assert!(self.ncc <= self.n);\n        self.cmp.clone()\n    }\n    /*\n     * Returns a dag whose vertices are scc's, and whose edges are those of the original graph.\n     */\n    #[allow(dead_code)]\n    fn dag(&self) -> Vec<Vec<usize>> {\n        assert!(self.ncc <= self.n);\n        let ncc = self.ncc;\n        let mut ret = vec![HashSet::new(); ncc];\n        let n = self.n;\n        for i in 0..n {\n            for &to in self.g[i].iter() {\n                if self.cmp[i] != self.cmp[to] {\n                    assert!(self.cmp[i] < self.cmp[to]);\n                    ret[self.cmp[i]].insert(self.cmp[to]);\n                }\n            }\n        }\n        ret.into_iter()\n            .map(|set| set.into_iter().collect())\n            .collect()\n    }\n    #[allow(dead_code)]\n    fn rdag(&self) -> Vec<Vec<usize>> {\n        assert!(self.ncc <= self.n);\n        let ncc = self.ncc;\n        let mut ret = vec![HashSet::new(); ncc];\n        let n = self.n;\n        for i in 0..n {\n            for &to in self.g[i].iter() {\n                if self.cmp[i] != self.cmp[to] {\n                    assert!(self.cmp[i] < self.cmp[to]);\n                    ret[self.cmp[to]].insert(self.cmp[i]);\n                }\n            }\n        }\n        ret.into_iter()\n            .map(|set| set.into_iter().collect())\n            .collect()\n    }\n}\n\n/**\n * 2-SAT solver.\n * n: the number of variables (v_1, ..., v_n)\n * cons: constraints, given in 2-cnf\n * i (1 <= i <= n) means v_i, -i (1 <= i <= n) means not v_i.\n * Returns: None if there's no assignment that satisfies cons.\n * Otherwise, it returns an assignment that safisfies cons. (true: true, false: false)\n * Dependencies: SCC.rs\n * Verified by: Codeforces #400 D\n *              (http://codeforces.com/contest/776/submission/24957215)\n */\nfn two_sat(n: usize, cons: &[(i32, i32)]) -> Option<Vec<bool>> {\n    let mut scc = SCC::new(2 * n);\n    let ni = n as i32;\n    for &(c1, c2) in cons.iter() {\n        let x = if c1 > 0 { c1 - 1 + ni } else { -c1 - 1 } as usize;\n        let y = if c2 > 0 { c2 - 1 } else { -c2 - 1 + ni } as usize;\n        scc.add_edge(x, y);\n        scc.add_edge((y + n) % (2 * n), (x + n) % (2 * n));\n    }\n    scc.scc();\n    let mut result = vec![false; n];\n    let top_ord = scc.top_order();\n    for i in 0..n {\n        if top_ord[i] == top_ord[i + n] {\n            return None;\n        }\n        result[i] = top_ord[i] > top_ord[i + n];\n    }\n    Some(result)\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\nuse std::ops::Bound::*;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let v = read_vec::<i64>();\n    let (n, d) = (v[0] as usize, v[1]);\n    let mut cands = vec![];\n    for i in 0..n {\n        let v = read_vec::<i64>();\n        let (x, y) = (v[0], v[1]);\n        cands.push((x, y));\n    }\n    // [0, n): x (not y)\n    // [n, 2 * n): y (not x)\n    let mut g = vec![vec![]; 2 * n];\n    let mut rg = vec![vec![]; 2 * n];\n    for i in 0..n {\n        let (xi, yi) = cands[i];\n        for j in i + 1..n {\n            let (xj, yj) = cands[j];\n\n            if (xi - xj).abs() < d {\n                add_edge(2 * i, 2 * j + 1, &mut g, &mut rg);\n                add_edge(2 * j, 2 * i + 1, &mut g, &mut rg);\n            }\n            if (xi - yj).abs() < d {\n                add_edge(2 * i, 2 * j, &mut g, &mut rg);\n                add_edge(2 * j + 1, 2 * i + 1, &mut g, &mut rg);\n            }\n            if (yi - xj).abs() < d {\n                add_edge(2 * i + 1, 2 * j + 1, &mut g, &mut rg);\n                add_edge(2 * j, 2 * i, &mut g, &mut rg);\n            }\n            if (yi - yj).abs() < d {\n                add_edge(2 * i + 1, 2 * j, &mut g, &mut rg);\n                add_edge(2 * j + 1, 2 * i, &mut g, &mut rg);\n            }\n        }\n    }\n    let cmp = scc(&g, &rg);\n    if (0..n).any(|i| cmp[2 * i] == cmp[2 * i + 1]) {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    for i in 0..n {\n        if cmp[2 * i] < cmp[2 * i + 1] {\n            println!(\"{}\", cands[i].1);\n        } else {\n            println!(\"{}\", cands[i].0);\n        }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\ntype Graph = Vec<Vec<usize>>;\n\nfn dfs(v: usize, used: &mut Vec<bool>, g: &Graph, vs: &mut Vec<usize>) {\n    used[v] = true;\n    for &to in g[v].iter() {\n        if !used[to] {\n            dfs(to, used, g, vs);\n        }\n    }\n    vs.push(v);\n}\n\nfn rdfs(v: usize, k: usize, used: &mut Vec<bool>, rg: &Graph, cmp: &mut Vec<usize>) {\n    used[v] = true;\n    cmp[v] = k;\n    for &to in rg[v].iter() {\n        if !used[to] {\n            rdfs(to, k, used, rg, cmp);\n        }\n    }\n}\n\nfn add_edge(from: usize, to: usize, g: &mut Graph, rg: &mut Graph) {\n    g[from].push(to);\n    rg[to].push(from);\n}\n\nfn scc(g: &Graph, rg: &Graph) -> Vec<usize> {\n    let mut used = vec![false; g.len()];\n    let mut vs = vec![];\n    for v in 0..g.len() {\n        if !used[v] {\n            dfs(v, &mut used, &g, &mut vs);\n        }\n    }\n    let mut used = vec![false; g.len()];\n    let mut cmp = vec![0usize; g.len()];\n    let mut k = 0;\n    for &i in vs.iter().rev() {\n        if !used[i] {\n            rdfs(i, k, &mut used, &rg, &mut cmp);\n            k += 1;\n        }\n    }\n    cmp\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://github.com/rust-lang-ja/ac-library-rs\n\npub struct Csr<E> {\n    start: Vec<usize>,\n    elist: Vec<E>,\n}\n\nimpl<E> Csr<E>\nwhere\n    E: Copy,\n{\n    pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n        let mut csr = Csr {\n            start: vec![0; n + 1],\n            elist: vec![init; edges.len()],\n        };\n        for e in edges.iter() {\n            csr.start[e.0 + 1] += 1;\n        }\n        for i in 1..=n {\n            csr.start[i] += csr.start[i - 1];\n        }\n        let mut counter = csr.start.clone();\n        for e in edges.iter() {\n            csr.elist[counter[e.0]] = e.1;\n            counter[e.0] += 1;\n        }\n        csr\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct _Edge {\n    to: usize,\n}\n\n/// Reference:\n/// R. Tarjan,\n/// Depth-First Search and Linear Graph Algorithms\npub struct SccGraph {\n    n: usize,\n    edges: Vec<(usize, _Edge)>,\n}\n\nimpl SccGraph {\n    pub fn new(n: usize) -> Self {\n        SccGraph { n, edges: vec![] }\n    }\n\n    pub fn num_vertices(&self) -> usize {\n        self.n\n    }\n\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.edges.push((from, _Edge { to }));\n    }\n\n    /// return pair of (# of scc, scc id)\n    pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n        // In C++ ac-library, this function is implemented by using recursive lambda functions.\n        // Instead, we use fn and struct for capturing environments.\n        struct _Env {\n            g: Csr<_Edge>,\n            now_ord: usize,\n            group_num: usize,\n            visited: Vec<usize>,\n            low: Vec<usize>,\n            ord: Vec<Option<usize>>,\n            ids: Vec<usize>,\n        }\n        let mut env = _Env {\n            g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n            now_ord: 0,\n            group_num: 0,\n            visited: Vec::with_capacity(self.n),\n            low: vec![0; self.n],\n            ord: vec![None; self.n],\n            ids: vec![0; self.n],\n        };\n\n        fn dfs(v: usize, n: usize, env: &mut _Env) {\n            env.low[v] = env.now_ord;\n            env.ord[v] = Some(env.now_ord);\n            env.now_ord += 1;\n            env.visited.push(v);\n\n            for i in env.g.start[v]..env.g.start[v + 1] {\n                let to = env.g.elist[i].to;\n                if let Some(x) = env.ord[to] {\n                    env.low[v] = std::cmp::min(env.low[v], x);\n                } else {\n                    dfs(to, n, env);\n                    env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                }\n            }\n            if env.low[v] == env.ord[v].unwrap() {\n                loop {\n                    let u = *env.visited.last().unwrap();\n                    env.visited.pop();\n                    env.ord[u] = Some(n);\n                    env.ids[u] = env.group_num;\n                    if u == v {\n                        break;\n                    }\n                }\n                env.group_num += 1;\n            }\n        }\n        for i in 0..self.n {\n            if env.ord[i].is_none() {\n                dfs(i, self.n, &mut env);\n            }\n        }\n        for x in env.ids.iter_mut() {\n            *x = env.group_num - 1 - *x;\n        }\n        (env.group_num, env.ids)\n    }\n\n    pub fn scc(&self) -> Vec<Vec<usize>> {\n        let ids = self.scc_ids();\n        let group_num = ids.0;\n        let mut counts = vec![0usize; group_num];\n        for &x in ids.1.iter() {\n            counts[x] += 1;\n        }\n        let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n        for i in 0..group_num {\n            groups[i].reserve(counts[i]);\n        }\n        for i in 0..self.n {\n            groups[ids.1[i]].push(i);\n        }\n        groups\n    }\n}\n\npub struct TwoSAT {\n    n: usize,\n    scc: SccGraph,\n    answer: Vec<bool>,\n}\nimpl TwoSAT {\n    pub fn new(n: usize) -> Self {\n        TwoSAT {\n            n,\n            answer: vec![false; n],\n            scc: SccGraph::new(2 * n),\n        }\n    }\n    pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n        assert!(i < self.n && j < self.n);\n        self.scc\n            .add_edge(2 * i + if f { 0 } else { 1 }, 2 * j + if g { 1 } else { 0 });\n        self.scc\n            .add_edge(2 * j + if f { 0 } else { 1 }, 2 * i + if g { 1 } else { 0 });\n    }\n    pub fn satisfiable(&mut self) -> bool {\n        let id = self.scc.scc_ids().1;\n        for i in 0..self.n {\n            if id[2 * i] == id[2 * i + 1] {\n                return false;\n            }\n            self.answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        true\n    }\n    pub fn answer(&self) -> &Vec<bool> {\n        &self.answer\n    }\n}\n\n#[allow(unused_imports)]\nuse proconio::{\n    fastout, input,\n    marker::{Bytes, Chars, Isize1, Usize1},\n};\n\nfn main() {\n    input! {\n        n:usize,d:isize,\n    }\n    let mut x = vec![];\n    let mut y = vec![];\n    for _ in 0..n {\n        input! {\n            a:isize,b:isize,\n        }\n        x.push(a);\n        y.push(b);\n    }\n\n    let mut t = TwoSAT::new(n);\n\n    for i in 0..n {\n        for j in i + 1..n {\n            if (x[i] - x[j]).abs() < d {\n                t.add_clause(i, false, j, false);\n            }\n            if (x[i] - y[j]).abs() < d {\n                t.add_clause(i, false, j, true);\n            }\n            if (y[i] - x[j]).abs() < d {\n                t.add_clause(i, true, j, false);\n            }\n            if (y[i] - y[j]).abs() < d {\n                t.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if !t.satisfiable() {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    let answer = t.answer();\n    for (i, &v) in answer.iter().enumerate() {\n        if v {\n            println!(\"{}\", x[i]);\n        } else {\n            println!(\"{}\", y[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "mod internal_scc {\n    pub struct Csr<E> {\n        start: Vec<usize>,\n        elist: Vec<E>,\n    }\n    \n    impl<E> Csr<E>\n    where\n        E: Copy,\n    {\n        pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n            let mut csr = Csr {\n                start: vec![0; n + 1],\n                elist: vec![init; edges.len()],\n            };\n            for e in edges.iter() {\n                csr.start[e.0 + 1] += 1;\n            }\n            for i in 1..=n {\n                csr.start[i] += csr.start[i - 1];\n            }\n            let mut counter = csr.start.clone();\n            for e in edges.iter() {\n                csr.elist[counter[e.0]] = e.1;\n                counter[e.0] += 1;\n            }\n            csr\n        }\n    }\n    \n    #[derive(Copy, Clone)]\n    struct _Edge {\n        to: usize,\n    }\n    \n    /// Reference:\n    /// R. Tarjan,\n    /// Depth-First Search and Linear Graph Algorithms\n    pub struct SccGraph {\n        n: usize,\n        edges: Vec<(usize, _Edge)>,\n    }\n    \n    impl SccGraph {\n        pub fn new(n: usize) -> Self {\n            SccGraph { n, edges: vec![] }\n        }\n    \n        pub fn num_vertices(&self) -> usize {\n            self.n\n        }\n    \n        pub fn add_edge(&mut self, from: usize, to: usize) {\n            self.edges.push((from, _Edge { to }));\n        }\n    \n        /// return pair of (# of scc, scc id)\n        pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n            // In C++ ac-library, this function is implemented by using recursive lambda functions.\n            // Instead, we use fn and struct for capturing environments.\n            struct _Env {\n                g: Csr<_Edge>,\n                now_ord: usize,\n                group_num: usize,\n                visited: Vec<usize>,\n                low: Vec<usize>,\n                ord: Vec<Option<usize>>,\n                ids: Vec<usize>,\n            }\n            let mut env = _Env {\n                g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n                now_ord: 0,\n                group_num: 0,\n                visited: Vec::with_capacity(self.n),\n                low: vec![0; self.n],\n                ord: vec![None; self.n],\n                ids: vec![0; self.n],\n            };\n    \n            fn dfs(v: usize, n: usize, env: &mut _Env) {\n                env.low[v] = env.now_ord;\n                env.ord[v] = Some(env.now_ord);\n                env.now_ord += 1;\n                env.visited.push(v);\n    \n                for i in env.g.start[v]..env.g.start[v + 1] {\n                    let to = env.g.elist[i].to;\n                    if let Some(x) = env.ord[to] {\n                        env.low[v] = std::cmp::min(env.low[v], x);\n                    } else {\n                        dfs(to, n, env);\n                        env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                    }\n                }\n                if env.low[v] == env.ord[v].unwrap() {\n                    loop {\n                        let u = *env.visited.last().unwrap();\n                        env.visited.pop();\n                        env.ord[u] = Some(n);\n                        env.ids[u] = env.group_num;\n                        if u == v {\n                            break;\n                        }\n                    }\n                    env.group_num += 1;\n                }\n            }\n            for i in 0..self.n {\n                if env.ord[i].is_none() {\n                    dfs(i, self.n, &mut env);\n                }\n            }\n            for x in env.ids.iter_mut() {\n                *x = env.group_num - 1 - *x;\n            }\n            (env.group_num, env.ids)\n        }\n    \n        pub fn scc(&self) -> Vec<Vec<usize>> {\n            let ids = self.scc_ids();\n            let group_num = ids.0;\n            let mut counts = vec![0usize; group_num];\n            for &x in ids.1.iter() {\n                counts[x] += 1;\n            }\n            let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n            for i in 0..group_num {\n                groups[i].reserve(counts[i]);\n            }\n            for i in 0..self.n {\n                groups[ids.1[i]].push(i);\n            }\n            groups\n        }\n    }\n}\n\nmod twosat {\n    use crate::internal_scc;\n\n    pub struct TwoSat {\n        n: usize,\n        scc: internal_scc::SccGraph,\n        answer: Vec<bool>,\n    }\n    impl TwoSat {\n        pub fn new(n: usize) -> Self {\n            TwoSat {\n                n,\n                answer: vec![false; n],\n                scc: internal_scc::SccGraph::new(2 * n),\n            }\n        }\n        pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n            assert!(i < self.n && j < self.n);\n            self.scc.add_edge(2 * i + !f as usize, 2 * j + g as usize);\n            self.scc.add_edge(2 * j + !g as usize, 2 * i + f as usize);\n        }\n        pub fn satisfiable(&mut self) -> bool {\n            let id = self.scc.scc_ids().1;\n            for i in 0..self.n {\n                if id[2 * i] == id[2 * i + 1] {\n                    return false;\n                }\n                self.answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            true\n        }\n        pub fn answer(&self) -> &[bool] {\n            &self.answer\n        }\n    }\n}\n\nuse twosat::TwoSat;\nuse std::io::Read;\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).unwrap();\n    let mut input = buf.split_whitespace();\n\n    let n = input.next().unwrap().parse().unwrap();\n    let d = input.next().unwrap().parse().unwrap();\n    let xs = (0..2 * n)\n        .map(|_| input.next().unwrap().parse().unwrap())\n        .collect::<Vec<i32>>();\n\n    let mut sat = TwoSat::new(2*n);\n    for i in 0..2 * n {\n        sat.add_clause(i, i % 2 == 0, i ^ 1, i % 2 == 0);\n    }\n    for (i, x) in xs.iter().enumerate() {\n        for (j, y) in xs[..i].iter().enumerate() {\n            if (x - y).abs() < d {\n                sat.add_clause(i, false, j, false);\n            }\n        }\n    }\n    if sat.satisfiable() {\n        println!(\"Yes\");\n        let ans = sat.answer();\n        for i in 0..n {\n            println!(\"{}\", xs[2 * i + ans[2 * i + 1] as usize]);\n        }\n    } else {\n        println!(\"No\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://github.com/rust-lang-ja/ac-library-rs\n\npub struct Csr<E> {\n    start: Vec<usize>,\n    elist: Vec<E>,\n}\n\nimpl<E> Csr<E>\nwhere\n    E: Copy,\n{\n    pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n        let mut csr = Csr {\n            start: vec![0; n + 1],\n            elist: vec![init; edges.len()],\n        };\n        for e in edges.iter() {\n            csr.start[e.0 + 1] += 1;\n        }\n        for i in 1..=n {\n            csr.start[i] += csr.start[i - 1];\n        }\n        let mut counter = csr.start.clone();\n        for e in edges.iter() {\n            csr.elist[counter[e.0]] = e.1;\n            counter[e.0] += 1;\n        }\n        csr\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct _Edge {\n    to: usize,\n}\n\n/// Reference:\n/// R. Tarjan,\n/// Depth-First Search and Linear Graph Algorithms\npub struct SccGraph {\n    n: usize,\n    edges: Vec<(usize, _Edge)>,\n}\n\nimpl SccGraph {\n    pub fn new(n: usize) -> Self {\n        SccGraph { n, edges: vec![] }\n    }\n\n    pub fn num_vertices(&self) -> usize {\n        self.n\n    }\n\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.edges.push((from, _Edge { to }));\n    }\n\n    /// return pair of (# of scc, scc id)\n    pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n        // In C++ ac-library, this function is implemented by using recursive lambda functions.\n        // Instead, we use fn and struct for capturing environments.\n        struct _Env {\n            g: Csr<_Edge>,\n            now_ord: usize,\n            group_num: usize,\n            visited: Vec<usize>,\n            low: Vec<usize>,\n            ord: Vec<Option<usize>>,\n            ids: Vec<usize>,\n        }\n        let mut env = _Env {\n            g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n            now_ord: 0,\n            group_num: 0,\n            visited: Vec::with_capacity(self.n),\n            low: vec![0; self.n],\n            ord: vec![None; self.n],\n            ids: vec![0; self.n],\n        };\n\n        fn dfs(v: usize, n: usize, env: &mut _Env) {\n            env.low[v] = env.now_ord;\n            env.ord[v] = Some(env.now_ord);\n            env.now_ord += 1;\n            env.visited.push(v);\n\n            for i in env.g.start[v]..env.g.start[v + 1] {\n                let to = env.g.elist[i].to;\n                if let Some(x) = env.ord[to] {\n                    env.low[v] = std::cmp::min(env.low[v], x);\n                } else {\n                    dfs(to, n, env);\n                    env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                }\n            }\n            if env.low[v] == env.ord[v].unwrap() {\n                loop {\n                    let u = *env.visited.last().unwrap();\n                    env.visited.pop();\n                    env.ord[u] = Some(n);\n                    env.ids[u] = env.group_num;\n                    if u == v {\n                        break;\n                    }\n                }\n                env.group_num += 1;\n            }\n        }\n        for i in 0..self.n {\n            if env.ord[i].is_none() {\n                dfs(i, self.n, &mut env);\n            }\n        }\n        for x in env.ids.iter_mut() {\n            *x = env.group_num - 1 - *x;\n        }\n        (env.group_num, env.ids)\n    }\n\n    pub fn scc(&self) -> Vec<Vec<usize>> {\n        let ids = self.scc_ids();\n        let group_num = ids.0;\n        let mut counts = vec![0usize; group_num];\n        for &x in ids.1.iter() {\n            counts[x] += 1;\n        }\n        let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n        for i in 0..group_num {\n            groups[i].reserve(counts[i]);\n        }\n        for i in 0..self.n {\n            groups[ids.1[i]].push(i);\n        }\n        groups\n    }\n}\n\npub struct TwoSAT {\n    n: usize,\n    scc: SccGraph,\n    answer: Vec<bool>,\n}\nimpl TwoSAT {\n    pub fn new(n: usize) -> Self {\n        TwoSAT {\n            n,\n            answer: vec![false; n],\n            scc: SccGraph::new(2 * n),\n        }\n    }\n    pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n        assert!(i < self.n && j < self.n);\n        self.scc.add_edge(2 * i + !f as usize, 2 * j + g as usize);\n        self.scc.add_edge(2 * j + !g as usize, 2 * i + f as usize);\n    }\n    pub fn satisfiable(&mut self) -> bool {\n        let id = self.scc.scc_ids().1;\n        for i in 0..self.n {\n            if id[2 * i] == id[2 * i + 1] {\n                return false;\n            }\n            self.answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        true\n    }\n    pub fn answer(&self) -> &Vec<bool> {\n        &self.answer\n    }\n}\n\n#[allow(unused_imports)]\nuse proconio::{\n    fastout, input,\n    marker::{Bytes, Chars, Isize1, Usize1},\n};\n\nfn main() {\n    input! {\n        n:usize,d:isize,\n    }\n    let mut x = vec![];\n    let mut y = vec![];\n    for _ in 0..n {\n        input! {\n            a:isize,b:isize,\n        }\n        x.push(a);\n        y.push(b);\n    }\n\n    let mut t = TwoSAT::new(n);\n\n    for i in 0..n {\n        for j in i + 1..n {\n            if (x[i] - x[j]).abs() < d {\n                t.add_clause(i, false, j, false);\n            }\n            if (x[i] - y[j]).abs() < d {\n                t.add_clause(i, false, j, true);\n            }\n            if (y[i] - x[j]).abs() < d {\n                t.add_clause(i, true, j, false);\n            }\n            if (y[i] - y[j]).abs() < d {\n                t.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if !t.satisfiable() {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    let answer = t.answer();\n    for (i, &v) in answer.iter().enumerate() {\n        if v {\n            println!(\"{}\", x[i]);\n        } else {\n            println!(\"{}\", y[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\nuse std::ops::Bound::*;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let v = read_vec::<i64>();\n    let (n, d) = (v[0] as usize, v[1]);\n    let mut cands = vec![];\n    for i in 0..n {\n        let v = read_vec::<i64>();\n        let (x, y) = (v[0], v[1]);\n        cands.push((x, y));\n    }\n    // [0, n): x (not y)\n    // [n, 2 * n): y (not x)\n    let mut g = vec![vec![]; 2 * n];\n    let mut rg = vec![vec![]; 2 * n];\n    for i in 0..n {\n        let (xi, yi) = cands[i];\n        for j in i + 1..n {\n            let (xj, yj) = cands[j];\n\n            if (xi - xj).abs() < d {\n                add_edge(2 * i, 2 * j + 1, &mut g, &mut rg);\n                add_edge(2 * j, 2 * i + 1, &mut g, &mut rg);\n            }\n            if (xi - yj).abs() < d {\n                add_edge(2 * i, 2 * j, &mut g, &mut rg);\n                add_edge(2 * j + 1, 2 * i + 1, &mut g, &mut rg);\n            }\n            if (yi - xj).abs() < d {\n                add_edge(2 * i + 1, 2 * j + 1, &mut g, &mut rg);\n                add_edge(2 * j, 2 * i, &mut g, &mut rg);\n            }\n            if (yi - yj).abs() < d {\n                add_edge(2 * i + 1, 2 * j, &mut g, &mut rg);\n                add_edge(2 * j + 1, i, &mut g, &mut rg);\n            }\n        }\n    }\n    let cmp = scc(&g, &rg);\n    if (0..n).any(|i| cmp[2 * i] == cmp[2 * i + 1]) {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    for i in 0..n {\n        if cmp[2 * i] < cmp[2 * i + 1] {\n            println!(\"{}\", cands[i].1);\n        } else {\n            println!(\"{}\", cands[i].0);\n        }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\ntype Graph = Vec<Vec<usize>>;\n\nfn dfs(v: usize, used: &mut Vec<bool>, g: &Graph, vs: &mut Vec<usize>) {\n    used[v] = true;\n    for &to in g[v].iter() {\n        if !used[to] {\n            dfs(to, used, g, vs);\n        }\n    }\n    vs.push(v);\n}\n\nfn rdfs(v: usize, k: usize, used: &mut Vec<bool>, rg: &Graph, cmp: &mut Vec<usize>) {\n    used[v] = true;\n    cmp[v] = k;\n    for &to in rg[v].iter() {\n        if !used[to] {\n            rdfs(to, k, used, rg, cmp);\n        }\n    }\n}\n\nfn add_edge(from: usize, to: usize, g: &mut Graph, rg: &mut Graph) {\n    g[from].push(to);\n    rg[to].push(from);\n}\n\nfn scc(g: &Graph, rg: &Graph) -> Vec<usize> {\n    let mut used = vec![false; g.len()];\n    let mut vs = vec![];\n    for v in 0..g.len() {\n        if !used[v] {\n            dfs(v, &mut used, &g, &mut vs);\n        }\n    }\n    let mut used = vec![false; g.len()];\n    let mut cmp = vec![0usize; g.len()];\n    let mut k = 0;\n    for &i in vs.iter().rev() {\n        if !used[i] {\n            rdfs(i, k, &mut used, &rg, &mut cmp);\n            k += 1;\n        }\n    }\n    cmp\n}\n"
  },
  {
    "language": "Rust",
    "code": "//! This code is generated by [cargo-compete](https://github.com/qryxip/cargo-compete).\n//!\n//! # Original source code\n//!\n//! ```ignore\n//! #![allow(unused_imports)]\n//! #![allow(non_snake_case)]\n//! use std::cmp::*;\n//! use std::collections::*;\n//! use std::ops::Bound::*;\n//! use itertools::Itertools;\n//! use num_traits::clamp;\n//! use ordered_float::OrderedFloat;\n//! use proconio::{input, marker::*, fastout};\n//! use superslice::*;\n//! use ac_library_rs::*;\n//!\n//! #[fastout]\n//! fn main() {\n//!     input! {\n//!         n: usize, d: i64,\n//!         xy: [(i64, i64); n]\n//!     }\n//!\n//!     let mut ts = TwoSat::new(n);\n//!\n//!     for i in 0..n {\n//!         let (xi, yi) = xy[i];\n//!         for j in i + 1..n {\n//!             let (xj, yj) = xy[j];\n//!             if (xi - xj).abs() < d {\n//!                 ts.add_clause(i, false, j, false);\n//!             }\n//!             if (xi - yj).abs() < d {\n//!                 ts.add_clause(i, false, j, true);\n//!             }\n//!             if (yi - xj).abs() < d {\n//!                 ts.add_clause(i, true, j, false);\n//!             }\n//!             if (yi - yj).abs() < d {\n//!                 ts.add_clause(i, true, j, true);\n//!             }\n//!         }\n//!     }\n//!\n//!     if !ts.satisfiable() {\n//!         println!(\"No\");\n//!         return;\n//!     }\n//!\n//!     println!(\"Yes\");\n//!     let answer = ts.answer();\n//!     for i in 0..n {\n//!         if answer[i] {\n//!             println!(\"{}\", xy[i].0);\n//!         } else {\n//!             println!(\"{}\", xy[i].1);\n//!         }\n//!     }\n//!\n//! }\n//! ```\n\nuse std::{\n    fs::{File, Permissions},\n    io::{self, Write as _},\n    os::unix::{fs::PermissionsExt as _, process::CommandExt as _},\n    process::Command,\n};\n\nfn main() -> io::Result<()> {\n    let mut file = File::create(PATH)?;\n    file.write_all(&decode())?;\n    file.set_permissions(Permissions::from_mode(0o755))?;\n    file.sync_all()?;\n    drop(file);\n    Err(Command::new(PATH).exec())\n}\n\nfn decode() -> Vec<u8> {\n    let mut table = [0; 256];\n    for (i, &c) in b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        .iter()\n        .enumerate()\n    {\n        table[usize::from(c)] = i as u8;\n    }\n\n    let mut acc = vec![];\n\n    for chunk in BASE64.as_bytes().chunks(4) {\n        let index0 = table[usize::from(chunk[0])];\n        let index1 = table[usize::from(chunk[1])];\n        let index2 = table[usize::from(chunk[2])];\n        let index3 = table[usize::from(chunk[3])];\n        acc.push((index0 << 2) + (index1 >> 4));\n        acc.push((index1 << 4) + (index2 >> 2));\n        acc.push((index2 << 6) + index3);\n    }\n\n    if BASE64.ends_with(\"==\") {\n        acc.pop();\n        acc.pop();\n    } else if BASE64.ends_with('=') {\n        acc.pop();\n    }\n\n    acc\n}\n\nstatic PATH: &str = \"/tmp/a.out\";\nstatic BASE64: &str = \"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Wuy7g1UAEV9f6yUolFqhDgkXeatnJxt7qi8XLzAvAIkv/0VhZCGR/wBaTElCTBDADg+jerEFoBWBazpk/IWwCV1fc6UvuQovSZktmmIKxomUJ4namOA6nr9py2UmCPA6x0BwsAgg4ZtNgoUUByslAGuOh/4daCb//xPYAJYwB3csYQ7uulEJmRnEbQeP//////RqcDWlY+mjlWSeMojbDqS43Hke6dXgiNnSlytMtgm9/////3yxfgctuOeRHb+QZBC3HfIgsGpIcbnz3kG+hH3U2hrr/////+TdbVG11PTHhdODVphsE8Coa2R6+WL97Mllik9cARTZ/4X/0mwGaD0P+vUNCI3I5jteEGlM5EFg/////9VycWei0eQDPEfUBEv9hQ3Sa7UKpfqotTVsmLJC1sm7/////9tA+bys42zYMnVc30XPDdbcWT3Rq6ww2SY6AN5RgFHX/////8gWYdC/tfS0ISPEs1aZlbrPD6W9uJ64AigIiAVfstkM//+X/sYk6Quxh3z/EUxoWKsdYcE9LWa2kEHcdgZx/////9sBvCDSmCoQ1e+JhbFxH7W2BqXkv58z1LjooskHeDT5f+P//wAPjqgJlhiYDuG7DWp/LT1tCJdNkQFcY+b0/6V/6VFra2tsHNgwZYVOdfLtlQZse6UB/////xvB9AiCV8QP9cbZsGVQ6bcS6ri+i3yIufzfHd1iSS3abyz8/xXzfNOMZUzU+1hhsk3OLDp5vKPi///b/zC71EGl30rXldhhxNGk+/TW02rpaUP82W40Roj/////Z63QuGDacy0EROUdAzNfTAqqyXwN3TxxBVCqQQInEBD/v/T/C76GIAzJJbVoV7OFrAnUZrmf5GHODvneXpj/////ydkpIpjQsLSo18cXPbNZgQ20LjtcvbetbLrAIIO47bb/////s7+aDOK2A5rSsXQ5R9Xqr3fSnRUm2wSDFtxzEgtj44T/////O2SUPmptDahaanoLzw7knf8JkyeuAAqxngd9RJMP8NL8G///owiHaPIBHv7CBmldV2L3y26AcTZsGecGL/D/b9d2G9T+4CvTiVp62hDMSt1937n5//////nvvo5DvrcX1Y6wYOij1tZ+k9GhxMLYOFLy30/xZ7vR/////2dXvKbdBrU/SzaySNorDdhMGwqv9koDNmB6BEHD72Df/////1XfZ6jv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\";\n"
  },
  {
    "language": "Rust",
    "code": "//https://github.com/rust-lang-ja/ac-library-rs\n\npub struct Csr<E> {\n    start: Vec<usize>,\n    elist: Vec<E>,\n}\n\nimpl<E> Csr<E>\nwhere\n    E: Copy,\n{\n    pub fn new(n: usize, edges: &[(usize, E)], init: E) -> Self {\n        let mut csr = Csr {\n            start: vec![0; n + 1],\n            elist: vec![init; edges.len()],\n        };\n        for e in edges.iter() {\n            csr.start[e.0 + 1] += 1;\n        }\n        for i in 1..=n {\n            csr.start[i] += csr.start[i - 1];\n        }\n        let mut counter = csr.start.clone();\n        for e in edges.iter() {\n            csr.elist[counter[e.0]] = e.1;\n            counter[e.0] += 1;\n        }\n        csr\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct _Edge {\n    to: usize,\n}\n\n/// Reference:\n/// R. Tarjan,\n/// Depth-First Search and Linear Graph Algorithms\npub struct SccGraph {\n    n: usize,\n    edges: Vec<(usize, _Edge)>,\n}\n\nimpl SccGraph {\n    pub fn new(n: usize) -> Self {\n        SccGraph { n, edges: vec![] }\n    }\n\n    pub fn num_vertices(&self) -> usize {\n        self.n\n    }\n\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.edges.push((from, _Edge { to }));\n    }\n\n    /// return pair of (# of scc, scc id)\n    pub fn scc_ids(&self) -> (usize, Vec<usize>) {\n        // In C++ ac-library, this function is implemented by using recursive lambda functions.\n        // Instead, we use fn and struct for capturing environments.\n        struct _Env {\n            g: Csr<_Edge>,\n            now_ord: usize,\n            group_num: usize,\n            visited: Vec<usize>,\n            low: Vec<usize>,\n            ord: Vec<Option<usize>>,\n            ids: Vec<usize>,\n        }\n        let mut env = _Env {\n            g: Csr::new(self.n, &self.edges, _Edge { to: 0 }),\n            now_ord: 0,\n            group_num: 0,\n            visited: Vec::with_capacity(self.n),\n            low: vec![0; self.n],\n            ord: vec![None; self.n],\n            ids: vec![0; self.n],\n        };\n\n        fn dfs(v: usize, n: usize, env: &mut _Env) {\n            env.low[v] = env.now_ord;\n            env.ord[v] = Some(env.now_ord);\n            env.now_ord += 1;\n            env.visited.push(v);\n\n            for i in env.g.start[v]..env.g.start[v + 1] {\n                let to = env.g.elist[i].to;\n                if let Some(x) = env.ord[to] {\n                    env.low[v] = std::cmp::min(env.low[v], x);\n                } else {\n                    dfs(to, n, env);\n                    env.low[v] = std::cmp::min(env.low[v], env.low[to]);\n                }\n            }\n            if env.low[v] == env.ord[v].unwrap() {\n                loop {\n                    let u = *env.visited.last().unwrap();\n                    env.visited.pop();\n                    env.ord[u] = Some(n);\n                    env.ids[u] = env.group_num;\n                    if u == v {\n                        break;\n                    }\n                }\n                env.group_num += 1;\n            }\n        }\n        for i in 0..self.n {\n            if env.ord[i].is_none() {\n                dfs(i, self.n, &mut env);\n            }\n        }\n        for x in env.ids.iter_mut() {\n            *x = env.group_num - 1 - *x;\n        }\n        (env.group_num, env.ids)\n    }\n\n    pub fn scc(&self) -> Vec<Vec<usize>> {\n        let ids = self.scc_ids();\n        let group_num = ids.0;\n        let mut counts = vec![0usize; group_num];\n        for &x in ids.1.iter() {\n            counts[x] += 1;\n        }\n        let mut groups: Vec<Vec<usize>> = (0..ids.0).map(|_| vec![]).collect();\n        for i in 0..group_num {\n            groups[i].reserve(counts[i]);\n        }\n        for i in 0..self.n {\n            groups[ids.1[i]].push(i);\n        }\n        groups\n    }\n}\n\npub struct TwoSAT {\n    n: usize,\n    scc: SccGraph,\n    answer: Vec<bool>,\n}\nimpl TwoSAT {\n    pub fn new(n: usize) -> Self {\n        TwoSAT {\n            n,\n            answer: vec![false; n],\n            scc: SccGraph::new(2 * n),\n        }\n    }\n    pub fn add_clause(&mut self, i: usize, f: bool, j: usize, g: bool) {\n        assert!(i < self.n && j < self.n);\n        self.scc\n            .add_edge(2 * i + if f { 0 } else { 1 }, 2 * j + if g { 1 } else { 0 });\n        self.scc\n            .add_edge(2 * j + if g { 0 } else { 1 }, 2 * i + if f { 1 } else { 0 });\n    }\n    pub fn satisfiable(&mut self) -> bool {\n        let id = self.scc.scc_ids().1;\n        for i in 0..self.n {\n            if id[2 * i] == id[2 * i + 1] {\n                return false;\n            }\n            self.answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        true\n    }\n    pub fn answer(&self) -> &Vec<bool> {\n        &self.answer\n    }\n}\n\n#[allow(unused_imports)]\nuse proconio::{\n    fastout, input,\n    marker::{Bytes, Chars, Isize1, Usize1},\n};\n\nfn main() {\n    input! {\n        n:usize,d:isize,\n    }\n    let mut x = vec![];\n    let mut y = vec![];\n    for _ in 0..n {\n        input! {\n            a:isize,b:isize,\n        }\n        x.push(a);\n        y.push(b);\n    }\n\n    let mut t = TwoSAT::new(n);\n\n    for i in 0..n {\n        for j in i + 1..n {\n            if (x[i] - x[j]).abs() < d {\n                t.add_clause(i, false, j, false);\n            }\n            if (x[i] - y[j]).abs() < d {\n                t.add_clause(i, false, j, true);\n            }\n            if (y[i] - x[j]).abs() < d {\n                t.add_clause(i, true, j, false);\n            }\n            if (y[i] - y[j]).abs() < d {\n                t.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if !t.satisfiable() {\n        println!(\"No\");\n        return;\n    }\n    println!(\"Yes\");\n    let answer = t.answer();\n    for (i, &v) in answer.iter().enumerate() {\n        if v {\n            println!(\"{}\", x[i]);\n        } else {\n            println!(\"{}\", y[i]);\n        }\n    }\n}\n"
  }
]