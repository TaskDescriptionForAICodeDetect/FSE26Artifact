[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\nint N, D;\nint X[MAX_N], Y[MAX_N];\nint result[MAX_N];\n\nbool check_distance(int pos[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(pos[i] - pos[j]) < D) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool solve(int index, int pos[]) {\n    if (index == N) {\n        return true;\n    }\n\n    pos[index] = X[index];\n    if (check_distance(pos, index + 1) && solve(index + 1, pos)) {\n        result[index] = X[index];\n        return true;\n    }\n\n    pos[index] = Y[index];\n    if (check_distance(pos, index + 1) && solve(index + 1, pos)) {\n        result[index] = Y[index];\n        return true;\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &D);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n\n    int pos[MAX_N];\n    if (solve(0, pos)) {\n        printf(\"YES\\n\");\n        for (int i = 0; i < N; i++) {\n            printf(\"%d \", result[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N, D;\nint X[100], Y[100];\nint pos[100];\n\nint backtrack(int idx) {\n    if (idx == N) {\n        return 1;\n    }\n    \n    // Try placing at X[idx]\n    pos[idx] = X[idx];\n    int valid = 1;\n    for (int i = 0; i < idx; i++) {\n        if (abs(pos[idx] - pos[i]) < D) {\n            valid = 0;\n            break;\n        }\n    }\n    if (valid && backtrack(idx + 1)) {\n        return 1;\n    }\n    \n    // Try placing at Y[idx]\n    pos[idx] = Y[idx];\n    valid = 1;\n    for (int i = 0; i < idx; i++) {\n        if (abs(pos[idx] - pos[i]) < D) {\n            valid = 0;\n            break;\n        }\n    }\n    if (valid && backtrack(idx + 1)) {\n        return 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &D);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n    \n    if (backtrack(0)) {\n        for (int i = 0; i < N; i++) {\n            printf(\"%d \", pos[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool backtrack(int index, vector<int>& positions, const vector<int>& X, const vector<int>& Y, int D) {\n    if (index == X.size()) {\n        return true;\n    }\n    \n    int prev_pos = (index == 0) ? -D : positions[index - 1];\n    \n    if (abs(X[index] - prev_pos) >= D) {\n        positions[index] = X[index];\n        if (backtrack(index + 1, positions, X, Y, D)) {\n            return true;\n        }\n    }\n    \n    if (abs(Y[index] - prev_pos) >= D) {\n        positions[index] = Y[index];\n        if (backtrack(index + 1, positions, X, Y, D)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i] >> Y[i];\n    }\n    \n    vector<int> positions(N);\n    if (backtrack(0, positions, X, Y, D)) {\n        cout << \"Yes\" << endl;\n        for (int pos : positions) {\n            cout << pos << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FlagPlacement {\n    static int N, D;\n    static int[] X, Y;\n    static int[] solution;\n    static boolean found = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        D = scanner.nextInt();\n        X = new int[N + 1];\n        Y = new int[N + 1];\n        solution = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            X[i] = scanner.nextInt();\n            Y[i] = scanner.nextInt();\n        }\n\n        backtrack(1);\n        if (found) {\n            for (int i = 1; i <= N; i++) {\n                System.out.println(solution[i]);\n            }\n        } else {\n            System.out.println(\"-1\");\n        }\n    }\n\n    static void backtrack(int flag) {\n        if (found) return;\n        if (flag > N) {\n            found = true;\n            return;\n        }\n\n        // Try placing flag at X[flag]\n        solution[flag] = X[flag];\n        if (isValid(flag)) {\n            backtrack(flag + 1);\n            if (found) return;\n        }\n\n        // Try placing flag at Y[flag]\n        solution[flag] = Y[flag];\n        if (isValid(flag)) {\n            backtrack(flag + 1);\n            if (found) return;\n        }\n    }\n\n    static boolean isValid(int flag) {\n        for (int i = 1; i < flag; i++) {\n            if (Math.abs(solution[i] - solution[flag]) < D) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 22:25:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FlagPlacement {\n    public static void solve(int N, int[] X, int[] Y, int D) {\n        List<Integer> result = new ArrayList<>();\n        boolean[] used = new boolean[N];\n\n        for (int i = 0; i < N; i++) {\n            if (canPlace(result, X[i], D) && !used[i]) {\n                result.add(X[i]);\n                used[i] = true;\n            } else if (canPlace(result, Y[i], D) && !used[i]) {\n                result.add(Y[i]);\n                used[i] = true;\n            } else {\n                System.out.println(\"impossible\");\n                return;\n            }\n        }\n\n        System.out.println(\"possible\");\n        for (int pos : result) {\n            System.out.print(pos + \" \");\n        }\n    }\n\n    private static boolean canPlace(List<Integer> placed, int newPos, int D) {\n        for (int pos : placed) {\n            if (Math.abs(pos - newPos) < D) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] X = new int[N];\n        int[] Y = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            X[i] = scanner.nextInt();\n            Y[i] = scanner.nextInt();\n        }\n        \n        int D = scanner.nextInt();\n        \n        solve(N, X, Y, D);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:25:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canPlaceFlags(int N, vector<int>& X, vector<int>& Y, int D) {\n    vector<pair<int, int>> positions;\n    for (int i = 0; i < N; i++) {\n        positions.push_back({X[i], i});\n        positions.push_back({Y[i], i});\n    }\n    \n    sort(positions.begin(), positions.end());\n    \n    vector<bool> used(N, false);\n    vector<int> result;\n    \n    for (auto& pos : positions) {\n        int coordinate = pos.first;\n        int flag = pos.second;\n        \n        if (used[flag]) continue;\n        \n        if (result.empty() || coordinate - result.back() >= D) {\n            result.push_back(coordinate);\n            used[flag] = true;\n        }\n    }\n    \n    return result.size() == N;\n}\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    \n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n    }\n    \n    if (canPlaceFlags(N, X, Y, D)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def place_flags(N, D, coordinates):\n    coordinates = [(X_i, Y_i) for X_i, Y_i in coordinates]\n    flags = sorted(coordinates, key=lambda c: (c[0], c[1]))\n    \n    placed_flags = []\n    last_position = -float('inf')\n\n    for i, flag in enumerate(flags):\n        if flag[0] - last_position >= D:\n            placed_flags.append((i + 1, flag[0]))\n            last_position = flag[0]\n        elif flag[1] - last_position >= D:\n            placed_flags.append((i + 1, flag[1]))\n            last_position = flag[1]\n        else:\n            return \"Impossible\"\n\n    return placed_flags\n\n\n# Example usage\nN = 4\nD = 2\ncoordinates = [(1, 3), (2, 5), (5, 8), (6, 9)]\nresult = place_flags(N, D, coordinates)\n\nif result == \"Impossible\":\n    print(result)\nelse:\n    for flag_number, position in result:\n        print(f\"Flag {flag_number} placed at {position}\")",
    "timestamp": "2025-08-13 10:33:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FlagPlacement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int D = scanner.nextInt();\n        \n        int[][] coordinates = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            coordinates[i][0] = scanner.nextInt();\n            coordinates[i][1] = scanner.nextInt();\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(Math.min(coordinates[0][0], coordinates[0][1]));\n        \n        for (int i = 1; i < N; i++) {\n            int lastPlaced = result.get(result.size() - 1);\n            int option1 = coordinates[i][0];\n            int option2 = coordinates[i][1];\n            \n            if (Math.abs(option1 - lastPlaced) >= D) {\n                result.add(option1);\n            } else if (Math.abs(option2 - lastPlaced) >= D) {\n                result.add(option2);\n            } else {\n                System.out.println(\"Not possible\");\n                return;\n            }\n        }\n        \n        for (int coord : result) {\n            System.out.print(coord + \" \");\n        }\n    }\n}",
    "timestamp": "2025-08-13 10:34:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int index;\n    int pos1;\n    int pos2;\n} Flag;\n\nint compare(const void *a, const void *b) {\n    return ((Flag*)a)->pos1 - ((Flag*)b)->pos1;\n}\n\nint compareByIndex(const void *a, const void *b) {\n    return ((Flag*)a)->index - ((Flag*)b)->index;\n}\n\nint isValidPlacement(int *placed, int pos, int N, int D) {\n    for (int i = 0; i < N; i++) {\n        if (placed[i] != -1 && abs(placed[i] - pos) < D)\n            return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    Flag flags[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &flags[i].pos1, &flags[i].pos2);\n        flags[i].index = i;\n    }\n\n    qsort(flags, N, sizeof(Flag), compare);\n\n    int placed[N];\n    for (int i = 0; i < N; i++) placed[i] = -1;\n\n    for (int i = 0; i < N; i++) {\n        if (isValidPlacement(placed, flags[i].pos1, N, D)) {\n            placed[flags[i].index] = flags[i].pos1;\n        } else if (isValidPlacement(placed, flags[i].pos2, N, D)) {\n            placed[flags[i].index] = flags[i].pos2;\n        } else {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", placed[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:34:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_place_flags(N, X, Y, D):\n    def is_valid_placement(placement):\n        for i in range(len(placement) - 1):\n            if abs(placement[i] - placement[i+1]) < D:\n                return False\n        return True\n\n    def backtrack(current_placement, remaining_flags):\n        if not remaining_flags:\n            return current_placement\n\n        for flag in remaining_flags:\n            if not current_placement or abs(current_placement[-1] - X[flag]) >= D or abs(current_placement[-1] - Y[flag]) >= D:\n                new_placement = current_placement + [X[flag]]\n                if is_valid_placement(new_placement):\n                    result = backtrack(new_placement, [f for f in remaining_flags if f != flag])\n                    if result:\n                        return result\n\n                new_placement = current_placement + [Y[flag]]\n                if is_valid_placement(new_placement):\n                    result = backtrack(new_placement, [f for f in remaining_flags if f != flag])\n                    if result:\n                        return result\n\n        return None\n\n    placement = backtrack([], list(range(N)))\n    return placement\n\ndef main():\n    N, D = map(int, input().split())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n\n    result = can_place_flags(N, X, Y, D)\n    \n    if result:\n        print(\"YES\")\n        print(*result)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:34:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    N, D = map(int, sys.stdin.readline().split())\n    X = []\n    Y = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        X.append(x)\n        Y.append(y)\n    \n    # Build the implication graph (2-SAT)\n    size = 2 * N\n    adj = [[] for _ in range(2*size)]\n    \n    def get_node(i, is_x):\n        # flag i's X_i is 2*i, Y_i is 2*i + 1\n        return 2*i + (0 if is_x else 1)\n    \n    # Add clause: (a -> b)\n    def add_implication(a, b):\n        adj[a].append(b)\n        adj[b^1].append(a^1)  # contrapositive\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            xi, yi = X[i], Y[i]\n            xj, yj = X[j], Y[j]\n            # Check all 4 combinations\n            if abs(xi - xj) < D:\n                # can't choose both xi and xj\n                add_implication(get_node(i, True), get_node(j, False))\n                add_implication(get_node(j, True), get_node(i, False))\n            if abs(xi - yj) < D:\n                add_implication(get_node(i, True), get_node(j, True))\n                add_implication(get_node(j, False), get_node(i, False))\n            if abs(yi - xj) < D:\n                add_implication(get_node(i, False), get_node(j, False))\n                add_implication(get_node(j, True), get_node(i, True))\n            if abs(yi - yj) < D:\n                add_implication(get_node(i, False), get_node(j, True))\n                add_implication(get_node(j, False), get_node(i, True))\n    \n    # Kosaraju's algorithm for SCC\n    order = []\n    visited = [False] * (2*size)\n    \n    def dfs(u):\n        stack = [(u, False)]\n        while stack:\n            node, processed = stack.pop()\n            if processed:\n                order.append(node)\n                continue\n            if visited[node]:\n                continue\n            visited[node] = True\n            stack.append((node, True))\n            for v in adj[node]:\n                if not visited[v]:\n                    stack.append((v, False))\n    \n    for i in range(2*size):\n        if not visited[i]:\n            dfs(i)\n    \n    # Reverse graph\n    adj_rev = [[] for _ in range(2*size)]\n    for u in range(2*size):\n        for v in adj[u]:\n            adj_rev[v].append(u)\n    \n    component = [0] * (2*size)\n    current_component = 0\n    visited = [False] * (2*size)\n    \n    for node in reversed(order):\n        if not visited[node]:\n            stack = [node]\n            visited[node] = True\n            current_component += 1\n            while stack:\n                u = stack.pop()\n                component[u] = current_component\n                for v in adj_rev[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n    \n    # Check for contradiction\n    possible = True\n    assignment = [False] * N\n    for i in range(N):\n        x_node = get_node(i, True)\n        y_node = get_node(i, False)\n        if component[x_node] == component[y_node]:\n            possible = False\n            break\n        # x_node and y_node must be in different components\n        # if x_node's component is after y_node's, choose x (False means not choosing)\n        assignment[i] = component[x_node] > component[y_node]\n    \n    if not possible:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        for i in range(N):\n            if assignment[i]:\n                print(X[i])\n            else:\n                print(Y[i])\n\nsolve()",
    "timestamp": "2025-08-13 10:34:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canPlaceFlags(vector<pair<int, int>>& positions, vector<int>& result, int N, int D) {\n    sort(positions.begin(), positions.end());\n    int last_position = positions[0].first;\n    result[0] = last_position;\n    \n    for (int i = 1; i < N; ++i) {\n        if (positions[i].first - last_position >= D) {\n            last_position = positions[i].first;\n            result[i] = positions[i].first;\n        } else if (positions[i].second - last_position >= D) {\n            last_position = positions[i].second;\n            result[i] = positions[i].second;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    \n    vector<pair<int, int>> positions(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> positions[i].first >> positions[i].second;\n    }\n    \n    vector<int> result(N);\n    if (canPlaceFlags(positions, result, N, D)) {\n        for (int i = 0; i < N; ++i) {\n            cout << result[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"No solution\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:59:44"
  }
]