[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PARTICIPANTS 1001\n#define MAX_LANGUAGES 1001\n\nint parent[MAX_PARTICIPANTS];\nbool participant_languages[MAX_PARTICIPANTS][MAX_LANGUAGES];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px != py) {\n        parent[px] = py;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        int k;\n        scanf(\"%d\", &k);\n        \n        for (int j = 0; j < k; j++) {\n            int lang;\n            scanf(\"%d\", &lang);\n            participant_languages[i][lang] = true;\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            for (int lang = 1; lang <= M; lang++) {\n                if (participant_languages[i][lang] && participant_languages[j][lang]) {\n                    unionSet(i, j);\n                    break;\n                }\n            }\n        }\n    }\n\n    int root = find(1);\n    bool communicable = true;\n\n    for (int i = 2; i <= N; i++) {\n        if (find(i) != root) {\n            communicable = false;\n            break;\n        }\n    }\n\n    printf(\"%s\\n\", communicable ? \"YES\" : \"NO\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_M 100000\n#define MAX_N 100000\n\nint parent[MAX_M + 1];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_set(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootY] = rootX;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= M; i++) {\n        parent[i] = i;\n    }\n\n    int first_lang = -1;\n    for (int i = 0; i < N; i++) {\n        int K;\n        scanf(\"%d\", &K);\n        int lang;\n        scanf(\"%d\", &lang);\n        if (first_lang == -1) {\n            first_lang = lang;\n        }\n        for (int j = 1; j < K; j++) {\n            int next_lang;\n            scanf(\"%d\", &next_lang);\n            union_set(lang, next_lang);\n        }\n    }\n\n    int root = find(first_lang);\n    int possible = 1;\n    for (int i = 0; i < N; i++) {\n        int K;\n        scanf(\"%d\", &K);\n        int lang;\n        scanf(\"%d\", &lang);\n        if (find(lang) != root) {\n            possible = 0;\n            break;\n        }\n        for (int j = 1; j < K; j++) {\n            int next_lang;\n            scanf(\"%d\", &next_lang);\n            if (find(next_lang) != root) {\n                possible = 0;\n                break;\n            }\n        }\n        if (!possible) {\n            break;\n        }\n    }\n\n    printf(possible ? \"YES\\n\" : \"NO\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent;\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        for (int i = 0; i < size; ++i) {\n            parent[i] = i;\n        }\n    }\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<unordered_set<int>> participants(N);\n    vector<vector<int>> langToPeople(M + 1);\n\n    for (int i = 0; i < N; ++i) {\n        int K;\n        cin >> K;\n        for (int j = 0; j < K; ++j) {\n            int L;\n            cin >> L;\n            participants[i].insert(L);\n            langToPeople[L].push_back(i);\n        }\n    }\n\n    UnionFind uf(N);\n    for (int lang = 1; lang <= M; ++lang) {\n        if (langToPeople[lang].size() > 1) {\n            int first = langToPeople[lang][0];\n            for (size_t i = 1; i < langToPeople[lang].size(); ++i) {\n                uf.unite(first, langToPeople[lang][i]);\n            }\n        }\n    }\n\n    bool allConnected = true;\n    int root = uf.find(0);\n    for (int i = 1; i < N; ++i) {\n        if (uf.find(i) != root) {\n            allConnected = false;\n            break;\n        }\n    }\n\n    cout << (allConnected ? \"YES\" : \"NO\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<Set<Integer>> participants = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int K = scanner.nextInt();\n            Set<Integer> languages = new HashSet<>();\n            for (int j = 0; j < K; j++) {\n                languages.add(scanner.nextInt());\n            }\n            participants.add(languages);\n        }\n        \n        UnionFind uf = new UnionFind(N);\n        Map<Integer, Integer> languageToFirstParticipant = new HashMap<>();\n        \n        for (int i = 0; i < N; i++) {\n            Set<Integer> languages = participants.get(i);\n            for (int lang : languages) {\n                if (languageToFirstParticipant.containsKey(lang)) {\n                    uf.union(i, languageToFirstParticipant.get(lang));\n                } else {\n                    languageToFirstParticipant.put(lang, i);\n                }\n            }\n        }\n        \n        boolean allConnected = true;\n        int root = uf.find(0);\n        for (int i = 1; i < N; i++) {\n            if (uf.find(i) != root) {\n                allConnected = false;\n                break;\n            }\n        }\n        \n        System.out.println(allConnected ? \"YES\" : \"NO\");\n    }\n    \n    static class UnionFind {\n        private int[] parent;\n        \n        public UnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                parent[rootX] = rootY;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:31:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CodeFestival {\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt(); // Number of participants\n        int M = sc.nextInt(); // Number of languages\n        \n        parent = new int[N + 1];\n        rank = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n        }\n        \n        List<List<Integer>> languageMap = new ArrayList<>();\n        for (int i = 0; i <= M; i++) {\n            languageMap.add(new ArrayList<>());\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            int K = sc.nextInt(); // Number of languages participant speaks\n            for (int j = 0; j < K; j++) {\n                int language = sc.nextInt();\n                languageMap.get(language).add(i);\n            }\n        }\n        \n        for (int language = 1; language <= M; language++) {\n            List<Integer> speakers = languageMap.get(language);\n            for (int k = 1; k < speakers.size(); k++) {\n                union(speakers.get(0), speakers.get(k));\n            }\n        }\n        \n        boolean connected = true;\n        int root = find(1);\n        for (int i = 2; i <= N; i++) {\n            if (find(i) != root) {\n                connected = false;\n                break;\n            }\n        }\n        \n        System.out.println(connected ? \"YES\" : \"NO\");\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 23:31:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) \n            parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) \n            swap(rootX, rootY);\n        \n        parent[rootY] = rootX;\n        \n        if (rank[rootX] == rank[rootY])\n            rank[rootX]++;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    UnionFind uf(N);\n    vector<vector<int>> languageUsers(M + 1);\n    \n    for (int i = 0; i < N; i++) {\n        int K;\n        cin >> K;\n        \n        for (int j = 0; j < K; j++) {\n            int lang;\n            cin >> lang;\n            languageUsers[lang].push_back(i);\n        }\n    }\n    \n    for (int lang = 1; lang <= M; lang++) {\n        for (int i = 1; i < languageUsers[lang].size(); i++) {\n            uf.unionSet(languageUsers[lang][0], languageUsers[lang][i]);\n        }\n    }\n    \n    bool connected = true;\n    int root = uf.find(0);\n    \n    for (int i = 1; i < N; i++) {\n        if (uf.find(i) != root) {\n            connected = false;\n            break;\n        }\n    }\n    \n    cout << (connected ? \"YES\" : \"NO\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.parent[rootY] = rootX\n\ndef can_communicate(n, participant_languages):\n    uf = UnionFind(n)\n    language_groups = {}\n\n    for i, languages in enumerate(participant_languages):\n        for language in languages:\n            if language not in language_groups:\n                language_groups[language] = i\n            else:\n                uf.union(i, language_groups[language])\n    \n    root = uf.find(0)\n    for i in range(n):\n        if uf.find(i) != root:\n            return False\n    return True\n\n# Example usage:\nn = 3  # Number of participants\nparticipant_languages = [\n    [1, 2],  # Languages spoken by participant 1\n    [2, 3],  # Languages spoken by participant 2\n    [3, 4]   # Languages spoken by participant 3\n]\n\nprint(can_communicate(n, participant_languages))  # Output: True or False",
    "timestamp": "2025-08-13 15:41:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CodeFestivalCommunication {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt(); // number of participants\n        int M = sc.nextInt(); // number of languages\n        \n        List<Set<Integer>> languageGroups = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int numLanguages = sc.nextInt();\n            Set<Integer> languages = new HashSet<>();\n            for (int j = 0; j < numLanguages; j++) {\n                languages.add(sc.nextInt());\n            }\n            languageGroups.add(languages);\n        }\n\n        UnionFind uf = new UnionFind(N);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                Set<Integer> languagesA = languageGroups.get(i);\n                Set<Integer> languagesB = languageGroups.get(j);\n                Set<Integer> intersection = new HashSet<>(languagesA);\n                intersection.retainAll(languagesB);\n                if (!intersection.isEmpty()) {\n                    uf.union(i, j);\n                }\n            }\n        }\n\n        int root = uf.find(0);\n        boolean canCommunicate = true;\n        for (int i = 1; i < N; i++) {\n            if (uf.find(i) != root) {\n                canCommunicate = false;\n                break;\n            }\n        }\n        \n        System.out.println(canCommunicate ? \"YES\" : \"NO\");\n        sc.close();\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int a) {\n        if (parent[a] != a) {\n            parent[a] = find(parent[a]);\n        }\n        return parent[a];\n    }\n\n    public void union(int a, int b) {\n        int rootA = find(a);\n        int rootB = find(b);\n        if (rootA != rootB) {\n            parent[rootA] = rootB;\n        }\n    }\n}",
    "timestamp": "2025-08-13 15:41:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n#define MAX_M 1000\n\ntypedef struct {\n    int size;\n    int *languages;\n} Participant;\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v != parent[v])\n        parent[v] = find_set(parent[v]);\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            parent[a] = b;\n        else if (rank[a] > rank[b])\n            parent[b] = a;\n        else {\n            parent[b] = a;\n            rank[a]++;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Participant participants[MAX_N];\n    for (int i = 0; i < N; ++i) {\n        make_set(i);\n    }\n\n    int language_to_person[MAX_M][MAX_N];\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; j < N; ++j) {\n            language_to_person[i][j] = -1;\n        }\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        int K;\n        scanf(\"%d\", &K);\n        participants[i].size = K;\n        participants[i].languages = (int *)malloc(K * sizeof(int));\n        for (int j = 0; j < K; ++j) {\n            int language;\n            scanf(\"%d\", &language);\n            language--; // Language indexes start from 0\n            participants[i].languages[j] = language;\n            language_to_person[language][i] = i;\n        }\n    }\n\n    for (int l = 0; l < M; ++l) {\n        int first_person = -1;\n        for (int p = 0; p < N; ++p) {\n            if (language_to_person[l][p] != -1) {\n                if (first_person == -1) {\n                    first_person = language_to_person[l][p];\n                } else {\n                    union_sets(first_person, language_to_person[l][p]);\n                }\n            }\n        }\n    }\n\n    int connected_component = find_set(0);\n    int all_connected = 1;\n    for (int i = 1; i < N; ++i) {\n        if (find_set(i) != connected_component) {\n            all_connected = 0;\n            break;\n        }\n    }\n\n    if (all_connected) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    for (int i = 0; i < N; ++i) {\n        free(participants[i].languages);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:41:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    UnionFind(int n) : parent(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n    \n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<unordered_set<int>> language(M + 1);\n    UnionFind uf(N);\n    \n    for (int i = 0; i < N; ++i) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; ++j) {\n            int lang;\n            cin >> lang;\n            language[lang].insert(i);\n        }\n    }\n    \n    for (int lang = 1; lang <= M; ++lang) {\n        if (!language[lang].empty()) {\n            int first = *language[lang].begin();\n            for (auto it = language[lang].begin(); it != language[lang].end(); ++it) {\n                uf.unite(first, *it);\n            }\n        }\n    }\n    \n    for (int i = 1; i < N; ++i) {\n        if (!uf.connected(0, i)) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Yes\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:41:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_parent(parent, x):\n    if parent[x] != x:\n        parent[x] = find_parent(parent, parent[x])\n    return parent[x]\n\ndef union(parent, x, y):\n    root_x = find_parent(parent, x)\n    root_y = find_parent(parent, y)\n    if root_x != root_y:\n        parent[root_x] = root_y\n\ndef can_communicate(N, M, languages):\n    parent = list(range(N))\n    \n    for lang in range(1, M + 1):\n        speakers = [i for i in range(N) if lang in languages[i]]\n        \n        for i in range(1, len(speakers)):\n            union(parent, speakers[0], speakers[i])\n    \n    root = find_parent(parent, 0)\n    return all(find_parent(parent, i) == root for i in range(N))\n\n# Input handling\nN, M = map(int, input().split())\nlanguages = []\nfor _ in range(N):\n    k, *langs = map(int, input().split())\n    languages.append(langs)\n\n# Output result\nprint(\"YES\" if can_communicate(N, M, languages) else \"NO\")",
    "timestamp": "2025-08-13 15:41:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 1-based indexing\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            self.parent[y_root] = x_root\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, M = map(int, data[idx:idx+2])\n    idx += 2\n    \n    uf = UnionFind(M)\n    participants = []\n    \n    for _ in range(N):\n        langs = list(map(int, data[idx+1:idx+1+int(data[idx])]))\n        idx += 1 + int(data[idx])\n        participants.append(langs)\n        for lang in langs[1:]:\n            uf.union(langs[0], lang)\n    \n    if not participants:\n        print(\"YES\")\n        return\n    \n    root = uf.find(participants[0][0])\n    for p in participants:\n        if not p:\n            print(\"NO\")\n            return\n        if uf.find(p[0]) != root:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n\nsolve()",
    "timestamp": "2025-08-13 15:41:53"
  }
]