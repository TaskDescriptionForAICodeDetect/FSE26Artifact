[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid update(long long *tree, long long *lazy, int node, int start, int end, int l, int r, long long val) {\n    if (lazy[node] != 0) {\n        tree[node] += (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[node*2] += lazy[node];\n            lazy[node*2+1] += lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    \n    if (start > end || start > r || end < l)\n        return;\n    \n    if (l <= start && end <= r) {\n        tree[node] += (end - start + 1) * val;\n        if (start != end) {\n            lazy[node*2] += val;\n            lazy[node*2+1] += val;\n        }\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    update(tree, lazy, node*2, start, mid, l, r, val);\n    update(tree, lazy, node*2+1, mid+1, end, l, r, val);\n    \n    tree[node] = tree[node*2] + tree[node*2+1];\n}\n\nlong long query(long long *tree, long long *lazy, int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l)\n        return 0;\n    \n    if (lazy[node] != 0) {\n        tree[node] += (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[node*2] += lazy[node];\n            lazy[node*2+1] += lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    \n    if (l <= start && end <= r)\n        return tree[node];\n    \n    int mid = (start + end) / 2;\n    long long p1 = query(tree, lazy, node*2, start, mid, l, r);\n    long long p2 = query(tree, lazy, node*2+1, mid+1, end, l, r);\n    \n    return p1 + p2;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    int size = 4 * n;\n    long long *tree = calloc(size, sizeof(long long));\n    long long *lazy = calloc(size, sizeof(long long));\n    \n    while (q--) {\n        int type, s, t, x;\n        scanf(\"%d\", &type);\n        \n        if (type == 0) {\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update(tree, lazy, 1, 0, n-1, s-1, t-1, x);\n        } else {\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%lld\\n\", query(tree, lazy, 1, 0, n-1, s-1, t-1));\n        }\n    }\n    \n    free(tree);\n    free(lazy);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int sum;\n    int lazy;\n    int is_lazy;\n} SegmentTreeNode;\n\nSegmentTreeNode* tree;\nint size;\n\nvoid build(int n) {\n    size = 1;\n    while (size < n) size <<= 1;\n    tree = (SegmentTreeNode*)calloc(2 * size, sizeof(SegmentTreeNode));\n}\n\nvoid push(int node, int node_left, int node_right) {\n    if (tree[node].is_lazy) {\n        int mid = (node_left + node_right) / 2;\n        tree[2 * node].sum = tree[node].lazy * (mid - node_left + 1);\n        tree[2 * node].lazy = tree[node].lazy;\n        tree[2 * node].is_lazy = 1;\n        \n        tree[2 * node + 1].sum = tree[node].lazy * (node_right - mid);\n        tree[2 * node + 1].lazy = tree[node].lazy;\n        tree[2 * node + 1].is_lazy = 1;\n        \n        tree[node].is_lazy = 0;\n    }\n}\n\nvoid update_range(int s, int t, int x, int node, int node_left, int node_right) {\n    if (t < node_left || s > node_right) return;\n    if (s <= node_left && node_right <= t) {\n        tree[node].sum = x * (node_right - node_left + 1);\n        tree[node].lazy = x;\n        tree[node].is_lazy = 1;\n        return;\n    }\n    push(node, node_left, node_right);\n    int mid = (node_left + node_right) / 2;\n    update_range(s, t, x, 2 * node, node_left, mid);\n    update_range(s, t, x, 2 * node + 1, mid + 1, node_right);\n    tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n}\n\nint query_sum(int s, int t, int node, int node_left, int node_right) {\n    if (t < node_left || s > node_right) return 0;\n    if (s <= node_left && node_right <= t) return tree[node].sum;\n    push(node, node_left, node_right);\n    int mid = (node_left + node_right) / 2;\n    return query_sum(s, t, 2 * node, node_left, mid) + \n           query_sum(s, t, 2 * node + 1, mid + 1, node_right);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    build(n);\n    \n    while (q--) {\n        int cmd, s, t, x;\n        scanf(\"%d\", &cmd);\n        if (cmd == 0) {\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update_range(s, t, x, 1, 0, size - 1);\n        } else {\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%d\\n\", query_sum(s, t, 1, 0, size - 1));\n        }\n    }\n    \n    free(tree);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass LazySegmentTree {\nprivate:\n    int n;\n    vector<int> tree;\n    vector<int> lazy;\n    vector<bool> hasLazy;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = 0;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    void push(int node, int start, int end) {\n        if (hasLazy[node]) {\n            tree[node] = lazy[node] * (end - start + 1);\n            if (start != end) {\n                lazy[2 * node + 1] = lazy[node];\n                lazy[2 * node + 2] = lazy[node];\n                hasLazy[2 * node + 1] = true;\n                hasLazy[2 * node + 2] = true;\n            }\n            hasLazy[node] = false;\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r, int val) {\n        push(node, start, end);\n        if (start > r || end < l) return;\n        if (start >= l && end <= r) {\n            lazy[node] = val;\n            hasLazy[node] = true;\n            push(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateRange(2 * node + 1, start, mid, l, r, val);\n        updateRange(2 * node + 2, mid + 1, end, l, r, val);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    int queryRange(int node, int start, int end, int l, int r) {\n        push(node, start, end);\n        if (start > r || end < l) return 0;\n        if (start >= l && end <= r) return tree[node];\n        int mid = (start + end) / 2;\n        int left = queryRange(2 * node + 1, start, mid, l, r);\n        int right = queryRange(2 * node + 2, mid + 1, end, l, r);\n        return left + right;\n    }\n\npublic:\n    LazySegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n);\n        lazy.resize(4 * n);\n        hasLazy.assign(4 * n, false);\n        build(0, 0, n - 1);\n    }\n\n    void update(int s, int t, int x) {\n        updateRange(0, 0, n - 1, s, t, x);\n    }\n\n    int getSum(int s, int t) {\n        return queryRange(0, 0, n - 1, s, t);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree st(n);\n\n    while (q--) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(s, t, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << st.getSum(s, t) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n    static class SegmentTree {\n        int size;\n        long[] sum;\n        long[] lazy;\n\n        SegmentTree(int n) {\n            size = 1;\n            while (size < n) size *= 2;\n            sum = new long[2 * size - 1];\n            lazy = new long[2 * size - 1];\n        }\n\n        void push(int k, int l, int r) {\n            if (lazy[k] != 0) {\n                sum[k] = lazy[k] * (r - l);\n                if (r - l > 1) {\n                    lazy[2 * k + 1] = lazy[k];\n                    lazy[2 * k + 2] = lazy[k];\n                }\n                lazy[k] = 0;\n            }\n        }\n\n        void update(int a, int b, long x, int k, int l, int r) {\n            push(k, l, r);\n            if (b <= l || r <= a) return;\n            if (a <= l && r <= b) {\n                lazy[k] = x;\n                push(k, l, r);\n                return;\n            }\n            int mid = (l + r) / 2;\n            update(a, b, x, 2 * k + 1, l, mid);\n            update(a, b, x, 2 * k + 2, mid, r);\n            sum[k] = sum[2 * k + 1] + sum[2 * k + 2];\n        }\n\n        long getSum(int a, int b, int k, int l, int r) {\n            push(k, l, r);\n            if (b <= l || r <= a) return 0;\n            if (a <= l && r <= b) return sum[k];\n            int mid = (l + r) / 2;\n            return getSum(a, b, 2 * k + 1, l, mid) + getSum(a, b, 2 * k + 2, mid, r);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int q = Integer.parseInt(line[1]);\n\n        SegmentTree st = new SegmentTree(n);\n\n        for (int i = 0; i < q; i++) {\n            line = br.readLine().split(\" \");\n            int query = Integer.parseInt(line[0]);\n            if (query == 0) {\n                int s = Integer.parseInt(line[1]);\n                int t = Integer.parseInt(line[2]);\n                long x = Long.parseLong(line[3]);\n                st.update(s, t + 1, x, 0, 0, st.size);\n            } else {\n                int s = Integer.parseInt(line[1]);\n                int t = Integer.parseInt(line[2]);\n                System.out.println(st.getSum(s, t + 1, 0, 0, st.size));\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:21:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SequenceManipulation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int q = scanner.nextInt();\n        \n        long[] arr = new long[n];\n        long[] tree = new long[4*n];\n        \n        for (int i = 0; i < q; i++) {\n            int type = scanner.nextInt();\n            \n            if (type == 0) {\n                int s = scanner.nextInt() - 1;\n                int t = scanner.nextInt() - 1;\n                long x = scanner.nextLong();\n                updateRange(tree, 0, 0, n-1, s, t, x);\n            } else {\n                int s = scanner.nextInt() - 1;\n                int t = scanner.nextInt() - 1;\n                System.out.println(getSum(tree, 0, 0, n-1, s, t));\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    static void updateRange(long[] tree, int node, int start, int end, int l, int r, long val) {\n        if (start > end || start > r || end < l) return;\n        \n        if (start >= l && end <= r) {\n            tree[node] += val;\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        updateRange(tree, 2*node+1, start, mid, l, r, val);\n        updateRange(tree, 2*node+2, mid+1, end, l, r, val);\n    }\n    \n    static long getSum(long[] tree, int node, int start, int end, int l, int r) {\n        if (start > end || start > r || end < l) return 0;\n        \n        if (start >= l && end <= r) return tree[node];\n        \n        int mid = (start + end) / 2;\n        long leftSum = getSum(tree, 2*node+1, start, mid, l, r);\n        long rightSum = getSum(tree, 2*node+2, mid+1, end, l, r);\n        \n        return tree[node] + leftSum + rightSum;\n    }\n}",
    "timestamp": "2025-08-05 22:21:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<long long> tree, lazy;\n    int n;\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] = lazy[node] * (end - start + 1);\n            \n            if (start != end) {\n                lazy[node * 2] = lazy[node];\n                lazy[node * 2 + 1] = lazy[node];\n            }\n            \n            lazy[node] = 0;\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r, long long val) {\n        propagate(node, start, end);\n        \n        if (start > end || start > r || end < l) return;\n        \n        if (l <= start && end <= r) {\n            lazy[node] = val;\n            propagate(node, start, end);\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        updateRange(node * 2, start, mid, l, r, val);\n        updateRange(node * 2 + 1, mid + 1, end, l, r, val);\n        \n        tree[node] = tree[node * 2] + tree[node * 2 + 1];\n    }\n\n    long long querySum(int node, int start, int end, int l, int r) {\n        if (start > end || start > r || end < l) return 0;\n        \n        propagate(node, start, end);\n        \n        if (l <= start && end <= r) return tree[node];\n        \n        int mid = (start + end) / 2;\n        long long left = querySum(node * 2, start, mid, l, r);\n        long long right = querySum(node * 2 + 1, mid + 1, end, l, r);\n        \n        return left + right;\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n    }\n\n    void update(int l, int r, long long val) {\n        updateRange(1, 0, n - 1, l, r, val);\n    }\n\n    long long getSum(int l, int r) {\n        return querySum(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree st(n);\n\n    while (q--) {\n        int type, s, t;\n        cin >> type >> s >> t;\n\n        if (type == 0) {\n            long long x;\n            cin >> x;\n            st.update(s, t, x);\n        } else {\n            cout << st.getSum(s, t) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [None] * (4 * n)\n\n    def _propagate(self, index, l, r):\n        if self.lazy[index] is not None:\n            self.tree[index] = (r - l + 1) * self.lazy[index]\n            if l != r:\n                self.lazy[index * 2 + 1] = self.lazy[index]\n                self.lazy[index * 2 + 2] = self.lazy[index]\n            self.lazy[index] = None\n\n    def _update(self, index, l, r, ul, ur, value):\n        self._propagate(index, l, r)\n        if ul > r or ur < l:\n            return\n        if ul <= l and ur >= r:\n            self.lazy[index] = value\n            self._propagate(index, l, r)\n            return\n        mid = (l + r) // 2\n        self._update(index * 2 + 1, l, mid, ul, ur, value)\n        self._update(index * 2 + 2, mid + 1, r, ul, ur, value)\n        self.tree[index] = self.tree[index * 2 + 1] + self.tree[index * 2 + 2]\n\n    def update(self, ul, ur, value):\n        self._update(0, 0, self.n - 1, ul, ur, value)\n\n    def _query(self, index, l, r, ql, qr):\n        self._propagate(index, l, r)\n        if ql > r or qr < l:\n            return 0\n        if ql <= l and qr >= r:\n            return self.tree[index]\n        mid = (l + r) // 2\n        left_sum = self._query(index * 2 + 1, l, mid, ql, qr)\n        right_sum = self._query(index * 2 + 2, mid + 1, r, ql, qr)\n        return left_sum + right_sum\n\n    def query(self, ql, qr):\n        return self._query(0, 0, self.n - 1, ql, qr)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    segment_tree = SegmentTree(n)\n    result = []\n    index = 2\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        s = int(data[index + 1])\n        t = int(data[index + 2])\n        if query_type == 0:\n            x = int(data[index + 3])\n            segment_tree.update(s, t, x)\n            index += 4\n        else:\n            sum_result = segment_tree.query(s, t)\n            result.append(sum_result)\n            index += 3\n    \n    for res in result:\n        print(res)\n\nmain()",
    "timestamp": "2025-08-13 10:03:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SequenceManipulation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int q = scanner.nextInt();\n\n        long[] sequence = new long[n];\n        for (int i = 0; i < q; i++) {\n            int op = scanner.nextInt();\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            if (op == 0) {\n                long x = scanner.nextLong();\n                for (int j = s; j <= t; j++) {\n                    sequence[j] = x;\n                }\n            } else if (op == 1) {\n                long sum = 0;\n                for (int j = s; j <= t; j++) {\n                    sum += sequence[j];\n                }\n                System.out.println(sum);\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:03:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    int A[n];\n    memset(A, 0, sizeof(A));\n    \n    while (q--) {\n        int type, s, t, x;\n        scanf(\"%d %d %d\", &type, &s, &t);\n        \n        if (type == 0) {\n            // update operation\n            scanf(\"%d\", &x);\n            for (int i = s; i <= t; ++i) {\n                A[i] = x;\n            }\n        } else if (type == 1) {\n            // getSum operation\n            int sum = 0;\n            for (int i = s; i <= t; ++i) {\n                sum += A[i];\n            }\n            printf(\"%d\\n\", sum);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:03:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n\n    def update_tree(self, node, start, end, l, r, val):\n        if self.lazy[node] != 0:\n            self.tree[node] = (end - start + 1) * self.lazy[node]\n            if start != end:\n                self.lazy[node * 2 + 1] = self.lazy[node]\n                self.lazy[node * 2 + 2] = self.lazy[node]\n            self.lazy[node] = 0\n\n        if start > end or start > r or end < l:\n            return\n\n        if l <= start and end <= r:\n            self.tree[node] = (end - start + 1) * val\n            if start != end:\n                self.lazy[node * 2 + 1] = val\n                self.lazy[node * 2 + 2] = val\n            return\n\n        mid = (start + end) // 2\n        self.update_tree(node * 2 + 1, start, mid, l, r, val)\n        self.update_tree(node * 2 + 2, mid + 1, end, l, r, val)\n        self.tree[node] = self.tree[node * 2 + 1] + self.tree[node * 2 + 2]\n\n    def query_tree(self, node, start, end, l, r):\n        if start > end or start > r or end < l:\n            return 0\n\n        if self.lazy[node] != 0:\n            self.tree[node] = (end - start + 1) * self.lazy[node]\n            if start != end:\n                self.lazy[node * 2 + 1] = self.lazy[node]\n                self.lazy[node * 2 + 2] = self.lazy[node]\n            self.lazy[node] = 0\n\n        if l <= start and end <= r:\n            return self.tree[node]\n\n        mid = (start + end) // 2\n        left_sum = self.query_tree(node * 2 + 1, start, mid, l, r)\n        right_sum = self.query_tree(node * 2 + 2, mid + 1, end, l, r)\n        return left_sum + right_sum\n\ndef main():\n    n, q = map(int, input().split())\n    st = SegmentTree(n)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        \n        if query[0] == 0:\n            st.update_tree(0, 0, n-1, query[1], query[2], query[3])\n        else:\n            print(st.query_tree(0, 0, n-1, query[1], query[2]))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:03:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nclass SegmentTreeNode:\n    __slots__ = ['l', 'r', 'left', 'right', 'sum_val', 'lazy']\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.left = None\n        self.right = None\n        self.sum_val = 0\n        self.lazy = None\n    \n    def apply_lazy(self, val):\n        self.sum_val = val * (self.r - self.l + 1)\n        if self.l != self.r:\n            self.lazy = val\n    \n    def push_down(self):\n        if self.lazy is not None and self.left:\n            self.left.apply_lazy(self.lazy)\n            self.right.apply_lazy(self.lazy)\n            self.lazy = None\n\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.root = self.build(0, self.n - 1, data)\n    \n    def build(self, l, r, data):\n        node = SegmentTreeNode(l, r)\n        if l == r:\n            node.sum_val = data[l]\n        else:\n            mid = (l + r) // 2\n            node.left = self.build(l, mid, data)\n            node.right = self.build(mid + 1, r, data)\n            node.sum_val = node.left.sum_val + node.right.sum_val\n        return node\n    \n    def update_range(self, node, l, r, val):\n        if node.r < l or node.l > r:\n            return\n        if l <= node.l and node.r <= r:\n            node.apply_lazy(val)\n            return\n        node.push_down()\n        self.update_range(node.left, l, r, val)\n        self.update_range(node.right, l, r, val)\n        node.sum_val = node.left.sum_val + node.right.sum_val\n    \n    def query_range(self, node, l, r):\n        if node.r < l or node.l > r:\n            return 0\n        if l <= node.l and node.r <= r:\n            return node.sum_val\n        node.push_down()\n        return self.query_range(node.left, l, r) + self.query_range(node.right, l, r)\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    data = [0] * n\n    st = SegmentTree(data)\n    for _ in range(q):\n        cmd = input[ptr]\n        ptr += 1\n        if cmd == '0':\n            s = int(input[ptr])\n            ptr += 1\n            t = int(input[ptr])\n            ptr += 1\n            x = int(input[ptr])\n            ptr += 1\n            st.update_range(st.root, s, t, x)\n        elif cmd == '1':\n            s = int(input[ptr])\n            ptr += 1\n            t = int(input[ptr])\n            ptr += 1\n            res = st.query_range(st.root, s, t)\n            print(res)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:03:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass SegmentTree {\n    vector<int> tree;\n    vector<int> lazy;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = 0;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node, start, mid);\n            build(2 * node + 1, mid + 1, end);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r, int val) {\n        if (lazy[node] != 0) {\n            tree[node] = (end - start + 1) * lazy[node];\n            if (start != end) {\n                lazy[2 * node] = lazy[node];\n                lazy[2 * node + 1] = lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        if (start > end || start > r || end < l) return;\n\n        if (start >= l && end <= r) {\n            tree[node] = (end - start + 1) * val;\n            if (start != end) {\n                lazy[2 * node] = val;\n                lazy[2 * node + 1] = val;\n            }\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        updateRange(2 * node, start, mid, l, r, val);\n        updateRange(2 * node + 1, mid + 1, end, l, r, val);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n\n    int queryRange(int node, int start, int end, int l, int r) {\n        if (start > end || start > r || end < l) return 0;\n\n        if (lazy[node] != 0) {\n            tree[node] = (end - start + 1) * lazy[node];\n            if (start != end) {\n                lazy[2 * node] = lazy[node];\n                lazy[2 * node + 1] = lazy[node];\n            }\n            lazy[node] = 0;\n        }\n\n        if (start >= l && end <= r) {\n            return tree[node];\n        }\n\n        int mid = (start + end) / 2;\n        int p1 = queryRange(2 * node, start, mid, l, r);\n        int p2 = queryRange(2 * node + 1, mid + 1, end, l, r);\n        return p1 + p2;\n    }\n\npublic:\n    SegmentTree(int size) : n(size) {\n        tree.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n        build(1, 0, n - 1);\n    }\n\n    void update(int l, int r, int val) {\n        updateRange(1, 0, n - 1, l, r, val);\n    }\n\n    int getSum(int l, int r) {\n        return queryRange(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree segTree(n);\n\n    for (int i = 0; i < q; ++i) {\n        int type, s, t, x;\n        cin >> type >> s >> t;\n        if (type == 0) {\n            cin >> x;\n            segTree.update(s, t, x);\n        } else {\n            cout << segTree.getSum(s, t) << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:56:59"
  }
]